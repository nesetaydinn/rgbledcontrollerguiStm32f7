
LEDCONTROLLER.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c8  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00028228  080001d0  080001d0  000101d0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00003204  080283f8  080283f8  000383f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  0802b5fc  0802b5fc  00040cac  2**0
                  CONTENTS
  4 .ARM          00000008  0802b5fc  0802b5fc  0003b5fc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0802b604  0802b604  00040cac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0802b604  0802b604  0003b604  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  0802b608  0802b608  0003b608  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000cac  20000000  0802b60c  00040000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000d308  20000cac  0802c2b8  00040cac  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000dfb4  0802c2b8  0004dfb4  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00040cac  2**0
                  CONTENTS, READONLY
 12 .debug_info   00068246  00000000  00000000  00040cdc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000b493  00000000  00000000  000a8f22  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 000039d8  00000000  00000000  000b43b8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00003720  00000000  00000000  000b7d90  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  0003617f  00000000  00000000  000bb4b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   0003d337  00000000  00000000  000f162f  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    001142a1  00000000  00000000  0012e966  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  00242c07  2**0
                  CONTENTS, READONLY
 20 .debug_frame  0000fa98  00000000  00000000  00242c84  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001d0 <__do_global_dtors_aux>:
 80001d0:	b510      	push	{r4, lr}
 80001d2:	4c05      	ldr	r4, [pc, #20]	; (80001e8 <__do_global_dtors_aux+0x18>)
 80001d4:	7823      	ldrb	r3, [r4, #0]
 80001d6:	b933      	cbnz	r3, 80001e6 <__do_global_dtors_aux+0x16>
 80001d8:	4b04      	ldr	r3, [pc, #16]	; (80001ec <__do_global_dtors_aux+0x1c>)
 80001da:	b113      	cbz	r3, 80001e2 <__do_global_dtors_aux+0x12>
 80001dc:	4804      	ldr	r0, [pc, #16]	; (80001f0 <__do_global_dtors_aux+0x20>)
 80001de:	f3af 8000 	nop.w
 80001e2:	2301      	movs	r3, #1
 80001e4:	7023      	strb	r3, [r4, #0]
 80001e6:	bd10      	pop	{r4, pc}
 80001e8:	20000cac 	.word	0x20000cac
 80001ec:	00000000 	.word	0x00000000
 80001f0:	080283e0 	.word	0x080283e0

080001f4 <frame_dummy>:
 80001f4:	b508      	push	{r3, lr}
 80001f6:	4b03      	ldr	r3, [pc, #12]	; (8000204 <frame_dummy+0x10>)
 80001f8:	b11b      	cbz	r3, 8000202 <frame_dummy+0xe>
 80001fa:	4903      	ldr	r1, [pc, #12]	; (8000208 <frame_dummy+0x14>)
 80001fc:	4803      	ldr	r0, [pc, #12]	; (800020c <frame_dummy+0x18>)
 80001fe:	f3af 8000 	nop.w
 8000202:	bd08      	pop	{r3, pc}
 8000204:	00000000 	.word	0x00000000
 8000208:	20000cb0 	.word	0x20000cb0
 800020c:	080283e0 	.word	0x080283e0

08000210 <strcmp>:
 8000210:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000214:	f811 3b01 	ldrb.w	r3, [r1], #1
 8000218:	2a01      	cmp	r2, #1
 800021a:	bf28      	it	cs
 800021c:	429a      	cmpcs	r2, r3
 800021e:	d0f7      	beq.n	8000210 <strcmp>
 8000220:	1ad0      	subs	r0, r2, r3
 8000222:	4770      	bx	lr

08000224 <strlen>:
 8000224:	4603      	mov	r3, r0
 8000226:	f813 2b01 	ldrb.w	r2, [r3], #1
 800022a:	2a00      	cmp	r2, #0
 800022c:	d1fb      	bne.n	8000226 <strlen+0x2>
 800022e:	1a18      	subs	r0, r3, r0
 8000230:	3801      	subs	r0, #1
 8000232:	4770      	bx	lr
	...

08000240 <memchr>:
 8000240:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000244:	2a10      	cmp	r2, #16
 8000246:	db2b      	blt.n	80002a0 <memchr+0x60>
 8000248:	f010 0f07 	tst.w	r0, #7
 800024c:	d008      	beq.n	8000260 <memchr+0x20>
 800024e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000252:	3a01      	subs	r2, #1
 8000254:	428b      	cmp	r3, r1
 8000256:	d02d      	beq.n	80002b4 <memchr+0x74>
 8000258:	f010 0f07 	tst.w	r0, #7
 800025c:	b342      	cbz	r2, 80002b0 <memchr+0x70>
 800025e:	d1f6      	bne.n	800024e <memchr+0xe>
 8000260:	b4f0      	push	{r4, r5, r6, r7}
 8000262:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000266:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800026a:	f022 0407 	bic.w	r4, r2, #7
 800026e:	f07f 0700 	mvns.w	r7, #0
 8000272:	2300      	movs	r3, #0
 8000274:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000278:	3c08      	subs	r4, #8
 800027a:	ea85 0501 	eor.w	r5, r5, r1
 800027e:	ea86 0601 	eor.w	r6, r6, r1
 8000282:	fa85 f547 	uadd8	r5, r5, r7
 8000286:	faa3 f587 	sel	r5, r3, r7
 800028a:	fa86 f647 	uadd8	r6, r6, r7
 800028e:	faa5 f687 	sel	r6, r5, r7
 8000292:	b98e      	cbnz	r6, 80002b8 <memchr+0x78>
 8000294:	d1ee      	bne.n	8000274 <memchr+0x34>
 8000296:	bcf0      	pop	{r4, r5, r6, r7}
 8000298:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800029c:	f002 0207 	and.w	r2, r2, #7
 80002a0:	b132      	cbz	r2, 80002b0 <memchr+0x70>
 80002a2:	f810 3b01 	ldrb.w	r3, [r0], #1
 80002a6:	3a01      	subs	r2, #1
 80002a8:	ea83 0301 	eor.w	r3, r3, r1
 80002ac:	b113      	cbz	r3, 80002b4 <memchr+0x74>
 80002ae:	d1f8      	bne.n	80002a2 <memchr+0x62>
 80002b0:	2000      	movs	r0, #0
 80002b2:	4770      	bx	lr
 80002b4:	3801      	subs	r0, #1
 80002b6:	4770      	bx	lr
 80002b8:	2d00      	cmp	r5, #0
 80002ba:	bf06      	itte	eq
 80002bc:	4635      	moveq	r5, r6
 80002be:	3803      	subeq	r0, #3
 80002c0:	3807      	subne	r0, #7
 80002c2:	f015 0f01 	tst.w	r5, #1
 80002c6:	d107      	bne.n	80002d8 <memchr+0x98>
 80002c8:	3001      	adds	r0, #1
 80002ca:	f415 7f80 	tst.w	r5, #256	; 0x100
 80002ce:	bf02      	ittt	eq
 80002d0:	3001      	addeq	r0, #1
 80002d2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002d6:	3001      	addeq	r0, #1
 80002d8:	bcf0      	pop	{r4, r5, r6, r7}
 80002da:	3801      	subs	r0, #1
 80002dc:	4770      	bx	lr
 80002de:	bf00      	nop

080002e0 <__aeabi_uldivmod>:
 80002e0:	b953      	cbnz	r3, 80002f8 <__aeabi_uldivmod+0x18>
 80002e2:	b94a      	cbnz	r2, 80002f8 <__aeabi_uldivmod+0x18>
 80002e4:	2900      	cmp	r1, #0
 80002e6:	bf08      	it	eq
 80002e8:	2800      	cmpeq	r0, #0
 80002ea:	bf1c      	itt	ne
 80002ec:	f04f 31ff 	movne.w	r1, #4294967295
 80002f0:	f04f 30ff 	movne.w	r0, #4294967295
 80002f4:	f000 b972 	b.w	80005dc <__aeabi_idiv0>
 80002f8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002fc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000300:	f000 f806 	bl	8000310 <__udivmoddi4>
 8000304:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000308:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800030c:	b004      	add	sp, #16
 800030e:	4770      	bx	lr

08000310 <__udivmoddi4>:
 8000310:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000314:	9e08      	ldr	r6, [sp, #32]
 8000316:	4604      	mov	r4, r0
 8000318:	4688      	mov	r8, r1
 800031a:	2b00      	cmp	r3, #0
 800031c:	d14b      	bne.n	80003b6 <__udivmoddi4+0xa6>
 800031e:	428a      	cmp	r2, r1
 8000320:	4615      	mov	r5, r2
 8000322:	d967      	bls.n	80003f4 <__udivmoddi4+0xe4>
 8000324:	fab2 f282 	clz	r2, r2
 8000328:	b14a      	cbz	r2, 800033e <__udivmoddi4+0x2e>
 800032a:	f1c2 0720 	rsb	r7, r2, #32
 800032e:	fa01 f302 	lsl.w	r3, r1, r2
 8000332:	fa20 f707 	lsr.w	r7, r0, r7
 8000336:	4095      	lsls	r5, r2
 8000338:	ea47 0803 	orr.w	r8, r7, r3
 800033c:	4094      	lsls	r4, r2
 800033e:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000342:	0c23      	lsrs	r3, r4, #16
 8000344:	fbb8 f7fe 	udiv	r7, r8, lr
 8000348:	fa1f fc85 	uxth.w	ip, r5
 800034c:	fb0e 8817 	mls	r8, lr, r7, r8
 8000350:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000354:	fb07 f10c 	mul.w	r1, r7, ip
 8000358:	4299      	cmp	r1, r3
 800035a:	d909      	bls.n	8000370 <__udivmoddi4+0x60>
 800035c:	18eb      	adds	r3, r5, r3
 800035e:	f107 30ff 	add.w	r0, r7, #4294967295
 8000362:	f080 811b 	bcs.w	800059c <__udivmoddi4+0x28c>
 8000366:	4299      	cmp	r1, r3
 8000368:	f240 8118 	bls.w	800059c <__udivmoddi4+0x28c>
 800036c:	3f02      	subs	r7, #2
 800036e:	442b      	add	r3, r5
 8000370:	1a5b      	subs	r3, r3, r1
 8000372:	b2a4      	uxth	r4, r4
 8000374:	fbb3 f0fe 	udiv	r0, r3, lr
 8000378:	fb0e 3310 	mls	r3, lr, r0, r3
 800037c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000380:	fb00 fc0c 	mul.w	ip, r0, ip
 8000384:	45a4      	cmp	ip, r4
 8000386:	d909      	bls.n	800039c <__udivmoddi4+0x8c>
 8000388:	192c      	adds	r4, r5, r4
 800038a:	f100 33ff 	add.w	r3, r0, #4294967295
 800038e:	f080 8107 	bcs.w	80005a0 <__udivmoddi4+0x290>
 8000392:	45a4      	cmp	ip, r4
 8000394:	f240 8104 	bls.w	80005a0 <__udivmoddi4+0x290>
 8000398:	3802      	subs	r0, #2
 800039a:	442c      	add	r4, r5
 800039c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 80003a0:	eba4 040c 	sub.w	r4, r4, ip
 80003a4:	2700      	movs	r7, #0
 80003a6:	b11e      	cbz	r6, 80003b0 <__udivmoddi4+0xa0>
 80003a8:	40d4      	lsrs	r4, r2
 80003aa:	2300      	movs	r3, #0
 80003ac:	e9c6 4300 	strd	r4, r3, [r6]
 80003b0:	4639      	mov	r1, r7
 80003b2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003b6:	428b      	cmp	r3, r1
 80003b8:	d909      	bls.n	80003ce <__udivmoddi4+0xbe>
 80003ba:	2e00      	cmp	r6, #0
 80003bc:	f000 80eb 	beq.w	8000596 <__udivmoddi4+0x286>
 80003c0:	2700      	movs	r7, #0
 80003c2:	e9c6 0100 	strd	r0, r1, [r6]
 80003c6:	4638      	mov	r0, r7
 80003c8:	4639      	mov	r1, r7
 80003ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003ce:	fab3 f783 	clz	r7, r3
 80003d2:	2f00      	cmp	r7, #0
 80003d4:	d147      	bne.n	8000466 <__udivmoddi4+0x156>
 80003d6:	428b      	cmp	r3, r1
 80003d8:	d302      	bcc.n	80003e0 <__udivmoddi4+0xd0>
 80003da:	4282      	cmp	r2, r0
 80003dc:	f200 80fa 	bhi.w	80005d4 <__udivmoddi4+0x2c4>
 80003e0:	1a84      	subs	r4, r0, r2
 80003e2:	eb61 0303 	sbc.w	r3, r1, r3
 80003e6:	2001      	movs	r0, #1
 80003e8:	4698      	mov	r8, r3
 80003ea:	2e00      	cmp	r6, #0
 80003ec:	d0e0      	beq.n	80003b0 <__udivmoddi4+0xa0>
 80003ee:	e9c6 4800 	strd	r4, r8, [r6]
 80003f2:	e7dd      	b.n	80003b0 <__udivmoddi4+0xa0>
 80003f4:	b902      	cbnz	r2, 80003f8 <__udivmoddi4+0xe8>
 80003f6:	deff      	udf	#255	; 0xff
 80003f8:	fab2 f282 	clz	r2, r2
 80003fc:	2a00      	cmp	r2, #0
 80003fe:	f040 808f 	bne.w	8000520 <__udivmoddi4+0x210>
 8000402:	1b49      	subs	r1, r1, r5
 8000404:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000408:	fa1f f885 	uxth.w	r8, r5
 800040c:	2701      	movs	r7, #1
 800040e:	fbb1 fcfe 	udiv	ip, r1, lr
 8000412:	0c23      	lsrs	r3, r4, #16
 8000414:	fb0e 111c 	mls	r1, lr, ip, r1
 8000418:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800041c:	fb08 f10c 	mul.w	r1, r8, ip
 8000420:	4299      	cmp	r1, r3
 8000422:	d907      	bls.n	8000434 <__udivmoddi4+0x124>
 8000424:	18eb      	adds	r3, r5, r3
 8000426:	f10c 30ff 	add.w	r0, ip, #4294967295
 800042a:	d202      	bcs.n	8000432 <__udivmoddi4+0x122>
 800042c:	4299      	cmp	r1, r3
 800042e:	f200 80cd 	bhi.w	80005cc <__udivmoddi4+0x2bc>
 8000432:	4684      	mov	ip, r0
 8000434:	1a59      	subs	r1, r3, r1
 8000436:	b2a3      	uxth	r3, r4
 8000438:	fbb1 f0fe 	udiv	r0, r1, lr
 800043c:	fb0e 1410 	mls	r4, lr, r0, r1
 8000440:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 8000444:	fb08 f800 	mul.w	r8, r8, r0
 8000448:	45a0      	cmp	r8, r4
 800044a:	d907      	bls.n	800045c <__udivmoddi4+0x14c>
 800044c:	192c      	adds	r4, r5, r4
 800044e:	f100 33ff 	add.w	r3, r0, #4294967295
 8000452:	d202      	bcs.n	800045a <__udivmoddi4+0x14a>
 8000454:	45a0      	cmp	r8, r4
 8000456:	f200 80b6 	bhi.w	80005c6 <__udivmoddi4+0x2b6>
 800045a:	4618      	mov	r0, r3
 800045c:	eba4 0408 	sub.w	r4, r4, r8
 8000460:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000464:	e79f      	b.n	80003a6 <__udivmoddi4+0x96>
 8000466:	f1c7 0c20 	rsb	ip, r7, #32
 800046a:	40bb      	lsls	r3, r7
 800046c:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000470:	ea4e 0e03 	orr.w	lr, lr, r3
 8000474:	fa01 f407 	lsl.w	r4, r1, r7
 8000478:	fa20 f50c 	lsr.w	r5, r0, ip
 800047c:	fa21 f30c 	lsr.w	r3, r1, ip
 8000480:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000484:	4325      	orrs	r5, r4
 8000486:	fbb3 f9f8 	udiv	r9, r3, r8
 800048a:	0c2c      	lsrs	r4, r5, #16
 800048c:	fb08 3319 	mls	r3, r8, r9, r3
 8000490:	fa1f fa8e 	uxth.w	sl, lr
 8000494:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000498:	fb09 f40a 	mul.w	r4, r9, sl
 800049c:	429c      	cmp	r4, r3
 800049e:	fa02 f207 	lsl.w	r2, r2, r7
 80004a2:	fa00 f107 	lsl.w	r1, r0, r7
 80004a6:	d90b      	bls.n	80004c0 <__udivmoddi4+0x1b0>
 80004a8:	eb1e 0303 	adds.w	r3, lr, r3
 80004ac:	f109 30ff 	add.w	r0, r9, #4294967295
 80004b0:	f080 8087 	bcs.w	80005c2 <__udivmoddi4+0x2b2>
 80004b4:	429c      	cmp	r4, r3
 80004b6:	f240 8084 	bls.w	80005c2 <__udivmoddi4+0x2b2>
 80004ba:	f1a9 0902 	sub.w	r9, r9, #2
 80004be:	4473      	add	r3, lr
 80004c0:	1b1b      	subs	r3, r3, r4
 80004c2:	b2ad      	uxth	r5, r5
 80004c4:	fbb3 f0f8 	udiv	r0, r3, r8
 80004c8:	fb08 3310 	mls	r3, r8, r0, r3
 80004cc:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 80004d0:	fb00 fa0a 	mul.w	sl, r0, sl
 80004d4:	45a2      	cmp	sl, r4
 80004d6:	d908      	bls.n	80004ea <__udivmoddi4+0x1da>
 80004d8:	eb1e 0404 	adds.w	r4, lr, r4
 80004dc:	f100 33ff 	add.w	r3, r0, #4294967295
 80004e0:	d26b      	bcs.n	80005ba <__udivmoddi4+0x2aa>
 80004e2:	45a2      	cmp	sl, r4
 80004e4:	d969      	bls.n	80005ba <__udivmoddi4+0x2aa>
 80004e6:	3802      	subs	r0, #2
 80004e8:	4474      	add	r4, lr
 80004ea:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80004ee:	fba0 8902 	umull	r8, r9, r0, r2
 80004f2:	eba4 040a 	sub.w	r4, r4, sl
 80004f6:	454c      	cmp	r4, r9
 80004f8:	46c2      	mov	sl, r8
 80004fa:	464b      	mov	r3, r9
 80004fc:	d354      	bcc.n	80005a8 <__udivmoddi4+0x298>
 80004fe:	d051      	beq.n	80005a4 <__udivmoddi4+0x294>
 8000500:	2e00      	cmp	r6, #0
 8000502:	d069      	beq.n	80005d8 <__udivmoddi4+0x2c8>
 8000504:	ebb1 050a 	subs.w	r5, r1, sl
 8000508:	eb64 0403 	sbc.w	r4, r4, r3
 800050c:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000510:	40fd      	lsrs	r5, r7
 8000512:	40fc      	lsrs	r4, r7
 8000514:	ea4c 0505 	orr.w	r5, ip, r5
 8000518:	e9c6 5400 	strd	r5, r4, [r6]
 800051c:	2700      	movs	r7, #0
 800051e:	e747      	b.n	80003b0 <__udivmoddi4+0xa0>
 8000520:	f1c2 0320 	rsb	r3, r2, #32
 8000524:	fa20 f703 	lsr.w	r7, r0, r3
 8000528:	4095      	lsls	r5, r2
 800052a:	fa01 f002 	lsl.w	r0, r1, r2
 800052e:	fa21 f303 	lsr.w	r3, r1, r3
 8000532:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000536:	4338      	orrs	r0, r7
 8000538:	0c01      	lsrs	r1, r0, #16
 800053a:	fbb3 f7fe 	udiv	r7, r3, lr
 800053e:	fa1f f885 	uxth.w	r8, r5
 8000542:	fb0e 3317 	mls	r3, lr, r7, r3
 8000546:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800054a:	fb07 f308 	mul.w	r3, r7, r8
 800054e:	428b      	cmp	r3, r1
 8000550:	fa04 f402 	lsl.w	r4, r4, r2
 8000554:	d907      	bls.n	8000566 <__udivmoddi4+0x256>
 8000556:	1869      	adds	r1, r5, r1
 8000558:	f107 3cff 	add.w	ip, r7, #4294967295
 800055c:	d22f      	bcs.n	80005be <__udivmoddi4+0x2ae>
 800055e:	428b      	cmp	r3, r1
 8000560:	d92d      	bls.n	80005be <__udivmoddi4+0x2ae>
 8000562:	3f02      	subs	r7, #2
 8000564:	4429      	add	r1, r5
 8000566:	1acb      	subs	r3, r1, r3
 8000568:	b281      	uxth	r1, r0
 800056a:	fbb3 f0fe 	udiv	r0, r3, lr
 800056e:	fb0e 3310 	mls	r3, lr, r0, r3
 8000572:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000576:	fb00 f308 	mul.w	r3, r0, r8
 800057a:	428b      	cmp	r3, r1
 800057c:	d907      	bls.n	800058e <__udivmoddi4+0x27e>
 800057e:	1869      	adds	r1, r5, r1
 8000580:	f100 3cff 	add.w	ip, r0, #4294967295
 8000584:	d217      	bcs.n	80005b6 <__udivmoddi4+0x2a6>
 8000586:	428b      	cmp	r3, r1
 8000588:	d915      	bls.n	80005b6 <__udivmoddi4+0x2a6>
 800058a:	3802      	subs	r0, #2
 800058c:	4429      	add	r1, r5
 800058e:	1ac9      	subs	r1, r1, r3
 8000590:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000594:	e73b      	b.n	800040e <__udivmoddi4+0xfe>
 8000596:	4637      	mov	r7, r6
 8000598:	4630      	mov	r0, r6
 800059a:	e709      	b.n	80003b0 <__udivmoddi4+0xa0>
 800059c:	4607      	mov	r7, r0
 800059e:	e6e7      	b.n	8000370 <__udivmoddi4+0x60>
 80005a0:	4618      	mov	r0, r3
 80005a2:	e6fb      	b.n	800039c <__udivmoddi4+0x8c>
 80005a4:	4541      	cmp	r1, r8
 80005a6:	d2ab      	bcs.n	8000500 <__udivmoddi4+0x1f0>
 80005a8:	ebb8 0a02 	subs.w	sl, r8, r2
 80005ac:	eb69 020e 	sbc.w	r2, r9, lr
 80005b0:	3801      	subs	r0, #1
 80005b2:	4613      	mov	r3, r2
 80005b4:	e7a4      	b.n	8000500 <__udivmoddi4+0x1f0>
 80005b6:	4660      	mov	r0, ip
 80005b8:	e7e9      	b.n	800058e <__udivmoddi4+0x27e>
 80005ba:	4618      	mov	r0, r3
 80005bc:	e795      	b.n	80004ea <__udivmoddi4+0x1da>
 80005be:	4667      	mov	r7, ip
 80005c0:	e7d1      	b.n	8000566 <__udivmoddi4+0x256>
 80005c2:	4681      	mov	r9, r0
 80005c4:	e77c      	b.n	80004c0 <__udivmoddi4+0x1b0>
 80005c6:	3802      	subs	r0, #2
 80005c8:	442c      	add	r4, r5
 80005ca:	e747      	b.n	800045c <__udivmoddi4+0x14c>
 80005cc:	f1ac 0c02 	sub.w	ip, ip, #2
 80005d0:	442b      	add	r3, r5
 80005d2:	e72f      	b.n	8000434 <__udivmoddi4+0x124>
 80005d4:	4638      	mov	r0, r7
 80005d6:	e708      	b.n	80003ea <__udivmoddi4+0xda>
 80005d8:	4637      	mov	r7, r6
 80005da:	e6e9      	b.n	80003b0 <__udivmoddi4+0xa0>

080005dc <__aeabi_idiv0>:
 80005dc:	4770      	bx	lr
 80005de:	bf00      	nop

080005e0 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80005e0:	b580      	push	{r7, lr}
 80005e2:	af00      	add	r7, sp, #0
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80005e4:	2003      	movs	r0, #3
 80005e6:	f000 fb6a 	bl	8000cbe <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80005ea:	2000      	movs	r0, #0
 80005ec:	f009 fe4e 	bl	800a28c <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80005f0:	f009 f8cc 	bl	800978c <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 80005f4:	2300      	movs	r3, #0
}
 80005f6:	4618      	mov	r0, r3
 80005f8:	bd80      	pop	{r7, pc}
	...

080005fc <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80005fc:	b480      	push	{r7}
 80005fe:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8000600:	4b06      	ldr	r3, [pc, #24]	; (800061c <HAL_IncTick+0x20>)
 8000602:	781b      	ldrb	r3, [r3, #0]
 8000604:	461a      	mov	r2, r3
 8000606:	4b06      	ldr	r3, [pc, #24]	; (8000620 <HAL_IncTick+0x24>)
 8000608:	681b      	ldr	r3, [r3, #0]
 800060a:	4413      	add	r3, r2
 800060c:	4a04      	ldr	r2, [pc, #16]	; (8000620 <HAL_IncTick+0x24>)
 800060e:	6013      	str	r3, [r2, #0]
}
 8000610:	bf00      	nop
 8000612:	46bd      	mov	sp, r7
 8000614:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000618:	4770      	bx	lr
 800061a:	bf00      	nop
 800061c:	20000000 	.word	0x20000000
 8000620:	2000d38c 	.word	0x2000d38c

08000624 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8000624:	b480      	push	{r7}
 8000626:	af00      	add	r7, sp, #0
  return uwTick;
 8000628:	4b03      	ldr	r3, [pc, #12]	; (8000638 <HAL_GetTick+0x14>)
 800062a:	681b      	ldr	r3, [r3, #0]
}
 800062c:	4618      	mov	r0, r3
 800062e:	46bd      	mov	sp, r7
 8000630:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000634:	4770      	bx	lr
 8000636:	bf00      	nop
 8000638:	2000d38c 	.word	0x2000d38c

0800063c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 800063c:	b580      	push	{r7, lr}
 800063e:	b084      	sub	sp, #16
 8000640:	af00      	add	r7, sp, #0
 8000642:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8000644:	f7ff ffee 	bl	8000624 <HAL_GetTick>
 8000648:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 800064a:	687b      	ldr	r3, [r7, #4]
 800064c:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 800064e:	68fb      	ldr	r3, [r7, #12]
 8000650:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000654:	d005      	beq.n	8000662 <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8000656:	4b09      	ldr	r3, [pc, #36]	; (800067c <HAL_Delay+0x40>)
 8000658:	781b      	ldrb	r3, [r3, #0]
 800065a:	461a      	mov	r2, r3
 800065c:	68fb      	ldr	r3, [r7, #12]
 800065e:	4413      	add	r3, r2
 8000660:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000662:	bf00      	nop
 8000664:	f7ff ffde 	bl	8000624 <HAL_GetTick>
 8000668:	4602      	mov	r2, r0
 800066a:	68bb      	ldr	r3, [r7, #8]
 800066c:	1ad3      	subs	r3, r2, r3
 800066e:	68fa      	ldr	r2, [r7, #12]
 8000670:	429a      	cmp	r2, r3
 8000672:	d8f7      	bhi.n	8000664 <HAL_Delay+0x28>
  {
  }
}
 8000674:	bf00      	nop
 8000676:	3710      	adds	r7, #16
 8000678:	46bd      	mov	sp, r7
 800067a:	bd80      	pop	{r7, pc}
 800067c:	20000000 	.word	0x20000000

08000680 <HAL_ADC_Init>:
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8000680:	b580      	push	{r7, lr}
 8000682:	b084      	sub	sp, #16
 8000684:	af00      	add	r7, sp, #0
 8000686:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8000688:	2300      	movs	r3, #0
 800068a:	73fb      	strb	r3, [r7, #15]
  
  /* Check ADC handle */
  if(hadc == NULL)
 800068c:	687b      	ldr	r3, [r7, #4]
 800068e:	2b00      	cmp	r3, #0
 8000690:	d101      	bne.n	8000696 <HAL_ADC_Init+0x16>
  {
    return HAL_ERROR;
 8000692:	2301      	movs	r3, #1
 8000694:	e031      	b.n	80006fa <HAL_ADC_Init+0x7a>
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
  {
    assert_param(IS_ADC_EXT_TRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
  }

  if(hadc->State == HAL_ADC_STATE_RESET)
 8000696:	687b      	ldr	r3, [r7, #4]
 8000698:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800069a:	2b00      	cmp	r3, #0
 800069c:	d109      	bne.n	80006b2 <HAL_ADC_Init+0x32>

    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 800069e:	6878      	ldr	r0, [r7, #4]
 80006a0:	f009 f898 	bl	80097d4 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */

    /* Initialize ADC error code */
    ADC_CLEAR_ERRORCODE(hadc);
 80006a4:	687b      	ldr	r3, [r7, #4]
 80006a6:	2200      	movs	r2, #0
 80006a8:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Allocate lock resource and initialize it */
    hadc->Lock = HAL_UNLOCKED;
 80006aa:	687b      	ldr	r3, [r7, #4]
 80006ac:	2200      	movs	r2, #0
 80006ae:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  }
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed.                                                     */
  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 80006b2:	687b      	ldr	r3, [r7, #4]
 80006b4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80006b6:	f003 0310 	and.w	r3, r3, #16
 80006ba:	2b00      	cmp	r3, #0
 80006bc:	d116      	bne.n	80006ec <HAL_ADC_Init+0x6c>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80006be:	687b      	ldr	r3, [r7, #4]
 80006c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80006c2:	4b10      	ldr	r3, [pc, #64]	; (8000704 <HAL_ADC_Init+0x84>)
 80006c4:	4013      	ands	r3, r2
 80006c6:	f043 0202 	orr.w	r2, r3, #2
 80006ca:	687b      	ldr	r3, [r7, #4]
 80006cc:	641a      	str	r2, [r3, #64]	; 0x40
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);
    
    /* Set ADC parameters */
    ADC_Init(hadc);
 80006ce:	6878      	ldr	r0, [r7, #4]
 80006d0:	f000 f94e 	bl	8000970 <ADC_Init>
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 80006d4:	687b      	ldr	r3, [r7, #4]
 80006d6:	2200      	movs	r2, #0
 80006d8:	645a      	str	r2, [r3, #68]	; 0x44
    
    /* Set the ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80006da:	687b      	ldr	r3, [r7, #4]
 80006dc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80006de:	f023 0303 	bic.w	r3, r3, #3
 80006e2:	f043 0201 	orr.w	r2, r3, #1
 80006e6:	687b      	ldr	r3, [r7, #4]
 80006e8:	641a      	str	r2, [r3, #64]	; 0x40
 80006ea:	e001      	b.n	80006f0 <HAL_ADC_Init+0x70>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    tmp_hal_status = HAL_ERROR;
 80006ec:	2301      	movs	r3, #1
 80006ee:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Release Lock */
  __HAL_UNLOCK(hadc);
 80006f0:	687b      	ldr	r3, [r7, #4]
 80006f2:	2200      	movs	r2, #0
 80006f4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Return function status */
  return tmp_hal_status;
 80006f8:	7bfb      	ldrb	r3, [r7, #15]
}
 80006fa:	4618      	mov	r0, r3
 80006fc:	3710      	adds	r7, #16
 80006fe:	46bd      	mov	sp, r7
 8000700:	bd80      	pop	{r7, pc}
 8000702:	bf00      	nop
 8000704:	ffffeefd 	.word	0xffffeefd

08000708 <HAL_ADC_ConfigChannel>:
  *         the configuration information for the specified ADC.
  * @param  sConfig ADC configuration structure. 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8000708:	b480      	push	{r7}
 800070a:	b085      	sub	sp, #20
 800070c:	af00      	add	r7, sp, #0
 800070e:	6078      	str	r0, [r7, #4]
 8000710:	6039      	str	r1, [r7, #0]
  __IO uint32_t counter = 0;
 8000712:	2300      	movs	r3, #0
 8000714:	60fb      	str	r3, [r7, #12]
  assert_param(IS_ADC_CHANNEL(sConfig->Channel));
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 8000716:	687b      	ldr	r3, [r7, #4]
 8000718:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800071c:	2b01      	cmp	r3, #1
 800071e:	d101      	bne.n	8000724 <HAL_ADC_ConfigChannel+0x1c>
 8000720:	2302      	movs	r3, #2
 8000722:	e115      	b.n	8000950 <HAL_ADC_ConfigChannel+0x248>
 8000724:	687b      	ldr	r3, [r7, #4]
 8000726:	2201      	movs	r2, #1
 8000728:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
			
	/* if ADC_Channel_10 ... ADC_Channel_18 is selected */
	if (sConfig->Channel > ADC_CHANNEL_9)
 800072c:	683b      	ldr	r3, [r7, #0]
 800072e:	681b      	ldr	r3, [r3, #0]
 8000730:	2b09      	cmp	r3, #9
 8000732:	d935      	bls.n	80007a0 <HAL_ADC_ConfigChannel+0x98>
	{
		/* Clear the old sample time */
		hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
 8000734:	687b      	ldr	r3, [r7, #4]
 8000736:	681b      	ldr	r3, [r3, #0]
 8000738:	68d9      	ldr	r1, [r3, #12]
 800073a:	683b      	ldr	r3, [r7, #0]
 800073c:	681b      	ldr	r3, [r3, #0]
 800073e:	b29b      	uxth	r3, r3
 8000740:	461a      	mov	r2, r3
 8000742:	4613      	mov	r3, r2
 8000744:	005b      	lsls	r3, r3, #1
 8000746:	4413      	add	r3, r2
 8000748:	3b1e      	subs	r3, #30
 800074a:	2207      	movs	r2, #7
 800074c:	fa02 f303 	lsl.w	r3, r2, r3
 8000750:	43da      	mvns	r2, r3
 8000752:	687b      	ldr	r3, [r7, #4]
 8000754:	681b      	ldr	r3, [r3, #0]
 8000756:	400a      	ands	r2, r1
 8000758:	60da      	str	r2, [r3, #12]

		if (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 800075a:	683b      	ldr	r3, [r7, #0]
 800075c:	681b      	ldr	r3, [r3, #0]
 800075e:	4a7f      	ldr	r2, [pc, #508]	; (800095c <HAL_ADC_ConfigChannel+0x254>)
 8000760:	4293      	cmp	r3, r2
 8000762:	d10a      	bne.n	800077a <HAL_ADC_ConfigChannel+0x72>
		{
			/* Set the new sample time */
			hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, ADC_CHANNEL_18);
 8000764:	687b      	ldr	r3, [r7, #4]
 8000766:	681b      	ldr	r3, [r3, #0]
 8000768:	68d9      	ldr	r1, [r3, #12]
 800076a:	683b      	ldr	r3, [r7, #0]
 800076c:	689b      	ldr	r3, [r3, #8]
 800076e:	061a      	lsls	r2, r3, #24
 8000770:	687b      	ldr	r3, [r7, #4]
 8000772:	681b      	ldr	r3, [r3, #0]
 8000774:	430a      	orrs	r2, r1
 8000776:	60da      	str	r2, [r3, #12]
 8000778:	e035      	b.n	80007e6 <HAL_ADC_ConfigChannel+0xde>
		}
	  else
	  {	
		  /* Set the new sample time */
		  hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
 800077a:	687b      	ldr	r3, [r7, #4]
 800077c:	681b      	ldr	r3, [r3, #0]
 800077e:	68d9      	ldr	r1, [r3, #12]
 8000780:	683b      	ldr	r3, [r7, #0]
 8000782:	689a      	ldr	r2, [r3, #8]
 8000784:	683b      	ldr	r3, [r7, #0]
 8000786:	681b      	ldr	r3, [r3, #0]
 8000788:	b29b      	uxth	r3, r3
 800078a:	4618      	mov	r0, r3
 800078c:	4603      	mov	r3, r0
 800078e:	005b      	lsls	r3, r3, #1
 8000790:	4403      	add	r3, r0
 8000792:	3b1e      	subs	r3, #30
 8000794:	409a      	lsls	r2, r3
 8000796:	687b      	ldr	r3, [r7, #4]
 8000798:	681b      	ldr	r3, [r3, #0]
 800079a:	430a      	orrs	r2, r1
 800079c:	60da      	str	r2, [r3, #12]
 800079e:	e022      	b.n	80007e6 <HAL_ADC_ConfigChannel+0xde>
	  }
  }
  else /* ADC_Channel include in ADC_Channel_[0..9] */
  {
    /* Clear the old sample time */
    hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
 80007a0:	687b      	ldr	r3, [r7, #4]
 80007a2:	681b      	ldr	r3, [r3, #0]
 80007a4:	6919      	ldr	r1, [r3, #16]
 80007a6:	683b      	ldr	r3, [r7, #0]
 80007a8:	681b      	ldr	r3, [r3, #0]
 80007aa:	b29b      	uxth	r3, r3
 80007ac:	461a      	mov	r2, r3
 80007ae:	4613      	mov	r3, r2
 80007b0:	005b      	lsls	r3, r3, #1
 80007b2:	4413      	add	r3, r2
 80007b4:	2207      	movs	r2, #7
 80007b6:	fa02 f303 	lsl.w	r3, r2, r3
 80007ba:	43da      	mvns	r2, r3
 80007bc:	687b      	ldr	r3, [r7, #4]
 80007be:	681b      	ldr	r3, [r3, #0]
 80007c0:	400a      	ands	r2, r1
 80007c2:	611a      	str	r2, [r3, #16]
    
    /* Set the new sample time */
    hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
 80007c4:	687b      	ldr	r3, [r7, #4]
 80007c6:	681b      	ldr	r3, [r3, #0]
 80007c8:	6919      	ldr	r1, [r3, #16]
 80007ca:	683b      	ldr	r3, [r7, #0]
 80007cc:	689a      	ldr	r2, [r3, #8]
 80007ce:	683b      	ldr	r3, [r7, #0]
 80007d0:	681b      	ldr	r3, [r3, #0]
 80007d2:	b29b      	uxth	r3, r3
 80007d4:	4618      	mov	r0, r3
 80007d6:	4603      	mov	r3, r0
 80007d8:	005b      	lsls	r3, r3, #1
 80007da:	4403      	add	r3, r0
 80007dc:	409a      	lsls	r2, r3
 80007de:	687b      	ldr	r3, [r7, #4]
 80007e0:	681b      	ldr	r3, [r3, #0]
 80007e2:	430a      	orrs	r2, r1
 80007e4:	611a      	str	r2, [r3, #16]
  }
  
  /* For Rank 1 to 6 */
  if (sConfig->Rank < 7)
 80007e6:	683b      	ldr	r3, [r7, #0]
 80007e8:	685b      	ldr	r3, [r3, #4]
 80007ea:	2b06      	cmp	r3, #6
 80007ec:	d824      	bhi.n	8000838 <HAL_ADC_ConfigChannel+0x130>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
 80007ee:	687b      	ldr	r3, [r7, #4]
 80007f0:	681b      	ldr	r3, [r3, #0]
 80007f2:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80007f4:	683b      	ldr	r3, [r7, #0]
 80007f6:	685a      	ldr	r2, [r3, #4]
 80007f8:	4613      	mov	r3, r2
 80007fa:	009b      	lsls	r3, r3, #2
 80007fc:	4413      	add	r3, r2
 80007fe:	3b05      	subs	r3, #5
 8000800:	221f      	movs	r2, #31
 8000802:	fa02 f303 	lsl.w	r3, r2, r3
 8000806:	43da      	mvns	r2, r3
 8000808:	687b      	ldr	r3, [r7, #4]
 800080a:	681b      	ldr	r3, [r3, #0]
 800080c:	400a      	ands	r2, r1
 800080e:	635a      	str	r2, [r3, #52]	; 0x34
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
 8000810:	687b      	ldr	r3, [r7, #4]
 8000812:	681b      	ldr	r3, [r3, #0]
 8000814:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8000816:	683b      	ldr	r3, [r7, #0]
 8000818:	681b      	ldr	r3, [r3, #0]
 800081a:	b29b      	uxth	r3, r3
 800081c:	4618      	mov	r0, r3
 800081e:	683b      	ldr	r3, [r7, #0]
 8000820:	685a      	ldr	r2, [r3, #4]
 8000822:	4613      	mov	r3, r2
 8000824:	009b      	lsls	r3, r3, #2
 8000826:	4413      	add	r3, r2
 8000828:	3b05      	subs	r3, #5
 800082a:	fa00 f203 	lsl.w	r2, r0, r3
 800082e:	687b      	ldr	r3, [r7, #4]
 8000830:	681b      	ldr	r3, [r3, #0]
 8000832:	430a      	orrs	r2, r1
 8000834:	635a      	str	r2, [r3, #52]	; 0x34
 8000836:	e04c      	b.n	80008d2 <HAL_ADC_ConfigChannel+0x1ca>
  }
  /* For Rank 7 to 12 */
  else if (sConfig->Rank < 13)
 8000838:	683b      	ldr	r3, [r7, #0]
 800083a:	685b      	ldr	r3, [r3, #4]
 800083c:	2b0c      	cmp	r3, #12
 800083e:	d824      	bhi.n	800088a <HAL_ADC_ConfigChannel+0x182>
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
 8000840:	687b      	ldr	r3, [r7, #4]
 8000842:	681b      	ldr	r3, [r3, #0]
 8000844:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8000846:	683b      	ldr	r3, [r7, #0]
 8000848:	685a      	ldr	r2, [r3, #4]
 800084a:	4613      	mov	r3, r2
 800084c:	009b      	lsls	r3, r3, #2
 800084e:	4413      	add	r3, r2
 8000850:	3b23      	subs	r3, #35	; 0x23
 8000852:	221f      	movs	r2, #31
 8000854:	fa02 f303 	lsl.w	r3, r2, r3
 8000858:	43da      	mvns	r2, r3
 800085a:	687b      	ldr	r3, [r7, #4]
 800085c:	681b      	ldr	r3, [r3, #0]
 800085e:	400a      	ands	r2, r1
 8000860:	631a      	str	r2, [r3, #48]	; 0x30
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
 8000862:	687b      	ldr	r3, [r7, #4]
 8000864:	681b      	ldr	r3, [r3, #0]
 8000866:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8000868:	683b      	ldr	r3, [r7, #0]
 800086a:	681b      	ldr	r3, [r3, #0]
 800086c:	b29b      	uxth	r3, r3
 800086e:	4618      	mov	r0, r3
 8000870:	683b      	ldr	r3, [r7, #0]
 8000872:	685a      	ldr	r2, [r3, #4]
 8000874:	4613      	mov	r3, r2
 8000876:	009b      	lsls	r3, r3, #2
 8000878:	4413      	add	r3, r2
 800087a:	3b23      	subs	r3, #35	; 0x23
 800087c:	fa00 f203 	lsl.w	r2, r0, r3
 8000880:	687b      	ldr	r3, [r7, #4]
 8000882:	681b      	ldr	r3, [r3, #0]
 8000884:	430a      	orrs	r2, r1
 8000886:	631a      	str	r2, [r3, #48]	; 0x30
 8000888:	e023      	b.n	80008d2 <HAL_ADC_ConfigChannel+0x1ca>
  }
  /* For Rank 13 to 16 */
  else
  {
    /* Clear the old SQx bits for the selected rank */
    hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
 800088a:	687b      	ldr	r3, [r7, #4]
 800088c:	681b      	ldr	r3, [r3, #0]
 800088e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8000890:	683b      	ldr	r3, [r7, #0]
 8000892:	685a      	ldr	r2, [r3, #4]
 8000894:	4613      	mov	r3, r2
 8000896:	009b      	lsls	r3, r3, #2
 8000898:	4413      	add	r3, r2
 800089a:	3b41      	subs	r3, #65	; 0x41
 800089c:	221f      	movs	r2, #31
 800089e:	fa02 f303 	lsl.w	r3, r2, r3
 80008a2:	43da      	mvns	r2, r3
 80008a4:	687b      	ldr	r3, [r7, #4]
 80008a6:	681b      	ldr	r3, [r3, #0]
 80008a8:	400a      	ands	r2, r1
 80008aa:	62da      	str	r2, [r3, #44]	; 0x2c
    
    /* Set the SQx bits for the selected rank */
    hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
 80008ac:	687b      	ldr	r3, [r7, #4]
 80008ae:	681b      	ldr	r3, [r3, #0]
 80008b0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 80008b2:	683b      	ldr	r3, [r7, #0]
 80008b4:	681b      	ldr	r3, [r3, #0]
 80008b6:	b29b      	uxth	r3, r3
 80008b8:	4618      	mov	r0, r3
 80008ba:	683b      	ldr	r3, [r7, #0]
 80008bc:	685a      	ldr	r2, [r3, #4]
 80008be:	4613      	mov	r3, r2
 80008c0:	009b      	lsls	r3, r3, #2
 80008c2:	4413      	add	r3, r2
 80008c4:	3b41      	subs	r3, #65	; 0x41
 80008c6:	fa00 f203 	lsl.w	r2, r0, r3
 80008ca:	687b      	ldr	r3, [r7, #4]
 80008cc:	681b      	ldr	r3, [r3, #0]
 80008ce:	430a      	orrs	r2, r1
 80008d0:	62da      	str	r2, [r3, #44]	; 0x2c
  }
  
  /* if ADC1 Channel_18 is selected enable VBAT Channel */
  if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
 80008d2:	687b      	ldr	r3, [r7, #4]
 80008d4:	681b      	ldr	r3, [r3, #0]
 80008d6:	4a22      	ldr	r2, [pc, #136]	; (8000960 <HAL_ADC_ConfigChannel+0x258>)
 80008d8:	4293      	cmp	r3, r2
 80008da:	d109      	bne.n	80008f0 <HAL_ADC_ConfigChannel+0x1e8>
 80008dc:	683b      	ldr	r3, [r7, #0]
 80008de:	681b      	ldr	r3, [r3, #0]
 80008e0:	2b12      	cmp	r3, #18
 80008e2:	d105      	bne.n	80008f0 <HAL_ADC_ConfigChannel+0x1e8>
  {
    /* Enable the VBAT channel*/
    ADC->CCR |= ADC_CCR_VBATE;
 80008e4:	4b1f      	ldr	r3, [pc, #124]	; (8000964 <HAL_ADC_ConfigChannel+0x25c>)
 80008e6:	685b      	ldr	r3, [r3, #4]
 80008e8:	4a1e      	ldr	r2, [pc, #120]	; (8000964 <HAL_ADC_ConfigChannel+0x25c>)
 80008ea:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 80008ee:	6053      	str	r3, [r2, #4]
  }
  
  /* if ADC1 Channel_18 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
  if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
 80008f0:	687b      	ldr	r3, [r7, #4]
 80008f2:	681b      	ldr	r3, [r3, #0]
 80008f4:	4a1a      	ldr	r2, [pc, #104]	; (8000960 <HAL_ADC_ConfigChannel+0x258>)
 80008f6:	4293      	cmp	r3, r2
 80008f8:	d125      	bne.n	8000946 <HAL_ADC_ConfigChannel+0x23e>
 80008fa:	683b      	ldr	r3, [r7, #0]
 80008fc:	681b      	ldr	r3, [r3, #0]
 80008fe:	4a17      	ldr	r2, [pc, #92]	; (800095c <HAL_ADC_ConfigChannel+0x254>)
 8000900:	4293      	cmp	r3, r2
 8000902:	d003      	beq.n	800090c <HAL_ADC_ConfigChannel+0x204>
 8000904:	683b      	ldr	r3, [r7, #0]
 8000906:	681b      	ldr	r3, [r3, #0]
 8000908:	2b11      	cmp	r3, #17
 800090a:	d11c      	bne.n	8000946 <HAL_ADC_ConfigChannel+0x23e>
  {
    /* Enable the TSVREFE channel*/
    ADC->CCR |= ADC_CCR_TSVREFE;
 800090c:	4b15      	ldr	r3, [pc, #84]	; (8000964 <HAL_ADC_ConfigChannel+0x25c>)
 800090e:	685b      	ldr	r3, [r3, #4]
 8000910:	4a14      	ldr	r2, [pc, #80]	; (8000964 <HAL_ADC_ConfigChannel+0x25c>)
 8000912:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8000916:	6053      	str	r3, [r2, #4]

    if(sConfig->Channel == ADC_CHANNEL_TEMPSENSOR)
 8000918:	683b      	ldr	r3, [r7, #0]
 800091a:	681b      	ldr	r3, [r3, #0]
 800091c:	4a0f      	ldr	r2, [pc, #60]	; (800095c <HAL_ADC_ConfigChannel+0x254>)
 800091e:	4293      	cmp	r3, r2
 8000920:	d111      	bne.n	8000946 <HAL_ADC_ConfigChannel+0x23e>
    {
      /* Delay for temperature sensor stabilization time */
      /* Compute number of CPU cycles to wait for */
      counter = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000));
 8000922:	4b11      	ldr	r3, [pc, #68]	; (8000968 <HAL_ADC_ConfigChannel+0x260>)
 8000924:	681b      	ldr	r3, [r3, #0]
 8000926:	4a11      	ldr	r2, [pc, #68]	; (800096c <HAL_ADC_ConfigChannel+0x264>)
 8000928:	fba2 2303 	umull	r2, r3, r2, r3
 800092c:	0c9a      	lsrs	r2, r3, #18
 800092e:	4613      	mov	r3, r2
 8000930:	009b      	lsls	r3, r3, #2
 8000932:	4413      	add	r3, r2
 8000934:	005b      	lsls	r3, r3, #1
 8000936:	60fb      	str	r3, [r7, #12]
      while(counter != 0)
 8000938:	e002      	b.n	8000940 <HAL_ADC_ConfigChannel+0x238>
      {
        counter--;
 800093a:	68fb      	ldr	r3, [r7, #12]
 800093c:	3b01      	subs	r3, #1
 800093e:	60fb      	str	r3, [r7, #12]
      while(counter != 0)
 8000940:	68fb      	ldr	r3, [r7, #12]
 8000942:	2b00      	cmp	r3, #0
 8000944:	d1f9      	bne.n	800093a <HAL_ADC_ConfigChannel+0x232>
      }
    }
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8000946:	687b      	ldr	r3, [r7, #4]
 8000948:	2200      	movs	r2, #0
 800094a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
  
  /* Return function status */
  return HAL_OK;
 800094e:	2300      	movs	r3, #0
}
 8000950:	4618      	mov	r0, r3
 8000952:	3714      	adds	r7, #20
 8000954:	46bd      	mov	sp, r7
 8000956:	f85d 7b04 	ldr.w	r7, [sp], #4
 800095a:	4770      	bx	lr
 800095c:	10000012 	.word	0x10000012
 8000960:	40012000 	.word	0x40012000
 8000964:	40012300 	.word	0x40012300
 8000968:	20000004 	.word	0x20000004
 800096c:	431bde83 	.word	0x431bde83

08000970 <ADC_Init>:
  * @param  hadc pointer to a ADC_HandleTypeDef structure that contains
  *         the configuration information for the specified ADC.  
  * @retval None
  */
static void ADC_Init(ADC_HandleTypeDef* hadc)
{
 8000970:	b480      	push	{r7}
 8000972:	b083      	sub	sp, #12
 8000974:	af00      	add	r7, sp, #0
 8000976:	6078      	str	r0, [r7, #4]
  /* Set ADC parameters */
  /* Set the ADC clock prescaler */
  ADC->CCR &= ~(ADC_CCR_ADCPRE);
 8000978:	4b78      	ldr	r3, [pc, #480]	; (8000b5c <ADC_Init+0x1ec>)
 800097a:	685b      	ldr	r3, [r3, #4]
 800097c:	4a77      	ldr	r2, [pc, #476]	; (8000b5c <ADC_Init+0x1ec>)
 800097e:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8000982:	6053      	str	r3, [r2, #4]
  ADC->CCR |=  hadc->Init.ClockPrescaler;
 8000984:	4b75      	ldr	r3, [pc, #468]	; (8000b5c <ADC_Init+0x1ec>)
 8000986:	685a      	ldr	r2, [r3, #4]
 8000988:	687b      	ldr	r3, [r7, #4]
 800098a:	685b      	ldr	r3, [r3, #4]
 800098c:	4973      	ldr	r1, [pc, #460]	; (8000b5c <ADC_Init+0x1ec>)
 800098e:	4313      	orrs	r3, r2
 8000990:	604b      	str	r3, [r1, #4]
  
  /* Set ADC scan mode */
  hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
 8000992:	687b      	ldr	r3, [r7, #4]
 8000994:	681b      	ldr	r3, [r3, #0]
 8000996:	685a      	ldr	r2, [r3, #4]
 8000998:	687b      	ldr	r3, [r7, #4]
 800099a:	681b      	ldr	r3, [r3, #0]
 800099c:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80009a0:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
 80009a2:	687b      	ldr	r3, [r7, #4]
 80009a4:	681b      	ldr	r3, [r3, #0]
 80009a6:	6859      	ldr	r1, [r3, #4]
 80009a8:	687b      	ldr	r3, [r7, #4]
 80009aa:	691b      	ldr	r3, [r3, #16]
 80009ac:	021a      	lsls	r2, r3, #8
 80009ae:	687b      	ldr	r3, [r7, #4]
 80009b0:	681b      	ldr	r3, [r3, #0]
 80009b2:	430a      	orrs	r2, r1
 80009b4:	605a      	str	r2, [r3, #4]
  
  /* Set ADC resolution */
  hadc->Instance->CR1 &= ~(ADC_CR1_RES);
 80009b6:	687b      	ldr	r3, [r7, #4]
 80009b8:	681b      	ldr	r3, [r3, #0]
 80009ba:	685a      	ldr	r2, [r3, #4]
 80009bc:	687b      	ldr	r3, [r7, #4]
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	f022 7240 	bic.w	r2, r2, #50331648	; 0x3000000
 80009c4:	605a      	str	r2, [r3, #4]
  hadc->Instance->CR1 |=  hadc->Init.Resolution;
 80009c6:	687b      	ldr	r3, [r7, #4]
 80009c8:	681b      	ldr	r3, [r3, #0]
 80009ca:	6859      	ldr	r1, [r3, #4]
 80009cc:	687b      	ldr	r3, [r7, #4]
 80009ce:	689a      	ldr	r2, [r3, #8]
 80009d0:	687b      	ldr	r3, [r7, #4]
 80009d2:	681b      	ldr	r3, [r3, #0]
 80009d4:	430a      	orrs	r2, r1
 80009d6:	605a      	str	r2, [r3, #4]
  
  /* Set ADC data alignment */
  hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
 80009d8:	687b      	ldr	r3, [r7, #4]
 80009da:	681b      	ldr	r3, [r3, #0]
 80009dc:	689a      	ldr	r2, [r3, #8]
 80009de:	687b      	ldr	r3, [r7, #4]
 80009e0:	681b      	ldr	r3, [r3, #0]
 80009e2:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80009e6:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= hadc->Init.DataAlign;
 80009e8:	687b      	ldr	r3, [r7, #4]
 80009ea:	681b      	ldr	r3, [r3, #0]
 80009ec:	6899      	ldr	r1, [r3, #8]
 80009ee:	687b      	ldr	r3, [r7, #4]
 80009f0:	68da      	ldr	r2, [r3, #12]
 80009f2:	687b      	ldr	r3, [r7, #4]
 80009f4:	681b      	ldr	r3, [r3, #0]
 80009f6:	430a      	orrs	r2, r1
 80009f8:	609a      	str	r2, [r3, #8]
  /* Enable external trigger if trigger selection is different of software  */
  /* start.                                                                 */
  /* Note: This configuration keeps the hardware feature of parameter       */
  /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
  /*       software start.                                                  */
  if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 80009fa:	687b      	ldr	r3, [r7, #4]
 80009fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80009fe:	4a58      	ldr	r2, [pc, #352]	; (8000b60 <ADC_Init+0x1f0>)
 8000a00:	4293      	cmp	r3, r2
 8000a02:	d022      	beq.n	8000a4a <ADC_Init+0xda>
  {
    /* Select external trigger to start conversion */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8000a04:	687b      	ldr	r3, [r7, #4]
 8000a06:	681b      	ldr	r3, [r3, #0]
 8000a08:	689a      	ldr	r2, [r3, #8]
 8000a0a:	687b      	ldr	r3, [r7, #4]
 8000a0c:	681b      	ldr	r3, [r3, #0]
 8000a0e:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8000a12:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
 8000a14:	687b      	ldr	r3, [r7, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	6899      	ldr	r1, [r3, #8]
 8000a1a:	687b      	ldr	r3, [r7, #4]
 8000a1c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000a1e:	687b      	ldr	r3, [r7, #4]
 8000a20:	681b      	ldr	r3, [r3, #0]
 8000a22:	430a      	orrs	r2, r1
 8000a24:	609a      	str	r2, [r3, #8]
    
    /* Select external trigger polarity */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8000a26:	687b      	ldr	r3, [r7, #4]
 8000a28:	681b      	ldr	r3, [r3, #0]
 8000a2a:	689a      	ldr	r2, [r3, #8]
 8000a2c:	687b      	ldr	r3, [r7, #4]
 8000a2e:	681b      	ldr	r3, [r3, #0]
 8000a30:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8000a34:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
 8000a36:	687b      	ldr	r3, [r7, #4]
 8000a38:	681b      	ldr	r3, [r3, #0]
 8000a3a:	6899      	ldr	r1, [r3, #8]
 8000a3c:	687b      	ldr	r3, [r7, #4]
 8000a3e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000a40:	687b      	ldr	r3, [r7, #4]
 8000a42:	681b      	ldr	r3, [r3, #0]
 8000a44:	430a      	orrs	r2, r1
 8000a46:	609a      	str	r2, [r3, #8]
 8000a48:	e00f      	b.n	8000a6a <ADC_Init+0xfa>
  }
  else
  {
    /* Reset the external trigger */
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
 8000a4a:	687b      	ldr	r3, [r7, #4]
 8000a4c:	681b      	ldr	r3, [r3, #0]
 8000a4e:	689a      	ldr	r2, [r3, #8]
 8000a50:	687b      	ldr	r3, [r7, #4]
 8000a52:	681b      	ldr	r3, [r3, #0]
 8000a54:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8000a58:	609a      	str	r2, [r3, #8]
    hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
 8000a5a:	687b      	ldr	r3, [r7, #4]
 8000a5c:	681b      	ldr	r3, [r3, #0]
 8000a5e:	689a      	ldr	r2, [r3, #8]
 8000a60:	687b      	ldr	r3, [r7, #4]
 8000a62:	681b      	ldr	r3, [r3, #0]
 8000a64:	f022 5240 	bic.w	r2, r2, #805306368	; 0x30000000
 8000a68:	609a      	str	r2, [r3, #8]
  }
  
  /* Enable or disable ADC continuous conversion mode */
  hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
 8000a6a:	687b      	ldr	r3, [r7, #4]
 8000a6c:	681b      	ldr	r3, [r3, #0]
 8000a6e:	689a      	ldr	r2, [r3, #8]
 8000a70:	687b      	ldr	r3, [r7, #4]
 8000a72:	681b      	ldr	r3, [r3, #0]
 8000a74:	f022 0202 	bic.w	r2, r2, #2
 8000a78:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode);
 8000a7a:	687b      	ldr	r3, [r7, #4]
 8000a7c:	681b      	ldr	r3, [r3, #0]
 8000a7e:	6899      	ldr	r1, [r3, #8]
 8000a80:	687b      	ldr	r3, [r7, #4]
 8000a82:	699b      	ldr	r3, [r3, #24]
 8000a84:	005a      	lsls	r2, r3, #1
 8000a86:	687b      	ldr	r3, [r7, #4]
 8000a88:	681b      	ldr	r3, [r3, #0]
 8000a8a:	430a      	orrs	r2, r1
 8000a8c:	609a      	str	r2, [r3, #8]
  
  if(hadc->Init.DiscontinuousConvMode != DISABLE)
 8000a8e:	687b      	ldr	r3, [r7, #4]
 8000a90:	f893 3020 	ldrb.w	r3, [r3, #32]
 8000a94:	2b00      	cmp	r3, #0
 8000a96:	d01b      	beq.n	8000ad0 <ADC_Init+0x160>
  {
    assert_param(IS_ADC_REGULAR_DISC_NUMBER(hadc->Init.NbrOfDiscConversion));
  
    /* Enable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
 8000a98:	687b      	ldr	r3, [r7, #4]
 8000a9a:	681b      	ldr	r3, [r3, #0]
 8000a9c:	685a      	ldr	r2, [r3, #4]
 8000a9e:	687b      	ldr	r3, [r7, #4]
 8000aa0:	681b      	ldr	r3, [r3, #0]
 8000aa2:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8000aa6:	605a      	str	r2, [r3, #4]
    
    /* Set the number of channels to be converted in discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
 8000aa8:	687b      	ldr	r3, [r7, #4]
 8000aaa:	681b      	ldr	r3, [r3, #0]
 8000aac:	685a      	ldr	r2, [r3, #4]
 8000aae:	687b      	ldr	r3, [r7, #4]
 8000ab0:	681b      	ldr	r3, [r3, #0]
 8000ab2:	f422 4260 	bic.w	r2, r2, #57344	; 0xe000
 8000ab6:	605a      	str	r2, [r3, #4]
    hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
 8000ab8:	687b      	ldr	r3, [r7, #4]
 8000aba:	681b      	ldr	r3, [r3, #0]
 8000abc:	6859      	ldr	r1, [r3, #4]
 8000abe:	687b      	ldr	r3, [r7, #4]
 8000ac0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ac2:	3b01      	subs	r3, #1
 8000ac4:	035a      	lsls	r2, r3, #13
 8000ac6:	687b      	ldr	r3, [r7, #4]
 8000ac8:	681b      	ldr	r3, [r3, #0]
 8000aca:	430a      	orrs	r2, r1
 8000acc:	605a      	str	r2, [r3, #4]
 8000ace:	e007      	b.n	8000ae0 <ADC_Init+0x170>
  }
  else
  {
    /* Disable the selected ADC regular discontinuous mode */
    hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
 8000ad0:	687b      	ldr	r3, [r7, #4]
 8000ad2:	681b      	ldr	r3, [r3, #0]
 8000ad4:	685a      	ldr	r2, [r3, #4]
 8000ad6:	687b      	ldr	r3, [r7, #4]
 8000ad8:	681b      	ldr	r3, [r3, #0]
 8000ada:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 8000ade:	605a      	str	r2, [r3, #4]
  }
  
  /* Set ADC number of conversion */
  hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
 8000ae0:	687b      	ldr	r3, [r7, #4]
 8000ae2:	681b      	ldr	r3, [r3, #0]
 8000ae4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000ae6:	687b      	ldr	r3, [r7, #4]
 8000ae8:	681b      	ldr	r3, [r3, #0]
 8000aea:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
 8000aee:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
 8000af0:	687b      	ldr	r3, [r7, #4]
 8000af2:	681b      	ldr	r3, [r3, #0]
 8000af4:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8000af6:	687b      	ldr	r3, [r7, #4]
 8000af8:	69db      	ldr	r3, [r3, #28]
 8000afa:	3b01      	subs	r3, #1
 8000afc:	051a      	lsls	r2, r3, #20
 8000afe:	687b      	ldr	r3, [r7, #4]
 8000b00:	681b      	ldr	r3, [r3, #0]
 8000b02:	430a      	orrs	r2, r1
 8000b04:	62da      	str	r2, [r3, #44]	; 0x2c
  
  /* Enable or disable ADC DMA continuous request */
  hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
 8000b06:	687b      	ldr	r3, [r7, #4]
 8000b08:	681b      	ldr	r3, [r3, #0]
 8000b0a:	689a      	ldr	r2, [r3, #8]
 8000b0c:	687b      	ldr	r3, [r7, #4]
 8000b0e:	681b      	ldr	r3, [r3, #0]
 8000b10:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8000b14:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_DMAContReq((uint32_t)hadc->Init.DMAContinuousRequests);
 8000b16:	687b      	ldr	r3, [r7, #4]
 8000b18:	681b      	ldr	r3, [r3, #0]
 8000b1a:	6899      	ldr	r1, [r3, #8]
 8000b1c:	687b      	ldr	r3, [r7, #4]
 8000b1e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8000b22:	025a      	lsls	r2, r3, #9
 8000b24:	687b      	ldr	r3, [r7, #4]
 8000b26:	681b      	ldr	r3, [r3, #0]
 8000b28:	430a      	orrs	r2, r1
 8000b2a:	609a      	str	r2, [r3, #8]
  
  /* Enable or disable ADC end of conversion selection */
  hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
 8000b2c:	687b      	ldr	r3, [r7, #4]
 8000b2e:	681b      	ldr	r3, [r3, #0]
 8000b30:	689a      	ldr	r2, [r3, #8]
 8000b32:	687b      	ldr	r3, [r7, #4]
 8000b34:	681b      	ldr	r3, [r3, #0]
 8000b36:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8000b3a:	609a      	str	r2, [r3, #8]
  hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
 8000b3c:	687b      	ldr	r3, [r7, #4]
 8000b3e:	681b      	ldr	r3, [r3, #0]
 8000b40:	6899      	ldr	r1, [r3, #8]
 8000b42:	687b      	ldr	r3, [r7, #4]
 8000b44:	695b      	ldr	r3, [r3, #20]
 8000b46:	029a      	lsls	r2, r3, #10
 8000b48:	687b      	ldr	r3, [r7, #4]
 8000b4a:	681b      	ldr	r3, [r3, #0]
 8000b4c:	430a      	orrs	r2, r1
 8000b4e:	609a      	str	r2, [r3, #8]
}
 8000b50:	bf00      	nop
 8000b52:	370c      	adds	r7, #12
 8000b54:	46bd      	mov	sp, r7
 8000b56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000b5a:	4770      	bx	lr
 8000b5c:	40012300 	.word	0x40012300
 8000b60:	0f000001 	.word	0x0f000001

08000b64 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000b64:	b480      	push	{r7}
 8000b66:	b085      	sub	sp, #20
 8000b68:	af00      	add	r7, sp, #0
 8000b6a:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000b6c:	687b      	ldr	r3, [r7, #4]
 8000b6e:	f003 0307 	and.w	r3, r3, #7
 8000b72:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000b74:	4b0b      	ldr	r3, [pc, #44]	; (8000ba4 <__NVIC_SetPriorityGrouping+0x40>)
 8000b76:	68db      	ldr	r3, [r3, #12]
 8000b78:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000b7a:	68ba      	ldr	r2, [r7, #8]
 8000b7c:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000b80:	4013      	ands	r3, r2
 8000b82:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000b84:	68fb      	ldr	r3, [r7, #12]
 8000b86:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000b88:	68bb      	ldr	r3, [r7, #8]
 8000b8a:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
 8000b8c:	4b06      	ldr	r3, [pc, #24]	; (8000ba8 <__NVIC_SetPriorityGrouping+0x44>)
 8000b8e:	4313      	orrs	r3, r2
 8000b90:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8000b92:	4a04      	ldr	r2, [pc, #16]	; (8000ba4 <__NVIC_SetPriorityGrouping+0x40>)
 8000b94:	68bb      	ldr	r3, [r7, #8]
 8000b96:	60d3      	str	r3, [r2, #12]
}
 8000b98:	bf00      	nop
 8000b9a:	3714      	adds	r7, #20
 8000b9c:	46bd      	mov	sp, r7
 8000b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000ba2:	4770      	bx	lr
 8000ba4:	e000ed00 	.word	0xe000ed00
 8000ba8:	05fa0000 	.word	0x05fa0000

08000bac <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8000bac:	b480      	push	{r7}
 8000bae:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000bb0:	4b04      	ldr	r3, [pc, #16]	; (8000bc4 <__NVIC_GetPriorityGrouping+0x18>)
 8000bb2:	68db      	ldr	r3, [r3, #12]
 8000bb4:	0a1b      	lsrs	r3, r3, #8
 8000bb6:	f003 0307 	and.w	r3, r3, #7
}
 8000bba:	4618      	mov	r0, r3
 8000bbc:	46bd      	mov	sp, r7
 8000bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bc2:	4770      	bx	lr
 8000bc4:	e000ed00 	.word	0xe000ed00

08000bc8 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000bc8:	b480      	push	{r7}
 8000bca:	b083      	sub	sp, #12
 8000bcc:	af00      	add	r7, sp, #0
 8000bce:	4603      	mov	r3, r0
 8000bd0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8000bd2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000bd6:	2b00      	cmp	r3, #0
 8000bd8:	db0b      	blt.n	8000bf2 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000bda:	79fb      	ldrb	r3, [r7, #7]
 8000bdc:	f003 021f 	and.w	r2, r3, #31
 8000be0:	4907      	ldr	r1, [pc, #28]	; (8000c00 <__NVIC_EnableIRQ+0x38>)
 8000be2:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000be6:	095b      	lsrs	r3, r3, #5
 8000be8:	2001      	movs	r0, #1
 8000bea:	fa00 f202 	lsl.w	r2, r0, r2
 8000bee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8000bf2:	bf00      	nop
 8000bf4:	370c      	adds	r7, #12
 8000bf6:	46bd      	mov	sp, r7
 8000bf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000bfc:	4770      	bx	lr
 8000bfe:	bf00      	nop
 8000c00:	e000e100 	.word	0xe000e100

08000c04 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000c04:	b480      	push	{r7}
 8000c06:	b083      	sub	sp, #12
 8000c08:	af00      	add	r7, sp, #0
 8000c0a:	4603      	mov	r3, r0
 8000c0c:	6039      	str	r1, [r7, #0]
 8000c0e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8000c10:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000c14:	2b00      	cmp	r3, #0
 8000c16:	db0a      	blt.n	8000c2e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c18:	683b      	ldr	r3, [r7, #0]
 8000c1a:	b2da      	uxtb	r2, r3
 8000c1c:	490c      	ldr	r1, [pc, #48]	; (8000c50 <__NVIC_SetPriority+0x4c>)
 8000c1e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000c22:	0112      	lsls	r2, r2, #4
 8000c24:	b2d2      	uxtb	r2, r2
 8000c26:	440b      	add	r3, r1
 8000c28:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8000c2c:	e00a      	b.n	8000c44 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c2e:	683b      	ldr	r3, [r7, #0]
 8000c30:	b2da      	uxtb	r2, r3
 8000c32:	4908      	ldr	r1, [pc, #32]	; (8000c54 <__NVIC_SetPriority+0x50>)
 8000c34:	79fb      	ldrb	r3, [r7, #7]
 8000c36:	f003 030f 	and.w	r3, r3, #15
 8000c3a:	3b04      	subs	r3, #4
 8000c3c:	0112      	lsls	r2, r2, #4
 8000c3e:	b2d2      	uxtb	r2, r2
 8000c40:	440b      	add	r3, r1
 8000c42:	761a      	strb	r2, [r3, #24]
}
 8000c44:	bf00      	nop
 8000c46:	370c      	adds	r7, #12
 8000c48:	46bd      	mov	sp, r7
 8000c4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000c4e:	4770      	bx	lr
 8000c50:	e000e100 	.word	0xe000e100
 8000c54:	e000ed00 	.word	0xe000ed00

08000c58 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000c58:	b480      	push	{r7}
 8000c5a:	b089      	sub	sp, #36	; 0x24
 8000c5c:	af00      	add	r7, sp, #0
 8000c5e:	60f8      	str	r0, [r7, #12]
 8000c60:	60b9      	str	r1, [r7, #8]
 8000c62:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8000c64:	68fb      	ldr	r3, [r7, #12]
 8000c66:	f003 0307 	and.w	r3, r3, #7
 8000c6a:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000c6c:	69fb      	ldr	r3, [r7, #28]
 8000c6e:	f1c3 0307 	rsb	r3, r3, #7
 8000c72:	2b04      	cmp	r3, #4
 8000c74:	bf28      	it	cs
 8000c76:	2304      	movcs	r3, #4
 8000c78:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000c7a:	69fb      	ldr	r3, [r7, #28]
 8000c7c:	3304      	adds	r3, #4
 8000c7e:	2b06      	cmp	r3, #6
 8000c80:	d902      	bls.n	8000c88 <NVIC_EncodePriority+0x30>
 8000c82:	69fb      	ldr	r3, [r7, #28]
 8000c84:	3b03      	subs	r3, #3
 8000c86:	e000      	b.n	8000c8a <NVIC_EncodePriority+0x32>
 8000c88:	2300      	movs	r3, #0
 8000c8a:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000c8c:	f04f 32ff 	mov.w	r2, #4294967295
 8000c90:	69bb      	ldr	r3, [r7, #24]
 8000c92:	fa02 f303 	lsl.w	r3, r2, r3
 8000c96:	43da      	mvns	r2, r3
 8000c98:	68bb      	ldr	r3, [r7, #8]
 8000c9a:	401a      	ands	r2, r3
 8000c9c:	697b      	ldr	r3, [r7, #20]
 8000c9e:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000ca0:	f04f 31ff 	mov.w	r1, #4294967295
 8000ca4:	697b      	ldr	r3, [r7, #20]
 8000ca6:	fa01 f303 	lsl.w	r3, r1, r3
 8000caa:	43d9      	mvns	r1, r3
 8000cac:	687b      	ldr	r3, [r7, #4]
 8000cae:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000cb0:	4313      	orrs	r3, r2
         );
}
 8000cb2:	4618      	mov	r0, r3
 8000cb4:	3724      	adds	r7, #36	; 0x24
 8000cb6:	46bd      	mov	sp, r7
 8000cb8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000cbc:	4770      	bx	lr

08000cbe <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000cbe:	b580      	push	{r7, lr}
 8000cc0:	b082      	sub	sp, #8
 8000cc2:	af00      	add	r7, sp, #0
 8000cc4:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8000cc6:	6878      	ldr	r0, [r7, #4]
 8000cc8:	f7ff ff4c 	bl	8000b64 <__NVIC_SetPriorityGrouping>
}
 8000ccc:	bf00      	nop
 8000cce:	3708      	adds	r7, #8
 8000cd0:	46bd      	mov	sp, r7
 8000cd2:	bd80      	pop	{r7, pc}

08000cd4 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8000cd4:	b580      	push	{r7, lr}
 8000cd6:	b086      	sub	sp, #24
 8000cd8:	af00      	add	r7, sp, #0
 8000cda:	4603      	mov	r3, r0
 8000cdc:	60b9      	str	r1, [r7, #8]
 8000cde:	607a      	str	r2, [r7, #4]
 8000ce0:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 8000ce2:	2300      	movs	r3, #0
 8000ce4:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8000ce6:	f7ff ff61 	bl	8000bac <__NVIC_GetPriorityGrouping>
 8000cea:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8000cec:	687a      	ldr	r2, [r7, #4]
 8000cee:	68b9      	ldr	r1, [r7, #8]
 8000cf0:	6978      	ldr	r0, [r7, #20]
 8000cf2:	f7ff ffb1 	bl	8000c58 <NVIC_EncodePriority>
 8000cf6:	4602      	mov	r2, r0
 8000cf8:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8000cfc:	4611      	mov	r1, r2
 8000cfe:	4618      	mov	r0, r3
 8000d00:	f7ff ff80 	bl	8000c04 <__NVIC_SetPriority>
}
 8000d04:	bf00      	nop
 8000d06:	3718      	adds	r7, #24
 8000d08:	46bd      	mov	sp, r7
 8000d0a:	bd80      	pop	{r7, pc}

08000d0c <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000d0c:	b580      	push	{r7, lr}
 8000d0e:	b082      	sub	sp, #8
 8000d10:	af00      	add	r7, sp, #0
 8000d12:	4603      	mov	r3, r0
 8000d14:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8000d16:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000d1a:	4618      	mov	r0, r3
 8000d1c:	f7ff ff54 	bl	8000bc8 <__NVIC_EnableIRQ>
}
 8000d20:	bf00      	nop
 8000d22:	3708      	adds	r7, #8
 8000d24:	46bd      	mov	sp, r7
 8000d26:	bd80      	pop	{r7, pc}

08000d28 <HAL_DCMI_Init>:
  * @param  hdcmi pointer to a DCMI_HandleTypeDef structure that contains
  *                the configuration information for DCMI.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DCMI_Init(DCMI_HandleTypeDef *hdcmi)
{     
 8000d28:	b580      	push	{r7, lr}
 8000d2a:	b082      	sub	sp, #8
 8000d2c:	af00      	add	r7, sp, #0
 8000d2e:	6078      	str	r0, [r7, #4]
  /* Check the DCMI peripheral state */
  if(hdcmi == NULL)
 8000d30:	687b      	ldr	r3, [r7, #4]
 8000d32:	2b00      	cmp	r3, #0
 8000d34:	d101      	bne.n	8000d3a <HAL_DCMI_Init+0x12>
  {
     return HAL_ERROR;
 8000d36:	2301      	movs	r3, #1
 8000d38:	e062      	b.n	8000e00 <HAL_DCMI_Init+0xd8>
  assert_param(IS_DCMI_BYTE_SELECT_MODE(hdcmi->Init.ByteSelectMode));
  assert_param(IS_DCMI_BYTE_SELECT_START(hdcmi->Init.ByteSelectStart));
  assert_param(IS_DCMI_LINE_SELECT_MODE(hdcmi->Init.LineSelectMode));
  assert_param(IS_DCMI_LINE_SELECT_START(hdcmi->Init.LineSelectStart));
                
  if(hdcmi->State == HAL_DCMI_STATE_RESET)
 8000d3a:	687b      	ldr	r3, [r7, #4]
 8000d3c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8000d40:	b2db      	uxtb	r3, r3
 8000d42:	2b00      	cmp	r3, #0
 8000d44:	d102      	bne.n	8000d4c <HAL_DCMI_Init+0x24>
    }
    /* Initialize the low level hardware (MSP) */
    hdcmi->MspInitCallback(hdcmi);
#else  
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_DCMI_MspInit(hdcmi);
 8000d46:	6878      	ldr	r0, [r7, #4]
 8000d48:	f008 fd9e 	bl	8009888 <HAL_DCMI_MspInit>
#endif /* (USE_HAL_DCMI_REGISTER_CALLBACKS) */
  } 
  
  /* Change the DCMI state */
  hdcmi->State = HAL_DCMI_STATE_BUSY; 
 8000d4c:	687b      	ldr	r3, [r7, #4]
 8000d4e:	2202      	movs	r2, #2
 8000d50:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
                          /* Configures the HS, VS, DE and PC polarity */
  hdcmi->Instance->CR &= ~(DCMI_CR_PCKPOL | DCMI_CR_HSPOL  | DCMI_CR_VSPOL  | DCMI_CR_EDM_0 |\
 8000d54:	687b      	ldr	r3, [r7, #4]
 8000d56:	681b      	ldr	r3, [r3, #0]
 8000d58:	6819      	ldr	r1, [r3, #0]
 8000d5a:	687b      	ldr	r3, [r7, #4]
 8000d5c:	681a      	ldr	r2, [r3, #0]
 8000d5e:	4b2a      	ldr	r3, [pc, #168]	; (8000e08 <HAL_DCMI_Init+0xe0>)
 8000d60:	400b      	ands	r3, r1
 8000d62:	6013      	str	r3, [r2, #0]
                           DCMI_CR_EDM_1  | DCMI_CR_FCRC_0 | DCMI_CR_FCRC_1 | DCMI_CR_JPEG  |\
                           DCMI_CR_ESS | DCMI_CR_BSM_0 | DCMI_CR_BSM_1 | DCMI_CR_OEBS |\
                           DCMI_CR_LSM | DCMI_CR_OELS);

  hdcmi->Instance->CR |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 8000d64:	687b      	ldr	r3, [r7, #4]
 8000d66:	681b      	ldr	r3, [r3, #0]
 8000d68:	6819      	ldr	r1, [r3, #0]
 8000d6a:	687b      	ldr	r3, [r7, #4]
 8000d6c:	685a      	ldr	r2, [r3, #4]
 8000d6e:	687b      	ldr	r3, [r7, #4]
 8000d70:	695b      	ldr	r3, [r3, #20]
 8000d72:	431a      	orrs	r2, r3
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 8000d74:	687b      	ldr	r3, [r7, #4]
 8000d76:	68db      	ldr	r3, [r3, #12]
  hdcmi->Instance->CR |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 8000d78:	431a      	orrs	r2, r3
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 8000d7a:	687b      	ldr	r3, [r7, #4]
 8000d7c:	691b      	ldr	r3, [r3, #16]
 8000d7e:	431a      	orrs	r2, r3
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 8000d80:	687b      	ldr	r3, [r7, #4]
 8000d82:	689b      	ldr	r3, [r3, #8]
                                     hdcmi->Init.VSPolarity  | hdcmi->Init.HSPolarity  |\
 8000d84:	431a      	orrs	r2, r3
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 8000d86:	687b      	ldr	r3, [r7, #4]
 8000d88:	699b      	ldr	r3, [r3, #24]
 8000d8a:	431a      	orrs	r2, r3
                                     hdcmi->Init.JPEGMode | hdcmi->Init.ByteSelectMode |\
 8000d8c:	687b      	ldr	r3, [r7, #4]
 8000d8e:	6a1b      	ldr	r3, [r3, #32]
                                     hdcmi->Init.PCKPolarity | hdcmi->Init.ExtendedDataMode |\
 8000d90:	431a      	orrs	r2, r3
                                     hdcmi->Init.JPEGMode | hdcmi->Init.ByteSelectMode |\
 8000d92:	687b      	ldr	r3, [r7, #4]
 8000d94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000d96:	431a      	orrs	r2, r3
                                     hdcmi->Init.ByteSelectStart | hdcmi->Init.LineSelectMode |\
 8000d98:	687b      	ldr	r3, [r7, #4]
 8000d9a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                                     hdcmi->Init.JPEGMode | hdcmi->Init.ByteSelectMode |\
 8000d9c:	431a      	orrs	r2, r3
                                     hdcmi->Init.ByteSelectStart | hdcmi->Init.LineSelectMode |\
 8000d9e:	687b      	ldr	r3, [r7, #4]
 8000da0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000da2:	431a      	orrs	r2, r3
                                     hdcmi->Init.LineSelectStart);
 8000da4:	687b      	ldr	r3, [r7, #4]
 8000da6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
                                     hdcmi->Init.ByteSelectStart | hdcmi->Init.LineSelectMode |\
 8000da8:	431a      	orrs	r2, r3
  hdcmi->Instance->CR |=  (uint32_t)(hdcmi->Init.SynchroMode | hdcmi->Init.CaptureRate |\
 8000daa:	687b      	ldr	r3, [r7, #4]
 8000dac:	681b      	ldr	r3, [r3, #0]
 8000dae:	430a      	orrs	r2, r1
 8000db0:	601a      	str	r2, [r3, #0]
                                     
  if(hdcmi->Init.SynchroMode == DCMI_SYNCHRO_EMBEDDED)
 8000db2:	687b      	ldr	r3, [r7, #4]
 8000db4:	685b      	ldr	r3, [r3, #4]
 8000db6:	2b10      	cmp	r3, #16
 8000db8:	d112      	bne.n	8000de0 <HAL_DCMI_Init+0xb8>
  {
    hdcmi->Instance->ESCR = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |\
 8000dba:	687b      	ldr	r3, [r7, #4]
 8000dbc:	7f1b      	ldrb	r3, [r3, #28]
 8000dbe:	461a      	mov	r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_ESCR_LSC_Pos)|\
 8000dc0:	687b      	ldr	r3, [r7, #4]
 8000dc2:	7f5b      	ldrb	r3, [r3, #29]
 8000dc4:	021b      	lsls	r3, r3, #8
    hdcmi->Instance->ESCR = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |\
 8000dc6:	431a      	orrs	r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_ESCR_LEC_Pos) |\
 8000dc8:	687b      	ldr	r3, [r7, #4]
 8000dca:	7f9b      	ldrb	r3, [r3, #30]
 8000dcc:	041b      	lsls	r3, r3, #16
                             ((uint32_t)hdcmi->Init.SyncroCode.LineStartCode << DCMI_ESCR_LSC_Pos)|\
 8000dce:	ea42 0103 	orr.w	r1, r2, r3
                             ((uint32_t)hdcmi->Init.SyncroCode.FrameEndCode << DCMI_ESCR_FEC_Pos));
 8000dd2:	687b      	ldr	r3, [r7, #4]
 8000dd4:	7fdb      	ldrb	r3, [r3, #31]
 8000dd6:	061a      	lsls	r2, r3, #24
    hdcmi->Instance->ESCR = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |\
 8000dd8:	687b      	ldr	r3, [r7, #4]
 8000dda:	681b      	ldr	r3, [r3, #0]
                             ((uint32_t)hdcmi->Init.SyncroCode.LineEndCode << DCMI_ESCR_LEC_Pos) |\
 8000ddc:	430a      	orrs	r2, r1
    hdcmi->Instance->ESCR = (((uint32_t)hdcmi->Init.SyncroCode.FrameStartCode)    |\
 8000dde:	619a      	str	r2, [r3, #24]

  }

  /* Enable the Line, Vsync, Error and Overrun interrupts */
  __HAL_DCMI_ENABLE_IT(hdcmi, DCMI_IT_LINE | DCMI_IT_VSYNC | DCMI_IT_ERR | DCMI_IT_OVR);
 8000de0:	687b      	ldr	r3, [r7, #4]
 8000de2:	681b      	ldr	r3, [r3, #0]
 8000de4:	68da      	ldr	r2, [r3, #12]
 8000de6:	687b      	ldr	r3, [r7, #4]
 8000de8:	681b      	ldr	r3, [r3, #0]
 8000dea:	f042 021e 	orr.w	r2, r2, #30
 8000dee:	60da      	str	r2, [r3, #12]

  /* Update error code */
  hdcmi->ErrorCode = HAL_DCMI_ERROR_NONE;
 8000df0:	687b      	ldr	r3, [r7, #4]
 8000df2:	2200      	movs	r2, #0
 8000df4:	64da      	str	r2, [r3, #76]	; 0x4c
  
  /* Initialize the DCMI state*/
  hdcmi->State  = HAL_DCMI_STATE_READY;
 8000df6:	687b      	ldr	r3, [r7, #4]
 8000df8:	2201      	movs	r2, #1
 8000dfa:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8000dfe:	2300      	movs	r3, #0
}
 8000e00:	4618      	mov	r0, r3
 8000e02:	3708      	adds	r7, #8
 8000e04:	46bd      	mov	sp, r7
 8000e06:	bd80      	pop	{r7, pc}
 8000e08:	ffe0f007 	.word	0xffe0f007

08000e0c <HAL_DMA_Init>:
  * @param  hdma Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8000e0c:	b580      	push	{r7, lr}
 8000e0e:	b086      	sub	sp, #24
 8000e10:	af00      	add	r7, sp, #0
 8000e12:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0U;
 8000e14:	2300      	movs	r3, #0
 8000e16:	617b      	str	r3, [r7, #20]
  uint32_t tickstart = HAL_GetTick();
 8000e18:	f7ff fc04 	bl	8000624 <HAL_GetTick>
 8000e1c:	6138      	str	r0, [r7, #16]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8000e1e:	687b      	ldr	r3, [r7, #4]
 8000e20:	2b00      	cmp	r3, #0
 8000e22:	d101      	bne.n	8000e28 <HAL_DMA_Init+0x1c>
  {
    return HAL_ERROR;
 8000e24:	2301      	movs	r3, #1
 8000e26:	e099      	b.n	8000f5c <HAL_DMA_Init+0x150>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 8000e28:	687b      	ldr	r3, [r7, #4]
 8000e2a:	2200      	movs	r2, #0
 8000e2c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8000e30:	687b      	ldr	r3, [r7, #4]
 8000e32:	2202      	movs	r2, #2
 8000e34:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8000e38:	687b      	ldr	r3, [r7, #4]
 8000e3a:	681b      	ldr	r3, [r3, #0]
 8000e3c:	681a      	ldr	r2, [r3, #0]
 8000e3e:	687b      	ldr	r3, [r7, #4]
 8000e40:	681b      	ldr	r3, [r3, #0]
 8000e42:	f022 0201 	bic.w	r2, r2, #1
 8000e46:	601a      	str	r2, [r3, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8000e48:	e00f      	b.n	8000e6a <HAL_DMA_Init+0x5e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8000e4a:	f7ff fbeb 	bl	8000624 <HAL_GetTick>
 8000e4e:	4602      	mov	r2, r0
 8000e50:	693b      	ldr	r3, [r7, #16]
 8000e52:	1ad3      	subs	r3, r2, r3
 8000e54:	2b05      	cmp	r3, #5
 8000e56:	d908      	bls.n	8000e6a <HAL_DMA_Init+0x5e>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8000e58:	687b      	ldr	r3, [r7, #4]
 8000e5a:	2220      	movs	r2, #32
 8000e5c:	655a      	str	r2, [r3, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8000e5e:	687b      	ldr	r3, [r7, #4]
 8000e60:	2203      	movs	r2, #3
 8000e62:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
      
      return HAL_TIMEOUT;
 8000e66:	2303      	movs	r3, #3
 8000e68:	e078      	b.n	8000f5c <HAL_DMA_Init+0x150>
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8000e6a:	687b      	ldr	r3, [r7, #4]
 8000e6c:	681b      	ldr	r3, [r3, #0]
 8000e6e:	681b      	ldr	r3, [r3, #0]
 8000e70:	f003 0301 	and.w	r3, r3, #1
 8000e74:	2b00      	cmp	r3, #0
 8000e76:	d1e8      	bne.n	8000e4a <HAL_DMA_Init+0x3e>
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8000e78:	687b      	ldr	r3, [r7, #4]
 8000e7a:	681b      	ldr	r3, [r3, #0]
 8000e7c:	681b      	ldr	r3, [r3, #0]
 8000e7e:	617b      	str	r3, [r7, #20]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8000e80:	697a      	ldr	r2, [r7, #20]
 8000e82:	4b38      	ldr	r3, [pc, #224]	; (8000f64 <HAL_DMA_Init+0x158>)
 8000e84:	4013      	ands	r3, r2
 8000e86:	617b      	str	r3, [r7, #20]
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000e88:	687b      	ldr	r3, [r7, #4]
 8000e8a:	685a      	ldr	r2, [r3, #4]
 8000e8c:	687b      	ldr	r3, [r7, #4]
 8000e8e:	689b      	ldr	r3, [r3, #8]
 8000e90:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000e92:	687b      	ldr	r3, [r7, #4]
 8000e94:	68db      	ldr	r3, [r3, #12]
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000e96:	431a      	orrs	r2, r3
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000e98:	687b      	ldr	r3, [r7, #4]
 8000e9a:	691b      	ldr	r3, [r3, #16]
 8000e9c:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000e9e:	687b      	ldr	r3, [r7, #4]
 8000ea0:	695b      	ldr	r3, [r3, #20]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8000ea2:	431a      	orrs	r2, r3
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000ea4:	687b      	ldr	r3, [r7, #4]
 8000ea6:	699b      	ldr	r3, [r3, #24]
 8000ea8:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8000eaa:	687b      	ldr	r3, [r7, #4]
 8000eac:	69db      	ldr	r3, [r3, #28]
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8000eae:	431a      	orrs	r2, r3
          hdma->Init.Mode                | hdma->Init.Priority;
 8000eb0:	687b      	ldr	r3, [r7, #4]
 8000eb2:	6a1b      	ldr	r3, [r3, #32]
 8000eb4:	4313      	orrs	r3, r2
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8000eb6:	697a      	ldr	r2, [r7, #20]
 8000eb8:	4313      	orrs	r3, r2
 8000eba:	617b      	str	r3, [r7, #20]

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000ebc:	687b      	ldr	r3, [r7, #4]
 8000ebe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ec0:	2b04      	cmp	r3, #4
 8000ec2:	d107      	bne.n	8000ed4 <HAL_DMA_Init+0xc8>
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8000ec4:	687b      	ldr	r3, [r7, #4]
 8000ec6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8000ec8:	687b      	ldr	r3, [r7, #4]
 8000eca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000ecc:	4313      	orrs	r3, r2
 8000ece:	697a      	ldr	r2, [r7, #20]
 8000ed0:	4313      	orrs	r3, r2
 8000ed2:	617b      	str	r3, [r7, #20]
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8000ed4:	687b      	ldr	r3, [r7, #4]
 8000ed6:	681b      	ldr	r3, [r3, #0]
 8000ed8:	697a      	ldr	r2, [r7, #20]
 8000eda:	601a      	str	r2, [r3, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8000edc:	687b      	ldr	r3, [r7, #4]
 8000ede:	681b      	ldr	r3, [r3, #0]
 8000ee0:	695b      	ldr	r3, [r3, #20]
 8000ee2:	617b      	str	r3, [r7, #20]

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8000ee4:	697b      	ldr	r3, [r7, #20]
 8000ee6:	f023 0307 	bic.w	r3, r3, #7
 8000eea:	617b      	str	r3, [r7, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8000eec:	687b      	ldr	r3, [r7, #4]
 8000eee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000ef0:	697a      	ldr	r2, [r7, #20]
 8000ef2:	4313      	orrs	r3, r2
 8000ef4:	617b      	str	r3, [r7, #20]

  /* The FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8000ef6:	687b      	ldr	r3, [r7, #4]
 8000ef8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000efa:	2b04      	cmp	r3, #4
 8000efc:	d117      	bne.n	8000f2e <HAL_DMA_Init+0x122>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8000efe:	687b      	ldr	r3, [r7, #4]
 8000f00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8000f02:	697a      	ldr	r2, [r7, #20]
 8000f04:	4313      	orrs	r3, r2
 8000f06:	617b      	str	r3, [r7, #20]
    
    /* Check compatibility between FIFO threshold level and size of the memory burst */
    /* for INCR4, INCR8, INCR16 bursts */
    if (hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8000f08:	687b      	ldr	r3, [r7, #4]
 8000f0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8000f0c:	2b00      	cmp	r3, #0
 8000f0e:	d00e      	beq.n	8000f2e <HAL_DMA_Init+0x122>
    {
      if (DMA_CheckFifoParam(hdma) != HAL_OK)
 8000f10:	6878      	ldr	r0, [r7, #4]
 8000f12:	f000 fb29 	bl	8001568 <DMA_CheckFifoParam>
 8000f16:	4603      	mov	r3, r0
 8000f18:	2b00      	cmp	r3, #0
 8000f1a:	d008      	beq.n	8000f2e <HAL_DMA_Init+0x122>
      {
        /* Update error code */
        hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8000f1c:	687b      	ldr	r3, [r7, #4]
 8000f1e:	2240      	movs	r2, #64	; 0x40
 8000f20:	655a      	str	r2, [r3, #84]	; 0x54
        
        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 8000f22:	687b      	ldr	r3, [r7, #4]
 8000f24:	2201      	movs	r2, #1
 8000f26:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        
        return HAL_ERROR; 
 8000f2a:	2301      	movs	r3, #1
 8000f2c:	e016      	b.n	8000f5c <HAL_DMA_Init+0x150>
      }
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 8000f2e:	687b      	ldr	r3, [r7, #4]
 8000f30:	681b      	ldr	r3, [r3, #0]
 8000f32:	697a      	ldr	r2, [r7, #20]
 8000f34:	615a      	str	r2, [r3, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8000f36:	6878      	ldr	r0, [r7, #4]
 8000f38:	f000 fae0 	bl	80014fc <DMA_CalcBaseAndBitshift>
 8000f3c:	4603      	mov	r3, r0
 8000f3e:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000f40:	687b      	ldr	r3, [r7, #4]
 8000f42:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8000f44:	223f      	movs	r2, #63	; 0x3f
 8000f46:	409a      	lsls	r2, r3
 8000f48:	68fb      	ldr	r3, [r7, #12]
 8000f4a:	609a      	str	r2, [r3, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8000f4c:	687b      	ldr	r3, [r7, #4]
 8000f4e:	2200      	movs	r2, #0
 8000f50:	655a      	str	r2, [r3, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8000f52:	687b      	ldr	r3, [r7, #4]
 8000f54:	2201      	movs	r2, #1
 8000f56:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  return HAL_OK;
 8000f5a:	2300      	movs	r3, #0
}
 8000f5c:	4618      	mov	r0, r3
 8000f5e:	3718      	adds	r7, #24
 8000f60:	46bd      	mov	sp, r7
 8000f62:	bd80      	pop	{r7, pc}
 8000f64:	f010803f 	.word	0xf010803f

08000f68 <HAL_DMA_DeInit>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 8000f68:	b580      	push	{r7, lr}
 8000f6a:	b084      	sub	sp, #16
 8000f6c:	af00      	add	r7, sp, #0
 8000f6e:	6078      	str	r0, [r7, #4]
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8000f70:	687b      	ldr	r3, [r7, #4]
 8000f72:	2b00      	cmp	r3, #0
 8000f74:	d101      	bne.n	8000f7a <HAL_DMA_DeInit+0x12>
  {
    return HAL_ERROR;
 8000f76:	2301      	movs	r3, #1
 8000f78:	e050      	b.n	800101c <HAL_DMA_DeInit+0xb4>
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 8000f7a:	687b      	ldr	r3, [r7, #4]
 8000f7c:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8000f80:	b2db      	uxtb	r3, r3
 8000f82:	2b02      	cmp	r3, #2
 8000f84:	d101      	bne.n	8000f8a <HAL_DMA_DeInit+0x22>
  {
    /* Return error status */
    return HAL_BUSY;
 8000f86:	2302      	movs	r3, #2
 8000f88:	e048      	b.n	800101c <HAL_DMA_DeInit+0xb4>

  /* Check the parameters */
  assert_param(IS_DMA_STREAM_ALL_INSTANCE(hdma->Instance));

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 8000f8a:	687b      	ldr	r3, [r7, #4]
 8000f8c:	681b      	ldr	r3, [r3, #0]
 8000f8e:	681a      	ldr	r2, [r3, #0]
 8000f90:	687b      	ldr	r3, [r7, #4]
 8000f92:	681b      	ldr	r3, [r3, #0]
 8000f94:	f022 0201 	bic.w	r2, r2, #1
 8000f98:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0U;
 8000f9a:	687b      	ldr	r3, [r7, #4]
 8000f9c:	681b      	ldr	r3, [r3, #0]
 8000f9e:	2200      	movs	r2, #0
 8000fa0:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0U;
 8000fa2:	687b      	ldr	r3, [r7, #4]
 8000fa4:	681b      	ldr	r3, [r3, #0]
 8000fa6:	2200      	movs	r2, #0
 8000fa8:	605a      	str	r2, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0U;
 8000faa:	687b      	ldr	r3, [r7, #4]
 8000fac:	681b      	ldr	r3, [r3, #0]
 8000fae:	2200      	movs	r2, #0
 8000fb0:	609a      	str	r2, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0U;
 8000fb2:	687b      	ldr	r3, [r7, #4]
 8000fb4:	681b      	ldr	r3, [r3, #0]
 8000fb6:	2200      	movs	r2, #0
 8000fb8:	60da      	str	r2, [r3, #12]
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0U;
 8000fba:	687b      	ldr	r3, [r7, #4]
 8000fbc:	681b      	ldr	r3, [r3, #0]
 8000fbe:	2200      	movs	r2, #0
 8000fc0:	611a      	str	r2, [r3, #16]
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 8000fc2:	687b      	ldr	r3, [r7, #4]
 8000fc4:	681b      	ldr	r3, [r3, #0]
 8000fc6:	2221      	movs	r2, #33	; 0x21
 8000fc8:	615a      	str	r2, [r3, #20]
  
  /* Get DMA steam Base Address */  
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8000fca:	6878      	ldr	r0, [r7, #4]
 8000fcc:	f000 fa96 	bl	80014fc <DMA_CalcBaseAndBitshift>
 8000fd0:	4603      	mov	r3, r0
 8000fd2:	60fb      	str	r3, [r7, #12]
  
  /* Clear all interrupt flags at correct offset within the register */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8000fd4:	687b      	ldr	r3, [r7, #4]
 8000fd6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8000fd8:	223f      	movs	r2, #63	; 0x3f
 8000fda:	409a      	lsls	r2, r3
 8000fdc:	68fb      	ldr	r3, [r7, #12]
 8000fde:	609a      	str	r2, [r3, #8]
  
  /* Clean all callbacks */
  hdma->XferCpltCallback = NULL;
 8000fe0:	687b      	ldr	r3, [r7, #4]
 8000fe2:	2200      	movs	r2, #0
 8000fe4:	63da      	str	r2, [r3, #60]	; 0x3c
  hdma->XferHalfCpltCallback = NULL;
 8000fe6:	687b      	ldr	r3, [r7, #4]
 8000fe8:	2200      	movs	r2, #0
 8000fea:	641a      	str	r2, [r3, #64]	; 0x40
  hdma->XferM1CpltCallback = NULL;
 8000fec:	687b      	ldr	r3, [r7, #4]
 8000fee:	2200      	movs	r2, #0
 8000ff0:	645a      	str	r2, [r3, #68]	; 0x44
  hdma->XferM1HalfCpltCallback = NULL;
 8000ff2:	687b      	ldr	r3, [r7, #4]
 8000ff4:	2200      	movs	r2, #0
 8000ff6:	649a      	str	r2, [r3, #72]	; 0x48
  hdma->XferErrorCallback = NULL;
 8000ff8:	687b      	ldr	r3, [r7, #4]
 8000ffa:	2200      	movs	r2, #0
 8000ffc:	64da      	str	r2, [r3, #76]	; 0x4c
  hdma->XferAbortCallback = NULL;  
 8000ffe:	687b      	ldr	r3, [r7, #4]
 8001000:	2200      	movs	r2, #0
 8001002:	651a      	str	r2, [r3, #80]	; 0x50

  /* Reset the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001004:	687b      	ldr	r3, [r7, #4]
 8001006:	2200      	movs	r2, #0
 8001008:	655a      	str	r2, [r3, #84]	; 0x54

  /* Reset the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 800100a:	687b      	ldr	r3, [r7, #4]
 800100c:	2200      	movs	r2, #0
 800100e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8001012:	687b      	ldr	r3, [r7, #4]
 8001014:	2200      	movs	r2, #0
 8001016:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  return HAL_OK;
 800101a:	2300      	movs	r3, #0
}
 800101c:	4618      	mov	r0, r3
 800101e:	3710      	adds	r7, #16
 8001020:	46bd      	mov	sp, r7
 8001022:	bd80      	pop	{r7, pc}

08001024 <HAL_DMA_Start_IT>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Start_IT(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 8001024:	b580      	push	{r7, lr}
 8001026:	b086      	sub	sp, #24
 8001028:	af00      	add	r7, sp, #0
 800102a:	60f8      	str	r0, [r7, #12]
 800102c:	60b9      	str	r1, [r7, #8]
 800102e:	607a      	str	r2, [r7, #4]
 8001030:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 8001032:	2300      	movs	r3, #0
 8001034:	75fb      	strb	r3, [r7, #23]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8001036:	68fb      	ldr	r3, [r7, #12]
 8001038:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800103a:	613b      	str	r3, [r7, #16]
  
  /* Check the parameters */
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 
  /* Process locked */
  __HAL_LOCK(hdma);
 800103c:	68fb      	ldr	r3, [r7, #12]
 800103e:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8001042:	2b01      	cmp	r3, #1
 8001044:	d101      	bne.n	800104a <HAL_DMA_Start_IT+0x26>
 8001046:	2302      	movs	r3, #2
 8001048:	e048      	b.n	80010dc <HAL_DMA_Start_IT+0xb8>
 800104a:	68fb      	ldr	r3, [r7, #12]
 800104c:	2201      	movs	r2, #1
 800104e:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  if(HAL_DMA_STATE_READY == hdma->State)
 8001052:	68fb      	ldr	r3, [r7, #12]
 8001054:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8001058:	b2db      	uxtb	r3, r3
 800105a:	2b01      	cmp	r3, #1
 800105c:	d137      	bne.n	80010ce <HAL_DMA_Start_IT+0xaa>
  {
    /* Change DMA peripheral state */
    hdma->State = HAL_DMA_STATE_BUSY;
 800105e:	68fb      	ldr	r3, [r7, #12]
 8001060:	2202      	movs	r2, #2
 8001062:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    
    /* Initialize the error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001066:	68fb      	ldr	r3, [r7, #12]
 8001068:	2200      	movs	r2, #0
 800106a:	655a      	str	r2, [r3, #84]	; 0x54
    
    /* Configure the source, destination address and the data length */
    DMA_SetConfig(hdma, SrcAddress, DstAddress, DataLength);
 800106c:	683b      	ldr	r3, [r7, #0]
 800106e:	687a      	ldr	r2, [r7, #4]
 8001070:	68b9      	ldr	r1, [r7, #8]
 8001072:	68f8      	ldr	r0, [r7, #12]
 8001074:	f000 fa14 	bl	80014a0 <DMA_SetConfig>
    
    /* Clear all interrupt flags at correct offset within the register */
    regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001078:	68fb      	ldr	r3, [r7, #12]
 800107a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800107c:	223f      	movs	r2, #63	; 0x3f
 800107e:	409a      	lsls	r2, r3
 8001080:	693b      	ldr	r3, [r7, #16]
 8001082:	609a      	str	r2, [r3, #8]
    
    /* Enable Common interrupts*/
    hdma->Instance->CR  |= DMA_IT_TC | DMA_IT_TE | DMA_IT_DME;
 8001084:	68fb      	ldr	r3, [r7, #12]
 8001086:	681b      	ldr	r3, [r3, #0]
 8001088:	681a      	ldr	r2, [r3, #0]
 800108a:	68fb      	ldr	r3, [r7, #12]
 800108c:	681b      	ldr	r3, [r3, #0]
 800108e:	f042 0216 	orr.w	r2, r2, #22
 8001092:	601a      	str	r2, [r3, #0]
    hdma->Instance->FCR |= DMA_IT_FE;
 8001094:	68fb      	ldr	r3, [r7, #12]
 8001096:	681b      	ldr	r3, [r3, #0]
 8001098:	695a      	ldr	r2, [r3, #20]
 800109a:	68fb      	ldr	r3, [r7, #12]
 800109c:	681b      	ldr	r3, [r3, #0]
 800109e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80010a2:	615a      	str	r2, [r3, #20]
    
    if(hdma->XferHalfCpltCallback != NULL)
 80010a4:	68fb      	ldr	r3, [r7, #12]
 80010a6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80010a8:	2b00      	cmp	r3, #0
 80010aa:	d007      	beq.n	80010bc <HAL_DMA_Start_IT+0x98>
    {
      hdma->Instance->CR  |= DMA_IT_HT;
 80010ac:	68fb      	ldr	r3, [r7, #12]
 80010ae:	681b      	ldr	r3, [r3, #0]
 80010b0:	681a      	ldr	r2, [r3, #0]
 80010b2:	68fb      	ldr	r3, [r7, #12]
 80010b4:	681b      	ldr	r3, [r3, #0]
 80010b6:	f042 0208 	orr.w	r2, r2, #8
 80010ba:	601a      	str	r2, [r3, #0]
    }
    
    /* Enable the Peripheral */
    __HAL_DMA_ENABLE(hdma);
 80010bc:	68fb      	ldr	r3, [r7, #12]
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	681a      	ldr	r2, [r3, #0]
 80010c2:	68fb      	ldr	r3, [r7, #12]
 80010c4:	681b      	ldr	r3, [r3, #0]
 80010c6:	f042 0201 	orr.w	r2, r2, #1
 80010ca:	601a      	str	r2, [r3, #0]
 80010cc:	e005      	b.n	80010da <HAL_DMA_Start_IT+0xb6>
  }
  else
  {
    /* Process unlocked */
    __HAL_UNLOCK(hdma);	  
 80010ce:	68fb      	ldr	r3, [r7, #12]
 80010d0:	2200      	movs	r2, #0
 80010d2:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    
    /* Return error status */
    status = HAL_BUSY;
 80010d6:	2302      	movs	r3, #2
 80010d8:	75fb      	strb	r3, [r7, #23]
  }
  
  return status;
 80010da:	7dfb      	ldrb	r3, [r7, #23]
}
 80010dc:	4618      	mov	r0, r3
 80010de:	3718      	adds	r7, #24
 80010e0:	46bd      	mov	sp, r7
 80010e2:	bd80      	pop	{r7, pc}

080010e4 <HAL_DMA_IRQHandler>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval None
  */
void HAL_DMA_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80010e4:	b580      	push	{r7, lr}
 80010e6:	b086      	sub	sp, #24
 80010e8:	af00      	add	r7, sp, #0
 80010ea:	6078      	str	r0, [r7, #4]
  uint32_t tmpisr;
  __IO uint32_t count = 0;
 80010ec:	2300      	movs	r3, #0
 80010ee:	60bb      	str	r3, [r7, #8]
  uint32_t timeout = SystemCoreClock / 9600;
 80010f0:	4b92      	ldr	r3, [pc, #584]	; (800133c <HAL_DMA_IRQHandler+0x258>)
 80010f2:	681b      	ldr	r3, [r3, #0]
 80010f4:	4a92      	ldr	r2, [pc, #584]	; (8001340 <HAL_DMA_IRQHandler+0x25c>)
 80010f6:	fba2 2303 	umull	r2, r3, r2, r3
 80010fa:	0a9b      	lsrs	r3, r3, #10
 80010fc:	617b      	str	r3, [r7, #20]

  /* calculate DMA base and stream number */
  DMA_Base_Registers *regs = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 80010fe:	687b      	ldr	r3, [r7, #4]
 8001100:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001102:	613b      	str	r3, [r7, #16]

  tmpisr = regs->ISR;
 8001104:	693b      	ldr	r3, [r7, #16]
 8001106:	681b      	ldr	r3, [r3, #0]
 8001108:	60fb      	str	r3, [r7, #12]

  /* Transfer Error Interrupt management ***************************************/
  if ((tmpisr & (DMA_FLAG_TEIF0_4 << hdma->StreamIndex)) != RESET)
 800110a:	687b      	ldr	r3, [r7, #4]
 800110c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800110e:	2208      	movs	r2, #8
 8001110:	409a      	lsls	r2, r3
 8001112:	68fb      	ldr	r3, [r7, #12]
 8001114:	4013      	ands	r3, r2
 8001116:	2b00      	cmp	r3, #0
 8001118:	d01a      	beq.n	8001150 <HAL_DMA_IRQHandler+0x6c>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != RESET)
 800111a:	687b      	ldr	r3, [r7, #4]
 800111c:	681b      	ldr	r3, [r3, #0]
 800111e:	681b      	ldr	r3, [r3, #0]
 8001120:	f003 0304 	and.w	r3, r3, #4
 8001124:	2b00      	cmp	r3, #0
 8001126:	d013      	beq.n	8001150 <HAL_DMA_IRQHandler+0x6c>
    {
      /* Disable the transfer error interrupt */
      hdma->Instance->CR  &= ~(DMA_IT_TE);
 8001128:	687b      	ldr	r3, [r7, #4]
 800112a:	681b      	ldr	r3, [r3, #0]
 800112c:	681a      	ldr	r2, [r3, #0]
 800112e:	687b      	ldr	r3, [r7, #4]
 8001130:	681b      	ldr	r3, [r3, #0]
 8001132:	f022 0204 	bic.w	r2, r2, #4
 8001136:	601a      	str	r2, [r3, #0]
      
      /* Clear the transfer error flag */
      regs->IFCR = DMA_FLAG_TEIF0_4 << hdma->StreamIndex;
 8001138:	687b      	ldr	r3, [r7, #4]
 800113a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800113c:	2208      	movs	r2, #8
 800113e:	409a      	lsls	r2, r3
 8001140:	693b      	ldr	r3, [r7, #16]
 8001142:	609a      	str	r2, [r3, #8]
      
      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8001144:	687b      	ldr	r3, [r7, #4]
 8001146:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001148:	f043 0201 	orr.w	r2, r3, #1
 800114c:	687b      	ldr	r3, [r7, #4]
 800114e:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* FIFO Error Interrupt management ******************************************/
  if ((tmpisr & (DMA_FLAG_FEIF0_4 << hdma->StreamIndex)) != RESET)
 8001150:	687b      	ldr	r3, [r7, #4]
 8001152:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001154:	2201      	movs	r2, #1
 8001156:	409a      	lsls	r2, r3
 8001158:	68fb      	ldr	r3, [r7, #12]
 800115a:	4013      	ands	r3, r2
 800115c:	2b00      	cmp	r3, #0
 800115e:	d012      	beq.n	8001186 <HAL_DMA_IRQHandler+0xa2>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != RESET)
 8001160:	687b      	ldr	r3, [r7, #4]
 8001162:	681b      	ldr	r3, [r3, #0]
 8001164:	695b      	ldr	r3, [r3, #20]
 8001166:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800116a:	2b00      	cmp	r3, #0
 800116c:	d00b      	beq.n	8001186 <HAL_DMA_IRQHandler+0xa2>
    {
      /* Clear the FIFO error flag */
      regs->IFCR = DMA_FLAG_FEIF0_4 << hdma->StreamIndex;
 800116e:	687b      	ldr	r3, [r7, #4]
 8001170:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001172:	2201      	movs	r2, #1
 8001174:	409a      	lsls	r2, r3
 8001176:	693b      	ldr	r3, [r7, #16]
 8001178:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 800117a:	687b      	ldr	r3, [r7, #4]
 800117c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800117e:	f043 0202 	orr.w	r2, r3, #2
 8001182:	687b      	ldr	r3, [r7, #4]
 8001184:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Direct Mode Error Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_DMEIF0_4 << hdma->StreamIndex)) != RESET)
 8001186:	687b      	ldr	r3, [r7, #4]
 8001188:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800118a:	2204      	movs	r2, #4
 800118c:	409a      	lsls	r2, r3
 800118e:	68fb      	ldr	r3, [r7, #12]
 8001190:	4013      	ands	r3, r2
 8001192:	2b00      	cmp	r3, #0
 8001194:	d012      	beq.n	80011bc <HAL_DMA_IRQHandler+0xd8>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != RESET)
 8001196:	687b      	ldr	r3, [r7, #4]
 8001198:	681b      	ldr	r3, [r3, #0]
 800119a:	681b      	ldr	r3, [r3, #0]
 800119c:	f003 0302 	and.w	r3, r3, #2
 80011a0:	2b00      	cmp	r3, #0
 80011a2:	d00b      	beq.n	80011bc <HAL_DMA_IRQHandler+0xd8>
    {
      /* Clear the direct mode error flag */
      regs->IFCR = DMA_FLAG_DMEIF0_4 << hdma->StreamIndex;
 80011a4:	687b      	ldr	r3, [r7, #4]
 80011a6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80011a8:	2204      	movs	r2, #4
 80011aa:	409a      	lsls	r2, r3
 80011ac:	693b      	ldr	r3, [r7, #16]
 80011ae:	609a      	str	r2, [r3, #8]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 80011b0:	687b      	ldr	r3, [r7, #4]
 80011b2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80011b4:	f043 0204 	orr.w	r2, r3, #4
 80011b8:	687b      	ldr	r3, [r7, #4]
 80011ba:	655a      	str	r2, [r3, #84]	; 0x54
    }
  }
  /* Half Transfer Complete Interrupt management ******************************/
  if ((tmpisr & (DMA_FLAG_HTIF0_4 << hdma->StreamIndex)) != RESET)
 80011bc:	687b      	ldr	r3, [r7, #4]
 80011be:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80011c0:	2210      	movs	r2, #16
 80011c2:	409a      	lsls	r2, r3
 80011c4:	68fb      	ldr	r3, [r7, #12]
 80011c6:	4013      	ands	r3, r2
 80011c8:	2b00      	cmp	r3, #0
 80011ca:	d043      	beq.n	8001254 <HAL_DMA_IRQHandler+0x170>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != RESET)
 80011cc:	687b      	ldr	r3, [r7, #4]
 80011ce:	681b      	ldr	r3, [r3, #0]
 80011d0:	681b      	ldr	r3, [r3, #0]
 80011d2:	f003 0308 	and.w	r3, r3, #8
 80011d6:	2b00      	cmp	r3, #0
 80011d8:	d03c      	beq.n	8001254 <HAL_DMA_IRQHandler+0x170>
    {
      /* Clear the half transfer complete flag */
      regs->IFCR = DMA_FLAG_HTIF0_4 << hdma->StreamIndex;
 80011da:	687b      	ldr	r3, [r7, #4]
 80011dc:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80011de:	2210      	movs	r2, #16
 80011e0:	409a      	lsls	r2, r3
 80011e2:	693b      	ldr	r3, [r7, #16]
 80011e4:	609a      	str	r2, [r3, #8]
      
      /* Multi_Buffering mode enabled */
      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80011e6:	687b      	ldr	r3, [r7, #4]
 80011e8:	681b      	ldr	r3, [r3, #0]
 80011ea:	681b      	ldr	r3, [r3, #0]
 80011ec:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80011f0:	2b00      	cmp	r3, #0
 80011f2:	d018      	beq.n	8001226 <HAL_DMA_IRQHandler+0x142>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 80011f4:	687b      	ldr	r3, [r7, #4]
 80011f6:	681b      	ldr	r3, [r3, #0]
 80011f8:	681b      	ldr	r3, [r3, #0]
 80011fa:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80011fe:	2b00      	cmp	r3, #0
 8001200:	d108      	bne.n	8001214 <HAL_DMA_IRQHandler+0x130>
        {
          if(hdma->XferHalfCpltCallback != NULL)
 8001202:	687b      	ldr	r3, [r7, #4]
 8001204:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001206:	2b00      	cmp	r3, #0
 8001208:	d024      	beq.n	8001254 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferHalfCpltCallback(hdma);
 800120a:	687b      	ldr	r3, [r7, #4]
 800120c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800120e:	6878      	ldr	r0, [r7, #4]
 8001210:	4798      	blx	r3
 8001212:	e01f      	b.n	8001254 <HAL_DMA_IRQHandler+0x170>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferM1HalfCpltCallback != NULL)
 8001214:	687b      	ldr	r3, [r7, #4]
 8001216:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001218:	2b00      	cmp	r3, #0
 800121a:	d01b      	beq.n	8001254 <HAL_DMA_IRQHandler+0x170>
          {
            /* Half transfer callback */
            hdma->XferM1HalfCpltCallback(hdma);
 800121c:	687b      	ldr	r3, [r7, #4]
 800121e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001220:	6878      	ldr	r0, [r7, #4]
 8001222:	4798      	blx	r3
 8001224:	e016      	b.n	8001254 <HAL_DMA_IRQHandler+0x170>
        }
      }
      else
      {
        /* Disable the half transfer interrupt if the DMA mode is not CIRCULAR */
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001226:	687b      	ldr	r3, [r7, #4]
 8001228:	681b      	ldr	r3, [r3, #0]
 800122a:	681b      	ldr	r3, [r3, #0]
 800122c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001230:	2b00      	cmp	r3, #0
 8001232:	d107      	bne.n	8001244 <HAL_DMA_IRQHandler+0x160>
        {
          /* Disable the half transfer interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 8001234:	687b      	ldr	r3, [r7, #4]
 8001236:	681b      	ldr	r3, [r3, #0]
 8001238:	681a      	ldr	r2, [r3, #0]
 800123a:	687b      	ldr	r3, [r7, #4]
 800123c:	681b      	ldr	r3, [r3, #0]
 800123e:	f022 0208 	bic.w	r2, r2, #8
 8001242:	601a      	str	r2, [r3, #0]
        }
        
        if(hdma->XferHalfCpltCallback != NULL)
 8001244:	687b      	ldr	r3, [r7, #4]
 8001246:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001248:	2b00      	cmp	r3, #0
 800124a:	d003      	beq.n	8001254 <HAL_DMA_IRQHandler+0x170>
        {
          /* Half transfer callback */
          hdma->XferHalfCpltCallback(hdma);
 800124c:	687b      	ldr	r3, [r7, #4]
 800124e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001250:	6878      	ldr	r0, [r7, #4]
 8001252:	4798      	blx	r3
        }
      }
    }
  }
  /* Transfer Complete Interrupt management ***********************************/
  if ((tmpisr & (DMA_FLAG_TCIF0_4 << hdma->StreamIndex)) != RESET)
 8001254:	687b      	ldr	r3, [r7, #4]
 8001256:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001258:	2220      	movs	r2, #32
 800125a:	409a      	lsls	r2, r3
 800125c:	68fb      	ldr	r3, [r7, #12]
 800125e:	4013      	ands	r3, r2
 8001260:	2b00      	cmp	r3, #0
 8001262:	f000 808e 	beq.w	8001382 <HAL_DMA_IRQHandler+0x29e>
  {
    if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != RESET)
 8001266:	687b      	ldr	r3, [r7, #4]
 8001268:	681b      	ldr	r3, [r3, #0]
 800126a:	681b      	ldr	r3, [r3, #0]
 800126c:	f003 0310 	and.w	r3, r3, #16
 8001270:	2b00      	cmp	r3, #0
 8001272:	f000 8086 	beq.w	8001382 <HAL_DMA_IRQHandler+0x29e>
    {
      /* Clear the transfer complete flag */
      regs->IFCR = DMA_FLAG_TCIF0_4 << hdma->StreamIndex;
 8001276:	687b      	ldr	r3, [r7, #4]
 8001278:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800127a:	2220      	movs	r2, #32
 800127c:	409a      	lsls	r2, r3
 800127e:	693b      	ldr	r3, [r7, #16]
 8001280:	609a      	str	r2, [r3, #8]
      
      if(HAL_DMA_STATE_ABORT == hdma->State)
 8001282:	687b      	ldr	r3, [r7, #4]
 8001284:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8001288:	b2db      	uxtb	r3, r3
 800128a:	2b05      	cmp	r3, #5
 800128c:	d136      	bne.n	80012fc <HAL_DMA_IRQHandler+0x218>
      {
        /* Disable all the transfer interrupts */
        hdma->Instance->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 800128e:	687b      	ldr	r3, [r7, #4]
 8001290:	681b      	ldr	r3, [r3, #0]
 8001292:	681a      	ldr	r2, [r3, #0]
 8001294:	687b      	ldr	r3, [r7, #4]
 8001296:	681b      	ldr	r3, [r3, #0]
 8001298:	f022 0216 	bic.w	r2, r2, #22
 800129c:	601a      	str	r2, [r3, #0]
        hdma->Instance->FCR &= ~(DMA_IT_FE);
 800129e:	687b      	ldr	r3, [r7, #4]
 80012a0:	681b      	ldr	r3, [r3, #0]
 80012a2:	695a      	ldr	r2, [r3, #20]
 80012a4:	687b      	ldr	r3, [r7, #4]
 80012a6:	681b      	ldr	r3, [r3, #0]
 80012a8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80012ac:	615a      	str	r2, [r3, #20]
        
        if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 80012ae:	687b      	ldr	r3, [r7, #4]
 80012b0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80012b2:	2b00      	cmp	r3, #0
 80012b4:	d103      	bne.n	80012be <HAL_DMA_IRQHandler+0x1da>
 80012b6:	687b      	ldr	r3, [r7, #4]
 80012b8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80012ba:	2b00      	cmp	r3, #0
 80012bc:	d007      	beq.n	80012ce <HAL_DMA_IRQHandler+0x1ea>
        {
          hdma->Instance->CR  &= ~(DMA_IT_HT);
 80012be:	687b      	ldr	r3, [r7, #4]
 80012c0:	681b      	ldr	r3, [r3, #0]
 80012c2:	681a      	ldr	r2, [r3, #0]
 80012c4:	687b      	ldr	r3, [r7, #4]
 80012c6:	681b      	ldr	r3, [r3, #0]
 80012c8:	f022 0208 	bic.w	r2, r2, #8
 80012cc:	601a      	str	r2, [r3, #0]
        }

        /* Clear all interrupt flags at correct offset within the register */
        regs->IFCR = 0x3FU << hdma->StreamIndex;
 80012ce:	687b      	ldr	r3, [r7, #4]
 80012d0:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80012d2:	223f      	movs	r2, #63	; 0x3f
 80012d4:	409a      	lsls	r2, r3
 80012d6:	693b      	ldr	r3, [r7, #16]
 80012d8:	609a      	str	r2, [r3, #8]

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
 80012da:	687b      	ldr	r3, [r7, #4]
 80012dc:	2200      	movs	r2, #0
 80012de:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

        /* Change the DMA state */
        hdma->State = HAL_DMA_STATE_READY;
 80012e2:	687b      	ldr	r3, [r7, #4]
 80012e4:	2201      	movs	r2, #1
 80012e6:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

        if(hdma->XferAbortCallback != NULL)
 80012ea:	687b      	ldr	r3, [r7, #4]
 80012ec:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80012ee:	2b00      	cmp	r3, #0
 80012f0:	d07d      	beq.n	80013ee <HAL_DMA_IRQHandler+0x30a>
        {
          hdma->XferAbortCallback(hdma);
 80012f2:	687b      	ldr	r3, [r7, #4]
 80012f4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80012f6:	6878      	ldr	r0, [r7, #4]
 80012f8:	4798      	blx	r3
        }
        return;
 80012fa:	e078      	b.n	80013ee <HAL_DMA_IRQHandler+0x30a>
      }

      if(((hdma->Instance->CR) & (uint32_t)(DMA_SxCR_DBM)) != RESET)
 80012fc:	687b      	ldr	r3, [r7, #4]
 80012fe:	681b      	ldr	r3, [r3, #0]
 8001300:	681b      	ldr	r3, [r3, #0]
 8001302:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001306:	2b00      	cmp	r3, #0
 8001308:	d01c      	beq.n	8001344 <HAL_DMA_IRQHandler+0x260>
      {
        /* Current memory buffer used is Memory 0 */
        if((hdma->Instance->CR & DMA_SxCR_CT) == RESET)
 800130a:	687b      	ldr	r3, [r7, #4]
 800130c:	681b      	ldr	r3, [r3, #0]
 800130e:	681b      	ldr	r3, [r3, #0]
 8001310:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8001314:	2b00      	cmp	r3, #0
 8001316:	d108      	bne.n	800132a <HAL_DMA_IRQHandler+0x246>
        {
          if(hdma->XferM1CpltCallback != NULL)
 8001318:	687b      	ldr	r3, [r7, #4]
 800131a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800131c:	2b00      	cmp	r3, #0
 800131e:	d030      	beq.n	8001382 <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory1 */
            hdma->XferM1CpltCallback(hdma);
 8001320:	687b      	ldr	r3, [r7, #4]
 8001322:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001324:	6878      	ldr	r0, [r7, #4]
 8001326:	4798      	blx	r3
 8001328:	e02b      	b.n	8001382 <HAL_DMA_IRQHandler+0x29e>
          }
        }
        /* Current memory buffer used is Memory 1 */
        else
        {
          if(hdma->XferCpltCallback != NULL)
 800132a:	687b      	ldr	r3, [r7, #4]
 800132c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800132e:	2b00      	cmp	r3, #0
 8001330:	d027      	beq.n	8001382 <HAL_DMA_IRQHandler+0x29e>
          {
            /* Transfer complete Callback for memory0 */
            hdma->XferCpltCallback(hdma);
 8001332:	687b      	ldr	r3, [r7, #4]
 8001334:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001336:	6878      	ldr	r0, [r7, #4]
 8001338:	4798      	blx	r3
 800133a:	e022      	b.n	8001382 <HAL_DMA_IRQHandler+0x29e>
 800133c:	20000004 	.word	0x20000004
 8001340:	1b4e81b5 	.word	0x1b4e81b5
        }
      }
      /* Disable the transfer complete interrupt if the DMA mode is not CIRCULAR */
      else
      {
        if((hdma->Instance->CR & DMA_SxCR_CIRC) == RESET)
 8001344:	687b      	ldr	r3, [r7, #4]
 8001346:	681b      	ldr	r3, [r3, #0]
 8001348:	681b      	ldr	r3, [r3, #0]
 800134a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800134e:	2b00      	cmp	r3, #0
 8001350:	d10f      	bne.n	8001372 <HAL_DMA_IRQHandler+0x28e>
        {
          /* Disable the transfer complete interrupt */
          hdma->Instance->CR  &= ~(DMA_IT_TC);
 8001352:	687b      	ldr	r3, [r7, #4]
 8001354:	681b      	ldr	r3, [r3, #0]
 8001356:	681a      	ldr	r2, [r3, #0]
 8001358:	687b      	ldr	r3, [r7, #4]
 800135a:	681b      	ldr	r3, [r3, #0]
 800135c:	f022 0210 	bic.w	r2, r2, #16
 8001360:	601a      	str	r2, [r3, #0]

          /* Process Unlocked */
          __HAL_UNLOCK(hdma);
 8001362:	687b      	ldr	r3, [r7, #4]
 8001364:	2200      	movs	r2, #0
 8001366:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

          /* Change the DMA state */
          hdma->State = HAL_DMA_STATE_READY;
 800136a:	687b      	ldr	r3, [r7, #4]
 800136c:	2201      	movs	r2, #1
 800136e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
        }

        if(hdma->XferCpltCallback != NULL)
 8001372:	687b      	ldr	r3, [r7, #4]
 8001374:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001376:	2b00      	cmp	r3, #0
 8001378:	d003      	beq.n	8001382 <HAL_DMA_IRQHandler+0x29e>
        {
          /* Transfer complete callback */
          hdma->XferCpltCallback(hdma);
 800137a:	687b      	ldr	r3, [r7, #4]
 800137c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800137e:	6878      	ldr	r0, [r7, #4]
 8001380:	4798      	blx	r3
      }
    }
  }
  
  /* manage error case */
  if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8001382:	687b      	ldr	r3, [r7, #4]
 8001384:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001386:	2b00      	cmp	r3, #0
 8001388:	d032      	beq.n	80013f0 <HAL_DMA_IRQHandler+0x30c>
  {
    if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != RESET)
 800138a:	687b      	ldr	r3, [r7, #4]
 800138c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800138e:	f003 0301 	and.w	r3, r3, #1
 8001392:	2b00      	cmp	r3, #0
 8001394:	d022      	beq.n	80013dc <HAL_DMA_IRQHandler+0x2f8>
    {
      hdma->State = HAL_DMA_STATE_ABORT;
 8001396:	687b      	ldr	r3, [r7, #4]
 8001398:	2205      	movs	r2, #5
 800139a:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35

      /* Disable the stream */
      __HAL_DMA_DISABLE(hdma);
 800139e:	687b      	ldr	r3, [r7, #4]
 80013a0:	681b      	ldr	r3, [r3, #0]
 80013a2:	681a      	ldr	r2, [r3, #0]
 80013a4:	687b      	ldr	r3, [r7, #4]
 80013a6:	681b      	ldr	r3, [r3, #0]
 80013a8:	f022 0201 	bic.w	r2, r2, #1
 80013ac:	601a      	str	r2, [r3, #0]

      do
      {
        if (++count > timeout)
 80013ae:	68bb      	ldr	r3, [r7, #8]
 80013b0:	3301      	adds	r3, #1
 80013b2:	60bb      	str	r3, [r7, #8]
 80013b4:	697a      	ldr	r2, [r7, #20]
 80013b6:	429a      	cmp	r2, r3
 80013b8:	d307      	bcc.n	80013ca <HAL_DMA_IRQHandler+0x2e6>
        {
          break;
        }
      }
      while((hdma->Instance->CR & DMA_SxCR_EN) != RESET);
 80013ba:	687b      	ldr	r3, [r7, #4]
 80013bc:	681b      	ldr	r3, [r3, #0]
 80013be:	681b      	ldr	r3, [r3, #0]
 80013c0:	f003 0301 	and.w	r3, r3, #1
 80013c4:	2b00      	cmp	r3, #0
 80013c6:	d1f2      	bne.n	80013ae <HAL_DMA_IRQHandler+0x2ca>
 80013c8:	e000      	b.n	80013cc <HAL_DMA_IRQHandler+0x2e8>
          break;
 80013ca:	bf00      	nop

      /* Process Unlocked */
      __HAL_UNLOCK(hdma);
 80013cc:	687b      	ldr	r3, [r7, #4]
 80013ce:	2200      	movs	r2, #0
 80013d0:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 80013d4:	687b      	ldr	r3, [r7, #4]
 80013d6:	2201      	movs	r2, #1
 80013d8:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    }

    if(hdma->XferErrorCallback != NULL)
 80013dc:	687b      	ldr	r3, [r7, #4]
 80013de:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80013e0:	2b00      	cmp	r3, #0
 80013e2:	d005      	beq.n	80013f0 <HAL_DMA_IRQHandler+0x30c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 80013e4:	687b      	ldr	r3, [r7, #4]
 80013e6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80013e8:	6878      	ldr	r0, [r7, #4]
 80013ea:	4798      	blx	r3
 80013ec:	e000      	b.n	80013f0 <HAL_DMA_IRQHandler+0x30c>
        return;
 80013ee:	bf00      	nop
    }
  }
}
 80013f0:	3718      	adds	r7, #24
 80013f2:	46bd      	mov	sp, r7
 80013f4:	bd80      	pop	{r7, pc}
 80013f6:	bf00      	nop

080013f8 <HAL_DMA_RegisterCallback>:
  * @param  pCallback            pointer to private callbacsk function which has pointer to 
  *                               a DMA_HandleTypeDef structure as parameter.
  * @retval HAL status
  */                      
HAL_StatusTypeDef HAL_DMA_RegisterCallback(DMA_HandleTypeDef *hdma, HAL_DMA_CallbackIDTypeDef CallbackID, void (* pCallback)(DMA_HandleTypeDef *_hdma))
{
 80013f8:	b480      	push	{r7}
 80013fa:	b087      	sub	sp, #28
 80013fc:	af00      	add	r7, sp, #0
 80013fe:	60f8      	str	r0, [r7, #12]
 8001400:	460b      	mov	r3, r1
 8001402:	607a      	str	r2, [r7, #4]
 8001404:	72fb      	strb	r3, [r7, #11]

  HAL_StatusTypeDef status = HAL_OK;
 8001406:	2300      	movs	r3, #0
 8001408:	75fb      	strb	r3, [r7, #23]

  /* Process locked */
  __HAL_LOCK(hdma);
 800140a:	68fb      	ldr	r3, [r7, #12]
 800140c:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
 8001410:	2b01      	cmp	r3, #1
 8001412:	d101      	bne.n	8001418 <HAL_DMA_RegisterCallback+0x20>
 8001414:	2302      	movs	r3, #2
 8001416:	e03c      	b.n	8001492 <HAL_DMA_RegisterCallback+0x9a>
 8001418:	68fb      	ldr	r3, [r7, #12]
 800141a:	2201      	movs	r2, #1
 800141c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34

  if(HAL_DMA_STATE_READY == hdma->State)
 8001420:	68fb      	ldr	r3, [r7, #12]
 8001422:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8001426:	b2db      	uxtb	r3, r3
 8001428:	2b01      	cmp	r3, #1
 800142a:	d129      	bne.n	8001480 <HAL_DMA_RegisterCallback+0x88>
  {
    switch (CallbackID)
 800142c:	7afb      	ldrb	r3, [r7, #11]
 800142e:	2b05      	cmp	r3, #5
 8001430:	d829      	bhi.n	8001486 <HAL_DMA_RegisterCallback+0x8e>
 8001432:	a201      	add	r2, pc, #4	; (adr r2, 8001438 <HAL_DMA_RegisterCallback+0x40>)
 8001434:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8001438:	08001451 	.word	0x08001451
 800143c:	08001459 	.word	0x08001459
 8001440:	08001461 	.word	0x08001461
 8001444:	08001469 	.word	0x08001469
 8001448:	08001471 	.word	0x08001471
 800144c:	08001479 	.word	0x08001479
    {
    case  HAL_DMA_XFER_CPLT_CB_ID:
      hdma->XferCpltCallback = pCallback;
 8001450:	68fb      	ldr	r3, [r7, #12]
 8001452:	687a      	ldr	r2, [r7, #4]
 8001454:	63da      	str	r2, [r3, #60]	; 0x3c
      break;
 8001456:	e017      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_HALFCPLT_CB_ID:
      hdma->XferHalfCpltCallback = pCallback;
 8001458:	68fb      	ldr	r3, [r7, #12]
 800145a:	687a      	ldr	r2, [r7, #4]
 800145c:	641a      	str	r2, [r3, #64]	; 0x40
      break;
 800145e:	e013      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_M1CPLT_CB_ID:
      hdma->XferM1CpltCallback = pCallback;
 8001460:	68fb      	ldr	r3, [r7, #12]
 8001462:	687a      	ldr	r2, [r7, #4]
 8001464:	645a      	str	r2, [r3, #68]	; 0x44
      break;
 8001466:	e00f      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_M1HALFCPLT_CB_ID:
      hdma->XferM1HalfCpltCallback = pCallback;
 8001468:	68fb      	ldr	r3, [r7, #12]
 800146a:	687a      	ldr	r2, [r7, #4]
 800146c:	649a      	str	r2, [r3, #72]	; 0x48
      break;
 800146e:	e00b      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_ERROR_CB_ID:
      hdma->XferErrorCallback = pCallback;
 8001470:	68fb      	ldr	r3, [r7, #12]
 8001472:	687a      	ldr	r2, [r7, #4]
 8001474:	64da      	str	r2, [r3, #76]	; 0x4c
      break;
 8001476:	e007      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>

    case  HAL_DMA_XFER_ABORT_CB_ID:
      hdma->XferAbortCallback = pCallback;
 8001478:	68fb      	ldr	r3, [r7, #12]
 800147a:	687a      	ldr	r2, [r7, #4]
 800147c:	651a      	str	r2, [r3, #80]	; 0x50
      break;
 800147e:	e003      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>
    }
  }
  else
  {
    /* Return error status */
    status =  HAL_ERROR;
 8001480:	2301      	movs	r3, #1
 8001482:	75fb      	strb	r3, [r7, #23]
 8001484:	e000      	b.n	8001488 <HAL_DMA_RegisterCallback+0x90>
      break;
 8001486:	bf00      	nop
  }

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8001488:	68fb      	ldr	r3, [r7, #12]
 800148a:	2200      	movs	r2, #0
 800148c:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  
  return status;
 8001490:	7dfb      	ldrb	r3, [r7, #23]
}
 8001492:	4618      	mov	r0, r3
 8001494:	371c      	adds	r7, #28
 8001496:	46bd      	mov	sp, r7
 8001498:	f85d 7b04 	ldr.w	r7, [sp], #4
 800149c:	4770      	bx	lr
 800149e:	bf00      	nop

080014a0 <DMA_SetConfig>:
  * @param  DstAddress The destination memory Buffer address
  * @param  DataLength The length of data to be transferred from source to destination
  * @retval HAL status
  */
static void DMA_SetConfig(DMA_HandleTypeDef *hdma, uint32_t SrcAddress, uint32_t DstAddress, uint32_t DataLength)
{
 80014a0:	b480      	push	{r7}
 80014a2:	b085      	sub	sp, #20
 80014a4:	af00      	add	r7, sp, #0
 80014a6:	60f8      	str	r0, [r7, #12]
 80014a8:	60b9      	str	r1, [r7, #8]
 80014aa:	607a      	str	r2, [r7, #4]
 80014ac:	603b      	str	r3, [r7, #0]
  /* Clear DBM bit */
  hdma->Instance->CR &= (uint32_t)(~DMA_SxCR_DBM);
 80014ae:	68fb      	ldr	r3, [r7, #12]
 80014b0:	681b      	ldr	r3, [r3, #0]
 80014b2:	681a      	ldr	r2, [r3, #0]
 80014b4:	68fb      	ldr	r3, [r7, #12]
 80014b6:	681b      	ldr	r3, [r3, #0]
 80014b8:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80014bc:	601a      	str	r2, [r3, #0]

  /* Configure DMA Stream data length */
  hdma->Instance->NDTR = DataLength;
 80014be:	68fb      	ldr	r3, [r7, #12]
 80014c0:	681b      	ldr	r3, [r3, #0]
 80014c2:	683a      	ldr	r2, [r7, #0]
 80014c4:	605a      	str	r2, [r3, #4]

  /* Memory to Peripheral */
  if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 80014c6:	68fb      	ldr	r3, [r7, #12]
 80014c8:	689b      	ldr	r3, [r3, #8]
 80014ca:	2b40      	cmp	r3, #64	; 0x40
 80014cc:	d108      	bne.n	80014e0 <DMA_SetConfig+0x40>
  {
    /* Configure DMA Stream destination address */
    hdma->Instance->PAR = DstAddress;
 80014ce:	68fb      	ldr	r3, [r7, #12]
 80014d0:	681b      	ldr	r3, [r3, #0]
 80014d2:	687a      	ldr	r2, [r7, #4]
 80014d4:	609a      	str	r2, [r3, #8]

    /* Configure DMA Stream source address */
    hdma->Instance->M0AR = SrcAddress;
 80014d6:	68fb      	ldr	r3, [r7, #12]
 80014d8:	681b      	ldr	r3, [r3, #0]
 80014da:	68ba      	ldr	r2, [r7, #8]
 80014dc:	60da      	str	r2, [r3, #12]
    hdma->Instance->PAR = SrcAddress;

    /* Configure DMA Stream destination address */
    hdma->Instance->M0AR = DstAddress;
  }
}
 80014de:	e007      	b.n	80014f0 <DMA_SetConfig+0x50>
    hdma->Instance->PAR = SrcAddress;
 80014e0:	68fb      	ldr	r3, [r7, #12]
 80014e2:	681b      	ldr	r3, [r3, #0]
 80014e4:	68ba      	ldr	r2, [r7, #8]
 80014e6:	609a      	str	r2, [r3, #8]
    hdma->Instance->M0AR = DstAddress;
 80014e8:	68fb      	ldr	r3, [r7, #12]
 80014ea:	681b      	ldr	r3, [r3, #0]
 80014ec:	687a      	ldr	r2, [r7, #4]
 80014ee:	60da      	str	r2, [r3, #12]
}
 80014f0:	bf00      	nop
 80014f2:	3714      	adds	r7, #20
 80014f4:	46bd      	mov	sp, r7
 80014f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80014fa:	4770      	bx	lr

080014fc <DMA_CalcBaseAndBitshift>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80014fc:	b480      	push	{r7}
 80014fe:	b085      	sub	sp, #20
 8001500:	af00      	add	r7, sp, #0
 8001502:	6078      	str	r0, [r7, #4]
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001504:	687b      	ldr	r3, [r7, #4]
 8001506:	681b      	ldr	r3, [r3, #0]
 8001508:	b2db      	uxtb	r3, r3
 800150a:	3b10      	subs	r3, #16
 800150c:	4a13      	ldr	r2, [pc, #76]	; (800155c <DMA_CalcBaseAndBitshift+0x60>)
 800150e:	fba2 2303 	umull	r2, r3, r2, r3
 8001512:	091b      	lsrs	r3, r3, #4
 8001514:	60fb      	str	r3, [r7, #12]
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001516:	4a12      	ldr	r2, [pc, #72]	; (8001560 <DMA_CalcBaseAndBitshift+0x64>)
 8001518:	68fb      	ldr	r3, [r7, #12]
 800151a:	4413      	add	r3, r2
 800151c:	781b      	ldrb	r3, [r3, #0]
 800151e:	461a      	mov	r2, r3
 8001520:	687b      	ldr	r3, [r7, #4]
 8001522:	65da      	str	r2, [r3, #92]	; 0x5c
  
  if (stream_number > 3U)
 8001524:	68fb      	ldr	r3, [r7, #12]
 8001526:	2b03      	cmp	r3, #3
 8001528:	d908      	bls.n	800153c <DMA_CalcBaseAndBitshift+0x40>
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 800152a:	687b      	ldr	r3, [r7, #4]
 800152c:	681b      	ldr	r3, [r3, #0]
 800152e:	461a      	mov	r2, r3
 8001530:	4b0c      	ldr	r3, [pc, #48]	; (8001564 <DMA_CalcBaseAndBitshift+0x68>)
 8001532:	4013      	ands	r3, r2
 8001534:	1d1a      	adds	r2, r3, #4
 8001536:	687b      	ldr	r3, [r7, #4]
 8001538:	659a      	str	r2, [r3, #88]	; 0x58
 800153a:	e006      	b.n	800154a <DMA_CalcBaseAndBitshift+0x4e>
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 800153c:	687b      	ldr	r3, [r7, #4]
 800153e:	681b      	ldr	r3, [r3, #0]
 8001540:	461a      	mov	r2, r3
 8001542:	4b08      	ldr	r3, [pc, #32]	; (8001564 <DMA_CalcBaseAndBitshift+0x68>)
 8001544:	4013      	ands	r3, r2
 8001546:	687a      	ldr	r2, [r7, #4]
 8001548:	6593      	str	r3, [r2, #88]	; 0x58
  }
  
  return hdma->StreamBaseAddress;
 800154a:	687b      	ldr	r3, [r7, #4]
 800154c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
}
 800154e:	4618      	mov	r0, r3
 8001550:	3714      	adds	r7, #20
 8001552:	46bd      	mov	sp, r7
 8001554:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001558:	4770      	bx	lr
 800155a:	bf00      	nop
 800155c:	aaaaaaab 	.word	0xaaaaaaab
 8001560:	08029144 	.word	0x08029144
 8001564:	fffffc00 	.word	0xfffffc00

08001568 <DMA_CheckFifoParam>:
  * @param  hdma       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream. 
  * @retval HAL status
  */
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
 8001568:	b480      	push	{r7}
 800156a:	b085      	sub	sp, #20
 800156c:	af00      	add	r7, sp, #0
 800156e:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
 8001570:	2300      	movs	r3, #0
 8001572:	73fb      	strb	r3, [r7, #15]
  uint32_t tmp = hdma->Init.FIFOThreshold;
 8001574:	687b      	ldr	r3, [r7, #4]
 8001576:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001578:	60bb      	str	r3, [r7, #8]
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 800157a:	687b      	ldr	r3, [r7, #4]
 800157c:	699b      	ldr	r3, [r3, #24]
 800157e:	2b00      	cmp	r3, #0
 8001580:	d11f      	bne.n	80015c2 <DMA_CheckFifoParam+0x5a>
  {
    switch (tmp)
 8001582:	68bb      	ldr	r3, [r7, #8]
 8001584:	2b03      	cmp	r3, #3
 8001586:	d855      	bhi.n	8001634 <DMA_CheckFifoParam+0xcc>
 8001588:	a201      	add	r2, pc, #4	; (adr r2, 8001590 <DMA_CheckFifoParam+0x28>)
 800158a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800158e:	bf00      	nop
 8001590:	080015a1 	.word	0x080015a1
 8001594:	080015b3 	.word	0x080015b3
 8001598:	080015a1 	.word	0x080015a1
 800159c:	08001635 	.word	0x08001635
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80015a0:	687b      	ldr	r3, [r7, #4]
 80015a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015a4:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80015a8:	2b00      	cmp	r3, #0
 80015aa:	d045      	beq.n	8001638 <DMA_CheckFifoParam+0xd0>
      {
        status = HAL_ERROR;
 80015ac:	2301      	movs	r3, #1
 80015ae:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80015b0:	e042      	b.n	8001638 <DMA_CheckFifoParam+0xd0>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 80015b2:	687b      	ldr	r3, [r7, #4]
 80015b4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015b6:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 80015ba:	d13f      	bne.n	800163c <DMA_CheckFifoParam+0xd4>
      {
        status = HAL_ERROR;
 80015bc:	2301      	movs	r3, #1
 80015be:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80015c0:	e03c      	b.n	800163c <DMA_CheckFifoParam+0xd4>
      break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 80015c2:	687b      	ldr	r3, [r7, #4]
 80015c4:	699b      	ldr	r3, [r3, #24]
 80015c6:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 80015ca:	d121      	bne.n	8001610 <DMA_CheckFifoParam+0xa8>
  {
    switch (tmp)
 80015cc:	68bb      	ldr	r3, [r7, #8]
 80015ce:	2b03      	cmp	r3, #3
 80015d0:	d836      	bhi.n	8001640 <DMA_CheckFifoParam+0xd8>
 80015d2:	a201      	add	r2, pc, #4	; (adr r2, 80015d8 <DMA_CheckFifoParam+0x70>)
 80015d4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80015d8:	080015e9 	.word	0x080015e9
 80015dc:	080015ef 	.word	0x080015ef
 80015e0:	080015e9 	.word	0x080015e9
 80015e4:	08001601 	.word	0x08001601
    {
    case DMA_FIFO_THRESHOLD_1QUARTERFULL:
    case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
      status = HAL_ERROR;
 80015e8:	2301      	movs	r3, #1
 80015ea:	73fb      	strb	r3, [r7, #15]
      break;
 80015ec:	e02f      	b.n	800164e <DMA_CheckFifoParam+0xe6>
    case DMA_FIFO_THRESHOLD_HALFFULL:
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 80015ee:	687b      	ldr	r3, [r7, #4]
 80015f0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015f2:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80015f6:	2b00      	cmp	r3, #0
 80015f8:	d024      	beq.n	8001644 <DMA_CheckFifoParam+0xdc>
      {
        status = HAL_ERROR;
 80015fa:	2301      	movs	r3, #1
 80015fc:	73fb      	strb	r3, [r7, #15]
      }
      break;
 80015fe:	e021      	b.n	8001644 <DMA_CheckFifoParam+0xdc>
    case DMA_FIFO_THRESHOLD_FULL:
      if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8001600:	687b      	ldr	r3, [r7, #4]
 8001602:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001604:	f1b3 7fc0 	cmp.w	r3, #25165824	; 0x1800000
 8001608:	d11e      	bne.n	8001648 <DMA_CheckFifoParam+0xe0>
      {
        status = HAL_ERROR;
 800160a:	2301      	movs	r3, #1
 800160c:	73fb      	strb	r3, [r7, #15]
      }
      break;   
 800160e:	e01b      	b.n	8001648 <DMA_CheckFifoParam+0xe0>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8001610:	68bb      	ldr	r3, [r7, #8]
 8001612:	2b02      	cmp	r3, #2
 8001614:	d902      	bls.n	800161c <DMA_CheckFifoParam+0xb4>
 8001616:	2b03      	cmp	r3, #3
 8001618:	d003      	beq.n	8001622 <DMA_CheckFifoParam+0xba>
      {
        status = HAL_ERROR;
      }
      break;
    default:
      break;
 800161a:	e018      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      status = HAL_ERROR;
 800161c:	2301      	movs	r3, #1
 800161e:	73fb      	strb	r3, [r7, #15]
      break;
 8001620:	e015      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8001622:	687b      	ldr	r3, [r7, #4]
 8001624:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001626:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 800162a:	2b00      	cmp	r3, #0
 800162c:	d00e      	beq.n	800164c <DMA_CheckFifoParam+0xe4>
        status = HAL_ERROR;
 800162e:	2301      	movs	r3, #1
 8001630:	73fb      	strb	r3, [r7, #15]
      break;
 8001632:	e00b      	b.n	800164c <DMA_CheckFifoParam+0xe4>
      break;
 8001634:	bf00      	nop
 8001636:	e00a      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      break;
 8001638:	bf00      	nop
 800163a:	e008      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      break;
 800163c:	bf00      	nop
 800163e:	e006      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      break;
 8001640:	bf00      	nop
 8001642:	e004      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      break;
 8001644:	bf00      	nop
 8001646:	e002      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      break;   
 8001648:	bf00      	nop
 800164a:	e000      	b.n	800164e <DMA_CheckFifoParam+0xe6>
      break;
 800164c:	bf00      	nop
    }
  } 
  
  return status; 
 800164e:	7bfb      	ldrb	r3, [r7, #15]
}
 8001650:	4618      	mov	r0, r3
 8001652:	3714      	adds	r7, #20
 8001654:	46bd      	mov	sp, r7
 8001656:	f85d 7b04 	ldr.w	r7, [sp], #4
 800165a:	4770      	bx	lr

0800165c <HAL_DMA2D_Init>:
  * @param  hdma2d pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
 800165c:	b580      	push	{r7, lr}
 800165e:	b082      	sub	sp, #8
 8001660:	af00      	add	r7, sp, #0
 8001662:	6078      	str	r0, [r7, #4]
  /* Check the DMA2D peripheral state */
  if(hdma2d == NULL)
 8001664:	687b      	ldr	r3, [r7, #4]
 8001666:	2b00      	cmp	r3, #0
 8001668:	d101      	bne.n	800166e <HAL_DMA2D_Init+0x12>
  {
     return HAL_ERROR;
 800166a:	2301      	movs	r3, #1
 800166c:	e039      	b.n	80016e2 <HAL_DMA2D_Init+0x86>

    /* Init the low level hardware */
    hdma2d->MspInitCallback(hdma2d);
  }
#else
  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 800166e:	687b      	ldr	r3, [r7, #4]
 8001670:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8001674:	b2db      	uxtb	r3, r3
 8001676:	2b00      	cmp	r3, #0
 8001678:	d106      	bne.n	8001688 <HAL_DMA2D_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
 800167a:	687b      	ldr	r3, [r7, #4]
 800167c:	2200      	movs	r2, #0
 800167e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
 8001682:	6878      	ldr	r0, [r7, #4]
 8001684:	f008 f9be 	bl	8009a04 <HAL_DMA2D_MspInit>
  }
#endif /* (USE_HAL_DMA2D_REGISTER_CALLBACKS) */

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001688:	687b      	ldr	r3, [r7, #4]
 800168a:	2202      	movs	r2, #2
 800168c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001690:	687b      	ldr	r3, [r7, #4]
 8001692:	681b      	ldr	r3, [r3, #0]
 8001694:	681b      	ldr	r3, [r3, #0]
 8001696:	f423 3140 	bic.w	r1, r3, #196608	; 0x30000
 800169a:	687b      	ldr	r3, [r7, #4]
 800169c:	685a      	ldr	r2, [r3, #4]
 800169e:	687b      	ldr	r3, [r7, #4]
 80016a0:	681b      	ldr	r3, [r3, #0]
 80016a2:	430a      	orrs	r2, r1
 80016a4:	601a      	str	r2, [r3, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 80016a6:	687b      	ldr	r3, [r7, #4]
 80016a8:	681b      	ldr	r3, [r3, #0]
 80016aa:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80016ac:	f023 0107 	bic.w	r1, r3, #7
 80016b0:	687b      	ldr	r3, [r7, #4]
 80016b2:	689a      	ldr	r2, [r3, #8]
 80016b4:	687b      	ldr	r3, [r7, #4]
 80016b6:	681b      	ldr	r3, [r3, #0]
 80016b8:	430a      	orrs	r2, r1
 80016ba:	635a      	str	r2, [r3, #52]	; 0x34

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);
 80016bc:	687b      	ldr	r3, [r7, #4]
 80016be:	681b      	ldr	r3, [r3, #0]
 80016c0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80016c2:	4b0a      	ldr	r3, [pc, #40]	; (80016ec <HAL_DMA2D_Init+0x90>)
 80016c4:	4013      	ands	r3, r2
 80016c6:	687a      	ldr	r2, [r7, #4]
 80016c8:	68d1      	ldr	r1, [r2, #12]
 80016ca:	687a      	ldr	r2, [r7, #4]
 80016cc:	6812      	ldr	r2, [r2, #0]
 80016ce:	430b      	orrs	r3, r1
 80016d0:	6413      	str	r3, [r2, #64]	; 0x40
  MODIFY_REG(hdma2d->Instance->OPFCCR,(DMA2D_OPFCCR_AI|DMA2D_OPFCCR_RBS), ((hdma2d->Init.AlphaInverted << DMA2D_OPFCCR_AI_Pos) | (hdma2d->Init.RedBlueSwap << DMA2D_OPFCCR_RBS_Pos)));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 80016d2:	687b      	ldr	r3, [r7, #4]
 80016d4:	2200      	movs	r2, #0
 80016d6:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 80016d8:	687b      	ldr	r3, [r7, #4]
 80016da:	2201      	movs	r2, #1
 80016dc:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  return HAL_OK;
 80016e0:	2300      	movs	r3, #0
}
 80016e2:	4618      	mov	r0, r3
 80016e4:	3708      	adds	r7, #8
 80016e6:	46bd      	mov	sp, r7
 80016e8:	bd80      	pop	{r7, pc}
 80016ea:	bf00      	nop
 80016ec:	ffffc000 	.word	0xffffc000

080016f0 <HAL_DMA2D_BlendingStart>:
  * @param  Width       The width of data to be transferred from source to destination (expressed in number of pixels per line).
  * @param  Height      The height of data to be transferred from source to destination (expressed in number of lines).
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_BlendingStart(DMA2D_HandleTypeDef *hdma2d, uint32_t SrcAddress1, uint32_t  SrcAddress2, uint32_t DstAddress, uint32_t Width,  uint32_t Height)
{
 80016f0:	b580      	push	{r7, lr}
 80016f2:	b086      	sub	sp, #24
 80016f4:	af02      	add	r7, sp, #8
 80016f6:	60f8      	str	r0, [r7, #12]
 80016f8:	60b9      	str	r1, [r7, #8]
 80016fa:	607a      	str	r2, [r7, #4]
 80016fc:	603b      	str	r3, [r7, #0]
  /* Check the parameters */
  assert_param(IS_DMA2D_LINE(Height));
  assert_param(IS_DMA2D_PIXEL(Width));

  /* Process locked */
  __HAL_LOCK(hdma2d);
 80016fe:	68fb      	ldr	r3, [r7, #12]
 8001700:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8001704:	2b01      	cmp	r3, #1
 8001706:	d101      	bne.n	800170c <HAL_DMA2D_BlendingStart+0x1c>
 8001708:	2302      	movs	r3, #2
 800170a:	e01c      	b.n	8001746 <HAL_DMA2D_BlendingStart+0x56>
 800170c:	68fb      	ldr	r3, [r7, #12]
 800170e:	2201      	movs	r2, #1
 8001710:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001714:	68fb      	ldr	r3, [r7, #12]
 8001716:	2202      	movs	r2, #2
 8001718:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Configure DMA2D Stream source2 address */
  WRITE_REG(hdma2d->Instance->BGMAR, SrcAddress2);
 800171c:	68fb      	ldr	r3, [r7, #12]
 800171e:	681b      	ldr	r3, [r3, #0]
 8001720:	687a      	ldr	r2, [r7, #4]
 8001722:	615a      	str	r2, [r3, #20]

  /* Configure the source, destination address and the data size */
  DMA2D_SetConfig(hdma2d, SrcAddress1, DstAddress, Width, Height);
 8001724:	69fb      	ldr	r3, [r7, #28]
 8001726:	9300      	str	r3, [sp, #0]
 8001728:	69bb      	ldr	r3, [r7, #24]
 800172a:	683a      	ldr	r2, [r7, #0]
 800172c:	68b9      	ldr	r1, [r7, #8]
 800172e:	68f8      	ldr	r0, [r7, #12]
 8001730:	f000 f988 	bl	8001a44 <DMA2D_SetConfig>

  /* Enable the Peripheral */
  __HAL_DMA2D_ENABLE(hdma2d);
 8001734:	68fb      	ldr	r3, [r7, #12]
 8001736:	681b      	ldr	r3, [r3, #0]
 8001738:	681a      	ldr	r2, [r3, #0]
 800173a:	68fb      	ldr	r3, [r7, #12]
 800173c:	681b      	ldr	r3, [r3, #0]
 800173e:	f042 0201 	orr.w	r2, r2, #1
 8001742:	601a      	str	r2, [r3, #0]

  return HAL_OK;
 8001744:	2300      	movs	r3, #0
}
 8001746:	4618      	mov	r0, r3
 8001748:	3710      	adds	r7, #16
 800174a:	46bd      	mov	sp, r7
 800174c:	bd80      	pop	{r7, pc}

0800174e <HAL_DMA2D_PollForTransfer>:
  *                 the configuration information for the DMA2D.
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_PollForTransfer(DMA2D_HandleTypeDef *hdma2d, uint32_t Timeout)
{
 800174e:	b580      	push	{r7, lr}
 8001750:	b086      	sub	sp, #24
 8001752:	af00      	add	r7, sp, #0
 8001754:	6078      	str	r0, [r7, #4]
 8001756:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  uint32_t layer_start;
  __IO uint32_t isrflags = 0x0U;
 8001758:	2300      	movs	r3, #0
 800175a:	60fb      	str	r3, [r7, #12]

  /* Polling for DMA2D transfer */
  if((hdma2d->Instance->CR & DMA2D_CR_START) != 0U)
 800175c:	687b      	ldr	r3, [r7, #4]
 800175e:	681b      	ldr	r3, [r3, #0]
 8001760:	681b      	ldr	r3, [r3, #0]
 8001762:	f003 0301 	and.w	r3, r3, #1
 8001766:	2b00      	cmp	r3, #0
 8001768:	d056      	beq.n	8001818 <HAL_DMA2D_PollForTransfer+0xca>
  {
   /* Get tick */
   tickstart = HAL_GetTick();
 800176a:	f7fe ff5b 	bl	8000624 <HAL_GetTick>
 800176e:	6178      	str	r0, [r7, #20]

    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
 8001770:	e04b      	b.n	800180a <HAL_DMA2D_PollForTransfer+0xbc>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8001772:	687b      	ldr	r3, [r7, #4]
 8001774:	681b      	ldr	r3, [r3, #0]
 8001776:	685b      	ldr	r3, [r3, #4]
 8001778:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 800177a:	68fb      	ldr	r3, [r7, #12]
 800177c:	f003 0321 	and.w	r3, r3, #33	; 0x21
 8001780:	2b00      	cmp	r3, #0
 8001782:	d023      	beq.n	80017cc <HAL_DMA2D_PollForTransfer+0x7e>
      {
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
 8001784:	68fb      	ldr	r3, [r7, #12]
 8001786:	f003 0320 	and.w	r3, r3, #32
 800178a:	2b00      	cmp	r3, #0
 800178c:	d005      	beq.n	800179a <HAL_DMA2D_PollForTransfer+0x4c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 800178e:	687b      	ldr	r3, [r7, #4]
 8001790:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001792:	f043 0202 	orr.w	r2, r3, #2
 8001796:	687b      	ldr	r3, [r7, #4]
 8001798:	63da      	str	r2, [r3, #60]	; 0x3c
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
 800179a:	68fb      	ldr	r3, [r7, #12]
 800179c:	f003 0301 	and.w	r3, r3, #1
 80017a0:	2b00      	cmp	r3, #0
 80017a2:	d005      	beq.n	80017b0 <HAL_DMA2D_PollForTransfer+0x62>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 80017a4:	687b      	ldr	r3, [r7, #4]
 80017a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80017a8:	f043 0201 	orr.w	r2, r3, #1
 80017ac:	687b      	ldr	r3, [r7, #4]
 80017ae:	63da      	str	r2, [r3, #60]	; 0x3c
        }
        /* Clear the transfer and configuration error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 80017b0:	687b      	ldr	r3, [r7, #4]
 80017b2:	681b      	ldr	r3, [r3, #0]
 80017b4:	2221      	movs	r2, #33	; 0x21
 80017b6:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State = HAL_DMA2D_STATE_ERROR;
 80017b8:	687b      	ldr	r3, [r7, #4]
 80017ba:	2204      	movs	r2, #4
 80017bc:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
 80017c0:	687b      	ldr	r3, [r7, #4]
 80017c2:	2200      	movs	r2, #0
 80017c4:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

        return HAL_ERROR;
 80017c8:	2301      	movs	r3, #1
 80017ca:	e0a5      	b.n	8001918 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 80017cc:	683b      	ldr	r3, [r7, #0]
 80017ce:	f1b3 3fff 	cmp.w	r3, #4294967295
 80017d2:	d01a      	beq.n	800180a <HAL_DMA2D_PollForTransfer+0xbc>
      {
        if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
 80017d4:	f7fe ff26 	bl	8000624 <HAL_GetTick>
 80017d8:	4602      	mov	r2, r0
 80017da:	697b      	ldr	r3, [r7, #20]
 80017dc:	1ad3      	subs	r3, r2, r3
 80017de:	683a      	ldr	r2, [r7, #0]
 80017e0:	429a      	cmp	r2, r3
 80017e2:	d302      	bcc.n	80017ea <HAL_DMA2D_PollForTransfer+0x9c>
 80017e4:	683b      	ldr	r3, [r7, #0]
 80017e6:	2b00      	cmp	r3, #0
 80017e8:	d10f      	bne.n	800180a <HAL_DMA2D_PollForTransfer+0xbc>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 80017ea:	687b      	ldr	r3, [r7, #4]
 80017ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80017ee:	f043 0220 	orr.w	r2, r3, #32
 80017f2:	687b      	ldr	r3, [r7, #4]
 80017f4:	63da      	str	r2, [r3, #60]	; 0x3c

          /* Change the DMA2D state */
          hdma2d->State = HAL_DMA2D_STATE_TIMEOUT;
 80017f6:	687b      	ldr	r3, [r7, #4]
 80017f8:	2203      	movs	r2, #3
 80017fa:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
 80017fe:	687b      	ldr	r3, [r7, #4]
 8001800:	2200      	movs	r2, #0
 8001802:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

          return HAL_TIMEOUT;
 8001806:	2303      	movs	r3, #3
 8001808:	e086      	b.n	8001918 <HAL_DMA2D_PollForTransfer+0x1ca>
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_TC) == 0U)
 800180a:	687b      	ldr	r3, [r7, #4]
 800180c:	681b      	ldr	r3, [r3, #0]
 800180e:	685b      	ldr	r3, [r3, #4]
 8001810:	f003 0302 	and.w	r3, r3, #2
 8001814:	2b00      	cmp	r3, #0
 8001816:	d0ac      	beq.n	8001772 <HAL_DMA2D_PollForTransfer+0x24>
        }
      }
    }
  }
  /* Polling for CLUT loading (foreground or background) */
  layer_start = hdma2d->Instance->FGPFCCR & DMA2D_FGPFCCR_START;
 8001818:	687b      	ldr	r3, [r7, #4]
 800181a:	681b      	ldr	r3, [r3, #0]
 800181c:	69db      	ldr	r3, [r3, #28]
 800181e:	f003 0320 	and.w	r3, r3, #32
 8001822:	613b      	str	r3, [r7, #16]
  layer_start |= hdma2d->Instance->BGPFCCR & DMA2D_BGPFCCR_START;
 8001824:	687b      	ldr	r3, [r7, #4]
 8001826:	681b      	ldr	r3, [r3, #0]
 8001828:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800182a:	f003 0320 	and.w	r3, r3, #32
 800182e:	693a      	ldr	r2, [r7, #16]
 8001830:	4313      	orrs	r3, r2
 8001832:	613b      	str	r3, [r7, #16]
  if (layer_start != 0U)
 8001834:	693b      	ldr	r3, [r7, #16]
 8001836:	2b00      	cmp	r3, #0
 8001838:	d061      	beq.n	80018fe <HAL_DMA2D_PollForTransfer+0x1b0>
  {
    /* Get tick */
    tickstart = HAL_GetTick();
 800183a:	f7fe fef3 	bl	8000624 <HAL_GetTick>
 800183e:	6178      	str	r0, [r7, #20]

    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
 8001840:	e056      	b.n	80018f0 <HAL_DMA2D_PollForTransfer+0x1a2>
    {
      isrflags = READ_REG(hdma2d->Instance->ISR);
 8001842:	687b      	ldr	r3, [r7, #4]
 8001844:	681b      	ldr	r3, [r3, #0]
 8001846:	685b      	ldr	r3, [r3, #4]
 8001848:	60fb      	str	r3, [r7, #12]
      if ((isrflags & (DMA2D_FLAG_CAE|DMA2D_FLAG_CE|DMA2D_FLAG_TE)) != 0U)
 800184a:	68fb      	ldr	r3, [r7, #12]
 800184c:	f003 0329 	and.w	r3, r3, #41	; 0x29
 8001850:	2b00      	cmp	r3, #0
 8001852:	d02e      	beq.n	80018b2 <HAL_DMA2D_PollForTransfer+0x164>
      {
        if ((isrflags & DMA2D_FLAG_CAE) != 0U)
 8001854:	68fb      	ldr	r3, [r7, #12]
 8001856:	f003 0308 	and.w	r3, r3, #8
 800185a:	2b00      	cmp	r3, #0
 800185c:	d005      	beq.n	800186a <HAL_DMA2D_PollForTransfer+0x11c>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CAE;
 800185e:	687b      	ldr	r3, [r7, #4]
 8001860:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001862:	f043 0204 	orr.w	r2, r3, #4
 8001866:	687b      	ldr	r3, [r7, #4]
 8001868:	63da      	str	r2, [r3, #60]	; 0x3c
        }
        if ((isrflags & DMA2D_FLAG_CE) != 0U)
 800186a:	68fb      	ldr	r3, [r7, #12]
 800186c:	f003 0320 	and.w	r3, r3, #32
 8001870:	2b00      	cmp	r3, #0
 8001872:	d005      	beq.n	8001880 <HAL_DMA2D_PollForTransfer+0x132>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_CE;
 8001874:	687b      	ldr	r3, [r7, #4]
 8001876:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001878:	f043 0202 	orr.w	r2, r3, #2
 800187c:	687b      	ldr	r3, [r7, #4]
 800187e:	63da      	str	r2, [r3, #60]	; 0x3c
        }
        if ((isrflags & DMA2D_FLAG_TE) != 0U)
 8001880:	68fb      	ldr	r3, [r7, #12]
 8001882:	f003 0301 	and.w	r3, r3, #1
 8001886:	2b00      	cmp	r3, #0
 8001888:	d005      	beq.n	8001896 <HAL_DMA2D_PollForTransfer+0x148>
        {
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TE;
 800188a:	687b      	ldr	r3, [r7, #4]
 800188c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800188e:	f043 0201 	orr.w	r2, r3, #1
 8001892:	687b      	ldr	r3, [r7, #4]
 8001894:	63da      	str	r2, [r3, #60]	; 0x3c
        }
        /* Clear the CLUT Access Error, Configuration Error and Transfer Error flags */
        __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_CAE | DMA2D_FLAG_CE | DMA2D_FLAG_TE);
 8001896:	687b      	ldr	r3, [r7, #4]
 8001898:	681b      	ldr	r3, [r3, #0]
 800189a:	2229      	movs	r2, #41	; 0x29
 800189c:	609a      	str	r2, [r3, #8]

        /* Change DMA2D state */
        hdma2d->State= HAL_DMA2D_STATE_ERROR;
 800189e:	687b      	ldr	r3, [r7, #4]
 80018a0:	2204      	movs	r2, #4
 80018a2:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

        /* Process unlocked */
        __HAL_UNLOCK(hdma2d);
 80018a6:	687b      	ldr	r3, [r7, #4]
 80018a8:	2200      	movs	r2, #0
 80018aa:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

        return HAL_ERROR;
 80018ae:	2301      	movs	r3, #1
 80018b0:	e032      	b.n	8001918 <HAL_DMA2D_PollForTransfer+0x1ca>
      }
      /* Check for the Timeout */
      if(Timeout != HAL_MAX_DELAY)
 80018b2:	683b      	ldr	r3, [r7, #0]
 80018b4:	f1b3 3fff 	cmp.w	r3, #4294967295
 80018b8:	d01a      	beq.n	80018f0 <HAL_DMA2D_PollForTransfer+0x1a2>
      {
        if(((HAL_GetTick() - tickstart ) > Timeout)||(Timeout == 0U))
 80018ba:	f7fe feb3 	bl	8000624 <HAL_GetTick>
 80018be:	4602      	mov	r2, r0
 80018c0:	697b      	ldr	r3, [r7, #20]
 80018c2:	1ad3      	subs	r3, r2, r3
 80018c4:	683a      	ldr	r2, [r7, #0]
 80018c6:	429a      	cmp	r2, r3
 80018c8:	d302      	bcc.n	80018d0 <HAL_DMA2D_PollForTransfer+0x182>
 80018ca:	683b      	ldr	r3, [r7, #0]
 80018cc:	2b00      	cmp	r3, #0
 80018ce:	d10f      	bne.n	80018f0 <HAL_DMA2D_PollForTransfer+0x1a2>
        {
          /* Update error code */
          hdma2d->ErrorCode |= HAL_DMA2D_ERROR_TIMEOUT;
 80018d0:	687b      	ldr	r3, [r7, #4]
 80018d2:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80018d4:	f043 0220 	orr.w	r2, r3, #32
 80018d8:	687b      	ldr	r3, [r7, #4]
 80018da:	63da      	str	r2, [r3, #60]	; 0x3c

          /* Change the DMA2D state */
          hdma2d->State= HAL_DMA2D_STATE_TIMEOUT;
 80018dc:	687b      	ldr	r3, [r7, #4]
 80018de:	2203      	movs	r2, #3
 80018e0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

          /* Process unlocked */
          __HAL_UNLOCK(hdma2d);
 80018e4:	687b      	ldr	r3, [r7, #4]
 80018e6:	2200      	movs	r2, #0
 80018e8:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

          return HAL_TIMEOUT;
 80018ec:	2303      	movs	r3, #3
 80018ee:	e013      	b.n	8001918 <HAL_DMA2D_PollForTransfer+0x1ca>
    while(__HAL_DMA2D_GET_FLAG(hdma2d, DMA2D_FLAG_CTC) == 0U)
 80018f0:	687b      	ldr	r3, [r7, #4]
 80018f2:	681b      	ldr	r3, [r3, #0]
 80018f4:	685b      	ldr	r3, [r3, #4]
 80018f6:	f003 0310 	and.w	r3, r3, #16
 80018fa:	2b00      	cmp	r3, #0
 80018fc:	d0a1      	beq.n	8001842 <HAL_DMA2D_PollForTransfer+0xf4>
      }
    }
  }

  /* Clear the transfer complete and CLUT loading flags */
  __HAL_DMA2D_CLEAR_FLAG(hdma2d, DMA2D_FLAG_TC|DMA2D_FLAG_CTC);
 80018fe:	687b      	ldr	r3, [r7, #4]
 8001900:	681b      	ldr	r3, [r3, #0]
 8001902:	2212      	movs	r2, #18
 8001904:	609a      	str	r2, [r3, #8]

  /* Change DMA2D state */
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001906:	687b      	ldr	r3, [r7, #4]
 8001908:	2201      	movs	r2, #1
 800190a:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
 800190e:	687b      	ldr	r3, [r7, #4]
 8001910:	2200      	movs	r2, #0
 8001912:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 8001916:	2300      	movs	r3, #0
}
 8001918:	4618      	mov	r0, r3
 800191a:	3718      	adds	r7, #24
 800191c:	46bd      	mov	sp, r7
 800191e:	bd80      	pop	{r7, pc}

08001920 <HAL_DMA2D_ConfigLayer>:
  *                   This parameter can be one of the following values:
  *                   DMA2D_BACKGROUND_LAYER(0) / DMA2D_FOREGROUND_LAYER(1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_ConfigLayer(DMA2D_HandleTypeDef *hdma2d, uint32_t LayerIdx)
{
 8001920:	b480      	push	{r7}
 8001922:	b087      	sub	sp, #28
 8001924:	af00      	add	r7, sp, #0
 8001926:	6078      	str	r0, [r7, #4]
 8001928:	6039      	str	r1, [r7, #0]
  uint32_t regMask, regValue;

  /* Check the parameters */
  assert_param(IS_DMA2D_LAYER(LayerIdx));
  assert_param(IS_DMA2D_OFFSET(hdma2d->LayerCfg[LayerIdx].InputOffset));
  if(hdma2d->Init.Mode != DMA2D_R2M)
 800192a:	687b      	ldr	r3, [r7, #4]
 800192c:	685b      	ldr	r3, [r3, #4]
 800192e:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
  assert_param(IS_DMA2D_ALPHA_INVERTED(hdma2d->LayerCfg[LayerIdx].AlphaInverted));
  assert_param(IS_DMA2D_RB_SWAP(hdma2d->LayerCfg[LayerIdx].RedBlueSwap));
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */

  /* Process locked */
  __HAL_LOCK(hdma2d);
 8001932:	687b      	ldr	r3, [r7, #4]
 8001934:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8001938:	2b01      	cmp	r3, #1
 800193a:	d101      	bne.n	8001940 <HAL_DMA2D_ConfigLayer+0x20>
 800193c:	2302      	movs	r3, #2
 800193e:	e079      	b.n	8001a34 <HAL_DMA2D_ConfigLayer+0x114>
 8001940:	687b      	ldr	r3, [r7, #4]
 8001942:	2201      	movs	r2, #1
 8001944:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001948:	687b      	ldr	r3, [r7, #4]
 800194a:	2202      	movs	r2, #2
 800194c:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  pLayerCfg = &hdma2d->LayerCfg[LayerIdx];
 8001950:	683b      	ldr	r3, [r7, #0]
 8001952:	011b      	lsls	r3, r3, #4
 8001954:	3318      	adds	r3, #24
 8001956:	687a      	ldr	r2, [r7, #4]
 8001958:	4413      	add	r3, r2
 800195a:	613b      	str	r3, [r7, #16]
#if defined (DMA2D_ALPHA_INV_RB_SWAP_SUPPORT)
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos) |\
             (pLayerCfg->AlphaInverted << DMA2D_BGPFCCR_AI_Pos) | (pLayerCfg->RedBlueSwap << DMA2D_BGPFCCR_RBS_Pos);
  regMask  = (DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA | DMA2D_BGPFCCR_AI | DMA2D_BGPFCCR_RBS);
#else
  regValue = pLayerCfg->InputColorMode | (pLayerCfg->AlphaMode << DMA2D_BGPFCCR_AM_Pos);
 800195c:	693b      	ldr	r3, [r7, #16]
 800195e:	685a      	ldr	r2, [r3, #4]
 8001960:	693b      	ldr	r3, [r7, #16]
 8001962:	689b      	ldr	r3, [r3, #8]
 8001964:	041b      	lsls	r3, r3, #16
 8001966:	4313      	orrs	r3, r2
 8001968:	617b      	str	r3, [r7, #20]
  regMask  = DMA2D_BGPFCCR_CM | DMA2D_BGPFCCR_AM | DMA2D_BGPFCCR_ALPHA;
 800196a:	4b35      	ldr	r3, [pc, #212]	; (8001a40 <HAL_DMA2D_ConfigLayer+0x120>)
 800196c:	60fb      	str	r3, [r7, #12]
#endif /* DMA2D_ALPHA_INV_RB_SWAP_SUPPORT */


  if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 800196e:	693b      	ldr	r3, [r7, #16]
 8001970:	685b      	ldr	r3, [r3, #4]
 8001972:	2b0a      	cmp	r3, #10
 8001974:	d003      	beq.n	800197e <HAL_DMA2D_ConfigLayer+0x5e>
 8001976:	693b      	ldr	r3, [r7, #16]
 8001978:	685b      	ldr	r3, [r3, #4]
 800197a:	2b09      	cmp	r3, #9
 800197c:	d107      	bne.n	800198e <HAL_DMA2D_ConfigLayer+0x6e>
  {
    regValue |= (pLayerCfg->InputAlpha & DMA2D_BGPFCCR_ALPHA);
 800197e:	693b      	ldr	r3, [r7, #16]
 8001980:	68db      	ldr	r3, [r3, #12]
 8001982:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8001986:	697a      	ldr	r2, [r7, #20]
 8001988:	4313      	orrs	r3, r2
 800198a:	617b      	str	r3, [r7, #20]
 800198c:	e005      	b.n	800199a <HAL_DMA2D_ConfigLayer+0x7a>
  }
  else
  {
    regValue |=  (pLayerCfg->InputAlpha << DMA2D_BGPFCCR_ALPHA_Pos);
 800198e:	693b      	ldr	r3, [r7, #16]
 8001990:	68db      	ldr	r3, [r3, #12]
 8001992:	061b      	lsls	r3, r3, #24
 8001994:	697a      	ldr	r2, [r7, #20]
 8001996:	4313      	orrs	r3, r2
 8001998:	617b      	str	r3, [r7, #20]
  }

  /* Configure the background DMA2D layer */
  if(LayerIdx == DMA2D_BACKGROUND_LAYER)
 800199a:	683b      	ldr	r3, [r7, #0]
 800199c:	2b00      	cmp	r3, #0
 800199e:	d120      	bne.n	80019e2 <HAL_DMA2D_ConfigLayer+0xc2>
  {
    /* Write DMA2D BGPFCCR register */
    MODIFY_REG(hdma2d->Instance->BGPFCCR, regMask, regValue);
 80019a0:	687b      	ldr	r3, [r7, #4]
 80019a2:	681b      	ldr	r3, [r3, #0]
 80019a4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80019a6:	68fb      	ldr	r3, [r7, #12]
 80019a8:	43db      	mvns	r3, r3
 80019aa:	ea02 0103 	and.w	r1, r2, r3
 80019ae:	687b      	ldr	r3, [r7, #4]
 80019b0:	681b      	ldr	r3, [r3, #0]
 80019b2:	697a      	ldr	r2, [r7, #20]
 80019b4:	430a      	orrs	r2, r1
 80019b6:	625a      	str	r2, [r3, #36]	; 0x24

    /* DMA2D BGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->BGOR, pLayerCfg->InputOffset);
 80019b8:	687b      	ldr	r3, [r7, #4]
 80019ba:	681b      	ldr	r3, [r3, #0]
 80019bc:	693a      	ldr	r2, [r7, #16]
 80019be:	6812      	ldr	r2, [r2, #0]
 80019c0:	619a      	str	r2, [r3, #24]

    /* DMA2D BGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 80019c2:	693b      	ldr	r3, [r7, #16]
 80019c4:	685b      	ldr	r3, [r3, #4]
 80019c6:	2b0a      	cmp	r3, #10
 80019c8:	d003      	beq.n	80019d2 <HAL_DMA2D_ConfigLayer+0xb2>
 80019ca:	693b      	ldr	r3, [r7, #16]
 80019cc:	685b      	ldr	r3, [r3, #4]
 80019ce:	2b09      	cmp	r3, #9
 80019d0:	d127      	bne.n	8001a22 <HAL_DMA2D_ConfigLayer+0x102>
    {
      WRITE_REG(hdma2d->Instance->BGCOLR, pLayerCfg->InputAlpha & (DMA2D_BGCOLR_BLUE|DMA2D_BGCOLR_GREEN|DMA2D_BGCOLR_RED));
 80019d2:	693b      	ldr	r3, [r7, #16]
 80019d4:	68da      	ldr	r2, [r3, #12]
 80019d6:	687b      	ldr	r3, [r7, #4]
 80019d8:	681b      	ldr	r3, [r3, #0]
 80019da:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 80019de:	629a      	str	r2, [r3, #40]	; 0x28
 80019e0:	e01f      	b.n	8001a22 <HAL_DMA2D_ConfigLayer+0x102>
  else
  {


     /* Write DMA2D FGPFCCR register */
    MODIFY_REG(hdma2d->Instance->FGPFCCR, regMask, regValue);
 80019e2:	687b      	ldr	r3, [r7, #4]
 80019e4:	681b      	ldr	r3, [r3, #0]
 80019e6:	69da      	ldr	r2, [r3, #28]
 80019e8:	68fb      	ldr	r3, [r7, #12]
 80019ea:	43db      	mvns	r3, r3
 80019ec:	ea02 0103 	and.w	r1, r2, r3
 80019f0:	687b      	ldr	r3, [r7, #4]
 80019f2:	681b      	ldr	r3, [r3, #0]
 80019f4:	697a      	ldr	r2, [r7, #20]
 80019f6:	430a      	orrs	r2, r1
 80019f8:	61da      	str	r2, [r3, #28]

    /* DMA2D FGOR register configuration -------------------------------------*/
    WRITE_REG(hdma2d->Instance->FGOR, pLayerCfg->InputOffset);
 80019fa:	687b      	ldr	r3, [r7, #4]
 80019fc:	681b      	ldr	r3, [r3, #0]
 80019fe:	693a      	ldr	r2, [r7, #16]
 8001a00:	6812      	ldr	r2, [r2, #0]
 8001a02:	611a      	str	r2, [r3, #16]

    /* DMA2D FGCOLR register configuration -------------------------------------*/
    if ((pLayerCfg->InputColorMode == DMA2D_INPUT_A4) || (pLayerCfg->InputColorMode == DMA2D_INPUT_A8))
 8001a04:	693b      	ldr	r3, [r7, #16]
 8001a06:	685b      	ldr	r3, [r3, #4]
 8001a08:	2b0a      	cmp	r3, #10
 8001a0a:	d003      	beq.n	8001a14 <HAL_DMA2D_ConfigLayer+0xf4>
 8001a0c:	693b      	ldr	r3, [r7, #16]
 8001a0e:	685b      	ldr	r3, [r3, #4]
 8001a10:	2b09      	cmp	r3, #9
 8001a12:	d106      	bne.n	8001a22 <HAL_DMA2D_ConfigLayer+0x102>
    {
      WRITE_REG(hdma2d->Instance->FGCOLR, pLayerCfg->InputAlpha & (DMA2D_FGCOLR_BLUE|DMA2D_FGCOLR_GREEN|DMA2D_FGCOLR_RED));
 8001a14:	693b      	ldr	r3, [r7, #16]
 8001a16:	68da      	ldr	r2, [r3, #12]
 8001a18:	687b      	ldr	r3, [r7, #4]
 8001a1a:	681b      	ldr	r3, [r3, #0]
 8001a1c:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 8001a20:	621a      	str	r2, [r3, #32]
    }
  }
  /* Initialize the DMA2D state*/
  hdma2d->State = HAL_DMA2D_STATE_READY;
 8001a22:	687b      	ldr	r3, [r7, #4]
 8001a24:	2201      	movs	r2, #1
 8001a26:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39

  /* Process unlocked */
  __HAL_UNLOCK(hdma2d);
 8001a2a:	687b      	ldr	r3, [r7, #4]
 8001a2c:	2200      	movs	r2, #0
 8001a2e:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38

  return HAL_OK;
 8001a32:	2300      	movs	r3, #0
}
 8001a34:	4618      	mov	r0, r3
 8001a36:	371c      	adds	r7, #28
 8001a38:	46bd      	mov	sp, r7
 8001a3a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001a3e:	4770      	bx	lr
 8001a40:	ff03000f 	.word	0xff03000f

08001a44 <DMA2D_SetConfig>:
  * @param  Width      The width of data to be transferred from source to destination.
  * @param  Height     The height of data to be transferred from source to destination.
  * @retval HAL status
  */
static void DMA2D_SetConfig(DMA2D_HandleTypeDef *hdma2d, uint32_t pdata, uint32_t DstAddress, uint32_t Width, uint32_t Height)
{
 8001a44:	b480      	push	{r7}
 8001a46:	b08b      	sub	sp, #44	; 0x2c
 8001a48:	af00      	add	r7, sp, #0
 8001a4a:	60f8      	str	r0, [r7, #12]
 8001a4c:	60b9      	str	r1, [r7, #8]
 8001a4e:	607a      	str	r2, [r7, #4]
 8001a50:	603b      	str	r3, [r7, #0]
  uint32_t tmp2;
  uint32_t tmp3;
  uint32_t tmp4;

  /* Configure DMA2D data size */
  MODIFY_REG(hdma2d->Instance->NLR, (DMA2D_NLR_NL|DMA2D_NLR_PL), (Height| (Width << DMA2D_NLR_PL_Pos)));
 8001a52:	68fb      	ldr	r3, [r7, #12]
 8001a54:	681b      	ldr	r3, [r3, #0]
 8001a56:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001a58:	f003 4140 	and.w	r1, r3, #3221225472	; 0xc0000000
 8001a5c:	683b      	ldr	r3, [r7, #0]
 8001a5e:	041a      	lsls	r2, r3, #16
 8001a60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001a62:	431a      	orrs	r2, r3
 8001a64:	68fb      	ldr	r3, [r7, #12]
 8001a66:	681b      	ldr	r3, [r3, #0]
 8001a68:	430a      	orrs	r2, r1
 8001a6a:	645a      	str	r2, [r3, #68]	; 0x44

  /* Configure DMA2D destination address */
  WRITE_REG(hdma2d->Instance->OMAR, DstAddress);
 8001a6c:	68fb      	ldr	r3, [r7, #12]
 8001a6e:	681b      	ldr	r3, [r3, #0]
 8001a70:	687a      	ldr	r2, [r7, #4]
 8001a72:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Register to memory DMA2D mode selected */
  if (hdma2d->Init.Mode == DMA2D_R2M)
 8001a74:	68fb      	ldr	r3, [r7, #12]
 8001a76:	685b      	ldr	r3, [r3, #4]
 8001a78:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8001a7c:	d174      	bne.n	8001b68 <DMA2D_SetConfig+0x124>
  {
    tmp1 = pdata & DMA2D_OCOLR_ALPHA_1;
 8001a7e:	68bb      	ldr	r3, [r7, #8]
 8001a80:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8001a84:	623b      	str	r3, [r7, #32]
    tmp2 = pdata & DMA2D_OCOLR_RED_1;
 8001a86:	68bb      	ldr	r3, [r7, #8]
 8001a88:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8001a8c:	61fb      	str	r3, [r7, #28]
    tmp3 = pdata & DMA2D_OCOLR_GREEN_1;
 8001a8e:	68bb      	ldr	r3, [r7, #8]
 8001a90:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8001a94:	61bb      	str	r3, [r7, #24]
    tmp4 = pdata & DMA2D_OCOLR_BLUE_1;
 8001a96:	68bb      	ldr	r3, [r7, #8]
 8001a98:	b2db      	uxtb	r3, r3
 8001a9a:	617b      	str	r3, [r7, #20]

    /* Prepare the value to be written to the OCOLR register according to the color mode */
    if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB8888)
 8001a9c:	68fb      	ldr	r3, [r7, #12]
 8001a9e:	689b      	ldr	r3, [r3, #8]
 8001aa0:	2b00      	cmp	r3, #0
 8001aa2:	d108      	bne.n	8001ab6 <DMA2D_SetConfig+0x72>
    {
      tmp = (tmp3 | tmp2 | tmp1| tmp4);
 8001aa4:	69ba      	ldr	r2, [r7, #24]
 8001aa6:	69fb      	ldr	r3, [r7, #28]
 8001aa8:	431a      	orrs	r2, r3
 8001aaa:	6a3b      	ldr	r3, [r7, #32]
 8001aac:	4313      	orrs	r3, r2
 8001aae:	697a      	ldr	r2, [r7, #20]
 8001ab0:	4313      	orrs	r3, r2
 8001ab2:	627b      	str	r3, [r7, #36]	; 0x24
 8001ab4:	e053      	b.n	8001b5e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB888)
 8001ab6:	68fb      	ldr	r3, [r7, #12]
 8001ab8:	689b      	ldr	r3, [r3, #8]
 8001aba:	2b01      	cmp	r3, #1
 8001abc:	d106      	bne.n	8001acc <DMA2D_SetConfig+0x88>
    {
      tmp = (tmp3 | tmp2 | tmp4);
 8001abe:	69ba      	ldr	r2, [r7, #24]
 8001ac0:	69fb      	ldr	r3, [r7, #28]
 8001ac2:	4313      	orrs	r3, r2
 8001ac4:	697a      	ldr	r2, [r7, #20]
 8001ac6:	4313      	orrs	r3, r2
 8001ac8:	627b      	str	r3, [r7, #36]	; 0x24
 8001aca:	e048      	b.n	8001b5e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_RGB565)
 8001acc:	68fb      	ldr	r3, [r7, #12]
 8001ace:	689b      	ldr	r3, [r3, #8]
 8001ad0:	2b02      	cmp	r3, #2
 8001ad2:	d111      	bne.n	8001af8 <DMA2D_SetConfig+0xb4>
    {
      tmp2 = (tmp2 >> 19U);
 8001ad4:	69fb      	ldr	r3, [r7, #28]
 8001ad6:	0cdb      	lsrs	r3, r3, #19
 8001ad8:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 10U);
 8001ada:	69bb      	ldr	r3, [r7, #24]
 8001adc:	0a9b      	lsrs	r3, r3, #10
 8001ade:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U );
 8001ae0:	697b      	ldr	r3, [r7, #20]
 8001ae2:	08db      	lsrs	r3, r3, #3
 8001ae4:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 11U) | tmp4);
 8001ae6:	69bb      	ldr	r3, [r7, #24]
 8001ae8:	015a      	lsls	r2, r3, #5
 8001aea:	69fb      	ldr	r3, [r7, #28]
 8001aec:	02db      	lsls	r3, r3, #11
 8001aee:	4313      	orrs	r3, r2
 8001af0:	697a      	ldr	r2, [r7, #20]
 8001af2:	4313      	orrs	r3, r2
 8001af4:	627b      	str	r3, [r7, #36]	; 0x24
 8001af6:	e032      	b.n	8001b5e <DMA2D_SetConfig+0x11a>
    }
    else if (hdma2d->Init.ColorMode == DMA2D_OUTPUT_ARGB1555)
 8001af8:	68fb      	ldr	r3, [r7, #12]
 8001afa:	689b      	ldr	r3, [r3, #8]
 8001afc:	2b03      	cmp	r3, #3
 8001afe:	d117      	bne.n	8001b30 <DMA2D_SetConfig+0xec>
    {
      tmp1 = (tmp1 >> 31U);
 8001b00:	6a3b      	ldr	r3, [r7, #32]
 8001b02:	0fdb      	lsrs	r3, r3, #31
 8001b04:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 19U);
 8001b06:	69fb      	ldr	r3, [r7, #28]
 8001b08:	0cdb      	lsrs	r3, r3, #19
 8001b0a:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 11U);
 8001b0c:	69bb      	ldr	r3, [r7, #24]
 8001b0e:	0adb      	lsrs	r3, r3, #11
 8001b10:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 3U );
 8001b12:	697b      	ldr	r3, [r7, #20]
 8001b14:	08db      	lsrs	r3, r3, #3
 8001b16:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 5U) | (tmp2 << 10U) | (tmp1 << 15U) | tmp4);
 8001b18:	69bb      	ldr	r3, [r7, #24]
 8001b1a:	015a      	lsls	r2, r3, #5
 8001b1c:	69fb      	ldr	r3, [r7, #28]
 8001b1e:	029b      	lsls	r3, r3, #10
 8001b20:	431a      	orrs	r2, r3
 8001b22:	6a3b      	ldr	r3, [r7, #32]
 8001b24:	03db      	lsls	r3, r3, #15
 8001b26:	4313      	orrs	r3, r2
 8001b28:	697a      	ldr	r2, [r7, #20]
 8001b2a:	4313      	orrs	r3, r2
 8001b2c:	627b      	str	r3, [r7, #36]	; 0x24
 8001b2e:	e016      	b.n	8001b5e <DMA2D_SetConfig+0x11a>
    }
    else /* Dhdma2d->Init.ColorMode = DMA2D_OUTPUT_ARGB4444 */
    {
      tmp1 = (tmp1 >> 28U);
 8001b30:	6a3b      	ldr	r3, [r7, #32]
 8001b32:	0f1b      	lsrs	r3, r3, #28
 8001b34:	623b      	str	r3, [r7, #32]
      tmp2 = (tmp2 >> 20U);
 8001b36:	69fb      	ldr	r3, [r7, #28]
 8001b38:	0d1b      	lsrs	r3, r3, #20
 8001b3a:	61fb      	str	r3, [r7, #28]
      tmp3 = (tmp3 >> 12U);
 8001b3c:	69bb      	ldr	r3, [r7, #24]
 8001b3e:	0b1b      	lsrs	r3, r3, #12
 8001b40:	61bb      	str	r3, [r7, #24]
      tmp4 = (tmp4 >> 4U );
 8001b42:	697b      	ldr	r3, [r7, #20]
 8001b44:	091b      	lsrs	r3, r3, #4
 8001b46:	617b      	str	r3, [r7, #20]
      tmp  = ((tmp3 << 4U) | (tmp2 << 8U) | (tmp1 << 12U) | tmp4);
 8001b48:	69bb      	ldr	r3, [r7, #24]
 8001b4a:	011a      	lsls	r2, r3, #4
 8001b4c:	69fb      	ldr	r3, [r7, #28]
 8001b4e:	021b      	lsls	r3, r3, #8
 8001b50:	431a      	orrs	r2, r3
 8001b52:	6a3b      	ldr	r3, [r7, #32]
 8001b54:	031b      	lsls	r3, r3, #12
 8001b56:	4313      	orrs	r3, r2
 8001b58:	697a      	ldr	r2, [r7, #20]
 8001b5a:	4313      	orrs	r3, r2
 8001b5c:	627b      	str	r3, [r7, #36]	; 0x24
    }
    /* Write to DMA2D OCOLR register */
    WRITE_REG(hdma2d->Instance->OCOLR, tmp);
 8001b5e:	68fb      	ldr	r3, [r7, #12]
 8001b60:	681b      	ldr	r3, [r3, #0]
 8001b62:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001b64:	639a      	str	r2, [r3, #56]	; 0x38
  else /* M2M, M2M_PFC or M2M_Blending DMA2D Mode */
  {
    /* Configure DMA2D source address */
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
  }
}
 8001b66:	e003      	b.n	8001b70 <DMA2D_SetConfig+0x12c>
    WRITE_REG(hdma2d->Instance->FGMAR, pdata);
 8001b68:	68fb      	ldr	r3, [r7, #12]
 8001b6a:	681b      	ldr	r3, [r3, #0]
 8001b6c:	68ba      	ldr	r2, [r7, #8]
 8001b6e:	60da      	str	r2, [r3, #12]
}
 8001b70:	bf00      	nop
 8001b72:	372c      	adds	r7, #44	; 0x2c
 8001b74:	46bd      	mov	sp, r7
 8001b76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001b7a:	4770      	bx	lr

08001b7c <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001b7c:	b480      	push	{r7}
 8001b7e:	b089      	sub	sp, #36	; 0x24
 8001b80:	af00      	add	r7, sp, #0
 8001b82:	6078      	str	r0, [r7, #4]
 8001b84:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 8001b86:	2300      	movs	r3, #0
 8001b88:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
 8001b8a:	2300      	movs	r3, #0
 8001b8c:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
 8001b8e:	2300      	movs	r3, #0
 8001b90:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
 8001b92:	2300      	movs	r3, #0
 8001b94:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8001b96:	2300      	movs	r3, #0
 8001b98:	61fb      	str	r3, [r7, #28]
 8001b9a:	e175      	b.n	8001e88 <HAL_GPIO_Init+0x30c>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8001b9c:	2201      	movs	r2, #1
 8001b9e:	69fb      	ldr	r3, [r7, #28]
 8001ba0:	fa02 f303 	lsl.w	r3, r2, r3
 8001ba4:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001ba6:	683b      	ldr	r3, [r7, #0]
 8001ba8:	681b      	ldr	r3, [r3, #0]
 8001baa:	697a      	ldr	r2, [r7, #20]
 8001bac:	4013      	ands	r3, r2
 8001bae:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8001bb0:	693a      	ldr	r2, [r7, #16]
 8001bb2:	697b      	ldr	r3, [r7, #20]
 8001bb4:	429a      	cmp	r2, r3
 8001bb6:	f040 8164 	bne.w	8001e82 <HAL_GPIO_Init+0x306>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001bba:	683b      	ldr	r3, [r7, #0]
 8001bbc:	685b      	ldr	r3, [r3, #4]
 8001bbe:	2b02      	cmp	r3, #2
 8001bc0:	d003      	beq.n	8001bca <HAL_GPIO_Init+0x4e>
 8001bc2:	683b      	ldr	r3, [r7, #0]
 8001bc4:	685b      	ldr	r3, [r3, #4]
 8001bc6:	2b12      	cmp	r3, #18
 8001bc8:	d123      	bne.n	8001c12 <HAL_GPIO_Init+0x96>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8001bca:	69fb      	ldr	r3, [r7, #28]
 8001bcc:	08da      	lsrs	r2, r3, #3
 8001bce:	687b      	ldr	r3, [r7, #4]
 8001bd0:	3208      	adds	r2, #8
 8001bd2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8001bd6:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001bd8:	69fb      	ldr	r3, [r7, #28]
 8001bda:	f003 0307 	and.w	r3, r3, #7
 8001bde:	009b      	lsls	r3, r3, #2
 8001be0:	220f      	movs	r2, #15
 8001be2:	fa02 f303 	lsl.w	r3, r2, r3
 8001be6:	43db      	mvns	r3, r3
 8001be8:	69ba      	ldr	r2, [r7, #24]
 8001bea:	4013      	ands	r3, r2
 8001bec:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001bee:	683b      	ldr	r3, [r7, #0]
 8001bf0:	691a      	ldr	r2, [r3, #16]
 8001bf2:	69fb      	ldr	r3, [r7, #28]
 8001bf4:	f003 0307 	and.w	r3, r3, #7
 8001bf8:	009b      	lsls	r3, r3, #2
 8001bfa:	fa02 f303 	lsl.w	r3, r2, r3
 8001bfe:	69ba      	ldr	r2, [r7, #24]
 8001c00:	4313      	orrs	r3, r2
 8001c02:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
 8001c04:	69fb      	ldr	r3, [r7, #28]
 8001c06:	08da      	lsrs	r2, r3, #3
 8001c08:	687b      	ldr	r3, [r7, #4]
 8001c0a:	3208      	adds	r2, #8
 8001c0c:	69b9      	ldr	r1, [r7, #24]
 8001c0e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001c12:	687b      	ldr	r3, [r7, #4]
 8001c14:	681b      	ldr	r3, [r3, #0]
 8001c16:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8001c18:	69fb      	ldr	r3, [r7, #28]
 8001c1a:	005b      	lsls	r3, r3, #1
 8001c1c:	2203      	movs	r2, #3
 8001c1e:	fa02 f303 	lsl.w	r3, r2, r3
 8001c22:	43db      	mvns	r3, r3
 8001c24:	69ba      	ldr	r2, [r7, #24]
 8001c26:	4013      	ands	r3, r2
 8001c28:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001c2a:	683b      	ldr	r3, [r7, #0]
 8001c2c:	685b      	ldr	r3, [r3, #4]
 8001c2e:	f003 0203 	and.w	r2, r3, #3
 8001c32:	69fb      	ldr	r3, [r7, #28]
 8001c34:	005b      	lsls	r3, r3, #1
 8001c36:	fa02 f303 	lsl.w	r3, r2, r3
 8001c3a:	69ba      	ldr	r2, [r7, #24]
 8001c3c:	4313      	orrs	r3, r2
 8001c3e:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8001c40:	687b      	ldr	r3, [r7, #4]
 8001c42:	69ba      	ldr	r2, [r7, #24]
 8001c44:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001c46:	683b      	ldr	r3, [r7, #0]
 8001c48:	685b      	ldr	r3, [r3, #4]
 8001c4a:	2b01      	cmp	r3, #1
 8001c4c:	d00b      	beq.n	8001c66 <HAL_GPIO_Init+0xea>
 8001c4e:	683b      	ldr	r3, [r7, #0]
 8001c50:	685b      	ldr	r3, [r3, #4]
 8001c52:	2b02      	cmp	r3, #2
 8001c54:	d007      	beq.n	8001c66 <HAL_GPIO_Init+0xea>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001c56:	683b      	ldr	r3, [r7, #0]
 8001c58:	685b      	ldr	r3, [r3, #4]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001c5a:	2b11      	cmp	r3, #17
 8001c5c:	d003      	beq.n	8001c66 <HAL_GPIO_Init+0xea>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001c5e:	683b      	ldr	r3, [r7, #0]
 8001c60:	685b      	ldr	r3, [r3, #4]
 8001c62:	2b12      	cmp	r3, #18
 8001c64:	d130      	bne.n	8001cc8 <HAL_GPIO_Init+0x14c>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8001c66:	687b      	ldr	r3, [r7, #4]
 8001c68:	689b      	ldr	r3, [r3, #8]
 8001c6a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8001c6c:	69fb      	ldr	r3, [r7, #28]
 8001c6e:	005b      	lsls	r3, r3, #1
 8001c70:	2203      	movs	r2, #3
 8001c72:	fa02 f303 	lsl.w	r3, r2, r3
 8001c76:	43db      	mvns	r3, r3
 8001c78:	69ba      	ldr	r2, [r7, #24]
 8001c7a:	4013      	ands	r3, r2
 8001c7c:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
 8001c7e:	683b      	ldr	r3, [r7, #0]
 8001c80:	68da      	ldr	r2, [r3, #12]
 8001c82:	69fb      	ldr	r3, [r7, #28]
 8001c84:	005b      	lsls	r3, r3, #1
 8001c86:	fa02 f303 	lsl.w	r3, r2, r3
 8001c8a:	69ba      	ldr	r2, [r7, #24]
 8001c8c:	4313      	orrs	r3, r2
 8001c8e:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8001c90:	687b      	ldr	r3, [r7, #4]
 8001c92:	69ba      	ldr	r2, [r7, #24]
 8001c94:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001c96:	687b      	ldr	r3, [r7, #4]
 8001c98:	685b      	ldr	r3, [r3, #4]
 8001c9a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001c9c:	2201      	movs	r2, #1
 8001c9e:	69fb      	ldr	r3, [r7, #28]
 8001ca0:	fa02 f303 	lsl.w	r3, r2, r3
 8001ca4:	43db      	mvns	r3, r3
 8001ca6:	69ba      	ldr	r2, [r7, #24]
 8001ca8:	4013      	ands	r3, r2
 8001caa:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001cac:	683b      	ldr	r3, [r7, #0]
 8001cae:	685b      	ldr	r3, [r3, #4]
 8001cb0:	091b      	lsrs	r3, r3, #4
 8001cb2:	f003 0201 	and.w	r2, r3, #1
 8001cb6:	69fb      	ldr	r3, [r7, #28]
 8001cb8:	fa02 f303 	lsl.w	r3, r2, r3
 8001cbc:	69ba      	ldr	r2, [r7, #24]
 8001cbe:	4313      	orrs	r3, r2
 8001cc0:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8001cc2:	687b      	ldr	r3, [r7, #4]
 8001cc4:	69ba      	ldr	r2, [r7, #24]
 8001cc6:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001cc8:	687b      	ldr	r3, [r7, #4]
 8001cca:	68db      	ldr	r3, [r3, #12]
 8001ccc:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8001cce:	69fb      	ldr	r3, [r7, #28]
 8001cd0:	005b      	lsls	r3, r3, #1
 8001cd2:	2203      	movs	r2, #3
 8001cd4:	fa02 f303 	lsl.w	r3, r2, r3
 8001cd8:	43db      	mvns	r3, r3
 8001cda:	69ba      	ldr	r2, [r7, #24]
 8001cdc:	4013      	ands	r3, r2
 8001cde:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001ce0:	683b      	ldr	r3, [r7, #0]
 8001ce2:	689a      	ldr	r2, [r3, #8]
 8001ce4:	69fb      	ldr	r3, [r7, #28]
 8001ce6:	005b      	lsls	r3, r3, #1
 8001ce8:	fa02 f303 	lsl.w	r3, r2, r3
 8001cec:	69ba      	ldr	r2, [r7, #24]
 8001cee:	4313      	orrs	r3, r2
 8001cf0:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8001cf2:	687b      	ldr	r3, [r7, #4]
 8001cf4:	69ba      	ldr	r2, [r7, #24]
 8001cf6:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001cf8:	683b      	ldr	r3, [r7, #0]
 8001cfa:	685b      	ldr	r3, [r3, #4]
 8001cfc:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001d00:	2b00      	cmp	r3, #0
 8001d02:	f000 80be 	beq.w	8001e82 <HAL_GPIO_Init+0x306>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001d06:	4b65      	ldr	r3, [pc, #404]	; (8001e9c <HAL_GPIO_Init+0x320>)
 8001d08:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001d0a:	4a64      	ldr	r2, [pc, #400]	; (8001e9c <HAL_GPIO_Init+0x320>)
 8001d0c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001d10:	6453      	str	r3, [r2, #68]	; 0x44
 8001d12:	4b62      	ldr	r3, [pc, #392]	; (8001e9c <HAL_GPIO_Init+0x320>)
 8001d14:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001d16:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001d1a:	60fb      	str	r3, [r7, #12]
 8001d1c:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 8001d1e:	4a60      	ldr	r2, [pc, #384]	; (8001ea0 <HAL_GPIO_Init+0x324>)
 8001d20:	69fb      	ldr	r3, [r7, #28]
 8001d22:	089b      	lsrs	r3, r3, #2
 8001d24:	3302      	adds	r3, #2
 8001d26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8001d2a:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001d2c:	69fb      	ldr	r3, [r7, #28]
 8001d2e:	f003 0303 	and.w	r3, r3, #3
 8001d32:	009b      	lsls	r3, r3, #2
 8001d34:	220f      	movs	r2, #15
 8001d36:	fa02 f303 	lsl.w	r3, r2, r3
 8001d3a:	43db      	mvns	r3, r3
 8001d3c:	69ba      	ldr	r2, [r7, #24]
 8001d3e:	4013      	ands	r3, r2
 8001d40:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8001d42:	687b      	ldr	r3, [r7, #4]
 8001d44:	4a57      	ldr	r2, [pc, #348]	; (8001ea4 <HAL_GPIO_Init+0x328>)
 8001d46:	4293      	cmp	r3, r2
 8001d48:	d037      	beq.n	8001dba <HAL_GPIO_Init+0x23e>
 8001d4a:	687b      	ldr	r3, [r7, #4]
 8001d4c:	4a56      	ldr	r2, [pc, #344]	; (8001ea8 <HAL_GPIO_Init+0x32c>)
 8001d4e:	4293      	cmp	r3, r2
 8001d50:	d031      	beq.n	8001db6 <HAL_GPIO_Init+0x23a>
 8001d52:	687b      	ldr	r3, [r7, #4]
 8001d54:	4a55      	ldr	r2, [pc, #340]	; (8001eac <HAL_GPIO_Init+0x330>)
 8001d56:	4293      	cmp	r3, r2
 8001d58:	d02b      	beq.n	8001db2 <HAL_GPIO_Init+0x236>
 8001d5a:	687b      	ldr	r3, [r7, #4]
 8001d5c:	4a54      	ldr	r2, [pc, #336]	; (8001eb0 <HAL_GPIO_Init+0x334>)
 8001d5e:	4293      	cmp	r3, r2
 8001d60:	d025      	beq.n	8001dae <HAL_GPIO_Init+0x232>
 8001d62:	687b      	ldr	r3, [r7, #4]
 8001d64:	4a53      	ldr	r2, [pc, #332]	; (8001eb4 <HAL_GPIO_Init+0x338>)
 8001d66:	4293      	cmp	r3, r2
 8001d68:	d01f      	beq.n	8001daa <HAL_GPIO_Init+0x22e>
 8001d6a:	687b      	ldr	r3, [r7, #4]
 8001d6c:	4a52      	ldr	r2, [pc, #328]	; (8001eb8 <HAL_GPIO_Init+0x33c>)
 8001d6e:	4293      	cmp	r3, r2
 8001d70:	d019      	beq.n	8001da6 <HAL_GPIO_Init+0x22a>
 8001d72:	687b      	ldr	r3, [r7, #4]
 8001d74:	4a51      	ldr	r2, [pc, #324]	; (8001ebc <HAL_GPIO_Init+0x340>)
 8001d76:	4293      	cmp	r3, r2
 8001d78:	d013      	beq.n	8001da2 <HAL_GPIO_Init+0x226>
 8001d7a:	687b      	ldr	r3, [r7, #4]
 8001d7c:	4a50      	ldr	r2, [pc, #320]	; (8001ec0 <HAL_GPIO_Init+0x344>)
 8001d7e:	4293      	cmp	r3, r2
 8001d80:	d00d      	beq.n	8001d9e <HAL_GPIO_Init+0x222>
 8001d82:	687b      	ldr	r3, [r7, #4]
 8001d84:	4a4f      	ldr	r2, [pc, #316]	; (8001ec4 <HAL_GPIO_Init+0x348>)
 8001d86:	4293      	cmp	r3, r2
 8001d88:	d007      	beq.n	8001d9a <HAL_GPIO_Init+0x21e>
 8001d8a:	687b      	ldr	r3, [r7, #4]
 8001d8c:	4a4e      	ldr	r2, [pc, #312]	; (8001ec8 <HAL_GPIO_Init+0x34c>)
 8001d8e:	4293      	cmp	r3, r2
 8001d90:	d101      	bne.n	8001d96 <HAL_GPIO_Init+0x21a>
 8001d92:	2309      	movs	r3, #9
 8001d94:	e012      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001d96:	230a      	movs	r3, #10
 8001d98:	e010      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001d9a:	2308      	movs	r3, #8
 8001d9c:	e00e      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001d9e:	2307      	movs	r3, #7
 8001da0:	e00c      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001da2:	2306      	movs	r3, #6
 8001da4:	e00a      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001da6:	2305      	movs	r3, #5
 8001da8:	e008      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001daa:	2304      	movs	r3, #4
 8001dac:	e006      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001dae:	2303      	movs	r3, #3
 8001db0:	e004      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001db2:	2302      	movs	r3, #2
 8001db4:	e002      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001db6:	2301      	movs	r3, #1
 8001db8:	e000      	b.n	8001dbc <HAL_GPIO_Init+0x240>
 8001dba:	2300      	movs	r3, #0
 8001dbc:	69fa      	ldr	r2, [r7, #28]
 8001dbe:	f002 0203 	and.w	r2, r2, #3
 8001dc2:	0092      	lsls	r2, r2, #2
 8001dc4:	4093      	lsls	r3, r2
 8001dc6:	69ba      	ldr	r2, [r7, #24]
 8001dc8:	4313      	orrs	r3, r2
 8001dca:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
 8001dcc:	4934      	ldr	r1, [pc, #208]	; (8001ea0 <HAL_GPIO_Init+0x324>)
 8001dce:	69fb      	ldr	r3, [r7, #28]
 8001dd0:	089b      	lsrs	r3, r3, #2
 8001dd2:	3302      	adds	r3, #2
 8001dd4:	69ba      	ldr	r2, [r7, #24]
 8001dd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001dda:	4b3c      	ldr	r3, [pc, #240]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001ddc:	681b      	ldr	r3, [r3, #0]
 8001dde:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001de0:	693b      	ldr	r3, [r7, #16]
 8001de2:	43db      	mvns	r3, r3
 8001de4:	69ba      	ldr	r2, [r7, #24]
 8001de6:	4013      	ands	r3, r2
 8001de8:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001dea:	683b      	ldr	r3, [r7, #0]
 8001dec:	685b      	ldr	r3, [r3, #4]
 8001dee:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001df2:	2b00      	cmp	r3, #0
 8001df4:	d003      	beq.n	8001dfe <HAL_GPIO_Init+0x282>
        {
          temp |= iocurrent;
 8001df6:	69ba      	ldr	r2, [r7, #24]
 8001df8:	693b      	ldr	r3, [r7, #16]
 8001dfa:	4313      	orrs	r3, r2
 8001dfc:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8001dfe:	4a33      	ldr	r2, [pc, #204]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e00:	69bb      	ldr	r3, [r7, #24]
 8001e02:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 8001e04:	4b31      	ldr	r3, [pc, #196]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e06:	685b      	ldr	r3, [r3, #4]
 8001e08:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001e0a:	693b      	ldr	r3, [r7, #16]
 8001e0c:	43db      	mvns	r3, r3
 8001e0e:	69ba      	ldr	r2, [r7, #24]
 8001e10:	4013      	ands	r3, r2
 8001e12:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001e14:	683b      	ldr	r3, [r7, #0]
 8001e16:	685b      	ldr	r3, [r3, #4]
 8001e18:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001e1c:	2b00      	cmp	r3, #0
 8001e1e:	d003      	beq.n	8001e28 <HAL_GPIO_Init+0x2ac>
        {
          temp |= iocurrent;
 8001e20:	69ba      	ldr	r2, [r7, #24]
 8001e22:	693b      	ldr	r3, [r7, #16]
 8001e24:	4313      	orrs	r3, r2
 8001e26:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8001e28:	4a28      	ldr	r2, [pc, #160]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e2a:	69bb      	ldr	r3, [r7, #24]
 8001e2c:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001e2e:	4b27      	ldr	r3, [pc, #156]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e30:	689b      	ldr	r3, [r3, #8]
 8001e32:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001e34:	693b      	ldr	r3, [r7, #16]
 8001e36:	43db      	mvns	r3, r3
 8001e38:	69ba      	ldr	r2, [r7, #24]
 8001e3a:	4013      	ands	r3, r2
 8001e3c:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001e3e:	683b      	ldr	r3, [r7, #0]
 8001e40:	685b      	ldr	r3, [r3, #4]
 8001e42:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001e46:	2b00      	cmp	r3, #0
 8001e48:	d003      	beq.n	8001e52 <HAL_GPIO_Init+0x2d6>
        {
          temp |= iocurrent;
 8001e4a:	69ba      	ldr	r2, [r7, #24]
 8001e4c:	693b      	ldr	r3, [r7, #16]
 8001e4e:	4313      	orrs	r3, r2
 8001e50:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8001e52:	4a1e      	ldr	r2, [pc, #120]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e54:	69bb      	ldr	r3, [r7, #24]
 8001e56:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8001e58:	4b1c      	ldr	r3, [pc, #112]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e5a:	68db      	ldr	r3, [r3, #12]
 8001e5c:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8001e5e:	693b      	ldr	r3, [r7, #16]
 8001e60:	43db      	mvns	r3, r3
 8001e62:	69ba      	ldr	r2, [r7, #24]
 8001e64:	4013      	ands	r3, r2
 8001e66:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001e68:	683b      	ldr	r3, [r7, #0]
 8001e6a:	685b      	ldr	r3, [r3, #4]
 8001e6c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001e70:	2b00      	cmp	r3, #0
 8001e72:	d003      	beq.n	8001e7c <HAL_GPIO_Init+0x300>
        {
          temp |= iocurrent;
 8001e74:	69ba      	ldr	r2, [r7, #24]
 8001e76:	693b      	ldr	r3, [r7, #16]
 8001e78:	4313      	orrs	r3, r2
 8001e7a:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8001e7c:	4a13      	ldr	r2, [pc, #76]	; (8001ecc <HAL_GPIO_Init+0x350>)
 8001e7e:	69bb      	ldr	r3, [r7, #24]
 8001e80:	60d3      	str	r3, [r2, #12]
  for(position = 0; position < GPIO_NUMBER; position++)
 8001e82:	69fb      	ldr	r3, [r7, #28]
 8001e84:	3301      	adds	r3, #1
 8001e86:	61fb      	str	r3, [r7, #28]
 8001e88:	69fb      	ldr	r3, [r7, #28]
 8001e8a:	2b0f      	cmp	r3, #15
 8001e8c:	f67f ae86 	bls.w	8001b9c <HAL_GPIO_Init+0x20>
      }
    }
  }
}
 8001e90:	bf00      	nop
 8001e92:	3724      	adds	r7, #36	; 0x24
 8001e94:	46bd      	mov	sp, r7
 8001e96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001e9a:	4770      	bx	lr
 8001e9c:	40023800 	.word	0x40023800
 8001ea0:	40013800 	.word	0x40013800
 8001ea4:	40020000 	.word	0x40020000
 8001ea8:	40020400 	.word	0x40020400
 8001eac:	40020800 	.word	0x40020800
 8001eb0:	40020c00 	.word	0x40020c00
 8001eb4:	40021000 	.word	0x40021000
 8001eb8:	40021400 	.word	0x40021400
 8001ebc:	40021800 	.word	0x40021800
 8001ec0:	40021c00 	.word	0x40021c00
 8001ec4:	40022000 	.word	0x40022000
 8001ec8:	40022400 	.word	0x40022400
 8001ecc:	40013c00 	.word	0x40013c00

08001ed0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8001ed0:	b480      	push	{r7}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	af00      	add	r7, sp, #0
 8001ed6:	6078      	str	r0, [r7, #4]
 8001ed8:	460b      	mov	r3, r1
 8001eda:	807b      	strh	r3, [r7, #2]
 8001edc:	4613      	mov	r3, r2
 8001ede:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8001ee0:	787b      	ldrb	r3, [r7, #1]
 8001ee2:	2b00      	cmp	r3, #0
 8001ee4:	d003      	beq.n	8001eee <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8001ee6:	887a      	ldrh	r2, [r7, #2]
 8001ee8:	687b      	ldr	r3, [r7, #4]
 8001eea:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
  }
}
 8001eec:	e003      	b.n	8001ef6 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16;
 8001eee:	887b      	ldrh	r3, [r7, #2]
 8001ef0:	041a      	lsls	r2, r3, #16
 8001ef2:	687b      	ldr	r3, [r7, #4]
 8001ef4:	619a      	str	r2, [r3, #24]
}
 8001ef6:	bf00      	nop
 8001ef8:	370c      	adds	r7, #12
 8001efa:	46bd      	mov	sp, r7
 8001efc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f00:	4770      	bx	lr

08001f02 <HAL_GPIO_TogglePin>:
  * @param  GPIOx Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8001f02:	b480      	push	{r7}
 8001f04:	b083      	sub	sp, #12
 8001f06:	af00      	add	r7, sp, #0
 8001f08:	6078      	str	r0, [r7, #4]
 8001f0a:	460b      	mov	r3, r1
 8001f0c:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if ((GPIOx->ODR & GPIO_Pin) == GPIO_Pin)
 8001f0e:	687b      	ldr	r3, [r7, #4]
 8001f10:	695a      	ldr	r2, [r3, #20]
 8001f12:	887b      	ldrh	r3, [r7, #2]
 8001f14:	401a      	ands	r2, r3
 8001f16:	887b      	ldrh	r3, [r7, #2]
 8001f18:	429a      	cmp	r2, r3
 8001f1a:	d104      	bne.n	8001f26 <HAL_GPIO_TogglePin+0x24>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8001f1c:	887b      	ldrh	r3, [r7, #2]
 8001f1e:	041a      	lsls	r2, r3, #16
 8001f20:	687b      	ldr	r3, [r7, #4]
 8001f22:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = GPIO_Pin;
  }
}
 8001f24:	e002      	b.n	8001f2c <HAL_GPIO_TogglePin+0x2a>
    GPIOx->BSRR = GPIO_Pin;
 8001f26:	887a      	ldrh	r2, [r7, #2]
 8001f28:	687b      	ldr	r3, [r7, #4]
 8001f2a:	619a      	str	r2, [r3, #24]
}
 8001f2c:	bf00      	nop
 8001f2e:	370c      	adds	r7, #12
 8001f30:	46bd      	mov	sp, r7
 8001f32:	f85d 7b04 	ldr.w	r7, [sp], #4
 8001f36:	4770      	bx	lr

08001f38 <HAL_HCD_Init>:
  * @brief  Initialize the host driver.
  * @param  hhcd HCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HCD_Init(HCD_HandleTypeDef *hhcd)
{
 8001f38:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001f3a:	b08d      	sub	sp, #52	; 0x34
 8001f3c:	af0a      	add	r7, sp, #40	; 0x28
 8001f3e:	6078      	str	r0, [r7, #4]
  /* Check the HCD handle allocation */
  if (hhcd == NULL)
 8001f40:	687b      	ldr	r3, [r7, #4]
 8001f42:	2b00      	cmp	r3, #0
 8001f44:	d101      	bne.n	8001f4a <HAL_HCD_Init+0x12>
  {
    return HAL_ERROR;
 8001f46:	2301      	movs	r3, #1
 8001f48:	e048      	b.n	8001fdc <HAL_HCD_Init+0xa4>
  }

  /* Check the parameters */
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));

  if (hhcd->State == HAL_HCD_STATE_RESET)
 8001f4a:	687b      	ldr	r3, [r7, #4]
 8001f4c:	f893 32b9 	ldrb.w	r3, [r3, #697]	; 0x2b9
 8001f50:	b2db      	uxtb	r3, r3
 8001f52:	2b00      	cmp	r3, #0
 8001f54:	d106      	bne.n	8001f64 <HAL_HCD_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hhcd->Lock = HAL_UNLOCKED;
 8001f56:	687b      	ldr	r3, [r7, #4]
 8001f58:	2200      	movs	r2, #0
 8001f5a:	f883 22b8 	strb.w	r2, [r3, #696]	; 0x2b8

    /* Init the low level hardware */
    hhcd->MspInitCallback(hhcd);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_HCD_MspInit(hhcd);
 8001f5e:	6878      	ldr	r0, [r7, #4]
 8001f60:	f008 f83a 	bl	8009fd8 <HAL_HCD_MspInit>
#endif /* (USE_HAL_HCD_REGISTER_CALLBACKS) */
  }

  hhcd->State = HAL_HCD_STATE_BUSY;
 8001f64:	687b      	ldr	r3, [r7, #4]
 8001f66:	2203      	movs	r2, #3
 8001f68:	f883 22b9 	strb.w	r2, [r3, #697]	; 0x2b9

  /* Disable the Interrupts */
  __HAL_HCD_DISABLE(hhcd);
 8001f6c:	687b      	ldr	r3, [r7, #4]
 8001f6e:	681b      	ldr	r3, [r3, #0]
 8001f70:	4618      	mov	r0, r3
 8001f72:	f005 ff35 	bl	8007de0 <USB_DisableGlobalInt>

  /* Init the Core (common init.) */
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8001f76:	687b      	ldr	r3, [r7, #4]
 8001f78:	681b      	ldr	r3, [r3, #0]
 8001f7a:	603b      	str	r3, [r7, #0]
 8001f7c:	687e      	ldr	r6, [r7, #4]
 8001f7e:	466d      	mov	r5, sp
 8001f80:	f106 0410 	add.w	r4, r6, #16
 8001f84:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001f86:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8001f88:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001f8a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8001f8c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8001f90:	e885 0003 	stmia.w	r5, {r0, r1}
 8001f94:	1d33      	adds	r3, r6, #4
 8001f96:	cb0e      	ldmia	r3, {r1, r2, r3}
 8001f98:	6838      	ldr	r0, [r7, #0]
 8001f9a:	f005 fec9 	bl	8007d30 <USB_CoreInit>

  /* Force Host Mode*/
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
 8001f9e:	687b      	ldr	r3, [r7, #4]
 8001fa0:	681b      	ldr	r3, [r3, #0]
 8001fa2:	2101      	movs	r1, #1
 8001fa4:	4618      	mov	r0, r3
 8001fa6:	f005 ff2c 	bl	8007e02 <USB_SetCurrentMode>

  /* Init Host */
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 8001faa:	687b      	ldr	r3, [r7, #4]
 8001fac:	681b      	ldr	r3, [r3, #0]
 8001fae:	603b      	str	r3, [r7, #0]
 8001fb0:	687e      	ldr	r6, [r7, #4]
 8001fb2:	466d      	mov	r5, sp
 8001fb4:	f106 0410 	add.w	r4, r6, #16
 8001fb8:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001fba:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8001fbc:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8001fbe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8001fc0:	e894 0003 	ldmia.w	r4, {r0, r1}
 8001fc4:	e885 0003 	stmia.w	r5, {r0, r1}
 8001fc8:	1d33      	adds	r3, r6, #4
 8001fca:	cb0e      	ldmia	r3, {r1, r2, r3}
 8001fcc:	6838      	ldr	r0, [r7, #0]
 8001fce:	f006 f809 	bl	8007fe4 <USB_HostInit>

  hhcd->State = HAL_HCD_STATE_READY;
 8001fd2:	687b      	ldr	r3, [r7, #4]
 8001fd4:	2201      	movs	r2, #1
 8001fd6:	f883 22b9 	strb.w	r2, [r3, #697]	; 0x2b9

  return HAL_OK;
 8001fda:	2300      	movs	r3, #0
}
 8001fdc:	4618      	mov	r0, r3
 8001fde:	370c      	adds	r7, #12
 8001fe0:	46bd      	mov	sp, r7
 8001fe2:	bdf0      	pop	{r4, r5, r6, r7, pc}

08001fe4 <HAL_HCD_IRQHandler>:
  * @brief  Handle HCD interrupt request.
  * @param  hhcd HCD handle
  * @retval None
  */
void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8001fe4:	b580      	push	{r7, lr}
 8001fe6:	b086      	sub	sp, #24
 8001fe8:	af00      	add	r7, sp, #0
 8001fea:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8001fec:	687b      	ldr	r3, [r7, #4]
 8001fee:	681b      	ldr	r3, [r3, #0]
 8001ff0:	613b      	str	r3, [r7, #16]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8001ff2:	693b      	ldr	r3, [r7, #16]
 8001ff4:	60fb      	str	r3, [r7, #12]
  uint32_t i, interrupt;

  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 8001ff6:	687b      	ldr	r3, [r7, #4]
 8001ff8:	681b      	ldr	r3, [r3, #0]
 8001ffa:	4618      	mov	r0, r3
 8001ffc:	f005 ffb0 	bl	8007f60 <USB_GetMode>
 8002000:	4603      	mov	r3, r0
 8002002:	2b01      	cmp	r3, #1
 8002004:	f040 80f1 	bne.w	80021ea <HAL_HCD_IRQHandler+0x206>
  {
    /* Avoid spurious interrupt */
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 8002008:	687b      	ldr	r3, [r7, #4]
 800200a:	681b      	ldr	r3, [r3, #0]
 800200c:	4618      	mov	r0, r3
 800200e:	f005 ff94 	bl	8007f3a <USB_ReadInterrupts>
 8002012:	4603      	mov	r3, r0
 8002014:	2b00      	cmp	r3, #0
 8002016:	f000 80e7 	beq.w	80021e8 <HAL_HCD_IRQHandler+0x204>
    {
      return;
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 800201a:	687b      	ldr	r3, [r7, #4]
 800201c:	681b      	ldr	r3, [r3, #0]
 800201e:	4618      	mov	r0, r3
 8002020:	f005 ff8b 	bl	8007f3a <USB_ReadInterrupts>
 8002024:	4603      	mov	r3, r0
 8002026:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800202a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800202e:	d104      	bne.n	800203a <HAL_HCD_IRQHandler+0x56>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 8002030:	687b      	ldr	r3, [r7, #4]
 8002032:	681b      	ldr	r3, [r3, #0]
 8002034:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 8002038:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 800203a:	687b      	ldr	r3, [r7, #4]
 800203c:	681b      	ldr	r3, [r3, #0]
 800203e:	4618      	mov	r0, r3
 8002040:	f005 ff7b 	bl	8007f3a <USB_ReadInterrupts>
 8002044:	4603      	mov	r3, r0
 8002046:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 800204a:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800204e:	d104      	bne.n	800205a <HAL_HCD_IRQHandler+0x76>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 8002050:	687b      	ldr	r3, [r7, #4]
 8002052:	681b      	ldr	r3, [r3, #0]
 8002054:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8002058:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 800205a:	687b      	ldr	r3, [r7, #4]
 800205c:	681b      	ldr	r3, [r3, #0]
 800205e:	4618      	mov	r0, r3
 8002060:	f005 ff6b 	bl	8007f3a <USB_ReadInterrupts>
 8002064:	4603      	mov	r3, r0
 8002066:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800206a:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800206e:	d104      	bne.n	800207a <HAL_HCD_IRQHandler+0x96>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8002070:	687b      	ldr	r3, [r7, #4]
 8002072:	681b      	ldr	r3, [r3, #0]
 8002074:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 8002078:	615a      	str	r2, [r3, #20]
    }

    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 800207a:	687b      	ldr	r3, [r7, #4]
 800207c:	681b      	ldr	r3, [r3, #0]
 800207e:	4618      	mov	r0, r3
 8002080:	f005 ff5b 	bl	8007f3a <USB_ReadInterrupts>
 8002084:	4603      	mov	r3, r0
 8002086:	f003 0302 	and.w	r3, r3, #2
 800208a:	2b02      	cmp	r3, #2
 800208c:	d103      	bne.n	8002096 <HAL_HCD_IRQHandler+0xb2>
    {
      /* Incorrect mode, acknowledge the interrupt */
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 800208e:	687b      	ldr	r3, [r7, #4]
 8002090:	681b      	ldr	r3, [r3, #0]
 8002092:	2202      	movs	r2, #2
 8002094:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host Disconnect Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 8002096:	687b      	ldr	r3, [r7, #4]
 8002098:	681b      	ldr	r3, [r3, #0]
 800209a:	4618      	mov	r0, r3
 800209c:	f005 ff4d 	bl	8007f3a <USB_ReadInterrupts>
 80020a0:	4603      	mov	r3, r0
 80020a2:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80020a6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80020aa:	d117      	bne.n	80020dc <HAL_HCD_IRQHandler+0xf8>
    {

      /* Cleanup HPRT */
      USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 80020ac:	68fb      	ldr	r3, [r7, #12]
 80020ae:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80020b2:	681b      	ldr	r3, [r3, #0]
 80020b4:	68fa      	ldr	r2, [r7, #12]
 80020b6:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 80020ba:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 80020be:	6013      	str	r3, [r2, #0]

      /* Handle Host Port Disconnect Interrupt */
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->DisconnectCallback(hhcd);
#else
      HAL_HCD_Disconnect_Callback(hhcd);
 80020c0:	6878      	ldr	r0, [r7, #4]
 80020c2:	f000 f8a9 	bl	8002218 <HAL_HCD_Disconnect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */

      (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 80020c6:	687b      	ldr	r3, [r7, #4]
 80020c8:	681b      	ldr	r3, [r3, #0]
 80020ca:	2101      	movs	r1, #1
 80020cc:	4618      	mov	r0, r3
 80020ce:	f006 f839 	bl	8008144 <USB_InitFSLSPClkSel>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 80020d2:	687b      	ldr	r3, [r7, #4]
 80020d4:	681b      	ldr	r3, [r3, #0]
 80020d6:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 80020da:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host Port Interrupts */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 80020dc:	687b      	ldr	r3, [r7, #4]
 80020de:	681b      	ldr	r3, [r3, #0]
 80020e0:	4618      	mov	r0, r3
 80020e2:	f005 ff2a 	bl	8007f3a <USB_ReadInterrupts>
 80020e6:	4603      	mov	r3, r0
 80020e8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80020ec:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80020f0:	d102      	bne.n	80020f8 <HAL_HCD_IRQHandler+0x114>
    {
      HCD_Port_IRQHandler(hhcd);
 80020f2:	6878      	ldr	r0, [r7, #4]
 80020f4:	f001 f874 	bl	80031e0 <HCD_Port_IRQHandler>
    }

    /* Handle Host SOF Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 80020f8:	687b      	ldr	r3, [r7, #4]
 80020fa:	681b      	ldr	r3, [r3, #0]
 80020fc:	4618      	mov	r0, r3
 80020fe:	f005 ff1c 	bl	8007f3a <USB_ReadInterrupts>
 8002102:	4603      	mov	r3, r0
 8002104:	f003 0308 	and.w	r3, r3, #8
 8002108:	2b08      	cmp	r3, #8
 800210a:	d106      	bne.n	800211a <HAL_HCD_IRQHandler+0x136>
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->SOFCallback(hhcd);
#else
      HAL_HCD_SOF_Callback(hhcd);
 800210c:	6878      	ldr	r0, [r7, #4]
 800210e:	f000 f86f 	bl	80021f0 <HAL_HCD_SOF_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */

      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 8002112:	687b      	ldr	r3, [r7, #4]
 8002114:	681b      	ldr	r3, [r3, #0]
 8002116:	2208      	movs	r2, #8
 8002118:	615a      	str	r2, [r3, #20]
    }

    /* Handle Host channel Interrupt */
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 800211a:	687b      	ldr	r3, [r7, #4]
 800211c:	681b      	ldr	r3, [r3, #0]
 800211e:	4618      	mov	r0, r3
 8002120:	f005 ff0b 	bl	8007f3a <USB_ReadInterrupts>
 8002124:	4603      	mov	r3, r0
 8002126:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800212a:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800212e:	d138      	bne.n	80021a2 <HAL_HCD_IRQHandler+0x1be>
    {
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 8002130:	687b      	ldr	r3, [r7, #4]
 8002132:	681b      	ldr	r3, [r3, #0]
 8002134:	4618      	mov	r0, r3
 8002136:	f006 f878 	bl	800822a <USB_HC_ReadInterrupt>
 800213a:	60b8      	str	r0, [r7, #8]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 800213c:	2300      	movs	r3, #0
 800213e:	617b      	str	r3, [r7, #20]
 8002140:	e025      	b.n	800218e <HAL_HCD_IRQHandler+0x1aa>
      {
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 8002142:	697b      	ldr	r3, [r7, #20]
 8002144:	f003 030f 	and.w	r3, r3, #15
 8002148:	68ba      	ldr	r2, [r7, #8]
 800214a:	fa22 f303 	lsr.w	r3, r2, r3
 800214e:	f003 0301 	and.w	r3, r3, #1
 8002152:	2b00      	cmp	r3, #0
 8002154:	d018      	beq.n	8002188 <HAL_HCD_IRQHandler+0x1a4>
        {
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8002156:	697b      	ldr	r3, [r7, #20]
 8002158:	015a      	lsls	r2, r3, #5
 800215a:	68fb      	ldr	r3, [r7, #12]
 800215c:	4413      	add	r3, r2
 800215e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002162:	681b      	ldr	r3, [r3, #0]
 8002164:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8002168:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800216c:	d106      	bne.n	800217c <HAL_HCD_IRQHandler+0x198>
          {
            HCD_HC_IN_IRQHandler(hhcd, (uint8_t)i);
 800216e:	697b      	ldr	r3, [r7, #20]
 8002170:	b2db      	uxtb	r3, r3
 8002172:	4619      	mov	r1, r3
 8002174:	6878      	ldr	r0, [r7, #4]
 8002176:	f000 f87b 	bl	8002270 <HCD_HC_IN_IRQHandler>
 800217a:	e005      	b.n	8002188 <HAL_HCD_IRQHandler+0x1a4>
          }
          else
          {
            HCD_HC_OUT_IRQHandler(hhcd, (uint8_t)i);
 800217c:	697b      	ldr	r3, [r7, #20]
 800217e:	b2db      	uxtb	r3, r3
 8002180:	4619      	mov	r1, r3
 8002182:	6878      	ldr	r0, [r7, #4]
 8002184:	f000 fc0b 	bl	800299e <HCD_HC_OUT_IRQHandler>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8002188:	697b      	ldr	r3, [r7, #20]
 800218a:	3301      	adds	r3, #1
 800218c:	617b      	str	r3, [r7, #20]
 800218e:	687b      	ldr	r3, [r7, #4]
 8002190:	689b      	ldr	r3, [r3, #8]
 8002192:	697a      	ldr	r2, [r7, #20]
 8002194:	429a      	cmp	r2, r3
 8002196:	d3d4      	bcc.n	8002142 <HAL_HCD_IRQHandler+0x15e>
          }
        }
      }
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 8002198:	687b      	ldr	r3, [r7, #4]
 800219a:	681b      	ldr	r3, [r3, #0]
 800219c:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 80021a0:	615a      	str	r2, [r3, #20]
    }

    /* Handle Rx Queue Level Interrupts */
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 80021a2:	687b      	ldr	r3, [r7, #4]
 80021a4:	681b      	ldr	r3, [r3, #0]
 80021a6:	4618      	mov	r0, r3
 80021a8:	f005 fec7 	bl	8007f3a <USB_ReadInterrupts>
 80021ac:	4603      	mov	r3, r0
 80021ae:	f003 0310 	and.w	r3, r3, #16
 80021b2:	2b10      	cmp	r3, #16
 80021b4:	d101      	bne.n	80021ba <HAL_HCD_IRQHandler+0x1d6>
 80021b6:	2301      	movs	r3, #1
 80021b8:	e000      	b.n	80021bc <HAL_HCD_IRQHandler+0x1d8>
 80021ba:	2300      	movs	r3, #0
 80021bc:	2b00      	cmp	r3, #0
 80021be:	d014      	beq.n	80021ea <HAL_HCD_IRQHandler+0x206>
    {
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80021c0:	687b      	ldr	r3, [r7, #4]
 80021c2:	681b      	ldr	r3, [r3, #0]
 80021c4:	699a      	ldr	r2, [r3, #24]
 80021c6:	687b      	ldr	r3, [r7, #4]
 80021c8:	681b      	ldr	r3, [r3, #0]
 80021ca:	f022 0210 	bic.w	r2, r2, #16
 80021ce:	619a      	str	r2, [r3, #24]

      HCD_RXQLVL_IRQHandler(hhcd);
 80021d0:	6878      	ldr	r0, [r7, #4]
 80021d2:	f000 ff59 	bl	8003088 <HCD_RXQLVL_IRQHandler>

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80021d6:	687b      	ldr	r3, [r7, #4]
 80021d8:	681b      	ldr	r3, [r3, #0]
 80021da:	699a      	ldr	r2, [r3, #24]
 80021dc:	687b      	ldr	r3, [r7, #4]
 80021de:	681b      	ldr	r3, [r3, #0]
 80021e0:	f042 0210 	orr.w	r2, r2, #16
 80021e4:	619a      	str	r2, [r3, #24]
 80021e6:	e000      	b.n	80021ea <HAL_HCD_IRQHandler+0x206>
      return;
 80021e8:	bf00      	nop
    }
  }
}
 80021ea:	3718      	adds	r7, #24
 80021ec:	46bd      	mov	sp, r7
 80021ee:	bd80      	pop	{r7, pc}

080021f0 <HAL_HCD_SOF_Callback>:
  * @brief  SOF callback.
  * @param  hhcd HCD handle
  * @retval None
  */
__weak void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
 80021f0:	b480      	push	{r7}
 80021f2:	b083      	sub	sp, #12
 80021f4:	af00      	add	r7, sp, #0
 80021f6:	6078      	str	r0, [r7, #4]
  UNUSED(hhcd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_HCD_SOF_Callback could be implemented in the user file
   */
}
 80021f8:	bf00      	nop
 80021fa:	370c      	adds	r7, #12
 80021fc:	46bd      	mov	sp, r7
 80021fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002202:	4770      	bx	lr

08002204 <HAL_HCD_Connect_Callback>:
  * @brief Connection Event callback.
  * @param  hhcd HCD handle
  * @retval None
  */
__weak void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
 8002204:	b480      	push	{r7}
 8002206:	b083      	sub	sp, #12
 8002208:	af00      	add	r7, sp, #0
 800220a:	6078      	str	r0, [r7, #4]
  UNUSED(hhcd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_HCD_Connect_Callback could be implemented in the user file
   */
}
 800220c:	bf00      	nop
 800220e:	370c      	adds	r7, #12
 8002210:	46bd      	mov	sp, r7
 8002212:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002216:	4770      	bx	lr

08002218 <HAL_HCD_Disconnect_Callback>:
  * @brief  Disconnection Event callback.
  * @param  hhcd HCD handle
  * @retval None
  */
__weak void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
 8002218:	b480      	push	{r7}
 800221a:	b083      	sub	sp, #12
 800221c:	af00      	add	r7, sp, #0
 800221e:	6078      	str	r0, [r7, #4]
  UNUSED(hhcd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_HCD_Disconnect_Callback could be implemented in the user file
   */
}
 8002220:	bf00      	nop
 8002222:	370c      	adds	r7, #12
 8002224:	46bd      	mov	sp, r7
 8002226:	f85d 7b04 	ldr.w	r7, [sp], #4
 800222a:	4770      	bx	lr

0800222c <HAL_HCD_PortEnabled_Callback>:
  * @brief  Port Enabled  Event callback.
  * @param  hhcd HCD handle
  * @retval None
  */
__weak void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
 800222c:	b480      	push	{r7}
 800222e:	b083      	sub	sp, #12
 8002230:	af00      	add	r7, sp, #0
 8002232:	6078      	str	r0, [r7, #4]
  UNUSED(hhcd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_HCD_Disconnect_Callback could be implemented in the user file
   */
}
 8002234:	bf00      	nop
 8002236:	370c      	adds	r7, #12
 8002238:	46bd      	mov	sp, r7
 800223a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800223e:	4770      	bx	lr

08002240 <HAL_HCD_PortDisabled_Callback>:
  * @brief  Port Disabled  Event callback.
  * @param  hhcd HCD handle
  * @retval None
  */
__weak void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
 8002240:	b480      	push	{r7}
 8002242:	b083      	sub	sp, #12
 8002244:	af00      	add	r7, sp, #0
 8002246:	6078      	str	r0, [r7, #4]
  UNUSED(hhcd);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_HCD_Disconnect_Callback could be implemented in the user file
   */
}
 8002248:	bf00      	nop
 800224a:	370c      	adds	r7, #12
 800224c:	46bd      	mov	sp, r7
 800224e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002252:	4770      	bx	lr

08002254 <HAL_HCD_HC_NotifyURBChange_Callback>:
  *            URB_ERROR/
  *            URB_STALL/
  * @retval None
  */
__weak void HAL_HCD_HC_NotifyURBChange_Callback(HCD_HandleTypeDef *hhcd, uint8_t chnum, HCD_URBStateTypeDef urb_state)
{
 8002254:	b480      	push	{r7}
 8002256:	b083      	sub	sp, #12
 8002258:	af00      	add	r7, sp, #0
 800225a:	6078      	str	r0, [r7, #4]
 800225c:	460b      	mov	r3, r1
 800225e:	70fb      	strb	r3, [r7, #3]
 8002260:	4613      	mov	r3, r2
 8002262:	70bb      	strb	r3, [r7, #2]
  UNUSED(urb_state);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_HCD_HC_NotifyURBChange_Callback could be implemented in the user file
   */
}
 8002264:	bf00      	nop
 8002266:	370c      	adds	r7, #12
 8002268:	46bd      	mov	sp, r7
 800226a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800226e:	4770      	bx	lr

08002270 <HCD_HC_IN_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_IN_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 8002270:	b580      	push	{r7, lr}
 8002272:	b086      	sub	sp, #24
 8002274:	af00      	add	r7, sp, #0
 8002276:	6078      	str	r0, [r7, #4]
 8002278:	460b      	mov	r3, r1
 800227a:	70fb      	strb	r3, [r7, #3]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800227c:	687b      	ldr	r3, [r7, #4]
 800227e:	681b      	ldr	r3, [r3, #0]
 8002280:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8002282:	697b      	ldr	r3, [r7, #20]
 8002284:	613b      	str	r3, [r7, #16]
  uint32_t ch_num = (uint32_t)chnum;
 8002286:	78fb      	ldrb	r3, [r7, #3]
 8002288:	60fb      	str	r3, [r7, #12]

  uint32_t tmpreg;

  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 800228a:	68fb      	ldr	r3, [r7, #12]
 800228c:	015a      	lsls	r2, r3, #5
 800228e:	693b      	ldr	r3, [r7, #16]
 8002290:	4413      	add	r3, r2
 8002292:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002296:	689b      	ldr	r3, [r3, #8]
 8002298:	f003 0304 	and.w	r3, r3, #4
 800229c:	2b04      	cmp	r3, #4
 800229e:	d119      	bne.n	80022d4 <HCD_HC_IN_IRQHandler+0x64>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 80022a0:	68fb      	ldr	r3, [r7, #12]
 80022a2:	015a      	lsls	r2, r3, #5
 80022a4:	693b      	ldr	r3, [r7, #16]
 80022a6:	4413      	add	r3, r2
 80022a8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80022ac:	461a      	mov	r2, r3
 80022ae:	2304      	movs	r3, #4
 80022b0:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80022b2:	68fb      	ldr	r3, [r7, #12]
 80022b4:	015a      	lsls	r2, r3, #5
 80022b6:	693b      	ldr	r3, [r7, #16]
 80022b8:	4413      	add	r3, r2
 80022ba:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80022be:	68db      	ldr	r3, [r3, #12]
 80022c0:	68fa      	ldr	r2, [r7, #12]
 80022c2:	0151      	lsls	r1, r2, #5
 80022c4:	693a      	ldr	r2, [r7, #16]
 80022c6:	440a      	add	r2, r1
 80022c8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80022cc:	f043 0302 	orr.w	r3, r3, #2
 80022d0:	60d3      	str	r3, [r2, #12]
 80022d2:	e095      	b.n	8002400 <HCD_HC_IN_IRQHandler+0x190>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 80022d4:	68fb      	ldr	r3, [r7, #12]
 80022d6:	015a      	lsls	r2, r3, #5
 80022d8:	693b      	ldr	r3, [r7, #16]
 80022da:	4413      	add	r3, r2
 80022dc:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80022e0:	689b      	ldr	r3, [r3, #8]
 80022e2:	f003 0320 	and.w	r3, r3, #32
 80022e6:	2b20      	cmp	r3, #32
 80022e8:	d109      	bne.n	80022fe <HCD_HC_IN_IRQHandler+0x8e>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 80022ea:	68fb      	ldr	r3, [r7, #12]
 80022ec:	015a      	lsls	r2, r3, #5
 80022ee:	693b      	ldr	r3, [r7, #16]
 80022f0:	4413      	add	r3, r2
 80022f2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80022f6:	461a      	mov	r2, r3
 80022f8:	2320      	movs	r3, #32
 80022fa:	6093      	str	r3, [r2, #8]
 80022fc:	e080      	b.n	8002400 <HCD_HC_IN_IRQHandler+0x190>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 80022fe:	68fb      	ldr	r3, [r7, #12]
 8002300:	015a      	lsls	r2, r3, #5
 8002302:	693b      	ldr	r3, [r7, #16]
 8002304:	4413      	add	r3, r2
 8002306:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800230a:	689b      	ldr	r3, [r3, #8]
 800230c:	f003 0308 	and.w	r3, r3, #8
 8002310:	2b08      	cmp	r3, #8
 8002312:	d134      	bne.n	800237e <HCD_HC_IN_IRQHandler+0x10e>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002314:	68fb      	ldr	r3, [r7, #12]
 8002316:	015a      	lsls	r2, r3, #5
 8002318:	693b      	ldr	r3, [r7, #16]
 800231a:	4413      	add	r3, r2
 800231c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002320:	68db      	ldr	r3, [r3, #12]
 8002322:	68fa      	ldr	r2, [r7, #12]
 8002324:	0151      	lsls	r1, r2, #5
 8002326:	693a      	ldr	r2, [r7, #16]
 8002328:	440a      	add	r2, r1
 800232a:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800232e:	f043 0302 	orr.w	r3, r3, #2
 8002332:	60d3      	str	r3, [r2, #12]
    hhcd->hc[ch_num].state = HC_STALL;
 8002334:	6879      	ldr	r1, [r7, #4]
 8002336:	68fa      	ldr	r2, [r7, #12]
 8002338:	4613      	mov	r3, r2
 800233a:	009b      	lsls	r3, r3, #2
 800233c:	4413      	add	r3, r2
 800233e:	00db      	lsls	r3, r3, #3
 8002340:	440b      	add	r3, r1
 8002342:	335d      	adds	r3, #93	; 0x5d
 8002344:	2205      	movs	r2, #5
 8002346:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002348:	68fb      	ldr	r3, [r7, #12]
 800234a:	015a      	lsls	r2, r3, #5
 800234c:	693b      	ldr	r3, [r7, #16]
 800234e:	4413      	add	r3, r2
 8002350:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002354:	461a      	mov	r2, r3
 8002356:	2310      	movs	r3, #16
 8002358:	6093      	str	r3, [r2, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 800235a:	68fb      	ldr	r3, [r7, #12]
 800235c:	015a      	lsls	r2, r3, #5
 800235e:	693b      	ldr	r3, [r7, #16]
 8002360:	4413      	add	r3, r2
 8002362:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002366:	461a      	mov	r2, r3
 8002368:	2308      	movs	r3, #8
 800236a:	6093      	str	r3, [r2, #8]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	681b      	ldr	r3, [r3, #0]
 8002370:	68fa      	ldr	r2, [r7, #12]
 8002372:	b2d2      	uxtb	r2, r2
 8002374:	4611      	mov	r1, r2
 8002376:	4618      	mov	r0, r3
 8002378:	f005 ff68 	bl	800824c <USB_HC_Halt>
 800237c:	e040      	b.n	8002400 <HCD_HC_IN_IRQHandler+0x190>
  }
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 800237e:	68fb      	ldr	r3, [r7, #12]
 8002380:	015a      	lsls	r2, r3, #5
 8002382:	693b      	ldr	r3, [r7, #16]
 8002384:	4413      	add	r3, r2
 8002386:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800238a:	689b      	ldr	r3, [r3, #8]
 800238c:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002390:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002394:	d134      	bne.n	8002400 <HCD_HC_IN_IRQHandler+0x190>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002396:	68fb      	ldr	r3, [r7, #12]
 8002398:	015a      	lsls	r2, r3, #5
 800239a:	693b      	ldr	r3, [r7, #16]
 800239c:	4413      	add	r3, r2
 800239e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80023a2:	68db      	ldr	r3, [r3, #12]
 80023a4:	68fa      	ldr	r2, [r7, #12]
 80023a6:	0151      	lsls	r1, r2, #5
 80023a8:	693a      	ldr	r2, [r7, #16]
 80023aa:	440a      	add	r2, r1
 80023ac:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80023b0:	f043 0302 	orr.w	r3, r3, #2
 80023b4:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80023b6:	687b      	ldr	r3, [r7, #4]
 80023b8:	681b      	ldr	r3, [r3, #0]
 80023ba:	68fa      	ldr	r2, [r7, #12]
 80023bc:	b2d2      	uxtb	r2, r2
 80023be:	4611      	mov	r1, r2
 80023c0:	4618      	mov	r0, r3
 80023c2:	f005 ff43 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 80023c6:	68fb      	ldr	r3, [r7, #12]
 80023c8:	015a      	lsls	r2, r3, #5
 80023ca:	693b      	ldr	r3, [r7, #16]
 80023cc:	4413      	add	r3, r2
 80023ce:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80023d2:	461a      	mov	r2, r3
 80023d4:	2310      	movs	r3, #16
 80023d6:	6093      	str	r3, [r2, #8]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 80023d8:	6879      	ldr	r1, [r7, #4]
 80023da:	68fa      	ldr	r2, [r7, #12]
 80023dc:	4613      	mov	r3, r2
 80023de:	009b      	lsls	r3, r3, #2
 80023e0:	4413      	add	r3, r2
 80023e2:	00db      	lsls	r3, r3, #3
 80023e4:	440b      	add	r3, r1
 80023e6:	335d      	adds	r3, #93	; 0x5d
 80023e8:	2208      	movs	r2, #8
 80023ea:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 80023ec:	68fb      	ldr	r3, [r7, #12]
 80023ee:	015a      	lsls	r2, r3, #5
 80023f0:	693b      	ldr	r3, [r7, #16]
 80023f2:	4413      	add	r3, r2
 80023f4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80023f8:	461a      	mov	r2, r3
 80023fa:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80023fe:	6093      	str	r3, [r2, #8]
  else
  {
    /* ... */
  }

  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8002400:	68fb      	ldr	r3, [r7, #12]
 8002402:	015a      	lsls	r2, r3, #5
 8002404:	693b      	ldr	r3, [r7, #16]
 8002406:	4413      	add	r3, r2
 8002408:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800240c:	689b      	ldr	r3, [r3, #8]
 800240e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002412:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002416:	d122      	bne.n	800245e <HCD_HC_IN_IRQHandler+0x1ee>
  {
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002418:	68fb      	ldr	r3, [r7, #12]
 800241a:	015a      	lsls	r2, r3, #5
 800241c:	693b      	ldr	r3, [r7, #16]
 800241e:	4413      	add	r3, r2
 8002420:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002424:	68db      	ldr	r3, [r3, #12]
 8002426:	68fa      	ldr	r2, [r7, #12]
 8002428:	0151      	lsls	r1, r2, #5
 800242a:	693a      	ldr	r2, [r7, #16]
 800242c:	440a      	add	r2, r1
 800242e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002432:	f043 0302 	orr.w	r3, r3, #2
 8002436:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002438:	687b      	ldr	r3, [r7, #4]
 800243a:	681b      	ldr	r3, [r3, #0]
 800243c:	68fa      	ldr	r2, [r7, #12]
 800243e:	b2d2      	uxtb	r2, r2
 8002440:	4611      	mov	r1, r2
 8002442:	4618      	mov	r0, r3
 8002444:	f005 ff02 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8002448:	68fb      	ldr	r3, [r7, #12]
 800244a:	015a      	lsls	r2, r3, #5
 800244c:	693b      	ldr	r3, [r7, #16]
 800244e:	4413      	add	r3, r2
 8002450:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002454:	461a      	mov	r2, r3
 8002456:	f44f 7300 	mov.w	r3, #512	; 0x200
 800245a:	6093      	str	r3, [r2, #8]
  }
  else
  {
    /* ... */
  }
}
 800245c:	e29b      	b.n	8002996 <HCD_HC_IN_IRQHandler+0x726>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 800245e:	68fb      	ldr	r3, [r7, #12]
 8002460:	015a      	lsls	r2, r3, #5
 8002462:	693b      	ldr	r3, [r7, #16]
 8002464:	4413      	add	r3, r2
 8002466:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800246a:	689b      	ldr	r3, [r3, #8]
 800246c:	f003 0301 	and.w	r3, r3, #1
 8002470:	2b01      	cmp	r3, #1
 8002472:	f040 80c1 	bne.w	80025f8 <HCD_HC_IN_IRQHandler+0x388>
    if (hhcd->Init.dma_enable != 0U)
 8002476:	687b      	ldr	r3, [r7, #4]
 8002478:	691b      	ldr	r3, [r3, #16]
 800247a:	2b00      	cmp	r3, #0
 800247c:	d01b      	beq.n	80024b6 <HCD_HC_IN_IRQHandler+0x246>
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 800247e:	6879      	ldr	r1, [r7, #4]
 8002480:	68fa      	ldr	r2, [r7, #12]
 8002482:	4613      	mov	r3, r2
 8002484:	009b      	lsls	r3, r3, #2
 8002486:	4413      	add	r3, r2
 8002488:	00db      	lsls	r3, r3, #3
 800248a:	440b      	add	r3, r1
 800248c:	3348      	adds	r3, #72	; 0x48
 800248e:	681a      	ldr	r2, [r3, #0]
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8002490:	68fb      	ldr	r3, [r7, #12]
 8002492:	0159      	lsls	r1, r3, #5
 8002494:	693b      	ldr	r3, [r7, #16]
 8002496:	440b      	add	r3, r1
 8002498:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800249c:	691b      	ldr	r3, [r3, #16]
 800249e:	f3c3 0312 	ubfx	r3, r3, #0, #19
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 80024a2:	1ad1      	subs	r1, r2, r3
 80024a4:	6878      	ldr	r0, [r7, #4]
 80024a6:	68fa      	ldr	r2, [r7, #12]
 80024a8:	4613      	mov	r3, r2
 80024aa:	009b      	lsls	r3, r3, #2
 80024ac:	4413      	add	r3, r2
 80024ae:	00db      	lsls	r3, r3, #3
 80024b0:	4403      	add	r3, r0
 80024b2:	334c      	adds	r3, #76	; 0x4c
 80024b4:	6019      	str	r1, [r3, #0]
    hhcd->hc[ch_num].state = HC_XFRC;
 80024b6:	6879      	ldr	r1, [r7, #4]
 80024b8:	68fa      	ldr	r2, [r7, #12]
 80024ba:	4613      	mov	r3, r2
 80024bc:	009b      	lsls	r3, r3, #2
 80024be:	4413      	add	r3, r2
 80024c0:	00db      	lsls	r3, r3, #3
 80024c2:	440b      	add	r3, r1
 80024c4:	335d      	adds	r3, #93	; 0x5d
 80024c6:	2201      	movs	r2, #1
 80024c8:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].ErrCnt = 0U;
 80024ca:	6879      	ldr	r1, [r7, #4]
 80024cc:	68fa      	ldr	r2, [r7, #12]
 80024ce:	4613      	mov	r3, r2
 80024d0:	009b      	lsls	r3, r3, #2
 80024d2:	4413      	add	r3, r2
 80024d4:	00db      	lsls	r3, r3, #3
 80024d6:	440b      	add	r3, r1
 80024d8:	3358      	adds	r3, #88	; 0x58
 80024da:	2200      	movs	r2, #0
 80024dc:	601a      	str	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 80024de:	68fb      	ldr	r3, [r7, #12]
 80024e0:	015a      	lsls	r2, r3, #5
 80024e2:	693b      	ldr	r3, [r7, #16]
 80024e4:	4413      	add	r3, r2
 80024e6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80024ea:	461a      	mov	r2, r3
 80024ec:	2301      	movs	r3, #1
 80024ee:	6093      	str	r3, [r2, #8]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 80024f0:	6879      	ldr	r1, [r7, #4]
 80024f2:	68fa      	ldr	r2, [r7, #12]
 80024f4:	4613      	mov	r3, r2
 80024f6:	009b      	lsls	r3, r3, #2
 80024f8:	4413      	add	r3, r2
 80024fa:	00db      	lsls	r3, r3, #3
 80024fc:	440b      	add	r3, r1
 80024fe:	333f      	adds	r3, #63	; 0x3f
 8002500:	781b      	ldrb	r3, [r3, #0]
 8002502:	2b00      	cmp	r3, #0
 8002504:	d00a      	beq.n	800251c <HCD_HC_IN_IRQHandler+0x2ac>
        (hhcd->hc[ch_num].ep_type == EP_TYPE_BULK))
 8002506:	6879      	ldr	r1, [r7, #4]
 8002508:	68fa      	ldr	r2, [r7, #12]
 800250a:	4613      	mov	r3, r2
 800250c:	009b      	lsls	r3, r3, #2
 800250e:	4413      	add	r3, r2
 8002510:	00db      	lsls	r3, r3, #3
 8002512:	440b      	add	r3, r1
 8002514:	333f      	adds	r3, #63	; 0x3f
 8002516:	781b      	ldrb	r3, [r3, #0]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002518:	2b02      	cmp	r3, #2
 800251a:	d121      	bne.n	8002560 <HCD_HC_IN_IRQHandler+0x2f0>
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 800251c:	68fb      	ldr	r3, [r7, #12]
 800251e:	015a      	lsls	r2, r3, #5
 8002520:	693b      	ldr	r3, [r7, #16]
 8002522:	4413      	add	r3, r2
 8002524:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002528:	68db      	ldr	r3, [r3, #12]
 800252a:	68fa      	ldr	r2, [r7, #12]
 800252c:	0151      	lsls	r1, r2, #5
 800252e:	693a      	ldr	r2, [r7, #16]
 8002530:	440a      	add	r2, r1
 8002532:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002536:	f043 0302 	orr.w	r3, r3, #2
 800253a:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 800253c:	687b      	ldr	r3, [r7, #4]
 800253e:	681b      	ldr	r3, [r3, #0]
 8002540:	68fa      	ldr	r2, [r7, #12]
 8002542:	b2d2      	uxtb	r2, r2
 8002544:	4611      	mov	r1, r2
 8002546:	4618      	mov	r0, r3
 8002548:	f005 fe80 	bl	800824c <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 800254c:	68fb      	ldr	r3, [r7, #12]
 800254e:	015a      	lsls	r2, r3, #5
 8002550:	693b      	ldr	r3, [r7, #16]
 8002552:	4413      	add	r3, r2
 8002554:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002558:	461a      	mov	r2, r3
 800255a:	2310      	movs	r3, #16
 800255c:	6093      	str	r3, [r2, #8]
 800255e:	e034      	b.n	80025ca <HCD_HC_IN_IRQHandler+0x35a>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8002560:	6879      	ldr	r1, [r7, #4]
 8002562:	68fa      	ldr	r2, [r7, #12]
 8002564:	4613      	mov	r3, r2
 8002566:	009b      	lsls	r3, r3, #2
 8002568:	4413      	add	r3, r2
 800256a:	00db      	lsls	r3, r3, #3
 800256c:	440b      	add	r3, r1
 800256e:	333f      	adds	r3, #63	; 0x3f
 8002570:	781b      	ldrb	r3, [r3, #0]
 8002572:	2b03      	cmp	r3, #3
 8002574:	d129      	bne.n	80025ca <HCD_HC_IN_IRQHandler+0x35a>
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8002576:	68fb      	ldr	r3, [r7, #12]
 8002578:	015a      	lsls	r2, r3, #5
 800257a:	693b      	ldr	r3, [r7, #16]
 800257c:	4413      	add	r3, r2
 800257e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002582:	681b      	ldr	r3, [r3, #0]
 8002584:	68fa      	ldr	r2, [r7, #12]
 8002586:	0151      	lsls	r1, r2, #5
 8002588:	693a      	ldr	r2, [r7, #16]
 800258a:	440a      	add	r2, r1
 800258c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002590:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8002594:	6013      	str	r3, [r2, #0]
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8002596:	6879      	ldr	r1, [r7, #4]
 8002598:	68fa      	ldr	r2, [r7, #12]
 800259a:	4613      	mov	r3, r2
 800259c:	009b      	lsls	r3, r3, #2
 800259e:	4413      	add	r3, r2
 80025a0:	00db      	lsls	r3, r3, #3
 80025a2:	440b      	add	r3, r1
 80025a4:	335c      	adds	r3, #92	; 0x5c
 80025a6:	2201      	movs	r2, #1
 80025a8:	701a      	strb	r2, [r3, #0]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 80025aa:	68fb      	ldr	r3, [r7, #12]
 80025ac:	b2d8      	uxtb	r0, r3
 80025ae:	6879      	ldr	r1, [r7, #4]
 80025b0:	68fa      	ldr	r2, [r7, #12]
 80025b2:	4613      	mov	r3, r2
 80025b4:	009b      	lsls	r3, r3, #2
 80025b6:	4413      	add	r3, r2
 80025b8:	00db      	lsls	r3, r3, #3
 80025ba:	440b      	add	r3, r1
 80025bc:	335c      	adds	r3, #92	; 0x5c
 80025be:	781b      	ldrb	r3, [r3, #0]
 80025c0:	461a      	mov	r2, r3
 80025c2:	4601      	mov	r1, r0
 80025c4:	6878      	ldr	r0, [r7, #4]
 80025c6:	f7ff fe45 	bl	8002254 <HAL_HCD_HC_NotifyURBChange_Callback>
    hhcd->hc[ch_num].toggle_in ^= 1U;
 80025ca:	6879      	ldr	r1, [r7, #4]
 80025cc:	68fa      	ldr	r2, [r7, #12]
 80025ce:	4613      	mov	r3, r2
 80025d0:	009b      	lsls	r3, r3, #2
 80025d2:	4413      	add	r3, r2
 80025d4:	00db      	lsls	r3, r3, #3
 80025d6:	440b      	add	r3, r1
 80025d8:	3350      	adds	r3, #80	; 0x50
 80025da:	781b      	ldrb	r3, [r3, #0]
 80025dc:	f083 0301 	eor.w	r3, r3, #1
 80025e0:	b2d8      	uxtb	r0, r3
 80025e2:	6879      	ldr	r1, [r7, #4]
 80025e4:	68fa      	ldr	r2, [r7, #12]
 80025e6:	4613      	mov	r3, r2
 80025e8:	009b      	lsls	r3, r3, #2
 80025ea:	4413      	add	r3, r2
 80025ec:	00db      	lsls	r3, r3, #3
 80025ee:	440b      	add	r3, r1
 80025f0:	3350      	adds	r3, #80	; 0x50
 80025f2:	4602      	mov	r2, r0
 80025f4:	701a      	strb	r2, [r3, #0]
}
 80025f6:	e1ce      	b.n	8002996 <HCD_HC_IN_IRQHandler+0x726>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 80025f8:	68fb      	ldr	r3, [r7, #12]
 80025fa:	015a      	lsls	r2, r3, #5
 80025fc:	693b      	ldr	r3, [r7, #16]
 80025fe:	4413      	add	r3, r2
 8002600:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002604:	689b      	ldr	r3, [r3, #8]
 8002606:	f003 0302 	and.w	r3, r3, #2
 800260a:	2b02      	cmp	r3, #2
 800260c:	f040 80f1 	bne.w	80027f2 <HCD_HC_IN_IRQHandler+0x582>
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8002610:	68fb      	ldr	r3, [r7, #12]
 8002612:	015a      	lsls	r2, r3, #5
 8002614:	693b      	ldr	r3, [r7, #16]
 8002616:	4413      	add	r3, r2
 8002618:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800261c:	68db      	ldr	r3, [r3, #12]
 800261e:	68fa      	ldr	r2, [r7, #12]
 8002620:	0151      	lsls	r1, r2, #5
 8002622:	693a      	ldr	r2, [r7, #16]
 8002624:	440a      	add	r2, r1
 8002626:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800262a:	f023 0302 	bic.w	r3, r3, #2
 800262e:	60d3      	str	r3, [r2, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8002630:	6879      	ldr	r1, [r7, #4]
 8002632:	68fa      	ldr	r2, [r7, #12]
 8002634:	4613      	mov	r3, r2
 8002636:	009b      	lsls	r3, r3, #2
 8002638:	4413      	add	r3, r2
 800263a:	00db      	lsls	r3, r3, #3
 800263c:	440b      	add	r3, r1
 800263e:	335d      	adds	r3, #93	; 0x5d
 8002640:	781b      	ldrb	r3, [r3, #0]
 8002642:	2b01      	cmp	r3, #1
 8002644:	d10a      	bne.n	800265c <HCD_HC_IN_IRQHandler+0x3ec>
      hhcd->hc[ch_num].urb_state  = URB_DONE;
 8002646:	6879      	ldr	r1, [r7, #4]
 8002648:	68fa      	ldr	r2, [r7, #12]
 800264a:	4613      	mov	r3, r2
 800264c:	009b      	lsls	r3, r3, #2
 800264e:	4413      	add	r3, r2
 8002650:	00db      	lsls	r3, r3, #3
 8002652:	440b      	add	r3, r1
 8002654:	335c      	adds	r3, #92	; 0x5c
 8002656:	2201      	movs	r2, #1
 8002658:	701a      	strb	r2, [r3, #0]
 800265a:	e0b0      	b.n	80027be <HCD_HC_IN_IRQHandler+0x54e>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 800265c:	6879      	ldr	r1, [r7, #4]
 800265e:	68fa      	ldr	r2, [r7, #12]
 8002660:	4613      	mov	r3, r2
 8002662:	009b      	lsls	r3, r3, #2
 8002664:	4413      	add	r3, r2
 8002666:	00db      	lsls	r3, r3, #3
 8002668:	440b      	add	r3, r1
 800266a:	335d      	adds	r3, #93	; 0x5d
 800266c:	781b      	ldrb	r3, [r3, #0]
 800266e:	2b05      	cmp	r3, #5
 8002670:	d10a      	bne.n	8002688 <HCD_HC_IN_IRQHandler+0x418>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8002672:	6879      	ldr	r1, [r7, #4]
 8002674:	68fa      	ldr	r2, [r7, #12]
 8002676:	4613      	mov	r3, r2
 8002678:	009b      	lsls	r3, r3, #2
 800267a:	4413      	add	r3, r2
 800267c:	00db      	lsls	r3, r3, #3
 800267e:	440b      	add	r3, r1
 8002680:	335c      	adds	r3, #92	; 0x5c
 8002682:	2205      	movs	r2, #5
 8002684:	701a      	strb	r2, [r3, #0]
 8002686:	e09a      	b.n	80027be <HCD_HC_IN_IRQHandler+0x54e>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8002688:	6879      	ldr	r1, [r7, #4]
 800268a:	68fa      	ldr	r2, [r7, #12]
 800268c:	4613      	mov	r3, r2
 800268e:	009b      	lsls	r3, r3, #2
 8002690:	4413      	add	r3, r2
 8002692:	00db      	lsls	r3, r3, #3
 8002694:	440b      	add	r3, r1
 8002696:	335d      	adds	r3, #93	; 0x5d
 8002698:	781b      	ldrb	r3, [r3, #0]
 800269a:	2b06      	cmp	r3, #6
 800269c:	d00a      	beq.n	80026b4 <HCD_HC_IN_IRQHandler+0x444>
             (hhcd->hc[ch_num].state == HC_DATATGLERR))
 800269e:	6879      	ldr	r1, [r7, #4]
 80026a0:	68fa      	ldr	r2, [r7, #12]
 80026a2:	4613      	mov	r3, r2
 80026a4:	009b      	lsls	r3, r3, #2
 80026a6:	4413      	add	r3, r2
 80026a8:	00db      	lsls	r3, r3, #3
 80026aa:	440b      	add	r3, r1
 80026ac:	335d      	adds	r3, #93	; 0x5d
 80026ae:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 80026b0:	2b08      	cmp	r3, #8
 80026b2:	d156      	bne.n	8002762 <HCD_HC_IN_IRQHandler+0x4f2>
      hhcd->hc[ch_num].ErrCnt++;
 80026b4:	6879      	ldr	r1, [r7, #4]
 80026b6:	68fa      	ldr	r2, [r7, #12]
 80026b8:	4613      	mov	r3, r2
 80026ba:	009b      	lsls	r3, r3, #2
 80026bc:	4413      	add	r3, r2
 80026be:	00db      	lsls	r3, r3, #3
 80026c0:	440b      	add	r3, r1
 80026c2:	3358      	adds	r3, #88	; 0x58
 80026c4:	681b      	ldr	r3, [r3, #0]
 80026c6:	1c59      	adds	r1, r3, #1
 80026c8:	6878      	ldr	r0, [r7, #4]
 80026ca:	68fa      	ldr	r2, [r7, #12]
 80026cc:	4613      	mov	r3, r2
 80026ce:	009b      	lsls	r3, r3, #2
 80026d0:	4413      	add	r3, r2
 80026d2:	00db      	lsls	r3, r3, #3
 80026d4:	4403      	add	r3, r0
 80026d6:	3358      	adds	r3, #88	; 0x58
 80026d8:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 80026da:	6879      	ldr	r1, [r7, #4]
 80026dc:	68fa      	ldr	r2, [r7, #12]
 80026de:	4613      	mov	r3, r2
 80026e0:	009b      	lsls	r3, r3, #2
 80026e2:	4413      	add	r3, r2
 80026e4:	00db      	lsls	r3, r3, #3
 80026e6:	440b      	add	r3, r1
 80026e8:	3358      	adds	r3, #88	; 0x58
 80026ea:	681b      	ldr	r3, [r3, #0]
 80026ec:	2b03      	cmp	r3, #3
 80026ee:	d914      	bls.n	800271a <HCD_HC_IN_IRQHandler+0x4aa>
        hhcd->hc[ch_num].ErrCnt = 0U;
 80026f0:	6879      	ldr	r1, [r7, #4]
 80026f2:	68fa      	ldr	r2, [r7, #12]
 80026f4:	4613      	mov	r3, r2
 80026f6:	009b      	lsls	r3, r3, #2
 80026f8:	4413      	add	r3, r2
 80026fa:	00db      	lsls	r3, r3, #3
 80026fc:	440b      	add	r3, r1
 80026fe:	3358      	adds	r3, #88	; 0x58
 8002700:	2200      	movs	r2, #0
 8002702:	601a      	str	r2, [r3, #0]
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002704:	6879      	ldr	r1, [r7, #4]
 8002706:	68fa      	ldr	r2, [r7, #12]
 8002708:	4613      	mov	r3, r2
 800270a:	009b      	lsls	r3, r3, #2
 800270c:	4413      	add	r3, r2
 800270e:	00db      	lsls	r3, r3, #3
 8002710:	440b      	add	r3, r1
 8002712:	335c      	adds	r3, #92	; 0x5c
 8002714:	2204      	movs	r2, #4
 8002716:	701a      	strb	r2, [r3, #0]
 8002718:	e009      	b.n	800272e <HCD_HC_IN_IRQHandler+0x4be>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 800271a:	6879      	ldr	r1, [r7, #4]
 800271c:	68fa      	ldr	r2, [r7, #12]
 800271e:	4613      	mov	r3, r2
 8002720:	009b      	lsls	r3, r3, #2
 8002722:	4413      	add	r3, r2
 8002724:	00db      	lsls	r3, r3, #3
 8002726:	440b      	add	r3, r1
 8002728:	335c      	adds	r3, #92	; 0x5c
 800272a:	2202      	movs	r2, #2
 800272c:	701a      	strb	r2, [r3, #0]
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 800272e:	68fb      	ldr	r3, [r7, #12]
 8002730:	015a      	lsls	r2, r3, #5
 8002732:	693b      	ldr	r3, [r7, #16]
 8002734:	4413      	add	r3, r2
 8002736:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800273a:	681b      	ldr	r3, [r3, #0]
 800273c:	60bb      	str	r3, [r7, #8]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800273e:	68bb      	ldr	r3, [r7, #8]
 8002740:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8002744:	60bb      	str	r3, [r7, #8]
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 8002746:	68bb      	ldr	r3, [r7, #8]
 8002748:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800274c:	60bb      	str	r3, [r7, #8]
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 800274e:	68fb      	ldr	r3, [r7, #12]
 8002750:	015a      	lsls	r2, r3, #5
 8002752:	693b      	ldr	r3, [r7, #16]
 8002754:	4413      	add	r3, r2
 8002756:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800275a:	461a      	mov	r2, r3
 800275c:	68bb      	ldr	r3, [r7, #8]
 800275e:	6013      	str	r3, [r2, #0]
 8002760:	e02d      	b.n	80027be <HCD_HC_IN_IRQHandler+0x54e>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8002762:	6879      	ldr	r1, [r7, #4]
 8002764:	68fa      	ldr	r2, [r7, #12]
 8002766:	4613      	mov	r3, r2
 8002768:	009b      	lsls	r3, r3, #2
 800276a:	4413      	add	r3, r2
 800276c:	00db      	lsls	r3, r3, #3
 800276e:	440b      	add	r3, r1
 8002770:	335d      	adds	r3, #93	; 0x5d
 8002772:	781b      	ldrb	r3, [r3, #0]
 8002774:	2b03      	cmp	r3, #3
 8002776:	d122      	bne.n	80027be <HCD_HC_IN_IRQHandler+0x54e>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8002778:	6879      	ldr	r1, [r7, #4]
 800277a:	68fa      	ldr	r2, [r7, #12]
 800277c:	4613      	mov	r3, r2
 800277e:	009b      	lsls	r3, r3, #2
 8002780:	4413      	add	r3, r2
 8002782:	00db      	lsls	r3, r3, #3
 8002784:	440b      	add	r3, r1
 8002786:	335c      	adds	r3, #92	; 0x5c
 8002788:	2202      	movs	r2, #2
 800278a:	701a      	strb	r2, [r3, #0]
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 800278c:	68fb      	ldr	r3, [r7, #12]
 800278e:	015a      	lsls	r2, r3, #5
 8002790:	693b      	ldr	r3, [r7, #16]
 8002792:	4413      	add	r3, r2
 8002794:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002798:	681b      	ldr	r3, [r3, #0]
 800279a:	60bb      	str	r3, [r7, #8]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800279c:	68bb      	ldr	r3, [r7, #8]
 800279e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 80027a2:	60bb      	str	r3, [r7, #8]
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 80027a4:	68bb      	ldr	r3, [r7, #8]
 80027a6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80027aa:	60bb      	str	r3, [r7, #8]
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 80027ac:	68fb      	ldr	r3, [r7, #12]
 80027ae:	015a      	lsls	r2, r3, #5
 80027b0:	693b      	ldr	r3, [r7, #16]
 80027b2:	4413      	add	r3, r2
 80027b4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80027b8:	461a      	mov	r2, r3
 80027ba:	68bb      	ldr	r3, [r7, #8]
 80027bc:	6013      	str	r3, [r2, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 80027be:	68fb      	ldr	r3, [r7, #12]
 80027c0:	015a      	lsls	r2, r3, #5
 80027c2:	693b      	ldr	r3, [r7, #16]
 80027c4:	4413      	add	r3, r2
 80027c6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80027ca:	461a      	mov	r2, r3
 80027cc:	2302      	movs	r3, #2
 80027ce:	6093      	str	r3, [r2, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 80027d0:	68fb      	ldr	r3, [r7, #12]
 80027d2:	b2d8      	uxtb	r0, r3
 80027d4:	6879      	ldr	r1, [r7, #4]
 80027d6:	68fa      	ldr	r2, [r7, #12]
 80027d8:	4613      	mov	r3, r2
 80027da:	009b      	lsls	r3, r3, #2
 80027dc:	4413      	add	r3, r2
 80027de:	00db      	lsls	r3, r3, #3
 80027e0:	440b      	add	r3, r1
 80027e2:	335c      	adds	r3, #92	; 0x5c
 80027e4:	781b      	ldrb	r3, [r3, #0]
 80027e6:	461a      	mov	r2, r3
 80027e8:	4601      	mov	r1, r0
 80027ea:	6878      	ldr	r0, [r7, #4]
 80027ec:	f7ff fd32 	bl	8002254 <HAL_HCD_HC_NotifyURBChange_Callback>
}
 80027f0:	e0d1      	b.n	8002996 <HCD_HC_IN_IRQHandler+0x726>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 80027f2:	68fb      	ldr	r3, [r7, #12]
 80027f4:	015a      	lsls	r2, r3, #5
 80027f6:	693b      	ldr	r3, [r7, #16]
 80027f8:	4413      	add	r3, r2
 80027fa:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80027fe:	689b      	ldr	r3, [r3, #8]
 8002800:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002804:	2b80      	cmp	r3, #128	; 0x80
 8002806:	d13e      	bne.n	8002886 <HCD_HC_IN_IRQHandler+0x616>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002808:	68fb      	ldr	r3, [r7, #12]
 800280a:	015a      	lsls	r2, r3, #5
 800280c:	693b      	ldr	r3, [r7, #16]
 800280e:	4413      	add	r3, r2
 8002810:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002814:	68db      	ldr	r3, [r3, #12]
 8002816:	68fa      	ldr	r2, [r7, #12]
 8002818:	0151      	lsls	r1, r2, #5
 800281a:	693a      	ldr	r2, [r7, #16]
 800281c:	440a      	add	r2, r1
 800281e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002822:	f043 0302 	orr.w	r3, r3, #2
 8002826:	60d3      	str	r3, [r2, #12]
    hhcd->hc[ch_num].ErrCnt++;
 8002828:	6879      	ldr	r1, [r7, #4]
 800282a:	68fa      	ldr	r2, [r7, #12]
 800282c:	4613      	mov	r3, r2
 800282e:	009b      	lsls	r3, r3, #2
 8002830:	4413      	add	r3, r2
 8002832:	00db      	lsls	r3, r3, #3
 8002834:	440b      	add	r3, r1
 8002836:	3358      	adds	r3, #88	; 0x58
 8002838:	681b      	ldr	r3, [r3, #0]
 800283a:	1c59      	adds	r1, r3, #1
 800283c:	6878      	ldr	r0, [r7, #4]
 800283e:	68fa      	ldr	r2, [r7, #12]
 8002840:	4613      	mov	r3, r2
 8002842:	009b      	lsls	r3, r3, #2
 8002844:	4413      	add	r3, r2
 8002846:	00db      	lsls	r3, r3, #3
 8002848:	4403      	add	r3, r0
 800284a:	3358      	adds	r3, #88	; 0x58
 800284c:	6019      	str	r1, [r3, #0]
    hhcd->hc[ch_num].state = HC_XACTERR;
 800284e:	6879      	ldr	r1, [r7, #4]
 8002850:	68fa      	ldr	r2, [r7, #12]
 8002852:	4613      	mov	r3, r2
 8002854:	009b      	lsls	r3, r3, #2
 8002856:	4413      	add	r3, r2
 8002858:	00db      	lsls	r3, r3, #3
 800285a:	440b      	add	r3, r1
 800285c:	335d      	adds	r3, #93	; 0x5d
 800285e:	2206      	movs	r2, #6
 8002860:	701a      	strb	r2, [r3, #0]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002862:	687b      	ldr	r3, [r7, #4]
 8002864:	681b      	ldr	r3, [r3, #0]
 8002866:	68fa      	ldr	r2, [r7, #12]
 8002868:	b2d2      	uxtb	r2, r2
 800286a:	4611      	mov	r1, r2
 800286c:	4618      	mov	r0, r3
 800286e:	f005 fced 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8002872:	68fb      	ldr	r3, [r7, #12]
 8002874:	015a      	lsls	r2, r3, #5
 8002876:	693b      	ldr	r3, [r7, #16]
 8002878:	4413      	add	r3, r2
 800287a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800287e:	461a      	mov	r2, r3
 8002880:	2380      	movs	r3, #128	; 0x80
 8002882:	6093      	str	r3, [r2, #8]
}
 8002884:	e087      	b.n	8002996 <HCD_HC_IN_IRQHandler+0x726>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8002886:	68fb      	ldr	r3, [r7, #12]
 8002888:	015a      	lsls	r2, r3, #5
 800288a:	693b      	ldr	r3, [r7, #16]
 800288c:	4413      	add	r3, r2
 800288e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002892:	689b      	ldr	r3, [r3, #8]
 8002894:	f003 0310 	and.w	r3, r3, #16
 8002898:	2b10      	cmp	r3, #16
 800289a:	d17c      	bne.n	8002996 <HCD_HC_IN_IRQHandler+0x726>
    if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 800289c:	6879      	ldr	r1, [r7, #4]
 800289e:	68fa      	ldr	r2, [r7, #12]
 80028a0:	4613      	mov	r3, r2
 80028a2:	009b      	lsls	r3, r3, #2
 80028a4:	4413      	add	r3, r2
 80028a6:	00db      	lsls	r3, r3, #3
 80028a8:	440b      	add	r3, r1
 80028aa:	333f      	adds	r3, #63	; 0x3f
 80028ac:	781b      	ldrb	r3, [r3, #0]
 80028ae:	2b03      	cmp	r3, #3
 80028b0:	d122      	bne.n	80028f8 <HCD_HC_IN_IRQHandler+0x688>
      hhcd->hc[ch_num].ErrCnt = 0U;
 80028b2:	6879      	ldr	r1, [r7, #4]
 80028b4:	68fa      	ldr	r2, [r7, #12]
 80028b6:	4613      	mov	r3, r2
 80028b8:	009b      	lsls	r3, r3, #2
 80028ba:	4413      	add	r3, r2
 80028bc:	00db      	lsls	r3, r3, #3
 80028be:	440b      	add	r3, r1
 80028c0:	3358      	adds	r3, #88	; 0x58
 80028c2:	2200      	movs	r2, #0
 80028c4:	601a      	str	r2, [r3, #0]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80028c6:	68fb      	ldr	r3, [r7, #12]
 80028c8:	015a      	lsls	r2, r3, #5
 80028ca:	693b      	ldr	r3, [r7, #16]
 80028cc:	4413      	add	r3, r2
 80028ce:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80028d2:	68db      	ldr	r3, [r3, #12]
 80028d4:	68fa      	ldr	r2, [r7, #12]
 80028d6:	0151      	lsls	r1, r2, #5
 80028d8:	693a      	ldr	r2, [r7, #16]
 80028da:	440a      	add	r2, r1
 80028dc:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80028e0:	f043 0302 	orr.w	r3, r3, #2
 80028e4:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80028e6:	687b      	ldr	r3, [r7, #4]
 80028e8:	681b      	ldr	r3, [r3, #0]
 80028ea:	68fa      	ldr	r2, [r7, #12]
 80028ec:	b2d2      	uxtb	r2, r2
 80028ee:	4611      	mov	r1, r2
 80028f0:	4618      	mov	r0, r3
 80028f2:	f005 fcab 	bl	800824c <USB_HC_Halt>
 80028f6:	e045      	b.n	8002984 <HCD_HC_IN_IRQHandler+0x714>
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 80028f8:	6879      	ldr	r1, [r7, #4]
 80028fa:	68fa      	ldr	r2, [r7, #12]
 80028fc:	4613      	mov	r3, r2
 80028fe:	009b      	lsls	r3, r3, #2
 8002900:	4413      	add	r3, r2
 8002902:	00db      	lsls	r3, r3, #3
 8002904:	440b      	add	r3, r1
 8002906:	333f      	adds	r3, #63	; 0x3f
 8002908:	781b      	ldrb	r3, [r3, #0]
 800290a:	2b00      	cmp	r3, #0
 800290c:	d00a      	beq.n	8002924 <HCD_HC_IN_IRQHandler+0x6b4>
             (hhcd->hc[ch_num].ep_type == EP_TYPE_BULK))
 800290e:	6879      	ldr	r1, [r7, #4]
 8002910:	68fa      	ldr	r2, [r7, #12]
 8002912:	4613      	mov	r3, r2
 8002914:	009b      	lsls	r3, r3, #2
 8002916:	4413      	add	r3, r2
 8002918:	00db      	lsls	r3, r3, #3
 800291a:	440b      	add	r3, r1
 800291c:	333f      	adds	r3, #63	; 0x3f
 800291e:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8002920:	2b02      	cmp	r3, #2
 8002922:	d12f      	bne.n	8002984 <HCD_HC_IN_IRQHandler+0x714>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8002924:	6879      	ldr	r1, [r7, #4]
 8002926:	68fa      	ldr	r2, [r7, #12]
 8002928:	4613      	mov	r3, r2
 800292a:	009b      	lsls	r3, r3, #2
 800292c:	4413      	add	r3, r2
 800292e:	00db      	lsls	r3, r3, #3
 8002930:	440b      	add	r3, r1
 8002932:	3358      	adds	r3, #88	; 0x58
 8002934:	2200      	movs	r2, #0
 8002936:	601a      	str	r2, [r3, #0]
      if (hhcd->Init.dma_enable == 0U)
 8002938:	687b      	ldr	r3, [r7, #4]
 800293a:	691b      	ldr	r3, [r3, #16]
 800293c:	2b00      	cmp	r3, #0
 800293e:	d121      	bne.n	8002984 <HCD_HC_IN_IRQHandler+0x714>
        hhcd->hc[ch_num].state = HC_NAK;
 8002940:	6879      	ldr	r1, [r7, #4]
 8002942:	68fa      	ldr	r2, [r7, #12]
 8002944:	4613      	mov	r3, r2
 8002946:	009b      	lsls	r3, r3, #2
 8002948:	4413      	add	r3, r2
 800294a:	00db      	lsls	r3, r3, #3
 800294c:	440b      	add	r3, r1
 800294e:	335d      	adds	r3, #93	; 0x5d
 8002950:	2203      	movs	r2, #3
 8002952:	701a      	strb	r2, [r3, #0]
        __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002954:	68fb      	ldr	r3, [r7, #12]
 8002956:	015a      	lsls	r2, r3, #5
 8002958:	693b      	ldr	r3, [r7, #16]
 800295a:	4413      	add	r3, r2
 800295c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002960:	68db      	ldr	r3, [r3, #12]
 8002962:	68fa      	ldr	r2, [r7, #12]
 8002964:	0151      	lsls	r1, r2, #5
 8002966:	693a      	ldr	r2, [r7, #16]
 8002968:	440a      	add	r2, r1
 800296a:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800296e:	f043 0302 	orr.w	r3, r3, #2
 8002972:	60d3      	str	r3, [r2, #12]
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002974:	687b      	ldr	r3, [r7, #4]
 8002976:	681b      	ldr	r3, [r3, #0]
 8002978:	68fa      	ldr	r2, [r7, #12]
 800297a:	b2d2      	uxtb	r2, r2
 800297c:	4611      	mov	r1, r2
 800297e:	4618      	mov	r0, r3
 8002980:	f005 fc64 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002984:	68fb      	ldr	r3, [r7, #12]
 8002986:	015a      	lsls	r2, r3, #5
 8002988:	693b      	ldr	r3, [r7, #16]
 800298a:	4413      	add	r3, r2
 800298c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002990:	461a      	mov	r2, r3
 8002992:	2310      	movs	r3, #16
 8002994:	6093      	str	r3, [r2, #8]
}
 8002996:	bf00      	nop
 8002998:	3718      	adds	r7, #24
 800299a:	46bd      	mov	sp, r7
 800299c:	bd80      	pop	{r7, pc}

0800299e <HCD_HC_OUT_IRQHandler>:
  * @param  chnum Channel number.
  *         This parameter can be a value from 1 to 15
  * @retval none
  */
static void HCD_HC_OUT_IRQHandler(HCD_HandleTypeDef *hhcd, uint8_t chnum)
{
 800299e:	b580      	push	{r7, lr}
 80029a0:	b086      	sub	sp, #24
 80029a2:	af00      	add	r7, sp, #0
 80029a4:	6078      	str	r0, [r7, #4]
 80029a6:	460b      	mov	r3, r1
 80029a8:	70fb      	strb	r3, [r7, #3]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80029aa:	687b      	ldr	r3, [r7, #4]
 80029ac:	681b      	ldr	r3, [r3, #0]
 80029ae:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80029b0:	697b      	ldr	r3, [r7, #20]
 80029b2:	613b      	str	r3, [r7, #16]
  uint32_t ch_num = (uint32_t)chnum;
 80029b4:	78fb      	ldrb	r3, [r7, #3]
 80029b6:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg;

  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 80029b8:	68fb      	ldr	r3, [r7, #12]
 80029ba:	015a      	lsls	r2, r3, #5
 80029bc:	693b      	ldr	r3, [r7, #16]
 80029be:	4413      	add	r3, r2
 80029c0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80029c4:	689b      	ldr	r3, [r3, #8]
 80029c6:	f003 0304 	and.w	r3, r3, #4
 80029ca:	2b04      	cmp	r3, #4
 80029cc:	d119      	bne.n	8002a02 <HCD_HC_OUT_IRQHandler+0x64>
  {
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 80029ce:	68fb      	ldr	r3, [r7, #12]
 80029d0:	015a      	lsls	r2, r3, #5
 80029d2:	693b      	ldr	r3, [r7, #16]
 80029d4:	4413      	add	r3, r2
 80029d6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80029da:	461a      	mov	r2, r3
 80029dc:	2304      	movs	r3, #4
 80029de:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 80029e0:	68fb      	ldr	r3, [r7, #12]
 80029e2:	015a      	lsls	r2, r3, #5
 80029e4:	693b      	ldr	r3, [r7, #16]
 80029e6:	4413      	add	r3, r2
 80029e8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80029ec:	68db      	ldr	r3, [r3, #12]
 80029ee:	68fa      	ldr	r2, [r7, #12]
 80029f0:	0151      	lsls	r1, r2, #5
 80029f2:	693a      	ldr	r2, [r7, #16]
 80029f4:	440a      	add	r2, r1
 80029f6:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80029fa:	f043 0302 	orr.w	r3, r3, #2
 80029fe:	60d3      	str	r3, [r2, #12]
  }
  else
  {
    /* ... */
  }
}
 8002a00:	e33e      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 8002a02:	68fb      	ldr	r3, [r7, #12]
 8002a04:	015a      	lsls	r2, r3, #5
 8002a06:	693b      	ldr	r3, [r7, #16]
 8002a08:	4413      	add	r3, r2
 8002a0a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a0e:	689b      	ldr	r3, [r3, #8]
 8002a10:	f003 0320 	and.w	r3, r3, #32
 8002a14:	2b20      	cmp	r3, #32
 8002a16:	d141      	bne.n	8002a9c <HCD_HC_OUT_IRQHandler+0xfe>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8002a18:	68fb      	ldr	r3, [r7, #12]
 8002a1a:	015a      	lsls	r2, r3, #5
 8002a1c:	693b      	ldr	r3, [r7, #16]
 8002a1e:	4413      	add	r3, r2
 8002a20:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a24:	461a      	mov	r2, r3
 8002a26:	2320      	movs	r3, #32
 8002a28:	6093      	str	r3, [r2, #8]
    if (hhcd->hc[ch_num].do_ping == 1U)
 8002a2a:	6879      	ldr	r1, [r7, #4]
 8002a2c:	68fa      	ldr	r2, [r7, #12]
 8002a2e:	4613      	mov	r3, r2
 8002a30:	009b      	lsls	r3, r3, #2
 8002a32:	4413      	add	r3, r2
 8002a34:	00db      	lsls	r3, r3, #3
 8002a36:	440b      	add	r3, r1
 8002a38:	333d      	adds	r3, #61	; 0x3d
 8002a3a:	781b      	ldrb	r3, [r3, #0]
 8002a3c:	2b01      	cmp	r3, #1
 8002a3e:	f040 831f 	bne.w	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
      hhcd->hc[ch_num].do_ping = 0U;
 8002a42:	6879      	ldr	r1, [r7, #4]
 8002a44:	68fa      	ldr	r2, [r7, #12]
 8002a46:	4613      	mov	r3, r2
 8002a48:	009b      	lsls	r3, r3, #2
 8002a4a:	4413      	add	r3, r2
 8002a4c:	00db      	lsls	r3, r3, #3
 8002a4e:	440b      	add	r3, r1
 8002a50:	333d      	adds	r3, #61	; 0x3d
 8002a52:	2200      	movs	r2, #0
 8002a54:	701a      	strb	r2, [r3, #0]
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8002a56:	6879      	ldr	r1, [r7, #4]
 8002a58:	68fa      	ldr	r2, [r7, #12]
 8002a5a:	4613      	mov	r3, r2
 8002a5c:	009b      	lsls	r3, r3, #2
 8002a5e:	4413      	add	r3, r2
 8002a60:	00db      	lsls	r3, r3, #3
 8002a62:	440b      	add	r3, r1
 8002a64:	335c      	adds	r3, #92	; 0x5c
 8002a66:	2202      	movs	r2, #2
 8002a68:	701a      	strb	r2, [r3, #0]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002a6a:	68fb      	ldr	r3, [r7, #12]
 8002a6c:	015a      	lsls	r2, r3, #5
 8002a6e:	693b      	ldr	r3, [r7, #16]
 8002a70:	4413      	add	r3, r2
 8002a72:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002a76:	68db      	ldr	r3, [r3, #12]
 8002a78:	68fa      	ldr	r2, [r7, #12]
 8002a7a:	0151      	lsls	r1, r2, #5
 8002a7c:	693a      	ldr	r2, [r7, #16]
 8002a7e:	440a      	add	r2, r1
 8002a80:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002a84:	f043 0302 	orr.w	r3, r3, #2
 8002a88:	60d3      	str	r3, [r2, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002a8a:	687b      	ldr	r3, [r7, #4]
 8002a8c:	681b      	ldr	r3, [r3, #0]
 8002a8e:	68fa      	ldr	r2, [r7, #12]
 8002a90:	b2d2      	uxtb	r2, r2
 8002a92:	4611      	mov	r1, r2
 8002a94:	4618      	mov	r0, r3
 8002a96:	f005 fbd9 	bl	800824c <USB_HC_Halt>
}
 8002a9a:	e2f1      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NYET) == USB_OTG_HCINT_NYET)
 8002a9c:	68fb      	ldr	r3, [r7, #12]
 8002a9e:	015a      	lsls	r2, r3, #5
 8002aa0:	693b      	ldr	r3, [r7, #16]
 8002aa2:	4413      	add	r3, r2
 8002aa4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002aa8:	689b      	ldr	r3, [r3, #8]
 8002aaa:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002aae:	2b40      	cmp	r3, #64	; 0x40
 8002ab0:	d13f      	bne.n	8002b32 <HCD_HC_OUT_IRQHandler+0x194>
    hhcd->hc[ch_num].state = HC_NYET;
 8002ab2:	6879      	ldr	r1, [r7, #4]
 8002ab4:	68fa      	ldr	r2, [r7, #12]
 8002ab6:	4613      	mov	r3, r2
 8002ab8:	009b      	lsls	r3, r3, #2
 8002aba:	4413      	add	r3, r2
 8002abc:	00db      	lsls	r3, r3, #3
 8002abe:	440b      	add	r3, r1
 8002ac0:	335d      	adds	r3, #93	; 0x5d
 8002ac2:	2204      	movs	r2, #4
 8002ac4:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].do_ping = 1U;
 8002ac6:	6879      	ldr	r1, [r7, #4]
 8002ac8:	68fa      	ldr	r2, [r7, #12]
 8002aca:	4613      	mov	r3, r2
 8002acc:	009b      	lsls	r3, r3, #2
 8002ace:	4413      	add	r3, r2
 8002ad0:	00db      	lsls	r3, r3, #3
 8002ad2:	440b      	add	r3, r1
 8002ad4:	333d      	adds	r3, #61	; 0x3d
 8002ad6:	2201      	movs	r2, #1
 8002ad8:	701a      	strb	r2, [r3, #0]
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002ada:	6879      	ldr	r1, [r7, #4]
 8002adc:	68fa      	ldr	r2, [r7, #12]
 8002ade:	4613      	mov	r3, r2
 8002ae0:	009b      	lsls	r3, r3, #2
 8002ae2:	4413      	add	r3, r2
 8002ae4:	00db      	lsls	r3, r3, #3
 8002ae6:	440b      	add	r3, r1
 8002ae8:	3358      	adds	r3, #88	; 0x58
 8002aea:	2200      	movs	r2, #0
 8002aec:	601a      	str	r2, [r3, #0]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002aee:	68fb      	ldr	r3, [r7, #12]
 8002af0:	015a      	lsls	r2, r3, #5
 8002af2:	693b      	ldr	r3, [r7, #16]
 8002af4:	4413      	add	r3, r2
 8002af6:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002afa:	68db      	ldr	r3, [r3, #12]
 8002afc:	68fa      	ldr	r2, [r7, #12]
 8002afe:	0151      	lsls	r1, r2, #5
 8002b00:	693a      	ldr	r2, [r7, #16]
 8002b02:	440a      	add	r2, r1
 8002b04:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002b08:	f043 0302 	orr.w	r3, r3, #2
 8002b0c:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	681b      	ldr	r3, [r3, #0]
 8002b12:	68fa      	ldr	r2, [r7, #12]
 8002b14:	b2d2      	uxtb	r2, r2
 8002b16:	4611      	mov	r1, r2
 8002b18:	4618      	mov	r0, r3
 8002b1a:	f005 fb97 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8002b1e:	68fb      	ldr	r3, [r7, #12]
 8002b20:	015a      	lsls	r2, r3, #5
 8002b22:	693b      	ldr	r3, [r7, #16]
 8002b24:	4413      	add	r3, r2
 8002b26:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b2a:	461a      	mov	r2, r3
 8002b2c:	2340      	movs	r3, #64	; 0x40
 8002b2e:	6093      	str	r3, [r2, #8]
}
 8002b30:	e2a6      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8002b32:	68fb      	ldr	r3, [r7, #12]
 8002b34:	015a      	lsls	r2, r3, #5
 8002b36:	693b      	ldr	r3, [r7, #16]
 8002b38:	4413      	add	r3, r2
 8002b3a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b3e:	689b      	ldr	r3, [r3, #8]
 8002b40:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8002b44:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8002b48:	d122      	bne.n	8002b90 <HCD_HC_OUT_IRQHandler+0x1f2>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002b4a:	68fb      	ldr	r3, [r7, #12]
 8002b4c:	015a      	lsls	r2, r3, #5
 8002b4e:	693b      	ldr	r3, [r7, #16]
 8002b50:	4413      	add	r3, r2
 8002b52:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b56:	68db      	ldr	r3, [r3, #12]
 8002b58:	68fa      	ldr	r2, [r7, #12]
 8002b5a:	0151      	lsls	r1, r2, #5
 8002b5c:	693a      	ldr	r2, [r7, #16]
 8002b5e:	440a      	add	r2, r1
 8002b60:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002b64:	f043 0302 	orr.w	r3, r3, #2
 8002b68:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002b6a:	687b      	ldr	r3, [r7, #4]
 8002b6c:	681b      	ldr	r3, [r3, #0]
 8002b6e:	68fa      	ldr	r2, [r7, #12]
 8002b70:	b2d2      	uxtb	r2, r2
 8002b72:	4611      	mov	r1, r2
 8002b74:	4618      	mov	r0, r3
 8002b76:	f005 fb69 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8002b7a:	68fb      	ldr	r3, [r7, #12]
 8002b7c:	015a      	lsls	r2, r3, #5
 8002b7e:	693b      	ldr	r3, [r7, #16]
 8002b80:	4413      	add	r3, r2
 8002b82:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b86:	461a      	mov	r2, r3
 8002b88:	f44f 7300 	mov.w	r3, #512	; 0x200
 8002b8c:	6093      	str	r3, [r2, #8]
}
 8002b8e:	e277      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 8002b90:	68fb      	ldr	r3, [r7, #12]
 8002b92:	015a      	lsls	r2, r3, #5
 8002b94:	693b      	ldr	r3, [r7, #16]
 8002b96:	4413      	add	r3, r2
 8002b98:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002b9c:	689b      	ldr	r3, [r3, #8]
 8002b9e:	f003 0301 	and.w	r3, r3, #1
 8002ba2:	2b01      	cmp	r3, #1
 8002ba4:	d135      	bne.n	8002c12 <HCD_HC_OUT_IRQHandler+0x274>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002ba6:	6879      	ldr	r1, [r7, #4]
 8002ba8:	68fa      	ldr	r2, [r7, #12]
 8002baa:	4613      	mov	r3, r2
 8002bac:	009b      	lsls	r3, r3, #2
 8002bae:	4413      	add	r3, r2
 8002bb0:	00db      	lsls	r3, r3, #3
 8002bb2:	440b      	add	r3, r1
 8002bb4:	3358      	adds	r3, #88	; 0x58
 8002bb6:	2200      	movs	r2, #0
 8002bb8:	601a      	str	r2, [r3, #0]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002bba:	68fb      	ldr	r3, [r7, #12]
 8002bbc:	015a      	lsls	r2, r3, #5
 8002bbe:	693b      	ldr	r3, [r7, #16]
 8002bc0:	4413      	add	r3, r2
 8002bc2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002bc6:	68db      	ldr	r3, [r3, #12]
 8002bc8:	68fa      	ldr	r2, [r7, #12]
 8002bca:	0151      	lsls	r1, r2, #5
 8002bcc:	693a      	ldr	r2, [r7, #16]
 8002bce:	440a      	add	r2, r1
 8002bd0:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002bd4:	f043 0302 	orr.w	r3, r3, #2
 8002bd8:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002bda:	687b      	ldr	r3, [r7, #4]
 8002bdc:	681b      	ldr	r3, [r3, #0]
 8002bde:	68fa      	ldr	r2, [r7, #12]
 8002be0:	b2d2      	uxtb	r2, r2
 8002be2:	4611      	mov	r1, r2
 8002be4:	4618      	mov	r0, r3
 8002be6:	f005 fb31 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8002bea:	68fb      	ldr	r3, [r7, #12]
 8002bec:	015a      	lsls	r2, r3, #5
 8002bee:	693b      	ldr	r3, [r7, #16]
 8002bf0:	4413      	add	r3, r2
 8002bf2:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002bf6:	461a      	mov	r2, r3
 8002bf8:	2301      	movs	r3, #1
 8002bfa:	6093      	str	r3, [r2, #8]
    hhcd->hc[ch_num].state = HC_XFRC;
 8002bfc:	6879      	ldr	r1, [r7, #4]
 8002bfe:	68fa      	ldr	r2, [r7, #12]
 8002c00:	4613      	mov	r3, r2
 8002c02:	009b      	lsls	r3, r3, #2
 8002c04:	4413      	add	r3, r2
 8002c06:	00db      	lsls	r3, r3, #3
 8002c08:	440b      	add	r3, r1
 8002c0a:	335d      	adds	r3, #93	; 0x5d
 8002c0c:	2201      	movs	r2, #1
 8002c0e:	701a      	strb	r2, [r3, #0]
}
 8002c10:	e236      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 8002c12:	68fb      	ldr	r3, [r7, #12]
 8002c14:	015a      	lsls	r2, r3, #5
 8002c16:	693b      	ldr	r3, [r7, #16]
 8002c18:	4413      	add	r3, r2
 8002c1a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c1e:	689b      	ldr	r3, [r3, #8]
 8002c20:	f003 0308 	and.w	r3, r3, #8
 8002c24:	2b08      	cmp	r3, #8
 8002c26:	d12b      	bne.n	8002c80 <HCD_HC_OUT_IRQHandler+0x2e2>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8002c28:	68fb      	ldr	r3, [r7, #12]
 8002c2a:	015a      	lsls	r2, r3, #5
 8002c2c:	693b      	ldr	r3, [r7, #16]
 8002c2e:	4413      	add	r3, r2
 8002c30:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c34:	461a      	mov	r2, r3
 8002c36:	2308      	movs	r3, #8
 8002c38:	6093      	str	r3, [r2, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002c3a:	68fb      	ldr	r3, [r7, #12]
 8002c3c:	015a      	lsls	r2, r3, #5
 8002c3e:	693b      	ldr	r3, [r7, #16]
 8002c40:	4413      	add	r3, r2
 8002c42:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c46:	68db      	ldr	r3, [r3, #12]
 8002c48:	68fa      	ldr	r2, [r7, #12]
 8002c4a:	0151      	lsls	r1, r2, #5
 8002c4c:	693a      	ldr	r2, [r7, #16]
 8002c4e:	440a      	add	r2, r1
 8002c50:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002c54:	f043 0302 	orr.w	r3, r3, #2
 8002c58:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002c5a:	687b      	ldr	r3, [r7, #4]
 8002c5c:	681b      	ldr	r3, [r3, #0]
 8002c5e:	68fa      	ldr	r2, [r7, #12]
 8002c60:	b2d2      	uxtb	r2, r2
 8002c62:	4611      	mov	r1, r2
 8002c64:	4618      	mov	r0, r3
 8002c66:	f005 faf1 	bl	800824c <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_STALL;
 8002c6a:	6879      	ldr	r1, [r7, #4]
 8002c6c:	68fa      	ldr	r2, [r7, #12]
 8002c6e:	4613      	mov	r3, r2
 8002c70:	009b      	lsls	r3, r3, #2
 8002c72:	4413      	add	r3, r2
 8002c74:	00db      	lsls	r3, r3, #3
 8002c76:	440b      	add	r3, r1
 8002c78:	335d      	adds	r3, #93	; 0x5d
 8002c7a:	2205      	movs	r2, #5
 8002c7c:	701a      	strb	r2, [r3, #0]
}
 8002c7e:	e1ff      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8002c80:	68fb      	ldr	r3, [r7, #12]
 8002c82:	015a      	lsls	r2, r3, #5
 8002c84:	693b      	ldr	r3, [r7, #16]
 8002c86:	4413      	add	r3, r2
 8002c88:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002c8c:	689b      	ldr	r3, [r3, #8]
 8002c8e:	f003 0310 	and.w	r3, r3, #16
 8002c92:	2b10      	cmp	r3, #16
 8002c94:	d155      	bne.n	8002d42 <HCD_HC_OUT_IRQHandler+0x3a4>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8002c96:	6879      	ldr	r1, [r7, #4]
 8002c98:	68fa      	ldr	r2, [r7, #12]
 8002c9a:	4613      	mov	r3, r2
 8002c9c:	009b      	lsls	r3, r3, #2
 8002c9e:	4413      	add	r3, r2
 8002ca0:	00db      	lsls	r3, r3, #3
 8002ca2:	440b      	add	r3, r1
 8002ca4:	3358      	adds	r3, #88	; 0x58
 8002ca6:	2200      	movs	r2, #0
 8002ca8:	601a      	str	r2, [r3, #0]
    hhcd->hc[ch_num].state = HC_NAK;
 8002caa:	6879      	ldr	r1, [r7, #4]
 8002cac:	68fa      	ldr	r2, [r7, #12]
 8002cae:	4613      	mov	r3, r2
 8002cb0:	009b      	lsls	r3, r3, #2
 8002cb2:	4413      	add	r3, r2
 8002cb4:	00db      	lsls	r3, r3, #3
 8002cb6:	440b      	add	r3, r1
 8002cb8:	335d      	adds	r3, #93	; 0x5d
 8002cba:	2203      	movs	r2, #3
 8002cbc:	701a      	strb	r2, [r3, #0]
    if (hhcd->hc[ch_num].do_ping == 0U)
 8002cbe:	6879      	ldr	r1, [r7, #4]
 8002cc0:	68fa      	ldr	r2, [r7, #12]
 8002cc2:	4613      	mov	r3, r2
 8002cc4:	009b      	lsls	r3, r3, #2
 8002cc6:	4413      	add	r3, r2
 8002cc8:	00db      	lsls	r3, r3, #3
 8002cca:	440b      	add	r3, r1
 8002ccc:	333d      	adds	r3, #61	; 0x3d
 8002cce:	781b      	ldrb	r3, [r3, #0]
 8002cd0:	2b00      	cmp	r3, #0
 8002cd2:	d114      	bne.n	8002cfe <HCD_HC_OUT_IRQHandler+0x360>
      if (hhcd->hc[ch_num].speed == HCD_SPEED_HIGH)
 8002cd4:	6879      	ldr	r1, [r7, #4]
 8002cd6:	68fa      	ldr	r2, [r7, #12]
 8002cd8:	4613      	mov	r3, r2
 8002cda:	009b      	lsls	r3, r3, #2
 8002cdc:	4413      	add	r3, r2
 8002cde:	00db      	lsls	r3, r3, #3
 8002ce0:	440b      	add	r3, r1
 8002ce2:	333c      	adds	r3, #60	; 0x3c
 8002ce4:	781b      	ldrb	r3, [r3, #0]
 8002ce6:	2b00      	cmp	r3, #0
 8002ce8:	d109      	bne.n	8002cfe <HCD_HC_OUT_IRQHandler+0x360>
        hhcd->hc[ch_num].do_ping = 1U;
 8002cea:	6879      	ldr	r1, [r7, #4]
 8002cec:	68fa      	ldr	r2, [r7, #12]
 8002cee:	4613      	mov	r3, r2
 8002cf0:	009b      	lsls	r3, r3, #2
 8002cf2:	4413      	add	r3, r2
 8002cf4:	00db      	lsls	r3, r3, #3
 8002cf6:	440b      	add	r3, r1
 8002cf8:	333d      	adds	r3, #61	; 0x3d
 8002cfa:	2201      	movs	r2, #1
 8002cfc:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002cfe:	68fb      	ldr	r3, [r7, #12]
 8002d00:	015a      	lsls	r2, r3, #5
 8002d02:	693b      	ldr	r3, [r7, #16]
 8002d04:	4413      	add	r3, r2
 8002d06:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002d0a:	68db      	ldr	r3, [r3, #12]
 8002d0c:	68fa      	ldr	r2, [r7, #12]
 8002d0e:	0151      	lsls	r1, r2, #5
 8002d10:	693a      	ldr	r2, [r7, #16]
 8002d12:	440a      	add	r2, r1
 8002d14:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002d18:	f043 0302 	orr.w	r3, r3, #2
 8002d1c:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002d1e:	687b      	ldr	r3, [r7, #4]
 8002d20:	681b      	ldr	r3, [r3, #0]
 8002d22:	68fa      	ldr	r2, [r7, #12]
 8002d24:	b2d2      	uxtb	r2, r2
 8002d26:	4611      	mov	r1, r2
 8002d28:	4618      	mov	r0, r3
 8002d2a:	f005 fa8f 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002d2e:	68fb      	ldr	r3, [r7, #12]
 8002d30:	015a      	lsls	r2, r3, #5
 8002d32:	693b      	ldr	r3, [r7, #16]
 8002d34:	4413      	add	r3, r2
 8002d36:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002d3a:	461a      	mov	r2, r3
 8002d3c:	2310      	movs	r3, #16
 8002d3e:	6093      	str	r3, [r2, #8]
}
 8002d40:	e19e      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 8002d42:	68fb      	ldr	r3, [r7, #12]
 8002d44:	015a      	lsls	r2, r3, #5
 8002d46:	693b      	ldr	r3, [r7, #16]
 8002d48:	4413      	add	r3, r2
 8002d4a:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002d4e:	689b      	ldr	r3, [r3, #8]
 8002d50:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8002d54:	2b80      	cmp	r3, #128	; 0x80
 8002d56:	d12b      	bne.n	8002db0 <HCD_HC_OUT_IRQHandler+0x412>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002d58:	68fb      	ldr	r3, [r7, #12]
 8002d5a:	015a      	lsls	r2, r3, #5
 8002d5c:	693b      	ldr	r3, [r7, #16]
 8002d5e:	4413      	add	r3, r2
 8002d60:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002d64:	68db      	ldr	r3, [r3, #12]
 8002d66:	68fa      	ldr	r2, [r7, #12]
 8002d68:	0151      	lsls	r1, r2, #5
 8002d6a:	693a      	ldr	r2, [r7, #16]
 8002d6c:	440a      	add	r2, r1
 8002d6e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002d72:	f043 0302 	orr.w	r3, r3, #2
 8002d76:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002d78:	687b      	ldr	r3, [r7, #4]
 8002d7a:	681b      	ldr	r3, [r3, #0]
 8002d7c:	68fa      	ldr	r2, [r7, #12]
 8002d7e:	b2d2      	uxtb	r2, r2
 8002d80:	4611      	mov	r1, r2
 8002d82:	4618      	mov	r0, r3
 8002d84:	f005 fa62 	bl	800824c <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_XACTERR;
 8002d88:	6879      	ldr	r1, [r7, #4]
 8002d8a:	68fa      	ldr	r2, [r7, #12]
 8002d8c:	4613      	mov	r3, r2
 8002d8e:	009b      	lsls	r3, r3, #2
 8002d90:	4413      	add	r3, r2
 8002d92:	00db      	lsls	r3, r3, #3
 8002d94:	440b      	add	r3, r1
 8002d96:	335d      	adds	r3, #93	; 0x5d
 8002d98:	2206      	movs	r2, #6
 8002d9a:	701a      	strb	r2, [r3, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8002d9c:	68fb      	ldr	r3, [r7, #12]
 8002d9e:	015a      	lsls	r2, r3, #5
 8002da0:	693b      	ldr	r3, [r7, #16]
 8002da2:	4413      	add	r3, r2
 8002da4:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002da8:	461a      	mov	r2, r3
 8002daa:	2380      	movs	r3, #128	; 0x80
 8002dac:	6093      	str	r3, [r2, #8]
}
 8002dae:	e167      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8002db0:	68fb      	ldr	r3, [r7, #12]
 8002db2:	015a      	lsls	r2, r3, #5
 8002db4:	693b      	ldr	r3, [r7, #16]
 8002db6:	4413      	add	r3, r2
 8002db8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002dbc:	689b      	ldr	r3, [r3, #8]
 8002dbe:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8002dc2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002dc6:	d135      	bne.n	8002e34 <HCD_HC_OUT_IRQHandler+0x496>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8002dc8:	68fb      	ldr	r3, [r7, #12]
 8002dca:	015a      	lsls	r2, r3, #5
 8002dcc:	693b      	ldr	r3, [r7, #16]
 8002dce:	4413      	add	r3, r2
 8002dd0:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002dd4:	68db      	ldr	r3, [r3, #12]
 8002dd6:	68fa      	ldr	r2, [r7, #12]
 8002dd8:	0151      	lsls	r1, r2, #5
 8002dda:	693a      	ldr	r2, [r7, #16]
 8002ddc:	440a      	add	r2, r1
 8002dde:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002de2:	f043 0302 	orr.w	r3, r3, #2
 8002de6:	60d3      	str	r3, [r2, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8002de8:	687b      	ldr	r3, [r7, #4]
 8002dea:	681b      	ldr	r3, [r3, #0]
 8002dec:	68fa      	ldr	r2, [r7, #12]
 8002dee:	b2d2      	uxtb	r2, r2
 8002df0:	4611      	mov	r1, r2
 8002df2:	4618      	mov	r0, r3
 8002df4:	f005 fa2a 	bl	800824c <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8002df8:	68fb      	ldr	r3, [r7, #12]
 8002dfa:	015a      	lsls	r2, r3, #5
 8002dfc:	693b      	ldr	r3, [r7, #16]
 8002dfe:	4413      	add	r3, r2
 8002e00:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002e04:	461a      	mov	r2, r3
 8002e06:	2310      	movs	r3, #16
 8002e08:	6093      	str	r3, [r2, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8002e0a:	68fb      	ldr	r3, [r7, #12]
 8002e0c:	015a      	lsls	r2, r3, #5
 8002e0e:	693b      	ldr	r3, [r7, #16]
 8002e10:	4413      	add	r3, r2
 8002e12:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002e16:	461a      	mov	r2, r3
 8002e18:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8002e1c:	6093      	str	r3, [r2, #8]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8002e1e:	6879      	ldr	r1, [r7, #4]
 8002e20:	68fa      	ldr	r2, [r7, #12]
 8002e22:	4613      	mov	r3, r2
 8002e24:	009b      	lsls	r3, r3, #2
 8002e26:	4413      	add	r3, r2
 8002e28:	00db      	lsls	r3, r3, #3
 8002e2a:	440b      	add	r3, r1
 8002e2c:	335d      	adds	r3, #93	; 0x5d
 8002e2e:	2208      	movs	r2, #8
 8002e30:	701a      	strb	r2, [r3, #0]
}
 8002e32:	e125      	b.n	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 8002e34:	68fb      	ldr	r3, [r7, #12]
 8002e36:	015a      	lsls	r2, r3, #5
 8002e38:	693b      	ldr	r3, [r7, #16]
 8002e3a:	4413      	add	r3, r2
 8002e3c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002e40:	689b      	ldr	r3, [r3, #8]
 8002e42:	f003 0302 	and.w	r3, r3, #2
 8002e46:	2b02      	cmp	r3, #2
 8002e48:	f040 811a 	bne.w	8003080 <HCD_HC_OUT_IRQHandler+0x6e2>
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8002e4c:	68fb      	ldr	r3, [r7, #12]
 8002e4e:	015a      	lsls	r2, r3, #5
 8002e50:	693b      	ldr	r3, [r7, #16]
 8002e52:	4413      	add	r3, r2
 8002e54:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8002e58:	68db      	ldr	r3, [r3, #12]
 8002e5a:	68fa      	ldr	r2, [r7, #12]
 8002e5c:	0151      	lsls	r1, r2, #5
 8002e5e:	693a      	ldr	r2, [r7, #16]
 8002e60:	440a      	add	r2, r1
 8002e62:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8002e66:	f023 0302 	bic.w	r3, r3, #2
 8002e6a:	60d3      	str	r3, [r2, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8002e6c:	6879      	ldr	r1, [r7, #4]
 8002e6e:	68fa      	ldr	r2, [r7, #12]
 8002e70:	4613      	mov	r3, r2
 8002e72:	009b      	lsls	r3, r3, #2
 8002e74:	4413      	add	r3, r2
 8002e76:	00db      	lsls	r3, r3, #3
 8002e78:	440b      	add	r3, r1
 8002e7a:	335d      	adds	r3, #93	; 0x5d
 8002e7c:	781b      	ldrb	r3, [r3, #0]
 8002e7e:	2b01      	cmp	r3, #1
 8002e80:	d137      	bne.n	8002ef2 <HCD_HC_OUT_IRQHandler+0x554>
      hhcd->hc[ch_num].urb_state  = URB_DONE;
 8002e82:	6879      	ldr	r1, [r7, #4]
 8002e84:	68fa      	ldr	r2, [r7, #12]
 8002e86:	4613      	mov	r3, r2
 8002e88:	009b      	lsls	r3, r3, #2
 8002e8a:	4413      	add	r3, r2
 8002e8c:	00db      	lsls	r3, r3, #3
 8002e8e:	440b      	add	r3, r1
 8002e90:	335c      	adds	r3, #92	; 0x5c
 8002e92:	2201      	movs	r2, #1
 8002e94:	701a      	strb	r2, [r3, #0]
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8002e96:	6879      	ldr	r1, [r7, #4]
 8002e98:	68fa      	ldr	r2, [r7, #12]
 8002e9a:	4613      	mov	r3, r2
 8002e9c:	009b      	lsls	r3, r3, #2
 8002e9e:	4413      	add	r3, r2
 8002ea0:	00db      	lsls	r3, r3, #3
 8002ea2:	440b      	add	r3, r1
 8002ea4:	333f      	adds	r3, #63	; 0x3f
 8002ea6:	781b      	ldrb	r3, [r3, #0]
 8002ea8:	2b02      	cmp	r3, #2
 8002eaa:	d00b      	beq.n	8002ec4 <HCD_HC_OUT_IRQHandler+0x526>
          (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR))
 8002eac:	6879      	ldr	r1, [r7, #4]
 8002eae:	68fa      	ldr	r2, [r7, #12]
 8002eb0:	4613      	mov	r3, r2
 8002eb2:	009b      	lsls	r3, r3, #2
 8002eb4:	4413      	add	r3, r2
 8002eb6:	00db      	lsls	r3, r3, #3
 8002eb8:	440b      	add	r3, r1
 8002eba:	333f      	adds	r3, #63	; 0x3f
 8002ebc:	781b      	ldrb	r3, [r3, #0]
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8002ebe:	2b03      	cmp	r3, #3
 8002ec0:	f040 80c5 	bne.w	800304e <HCD_HC_OUT_IRQHandler+0x6b0>
        hhcd->hc[ch_num].toggle_out ^= 1U;
 8002ec4:	6879      	ldr	r1, [r7, #4]
 8002ec6:	68fa      	ldr	r2, [r7, #12]
 8002ec8:	4613      	mov	r3, r2
 8002eca:	009b      	lsls	r3, r3, #2
 8002ecc:	4413      	add	r3, r2
 8002ece:	00db      	lsls	r3, r3, #3
 8002ed0:	440b      	add	r3, r1
 8002ed2:	3351      	adds	r3, #81	; 0x51
 8002ed4:	781b      	ldrb	r3, [r3, #0]
 8002ed6:	f083 0301 	eor.w	r3, r3, #1
 8002eda:	b2d8      	uxtb	r0, r3
 8002edc:	6879      	ldr	r1, [r7, #4]
 8002ede:	68fa      	ldr	r2, [r7, #12]
 8002ee0:	4613      	mov	r3, r2
 8002ee2:	009b      	lsls	r3, r3, #2
 8002ee4:	4413      	add	r3, r2
 8002ee6:	00db      	lsls	r3, r3, #3
 8002ee8:	440b      	add	r3, r1
 8002eea:	3351      	adds	r3, #81	; 0x51
 8002eec:	4602      	mov	r2, r0
 8002eee:	701a      	strb	r2, [r3, #0]
 8002ef0:	e0ad      	b.n	800304e <HCD_HC_OUT_IRQHandler+0x6b0>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8002ef2:	6879      	ldr	r1, [r7, #4]
 8002ef4:	68fa      	ldr	r2, [r7, #12]
 8002ef6:	4613      	mov	r3, r2
 8002ef8:	009b      	lsls	r3, r3, #2
 8002efa:	4413      	add	r3, r2
 8002efc:	00db      	lsls	r3, r3, #3
 8002efe:	440b      	add	r3, r1
 8002f00:	335d      	adds	r3, #93	; 0x5d
 8002f02:	781b      	ldrb	r3, [r3, #0]
 8002f04:	2b03      	cmp	r3, #3
 8002f06:	d10a      	bne.n	8002f1e <HCD_HC_OUT_IRQHandler+0x580>
      hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8002f08:	6879      	ldr	r1, [r7, #4]
 8002f0a:	68fa      	ldr	r2, [r7, #12]
 8002f0c:	4613      	mov	r3, r2
 8002f0e:	009b      	lsls	r3, r3, #2
 8002f10:	4413      	add	r3, r2
 8002f12:	00db      	lsls	r3, r3, #3
 8002f14:	440b      	add	r3, r1
 8002f16:	335c      	adds	r3, #92	; 0x5c
 8002f18:	2202      	movs	r2, #2
 8002f1a:	701a      	strb	r2, [r3, #0]
 8002f1c:	e097      	b.n	800304e <HCD_HC_OUT_IRQHandler+0x6b0>
    else if (hhcd->hc[ch_num].state == HC_NYET)
 8002f1e:	6879      	ldr	r1, [r7, #4]
 8002f20:	68fa      	ldr	r2, [r7, #12]
 8002f22:	4613      	mov	r3, r2
 8002f24:	009b      	lsls	r3, r3, #2
 8002f26:	4413      	add	r3, r2
 8002f28:	00db      	lsls	r3, r3, #3
 8002f2a:	440b      	add	r3, r1
 8002f2c:	335d      	adds	r3, #93	; 0x5d
 8002f2e:	781b      	ldrb	r3, [r3, #0]
 8002f30:	2b04      	cmp	r3, #4
 8002f32:	d10a      	bne.n	8002f4a <HCD_HC_OUT_IRQHandler+0x5ac>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8002f34:	6879      	ldr	r1, [r7, #4]
 8002f36:	68fa      	ldr	r2, [r7, #12]
 8002f38:	4613      	mov	r3, r2
 8002f3a:	009b      	lsls	r3, r3, #2
 8002f3c:	4413      	add	r3, r2
 8002f3e:	00db      	lsls	r3, r3, #3
 8002f40:	440b      	add	r3, r1
 8002f42:	335c      	adds	r3, #92	; 0x5c
 8002f44:	2202      	movs	r2, #2
 8002f46:	701a      	strb	r2, [r3, #0]
 8002f48:	e081      	b.n	800304e <HCD_HC_OUT_IRQHandler+0x6b0>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8002f4a:	6879      	ldr	r1, [r7, #4]
 8002f4c:	68fa      	ldr	r2, [r7, #12]
 8002f4e:	4613      	mov	r3, r2
 8002f50:	009b      	lsls	r3, r3, #2
 8002f52:	4413      	add	r3, r2
 8002f54:	00db      	lsls	r3, r3, #3
 8002f56:	440b      	add	r3, r1
 8002f58:	335d      	adds	r3, #93	; 0x5d
 8002f5a:	781b      	ldrb	r3, [r3, #0]
 8002f5c:	2b05      	cmp	r3, #5
 8002f5e:	d10a      	bne.n	8002f76 <HCD_HC_OUT_IRQHandler+0x5d8>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8002f60:	6879      	ldr	r1, [r7, #4]
 8002f62:	68fa      	ldr	r2, [r7, #12]
 8002f64:	4613      	mov	r3, r2
 8002f66:	009b      	lsls	r3, r3, #2
 8002f68:	4413      	add	r3, r2
 8002f6a:	00db      	lsls	r3, r3, #3
 8002f6c:	440b      	add	r3, r1
 8002f6e:	335c      	adds	r3, #92	; 0x5c
 8002f70:	2205      	movs	r2, #5
 8002f72:	701a      	strb	r2, [r3, #0]
 8002f74:	e06b      	b.n	800304e <HCD_HC_OUT_IRQHandler+0x6b0>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8002f76:	6879      	ldr	r1, [r7, #4]
 8002f78:	68fa      	ldr	r2, [r7, #12]
 8002f7a:	4613      	mov	r3, r2
 8002f7c:	009b      	lsls	r3, r3, #2
 8002f7e:	4413      	add	r3, r2
 8002f80:	00db      	lsls	r3, r3, #3
 8002f82:	440b      	add	r3, r1
 8002f84:	335d      	adds	r3, #93	; 0x5d
 8002f86:	781b      	ldrb	r3, [r3, #0]
 8002f88:	2b06      	cmp	r3, #6
 8002f8a:	d00a      	beq.n	8002fa2 <HCD_HC_OUT_IRQHandler+0x604>
             (hhcd->hc[ch_num].state == HC_DATATGLERR))
 8002f8c:	6879      	ldr	r1, [r7, #4]
 8002f8e:	68fa      	ldr	r2, [r7, #12]
 8002f90:	4613      	mov	r3, r2
 8002f92:	009b      	lsls	r3, r3, #2
 8002f94:	4413      	add	r3, r2
 8002f96:	00db      	lsls	r3, r3, #3
 8002f98:	440b      	add	r3, r1
 8002f9a:	335d      	adds	r3, #93	; 0x5d
 8002f9c:	781b      	ldrb	r3, [r3, #0]
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8002f9e:	2b08      	cmp	r3, #8
 8002fa0:	d155      	bne.n	800304e <HCD_HC_OUT_IRQHandler+0x6b0>
      hhcd->hc[ch_num].ErrCnt++;
 8002fa2:	6879      	ldr	r1, [r7, #4]
 8002fa4:	68fa      	ldr	r2, [r7, #12]
 8002fa6:	4613      	mov	r3, r2
 8002fa8:	009b      	lsls	r3, r3, #2
 8002faa:	4413      	add	r3, r2
 8002fac:	00db      	lsls	r3, r3, #3
 8002fae:	440b      	add	r3, r1
 8002fb0:	3358      	adds	r3, #88	; 0x58
 8002fb2:	681b      	ldr	r3, [r3, #0]
 8002fb4:	1c59      	adds	r1, r3, #1
 8002fb6:	6878      	ldr	r0, [r7, #4]
 8002fb8:	68fa      	ldr	r2, [r7, #12]
 8002fba:	4613      	mov	r3, r2
 8002fbc:	009b      	lsls	r3, r3, #2
 8002fbe:	4413      	add	r3, r2
 8002fc0:	00db      	lsls	r3, r3, #3
 8002fc2:	4403      	add	r3, r0
 8002fc4:	3358      	adds	r3, #88	; 0x58
 8002fc6:	6019      	str	r1, [r3, #0]
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 8002fc8:	6879      	ldr	r1, [r7, #4]
 8002fca:	68fa      	ldr	r2, [r7, #12]
 8002fcc:	4613      	mov	r3, r2
 8002fce:	009b      	lsls	r3, r3, #2
 8002fd0:	4413      	add	r3, r2
 8002fd2:	00db      	lsls	r3, r3, #3
 8002fd4:	440b      	add	r3, r1
 8002fd6:	3358      	adds	r3, #88	; 0x58
 8002fd8:	681b      	ldr	r3, [r3, #0]
 8002fda:	2b03      	cmp	r3, #3
 8002fdc:	d914      	bls.n	8003008 <HCD_HC_OUT_IRQHandler+0x66a>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8002fde:	6879      	ldr	r1, [r7, #4]
 8002fe0:	68fa      	ldr	r2, [r7, #12]
 8002fe2:	4613      	mov	r3, r2
 8002fe4:	009b      	lsls	r3, r3, #2
 8002fe6:	4413      	add	r3, r2
 8002fe8:	00db      	lsls	r3, r3, #3
 8002fea:	440b      	add	r3, r1
 8002fec:	3358      	adds	r3, #88	; 0x58
 8002fee:	2200      	movs	r2, #0
 8002ff0:	601a      	str	r2, [r3, #0]
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8002ff2:	6879      	ldr	r1, [r7, #4]
 8002ff4:	68fa      	ldr	r2, [r7, #12]
 8002ff6:	4613      	mov	r3, r2
 8002ff8:	009b      	lsls	r3, r3, #2
 8002ffa:	4413      	add	r3, r2
 8002ffc:	00db      	lsls	r3, r3, #3
 8002ffe:	440b      	add	r3, r1
 8003000:	335c      	adds	r3, #92	; 0x5c
 8003002:	2204      	movs	r2, #4
 8003004:	701a      	strb	r2, [r3, #0]
 8003006:	e009      	b.n	800301c <HCD_HC_OUT_IRQHandler+0x67e>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8003008:	6879      	ldr	r1, [r7, #4]
 800300a:	68fa      	ldr	r2, [r7, #12]
 800300c:	4613      	mov	r3, r2
 800300e:	009b      	lsls	r3, r3, #2
 8003010:	4413      	add	r3, r2
 8003012:	00db      	lsls	r3, r3, #3
 8003014:	440b      	add	r3, r1
 8003016:	335c      	adds	r3, #92	; 0x5c
 8003018:	2202      	movs	r2, #2
 800301a:	701a      	strb	r2, [r3, #0]
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 800301c:	68fb      	ldr	r3, [r7, #12]
 800301e:	015a      	lsls	r2, r3, #5
 8003020:	693b      	ldr	r3, [r7, #16]
 8003022:	4413      	add	r3, r2
 8003024:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003028:	681b      	ldr	r3, [r3, #0]
 800302a:	60bb      	str	r3, [r7, #8]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800302c:	68bb      	ldr	r3, [r7, #8]
 800302e:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003032:	60bb      	str	r3, [r7, #8]
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 8003034:	68bb      	ldr	r3, [r7, #8]
 8003036:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800303a:	60bb      	str	r3, [r7, #8]
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 800303c:	68fb      	ldr	r3, [r7, #12]
 800303e:	015a      	lsls	r2, r3, #5
 8003040:	693b      	ldr	r3, [r7, #16]
 8003042:	4413      	add	r3, r2
 8003044:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003048:	461a      	mov	r2, r3
 800304a:	68bb      	ldr	r3, [r7, #8]
 800304c:	6013      	str	r3, [r2, #0]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 800304e:	68fb      	ldr	r3, [r7, #12]
 8003050:	015a      	lsls	r2, r3, #5
 8003052:	693b      	ldr	r3, [r7, #16]
 8003054:	4413      	add	r3, r2
 8003056:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800305a:	461a      	mov	r2, r3
 800305c:	2302      	movs	r3, #2
 800305e:	6093      	str	r3, [r2, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8003060:	68fb      	ldr	r3, [r7, #12]
 8003062:	b2d8      	uxtb	r0, r3
 8003064:	6879      	ldr	r1, [r7, #4]
 8003066:	68fa      	ldr	r2, [r7, #12]
 8003068:	4613      	mov	r3, r2
 800306a:	009b      	lsls	r3, r3, #2
 800306c:	4413      	add	r3, r2
 800306e:	00db      	lsls	r3, r3, #3
 8003070:	440b      	add	r3, r1
 8003072:	335c      	adds	r3, #92	; 0x5c
 8003074:	781b      	ldrb	r3, [r3, #0]
 8003076:	461a      	mov	r2, r3
 8003078:	4601      	mov	r1, r0
 800307a:	6878      	ldr	r0, [r7, #4]
 800307c:	f7ff f8ea 	bl	8002254 <HAL_HCD_HC_NotifyURBChange_Callback>
}
 8003080:	bf00      	nop
 8003082:	3718      	adds	r7, #24
 8003084:	46bd      	mov	sp, r7
 8003086:	bd80      	pop	{r7, pc}

08003088 <HCD_RXQLVL_IRQHandler>:
  * @brief  Handle Rx Queue Level interrupt requests.
  * @param  hhcd HCD handle
  * @retval none
  */
static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 8003088:	b580      	push	{r7, lr}
 800308a:	b08a      	sub	sp, #40	; 0x28
 800308c:	af00      	add	r7, sp, #0
 800308e:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 8003090:	687b      	ldr	r3, [r7, #4]
 8003092:	681b      	ldr	r3, [r3, #0]
 8003094:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t USBx_BASE = (uint32_t)USBx;
 8003096:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003098:	623b      	str	r3, [r7, #32]
  uint32_t pktcnt;
  uint32_t temp;
  uint32_t tmpreg;
  uint32_t ch_num;

  temp = hhcd->Instance->GRXSTSP;
 800309a:	687b      	ldr	r3, [r7, #4]
 800309c:	681b      	ldr	r3, [r3, #0]
 800309e:	6a1b      	ldr	r3, [r3, #32]
 80030a0:	61fb      	str	r3, [r7, #28]
  ch_num = temp & USB_OTG_GRXSTSP_EPNUM;
 80030a2:	69fb      	ldr	r3, [r7, #28]
 80030a4:	f003 030f 	and.w	r3, r3, #15
 80030a8:	61bb      	str	r3, [r7, #24]
  pktsts = (temp & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 80030aa:	69fb      	ldr	r3, [r7, #28]
 80030ac:	0c5b      	lsrs	r3, r3, #17
 80030ae:	f003 030f 	and.w	r3, r3, #15
 80030b2:	617b      	str	r3, [r7, #20]
  pktcnt = (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 80030b4:	69fb      	ldr	r3, [r7, #28]
 80030b6:	091b      	lsrs	r3, r3, #4
 80030b8:	f3c3 030a 	ubfx	r3, r3, #0, #11
 80030bc:	613b      	str	r3, [r7, #16]

  switch (pktsts)
 80030be:	697b      	ldr	r3, [r7, #20]
 80030c0:	2b02      	cmp	r3, #2
 80030c2:	d003      	beq.n	80030cc <HCD_RXQLVL_IRQHandler+0x44>
 80030c4:	2b05      	cmp	r3, #5
 80030c6:	f000 8082 	beq.w	80031ce <HCD_RXQLVL_IRQHandler+0x146>
      break;

    case GRXSTS_PKTSTS_IN_XFER_COMP:
    case GRXSTS_PKTSTS_CH_HALTED:
    default:
      break;
 80030ca:	e083      	b.n	80031d4 <HCD_RXQLVL_IRQHandler+0x14c>
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 80030cc:	693b      	ldr	r3, [r7, #16]
 80030ce:	2b00      	cmp	r3, #0
 80030d0:	d07f      	beq.n	80031d2 <HCD_RXQLVL_IRQHandler+0x14a>
 80030d2:	6879      	ldr	r1, [r7, #4]
 80030d4:	69ba      	ldr	r2, [r7, #24]
 80030d6:	4613      	mov	r3, r2
 80030d8:	009b      	lsls	r3, r3, #2
 80030da:	4413      	add	r3, r2
 80030dc:	00db      	lsls	r3, r3, #3
 80030de:	440b      	add	r3, r1
 80030e0:	3344      	adds	r3, #68	; 0x44
 80030e2:	681b      	ldr	r3, [r3, #0]
 80030e4:	2b00      	cmp	r3, #0
 80030e6:	d074      	beq.n	80031d2 <HCD_RXQLVL_IRQHandler+0x14a>
        (void)USB_ReadPacket(hhcd->Instance, hhcd->hc[ch_num].xfer_buff, (uint16_t)pktcnt);
 80030e8:	687b      	ldr	r3, [r7, #4]
 80030ea:	6818      	ldr	r0, [r3, #0]
 80030ec:	6879      	ldr	r1, [r7, #4]
 80030ee:	69ba      	ldr	r2, [r7, #24]
 80030f0:	4613      	mov	r3, r2
 80030f2:	009b      	lsls	r3, r3, #2
 80030f4:	4413      	add	r3, r2
 80030f6:	00db      	lsls	r3, r3, #3
 80030f8:	440b      	add	r3, r1
 80030fa:	3344      	adds	r3, #68	; 0x44
 80030fc:	681b      	ldr	r3, [r3, #0]
 80030fe:	693a      	ldr	r2, [r7, #16]
 8003100:	b292      	uxth	r2, r2
 8003102:	4619      	mov	r1, r3
 8003104:	f004 fef0 	bl	8007ee8 <USB_ReadPacket>
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 8003108:	6879      	ldr	r1, [r7, #4]
 800310a:	69ba      	ldr	r2, [r7, #24]
 800310c:	4613      	mov	r3, r2
 800310e:	009b      	lsls	r3, r3, #2
 8003110:	4413      	add	r3, r2
 8003112:	00db      	lsls	r3, r3, #3
 8003114:	440b      	add	r3, r1
 8003116:	3344      	adds	r3, #68	; 0x44
 8003118:	681a      	ldr	r2, [r3, #0]
 800311a:	693b      	ldr	r3, [r7, #16]
 800311c:	18d1      	adds	r1, r2, r3
 800311e:	6878      	ldr	r0, [r7, #4]
 8003120:	69ba      	ldr	r2, [r7, #24]
 8003122:	4613      	mov	r3, r2
 8003124:	009b      	lsls	r3, r3, #2
 8003126:	4413      	add	r3, r2
 8003128:	00db      	lsls	r3, r3, #3
 800312a:	4403      	add	r3, r0
 800312c:	3344      	adds	r3, #68	; 0x44
 800312e:	6019      	str	r1, [r3, #0]
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 8003130:	6879      	ldr	r1, [r7, #4]
 8003132:	69ba      	ldr	r2, [r7, #24]
 8003134:	4613      	mov	r3, r2
 8003136:	009b      	lsls	r3, r3, #2
 8003138:	4413      	add	r3, r2
 800313a:	00db      	lsls	r3, r3, #3
 800313c:	440b      	add	r3, r1
 800313e:	334c      	adds	r3, #76	; 0x4c
 8003140:	681a      	ldr	r2, [r3, #0]
 8003142:	693b      	ldr	r3, [r7, #16]
 8003144:	18d1      	adds	r1, r2, r3
 8003146:	6878      	ldr	r0, [r7, #4]
 8003148:	69ba      	ldr	r2, [r7, #24]
 800314a:	4613      	mov	r3, r2
 800314c:	009b      	lsls	r3, r3, #2
 800314e:	4413      	add	r3, r2
 8003150:	00db      	lsls	r3, r3, #3
 8003152:	4403      	add	r3, r0
 8003154:	334c      	adds	r3, #76	; 0x4c
 8003156:	6019      	str	r1, [r3, #0]
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8003158:	69bb      	ldr	r3, [r7, #24]
 800315a:	015a      	lsls	r2, r3, #5
 800315c:	6a3b      	ldr	r3, [r7, #32]
 800315e:	4413      	add	r3, r2
 8003160:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8003164:	691a      	ldr	r2, [r3, #16]
 8003166:	4b1d      	ldr	r3, [pc, #116]	; (80031dc <HCD_RXQLVL_IRQHandler+0x154>)
 8003168:	4013      	ands	r3, r2
 800316a:	2b00      	cmp	r3, #0
 800316c:	d031      	beq.n	80031d2 <HCD_RXQLVL_IRQHandler+0x14a>
          tmpreg = USBx_HC(ch_num)->HCCHAR;
 800316e:	69bb      	ldr	r3, [r7, #24]
 8003170:	015a      	lsls	r2, r3, #5
 8003172:	6a3b      	ldr	r3, [r7, #32]
 8003174:	4413      	add	r3, r2
 8003176:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800317a:	681b      	ldr	r3, [r3, #0]
 800317c:	60fb      	str	r3, [r7, #12]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 800317e:	68fb      	ldr	r3, [r7, #12]
 8003180:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
 8003184:	60fb      	str	r3, [r7, #12]
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 8003186:	68fb      	ldr	r3, [r7, #12]
 8003188:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800318c:	60fb      	str	r3, [r7, #12]
          USBx_HC(ch_num)->HCCHAR = tmpreg;
 800318e:	69bb      	ldr	r3, [r7, #24]
 8003190:	015a      	lsls	r2, r3, #5
 8003192:	6a3b      	ldr	r3, [r7, #32]
 8003194:	4413      	add	r3, r2
 8003196:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800319a:	461a      	mov	r2, r3
 800319c:	68fb      	ldr	r3, [r7, #12]
 800319e:	6013      	str	r3, [r2, #0]
          hhcd->hc[ch_num].toggle_in ^= 1U;
 80031a0:	6879      	ldr	r1, [r7, #4]
 80031a2:	69ba      	ldr	r2, [r7, #24]
 80031a4:	4613      	mov	r3, r2
 80031a6:	009b      	lsls	r3, r3, #2
 80031a8:	4413      	add	r3, r2
 80031aa:	00db      	lsls	r3, r3, #3
 80031ac:	440b      	add	r3, r1
 80031ae:	3350      	adds	r3, #80	; 0x50
 80031b0:	781b      	ldrb	r3, [r3, #0]
 80031b2:	f083 0301 	eor.w	r3, r3, #1
 80031b6:	b2d8      	uxtb	r0, r3
 80031b8:	6879      	ldr	r1, [r7, #4]
 80031ba:	69ba      	ldr	r2, [r7, #24]
 80031bc:	4613      	mov	r3, r2
 80031be:	009b      	lsls	r3, r3, #2
 80031c0:	4413      	add	r3, r2
 80031c2:	00db      	lsls	r3, r3, #3
 80031c4:	440b      	add	r3, r1
 80031c6:	3350      	adds	r3, #80	; 0x50
 80031c8:	4602      	mov	r2, r0
 80031ca:	701a      	strb	r2, [r3, #0]
      break;
 80031cc:	e001      	b.n	80031d2 <HCD_RXQLVL_IRQHandler+0x14a>
      break;
 80031ce:	bf00      	nop
 80031d0:	e000      	b.n	80031d4 <HCD_RXQLVL_IRQHandler+0x14c>
      break;
 80031d2:	bf00      	nop
  }
}
 80031d4:	bf00      	nop
 80031d6:	3728      	adds	r7, #40	; 0x28
 80031d8:	46bd      	mov	sp, r7
 80031da:	bd80      	pop	{r7, pc}
 80031dc:	1ff80000 	.word	0x1ff80000

080031e0 <HCD_Port_IRQHandler>:
  * @brief  Handle Host Port interrupt requests.
  * @param  hhcd HCD handle
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 80031e0:	b580      	push	{r7, lr}
 80031e2:	b086      	sub	sp, #24
 80031e4:	af00      	add	r7, sp, #0
 80031e6:	6078      	str	r0, [r7, #4]
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80031e8:	687b      	ldr	r3, [r7, #4]
 80031ea:	681b      	ldr	r3, [r3, #0]
 80031ec:	617b      	str	r3, [r7, #20]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80031ee:	697b      	ldr	r3, [r7, #20]
 80031f0:	613b      	str	r3, [r7, #16]
  __IO uint32_t hprt0, hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 80031f2:	693b      	ldr	r3, [r7, #16]
 80031f4:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80031f8:	681b      	ldr	r3, [r3, #0]
 80031fa:	60fb      	str	r3, [r7, #12]
  hprt0_dup = USBx_HPRT0;
 80031fc:	693b      	ldr	r3, [r7, #16]
 80031fe:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 8003202:	681b      	ldr	r3, [r3, #0]
 8003204:	60bb      	str	r3, [r7, #8]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 8003206:	68bb      	ldr	r3, [r7, #8]
 8003208:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 800320c:	60bb      	str	r3, [r7, #8]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 800320e:	68fb      	ldr	r3, [r7, #12]
 8003210:	f003 0302 	and.w	r3, r3, #2
 8003214:	2b02      	cmp	r3, #2
 8003216:	d113      	bne.n	8003240 <HCD_Port_IRQHandler+0x60>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 8003218:	68fb      	ldr	r3, [r7, #12]
 800321a:	f003 0301 	and.w	r3, r3, #1
 800321e:	2b01      	cmp	r3, #1
 8003220:	d10a      	bne.n	8003238 <HCD_Port_IRQHandler+0x58>
    {
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT);
 8003222:	687b      	ldr	r3, [r7, #4]
 8003224:	681b      	ldr	r3, [r3, #0]
 8003226:	699a      	ldr	r2, [r3, #24]
 8003228:	687b      	ldr	r3, [r7, #4]
 800322a:	681b      	ldr	r3, [r3, #0]
 800322c:	f022 5200 	bic.w	r2, r2, #536870912	; 0x20000000
 8003230:	619a      	str	r2, [r3, #24]

#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
 8003232:	6878      	ldr	r0, [r7, #4]
 8003234:	f7fe ffe6 	bl	8002204 <HAL_HCD_Connect_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup  |= USB_OTG_HPRT_PCDET;
 8003238:	68bb      	ldr	r3, [r7, #8]
 800323a:	f043 0302 	orr.w	r3, r3, #2
 800323e:	60bb      	str	r3, [r7, #8]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8003240:	68fb      	ldr	r3, [r7, #12]
 8003242:	f003 0308 	and.w	r3, r3, #8
 8003246:	2b08      	cmp	r3, #8
 8003248:	d147      	bne.n	80032da <HCD_Port_IRQHandler+0xfa>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 800324a:	68bb      	ldr	r3, [r7, #8]
 800324c:	f043 0308 	orr.w	r3, r3, #8
 8003250:	60bb      	str	r3, [r7, #8]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 8003252:	68fb      	ldr	r3, [r7, #12]
 8003254:	f003 0304 	and.w	r3, r3, #4
 8003258:	2b04      	cmp	r3, #4
 800325a:	d129      	bne.n	80032b0 <HCD_Port_IRQHandler+0xd0>
    {
      if (hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
 800325c:	687b      	ldr	r3, [r7, #4]
 800325e:	699b      	ldr	r3, [r3, #24]
 8003260:	2b02      	cmp	r3, #2
 8003262:	d113      	bne.n	800328c <HCD_Port_IRQHandler+0xac>
      {
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8003264:	68fb      	ldr	r3, [r7, #12]
 8003266:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 800326a:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 800326e:	d106      	bne.n	800327e <HCD_Port_IRQHandler+0x9e>
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_6_MHZ);
 8003270:	687b      	ldr	r3, [r7, #4]
 8003272:	681b      	ldr	r3, [r3, #0]
 8003274:	2102      	movs	r1, #2
 8003276:	4618      	mov	r0, r3
 8003278:	f004 ff64 	bl	8008144 <USB_InitFSLSPClkSel>
 800327c:	e011      	b.n	80032a2 <HCD_Port_IRQHandler+0xc2>
        }
        else
        {
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 800327e:	687b      	ldr	r3, [r7, #4]
 8003280:	681b      	ldr	r3, [r3, #0]
 8003282:	2101      	movs	r1, #1
 8003284:	4618      	mov	r0, r3
 8003286:	f004 ff5d 	bl	8008144 <USB_InitFSLSPClkSel>
 800328a:	e00a      	b.n	80032a2 <HCD_Port_IRQHandler+0xc2>
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 800328c:	687b      	ldr	r3, [r7, #4]
 800328e:	68db      	ldr	r3, [r3, #12]
 8003290:	2b03      	cmp	r3, #3
 8003292:	d106      	bne.n	80032a2 <HCD_Port_IRQHandler+0xc2>
        {
          USBx_HOST->HFIR = 60000U;
 8003294:	693b      	ldr	r3, [r7, #16]
 8003296:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800329a:	461a      	mov	r2, r3
 800329c:	f64e 2360 	movw	r3, #60000	; 0xea60
 80032a0:	6053      	str	r3, [r2, #4]
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 80032a2:	6878      	ldr	r0, [r7, #4]
 80032a4:	f7fe ffc2 	bl	800222c <HAL_HCD_PortEnabled_Callback>
      HAL_HCD_Connect_Callback(hhcd);
 80032a8:	6878      	ldr	r0, [r7, #4]
 80032aa:	f7fe ffab 	bl	8002204 <HAL_HCD_Connect_Callback>
 80032ae:	e014      	b.n	80032da <HCD_Port_IRQHandler+0xfa>
    else
    {
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortDisabledCallback(hhcd);
#else
      HAL_HCD_PortDisabled_Callback(hhcd);
 80032b0:	6878      	ldr	r0, [r7, #4]
 80032b2:	f7fe ffc5 	bl	8002240 <HAL_HCD_PortDisabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */

      /* Cleanup HPRT */
      USBx_HPRT0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 80032b6:	693b      	ldr	r3, [r7, #16]
 80032b8:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80032bc:	681b      	ldr	r3, [r3, #0]
 80032be:	693a      	ldr	r2, [r7, #16]
 80032c0:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 80032c4:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 80032c8:	6013      	str	r3, [r2, #0]
                      USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_DISCINT);
 80032ca:	687b      	ldr	r3, [r7, #4]
 80032cc:	681b      	ldr	r3, [r3, #0]
 80032ce:	699a      	ldr	r2, [r3, #24]
 80032d0:	687b      	ldr	r3, [r7, #4]
 80032d2:	681b      	ldr	r3, [r3, #0]
 80032d4:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80032d8:	619a      	str	r2, [r3, #24]
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 80032da:	68fb      	ldr	r3, [r7, #12]
 80032dc:	f003 0320 	and.w	r3, r3, #32
 80032e0:	2b20      	cmp	r3, #32
 80032e2:	d103      	bne.n	80032ec <HCD_Port_IRQHandler+0x10c>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 80032e4:	68bb      	ldr	r3, [r7, #8]
 80032e6:	f043 0320 	orr.w	r3, r3, #32
 80032ea:	60bb      	str	r3, [r7, #8]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 80032ec:	693b      	ldr	r3, [r7, #16]
 80032ee:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80032f2:	461a      	mov	r2, r3
 80032f4:	68bb      	ldr	r3, [r7, #8]
 80032f6:	6013      	str	r3, [r2, #0]
}
 80032f8:	bf00      	nop
 80032fa:	3718      	adds	r7, #24
 80032fc:	46bd      	mov	sp, r7
 80032fe:	bd80      	pop	{r7, pc}

08003300 <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 8003300:	b580      	push	{r7, lr}
 8003302:	b082      	sub	sp, #8
 8003304:	af00      	add	r7, sp, #0
 8003306:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8003308:	687b      	ldr	r3, [r7, #4]
 800330a:	2b00      	cmp	r3, #0
 800330c:	d101      	bne.n	8003312 <HAL_I2C_Init+0x12>
  {
    return HAL_ERROR;
 800330e:	2301      	movs	r3, #1
 8003310:	e07f      	b.n	8003412 <HAL_I2C_Init+0x112>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if (hi2c->State == HAL_I2C_STATE_RESET)
 8003312:	687b      	ldr	r3, [r7, #4]
 8003314:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8003318:	b2db      	uxtb	r3, r3
 800331a:	2b00      	cmp	r3, #0
 800331c:	d106      	bne.n	800332c <HAL_I2C_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800331e:	687b      	ldr	r3, [r7, #4]
 8003320:	2200      	movs	r2, #0
 8003322:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    hi2c->MspInitCallback(hi2c);
#else
    /* Init the low level hardware : GPIO, CLOCK, CORTEX...etc */
    HAL_I2C_MspInit(hi2c);
 8003326:	6878      	ldr	r0, [r7, #4]
 8003328:	f000 f8a9 	bl	800347e <HAL_I2C_MspInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 800332c:	687b      	ldr	r3, [r7, #4]
 800332e:	2224      	movs	r2, #36	; 0x24
 8003330:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 8003334:	687b      	ldr	r3, [r7, #4]
 8003336:	681b      	ldr	r3, [r3, #0]
 8003338:	681a      	ldr	r2, [r3, #0]
 800333a:	687b      	ldr	r3, [r7, #4]
 800333c:	681b      	ldr	r3, [r3, #0]
 800333e:	f022 0201 	bic.w	r2, r2, #1
 8003342:	601a      	str	r2, [r3, #0]

  /*---------------------------- I2Cx TIMINGR Configuration ------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8003344:	687b      	ldr	r3, [r7, #4]
 8003346:	685a      	ldr	r2, [r3, #4]
 8003348:	687b      	ldr	r3, [r7, #4]
 800334a:	681b      	ldr	r3, [r3, #0]
 800334c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8003350:	611a      	str	r2, [r3, #16]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Disable Own Address1 before set the Own Address1 configuration */
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8003352:	687b      	ldr	r3, [r7, #4]
 8003354:	681b      	ldr	r3, [r3, #0]
 8003356:	689a      	ldr	r2, [r3, #8]
 8003358:	687b      	ldr	r3, [r7, #4]
 800335a:	681b      	ldr	r3, [r3, #0]
 800335c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003360:	609a      	str	r2, [r3, #8]

  /* Configure I2Cx: Own Address1 and ack own address1 mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8003362:	687b      	ldr	r3, [r7, #4]
 8003364:	68db      	ldr	r3, [r3, #12]
 8003366:	2b01      	cmp	r3, #1
 8003368:	d107      	bne.n	800337a <HAL_I2C_Init+0x7a>
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 800336a:	687b      	ldr	r3, [r7, #4]
 800336c:	689a      	ldr	r2, [r3, #8]
 800336e:	687b      	ldr	r3, [r7, #4]
 8003370:	681b      	ldr	r3, [r3, #0]
 8003372:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8003376:	609a      	str	r2, [r3, #8]
 8003378:	e006      	b.n	8003388 <HAL_I2C_Init+0x88>
  }
  else /* I2C_ADDRESSINGMODE_10BIT */
  {
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 800337a:	687b      	ldr	r3, [r7, #4]
 800337c:	689a      	ldr	r2, [r3, #8]
 800337e:	687b      	ldr	r3, [r7, #4]
 8003380:	681b      	ldr	r3, [r3, #0]
 8003382:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
 8003386:	609a      	str	r2, [r3, #8]
  }

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Addressing Master mode */
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8003388:	687b      	ldr	r3, [r7, #4]
 800338a:	68db      	ldr	r3, [r3, #12]
 800338c:	2b02      	cmp	r3, #2
 800338e:	d104      	bne.n	800339a <HAL_I2C_Init+0x9a>
  {
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8003390:	687b      	ldr	r3, [r7, #4]
 8003392:	681b      	ldr	r3, [r3, #0]
 8003394:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8003398:	605a      	str	r2, [r3, #4]
  }
  /* Enable the AUTOEND by default, and enable NACK (should be disable only during Slave process */
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800339a:	687b      	ldr	r3, [r7, #4]
 800339c:	681b      	ldr	r3, [r3, #0]
 800339e:	6859      	ldr	r1, [r3, #4]
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	681a      	ldr	r2, [r3, #0]
 80033a4:	4b1d      	ldr	r3, [pc, #116]	; (800341c <HAL_I2C_Init+0x11c>)
 80033a6:	430b      	orrs	r3, r1
 80033a8:	6053      	str	r3, [r2, #4]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Disable Own Address2 before set the Own Address2 configuration */
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80033aa:	687b      	ldr	r3, [r7, #4]
 80033ac:	681b      	ldr	r3, [r3, #0]
 80033ae:	68da      	ldr	r2, [r3, #12]
 80033b0:	687b      	ldr	r3, [r7, #4]
 80033b2:	681b      	ldr	r3, [r3, #0]
 80033b4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80033b8:	60da      	str	r2, [r3, #12]

  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80033ba:	687b      	ldr	r3, [r7, #4]
 80033bc:	691a      	ldr	r2, [r3, #16]
 80033be:	687b      	ldr	r3, [r7, #4]
 80033c0:	695b      	ldr	r3, [r3, #20]
 80033c2:	ea42 0103 	orr.w	r1, r2, r3
 80033c6:	687b      	ldr	r3, [r7, #4]
 80033c8:	699b      	ldr	r3, [r3, #24]
 80033ca:	021a      	lsls	r2, r3, #8
 80033cc:	687b      	ldr	r3, [r7, #4]
 80033ce:	681b      	ldr	r3, [r3, #0]
 80033d0:	430a      	orrs	r2, r1
 80033d2:	60da      	str	r2, [r3, #12]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80033d4:	687b      	ldr	r3, [r7, #4]
 80033d6:	69d9      	ldr	r1, [r3, #28]
 80033d8:	687b      	ldr	r3, [r7, #4]
 80033da:	6a1a      	ldr	r2, [r3, #32]
 80033dc:	687b      	ldr	r3, [r7, #4]
 80033de:	681b      	ldr	r3, [r3, #0]
 80033e0:	430a      	orrs	r2, r1
 80033e2:	601a      	str	r2, [r3, #0]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 80033e4:	687b      	ldr	r3, [r7, #4]
 80033e6:	681b      	ldr	r3, [r3, #0]
 80033e8:	681a      	ldr	r2, [r3, #0]
 80033ea:	687b      	ldr	r3, [r7, #4]
 80033ec:	681b      	ldr	r3, [r3, #0]
 80033ee:	f042 0201 	orr.w	r2, r2, #1
 80033f2:	601a      	str	r2, [r3, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80033f4:	687b      	ldr	r3, [r7, #4]
 80033f6:	2200      	movs	r2, #0
 80033f8:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 80033fa:	687b      	ldr	r3, [r7, #4]
 80033fc:	2220      	movs	r2, #32
 80033fe:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8003402:	687b      	ldr	r3, [r7, #4]
 8003404:	2200      	movs	r2, #0
 8003406:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8003408:	687b      	ldr	r3, [r7, #4]
 800340a:	2200      	movs	r2, #0
 800340c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  return HAL_OK;
 8003410:	2300      	movs	r3, #0
}
 8003412:	4618      	mov	r0, r3
 8003414:	3708      	adds	r7, #8
 8003416:	46bd      	mov	sp, r7
 8003418:	bd80      	pop	{r7, pc}
 800341a:	bf00      	nop
 800341c:	02008000 	.word	0x02008000

08003420 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 8003420:	b580      	push	{r7, lr}
 8003422:	b082      	sub	sp, #8
 8003424:	af00      	add	r7, sp, #0
 8003426:	6078      	str	r0, [r7, #4]
  /* Check the I2C handle allocation */
  if (hi2c == NULL)
 8003428:	687b      	ldr	r3, [r7, #4]
 800342a:	2b00      	cmp	r3, #0
 800342c:	d101      	bne.n	8003432 <HAL_I2C_DeInit+0x12>
  {
    return HAL_ERROR;
 800342e:	2301      	movs	r3, #1
 8003430:	e021      	b.n	8003476 <HAL_I2C_DeInit+0x56>
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 8003432:	687b      	ldr	r3, [r7, #4]
 8003434:	2224      	movs	r2, #36	; 0x24
 8003436:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800343a:	687b      	ldr	r3, [r7, #4]
 800343c:	681b      	ldr	r3, [r3, #0]
 800343e:	681a      	ldr	r2, [r3, #0]
 8003440:	687b      	ldr	r3, [r7, #4]
 8003442:	681b      	ldr	r3, [r3, #0]
 8003444:	f022 0201 	bic.w	r2, r2, #1
 8003448:	601a      	str	r2, [r3, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  hi2c->MspDeInitCallback(hi2c);
#else
  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 800344a:	6878      	ldr	r0, [r7, #4]
 800344c:	f000 f821 	bl	8003492 <HAL_I2C_MspDeInit>
#endif /* USE_HAL_I2C_REGISTER_CALLBACKS */

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003450:	687b      	ldr	r3, [r7, #4]
 8003452:	2200      	movs	r2, #0
 8003454:	645a      	str	r2, [r3, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_RESET;
 8003456:	687b      	ldr	r3, [r7, #4]
 8003458:	2200      	movs	r2, #0
 800345a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 800345e:	687b      	ldr	r3, [r7, #4]
 8003460:	2200      	movs	r2, #0
 8003462:	631a      	str	r2, [r3, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8003464:	687b      	ldr	r3, [r7, #4]
 8003466:	2200      	movs	r2, #0
 8003468:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 800346c:	687b      	ldr	r3, [r7, #4]
 800346e:	2200      	movs	r2, #0
 8003470:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

  return HAL_OK;
 8003474:	2300      	movs	r3, #0
}
 8003476:	4618      	mov	r0, r3
 8003478:	3708      	adds	r7, #8
 800347a:	46bd      	mov	sp, r7
 800347c:	bd80      	pop	{r7, pc}

0800347e <HAL_I2C_MspInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
{
 800347e:	b480      	push	{r7}
 8003480:	b083      	sub	sp, #12
 8003482:	af00      	add	r7, sp, #0
 8003484:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspInit could be implemented in the user file
   */
}
 8003486:	bf00      	nop
 8003488:	370c      	adds	r7, #12
 800348a:	46bd      	mov	sp, r7
 800348c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003490:	4770      	bx	lr

08003492 <HAL_I2C_MspDeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval None
  */
__weak void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c)
{
 8003492:	b480      	push	{r7}
 8003494:	b083      	sub	sp, #12
 8003496:	af00      	add	r7, sp, #0
 8003498:	6078      	str	r0, [r7, #4]
  UNUSED(hi2c);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_I2C_MspDeInit could be implemented in the user file
   */
}
 800349a:	bf00      	nop
 800349c:	370c      	adds	r7, #12
 800349e:	46bd      	mov	sp, r7
 80034a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80034a4:	4770      	bx	lr
	...

080034a8 <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80034a8:	b580      	push	{r7, lr}
 80034aa:	b088      	sub	sp, #32
 80034ac:	af02      	add	r7, sp, #8
 80034ae:	60f8      	str	r0, [r7, #12]
 80034b0:	4608      	mov	r0, r1
 80034b2:	4611      	mov	r1, r2
 80034b4:	461a      	mov	r2, r3
 80034b6:	4603      	mov	r3, r0
 80034b8:	817b      	strh	r3, [r7, #10]
 80034ba:	460b      	mov	r3, r1
 80034bc:	813b      	strh	r3, [r7, #8]
 80034be:	4613      	mov	r3, r2
 80034c0:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80034c2:	68fb      	ldr	r3, [r7, #12]
 80034c4:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80034c8:	b2db      	uxtb	r3, r3
 80034ca:	2b20      	cmp	r3, #32
 80034cc:	f040 80f9 	bne.w	80036c2 <HAL_I2C_Mem_Write+0x21a>
  {
    if ((pData == NULL) || (Size == 0U))
 80034d0:	6a3b      	ldr	r3, [r7, #32]
 80034d2:	2b00      	cmp	r3, #0
 80034d4:	d002      	beq.n	80034dc <HAL_I2C_Mem_Write+0x34>
 80034d6:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80034d8:	2b00      	cmp	r3, #0
 80034da:	d105      	bne.n	80034e8 <HAL_I2C_Mem_Write+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80034dc:	68fb      	ldr	r3, [r7, #12]
 80034de:	f44f 7200 	mov.w	r2, #512	; 0x200
 80034e2:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 80034e4:	2301      	movs	r3, #1
 80034e6:	e0ed      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80034e8:	68fb      	ldr	r3, [r7, #12]
 80034ea:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 80034ee:	2b01      	cmp	r3, #1
 80034f0:	d101      	bne.n	80034f6 <HAL_I2C_Mem_Write+0x4e>
 80034f2:	2302      	movs	r3, #2
 80034f4:	e0e6      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
 80034f6:	68fb      	ldr	r3, [r7, #12]
 80034f8:	2201      	movs	r2, #1
 80034fa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 80034fe:	f7fd f891 	bl	8000624 <HAL_GetTick>
 8003502:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8003504:	697b      	ldr	r3, [r7, #20]
 8003506:	9300      	str	r3, [sp, #0]
 8003508:	2319      	movs	r3, #25
 800350a:	2201      	movs	r2, #1
 800350c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003510:	68f8      	ldr	r0, [r7, #12]
 8003512:	f000 fad1 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 8003516:	4603      	mov	r3, r0
 8003518:	2b00      	cmp	r3, #0
 800351a:	d001      	beq.n	8003520 <HAL_I2C_Mem_Write+0x78>
    {
      return HAL_ERROR;
 800351c:	2301      	movs	r3, #1
 800351e:	e0d1      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8003520:	68fb      	ldr	r3, [r7, #12]
 8003522:	2221      	movs	r2, #33	; 0x21
 8003524:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8003528:	68fb      	ldr	r3, [r7, #12]
 800352a:	2240      	movs	r2, #64	; 0x40
 800352c:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003530:	68fb      	ldr	r3, [r7, #12]
 8003532:	2200      	movs	r2, #0
 8003534:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 8003536:	68fb      	ldr	r3, [r7, #12]
 8003538:	6a3a      	ldr	r2, [r7, #32]
 800353a:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 800353c:	68fb      	ldr	r3, [r7, #12]
 800353e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8003540:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 8003542:	68fb      	ldr	r3, [r7, #12]
 8003544:	2200      	movs	r2, #0
 8003546:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8003548:	88f8      	ldrh	r0, [r7, #6]
 800354a:	893a      	ldrh	r2, [r7, #8]
 800354c:	8979      	ldrh	r1, [r7, #10]
 800354e:	697b      	ldr	r3, [r7, #20]
 8003550:	9301      	str	r3, [sp, #4]
 8003552:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003554:	9300      	str	r3, [sp, #0]
 8003556:	4603      	mov	r3, r0
 8003558:	68f8      	ldr	r0, [r7, #12]
 800355a:	f000 f9e1 	bl	8003920 <I2C_RequestMemoryWrite>
 800355e:	4603      	mov	r3, r0
 8003560:	2b00      	cmp	r3, #0
 8003562:	d005      	beq.n	8003570 <HAL_I2C_Mem_Write+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8003564:	68fb      	ldr	r3, [r7, #12]
 8003566:	2200      	movs	r2, #0
 8003568:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
 800356c:	2301      	movs	r3, #1
 800356e:	e0a9      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003570:	68fb      	ldr	r3, [r7, #12]
 8003572:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003574:	b29b      	uxth	r3, r3
 8003576:	2bff      	cmp	r3, #255	; 0xff
 8003578:	d90e      	bls.n	8003598 <HAL_I2C_Mem_Write+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800357a:	68fb      	ldr	r3, [r7, #12]
 800357c:	22ff      	movs	r2, #255	; 0xff
 800357e:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8003580:	68fb      	ldr	r3, [r7, #12]
 8003582:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8003584:	b2da      	uxtb	r2, r3
 8003586:	8979      	ldrh	r1, [r7, #10]
 8003588:	2300      	movs	r3, #0
 800358a:	9300      	str	r3, [sp, #0]
 800358c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003590:	68f8      	ldr	r0, [r7, #12]
 8003592:	f000 fbb3 	bl	8003cfc <I2C_TransferConfig>
 8003596:	e00f      	b.n	80035b8 <HAL_I2C_Mem_Write+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 8003598:	68fb      	ldr	r3, [r7, #12]
 800359a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800359c:	b29a      	uxth	r2, r3
 800359e:	68fb      	ldr	r3, [r7, #12]
 80035a0:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80035a2:	68fb      	ldr	r3, [r7, #12]
 80035a4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80035a6:	b2da      	uxtb	r2, r3
 80035a8:	8979      	ldrh	r1, [r7, #10]
 80035aa:	2300      	movs	r3, #0
 80035ac:	9300      	str	r3, [sp, #0]
 80035ae:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80035b2:	68f8      	ldr	r0, [r7, #12]
 80035b4:	f000 fba2 	bl	8003cfc <I2C_TransferConfig>
    }

    do
    {
      /* Wait until TXIS flag is set */
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80035b8:	697a      	ldr	r2, [r7, #20]
 80035ba:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80035bc:	68f8      	ldr	r0, [r7, #12]
 80035be:	f000 fabb 	bl	8003b38 <I2C_WaitOnTXISFlagUntilTimeout>
 80035c2:	4603      	mov	r3, r0
 80035c4:	2b00      	cmp	r3, #0
 80035c6:	d001      	beq.n	80035cc <HAL_I2C_Mem_Write+0x124>
      {
        return HAL_ERROR;
 80035c8:	2301      	movs	r3, #1
 80035ca:	e07b      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
      }

      /* Write data to TXDR */
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 80035cc:	68fb      	ldr	r3, [r7, #12]
 80035ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80035d0:	781a      	ldrb	r2, [r3, #0]
 80035d2:	68fb      	ldr	r3, [r7, #12]
 80035d4:	681b      	ldr	r3, [r3, #0]
 80035d6:	629a      	str	r2, [r3, #40]	; 0x28

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 80035d8:	68fb      	ldr	r3, [r7, #12]
 80035da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80035dc:	1c5a      	adds	r2, r3, #1
 80035de:	68fb      	ldr	r3, [r7, #12]
 80035e0:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferCount--;
 80035e2:	68fb      	ldr	r3, [r7, #12]
 80035e4:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80035e6:	b29b      	uxth	r3, r3
 80035e8:	3b01      	subs	r3, #1
 80035ea:	b29a      	uxth	r2, r3
 80035ec:	68fb      	ldr	r3, [r7, #12]
 80035ee:	855a      	strh	r2, [r3, #42]	; 0x2a
      hi2c->XferSize--;
 80035f0:	68fb      	ldr	r3, [r7, #12]
 80035f2:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80035f4:	3b01      	subs	r3, #1
 80035f6:	b29a      	uxth	r2, r3
 80035f8:	68fb      	ldr	r3, [r7, #12]
 80035fa:	851a      	strh	r2, [r3, #40]	; 0x28

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80035fc:	68fb      	ldr	r3, [r7, #12]
 80035fe:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003600:	b29b      	uxth	r3, r3
 8003602:	2b00      	cmp	r3, #0
 8003604:	d034      	beq.n	8003670 <HAL_I2C_Mem_Write+0x1c8>
 8003606:	68fb      	ldr	r3, [r7, #12]
 8003608:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800360a:	2b00      	cmp	r3, #0
 800360c:	d130      	bne.n	8003670 <HAL_I2C_Mem_Write+0x1c8>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800360e:	697b      	ldr	r3, [r7, #20]
 8003610:	9300      	str	r3, [sp, #0]
 8003612:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003614:	2200      	movs	r2, #0
 8003616:	2180      	movs	r1, #128	; 0x80
 8003618:	68f8      	ldr	r0, [r7, #12]
 800361a:	f000 fa4d 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 800361e:	4603      	mov	r3, r0
 8003620:	2b00      	cmp	r3, #0
 8003622:	d001      	beq.n	8003628 <HAL_I2C_Mem_Write+0x180>
        {
          return HAL_ERROR;
 8003624:	2301      	movs	r3, #1
 8003626:	e04d      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003628:	68fb      	ldr	r3, [r7, #12]
 800362a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800362c:	b29b      	uxth	r3, r3
 800362e:	2bff      	cmp	r3, #255	; 0xff
 8003630:	d90e      	bls.n	8003650 <HAL_I2C_Mem_Write+0x1a8>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8003632:	68fb      	ldr	r3, [r7, #12]
 8003634:	22ff      	movs	r2, #255	; 0xff
 8003636:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8003638:	68fb      	ldr	r3, [r7, #12]
 800363a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800363c:	b2da      	uxtb	r2, r3
 800363e:	8979      	ldrh	r1, [r7, #10]
 8003640:	2300      	movs	r3, #0
 8003642:	9300      	str	r3, [sp, #0]
 8003644:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003648:	68f8      	ldr	r0, [r7, #12]
 800364a:	f000 fb57 	bl	8003cfc <I2C_TransferConfig>
 800364e:	e00f      	b.n	8003670 <HAL_I2C_Mem_Write+0x1c8>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8003650:	68fb      	ldr	r3, [r7, #12]
 8003652:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003654:	b29a      	uxth	r2, r3
 8003656:	68fb      	ldr	r3, [r7, #12]
 8003658:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800365a:	68fb      	ldr	r3, [r7, #12]
 800365c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800365e:	b2da      	uxtb	r2, r3
 8003660:	8979      	ldrh	r1, [r7, #10]
 8003662:	2300      	movs	r3, #0
 8003664:	9300      	str	r3, [sp, #0]
 8003666:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800366a:	68f8      	ldr	r0, [r7, #12]
 800366c:	f000 fb46 	bl	8003cfc <I2C_TransferConfig>
        }
      }

    }
    while (hi2c->XferCount > 0U);
 8003670:	68fb      	ldr	r3, [r7, #12]
 8003672:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003674:	b29b      	uxth	r3, r3
 8003676:	2b00      	cmp	r3, #0
 8003678:	d19e      	bne.n	80035b8 <HAL_I2C_Mem_Write+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800367a:	697a      	ldr	r2, [r7, #20]
 800367c:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800367e:	68f8      	ldr	r0, [r7, #12]
 8003680:	f000 fa9a 	bl	8003bb8 <I2C_WaitOnSTOPFlagUntilTimeout>
 8003684:	4603      	mov	r3, r0
 8003686:	2b00      	cmp	r3, #0
 8003688:	d001      	beq.n	800368e <HAL_I2C_Mem_Write+0x1e6>
    {
      return HAL_ERROR;
 800368a:	2301      	movs	r3, #1
 800368c:	e01a      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800368e:	68fb      	ldr	r3, [r7, #12]
 8003690:	681b      	ldr	r3, [r3, #0]
 8003692:	2220      	movs	r2, #32
 8003694:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003696:	68fb      	ldr	r3, [r7, #12]
 8003698:	681b      	ldr	r3, [r3, #0]
 800369a:	6859      	ldr	r1, [r3, #4]
 800369c:	68fb      	ldr	r3, [r7, #12]
 800369e:	681a      	ldr	r2, [r3, #0]
 80036a0:	4b0a      	ldr	r3, [pc, #40]	; (80036cc <HAL_I2C_Mem_Write+0x224>)
 80036a2:	400b      	ands	r3, r1
 80036a4:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 80036a6:	68fb      	ldr	r3, [r7, #12]
 80036a8:	2220      	movs	r2, #32
 80036aa:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80036ae:	68fb      	ldr	r3, [r7, #12]
 80036b0:	2200      	movs	r2, #0
 80036b2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80036b6:	68fb      	ldr	r3, [r7, #12]
 80036b8:	2200      	movs	r2, #0
 80036ba:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 80036be:	2300      	movs	r3, #0
 80036c0:	e000      	b.n	80036c4 <HAL_I2C_Mem_Write+0x21c>
  }
  else
  {
    return HAL_BUSY;
 80036c2:	2302      	movs	r3, #2
  }
}
 80036c4:	4618      	mov	r0, r3
 80036c6:	3718      	adds	r7, #24
 80036c8:	46bd      	mov	sp, r7
 80036ca:	bd80      	pop	{r7, pc}
 80036cc:	fe00e800 	.word	0xfe00e800

080036d0 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80036d0:	b580      	push	{r7, lr}
 80036d2:	b088      	sub	sp, #32
 80036d4:	af02      	add	r7, sp, #8
 80036d6:	60f8      	str	r0, [r7, #12]
 80036d8:	4608      	mov	r0, r1
 80036da:	4611      	mov	r1, r2
 80036dc:	461a      	mov	r2, r3
 80036de:	4603      	mov	r3, r0
 80036e0:	817b      	strh	r3, [r7, #10]
 80036e2:	460b      	mov	r3, r1
 80036e4:	813b      	strh	r3, [r7, #8]
 80036e6:	4613      	mov	r3, r2
 80036e8:	80fb      	strh	r3, [r7, #6]
  uint32_t tickstart;

  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80036ea:	68fb      	ldr	r3, [r7, #12]
 80036ec:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80036f0:	b2db      	uxtb	r3, r3
 80036f2:	2b20      	cmp	r3, #32
 80036f4:	f040 80fd 	bne.w	80038f2 <HAL_I2C_Mem_Read+0x222>
  {
    if ((pData == NULL) || (Size == 0U))
 80036f8:	6a3b      	ldr	r3, [r7, #32]
 80036fa:	2b00      	cmp	r3, #0
 80036fc:	d002      	beq.n	8003704 <HAL_I2C_Mem_Read+0x34>
 80036fe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8003700:	2b00      	cmp	r3, #0
 8003702:	d105      	bne.n	8003710 <HAL_I2C_Mem_Read+0x40>
    {
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8003704:	68fb      	ldr	r3, [r7, #12]
 8003706:	f44f 7200 	mov.w	r2, #512	; 0x200
 800370a:	645a      	str	r2, [r3, #68]	; 0x44
      return  HAL_ERROR;
 800370c:	2301      	movs	r3, #1
 800370e:	e0f1      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 8003710:	68fb      	ldr	r3, [r7, #12]
 8003712:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8003716:	2b01      	cmp	r3, #1
 8003718:	d101      	bne.n	800371e <HAL_I2C_Mem_Read+0x4e>
 800371a:	2302      	movs	r3, #2
 800371c:	e0ea      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
 800371e:	68fb      	ldr	r3, [r7, #12]
 8003720:	2201      	movs	r2, #1
 8003722:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    /* Init tickstart for timeout management*/
    tickstart = HAL_GetTick();
 8003726:	f7fc ff7d 	bl	8000624 <HAL_GetTick>
 800372a:	6178      	str	r0, [r7, #20]

    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800372c:	697b      	ldr	r3, [r7, #20]
 800372e:	9300      	str	r3, [sp, #0]
 8003730:	2319      	movs	r3, #25
 8003732:	2201      	movs	r2, #1
 8003734:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8003738:	68f8      	ldr	r0, [r7, #12]
 800373a:	f000 f9bd 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 800373e:	4603      	mov	r3, r0
 8003740:	2b00      	cmp	r3, #0
 8003742:	d001      	beq.n	8003748 <HAL_I2C_Mem_Read+0x78>
    {
      return HAL_ERROR;
 8003744:	2301      	movs	r3, #1
 8003746:	e0d5      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
    }

    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8003748:	68fb      	ldr	r3, [r7, #12]
 800374a:	2222      	movs	r2, #34	; 0x22
 800374c:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 8003750:	68fb      	ldr	r3, [r7, #12]
 8003752:	2240      	movs	r2, #64	; 0x40
 8003754:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8003758:	68fb      	ldr	r3, [r7, #12]
 800375a:	2200      	movs	r2, #0
 800375c:	645a      	str	r2, [r3, #68]	; 0x44

    /* Prepare transfer parameters */
    hi2c->pBuffPtr  = pData;
 800375e:	68fb      	ldr	r3, [r7, #12]
 8003760:	6a3a      	ldr	r2, [r7, #32]
 8003762:	625a      	str	r2, [r3, #36]	; 0x24
    hi2c->XferCount = Size;
 8003764:	68fb      	ldr	r3, [r7, #12]
 8003766:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8003768:	855a      	strh	r2, [r3, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 800376a:	68fb      	ldr	r3, [r7, #12]
 800376c:	2200      	movs	r2, #0
 800376e:	635a      	str	r2, [r3, #52]	; 0x34

    /* Send Slave Address and Memory Address */
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8003770:	88f8      	ldrh	r0, [r7, #6]
 8003772:	893a      	ldrh	r2, [r7, #8]
 8003774:	8979      	ldrh	r1, [r7, #10]
 8003776:	697b      	ldr	r3, [r7, #20]
 8003778:	9301      	str	r3, [sp, #4]
 800377a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800377c:	9300      	str	r3, [sp, #0]
 800377e:	4603      	mov	r3, r0
 8003780:	68f8      	ldr	r0, [r7, #12]
 8003782:	f000 f921 	bl	80039c8 <I2C_RequestMemoryRead>
 8003786:	4603      	mov	r3, r0
 8003788:	2b00      	cmp	r3, #0
 800378a:	d005      	beq.n	8003798 <HAL_I2C_Mem_Read+0xc8>
    {
      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 800378c:	68fb      	ldr	r3, [r7, #12]
 800378e:	2200      	movs	r2, #0
 8003790:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
      return HAL_ERROR;
 8003794:	2301      	movs	r3, #1
 8003796:	e0ad      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
    }

    /* Send Slave Address */
    /* Set NBYTES to write and reload if hi2c->XferCount > MAX_NBYTE_SIZE and generate RESTART */
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003798:	68fb      	ldr	r3, [r7, #12]
 800379a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800379c:	b29b      	uxth	r3, r3
 800379e:	2bff      	cmp	r3, #255	; 0xff
 80037a0:	d90e      	bls.n	80037c0 <HAL_I2C_Mem_Read+0xf0>
    {
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80037a2:	68fb      	ldr	r3, [r7, #12]
 80037a4:	22ff      	movs	r2, #255	; 0xff
 80037a6:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80037a8:	68fb      	ldr	r3, [r7, #12]
 80037aa:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80037ac:	b2da      	uxtb	r2, r3
 80037ae:	8979      	ldrh	r1, [r7, #10]
 80037b0:	4b52      	ldr	r3, [pc, #328]	; (80038fc <HAL_I2C_Mem_Read+0x22c>)
 80037b2:	9300      	str	r3, [sp, #0]
 80037b4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80037b8:	68f8      	ldr	r0, [r7, #12]
 80037ba:	f000 fa9f 	bl	8003cfc <I2C_TransferConfig>
 80037be:	e00f      	b.n	80037e0 <HAL_I2C_Mem_Read+0x110>
    }
    else
    {
      hi2c->XferSize = hi2c->XferCount;
 80037c0:	68fb      	ldr	r3, [r7, #12]
 80037c2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80037c4:	b29a      	uxth	r2, r3
 80037c6:	68fb      	ldr	r3, [r7, #12]
 80037c8:	851a      	strh	r2, [r3, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80037ca:	68fb      	ldr	r3, [r7, #12]
 80037cc:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 80037ce:	b2da      	uxtb	r2, r3
 80037d0:	8979      	ldrh	r1, [r7, #10]
 80037d2:	4b4a      	ldr	r3, [pc, #296]	; (80038fc <HAL_I2C_Mem_Read+0x22c>)
 80037d4:	9300      	str	r3, [sp, #0]
 80037d6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80037da:	68f8      	ldr	r0, [r7, #12]
 80037dc:	f000 fa8e 	bl	8003cfc <I2C_TransferConfig>
    }

    do
    {
      /* Wait until RXNE flag is set */
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 80037e0:	697b      	ldr	r3, [r7, #20]
 80037e2:	9300      	str	r3, [sp, #0]
 80037e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80037e6:	2200      	movs	r2, #0
 80037e8:	2104      	movs	r1, #4
 80037ea:	68f8      	ldr	r0, [r7, #12]
 80037ec:	f000 f964 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 80037f0:	4603      	mov	r3, r0
 80037f2:	2b00      	cmp	r3, #0
 80037f4:	d001      	beq.n	80037fa <HAL_I2C_Mem_Read+0x12a>
      {
        return HAL_ERROR;
 80037f6:	2301      	movs	r3, #1
 80037f8:	e07c      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
      }

      /* Read data from RXDR */
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80037fa:	68fb      	ldr	r3, [r7, #12]
 80037fc:	681b      	ldr	r3, [r3, #0]
 80037fe:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003800:	68fb      	ldr	r3, [r7, #12]
 8003802:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003804:	b2d2      	uxtb	r2, r2
 8003806:	701a      	strb	r2, [r3, #0]

      /* Increment Buffer pointer */
      hi2c->pBuffPtr++;
 8003808:	68fb      	ldr	r3, [r7, #12]
 800380a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800380c:	1c5a      	adds	r2, r3, #1
 800380e:	68fb      	ldr	r3, [r7, #12]
 8003810:	625a      	str	r2, [r3, #36]	; 0x24

      hi2c->XferSize--;
 8003812:	68fb      	ldr	r3, [r7, #12]
 8003814:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 8003816:	3b01      	subs	r3, #1
 8003818:	b29a      	uxth	r2, r3
 800381a:	68fb      	ldr	r3, [r7, #12]
 800381c:	851a      	strh	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 800381e:	68fb      	ldr	r3, [r7, #12]
 8003820:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003822:	b29b      	uxth	r3, r3
 8003824:	3b01      	subs	r3, #1
 8003826:	b29a      	uxth	r2, r3
 8003828:	68fb      	ldr	r3, [r7, #12]
 800382a:	855a      	strh	r2, [r3, #42]	; 0x2a

      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800382c:	68fb      	ldr	r3, [r7, #12]
 800382e:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003830:	b29b      	uxth	r3, r3
 8003832:	2b00      	cmp	r3, #0
 8003834:	d034      	beq.n	80038a0 <HAL_I2C_Mem_Read+0x1d0>
 8003836:	68fb      	ldr	r3, [r7, #12]
 8003838:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800383a:	2b00      	cmp	r3, #0
 800383c:	d130      	bne.n	80038a0 <HAL_I2C_Mem_Read+0x1d0>
      {
        /* Wait until TCR flag is set */
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800383e:	697b      	ldr	r3, [r7, #20]
 8003840:	9300      	str	r3, [sp, #0]
 8003842:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8003844:	2200      	movs	r2, #0
 8003846:	2180      	movs	r1, #128	; 0x80
 8003848:	68f8      	ldr	r0, [r7, #12]
 800384a:	f000 f935 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 800384e:	4603      	mov	r3, r0
 8003850:	2b00      	cmp	r3, #0
 8003852:	d001      	beq.n	8003858 <HAL_I2C_Mem_Read+0x188>
        {
          return HAL_ERROR;
 8003854:	2301      	movs	r3, #1
 8003856:	e04d      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
        }

        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8003858:	68fb      	ldr	r3, [r7, #12]
 800385a:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 800385c:	b29b      	uxth	r3, r3
 800385e:	2bff      	cmp	r3, #255	; 0xff
 8003860:	d90e      	bls.n	8003880 <HAL_I2C_Mem_Read+0x1b0>
        {
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8003862:	68fb      	ldr	r3, [r7, #12]
 8003864:	22ff      	movs	r2, #255	; 0xff
 8003866:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t) hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8003868:	68fb      	ldr	r3, [r7, #12]
 800386a:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800386c:	b2da      	uxtb	r2, r3
 800386e:	8979      	ldrh	r1, [r7, #10]
 8003870:	2300      	movs	r3, #0
 8003872:	9300      	str	r3, [sp, #0]
 8003874:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003878:	68f8      	ldr	r0, [r7, #12]
 800387a:	f000 fa3f 	bl	8003cfc <I2C_TransferConfig>
 800387e:	e00f      	b.n	80038a0 <HAL_I2C_Mem_Read+0x1d0>
        }
        else
        {
          hi2c->XferSize = hi2c->XferCount;
 8003880:	68fb      	ldr	r3, [r7, #12]
 8003882:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 8003884:	b29a      	uxth	r2, r3
 8003886:	68fb      	ldr	r3, [r7, #12]
 8003888:	851a      	strh	r2, [r3, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800388a:	68fb      	ldr	r3, [r7, #12]
 800388c:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
 800388e:	b2da      	uxtb	r2, r3
 8003890:	8979      	ldrh	r1, [r7, #10]
 8003892:	2300      	movs	r3, #0
 8003894:	9300      	str	r3, [sp, #0]
 8003896:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800389a:	68f8      	ldr	r0, [r7, #12]
 800389c:	f000 fa2e 	bl	8003cfc <I2C_TransferConfig>
        }
      }
    }
    while (hi2c->XferCount > 0U);
 80038a0:	68fb      	ldr	r3, [r7, #12]
 80038a2:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
 80038a4:	b29b      	uxth	r3, r3
 80038a6:	2b00      	cmp	r3, #0
 80038a8:	d19a      	bne.n	80037e0 <HAL_I2C_Mem_Read+0x110>

    /* No need to Check TC flag, with AUTOEND mode the stop is automatically generated */
    /* Wait until STOPF flag is reset */
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80038aa:	697a      	ldr	r2, [r7, #20]
 80038ac:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 80038ae:	68f8      	ldr	r0, [r7, #12]
 80038b0:	f000 f982 	bl	8003bb8 <I2C_WaitOnSTOPFlagUntilTimeout>
 80038b4:	4603      	mov	r3, r0
 80038b6:	2b00      	cmp	r3, #0
 80038b8:	d001      	beq.n	80038be <HAL_I2C_Mem_Read+0x1ee>
    {
      return HAL_ERROR;
 80038ba:	2301      	movs	r3, #1
 80038bc:	e01a      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
    }

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80038be:	68fb      	ldr	r3, [r7, #12]
 80038c0:	681b      	ldr	r3, [r3, #0]
 80038c2:	2220      	movs	r2, #32
 80038c4:	61da      	str	r2, [r3, #28]

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80038c6:	68fb      	ldr	r3, [r7, #12]
 80038c8:	681b      	ldr	r3, [r3, #0]
 80038ca:	6859      	ldr	r1, [r3, #4]
 80038cc:	68fb      	ldr	r3, [r7, #12]
 80038ce:	681a      	ldr	r2, [r3, #0]
 80038d0:	4b0b      	ldr	r3, [pc, #44]	; (8003900 <HAL_I2C_Mem_Read+0x230>)
 80038d2:	400b      	ands	r3, r1
 80038d4:	6053      	str	r3, [r2, #4]

    hi2c->State = HAL_I2C_STATE_READY;
 80038d6:	68fb      	ldr	r3, [r7, #12]
 80038d8:	2220      	movs	r2, #32
 80038da:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80038de:	68fb      	ldr	r3, [r7, #12]
 80038e0:	2200      	movs	r2, #0
 80038e2:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80038e6:	68fb      	ldr	r3, [r7, #12]
 80038e8:	2200      	movs	r2, #0
 80038ea:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_OK;
 80038ee:	2300      	movs	r3, #0
 80038f0:	e000      	b.n	80038f4 <HAL_I2C_Mem_Read+0x224>
  }
  else
  {
    return HAL_BUSY;
 80038f2:	2302      	movs	r3, #2
  }
}
 80038f4:	4618      	mov	r0, r3
 80038f6:	3718      	adds	r7, #24
 80038f8:	46bd      	mov	sp, r7
 80038fa:	bd80      	pop	{r7, pc}
 80038fc:	80002400 	.word	0x80002400
 8003900:	fe00e800 	.word	0xfe00e800

08003904 <HAL_I2C_GetState>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *                the configuration information for the specified I2C.
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
 8003904:	b480      	push	{r7}
 8003906:	b083      	sub	sp, #12
 8003908:	af00      	add	r7, sp, #0
 800390a:	6078      	str	r0, [r7, #4]
  /* Return I2C handle state */
  return hi2c->State;
 800390c:	687b      	ldr	r3, [r7, #4]
 800390e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8003912:	b2db      	uxtb	r3, r3
}
 8003914:	4618      	mov	r0, r3
 8003916:	370c      	adds	r7, #12
 8003918:	46bd      	mov	sp, r7
 800391a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800391e:	4770      	bx	lr

08003920 <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 8003920:	b580      	push	{r7, lr}
 8003922:	b086      	sub	sp, #24
 8003924:	af02      	add	r7, sp, #8
 8003926:	60f8      	str	r0, [r7, #12]
 8003928:	4608      	mov	r0, r1
 800392a:	4611      	mov	r1, r2
 800392c:	461a      	mov	r2, r3
 800392e:	4603      	mov	r3, r0
 8003930:	817b      	strh	r3, [r7, #10]
 8003932:	460b      	mov	r3, r1
 8003934:	813b      	strh	r3, [r7, #8]
 8003936:	4613      	mov	r3, r2
 8003938:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800393a:	88fb      	ldrh	r3, [r7, #6]
 800393c:	b2da      	uxtb	r2, r3
 800393e:	8979      	ldrh	r1, [r7, #10]
 8003940:	4b20      	ldr	r3, [pc, #128]	; (80039c4 <I2C_RequestMemoryWrite+0xa4>)
 8003942:	9300      	str	r3, [sp, #0]
 8003944:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8003948:	68f8      	ldr	r0, [r7, #12]
 800394a:	f000 f9d7 	bl	8003cfc <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800394e:	69fa      	ldr	r2, [r7, #28]
 8003950:	69b9      	ldr	r1, [r7, #24]
 8003952:	68f8      	ldr	r0, [r7, #12]
 8003954:	f000 f8f0 	bl	8003b38 <I2C_WaitOnTXISFlagUntilTimeout>
 8003958:	4603      	mov	r3, r0
 800395a:	2b00      	cmp	r3, #0
 800395c:	d001      	beq.n	8003962 <I2C_RequestMemoryWrite+0x42>
  {
    return HAL_ERROR;
 800395e:	2301      	movs	r3, #1
 8003960:	e02c      	b.n	80039bc <I2C_RequestMemoryWrite+0x9c>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8003962:	88fb      	ldrh	r3, [r7, #6]
 8003964:	2b01      	cmp	r3, #1
 8003966:	d105      	bne.n	8003974 <I2C_RequestMemoryWrite+0x54>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8003968:	893b      	ldrh	r3, [r7, #8]
 800396a:	b2da      	uxtb	r2, r3
 800396c:	68fb      	ldr	r3, [r7, #12]
 800396e:	681b      	ldr	r3, [r3, #0]
 8003970:	629a      	str	r2, [r3, #40]	; 0x28
 8003972:	e015      	b.n	80039a0 <I2C_RequestMemoryWrite+0x80>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8003974:	893b      	ldrh	r3, [r7, #8]
 8003976:	0a1b      	lsrs	r3, r3, #8
 8003978:	b29b      	uxth	r3, r3
 800397a:	b2da      	uxtb	r2, r3
 800397c:	68fb      	ldr	r3, [r7, #12]
 800397e:	681b      	ldr	r3, [r3, #0]
 8003980:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8003982:	69fa      	ldr	r2, [r7, #28]
 8003984:	69b9      	ldr	r1, [r7, #24]
 8003986:	68f8      	ldr	r0, [r7, #12]
 8003988:	f000 f8d6 	bl	8003b38 <I2C_WaitOnTXISFlagUntilTimeout>
 800398c:	4603      	mov	r3, r0
 800398e:	2b00      	cmp	r3, #0
 8003990:	d001      	beq.n	8003996 <I2C_RequestMemoryWrite+0x76>
    {
      return HAL_ERROR;
 8003992:	2301      	movs	r3, #1
 8003994:	e012      	b.n	80039bc <I2C_RequestMemoryWrite+0x9c>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8003996:	893b      	ldrh	r3, [r7, #8]
 8003998:	b2da      	uxtb	r2, r3
 800399a:	68fb      	ldr	r3, [r7, #12]
 800399c:	681b      	ldr	r3, [r3, #0]
 800399e:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TCR flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, Tickstart) != HAL_OK)
 80039a0:	69fb      	ldr	r3, [r7, #28]
 80039a2:	9300      	str	r3, [sp, #0]
 80039a4:	69bb      	ldr	r3, [r7, #24]
 80039a6:	2200      	movs	r2, #0
 80039a8:	2180      	movs	r1, #128	; 0x80
 80039aa:	68f8      	ldr	r0, [r7, #12]
 80039ac:	f000 f884 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 80039b0:	4603      	mov	r3, r0
 80039b2:	2b00      	cmp	r3, #0
 80039b4:	d001      	beq.n	80039ba <I2C_RequestMemoryWrite+0x9a>
  {
    return HAL_ERROR;
 80039b6:	2301      	movs	r3, #1
 80039b8:	e000      	b.n	80039bc <I2C_RequestMemoryWrite+0x9c>
  }

  return HAL_OK;
 80039ba:	2300      	movs	r3, #0
}
 80039bc:	4618      	mov	r0, r3
 80039be:	3710      	adds	r7, #16
 80039c0:	46bd      	mov	sp, r7
 80039c2:	bd80      	pop	{r7, pc}
 80039c4:	80002000 	.word	0x80002000

080039c8 <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80039c8:	b580      	push	{r7, lr}
 80039ca:	b086      	sub	sp, #24
 80039cc:	af02      	add	r7, sp, #8
 80039ce:	60f8      	str	r0, [r7, #12]
 80039d0:	4608      	mov	r0, r1
 80039d2:	4611      	mov	r1, r2
 80039d4:	461a      	mov	r2, r3
 80039d6:	4603      	mov	r3, r0
 80039d8:	817b      	strh	r3, [r7, #10]
 80039da:	460b      	mov	r3, r1
 80039dc:	813b      	strh	r3, [r7, #8]
 80039de:	4613      	mov	r3, r2
 80039e0:	80fb      	strh	r3, [r7, #6]
  I2C_TransferConfig(hi2c, DevAddress, (uint8_t)MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 80039e2:	88fb      	ldrh	r3, [r7, #6]
 80039e4:	b2da      	uxtb	r2, r3
 80039e6:	8979      	ldrh	r1, [r7, #10]
 80039e8:	4b20      	ldr	r3, [pc, #128]	; (8003a6c <I2C_RequestMemoryRead+0xa4>)
 80039ea:	9300      	str	r3, [sp, #0]
 80039ec:	2300      	movs	r3, #0
 80039ee:	68f8      	ldr	r0, [r7, #12]
 80039f0:	f000 f984 	bl	8003cfc <I2C_TransferConfig>

  /* Wait until TXIS flag is set */
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80039f4:	69fa      	ldr	r2, [r7, #28]
 80039f6:	69b9      	ldr	r1, [r7, #24]
 80039f8:	68f8      	ldr	r0, [r7, #12]
 80039fa:	f000 f89d 	bl	8003b38 <I2C_WaitOnTXISFlagUntilTimeout>
 80039fe:	4603      	mov	r3, r0
 8003a00:	2b00      	cmp	r3, #0
 8003a02:	d001      	beq.n	8003a08 <I2C_RequestMemoryRead+0x40>
  {
    return HAL_ERROR;
 8003a04:	2301      	movs	r3, #1
 8003a06:	e02c      	b.n	8003a62 <I2C_RequestMemoryRead+0x9a>
  }

  /* If Memory address size is 8Bit */
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8003a08:	88fb      	ldrh	r3, [r7, #6]
 8003a0a:	2b01      	cmp	r3, #1
 8003a0c:	d105      	bne.n	8003a1a <I2C_RequestMemoryRead+0x52>
  {
    /* Send Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8003a0e:	893b      	ldrh	r3, [r7, #8]
 8003a10:	b2da      	uxtb	r2, r3
 8003a12:	68fb      	ldr	r3, [r7, #12]
 8003a14:	681b      	ldr	r3, [r3, #0]
 8003a16:	629a      	str	r2, [r3, #40]	; 0x28
 8003a18:	e015      	b.n	8003a46 <I2C_RequestMemoryRead+0x7e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8003a1a:	893b      	ldrh	r3, [r7, #8]
 8003a1c:	0a1b      	lsrs	r3, r3, #8
 8003a1e:	b29b      	uxth	r3, r3
 8003a20:	b2da      	uxtb	r2, r3
 8003a22:	68fb      	ldr	r3, [r7, #12]
 8003a24:	681b      	ldr	r3, [r3, #0]
 8003a26:	629a      	str	r2, [r3, #40]	; 0x28

    /* Wait until TXIS flag is set */
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8003a28:	69fa      	ldr	r2, [r7, #28]
 8003a2a:	69b9      	ldr	r1, [r7, #24]
 8003a2c:	68f8      	ldr	r0, [r7, #12]
 8003a2e:	f000 f883 	bl	8003b38 <I2C_WaitOnTXISFlagUntilTimeout>
 8003a32:	4603      	mov	r3, r0
 8003a34:	2b00      	cmp	r3, #0
 8003a36:	d001      	beq.n	8003a3c <I2C_RequestMemoryRead+0x74>
    {
      return HAL_ERROR;
 8003a38:	2301      	movs	r3, #1
 8003a3a:	e012      	b.n	8003a62 <I2C_RequestMemoryRead+0x9a>
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 8003a3c:	893b      	ldrh	r3, [r7, #8]
 8003a3e:	b2da      	uxtb	r2, r3
 8003a40:	68fb      	ldr	r3, [r7, #12]
 8003a42:	681b      	ldr	r3, [r3, #0]
 8003a44:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Wait until TC flag is set */
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8003a46:	69fb      	ldr	r3, [r7, #28]
 8003a48:	9300      	str	r3, [sp, #0]
 8003a4a:	69bb      	ldr	r3, [r7, #24]
 8003a4c:	2200      	movs	r2, #0
 8003a4e:	2140      	movs	r1, #64	; 0x40
 8003a50:	68f8      	ldr	r0, [r7, #12]
 8003a52:	f000 f831 	bl	8003ab8 <I2C_WaitOnFlagUntilTimeout>
 8003a56:	4603      	mov	r3, r0
 8003a58:	2b00      	cmp	r3, #0
 8003a5a:	d001      	beq.n	8003a60 <I2C_RequestMemoryRead+0x98>
  {
    return HAL_ERROR;
 8003a5c:	2301      	movs	r3, #1
 8003a5e:	e000      	b.n	8003a62 <I2C_RequestMemoryRead+0x9a>
  }

  return HAL_OK;
 8003a60:	2300      	movs	r3, #0
}
 8003a62:	4618      	mov	r0, r3
 8003a64:	3710      	adds	r7, #16
 8003a66:	46bd      	mov	sp, r7
 8003a68:	bd80      	pop	{r7, pc}
 8003a6a:	bf00      	nop
 8003a6c:	80002000 	.word	0x80002000

08003a70 <I2C_Flush_TXDR>:
  * @brief  I2C Tx data register flush process.
  * @param  hi2c I2C handle.
  * @retval None
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
 8003a70:	b480      	push	{r7}
 8003a72:	b083      	sub	sp, #12
 8003a74:	af00      	add	r7, sp, #0
 8003a76:	6078      	str	r0, [r7, #4]
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8003a78:	687b      	ldr	r3, [r7, #4]
 8003a7a:	681b      	ldr	r3, [r3, #0]
 8003a7c:	699b      	ldr	r3, [r3, #24]
 8003a7e:	f003 0302 	and.w	r3, r3, #2
 8003a82:	2b02      	cmp	r3, #2
 8003a84:	d103      	bne.n	8003a8e <I2C_Flush_TXDR+0x1e>
  {
    hi2c->Instance->TXDR = 0x00U;
 8003a86:	687b      	ldr	r3, [r7, #4]
 8003a88:	681b      	ldr	r3, [r3, #0]
 8003a8a:	2200      	movs	r2, #0
 8003a8c:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8003a8e:	687b      	ldr	r3, [r7, #4]
 8003a90:	681b      	ldr	r3, [r3, #0]
 8003a92:	699b      	ldr	r3, [r3, #24]
 8003a94:	f003 0301 	and.w	r3, r3, #1
 8003a98:	2b01      	cmp	r3, #1
 8003a9a:	d007      	beq.n	8003aac <I2C_Flush_TXDR+0x3c>
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8003a9c:	687b      	ldr	r3, [r7, #4]
 8003a9e:	681b      	ldr	r3, [r3, #0]
 8003aa0:	699a      	ldr	r2, [r3, #24]
 8003aa2:	687b      	ldr	r3, [r7, #4]
 8003aa4:	681b      	ldr	r3, [r3, #0]
 8003aa6:	f042 0201 	orr.w	r2, r2, #1
 8003aaa:	619a      	str	r2, [r3, #24]
  }
}
 8003aac:	bf00      	nop
 8003aae:	370c      	adds	r7, #12
 8003ab0:	46bd      	mov	sp, r7
 8003ab2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003ab6:	4770      	bx	lr

08003ab8 <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 8003ab8:	b580      	push	{r7, lr}
 8003aba:	b084      	sub	sp, #16
 8003abc:	af00      	add	r7, sp, #0
 8003abe:	60f8      	str	r0, [r7, #12]
 8003ac0:	60b9      	str	r1, [r7, #8]
 8003ac2:	603b      	str	r3, [r7, #0]
 8003ac4:	4613      	mov	r3, r2
 8003ac6:	71fb      	strb	r3, [r7, #7]
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003ac8:	e022      	b.n	8003b10 <I2C_WaitOnFlagUntilTimeout+0x58>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8003aca:	683b      	ldr	r3, [r7, #0]
 8003acc:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003ad0:	d01e      	beq.n	8003b10 <I2C_WaitOnFlagUntilTimeout+0x58>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003ad2:	f7fc fda7 	bl	8000624 <HAL_GetTick>
 8003ad6:	4602      	mov	r2, r0
 8003ad8:	69bb      	ldr	r3, [r7, #24]
 8003ada:	1ad3      	subs	r3, r2, r3
 8003adc:	683a      	ldr	r2, [r7, #0]
 8003ade:	429a      	cmp	r2, r3
 8003ae0:	d302      	bcc.n	8003ae8 <I2C_WaitOnFlagUntilTimeout+0x30>
 8003ae2:	683b      	ldr	r3, [r7, #0]
 8003ae4:	2b00      	cmp	r3, #0
 8003ae6:	d113      	bne.n	8003b10 <I2C_WaitOnFlagUntilTimeout+0x58>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003ae8:	68fb      	ldr	r3, [r7, #12]
 8003aea:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003aec:	f043 0220 	orr.w	r2, r3, #32
 8003af0:	68fb      	ldr	r3, [r7, #12]
 8003af2:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003af4:	68fb      	ldr	r3, [r7, #12]
 8003af6:	2220      	movs	r2, #32
 8003af8:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003afc:	68fb      	ldr	r3, [r7, #12]
 8003afe:	2200      	movs	r2, #0
 8003b00:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8003b04:	68fb      	ldr	r3, [r7, #12]
 8003b06:	2200      	movs	r2, #0
 8003b08:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        return HAL_ERROR;
 8003b0c:	2301      	movs	r3, #1
 8003b0e:	e00f      	b.n	8003b30 <I2C_WaitOnFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8003b10:	68fb      	ldr	r3, [r7, #12]
 8003b12:	681b      	ldr	r3, [r3, #0]
 8003b14:	699a      	ldr	r2, [r3, #24]
 8003b16:	68bb      	ldr	r3, [r7, #8]
 8003b18:	4013      	ands	r3, r2
 8003b1a:	68ba      	ldr	r2, [r7, #8]
 8003b1c:	429a      	cmp	r2, r3
 8003b1e:	bf0c      	ite	eq
 8003b20:	2301      	moveq	r3, #1
 8003b22:	2300      	movne	r3, #0
 8003b24:	b2db      	uxtb	r3, r3
 8003b26:	461a      	mov	r2, r3
 8003b28:	79fb      	ldrb	r3, [r7, #7]
 8003b2a:	429a      	cmp	r2, r3
 8003b2c:	d0cd      	beq.n	8003aca <I2C_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8003b2e:	2300      	movs	r3, #0
}
 8003b30:	4618      	mov	r0, r3
 8003b32:	3710      	adds	r7, #16
 8003b34:	46bd      	mov	sp, r7
 8003b36:	bd80      	pop	{r7, pc}

08003b38 <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8003b38:	b580      	push	{r7, lr}
 8003b3a:	b084      	sub	sp, #16
 8003b3c:	af00      	add	r7, sp, #0
 8003b3e:	60f8      	str	r0, [r7, #12]
 8003b40:	60b9      	str	r1, [r7, #8]
 8003b42:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8003b44:	e02c      	b.n	8003ba0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8003b46:	687a      	ldr	r2, [r7, #4]
 8003b48:	68b9      	ldr	r1, [r7, #8]
 8003b4a:	68f8      	ldr	r0, [r7, #12]
 8003b4c:	f000 f870 	bl	8003c30 <I2C_IsAcknowledgeFailed>
 8003b50:	4603      	mov	r3, r0
 8003b52:	2b00      	cmp	r3, #0
 8003b54:	d001      	beq.n	8003b5a <I2C_WaitOnTXISFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8003b56:	2301      	movs	r3, #1
 8003b58:	e02a      	b.n	8003bb0 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
    }

    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8003b5a:	68bb      	ldr	r3, [r7, #8]
 8003b5c:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003b60:	d01e      	beq.n	8003ba0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003b62:	f7fc fd5f 	bl	8000624 <HAL_GetTick>
 8003b66:	4602      	mov	r2, r0
 8003b68:	687b      	ldr	r3, [r7, #4]
 8003b6a:	1ad3      	subs	r3, r2, r3
 8003b6c:	68ba      	ldr	r2, [r7, #8]
 8003b6e:	429a      	cmp	r2, r3
 8003b70:	d302      	bcc.n	8003b78 <I2C_WaitOnTXISFlagUntilTimeout+0x40>
 8003b72:	68bb      	ldr	r3, [r7, #8]
 8003b74:	2b00      	cmp	r3, #0
 8003b76:	d113      	bne.n	8003ba0 <I2C_WaitOnTXISFlagUntilTimeout+0x68>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003b78:	68fb      	ldr	r3, [r7, #12]
 8003b7a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003b7c:	f043 0220 	orr.w	r2, r3, #32
 8003b80:	68fb      	ldr	r3, [r7, #12]
 8003b82:	645a      	str	r2, [r3, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8003b84:	68fb      	ldr	r3, [r7, #12]
 8003b86:	2220      	movs	r2, #32
 8003b88:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8003b8c:	68fb      	ldr	r3, [r7, #12]
 8003b8e:	2200      	movs	r2, #0
 8003b90:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8003b94:	68fb      	ldr	r3, [r7, #12]
 8003b96:	2200      	movs	r2, #0
 8003b98:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

        return HAL_ERROR;
 8003b9c:	2301      	movs	r3, #1
 8003b9e:	e007      	b.n	8003bb0 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8003ba0:	68fb      	ldr	r3, [r7, #12]
 8003ba2:	681b      	ldr	r3, [r3, #0]
 8003ba4:	699b      	ldr	r3, [r3, #24]
 8003ba6:	f003 0302 	and.w	r3, r3, #2
 8003baa:	2b02      	cmp	r3, #2
 8003bac:	d1cb      	bne.n	8003b46 <I2C_WaitOnTXISFlagUntilTimeout+0xe>
      }
    }
  }
  return HAL_OK;
 8003bae:	2300      	movs	r3, #0
}
 8003bb0:	4618      	mov	r0, r3
 8003bb2:	3710      	adds	r7, #16
 8003bb4:	46bd      	mov	sp, r7
 8003bb6:	bd80      	pop	{r7, pc}

08003bb8 <I2C_WaitOnSTOPFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnSTOPFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8003bb8:	b580      	push	{r7, lr}
 8003bba:	b084      	sub	sp, #16
 8003bbc:	af00      	add	r7, sp, #0
 8003bbe:	60f8      	str	r0, [r7, #12]
 8003bc0:	60b9      	str	r1, [r7, #8]
 8003bc2:	607a      	str	r2, [r7, #4]
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8003bc4:	e028      	b.n	8003c18 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
  {
    /* Check if a NACK is detected */
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8003bc6:	687a      	ldr	r2, [r7, #4]
 8003bc8:	68b9      	ldr	r1, [r7, #8]
 8003bca:	68f8      	ldr	r0, [r7, #12]
 8003bcc:	f000 f830 	bl	8003c30 <I2C_IsAcknowledgeFailed>
 8003bd0:	4603      	mov	r3, r0
 8003bd2:	2b00      	cmp	r3, #0
 8003bd4:	d001      	beq.n	8003bda <I2C_WaitOnSTOPFlagUntilTimeout+0x22>
    {
      return HAL_ERROR;
 8003bd6:	2301      	movs	r3, #1
 8003bd8:	e026      	b.n	8003c28 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
    }

    /* Check for the Timeout */
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003bda:	f7fc fd23 	bl	8000624 <HAL_GetTick>
 8003bde:	4602      	mov	r2, r0
 8003be0:	687b      	ldr	r3, [r7, #4]
 8003be2:	1ad3      	subs	r3, r2, r3
 8003be4:	68ba      	ldr	r2, [r7, #8]
 8003be6:	429a      	cmp	r2, r3
 8003be8:	d302      	bcc.n	8003bf0 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
 8003bea:	68bb      	ldr	r3, [r7, #8]
 8003bec:	2b00      	cmp	r3, #0
 8003bee:	d113      	bne.n	8003c18 <I2C_WaitOnSTOPFlagUntilTimeout+0x60>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003bf0:	68fb      	ldr	r3, [r7, #12]
 8003bf2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003bf4:	f043 0220 	orr.w	r2, r3, #32
 8003bf8:	68fb      	ldr	r3, [r7, #12]
 8003bfa:	645a      	str	r2, [r3, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8003bfc:	68fb      	ldr	r3, [r7, #12]
 8003bfe:	2220      	movs	r2, #32
 8003c00:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8003c04:	68fb      	ldr	r3, [r7, #12]
 8003c06:	2200      	movs	r2, #0
 8003c08:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8003c0c:	68fb      	ldr	r3, [r7, #12]
 8003c0e:	2200      	movs	r2, #0
 8003c10:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

      return HAL_ERROR;
 8003c14:	2301      	movs	r3, #1
 8003c16:	e007      	b.n	8003c28 <I2C_WaitOnSTOPFlagUntilTimeout+0x70>
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8003c18:	68fb      	ldr	r3, [r7, #12]
 8003c1a:	681b      	ldr	r3, [r3, #0]
 8003c1c:	699b      	ldr	r3, [r3, #24]
 8003c1e:	f003 0320 	and.w	r3, r3, #32
 8003c22:	2b20      	cmp	r3, #32
 8003c24:	d1cf      	bne.n	8003bc6 <I2C_WaitOnSTOPFlagUntilTimeout+0xe>
    }
  }
  return HAL_OK;
 8003c26:	2300      	movs	r3, #0
}
 8003c28:	4618      	mov	r0, r3
 8003c2a:	3710      	adds	r7, #16
 8003c2c:	46bd      	mov	sp, r7
 8003c2e:	bd80      	pop	{r7, pc}

08003c30 <I2C_IsAcknowledgeFailed>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 8003c30:	b580      	push	{r7, lr}
 8003c32:	b084      	sub	sp, #16
 8003c34:	af00      	add	r7, sp, #0
 8003c36:	60f8      	str	r0, [r7, #12]
 8003c38:	60b9      	str	r1, [r7, #8]
 8003c3a:	607a      	str	r2, [r7, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8003c3c:	68fb      	ldr	r3, [r7, #12]
 8003c3e:	681b      	ldr	r3, [r3, #0]
 8003c40:	699b      	ldr	r3, [r3, #24]
 8003c42:	f003 0310 	and.w	r3, r3, #16
 8003c46:	2b10      	cmp	r3, #16
 8003c48:	d151      	bne.n	8003cee <I2C_IsAcknowledgeFailed+0xbe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8003c4a:	e022      	b.n	8003c92 <I2C_IsAcknowledgeFailed+0x62>
    {
      /* Check for the Timeout */
      if (Timeout != HAL_MAX_DELAY)
 8003c4c:	68bb      	ldr	r3, [r7, #8]
 8003c4e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8003c52:	d01e      	beq.n	8003c92 <I2C_IsAcknowledgeFailed+0x62>
      {
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8003c54:	f7fc fce6 	bl	8000624 <HAL_GetTick>
 8003c58:	4602      	mov	r2, r0
 8003c5a:	687b      	ldr	r3, [r7, #4]
 8003c5c:	1ad3      	subs	r3, r2, r3
 8003c5e:	68ba      	ldr	r2, [r7, #8]
 8003c60:	429a      	cmp	r2, r3
 8003c62:	d302      	bcc.n	8003c6a <I2C_IsAcknowledgeFailed+0x3a>
 8003c64:	68bb      	ldr	r3, [r7, #8]
 8003c66:	2b00      	cmp	r3, #0
 8003c68:	d113      	bne.n	8003c92 <I2C_IsAcknowledgeFailed+0x62>
        {
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8003c6a:	68fb      	ldr	r3, [r7, #12]
 8003c6c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003c6e:	f043 0220 	orr.w	r2, r3, #32
 8003c72:	68fb      	ldr	r3, [r7, #12]
 8003c74:	645a      	str	r2, [r3, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8003c76:	68fb      	ldr	r3, [r7, #12]
 8003c78:	2220      	movs	r2, #32
 8003c7a:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8003c7e:	68fb      	ldr	r3, [r7, #12]
 8003c80:	2200      	movs	r2, #0
 8003c82:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

          /* Process Unlocked */
          __HAL_UNLOCK(hi2c);
 8003c86:	68fb      	ldr	r3, [r7, #12]
 8003c88:	2200      	movs	r2, #0
 8003c8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

          return HAL_ERROR;
 8003c8e:	2301      	movs	r3, #1
 8003c90:	e02e      	b.n	8003cf0 <I2C_IsAcknowledgeFailed+0xc0>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8003c92:	68fb      	ldr	r3, [r7, #12]
 8003c94:	681b      	ldr	r3, [r3, #0]
 8003c96:	699b      	ldr	r3, [r3, #24]
 8003c98:	f003 0320 	and.w	r3, r3, #32
 8003c9c:	2b20      	cmp	r3, #32
 8003c9e:	d1d5      	bne.n	8003c4c <I2C_IsAcknowledgeFailed+0x1c>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8003ca0:	68fb      	ldr	r3, [r7, #12]
 8003ca2:	681b      	ldr	r3, [r3, #0]
 8003ca4:	2210      	movs	r2, #16
 8003ca6:	61da      	str	r2, [r3, #28]

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8003ca8:	68fb      	ldr	r3, [r7, #12]
 8003caa:	681b      	ldr	r3, [r3, #0]
 8003cac:	2220      	movs	r2, #32
 8003cae:	61da      	str	r2, [r3, #28]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);
 8003cb0:	68f8      	ldr	r0, [r7, #12]
 8003cb2:	f7ff fedd 	bl	8003a70 <I2C_Flush_TXDR>

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 8003cb6:	68fb      	ldr	r3, [r7, #12]
 8003cb8:	681b      	ldr	r3, [r3, #0]
 8003cba:	6859      	ldr	r1, [r3, #4]
 8003cbc:	68fb      	ldr	r3, [r7, #12]
 8003cbe:	681a      	ldr	r2, [r3, #0]
 8003cc0:	4b0d      	ldr	r3, [pc, #52]	; (8003cf8 <I2C_IsAcknowledgeFailed+0xc8>)
 8003cc2:	400b      	ands	r3, r1
 8003cc4:	6053      	str	r3, [r2, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8003cc6:	68fb      	ldr	r3, [r7, #12]
 8003cc8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8003cca:	f043 0204 	orr.w	r2, r3, #4
 8003cce:	68fb      	ldr	r3, [r7, #12]
 8003cd0:	645a      	str	r2, [r3, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8003cd2:	68fb      	ldr	r3, [r7, #12]
 8003cd4:	2220      	movs	r2, #32
 8003cd6:	f883 2041 	strb.w	r2, [r3, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8003cda:	68fb      	ldr	r3, [r7, #12]
 8003cdc:	2200      	movs	r2, #0
 8003cde:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8003ce2:	68fb      	ldr	r3, [r7, #12]
 8003ce4:	2200      	movs	r2, #0
 8003ce6:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40

    return HAL_ERROR;
 8003cea:	2301      	movs	r3, #1
 8003cec:	e000      	b.n	8003cf0 <I2C_IsAcknowledgeFailed+0xc0>
  }
  return HAL_OK;
 8003cee:	2300      	movs	r3, #0
}
 8003cf0:	4618      	mov	r0, r3
 8003cf2:	3710      	adds	r7, #16
 8003cf4:	46bd      	mov	sp, r7
 8003cf6:	bd80      	pop	{r7, pc}
 8003cf8:	fe00e800 	.word	0xfe00e800

08003cfc <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
 8003cfc:	b480      	push	{r7}
 8003cfe:	b085      	sub	sp, #20
 8003d00:	af00      	add	r7, sp, #0
 8003d02:	60f8      	str	r0, [r7, #12]
 8003d04:	607b      	str	r3, [r7, #4]
 8003d06:	460b      	mov	r3, r1
 8003d08:	817b      	strh	r3, [r7, #10]
 8003d0a:	4613      	mov	r3, r2
 8003d0c:	727b      	strb	r3, [r7, #9]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8003d0e:	68fb      	ldr	r3, [r7, #12]
 8003d10:	681b      	ldr	r3, [r3, #0]
 8003d12:	685a      	ldr	r2, [r3, #4]
 8003d14:	69bb      	ldr	r3, [r7, #24]
 8003d16:	0d5b      	lsrs	r3, r3, #21
 8003d18:	f403 6180 	and.w	r1, r3, #1024	; 0x400
 8003d1c:	4b0d      	ldr	r3, [pc, #52]	; (8003d54 <I2C_TransferConfig+0x58>)
 8003d1e:	430b      	orrs	r3, r1
 8003d20:	43db      	mvns	r3, r3
 8003d22:	ea02 0103 	and.w	r1, r2, r3
 8003d26:	897b      	ldrh	r3, [r7, #10]
 8003d28:	f3c3 0209 	ubfx	r2, r3, #0, #10
 8003d2c:	7a7b      	ldrb	r3, [r7, #9]
 8003d2e:	041b      	lsls	r3, r3, #16
 8003d30:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 8003d34:	431a      	orrs	r2, r3
 8003d36:	687b      	ldr	r3, [r7, #4]
 8003d38:	431a      	orrs	r2, r3
 8003d3a:	69bb      	ldr	r3, [r7, #24]
 8003d3c:	431a      	orrs	r2, r3
 8003d3e:	68fb      	ldr	r3, [r7, #12]
 8003d40:	681b      	ldr	r3, [r3, #0]
 8003d42:	430a      	orrs	r2, r1
 8003d44:	605a      	str	r2, [r3, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 8003d46:	bf00      	nop
 8003d48:	3714      	adds	r7, #20
 8003d4a:	46bd      	mov	sp, r7
 8003d4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003d50:	4770      	bx	lr
 8003d52:	bf00      	nop
 8003d54:	03ff63ff 	.word	0x03ff63ff

08003d58 <HAL_LTDC_Init>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
 8003d58:	b580      	push	{r7, lr}
 8003d5a:	b084      	sub	sp, #16
 8003d5c:	af00      	add	r7, sp, #0
 8003d5e:	6078      	str	r0, [r7, #4]
  uint32_t tmp, tmp1;

  /* Check the LTDC peripheral state */
  if (hltdc == NULL)
 8003d60:	687b      	ldr	r3, [r7, #4]
 8003d62:	2b00      	cmp	r3, #0
 8003d64:	d101      	bne.n	8003d6a <HAL_LTDC_Init+0x12>
  {
    return HAL_ERROR;
 8003d66:	2301      	movs	r3, #1
 8003d68:	e0bf      	b.n	8003eea <HAL_LTDC_Init+0x192>
    }
    /* Init the low level hardware */
    hltdc->MspInitCallback(hltdc);
  }
#else
  if (hltdc->State == HAL_LTDC_STATE_RESET)
 8003d6a:	687b      	ldr	r3, [r7, #4]
 8003d6c:	f893 30a1 	ldrb.w	r3, [r3, #161]	; 0xa1
 8003d70:	b2db      	uxtb	r3, r3
 8003d72:	2b00      	cmp	r3, #0
 8003d74:	d106      	bne.n	8003d84 <HAL_LTDC_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
 8003d76:	687b      	ldr	r3, [r7, #4]
 8003d78:	2200      	movs	r2, #0
 8003d7a:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
 8003d7e:	6878      	ldr	r0, [r7, #4]
 8003d80:	f005 fe60 	bl	8009a44 <HAL_LTDC_MspInit>
  }
#endif /* USE_HAL_LTDC_REGISTER_CALLBACKS */

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003d84:	687b      	ldr	r3, [r7, #4]
 8003d86:	2202      	movs	r2, #2
 8003d88:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Configure the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 8003d8c:	687b      	ldr	r3, [r7, #4]
 8003d8e:	681b      	ldr	r3, [r3, #0]
 8003d90:	699a      	ldr	r2, [r3, #24]
 8003d92:	687b      	ldr	r3, [r7, #4]
 8003d94:	681b      	ldr	r3, [r3, #0]
 8003d96:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 8003d9a:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003d9c:	687b      	ldr	r3, [r7, #4]
 8003d9e:	681b      	ldr	r3, [r3, #0]
 8003da0:	6999      	ldr	r1, [r3, #24]
 8003da2:	687b      	ldr	r3, [r7, #4]
 8003da4:	685a      	ldr	r2, [r3, #4]
 8003da6:	687b      	ldr	r3, [r7, #4]
 8003da8:	689b      	ldr	r3, [r3, #8]
 8003daa:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8003dac:	687b      	ldr	r3, [r7, #4]
 8003dae:	68db      	ldr	r3, [r3, #12]
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003db0:	431a      	orrs	r2, r3
                                     hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);
 8003db2:	687b      	ldr	r3, [r7, #4]
 8003db4:	691b      	ldr	r3, [r3, #16]
 8003db6:	431a      	orrs	r2, r3
  hltdc->Instance->GCR |= (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 8003db8:	687b      	ldr	r3, [r7, #4]
 8003dba:	681b      	ldr	r3, [r3, #0]
 8003dbc:	430a      	orrs	r2, r1
 8003dbe:	619a      	str	r2, [r3, #24]

  /* Set Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 8003dc0:	687b      	ldr	r3, [r7, #4]
 8003dc2:	681b      	ldr	r3, [r3, #0]
 8003dc4:	6899      	ldr	r1, [r3, #8]
 8003dc6:	687b      	ldr	r3, [r7, #4]
 8003dc8:	681a      	ldr	r2, [r3, #0]
 8003dca:	4b4a      	ldr	r3, [pc, #296]	; (8003ef4 <HAL_LTDC_Init+0x19c>)
 8003dcc:	400b      	ands	r3, r1
 8003dce:	6093      	str	r3, [r2, #8]
  tmp = (hltdc->Init.HorizontalSync << 16U);
 8003dd0:	687b      	ldr	r3, [r7, #4]
 8003dd2:	695b      	ldr	r3, [r3, #20]
 8003dd4:	041b      	lsls	r3, r3, #16
 8003dd6:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 8003dd8:	687b      	ldr	r3, [r7, #4]
 8003dda:	681b      	ldr	r3, [r3, #0]
 8003ddc:	6899      	ldr	r1, [r3, #8]
 8003dde:	687b      	ldr	r3, [r7, #4]
 8003de0:	699a      	ldr	r2, [r3, #24]
 8003de2:	68fb      	ldr	r3, [r7, #12]
 8003de4:	431a      	orrs	r2, r3
 8003de6:	687b      	ldr	r3, [r7, #4]
 8003de8:	681b      	ldr	r3, [r3, #0]
 8003dea:	430a      	orrs	r2, r1
 8003dec:	609a      	str	r2, [r3, #8]

  /* Set Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 8003dee:	687b      	ldr	r3, [r7, #4]
 8003df0:	681b      	ldr	r3, [r3, #0]
 8003df2:	68d9      	ldr	r1, [r3, #12]
 8003df4:	687b      	ldr	r3, [r7, #4]
 8003df6:	681a      	ldr	r2, [r3, #0]
 8003df8:	4b3e      	ldr	r3, [pc, #248]	; (8003ef4 <HAL_LTDC_Init+0x19c>)
 8003dfa:	400b      	ands	r3, r1
 8003dfc:	60d3      	str	r3, [r2, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
 8003dfe:	687b      	ldr	r3, [r7, #4]
 8003e00:	69db      	ldr	r3, [r3, #28]
 8003e02:	041b      	lsls	r3, r3, #16
 8003e04:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8003e06:	687b      	ldr	r3, [r7, #4]
 8003e08:	681b      	ldr	r3, [r3, #0]
 8003e0a:	68d9      	ldr	r1, [r3, #12]
 8003e0c:	687b      	ldr	r3, [r7, #4]
 8003e0e:	6a1a      	ldr	r2, [r3, #32]
 8003e10:	68fb      	ldr	r3, [r7, #12]
 8003e12:	431a      	orrs	r2, r3
 8003e14:	687b      	ldr	r3, [r7, #4]
 8003e16:	681b      	ldr	r3, [r3, #0]
 8003e18:	430a      	orrs	r2, r1
 8003e1a:	60da      	str	r2, [r3, #12]

  /* Set Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8003e1c:	687b      	ldr	r3, [r7, #4]
 8003e1e:	681b      	ldr	r3, [r3, #0]
 8003e20:	6919      	ldr	r1, [r3, #16]
 8003e22:	687b      	ldr	r3, [r7, #4]
 8003e24:	681a      	ldr	r2, [r3, #0]
 8003e26:	4b33      	ldr	r3, [pc, #204]	; (8003ef4 <HAL_LTDC_Init+0x19c>)
 8003e28:	400b      	ands	r3, r1
 8003e2a:	6113      	str	r3, [r2, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
 8003e2c:	687b      	ldr	r3, [r7, #4]
 8003e2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8003e30:	041b      	lsls	r3, r3, #16
 8003e32:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8003e34:	687b      	ldr	r3, [r7, #4]
 8003e36:	681b      	ldr	r3, [r3, #0]
 8003e38:	6919      	ldr	r1, [r3, #16]
 8003e3a:	687b      	ldr	r3, [r7, #4]
 8003e3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003e3e:	68fb      	ldr	r3, [r7, #12]
 8003e40:	431a      	orrs	r2, r3
 8003e42:	687b      	ldr	r3, [r7, #4]
 8003e44:	681b      	ldr	r3, [r3, #0]
 8003e46:	430a      	orrs	r2, r1
 8003e48:	611a      	str	r2, [r3, #16]

  /* Set Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 8003e4a:	687b      	ldr	r3, [r7, #4]
 8003e4c:	681b      	ldr	r3, [r3, #0]
 8003e4e:	6959      	ldr	r1, [r3, #20]
 8003e50:	687b      	ldr	r3, [r7, #4]
 8003e52:	681a      	ldr	r2, [r3, #0]
 8003e54:	4b27      	ldr	r3, [pc, #156]	; (8003ef4 <HAL_LTDC_Init+0x19c>)
 8003e56:	400b      	ands	r3, r1
 8003e58:	6153      	str	r3, [r2, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
 8003e5a:	687b      	ldr	r3, [r7, #4]
 8003e5c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8003e5e:	041b      	lsls	r3, r3, #16
 8003e60:	60fb      	str	r3, [r7, #12]
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8003e62:	687b      	ldr	r3, [r7, #4]
 8003e64:	681b      	ldr	r3, [r3, #0]
 8003e66:	6959      	ldr	r1, [r3, #20]
 8003e68:	687b      	ldr	r3, [r7, #4]
 8003e6a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003e6c:	68fb      	ldr	r3, [r7, #12]
 8003e6e:	431a      	orrs	r2, r3
 8003e70:	687b      	ldr	r3, [r7, #4]
 8003e72:	681b      	ldr	r3, [r3, #0]
 8003e74:	430a      	orrs	r2, r1
 8003e76:	615a      	str	r2, [r3, #20]

  /* Set the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
 8003e78:	687b      	ldr	r3, [r7, #4]
 8003e7a:	f893 3035 	ldrb.w	r3, [r3, #53]	; 0x35
 8003e7e:	021b      	lsls	r3, r3, #8
 8003e80:	60fb      	str	r3, [r7, #12]
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
 8003e82:	687b      	ldr	r3, [r7, #4]
 8003e84:	f893 3036 	ldrb.w	r3, [r3, #54]	; 0x36
 8003e88:	041b      	lsls	r3, r3, #16
 8003e8a:	60bb      	str	r3, [r7, #8]
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8003e8c:	687b      	ldr	r3, [r7, #4]
 8003e8e:	681b      	ldr	r3, [r3, #0]
 8003e90:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8003e92:	687b      	ldr	r3, [r7, #4]
 8003e94:	681b      	ldr	r3, [r3, #0]
 8003e96:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
 8003e9a:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8003e9c:	687b      	ldr	r3, [r7, #4]
 8003e9e:	681b      	ldr	r3, [r3, #0]
 8003ea0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8003ea2:	68ba      	ldr	r2, [r7, #8]
 8003ea4:	68fb      	ldr	r3, [r7, #12]
 8003ea6:	4313      	orrs	r3, r2
 8003ea8:	687a      	ldr	r2, [r7, #4]
 8003eaa:	f892 2034 	ldrb.w	r2, [r2, #52]	; 0x34
 8003eae:	431a      	orrs	r2, r3
 8003eb0:	687b      	ldr	r3, [r7, #4]
 8003eb2:	681b      	ldr	r3, [r3, #0]
 8003eb4:	430a      	orrs	r2, r1
 8003eb6:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the Transfer Error and FIFO underrun interrupts */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE | LTDC_IT_FU);
 8003eb8:	687b      	ldr	r3, [r7, #4]
 8003eba:	681b      	ldr	r3, [r3, #0]
 8003ebc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003ebe:	687b      	ldr	r3, [r7, #4]
 8003ec0:	681b      	ldr	r3, [r3, #0]
 8003ec2:	f042 0206 	orr.w	r2, r2, #6
 8003ec6:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
 8003ec8:	687b      	ldr	r3, [r7, #4]
 8003eca:	681b      	ldr	r3, [r3, #0]
 8003ecc:	699a      	ldr	r2, [r3, #24]
 8003ece:	687b      	ldr	r3, [r7, #4]
 8003ed0:	681b      	ldr	r3, [r3, #0]
 8003ed2:	f042 0201 	orr.w	r2, r2, #1
 8003ed6:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8003ed8:	687b      	ldr	r3, [r7, #4]
 8003eda:	2200      	movs	r2, #0
 8003edc:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8003ee0:	687b      	ldr	r3, [r7, #4]
 8003ee2:	2201      	movs	r2, #1
 8003ee4:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  return HAL_OK;
 8003ee8:	2300      	movs	r3, #0
}
 8003eea:	4618      	mov	r0, r3
 8003eec:	3710      	adds	r7, #16
 8003eee:	46bd      	mov	sp, r7
 8003ef0:	bd80      	pop	{r7, pc}
 8003ef2:	bf00      	nop
 8003ef4:	f000f800 	.word	0xf000f800

08003ef8 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
 8003ef8:	b5b0      	push	{r4, r5, r7, lr}
 8003efa:	b084      	sub	sp, #16
 8003efc:	af00      	add	r7, sp, #0
 8003efe:	60f8      	str	r0, [r7, #12]
 8003f00:	60b9      	str	r1, [r7, #8]
 8003f02:	607a      	str	r2, [r7, #4]
  assert_param(IS_LTDC_BLENDING_FACTOR2(pLayerCfg->BlendingFactor2));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Process locked */
  __HAL_LOCK(hltdc);
 8003f04:	68fb      	ldr	r3, [r7, #12]
 8003f06:	f893 30a0 	ldrb.w	r3, [r3, #160]	; 0xa0
 8003f0a:	2b01      	cmp	r3, #1
 8003f0c:	d101      	bne.n	8003f12 <HAL_LTDC_ConfigLayer+0x1a>
 8003f0e:	2302      	movs	r3, #2
 8003f10:	e02c      	b.n	8003f6c <HAL_LTDC_ConfigLayer+0x74>
 8003f12:	68fb      	ldr	r3, [r7, #12]
 8003f14:	2201      	movs	r2, #1
 8003f16:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8003f1a:	68fb      	ldr	r3, [r7, #12]
 8003f1c:	2202      	movs	r2, #2
 8003f1e:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;
 8003f22:	68fa      	ldr	r2, [r7, #12]
 8003f24:	687b      	ldr	r3, [r7, #4]
 8003f26:	2134      	movs	r1, #52	; 0x34
 8003f28:	fb01 f303 	mul.w	r3, r1, r3
 8003f2c:	4413      	add	r3, r2
 8003f2e:	f103 0238 	add.w	r2, r3, #56	; 0x38
 8003f32:	68bb      	ldr	r3, [r7, #8]
 8003f34:	4614      	mov	r4, r2
 8003f36:	461d      	mov	r5, r3
 8003f38:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003f3a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003f3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003f3e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003f40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8003f42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003f44:	682b      	ldr	r3, [r5, #0]
 8003f46:	6023      	str	r3, [r4, #0]

  /* Configure the LTDC Layer */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8003f48:	687a      	ldr	r2, [r7, #4]
 8003f4a:	68b9      	ldr	r1, [r7, #8]
 8003f4c:	68f8      	ldr	r0, [r7, #12]
 8003f4e:	f000 f81f 	bl	8003f90 <LTDC_SetConfig>

  /* Set the Immediate Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8003f52:	68fb      	ldr	r3, [r7, #12]
 8003f54:	681b      	ldr	r3, [r3, #0]
 8003f56:	2201      	movs	r2, #1
 8003f58:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
 8003f5a:	68fb      	ldr	r3, [r7, #12]
 8003f5c:	2201      	movs	r2, #1
 8003f5e:	f883 20a1 	strb.w	r2, [r3, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8003f62:	68fb      	ldr	r3, [r7, #12]
 8003f64:	2200      	movs	r2, #0
 8003f66:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0

  return HAL_OK;
 8003f6a:	2300      	movs	r3, #0
}
 8003f6c:	4618      	mov	r0, r3
 8003f6e:	3710      	adds	r7, #16
 8003f70:	46bd      	mov	sp, r7
 8003f72:	bdb0      	pop	{r4, r5, r7, pc}

08003f74 <HAL_LTDC_GetState>:
  * @param  hltdc  pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL state
  */
HAL_LTDC_StateTypeDef HAL_LTDC_GetState(LTDC_HandleTypeDef *hltdc)
{
 8003f74:	b480      	push	{r7}
 8003f76:	b083      	sub	sp, #12
 8003f78:	af00      	add	r7, sp, #0
 8003f7a:	6078      	str	r0, [r7, #4]
  return hltdc->State;
 8003f7c:	687b      	ldr	r3, [r7, #4]
 8003f7e:	f893 30a1 	ldrb.w	r3, [r3, #161]	; 0xa1
 8003f82:	b2db      	uxtb	r3, r3
}
 8003f84:	4618      	mov	r0, r3
 8003f86:	370c      	adds	r7, #12
 8003f88:	46bd      	mov	sp, r7
 8003f8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f8e:	4770      	bx	lr

08003f90 <LTDC_SetConfig>:
  * @param  LayerIdx  LTDC Layer index.
  *                   This parameter can be one of the following values: LTDC_LAYER_1 (0) or LTDC_LAYER_2 (1)
  * @retval None
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
 8003f90:	b480      	push	{r7}
 8003f92:	b089      	sub	sp, #36	; 0x24
 8003f94:	af00      	add	r7, sp, #0
 8003f96:	60f8      	str	r0, [r7, #12]
 8003f98:	60b9      	str	r1, [r7, #8]
 8003f9a:	607a      	str	r2, [r7, #4]
  uint32_t tmp;
  uint32_t tmp1;
  uint32_t tmp2;

  /* Configure the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 8003f9c:	68bb      	ldr	r3, [r7, #8]
 8003f9e:	685a      	ldr	r2, [r3, #4]
 8003fa0:	68fb      	ldr	r3, [r7, #12]
 8003fa2:	681b      	ldr	r3, [r3, #0]
 8003fa4:	68db      	ldr	r3, [r3, #12]
 8003fa6:	0c1b      	lsrs	r3, r3, #16
 8003fa8:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8003fac:	4413      	add	r3, r2
 8003fae:	041b      	lsls	r3, r3, #16
 8003fb0:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 8003fb2:	68fb      	ldr	r3, [r7, #12]
 8003fb4:	681b      	ldr	r3, [r3, #0]
 8003fb6:	461a      	mov	r2, r3
 8003fb8:	687b      	ldr	r3, [r7, #4]
 8003fba:	01db      	lsls	r3, r3, #7
 8003fbc:	4413      	add	r3, r2
 8003fbe:	3384      	adds	r3, #132	; 0x84
 8003fc0:	685b      	ldr	r3, [r3, #4]
 8003fc2:	68fa      	ldr	r2, [r7, #12]
 8003fc4:	6812      	ldr	r2, [r2, #0]
 8003fc6:	4611      	mov	r1, r2
 8003fc8:	687a      	ldr	r2, [r7, #4]
 8003fca:	01d2      	lsls	r2, r2, #7
 8003fcc:	440a      	add	r2, r1
 8003fce:	3284      	adds	r2, #132	; 0x84
 8003fd0:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 8003fd4:	6053      	str	r3, [r2, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 8003fd6:	68bb      	ldr	r3, [r7, #8]
 8003fd8:	681a      	ldr	r2, [r3, #0]
 8003fda:	68fb      	ldr	r3, [r7, #12]
 8003fdc:	681b      	ldr	r3, [r3, #0]
 8003fde:	68db      	ldr	r3, [r3, #12]
 8003fe0:	0c1b      	lsrs	r3, r3, #16
 8003fe2:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8003fe6:	4413      	add	r3, r2
 8003fe8:	1c5a      	adds	r2, r3, #1
 8003fea:	68fb      	ldr	r3, [r7, #12]
 8003fec:	681b      	ldr	r3, [r3, #0]
 8003fee:	4619      	mov	r1, r3
 8003ff0:	687b      	ldr	r3, [r7, #4]
 8003ff2:	01db      	lsls	r3, r3, #7
 8003ff4:	440b      	add	r3, r1
 8003ff6:	3384      	adds	r3, #132	; 0x84
 8003ff8:	4619      	mov	r1, r3
 8003ffa:	69fb      	ldr	r3, [r7, #28]
 8003ffc:	4313      	orrs	r3, r2
 8003ffe:	604b      	str	r3, [r1, #4]

  /* Configure the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 8004000:	68bb      	ldr	r3, [r7, #8]
 8004002:	68da      	ldr	r2, [r3, #12]
 8004004:	68fb      	ldr	r3, [r7, #12]
 8004006:	681b      	ldr	r3, [r3, #0]
 8004008:	68db      	ldr	r3, [r3, #12]
 800400a:	f3c3 030a 	ubfx	r3, r3, #0, #11
 800400e:	4413      	add	r3, r2
 8004010:	041b      	lsls	r3, r3, #16
 8004012:	61fb      	str	r3, [r7, #28]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 8004014:	68fb      	ldr	r3, [r7, #12]
 8004016:	681b      	ldr	r3, [r3, #0]
 8004018:	461a      	mov	r2, r3
 800401a:	687b      	ldr	r3, [r7, #4]
 800401c:	01db      	lsls	r3, r3, #7
 800401e:	4413      	add	r3, r2
 8004020:	3384      	adds	r3, #132	; 0x84
 8004022:	689b      	ldr	r3, [r3, #8]
 8004024:	68fa      	ldr	r2, [r7, #12]
 8004026:	6812      	ldr	r2, [r2, #0]
 8004028:	4611      	mov	r1, r2
 800402a:	687a      	ldr	r2, [r7, #4]
 800402c:	01d2      	lsls	r2, r2, #7
 800402e:	440a      	add	r2, r1
 8004030:	3284      	adds	r2, #132	; 0x84
 8004032:	f403 4370 	and.w	r3, r3, #61440	; 0xf000
 8004036:	6093      	str	r3, [r2, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);
 8004038:	68bb      	ldr	r3, [r7, #8]
 800403a:	689a      	ldr	r2, [r3, #8]
 800403c:	68fb      	ldr	r3, [r7, #12]
 800403e:	681b      	ldr	r3, [r3, #0]
 8004040:	68db      	ldr	r3, [r3, #12]
 8004042:	f3c3 030a 	ubfx	r3, r3, #0, #11
 8004046:	4413      	add	r3, r2
 8004048:	1c5a      	adds	r2, r3, #1
 800404a:	68fb      	ldr	r3, [r7, #12]
 800404c:	681b      	ldr	r3, [r3, #0]
 800404e:	4619      	mov	r1, r3
 8004050:	687b      	ldr	r3, [r7, #4]
 8004052:	01db      	lsls	r3, r3, #7
 8004054:	440b      	add	r3, r1
 8004056:	3384      	adds	r3, #132	; 0x84
 8004058:	4619      	mov	r1, r3
 800405a:	69fb      	ldr	r3, [r7, #28]
 800405c:	4313      	orrs	r3, r2
 800405e:	608b      	str	r3, [r1, #8]

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 8004060:	68fb      	ldr	r3, [r7, #12]
 8004062:	681b      	ldr	r3, [r3, #0]
 8004064:	461a      	mov	r2, r3
 8004066:	687b      	ldr	r3, [r7, #4]
 8004068:	01db      	lsls	r3, r3, #7
 800406a:	4413      	add	r3, r2
 800406c:	3384      	adds	r3, #132	; 0x84
 800406e:	691b      	ldr	r3, [r3, #16]
 8004070:	68fa      	ldr	r2, [r7, #12]
 8004072:	6812      	ldr	r2, [r2, #0]
 8004074:	4611      	mov	r1, r2
 8004076:	687a      	ldr	r2, [r7, #4]
 8004078:	01d2      	lsls	r2, r2, #7
 800407a:	440a      	add	r2, r1
 800407c:	3284      	adds	r2, #132	; 0x84
 800407e:	f023 0307 	bic.w	r3, r3, #7
 8004082:	6113      	str	r3, [r2, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8004084:	68fb      	ldr	r3, [r7, #12]
 8004086:	681b      	ldr	r3, [r3, #0]
 8004088:	461a      	mov	r2, r3
 800408a:	687b      	ldr	r3, [r7, #4]
 800408c:	01db      	lsls	r3, r3, #7
 800408e:	4413      	add	r3, r2
 8004090:	3384      	adds	r3, #132	; 0x84
 8004092:	461a      	mov	r2, r3
 8004094:	68bb      	ldr	r3, [r7, #8]
 8004096:	691b      	ldr	r3, [r3, #16]
 8004098:	6113      	str	r3, [r2, #16]

  /* Configure the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 800409a:	68bb      	ldr	r3, [r7, #8]
 800409c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 80040a0:	021b      	lsls	r3, r3, #8
 80040a2:	61fb      	str	r3, [r7, #28]
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 80040a4:	68bb      	ldr	r3, [r7, #8]
 80040a6:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 80040aa:	041b      	lsls	r3, r3, #16
 80040ac:	61bb      	str	r3, [r7, #24]
  tmp2 = (pLayerCfg->Alpha0 << 24U);
 80040ae:	68bb      	ldr	r3, [r7, #8]
 80040b0:	699b      	ldr	r3, [r3, #24]
 80040b2:	061b      	lsls	r3, r3, #24
 80040b4:	617b      	str	r3, [r7, #20]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80040b6:	68fb      	ldr	r3, [r7, #12]
 80040b8:	681b      	ldr	r3, [r3, #0]
 80040ba:	461a      	mov	r2, r3
 80040bc:	687b      	ldr	r3, [r7, #4]
 80040be:	01db      	lsls	r3, r3, #7
 80040c0:	4413      	add	r3, r2
 80040c2:	3384      	adds	r3, #132	; 0x84
 80040c4:	699b      	ldr	r3, [r3, #24]
 80040c6:	68fb      	ldr	r3, [r7, #12]
 80040c8:	681b      	ldr	r3, [r3, #0]
 80040ca:	461a      	mov	r2, r3
 80040cc:	687b      	ldr	r3, [r7, #4]
 80040ce:	01db      	lsls	r3, r3, #7
 80040d0:	4413      	add	r3, r2
 80040d2:	3384      	adds	r3, #132	; 0x84
 80040d4:	461a      	mov	r2, r3
 80040d6:	2300      	movs	r3, #0
 80040d8:	6193      	str	r3, [r2, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2);
 80040da:	68bb      	ldr	r3, [r7, #8]
 80040dc:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80040e0:	461a      	mov	r2, r3
 80040e2:	69fb      	ldr	r3, [r7, #28]
 80040e4:	431a      	orrs	r2, r3
 80040e6:	69bb      	ldr	r3, [r7, #24]
 80040e8:	431a      	orrs	r2, r3
 80040ea:	68fb      	ldr	r3, [r7, #12]
 80040ec:	681b      	ldr	r3, [r3, #0]
 80040ee:	4619      	mov	r1, r3
 80040f0:	687b      	ldr	r3, [r7, #4]
 80040f2:	01db      	lsls	r3, r3, #7
 80040f4:	440b      	add	r3, r1
 80040f6:	3384      	adds	r3, #132	; 0x84
 80040f8:	4619      	mov	r1, r3
 80040fa:	697b      	ldr	r3, [r7, #20]
 80040fc:	4313      	orrs	r3, r2
 80040fe:	618b      	str	r3, [r1, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 8004100:	68fb      	ldr	r3, [r7, #12]
 8004102:	681b      	ldr	r3, [r3, #0]
 8004104:	461a      	mov	r2, r3
 8004106:	687b      	ldr	r3, [r7, #4]
 8004108:	01db      	lsls	r3, r3, #7
 800410a:	4413      	add	r3, r2
 800410c:	3384      	adds	r3, #132	; 0x84
 800410e:	695b      	ldr	r3, [r3, #20]
 8004110:	68fa      	ldr	r2, [r7, #12]
 8004112:	6812      	ldr	r2, [r2, #0]
 8004114:	4611      	mov	r1, r2
 8004116:	687a      	ldr	r2, [r7, #4]
 8004118:	01d2      	lsls	r2, r2, #7
 800411a:	440a      	add	r2, r1
 800411c:	3284      	adds	r2, #132	; 0x84
 800411e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8004122:	6153      	str	r3, [r2, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 8004124:	68fb      	ldr	r3, [r7, #12]
 8004126:	681b      	ldr	r3, [r3, #0]
 8004128:	461a      	mov	r2, r3
 800412a:	687b      	ldr	r3, [r7, #4]
 800412c:	01db      	lsls	r3, r3, #7
 800412e:	4413      	add	r3, r2
 8004130:	3384      	adds	r3, #132	; 0x84
 8004132:	461a      	mov	r2, r3
 8004134:	68bb      	ldr	r3, [r7, #8]
 8004136:	695b      	ldr	r3, [r3, #20]
 8004138:	6153      	str	r3, [r2, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 800413a:	68fb      	ldr	r3, [r7, #12]
 800413c:	681b      	ldr	r3, [r3, #0]
 800413e:	461a      	mov	r2, r3
 8004140:	687b      	ldr	r3, [r7, #4]
 8004142:	01db      	lsls	r3, r3, #7
 8004144:	4413      	add	r3, r2
 8004146:	3384      	adds	r3, #132	; 0x84
 8004148:	69da      	ldr	r2, [r3, #28]
 800414a:	68fb      	ldr	r3, [r7, #12]
 800414c:	681b      	ldr	r3, [r3, #0]
 800414e:	4619      	mov	r1, r3
 8004150:	687b      	ldr	r3, [r7, #4]
 8004152:	01db      	lsls	r3, r3, #7
 8004154:	440b      	add	r3, r1
 8004156:	3384      	adds	r3, #132	; 0x84
 8004158:	4619      	mov	r1, r3
 800415a:	4b58      	ldr	r3, [pc, #352]	; (80042bc <LTDC_SetConfig+0x32c>)
 800415c:	4013      	ands	r3, r2
 800415e:	61cb      	str	r3, [r1, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 8004160:	68bb      	ldr	r3, [r7, #8]
 8004162:	69da      	ldr	r2, [r3, #28]
 8004164:	68bb      	ldr	r3, [r7, #8]
 8004166:	6a1b      	ldr	r3, [r3, #32]
 8004168:	68f9      	ldr	r1, [r7, #12]
 800416a:	6809      	ldr	r1, [r1, #0]
 800416c:	4608      	mov	r0, r1
 800416e:	6879      	ldr	r1, [r7, #4]
 8004170:	01c9      	lsls	r1, r1, #7
 8004172:	4401      	add	r1, r0
 8004174:	3184      	adds	r1, #132	; 0x84
 8004176:	4313      	orrs	r3, r2
 8004178:	61cb      	str	r3, [r1, #28]

  /* Configure the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 800417a:	68fb      	ldr	r3, [r7, #12]
 800417c:	681b      	ldr	r3, [r3, #0]
 800417e:	461a      	mov	r2, r3
 8004180:	687b      	ldr	r3, [r7, #4]
 8004182:	01db      	lsls	r3, r3, #7
 8004184:	4413      	add	r3, r2
 8004186:	3384      	adds	r3, #132	; 0x84
 8004188:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800418a:	68fb      	ldr	r3, [r7, #12]
 800418c:	681b      	ldr	r3, [r3, #0]
 800418e:	461a      	mov	r2, r3
 8004190:	687b      	ldr	r3, [r7, #4]
 8004192:	01db      	lsls	r3, r3, #7
 8004194:	4413      	add	r3, r2
 8004196:	3384      	adds	r3, #132	; 0x84
 8004198:	461a      	mov	r2, r3
 800419a:	2300      	movs	r3, #0
 800419c:	6293      	str	r3, [r2, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 800419e:	68fb      	ldr	r3, [r7, #12]
 80041a0:	681b      	ldr	r3, [r3, #0]
 80041a2:	461a      	mov	r2, r3
 80041a4:	687b      	ldr	r3, [r7, #4]
 80041a6:	01db      	lsls	r3, r3, #7
 80041a8:	4413      	add	r3, r2
 80041aa:	3384      	adds	r3, #132	; 0x84
 80041ac:	461a      	mov	r2, r3
 80041ae:	68bb      	ldr	r3, [r7, #8]
 80041b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80041b2:	6293      	str	r3, [r2, #40]	; 0x28

  if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 80041b4:	68bb      	ldr	r3, [r7, #8]
 80041b6:	691b      	ldr	r3, [r3, #16]
 80041b8:	2b00      	cmp	r3, #0
 80041ba:	d102      	bne.n	80041c2 <LTDC_SetConfig+0x232>
  {
    tmp = 4U;
 80041bc:	2304      	movs	r3, #4
 80041be:	61fb      	str	r3, [r7, #28]
 80041c0:	e01b      	b.n	80041fa <LTDC_SetConfig+0x26a>
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 80041c2:	68bb      	ldr	r3, [r7, #8]
 80041c4:	691b      	ldr	r3, [r3, #16]
 80041c6:	2b01      	cmp	r3, #1
 80041c8:	d102      	bne.n	80041d0 <LTDC_SetConfig+0x240>
  {
    tmp = 3U;
 80041ca:	2303      	movs	r3, #3
 80041cc:	61fb      	str	r3, [r7, #28]
 80041ce:	e014      	b.n	80041fa <LTDC_SetConfig+0x26a>
  }
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 80041d0:	68bb      	ldr	r3, [r7, #8]
 80041d2:	691b      	ldr	r3, [r3, #16]
 80041d4:	2b04      	cmp	r3, #4
 80041d6:	d00b      	beq.n	80041f0 <LTDC_SetConfig+0x260>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
 80041d8:	68bb      	ldr	r3, [r7, #8]
 80041da:	691b      	ldr	r3, [r3, #16]
  else if ((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 80041dc:	2b02      	cmp	r3, #2
 80041de:	d007      	beq.n	80041f0 <LTDC_SetConfig+0x260>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 80041e0:	68bb      	ldr	r3, [r7, #8]
 80041e2:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
 80041e4:	2b03      	cmp	r3, #3
 80041e6:	d003      	beq.n	80041f0 <LTDC_SetConfig+0x260>
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
 80041e8:	68bb      	ldr	r3, [r7, #8]
 80041ea:	691b      	ldr	r3, [r3, #16]
           (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 80041ec:	2b07      	cmp	r3, #7
 80041ee:	d102      	bne.n	80041f6 <LTDC_SetConfig+0x266>
  {
    tmp = 2U;
 80041f0:	2302      	movs	r3, #2
 80041f2:	61fb      	str	r3, [r7, #28]
 80041f4:	e001      	b.n	80041fa <LTDC_SetConfig+0x26a>
  }
  else
  {
    tmp = 1U;
 80041f6:	2301      	movs	r3, #1
 80041f8:	61fb      	str	r3, [r7, #28]
  }

  /* Configure the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 80041fa:	68fb      	ldr	r3, [r7, #12]
 80041fc:	681b      	ldr	r3, [r3, #0]
 80041fe:	461a      	mov	r2, r3
 8004200:	687b      	ldr	r3, [r7, #4]
 8004202:	01db      	lsls	r3, r3, #7
 8004204:	4413      	add	r3, r2
 8004206:	3384      	adds	r3, #132	; 0x84
 8004208:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800420a:	68fa      	ldr	r2, [r7, #12]
 800420c:	6812      	ldr	r2, [r2, #0]
 800420e:	4611      	mov	r1, r2
 8004210:	687a      	ldr	r2, [r7, #4]
 8004212:	01d2      	lsls	r2, r2, #7
 8004214:	440a      	add	r2, r1
 8004216:	3284      	adds	r2, #132	; 0x84
 8004218:	f003 23e0 	and.w	r3, r3, #3758153728	; 0xe000e000
 800421c:	62d3      	str	r3, [r2, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 800421e:	68bb      	ldr	r3, [r7, #8]
 8004220:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004222:	69fa      	ldr	r2, [r7, #28]
 8004224:	fb02 f303 	mul.w	r3, r2, r3
 8004228:	041a      	lsls	r2, r3, #16
 800422a:	68bb      	ldr	r3, [r7, #8]
 800422c:	6859      	ldr	r1, [r3, #4]
 800422e:	68bb      	ldr	r3, [r7, #8]
 8004230:	681b      	ldr	r3, [r3, #0]
 8004232:	1acb      	subs	r3, r1, r3
 8004234:	69f9      	ldr	r1, [r7, #28]
 8004236:	fb01 f303 	mul.w	r3, r1, r3
 800423a:	3303      	adds	r3, #3
 800423c:	68f9      	ldr	r1, [r7, #12]
 800423e:	6809      	ldr	r1, [r1, #0]
 8004240:	4608      	mov	r0, r1
 8004242:	6879      	ldr	r1, [r7, #4]
 8004244:	01c9      	lsls	r1, r1, #7
 8004246:	4401      	add	r1, r0
 8004248:	3184      	adds	r1, #132	; 0x84
 800424a:	4313      	orrs	r3, r2
 800424c:	62cb      	str	r3, [r1, #44]	; 0x2c
  /* Configure the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 800424e:	68fb      	ldr	r3, [r7, #12]
 8004250:	681b      	ldr	r3, [r3, #0]
 8004252:	461a      	mov	r2, r3
 8004254:	687b      	ldr	r3, [r7, #4]
 8004256:	01db      	lsls	r3, r3, #7
 8004258:	4413      	add	r3, r2
 800425a:	3384      	adds	r3, #132	; 0x84
 800425c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800425e:	68fb      	ldr	r3, [r7, #12]
 8004260:	681b      	ldr	r3, [r3, #0]
 8004262:	4619      	mov	r1, r3
 8004264:	687b      	ldr	r3, [r7, #4]
 8004266:	01db      	lsls	r3, r3, #7
 8004268:	440b      	add	r3, r1
 800426a:	3384      	adds	r3, #132	; 0x84
 800426c:	4619      	mov	r1, r3
 800426e:	4b14      	ldr	r3, [pc, #80]	; (80042c0 <LTDC_SetConfig+0x330>)
 8004270:	4013      	ands	r3, r2
 8004272:	630b      	str	r3, [r1, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8004274:	68fb      	ldr	r3, [r7, #12]
 8004276:	681b      	ldr	r3, [r3, #0]
 8004278:	461a      	mov	r2, r3
 800427a:	687b      	ldr	r3, [r7, #4]
 800427c:	01db      	lsls	r3, r3, #7
 800427e:	4413      	add	r3, r2
 8004280:	3384      	adds	r3, #132	; 0x84
 8004282:	461a      	mov	r2, r3
 8004284:	68bb      	ldr	r3, [r7, #8]
 8004286:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004288:	6313      	str	r3, [r2, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 800428a:	68fb      	ldr	r3, [r7, #12]
 800428c:	681b      	ldr	r3, [r3, #0]
 800428e:	461a      	mov	r2, r3
 8004290:	687b      	ldr	r3, [r7, #4]
 8004292:	01db      	lsls	r3, r3, #7
 8004294:	4413      	add	r3, r2
 8004296:	3384      	adds	r3, #132	; 0x84
 8004298:	681b      	ldr	r3, [r3, #0]
 800429a:	68fa      	ldr	r2, [r7, #12]
 800429c:	6812      	ldr	r2, [r2, #0]
 800429e:	4611      	mov	r1, r2
 80042a0:	687a      	ldr	r2, [r7, #4]
 80042a2:	01d2      	lsls	r2, r2, #7
 80042a4:	440a      	add	r2, r1
 80042a6:	3284      	adds	r2, #132	; 0x84
 80042a8:	f043 0301 	orr.w	r3, r3, #1
 80042ac:	6013      	str	r3, [r2, #0]
}
 80042ae:	bf00      	nop
 80042b0:	3724      	adds	r7, #36	; 0x24
 80042b2:	46bd      	mov	sp, r7
 80042b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042b8:	4770      	bx	lr
 80042ba:	bf00      	nop
 80042bc:	fffff8f8 	.word	0xfffff8f8
 80042c0:	fffff800 	.word	0xfffff800

080042c4 <HAL_PWR_EnableBkUpAccess>:
  * @note If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
  *         Backup Domain Access should be kept enabled.
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
 80042c4:	b480      	push	{r7}
 80042c6:	af00      	add	r7, sp, #0
  /* Enable access to RTC and backup registers */
  SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80042c8:	4b05      	ldr	r3, [pc, #20]	; (80042e0 <HAL_PWR_EnableBkUpAccess+0x1c>)
 80042ca:	681b      	ldr	r3, [r3, #0]
 80042cc:	4a04      	ldr	r2, [pc, #16]	; (80042e0 <HAL_PWR_EnableBkUpAccess+0x1c>)
 80042ce:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80042d2:	6013      	str	r3, [r2, #0]
}
 80042d4:	bf00      	nop
 80042d6:	46bd      	mov	sp, r7
 80042d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80042dc:	4770      	bx	lr
 80042de:	bf00      	nop
 80042e0:	40007000 	.word	0x40007000

080042e4 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 80042e4:	b580      	push	{r7, lr}
 80042e6:	b082      	sub	sp, #8
 80042e8:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 80042ea:	2300      	movs	r3, #0
 80042ec:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 80042ee:	4b23      	ldr	r3, [pc, #140]	; (800437c <HAL_PWREx_EnableOverDrive+0x98>)
 80042f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042f2:	4a22      	ldr	r2, [pc, #136]	; (800437c <HAL_PWREx_EnableOverDrive+0x98>)
 80042f4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80042f8:	6413      	str	r3, [r2, #64]	; 0x40
 80042fa:	4b20      	ldr	r3, [pc, #128]	; (800437c <HAL_PWREx_EnableOverDrive+0x98>)
 80042fc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80042fe:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004302:	603b      	str	r3, [r7, #0]
 8004304:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8004306:	4b1e      	ldr	r3, [pc, #120]	; (8004380 <HAL_PWREx_EnableOverDrive+0x9c>)
 8004308:	681b      	ldr	r3, [r3, #0]
 800430a:	4a1d      	ldr	r2, [pc, #116]	; (8004380 <HAL_PWREx_EnableOverDrive+0x9c>)
 800430c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004310:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8004312:	f7fc f987 	bl	8000624 <HAL_GetTick>
 8004316:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8004318:	e009      	b.n	800432e <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 800431a:	f7fc f983 	bl	8000624 <HAL_GetTick>
 800431e:	4602      	mov	r2, r0
 8004320:	687b      	ldr	r3, [r7, #4]
 8004322:	1ad3      	subs	r3, r2, r3
 8004324:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8004328:	d901      	bls.n	800432e <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 800432a:	2303      	movs	r3, #3
 800432c:	e022      	b.n	8004374 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 800432e:	4b14      	ldr	r3, [pc, #80]	; (8004380 <HAL_PWREx_EnableOverDrive+0x9c>)
 8004330:	685b      	ldr	r3, [r3, #4]
 8004332:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004336:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800433a:	d1ee      	bne.n	800431a <HAL_PWREx_EnableOverDrive+0x36>
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 800433c:	4b10      	ldr	r3, [pc, #64]	; (8004380 <HAL_PWREx_EnableOverDrive+0x9c>)
 800433e:	681b      	ldr	r3, [r3, #0]
 8004340:	4a0f      	ldr	r2, [pc, #60]	; (8004380 <HAL_PWREx_EnableOverDrive+0x9c>)
 8004342:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8004346:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8004348:	f7fc f96c 	bl	8000624 <HAL_GetTick>
 800434c:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 800434e:	e009      	b.n	8004364 <HAL_PWREx_EnableOverDrive+0x80>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8004350:	f7fc f968 	bl	8000624 <HAL_GetTick>
 8004354:	4602      	mov	r2, r0
 8004356:	687b      	ldr	r3, [r7, #4]
 8004358:	1ad3      	subs	r3, r2, r3
 800435a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800435e:	d901      	bls.n	8004364 <HAL_PWREx_EnableOverDrive+0x80>
    {
      return HAL_TIMEOUT;
 8004360:	2303      	movs	r3, #3
 8004362:	e007      	b.n	8004374 <HAL_PWREx_EnableOverDrive+0x90>
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8004364:	4b06      	ldr	r3, [pc, #24]	; (8004380 <HAL_PWREx_EnableOverDrive+0x9c>)
 8004366:	685b      	ldr	r3, [r3, #4]
 8004368:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800436c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8004370:	d1ee      	bne.n	8004350 <HAL_PWREx_EnableOverDrive+0x6c>
    }
  } 
  return HAL_OK;
 8004372:	2300      	movs	r3, #0
}
 8004374:	4618      	mov	r0, r3
 8004376:	3708      	adds	r7, #8
 8004378:	46bd      	mov	sp, r7
 800437a:	bd80      	pop	{r7, pc}
 800437c:	40023800 	.word	0x40023800
 8004380:	40007000 	.word	0x40007000

08004384 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8004384:	b580      	push	{r7, lr}
 8004386:	b086      	sub	sp, #24
 8004388:	af00      	add	r7, sp, #0
 800438a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;
  FlagStatus pwrclkchanged = RESET;
 800438c:	2300      	movs	r3, #0
 800438e:	75fb      	strb	r3, [r7, #23]

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8004390:	687b      	ldr	r3, [r7, #4]
 8004392:	2b00      	cmp	r3, #0
 8004394:	d101      	bne.n	800439a <HAL_RCC_OscConfig+0x16>
  {
    return HAL_ERROR;
 8004396:	2301      	movs	r3, #1
 8004398:	e25c      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800439a:	687b      	ldr	r3, [r7, #4]
 800439c:	681b      	ldr	r3, [r3, #0]
 800439e:	f003 0301 	and.w	r3, r3, #1
 80043a2:	2b00      	cmp	r3, #0
 80043a4:	f000 8087 	beq.w	80044b6 <HAL_RCC_OscConfig+0x132>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE)
 80043a8:	4b96      	ldr	r3, [pc, #600]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80043aa:	689b      	ldr	r3, [r3, #8]
 80043ac:	f003 030c 	and.w	r3, r3, #12
 80043b0:	2b04      	cmp	r3, #4
 80043b2:	d00c      	beq.n	80043ce <HAL_RCC_OscConfig+0x4a>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 80043b4:	4b93      	ldr	r3, [pc, #588]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80043b6:	689b      	ldr	r3, [r3, #8]
 80043b8:	f003 030c 	and.w	r3, r3, #12
 80043bc:	2b08      	cmp	r3, #8
 80043be:	d112      	bne.n	80043e6 <HAL_RCC_OscConfig+0x62>
 80043c0:	4b90      	ldr	r3, [pc, #576]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80043c2:	685b      	ldr	r3, [r3, #4]
 80043c4:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80043c8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 80043cc:	d10b      	bne.n	80043e6 <HAL_RCC_OscConfig+0x62>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80043ce:	4b8d      	ldr	r3, [pc, #564]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80043d0:	681b      	ldr	r3, [r3, #0]
 80043d2:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80043d6:	2b00      	cmp	r3, #0
 80043d8:	d06c      	beq.n	80044b4 <HAL_RCC_OscConfig+0x130>
 80043da:	687b      	ldr	r3, [r7, #4]
 80043dc:	685b      	ldr	r3, [r3, #4]
 80043de:	2b00      	cmp	r3, #0
 80043e0:	d168      	bne.n	80044b4 <HAL_RCC_OscConfig+0x130>
      {
        return HAL_ERROR;
 80043e2:	2301      	movs	r3, #1
 80043e4:	e236      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80043e6:	687b      	ldr	r3, [r7, #4]
 80043e8:	685b      	ldr	r3, [r3, #4]
 80043ea:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80043ee:	d106      	bne.n	80043fe <HAL_RCC_OscConfig+0x7a>
 80043f0:	4b84      	ldr	r3, [pc, #528]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80043f2:	681b      	ldr	r3, [r3, #0]
 80043f4:	4a83      	ldr	r2, [pc, #524]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80043f6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80043fa:	6013      	str	r3, [r2, #0]
 80043fc:	e02e      	b.n	800445c <HAL_RCC_OscConfig+0xd8>
 80043fe:	687b      	ldr	r3, [r7, #4]
 8004400:	685b      	ldr	r3, [r3, #4]
 8004402:	2b00      	cmp	r3, #0
 8004404:	d10c      	bne.n	8004420 <HAL_RCC_OscConfig+0x9c>
 8004406:	4b7f      	ldr	r3, [pc, #508]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004408:	681b      	ldr	r3, [r3, #0]
 800440a:	4a7e      	ldr	r2, [pc, #504]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800440c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004410:	6013      	str	r3, [r2, #0]
 8004412:	4b7c      	ldr	r3, [pc, #496]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004414:	681b      	ldr	r3, [r3, #0]
 8004416:	4a7b      	ldr	r2, [pc, #492]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004418:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800441c:	6013      	str	r3, [r2, #0]
 800441e:	e01d      	b.n	800445c <HAL_RCC_OscConfig+0xd8>
 8004420:	687b      	ldr	r3, [r7, #4]
 8004422:	685b      	ldr	r3, [r3, #4]
 8004424:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8004428:	d10c      	bne.n	8004444 <HAL_RCC_OscConfig+0xc0>
 800442a:	4b76      	ldr	r3, [pc, #472]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800442c:	681b      	ldr	r3, [r3, #0]
 800442e:	4a75      	ldr	r2, [pc, #468]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004430:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8004434:	6013      	str	r3, [r2, #0]
 8004436:	4b73      	ldr	r3, [pc, #460]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004438:	681b      	ldr	r3, [r3, #0]
 800443a:	4a72      	ldr	r2, [pc, #456]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800443c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004440:	6013      	str	r3, [r2, #0]
 8004442:	e00b      	b.n	800445c <HAL_RCC_OscConfig+0xd8>
 8004444:	4b6f      	ldr	r3, [pc, #444]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004446:	681b      	ldr	r3, [r3, #0]
 8004448:	4a6e      	ldr	r2, [pc, #440]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800444a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800444e:	6013      	str	r3, [r2, #0]
 8004450:	4b6c      	ldr	r3, [pc, #432]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004452:	681b      	ldr	r3, [r3, #0]
 8004454:	4a6b      	ldr	r2, [pc, #428]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004456:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800445a:	6013      	str	r3, [r2, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800445c:	687b      	ldr	r3, [r7, #4]
 800445e:	685b      	ldr	r3, [r3, #4]
 8004460:	2b00      	cmp	r3, #0
 8004462:	d013      	beq.n	800448c <HAL_RCC_OscConfig+0x108>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004464:	f7fc f8de 	bl	8000624 <HAL_GetTick>
 8004468:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800446a:	e008      	b.n	800447e <HAL_RCC_OscConfig+0xfa>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 800446c:	f7fc f8da 	bl	8000624 <HAL_GetTick>
 8004470:	4602      	mov	r2, r0
 8004472:	693b      	ldr	r3, [r7, #16]
 8004474:	1ad3      	subs	r3, r2, r3
 8004476:	2b64      	cmp	r3, #100	; 0x64
 8004478:	d901      	bls.n	800447e <HAL_RCC_OscConfig+0xfa>
          {
            return HAL_TIMEOUT;
 800447a:	2303      	movs	r3, #3
 800447c:	e1ea      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800447e:	4b61      	ldr	r3, [pc, #388]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004480:	681b      	ldr	r3, [r3, #0]
 8004482:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004486:	2b00      	cmp	r3, #0
 8004488:	d0f0      	beq.n	800446c <HAL_RCC_OscConfig+0xe8>
 800448a:	e014      	b.n	80044b6 <HAL_RCC_OscConfig+0x132>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800448c:	f7fc f8ca 	bl	8000624 <HAL_GetTick>
 8004490:	6138      	str	r0, [r7, #16]

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8004492:	e008      	b.n	80044a6 <HAL_RCC_OscConfig+0x122>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8004494:	f7fc f8c6 	bl	8000624 <HAL_GetTick>
 8004498:	4602      	mov	r2, r0
 800449a:	693b      	ldr	r3, [r7, #16]
 800449c:	1ad3      	subs	r3, r2, r3
 800449e:	2b64      	cmp	r3, #100	; 0x64
 80044a0:	d901      	bls.n	80044a6 <HAL_RCC_OscConfig+0x122>
          {
            return HAL_TIMEOUT;
 80044a2:	2303      	movs	r3, #3
 80044a4:	e1d6      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80044a6:	4b57      	ldr	r3, [pc, #348]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80044a8:	681b      	ldr	r3, [r3, #0]
 80044aa:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80044ae:	2b00      	cmp	r3, #0
 80044b0:	d1f0      	bne.n	8004494 <HAL_RCC_OscConfig+0x110>
 80044b2:	e000      	b.n	80044b6 <HAL_RCC_OscConfig+0x132>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 80044b4:	bf00      	nop
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80044b6:	687b      	ldr	r3, [r7, #4]
 80044b8:	681b      	ldr	r3, [r3, #0]
 80044ba:	f003 0302 	and.w	r3, r3, #2
 80044be:	2b00      	cmp	r3, #0
 80044c0:	d069      	beq.n	8004596 <HAL_RCC_OscConfig+0x212>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI)
 80044c2:	4b50      	ldr	r3, [pc, #320]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80044c4:	689b      	ldr	r3, [r3, #8]
 80044c6:	f003 030c 	and.w	r3, r3, #12
 80044ca:	2b00      	cmp	r3, #0
 80044cc:	d00b      	beq.n	80044e6 <HAL_RCC_OscConfig+0x162>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 80044ce:	4b4d      	ldr	r3, [pc, #308]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80044d0:	689b      	ldr	r3, [r3, #8]
 80044d2:	f003 030c 	and.w	r3, r3, #12
 80044d6:	2b08      	cmp	r3, #8
 80044d8:	d11c      	bne.n	8004514 <HAL_RCC_OscConfig+0x190>
 80044da:	4b4a      	ldr	r3, [pc, #296]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80044dc:	685b      	ldr	r3, [r3, #4]
 80044de:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80044e2:	2b00      	cmp	r3, #0
 80044e4:	d116      	bne.n	8004514 <HAL_RCC_OscConfig+0x190>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 80044e6:	4b47      	ldr	r3, [pc, #284]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80044e8:	681b      	ldr	r3, [r3, #0]
 80044ea:	f003 0302 	and.w	r3, r3, #2
 80044ee:	2b00      	cmp	r3, #0
 80044f0:	d005      	beq.n	80044fe <HAL_RCC_OscConfig+0x17a>
 80044f2:	687b      	ldr	r3, [r7, #4]
 80044f4:	68db      	ldr	r3, [r3, #12]
 80044f6:	2b01      	cmp	r3, #1
 80044f8:	d001      	beq.n	80044fe <HAL_RCC_OscConfig+0x17a>
      {
        return HAL_ERROR;
 80044fa:	2301      	movs	r3, #1
 80044fc:	e1aa      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80044fe:	4b41      	ldr	r3, [pc, #260]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004500:	681b      	ldr	r3, [r3, #0]
 8004502:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8004506:	687b      	ldr	r3, [r7, #4]
 8004508:	691b      	ldr	r3, [r3, #16]
 800450a:	00db      	lsls	r3, r3, #3
 800450c:	493d      	ldr	r1, [pc, #244]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800450e:	4313      	orrs	r3, r2
 8004510:	600b      	str	r3, [r1, #0]
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8004512:	e040      	b.n	8004596 <HAL_RCC_OscConfig+0x212>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8004514:	687b      	ldr	r3, [r7, #4]
 8004516:	68db      	ldr	r3, [r3, #12]
 8004518:	2b00      	cmp	r3, #0
 800451a:	d023      	beq.n	8004564 <HAL_RCC_OscConfig+0x1e0>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800451c:	4b39      	ldr	r3, [pc, #228]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800451e:	681b      	ldr	r3, [r3, #0]
 8004520:	4a38      	ldr	r2, [pc, #224]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004522:	f043 0301 	orr.w	r3, r3, #1
 8004526:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004528:	f7fc f87c 	bl	8000624 <HAL_GetTick>
 800452c:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800452e:	e008      	b.n	8004542 <HAL_RCC_OscConfig+0x1be>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8004530:	f7fc f878 	bl	8000624 <HAL_GetTick>
 8004534:	4602      	mov	r2, r0
 8004536:	693b      	ldr	r3, [r7, #16]
 8004538:	1ad3      	subs	r3, r2, r3
 800453a:	2b02      	cmp	r3, #2
 800453c:	d901      	bls.n	8004542 <HAL_RCC_OscConfig+0x1be>
          {
            return HAL_TIMEOUT;
 800453e:	2303      	movs	r3, #3
 8004540:	e188      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004542:	4b30      	ldr	r3, [pc, #192]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004544:	681b      	ldr	r3, [r3, #0]
 8004546:	f003 0302 	and.w	r3, r3, #2
 800454a:	2b00      	cmp	r3, #0
 800454c:	d0f0      	beq.n	8004530 <HAL_RCC_OscConfig+0x1ac>
          }
        }

        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800454e:	4b2d      	ldr	r3, [pc, #180]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004550:	681b      	ldr	r3, [r3, #0]
 8004552:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8004556:	687b      	ldr	r3, [r7, #4]
 8004558:	691b      	ldr	r3, [r3, #16]
 800455a:	00db      	lsls	r3, r3, #3
 800455c:	4929      	ldr	r1, [pc, #164]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800455e:	4313      	orrs	r3, r2
 8004560:	600b      	str	r3, [r1, #0]
 8004562:	e018      	b.n	8004596 <HAL_RCC_OscConfig+0x212>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8004564:	4b27      	ldr	r3, [pc, #156]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 8004566:	681b      	ldr	r3, [r3, #0]
 8004568:	4a26      	ldr	r2, [pc, #152]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800456a:	f023 0301 	bic.w	r3, r3, #1
 800456e:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004570:	f7fc f858 	bl	8000624 <HAL_GetTick>
 8004574:	6138      	str	r0, [r7, #16]

        /* Wait till HSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8004576:	e008      	b.n	800458a <HAL_RCC_OscConfig+0x206>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8004578:	f7fc f854 	bl	8000624 <HAL_GetTick>
 800457c:	4602      	mov	r2, r0
 800457e:	693b      	ldr	r3, [r7, #16]
 8004580:	1ad3      	subs	r3, r2, r3
 8004582:	2b02      	cmp	r3, #2
 8004584:	d901      	bls.n	800458a <HAL_RCC_OscConfig+0x206>
          {
            return HAL_TIMEOUT;
 8004586:	2303      	movs	r3, #3
 8004588:	e164      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 800458a:	4b1e      	ldr	r3, [pc, #120]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 800458c:	681b      	ldr	r3, [r3, #0]
 800458e:	f003 0302 	and.w	r3, r3, #2
 8004592:	2b00      	cmp	r3, #0
 8004594:	d1f0      	bne.n	8004578 <HAL_RCC_OscConfig+0x1f4>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8004596:	687b      	ldr	r3, [r7, #4]
 8004598:	681b      	ldr	r3, [r3, #0]
 800459a:	f003 0308 	and.w	r3, r3, #8
 800459e:	2b00      	cmp	r3, #0
 80045a0:	d038      	beq.n	8004614 <HAL_RCC_OscConfig+0x290>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80045a2:	687b      	ldr	r3, [r7, #4]
 80045a4:	695b      	ldr	r3, [r3, #20]
 80045a6:	2b00      	cmp	r3, #0
 80045a8:	d019      	beq.n	80045de <HAL_RCC_OscConfig+0x25a>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80045aa:	4b16      	ldr	r3, [pc, #88]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80045ac:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80045ae:	4a15      	ldr	r2, [pc, #84]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80045b0:	f043 0301 	orr.w	r3, r3, #1
 80045b4:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80045b6:	f7fc f835 	bl	8000624 <HAL_GetTick>
 80045ba:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80045bc:	e008      	b.n	80045d0 <HAL_RCC_OscConfig+0x24c>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80045be:	f7fc f831 	bl	8000624 <HAL_GetTick>
 80045c2:	4602      	mov	r2, r0
 80045c4:	693b      	ldr	r3, [r7, #16]
 80045c6:	1ad3      	subs	r3, r2, r3
 80045c8:	2b02      	cmp	r3, #2
 80045ca:	d901      	bls.n	80045d0 <HAL_RCC_OscConfig+0x24c>
        {
          return HAL_TIMEOUT;
 80045cc:	2303      	movs	r3, #3
 80045ce:	e141      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80045d0:	4b0c      	ldr	r3, [pc, #48]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80045d2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80045d4:	f003 0302 	and.w	r3, r3, #2
 80045d8:	2b00      	cmp	r3, #0
 80045da:	d0f0      	beq.n	80045be <HAL_RCC_OscConfig+0x23a>
 80045dc:	e01a      	b.n	8004614 <HAL_RCC_OscConfig+0x290>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 80045de:	4b09      	ldr	r3, [pc, #36]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80045e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80045e2:	4a08      	ldr	r2, [pc, #32]	; (8004604 <HAL_RCC_OscConfig+0x280>)
 80045e4:	f023 0301 	bic.w	r3, r3, #1
 80045e8:	6753      	str	r3, [r2, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80045ea:	f7fc f81b 	bl	8000624 <HAL_GetTick>
 80045ee:	6138      	str	r0, [r7, #16]

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 80045f0:	e00a      	b.n	8004608 <HAL_RCC_OscConfig+0x284>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80045f2:	f7fc f817 	bl	8000624 <HAL_GetTick>
 80045f6:	4602      	mov	r2, r0
 80045f8:	693b      	ldr	r3, [r7, #16]
 80045fa:	1ad3      	subs	r3, r2, r3
 80045fc:	2b02      	cmp	r3, #2
 80045fe:	d903      	bls.n	8004608 <HAL_RCC_OscConfig+0x284>
        {
          return HAL_TIMEOUT;
 8004600:	2303      	movs	r3, #3
 8004602:	e127      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
 8004604:	40023800 	.word	0x40023800
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8004608:	4b94      	ldr	r3, [pc, #592]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 800460a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800460c:	f003 0302 	and.w	r3, r3, #2
 8004610:	2b00      	cmp	r3, #0
 8004612:	d1ee      	bne.n	80045f2 <HAL_RCC_OscConfig+0x26e>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8004614:	687b      	ldr	r3, [r7, #4]
 8004616:	681b      	ldr	r3, [r3, #0]
 8004618:	f003 0304 	and.w	r3, r3, #4
 800461c:	2b00      	cmp	r3, #0
 800461e:	f000 80a4 	beq.w	800476a <HAL_RCC_OscConfig+0x3e6>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8004622:	4b8e      	ldr	r3, [pc, #568]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004624:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004626:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800462a:	2b00      	cmp	r3, #0
 800462c:	d10d      	bne.n	800464a <HAL_RCC_OscConfig+0x2c6>
    {
      /* Enable Power Clock*/
      __HAL_RCC_PWR_CLK_ENABLE();
 800462e:	4b8b      	ldr	r3, [pc, #556]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004630:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004632:	4a8a      	ldr	r2, [pc, #552]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004634:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004638:	6413      	str	r3, [r2, #64]	; 0x40
 800463a:	4b88      	ldr	r3, [pc, #544]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 800463c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800463e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004642:	60fb      	str	r3, [r7, #12]
 8004644:	68fb      	ldr	r3, [r7, #12]
      pwrclkchanged = SET;
 8004646:	2301      	movs	r3, #1
 8004648:	75fb      	strb	r3, [r7, #23]
    }

    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800464a:	4b85      	ldr	r3, [pc, #532]	; (8004860 <HAL_RCC_OscConfig+0x4dc>)
 800464c:	681b      	ldr	r3, [r3, #0]
 800464e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004652:	2b00      	cmp	r3, #0
 8004654:	d118      	bne.n	8004688 <HAL_RCC_OscConfig+0x304>
    {
      /* Enable write access to Backup domain */
      PWR->CR1 |= PWR_CR1_DBP;
 8004656:	4b82      	ldr	r3, [pc, #520]	; (8004860 <HAL_RCC_OscConfig+0x4dc>)
 8004658:	681b      	ldr	r3, [r3, #0]
 800465a:	4a81      	ldr	r2, [pc, #516]	; (8004860 <HAL_RCC_OscConfig+0x4dc>)
 800465c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004660:	6013      	str	r3, [r2, #0]

      /* Wait for Backup domain Write protection disable */
      tickstart = HAL_GetTick();
 8004662:	f7fb ffdf 	bl	8000624 <HAL_GetTick>
 8004666:	6138      	str	r0, [r7, #16]

      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8004668:	e008      	b.n	800467c <HAL_RCC_OscConfig+0x2f8>
      {
        if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 800466a:	f7fb ffdb 	bl	8000624 <HAL_GetTick>
 800466e:	4602      	mov	r2, r0
 8004670:	693b      	ldr	r3, [r7, #16]
 8004672:	1ad3      	subs	r3, r2, r3
 8004674:	2b64      	cmp	r3, #100	; 0x64
 8004676:	d901      	bls.n	800467c <HAL_RCC_OscConfig+0x2f8>
        {
          return HAL_TIMEOUT;
 8004678:	2303      	movs	r3, #3
 800467a:	e0eb      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800467c:	4b78      	ldr	r3, [pc, #480]	; (8004860 <HAL_RCC_OscConfig+0x4dc>)
 800467e:	681b      	ldr	r3, [r3, #0]
 8004680:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004684:	2b00      	cmp	r3, #0
 8004686:	d0f0      	beq.n	800466a <HAL_RCC_OscConfig+0x2e6>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8004688:	687b      	ldr	r3, [r7, #4]
 800468a:	689b      	ldr	r3, [r3, #8]
 800468c:	2b01      	cmp	r3, #1
 800468e:	d106      	bne.n	800469e <HAL_RCC_OscConfig+0x31a>
 8004690:	4b72      	ldr	r3, [pc, #456]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004692:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004694:	4a71      	ldr	r2, [pc, #452]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004696:	f043 0301 	orr.w	r3, r3, #1
 800469a:	6713      	str	r3, [r2, #112]	; 0x70
 800469c:	e02d      	b.n	80046fa <HAL_RCC_OscConfig+0x376>
 800469e:	687b      	ldr	r3, [r7, #4]
 80046a0:	689b      	ldr	r3, [r3, #8]
 80046a2:	2b00      	cmp	r3, #0
 80046a4:	d10c      	bne.n	80046c0 <HAL_RCC_OscConfig+0x33c>
 80046a6:	4b6d      	ldr	r3, [pc, #436]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046a8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046aa:	4a6c      	ldr	r2, [pc, #432]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046ac:	f023 0301 	bic.w	r3, r3, #1
 80046b0:	6713      	str	r3, [r2, #112]	; 0x70
 80046b2:	4b6a      	ldr	r3, [pc, #424]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046b6:	4a69      	ldr	r2, [pc, #420]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046b8:	f023 0304 	bic.w	r3, r3, #4
 80046bc:	6713      	str	r3, [r2, #112]	; 0x70
 80046be:	e01c      	b.n	80046fa <HAL_RCC_OscConfig+0x376>
 80046c0:	687b      	ldr	r3, [r7, #4]
 80046c2:	689b      	ldr	r3, [r3, #8]
 80046c4:	2b05      	cmp	r3, #5
 80046c6:	d10c      	bne.n	80046e2 <HAL_RCC_OscConfig+0x35e>
 80046c8:	4b64      	ldr	r3, [pc, #400]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046ca:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046cc:	4a63      	ldr	r2, [pc, #396]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046ce:	f043 0304 	orr.w	r3, r3, #4
 80046d2:	6713      	str	r3, [r2, #112]	; 0x70
 80046d4:	4b61      	ldr	r3, [pc, #388]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046d6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046d8:	4a60      	ldr	r2, [pc, #384]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046da:	f043 0301 	orr.w	r3, r3, #1
 80046de:	6713      	str	r3, [r2, #112]	; 0x70
 80046e0:	e00b      	b.n	80046fa <HAL_RCC_OscConfig+0x376>
 80046e2:	4b5e      	ldr	r3, [pc, #376]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046e6:	4a5d      	ldr	r2, [pc, #372]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046e8:	f023 0301 	bic.w	r3, r3, #1
 80046ec:	6713      	str	r3, [r2, #112]	; 0x70
 80046ee:	4b5b      	ldr	r3, [pc, #364]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80046f2:	4a5a      	ldr	r2, [pc, #360]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80046f4:	f023 0304 	bic.w	r3, r3, #4
 80046f8:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80046fa:	687b      	ldr	r3, [r7, #4]
 80046fc:	689b      	ldr	r3, [r3, #8]
 80046fe:	2b00      	cmp	r3, #0
 8004700:	d015      	beq.n	800472e <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8004702:	f7fb ff8f 	bl	8000624 <HAL_GetTick>
 8004706:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004708:	e00a      	b.n	8004720 <HAL_RCC_OscConfig+0x39c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800470a:	f7fb ff8b 	bl	8000624 <HAL_GetTick>
 800470e:	4602      	mov	r2, r0
 8004710:	693b      	ldr	r3, [r7, #16]
 8004712:	1ad3      	subs	r3, r2, r3
 8004714:	f241 3288 	movw	r2, #5000	; 0x1388
 8004718:	4293      	cmp	r3, r2
 800471a:	d901      	bls.n	8004720 <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
 800471c:	2303      	movs	r3, #3
 800471e:	e099      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004720:	4b4e      	ldr	r3, [pc, #312]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004722:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004724:	f003 0302 	and.w	r3, r3, #2
 8004728:	2b00      	cmp	r3, #0
 800472a:	d0ee      	beq.n	800470a <HAL_RCC_OscConfig+0x386>
 800472c:	e014      	b.n	8004758 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800472e:	f7fb ff79 	bl	8000624 <HAL_GetTick>
 8004732:	6138      	str	r0, [r7, #16]

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8004734:	e00a      	b.n	800474c <HAL_RCC_OscConfig+0x3c8>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004736:	f7fb ff75 	bl	8000624 <HAL_GetTick>
 800473a:	4602      	mov	r2, r0
 800473c:	693b      	ldr	r3, [r7, #16]
 800473e:	1ad3      	subs	r3, r2, r3
 8004740:	f241 3288 	movw	r2, #5000	; 0x1388
 8004744:	4293      	cmp	r3, r2
 8004746:	d901      	bls.n	800474c <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
 8004748:	2303      	movs	r3, #3
 800474a:	e083      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800474c:	4b43      	ldr	r3, [pc, #268]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 800474e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004750:	f003 0302 	and.w	r3, r3, #2
 8004754:	2b00      	cmp	r3, #0
 8004756:	d1ee      	bne.n	8004736 <HAL_RCC_OscConfig+0x3b2>
        }
      }
    }

    /* Restore clock configuration if changed */
    if(pwrclkchanged == SET)
 8004758:	7dfb      	ldrb	r3, [r7, #23]
 800475a:	2b01      	cmp	r3, #1
 800475c:	d105      	bne.n	800476a <HAL_RCC_OscConfig+0x3e6>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 800475e:	4b3f      	ldr	r3, [pc, #252]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004760:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004762:	4a3e      	ldr	r2, [pc, #248]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004764:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8004768:	6413      	str	r3, [r2, #64]	; 0x40
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800476a:	687b      	ldr	r3, [r7, #4]
 800476c:	699b      	ldr	r3, [r3, #24]
 800476e:	2b00      	cmp	r3, #0
 8004770:	d06f      	beq.n	8004852 <HAL_RCC_OscConfig+0x4ce>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8004772:	4b3a      	ldr	r3, [pc, #232]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004774:	689b      	ldr	r3, [r3, #8]
 8004776:	f003 030c 	and.w	r3, r3, #12
 800477a:	2b08      	cmp	r3, #8
 800477c:	d067      	beq.n	800484e <HAL_RCC_OscConfig+0x4ca>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800477e:	687b      	ldr	r3, [r7, #4]
 8004780:	699b      	ldr	r3, [r3, #24]
 8004782:	2b02      	cmp	r3, #2
 8004784:	d149      	bne.n	800481a <HAL_RCC_OscConfig+0x496>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8004786:	4b35      	ldr	r3, [pc, #212]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004788:	681b      	ldr	r3, [r3, #0]
 800478a:	4a34      	ldr	r2, [pc, #208]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 800478c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004790:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004792:	f7fb ff47 	bl	8000624 <HAL_GetTick>
 8004796:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004798:	e008      	b.n	80047ac <HAL_RCC_OscConfig+0x428>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800479a:	f7fb ff43 	bl	8000624 <HAL_GetTick>
 800479e:	4602      	mov	r2, r0
 80047a0:	693b      	ldr	r3, [r7, #16]
 80047a2:	1ad3      	subs	r3, r2, r3
 80047a4:	2b02      	cmp	r3, #2
 80047a6:	d901      	bls.n	80047ac <HAL_RCC_OscConfig+0x428>
          {
            return HAL_TIMEOUT;
 80047a8:	2303      	movs	r3, #3
 80047aa:	e053      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80047ac:	4b2b      	ldr	r3, [pc, #172]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80047ae:	681b      	ldr	r3, [r3, #0]
 80047b0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80047b4:	2b00      	cmp	r3, #0
 80047b6:	d1f0      	bne.n	800479a <HAL_RCC_OscConfig+0x416>
                             RCC_OscInitStruct->PLL.PLLN,
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ,
                             RCC_OscInitStruct->PLL.PLLR);
#else
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80047b8:	687b      	ldr	r3, [r7, #4]
 80047ba:	69da      	ldr	r2, [r3, #28]
 80047bc:	687b      	ldr	r3, [r7, #4]
 80047be:	6a1b      	ldr	r3, [r3, #32]
 80047c0:	431a      	orrs	r2, r3
 80047c2:	687b      	ldr	r3, [r7, #4]
 80047c4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047c6:	019b      	lsls	r3, r3, #6
 80047c8:	431a      	orrs	r2, r3
 80047ca:	687b      	ldr	r3, [r7, #4]
 80047cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80047ce:	085b      	lsrs	r3, r3, #1
 80047d0:	3b01      	subs	r3, #1
 80047d2:	041b      	lsls	r3, r3, #16
 80047d4:	431a      	orrs	r2, r3
 80047d6:	687b      	ldr	r3, [r7, #4]
 80047d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80047da:	061b      	lsls	r3, r3, #24
 80047dc:	4313      	orrs	r3, r2
 80047de:	4a1f      	ldr	r2, [pc, #124]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80047e0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80047e4:	6053      	str	r3, [r2, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 80047e6:	4b1d      	ldr	r3, [pc, #116]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80047e8:	681b      	ldr	r3, [r3, #0]
 80047ea:	4a1c      	ldr	r2, [pc, #112]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 80047ec:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80047f0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80047f2:	f7fb ff17 	bl	8000624 <HAL_GetTick>
 80047f6:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80047f8:	e008      	b.n	800480c <HAL_RCC_OscConfig+0x488>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80047fa:	f7fb ff13 	bl	8000624 <HAL_GetTick>
 80047fe:	4602      	mov	r2, r0
 8004800:	693b      	ldr	r3, [r7, #16]
 8004802:	1ad3      	subs	r3, r2, r3
 8004804:	2b02      	cmp	r3, #2
 8004806:	d901      	bls.n	800480c <HAL_RCC_OscConfig+0x488>
          {
            return HAL_TIMEOUT;
 8004808:	2303      	movs	r3, #3
 800480a:	e023      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800480c:	4b13      	ldr	r3, [pc, #76]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 800480e:	681b      	ldr	r3, [r3, #0]
 8004810:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004814:	2b00      	cmp	r3, #0
 8004816:	d0f0      	beq.n	80047fa <HAL_RCC_OscConfig+0x476>
 8004818:	e01b      	b.n	8004852 <HAL_RCC_OscConfig+0x4ce>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 800481a:	4b10      	ldr	r3, [pc, #64]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 800481c:	681b      	ldr	r3, [r3, #0]
 800481e:	4a0f      	ldr	r2, [pc, #60]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004820:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004824:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004826:	f7fb fefd 	bl	8000624 <HAL_GetTick>
 800482a:	6138      	str	r0, [r7, #16]

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800482c:	e008      	b.n	8004840 <HAL_RCC_OscConfig+0x4bc>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800482e:	f7fb fef9 	bl	8000624 <HAL_GetTick>
 8004832:	4602      	mov	r2, r0
 8004834:	693b      	ldr	r3, [r7, #16]
 8004836:	1ad3      	subs	r3, r2, r3
 8004838:	2b02      	cmp	r3, #2
 800483a:	d901      	bls.n	8004840 <HAL_RCC_OscConfig+0x4bc>
          {
            return HAL_TIMEOUT;
 800483c:	2303      	movs	r3, #3
 800483e:	e009      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8004840:	4b06      	ldr	r3, [pc, #24]	; (800485c <HAL_RCC_OscConfig+0x4d8>)
 8004842:	681b      	ldr	r3, [r3, #0]
 8004844:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8004848:	2b00      	cmp	r3, #0
 800484a:	d1f0      	bne.n	800482e <HAL_RCC_OscConfig+0x4aa>
 800484c:	e001      	b.n	8004852 <HAL_RCC_OscConfig+0x4ce>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 800484e:	2301      	movs	r3, #1
 8004850:	e000      	b.n	8004854 <HAL_RCC_OscConfig+0x4d0>
    }
  }
  return HAL_OK;
 8004852:	2300      	movs	r3, #0
}
 8004854:	4618      	mov	r0, r3
 8004856:	3718      	adds	r7, #24
 8004858:	46bd      	mov	sp, r7
 800485a:	bd80      	pop	{r7, pc}
 800485c:	40023800 	.word	0x40023800
 8004860:	40007000 	.word	0x40007000

08004864 <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 8004864:	b580      	push	{r7, lr}
 8004866:	b084      	sub	sp, #16
 8004868:	af00      	add	r7, sp, #0
 800486a:	6078      	str	r0, [r7, #4]
 800486c:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 800486e:	2300      	movs	r3, #0
 8004870:	60fb      	str	r3, [r7, #12]

  /* Check Null pointer */
  if(RCC_ClkInitStruct == NULL)
 8004872:	687b      	ldr	r3, [r7, #4]
 8004874:	2b00      	cmp	r3, #0
 8004876:	d101      	bne.n	800487c <HAL_RCC_ClockConfig+0x18>
  {
    return HAL_ERROR;
 8004878:	2301      	movs	r3, #1
 800487a:	e0ce      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY)
     must be correctly programmed according to the frequency of the CPU clock
     (HCLK) and the supply voltage of the device. */

  /* Increasing the CPU frequency */
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800487c:	4b69      	ldr	r3, [pc, #420]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 800487e:	681b      	ldr	r3, [r3, #0]
 8004880:	f003 030f 	and.w	r3, r3, #15
 8004884:	683a      	ldr	r2, [r7, #0]
 8004886:	429a      	cmp	r2, r3
 8004888:	d910      	bls.n	80048ac <HAL_RCC_ClockConfig+0x48>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800488a:	4b66      	ldr	r3, [pc, #408]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 800488c:	681b      	ldr	r3, [r3, #0]
 800488e:	f023 020f 	bic.w	r2, r3, #15
 8004892:	4964      	ldr	r1, [pc, #400]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 8004894:	683b      	ldr	r3, [r7, #0]
 8004896:	4313      	orrs	r3, r2
 8004898:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800489a:	4b62      	ldr	r3, [pc, #392]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 800489c:	681b      	ldr	r3, [r3, #0]
 800489e:	f003 030f 	and.w	r3, r3, #15
 80048a2:	683a      	ldr	r2, [r7, #0]
 80048a4:	429a      	cmp	r2, r3
 80048a6:	d001      	beq.n	80048ac <HAL_RCC_ClockConfig+0x48>
    {
      return HAL_ERROR;
 80048a8:	2301      	movs	r3, #1
 80048aa:	e0b6      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
    }
  }

  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80048ac:	687b      	ldr	r3, [r7, #4]
 80048ae:	681b      	ldr	r3, [r3, #0]
 80048b0:	f003 0302 	and.w	r3, r3, #2
 80048b4:	2b00      	cmp	r3, #0
 80048b6:	d020      	beq.n	80048fa <HAL_RCC_ClockConfig+0x96>
  {
    /* Set the highest APBx dividers in order to ensure that we do not go through
       a non-spec phase whatever we decrease or increase HCLK. */
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80048b8:	687b      	ldr	r3, [r7, #4]
 80048ba:	681b      	ldr	r3, [r3, #0]
 80048bc:	f003 0304 	and.w	r3, r3, #4
 80048c0:	2b00      	cmp	r3, #0
 80048c2:	d005      	beq.n	80048d0 <HAL_RCC_ClockConfig+0x6c>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 80048c4:	4b58      	ldr	r3, [pc, #352]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80048c6:	689b      	ldr	r3, [r3, #8]
 80048c8:	4a57      	ldr	r2, [pc, #348]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80048ca:	f443 53e0 	orr.w	r3, r3, #7168	; 0x1c00
 80048ce:	6093      	str	r3, [r2, #8]
    }

    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80048d0:	687b      	ldr	r3, [r7, #4]
 80048d2:	681b      	ldr	r3, [r3, #0]
 80048d4:	f003 0308 	and.w	r3, r3, #8
 80048d8:	2b00      	cmp	r3, #0
 80048da:	d005      	beq.n	80048e8 <HAL_RCC_ClockConfig+0x84>
    {
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, (RCC_HCLK_DIV16 << 3));
 80048dc:	4b52      	ldr	r3, [pc, #328]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80048de:	689b      	ldr	r3, [r3, #8]
 80048e0:	4a51      	ldr	r2, [pc, #324]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80048e2:	f443 4360 	orr.w	r3, r3, #57344	; 0xe000
 80048e6:	6093      	str	r3, [r2, #8]
    }

    /* Set the new HCLK clock divider */
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80048e8:	4b4f      	ldr	r3, [pc, #316]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80048ea:	689b      	ldr	r3, [r3, #8]
 80048ec:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 80048f0:	687b      	ldr	r3, [r7, #4]
 80048f2:	689b      	ldr	r3, [r3, #8]
 80048f4:	494c      	ldr	r1, [pc, #304]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80048f6:	4313      	orrs	r3, r2
 80048f8:	608b      	str	r3, [r1, #8]
  }

  /*------------------------- SYSCLK Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80048fa:	687b      	ldr	r3, [r7, #4]
 80048fc:	681b      	ldr	r3, [r3, #0]
 80048fe:	f003 0301 	and.w	r3, r3, #1
 8004902:	2b00      	cmp	r3, #0
 8004904:	d040      	beq.n	8004988 <HAL_RCC_ClockConfig+0x124>
  {
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));

    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8004906:	687b      	ldr	r3, [r7, #4]
 8004908:	685b      	ldr	r3, [r3, #4]
 800490a:	2b01      	cmp	r3, #1
 800490c:	d107      	bne.n	800491e <HAL_RCC_ClockConfig+0xba>
    {
      /* Check the HSE ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800490e:	4b46      	ldr	r3, [pc, #280]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 8004910:	681b      	ldr	r3, [r3, #0]
 8004912:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004916:	2b00      	cmp	r3, #0
 8004918:	d115      	bne.n	8004946 <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 800491a:	2301      	movs	r3, #1
 800491c:	e07d      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800491e:	687b      	ldr	r3, [r7, #4]
 8004920:	685b      	ldr	r3, [r3, #4]
 8004922:	2b02      	cmp	r3, #2
 8004924:	d107      	bne.n	8004936 <HAL_RCC_ClockConfig+0xd2>
    {
      /* Check the PLL ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8004926:	4b40      	ldr	r3, [pc, #256]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 8004928:	681b      	ldr	r3, [r3, #0]
 800492a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800492e:	2b00      	cmp	r3, #0
 8004930:	d109      	bne.n	8004946 <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 8004932:	2301      	movs	r3, #1
 8004934:	e071      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8004936:	4b3c      	ldr	r3, [pc, #240]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 8004938:	681b      	ldr	r3, [r3, #0]
 800493a:	f003 0302 	and.w	r3, r3, #2
 800493e:	2b00      	cmp	r3, #0
 8004940:	d101      	bne.n	8004946 <HAL_RCC_ClockConfig+0xe2>
      {
        return HAL_ERROR;
 8004942:	2301      	movs	r3, #1
 8004944:	e069      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
      }
    }

    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8004946:	4b38      	ldr	r3, [pc, #224]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 8004948:	689b      	ldr	r3, [r3, #8]
 800494a:	f023 0203 	bic.w	r2, r3, #3
 800494e:	687b      	ldr	r3, [r7, #4]
 8004950:	685b      	ldr	r3, [r3, #4]
 8004952:	4935      	ldr	r1, [pc, #212]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 8004954:	4313      	orrs	r3, r2
 8004956:	608b      	str	r3, [r1, #8]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004958:	f7fb fe64 	bl	8000624 <HAL_GetTick>
 800495c:	60f8      	str	r0, [r7, #12]

    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800495e:	e00a      	b.n	8004976 <HAL_RCC_ClockConfig+0x112>
    {
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8004960:	f7fb fe60 	bl	8000624 <HAL_GetTick>
 8004964:	4602      	mov	r2, r0
 8004966:	68fb      	ldr	r3, [r7, #12]
 8004968:	1ad3      	subs	r3, r2, r3
 800496a:	f241 3288 	movw	r2, #5000	; 0x1388
 800496e:	4293      	cmp	r3, r2
 8004970:	d901      	bls.n	8004976 <HAL_RCC_ClockConfig+0x112>
      {
        return HAL_TIMEOUT;
 8004972:	2303      	movs	r3, #3
 8004974:	e051      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8004976:	4b2c      	ldr	r3, [pc, #176]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 8004978:	689b      	ldr	r3, [r3, #8]
 800497a:	f003 020c 	and.w	r2, r3, #12
 800497e:	687b      	ldr	r3, [r7, #4]
 8004980:	685b      	ldr	r3, [r3, #4]
 8004982:	009b      	lsls	r3, r3, #2
 8004984:	429a      	cmp	r2, r3
 8004986:	d1eb      	bne.n	8004960 <HAL_RCC_ClockConfig+0xfc>
      }
    }
  }

  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8004988:	4b26      	ldr	r3, [pc, #152]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 800498a:	681b      	ldr	r3, [r3, #0]
 800498c:	f003 030f 	and.w	r3, r3, #15
 8004990:	683a      	ldr	r2, [r7, #0]
 8004992:	429a      	cmp	r2, r3
 8004994:	d210      	bcs.n	80049b8 <HAL_RCC_ClockConfig+0x154>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8004996:	4b23      	ldr	r3, [pc, #140]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 8004998:	681b      	ldr	r3, [r3, #0]
 800499a:	f023 020f 	bic.w	r2, r3, #15
 800499e:	4921      	ldr	r1, [pc, #132]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 80049a0:	683b      	ldr	r3, [r7, #0]
 80049a2:	4313      	orrs	r3, r2
 80049a4:	600b      	str	r3, [r1, #0]

    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80049a6:	4b1f      	ldr	r3, [pc, #124]	; (8004a24 <HAL_RCC_ClockConfig+0x1c0>)
 80049a8:	681b      	ldr	r3, [r3, #0]
 80049aa:	f003 030f 	and.w	r3, r3, #15
 80049ae:	683a      	ldr	r2, [r7, #0]
 80049b0:	429a      	cmp	r2, r3
 80049b2:	d001      	beq.n	80049b8 <HAL_RCC_ClockConfig+0x154>
    {
      return HAL_ERROR;
 80049b4:	2301      	movs	r3, #1
 80049b6:	e030      	b.n	8004a1a <HAL_RCC_ClockConfig+0x1b6>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80049b8:	687b      	ldr	r3, [r7, #4]
 80049ba:	681b      	ldr	r3, [r3, #0]
 80049bc:	f003 0304 	and.w	r3, r3, #4
 80049c0:	2b00      	cmp	r3, #0
 80049c2:	d008      	beq.n	80049d6 <HAL_RCC_ClockConfig+0x172>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80049c4:	4b18      	ldr	r3, [pc, #96]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80049c6:	689b      	ldr	r3, [r3, #8]
 80049c8:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 80049cc:	687b      	ldr	r3, [r7, #4]
 80049ce:	68db      	ldr	r3, [r3, #12]
 80049d0:	4915      	ldr	r1, [pc, #84]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80049d2:	4313      	orrs	r3, r2
 80049d4:	608b      	str	r3, [r1, #8]
  }

  /*-------------------------- PCLK2 Configuration ---------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80049d6:	687b      	ldr	r3, [r7, #4]
 80049d8:	681b      	ldr	r3, [r3, #0]
 80049da:	f003 0308 	and.w	r3, r3, #8
 80049de:	2b00      	cmp	r3, #0
 80049e0:	d009      	beq.n	80049f6 <HAL_RCC_ClockConfig+0x192>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 80049e2:	4b11      	ldr	r3, [pc, #68]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80049e4:	689b      	ldr	r3, [r3, #8]
 80049e6:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 80049ea:	687b      	ldr	r3, [r7, #4]
 80049ec:	691b      	ldr	r3, [r3, #16]
 80049ee:	00db      	lsls	r3, r3, #3
 80049f0:	490d      	ldr	r1, [pc, #52]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80049f2:	4313      	orrs	r3, r2
 80049f4:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_Pos];
 80049f6:	f000 f81d 	bl	8004a34 <HAL_RCC_GetSysClockFreq>
 80049fa:	4601      	mov	r1, r0
 80049fc:	4b0a      	ldr	r3, [pc, #40]	; (8004a28 <HAL_RCC_ClockConfig+0x1c4>)
 80049fe:	689b      	ldr	r3, [r3, #8]
 8004a00:	091b      	lsrs	r3, r3, #4
 8004a02:	f003 030f 	and.w	r3, r3, #15
 8004a06:	4a09      	ldr	r2, [pc, #36]	; (8004a2c <HAL_RCC_ClockConfig+0x1c8>)
 8004a08:	5cd3      	ldrb	r3, [r2, r3]
 8004a0a:	fa21 f303 	lsr.w	r3, r1, r3
 8004a0e:	4a08      	ldr	r2, [pc, #32]	; (8004a30 <HAL_RCC_ClockConfig+0x1cc>)
 8004a10:	6013      	str	r3, [r2, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 8004a12:	2000      	movs	r0, #0
 8004a14:	f005 fc3a 	bl	800a28c <HAL_InitTick>

  return HAL_OK;
 8004a18:	2300      	movs	r3, #0
}
 8004a1a:	4618      	mov	r0, r3
 8004a1c:	3710      	adds	r7, #16
 8004a1e:	46bd      	mov	sp, r7
 8004a20:	bd80      	pop	{r7, pc}
 8004a22:	bf00      	nop
 8004a24:	40023c00 	.word	0x40023c00
 8004a28:	40023800 	.word	0x40023800
 8004a2c:	0802914c 	.word	0x0802914c
 8004a30:	20000004 	.word	0x20000004

08004a34 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8004a34:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004a36:	b085      	sub	sp, #20
 8004a38:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 8004a3a:	2300      	movs	r3, #0
 8004a3c:	607b      	str	r3, [r7, #4]
 8004a3e:	2300      	movs	r3, #0
 8004a40:	60fb      	str	r3, [r7, #12]
 8004a42:	2300      	movs	r3, #0
 8004a44:	603b      	str	r3, [r7, #0]
  uint32_t sysclockfreq = 0;
 8004a46:	2300      	movs	r3, #0
 8004a48:	60bb      	str	r3, [r7, #8]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8004a4a:	4b50      	ldr	r3, [pc, #320]	; (8004b8c <HAL_RCC_GetSysClockFreq+0x158>)
 8004a4c:	689b      	ldr	r3, [r3, #8]
 8004a4e:	f003 030c 	and.w	r3, r3, #12
 8004a52:	2b04      	cmp	r3, #4
 8004a54:	d007      	beq.n	8004a66 <HAL_RCC_GetSysClockFreq+0x32>
 8004a56:	2b08      	cmp	r3, #8
 8004a58:	d008      	beq.n	8004a6c <HAL_RCC_GetSysClockFreq+0x38>
 8004a5a:	2b00      	cmp	r3, #0
 8004a5c:	f040 808d 	bne.w	8004b7a <HAL_RCC_GetSysClockFreq+0x146>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8004a60:	4b4b      	ldr	r3, [pc, #300]	; (8004b90 <HAL_RCC_GetSysClockFreq+0x15c>)
 8004a62:	60bb      	str	r3, [r7, #8]
       break;
 8004a64:	e08c      	b.n	8004b80 <HAL_RCC_GetSysClockFreq+0x14c>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 8004a66:	4b4b      	ldr	r3, [pc, #300]	; (8004b94 <HAL_RCC_GetSysClockFreq+0x160>)
 8004a68:	60bb      	str	r3, [r7, #8]
      break;
 8004a6a:	e089      	b.n	8004b80 <HAL_RCC_GetSysClockFreq+0x14c>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8004a6c:	4b47      	ldr	r3, [pc, #284]	; (8004b8c <HAL_RCC_GetSysClockFreq+0x158>)
 8004a6e:	685b      	ldr	r3, [r3, #4]
 8004a70:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8004a74:	607b      	str	r3, [r7, #4]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 8004a76:	4b45      	ldr	r3, [pc, #276]	; (8004b8c <HAL_RCC_GetSysClockFreq+0x158>)
 8004a78:	685b      	ldr	r3, [r3, #4]
 8004a7a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8004a7e:	2b00      	cmp	r3, #0
 8004a80:	d023      	beq.n	8004aca <HAL_RCC_GetSysClockFreq+0x96>
      {
        /* HSE used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSE_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004a82:	4b42      	ldr	r3, [pc, #264]	; (8004b8c <HAL_RCC_GetSysClockFreq+0x158>)
 8004a84:	685b      	ldr	r3, [r3, #4]
 8004a86:	099b      	lsrs	r3, r3, #6
 8004a88:	f04f 0400 	mov.w	r4, #0
 8004a8c:	f240 11ff 	movw	r1, #511	; 0x1ff
 8004a90:	f04f 0200 	mov.w	r2, #0
 8004a94:	ea03 0501 	and.w	r5, r3, r1
 8004a98:	ea04 0602 	and.w	r6, r4, r2
 8004a9c:	4a3d      	ldr	r2, [pc, #244]	; (8004b94 <HAL_RCC_GetSysClockFreq+0x160>)
 8004a9e:	fb02 f106 	mul.w	r1, r2, r6
 8004aa2:	2200      	movs	r2, #0
 8004aa4:	fb02 f205 	mul.w	r2, r2, r5
 8004aa8:	440a      	add	r2, r1
 8004aaa:	493a      	ldr	r1, [pc, #232]	; (8004b94 <HAL_RCC_GetSysClockFreq+0x160>)
 8004aac:	fba5 0101 	umull	r0, r1, r5, r1
 8004ab0:	1853      	adds	r3, r2, r1
 8004ab2:	4619      	mov	r1, r3
 8004ab4:	687b      	ldr	r3, [r7, #4]
 8004ab6:	f04f 0400 	mov.w	r4, #0
 8004aba:	461a      	mov	r2, r3
 8004abc:	4623      	mov	r3, r4
 8004abe:	f7fb fc0f 	bl	80002e0 <__aeabi_uldivmod>
 8004ac2:	4603      	mov	r3, r0
 8004ac4:	460c      	mov	r4, r1
 8004ac6:	60fb      	str	r3, [r7, #12]
 8004ac8:	e049      	b.n	8004b5e <HAL_RCC_GetSysClockFreq+0x12a>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = (uint32_t) ((((uint64_t) HSI_VALUE * ((uint64_t) ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)))) / (uint64_t)pllm);
 8004aca:	4b30      	ldr	r3, [pc, #192]	; (8004b8c <HAL_RCC_GetSysClockFreq+0x158>)
 8004acc:	685b      	ldr	r3, [r3, #4]
 8004ace:	099b      	lsrs	r3, r3, #6
 8004ad0:	f04f 0400 	mov.w	r4, #0
 8004ad4:	f240 11ff 	movw	r1, #511	; 0x1ff
 8004ad8:	f04f 0200 	mov.w	r2, #0
 8004adc:	ea03 0501 	and.w	r5, r3, r1
 8004ae0:	ea04 0602 	and.w	r6, r4, r2
 8004ae4:	4629      	mov	r1, r5
 8004ae6:	4632      	mov	r2, r6
 8004ae8:	f04f 0300 	mov.w	r3, #0
 8004aec:	f04f 0400 	mov.w	r4, #0
 8004af0:	0154      	lsls	r4, r2, #5
 8004af2:	ea44 64d1 	orr.w	r4, r4, r1, lsr #27
 8004af6:	014b      	lsls	r3, r1, #5
 8004af8:	4619      	mov	r1, r3
 8004afa:	4622      	mov	r2, r4
 8004afc:	1b49      	subs	r1, r1, r5
 8004afe:	eb62 0206 	sbc.w	r2, r2, r6
 8004b02:	f04f 0300 	mov.w	r3, #0
 8004b06:	f04f 0400 	mov.w	r4, #0
 8004b0a:	0194      	lsls	r4, r2, #6
 8004b0c:	ea44 6491 	orr.w	r4, r4, r1, lsr #26
 8004b10:	018b      	lsls	r3, r1, #6
 8004b12:	1a5b      	subs	r3, r3, r1
 8004b14:	eb64 0402 	sbc.w	r4, r4, r2
 8004b18:	f04f 0100 	mov.w	r1, #0
 8004b1c:	f04f 0200 	mov.w	r2, #0
 8004b20:	00e2      	lsls	r2, r4, #3
 8004b22:	ea42 7253 	orr.w	r2, r2, r3, lsr #29
 8004b26:	00d9      	lsls	r1, r3, #3
 8004b28:	460b      	mov	r3, r1
 8004b2a:	4614      	mov	r4, r2
 8004b2c:	195b      	adds	r3, r3, r5
 8004b2e:	eb44 0406 	adc.w	r4, r4, r6
 8004b32:	f04f 0100 	mov.w	r1, #0
 8004b36:	f04f 0200 	mov.w	r2, #0
 8004b3a:	02a2      	lsls	r2, r4, #10
 8004b3c:	ea42 5293 	orr.w	r2, r2, r3, lsr #22
 8004b40:	0299      	lsls	r1, r3, #10
 8004b42:	460b      	mov	r3, r1
 8004b44:	4614      	mov	r4, r2
 8004b46:	4618      	mov	r0, r3
 8004b48:	4621      	mov	r1, r4
 8004b4a:	687b      	ldr	r3, [r7, #4]
 8004b4c:	f04f 0400 	mov.w	r4, #0
 8004b50:	461a      	mov	r2, r3
 8004b52:	4623      	mov	r3, r4
 8004b54:	f7fb fbc4 	bl	80002e0 <__aeabi_uldivmod>
 8004b58:	4603      	mov	r3, r0
 8004b5a:	460c      	mov	r4, r1
 8004b5c:	60fb      	str	r3, [r7, #12]
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> RCC_PLLCFGR_PLLP_Pos) + 1 ) *2);
 8004b5e:	4b0b      	ldr	r3, [pc, #44]	; (8004b8c <HAL_RCC_GetSysClockFreq+0x158>)
 8004b60:	685b      	ldr	r3, [r3, #4]
 8004b62:	0c1b      	lsrs	r3, r3, #16
 8004b64:	f003 0303 	and.w	r3, r3, #3
 8004b68:	3301      	adds	r3, #1
 8004b6a:	005b      	lsls	r3, r3, #1
 8004b6c:	603b      	str	r3, [r7, #0]

      sysclockfreq = pllvco/pllp;
 8004b6e:	68fa      	ldr	r2, [r7, #12]
 8004b70:	683b      	ldr	r3, [r7, #0]
 8004b72:	fbb2 f3f3 	udiv	r3, r2, r3
 8004b76:	60bb      	str	r3, [r7, #8]
      break;
 8004b78:	e002      	b.n	8004b80 <HAL_RCC_GetSysClockFreq+0x14c>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 8004b7a:	4b05      	ldr	r3, [pc, #20]	; (8004b90 <HAL_RCC_GetSysClockFreq+0x15c>)
 8004b7c:	60bb      	str	r3, [r7, #8]
      break;
 8004b7e:	bf00      	nop
    }
  }
  return sysclockfreq;
 8004b80:	68bb      	ldr	r3, [r7, #8]
}
 8004b82:	4618      	mov	r0, r3
 8004b84:	3714      	adds	r7, #20
 8004b86:	46bd      	mov	sp, r7
 8004b88:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004b8a:	bf00      	nop
 8004b8c:	40023800 	.word	0x40023800
 8004b90:	00f42400 	.word	0x00f42400
 8004b94:	017d7840 	.word	0x017d7840

08004b98 <HAL_RCC_GetHCLKFreq>:
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect.
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8004b98:	b480      	push	{r7}
 8004b9a:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 8004b9c:	4b03      	ldr	r3, [pc, #12]	; (8004bac <HAL_RCC_GetHCLKFreq+0x14>)
 8004b9e:	681b      	ldr	r3, [r3, #0]
}
 8004ba0:	4618      	mov	r0, r3
 8004ba2:	46bd      	mov	sp, r7
 8004ba4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004ba8:	4770      	bx	lr
 8004baa:	bf00      	nop
 8004bac:	20000004 	.word	0x20000004

08004bb0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8004bb0:	b580      	push	{r7, lr}
 8004bb2:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> RCC_CFGR_PPRE1_Pos]);
 8004bb4:	f7ff fff0 	bl	8004b98 <HAL_RCC_GetHCLKFreq>
 8004bb8:	4601      	mov	r1, r0
 8004bba:	4b05      	ldr	r3, [pc, #20]	; (8004bd0 <HAL_RCC_GetPCLK1Freq+0x20>)
 8004bbc:	689b      	ldr	r3, [r3, #8]
 8004bbe:	0a9b      	lsrs	r3, r3, #10
 8004bc0:	f003 0307 	and.w	r3, r3, #7
 8004bc4:	4a03      	ldr	r2, [pc, #12]	; (8004bd4 <HAL_RCC_GetPCLK1Freq+0x24>)
 8004bc6:	5cd3      	ldrb	r3, [r2, r3]
 8004bc8:	fa21 f303 	lsr.w	r3, r1, r3
}
 8004bcc:	4618      	mov	r0, r3
 8004bce:	bd80      	pop	{r7, pc}
 8004bd0:	40023800 	.word	0x40023800
 8004bd4:	0802915c 	.word	0x0802915c

08004bd8 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
 8004bd8:	b580      	push	{r7, lr}
 8004bda:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> RCC_CFGR_PPRE2_Pos]);
 8004bdc:	f7ff ffdc 	bl	8004b98 <HAL_RCC_GetHCLKFreq>
 8004be0:	4601      	mov	r1, r0
 8004be2:	4b05      	ldr	r3, [pc, #20]	; (8004bf8 <HAL_RCC_GetPCLK2Freq+0x20>)
 8004be4:	689b      	ldr	r3, [r3, #8]
 8004be6:	0b5b      	lsrs	r3, r3, #13
 8004be8:	f003 0307 	and.w	r3, r3, #7
 8004bec:	4a03      	ldr	r2, [pc, #12]	; (8004bfc <HAL_RCC_GetPCLK2Freq+0x24>)
 8004bee:	5cd3      	ldrb	r3, [r2, r3]
 8004bf0:	fa21 f303 	lsr.w	r3, r1, r3
}
 8004bf4:	4618      	mov	r0, r3
 8004bf6:	bd80      	pop	{r7, pc}
 8004bf8:	40023800 	.word	0x40023800
 8004bfc:	0802915c 	.word	0x0802915c

08004c00 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8004c00:	b480      	push	{r7}
 8004c02:	b083      	sub	sp, #12
 8004c04:	af00      	add	r7, sp, #0
 8004c06:	6078      	str	r0, [r7, #4]
 8004c08:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 8004c0a:	687b      	ldr	r3, [r7, #4]
 8004c0c:	220f      	movs	r2, #15
 8004c0e:	601a      	str	r2, [r3, #0]

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8004c10:	4b12      	ldr	r3, [pc, #72]	; (8004c5c <HAL_RCC_GetClockConfig+0x5c>)
 8004c12:	689b      	ldr	r3, [r3, #8]
 8004c14:	f003 0203 	and.w	r2, r3, #3
 8004c18:	687b      	ldr	r3, [r7, #4]
 8004c1a:	605a      	str	r2, [r3, #4]

  /* Get the HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE);
 8004c1c:	4b0f      	ldr	r3, [pc, #60]	; (8004c5c <HAL_RCC_GetClockConfig+0x5c>)
 8004c1e:	689b      	ldr	r3, [r3, #8]
 8004c20:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8004c24:	687b      	ldr	r3, [r7, #4]
 8004c26:	609a      	str	r2, [r3, #8]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);
 8004c28:	4b0c      	ldr	r3, [pc, #48]	; (8004c5c <HAL_RCC_GetClockConfig+0x5c>)
 8004c2a:	689b      	ldr	r3, [r3, #8]
 8004c2c:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 8004c30:	687b      	ldr	r3, [r7, #4]
 8004c32:	60da      	str	r2, [r3, #12]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8004c34:	4b09      	ldr	r3, [pc, #36]	; (8004c5c <HAL_RCC_GetClockConfig+0x5c>)
 8004c36:	689b      	ldr	r3, [r3, #8]
 8004c38:	08db      	lsrs	r3, r3, #3
 8004c3a:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 8004c3e:	687b      	ldr	r3, [r7, #4]
 8004c40:	611a      	str	r2, [r3, #16]

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 8004c42:	4b07      	ldr	r3, [pc, #28]	; (8004c60 <HAL_RCC_GetClockConfig+0x60>)
 8004c44:	681b      	ldr	r3, [r3, #0]
 8004c46:	f003 020f 	and.w	r2, r3, #15
 8004c4a:	683b      	ldr	r3, [r7, #0]
 8004c4c:	601a      	str	r2, [r3, #0]
}
 8004c4e:	bf00      	nop
 8004c50:	370c      	adds	r7, #12
 8004c52:	46bd      	mov	sp, r7
 8004c54:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004c58:	4770      	bx	lr
 8004c5a:	bf00      	nop
 8004c5c:	40023800 	.word	0x40023800
 8004c60:	40023c00 	.word	0x40023c00

08004c64 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8004c64:	b580      	push	{r7, lr}
 8004c66:	b088      	sub	sp, #32
 8004c68:	af00      	add	r7, sp, #0
 8004c6a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8004c6c:	2300      	movs	r3, #0
 8004c6e:	617b      	str	r3, [r7, #20]
  uint32_t tmpreg0 = 0;
 8004c70:	2300      	movs	r3, #0
 8004c72:	613b      	str	r3, [r7, #16]
  uint32_t tmpreg1 = 0;
 8004c74:	2300      	movs	r3, #0
 8004c76:	60fb      	str	r3, [r7, #12]
  uint32_t plli2sused = 0;
 8004c78:	2300      	movs	r3, #0
 8004c7a:	61fb      	str	r3, [r7, #28]
  uint32_t pllsaiused = 0;
 8004c7c:	2300      	movs	r3, #0
 8004c7e:	61bb      	str	r3, [r7, #24]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8004c80:	687b      	ldr	r3, [r7, #4]
 8004c82:	681b      	ldr	r3, [r3, #0]
 8004c84:	f003 0301 	and.w	r3, r3, #1
 8004c88:	2b00      	cmp	r3, #0
 8004c8a:	d012      	beq.n	8004cb2 <HAL_RCCEx_PeriphCLKConfig+0x4e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8004c8c:	4b69      	ldr	r3, [pc, #420]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004c8e:	689b      	ldr	r3, [r3, #8]
 8004c90:	4a68      	ldr	r2, [pc, #416]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004c92:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8004c96:	6093      	str	r3, [r2, #8]
 8004c98:	4b66      	ldr	r3, [pc, #408]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004c9a:	689a      	ldr	r2, [r3, #8]
 8004c9c:	687b      	ldr	r3, [r7, #4]
 8004c9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004ca0:	4964      	ldr	r1, [pc, #400]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004ca2:	4313      	orrs	r3, r2
 8004ca4:	608b      	str	r3, [r1, #8]

    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 8004ca6:	687b      	ldr	r3, [r7, #4]
 8004ca8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8004caa:	2b00      	cmp	r3, #0
 8004cac:	d101      	bne.n	8004cb2 <HAL_RCCEx_PeriphCLKConfig+0x4e>
    {
      plli2sused = 1;
 8004cae:	2301      	movs	r3, #1
 8004cb0:	61fb      	str	r3, [r7, #28]
    }
  }

  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 8004cb2:	687b      	ldr	r3, [r7, #4]
 8004cb4:	681b      	ldr	r3, [r3, #0]
 8004cb6:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8004cba:	2b00      	cmp	r3, #0
 8004cbc:	d017      	beq.n	8004cee <HAL_RCCEx_PeriphCLKConfig+0x8a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8004cbe:	4b5d      	ldr	r3, [pc, #372]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004cc0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004cc4:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8004cc8:	687b      	ldr	r3, [r7, #4]
 8004cca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004ccc:	4959      	ldr	r1, [pc, #356]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004cce:	4313      	orrs	r3, r2
 8004cd0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 8004cd4:	687b      	ldr	r3, [r7, #4]
 8004cd6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004cd8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8004cdc:	d101      	bne.n	8004ce2 <HAL_RCCEx_PeriphCLKConfig+0x7e>
    {
      plli2sused = 1;
 8004cde:	2301      	movs	r3, #1
 8004ce0:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 8004ce2:	687b      	ldr	r3, [r7, #4]
 8004ce4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004ce6:	2b00      	cmp	r3, #0
 8004ce8:	d101      	bne.n	8004cee <HAL_RCCEx_PeriphCLKConfig+0x8a>
    {
      pllsaiused = 1;
 8004cea:	2301      	movs	r3, #1
 8004cec:	61bb      	str	r3, [r7, #24]
    }
  }

  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 8004cee:	687b      	ldr	r3, [r7, #4]
 8004cf0:	681b      	ldr	r3, [r3, #0]
 8004cf2:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8004cf6:	2b00      	cmp	r3, #0
 8004cf8:	d017      	beq.n	8004d2a <HAL_RCCEx_PeriphCLKConfig+0xc6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8004cfa:	4b4e      	ldr	r3, [pc, #312]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004cfc:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004d00:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8004d04:	687b      	ldr	r3, [r7, #4]
 8004d06:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d08:	494a      	ldr	r1, [pc, #296]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004d0a:	4313      	orrs	r3, r2
 8004d0c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c

    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8004d10:	687b      	ldr	r3, [r7, #4]
 8004d12:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d14:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8004d18:	d101      	bne.n	8004d1e <HAL_RCCEx_PeriphCLKConfig+0xba>
    {
      plli2sused = 1;
 8004d1a:	2301      	movs	r3, #1
 8004d1c:	61fb      	str	r3, [r7, #28]
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
 8004d1e:	687b      	ldr	r3, [r7, #4]
 8004d20:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d22:	2b00      	cmp	r3, #0
 8004d24:	d101      	bne.n	8004d2a <HAL_RCCEx_PeriphCLKConfig+0xc6>
    {
      pllsaiused = 1;
 8004d26:	2301      	movs	r3, #1
 8004d28:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8004d2a:	687b      	ldr	r3, [r7, #4]
 8004d2c:	681b      	ldr	r3, [r3, #0]
 8004d2e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8004d32:	2b00      	cmp	r3, #0
 8004d34:	d001      	beq.n	8004d3a <HAL_RCCEx_PeriphCLKConfig+0xd6>
  {
      plli2sused = 1;
 8004d36:	2301      	movs	r3, #1
 8004d38:	61fb      	str	r3, [r7, #28]
  }

  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8004d3a:	687b      	ldr	r3, [r7, #4]
 8004d3c:	681b      	ldr	r3, [r3, #0]
 8004d3e:	f003 0320 	and.w	r3, r3, #32
 8004d42:	2b00      	cmp	r3, #0
 8004d44:	f000 808b 	beq.w	8004e5e <HAL_RCCEx_PeriphCLKConfig+0x1fa>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8004d48:	4b3a      	ldr	r3, [pc, #232]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004d4a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d4c:	4a39      	ldr	r2, [pc, #228]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004d4e:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004d52:	6413      	str	r3, [r2, #64]	; 0x40
 8004d54:	4b37      	ldr	r3, [pc, #220]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004d56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d58:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8004d5c:	60bb      	str	r3, [r7, #8]
 8004d5e:	68bb      	ldr	r3, [r7, #8]

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8004d60:	4b35      	ldr	r3, [pc, #212]	; (8004e38 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8004d62:	681b      	ldr	r3, [r3, #0]
 8004d64:	4a34      	ldr	r2, [pc, #208]	; (8004e38 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8004d66:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004d6a:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8004d6c:	f7fb fc5a 	bl	8000624 <HAL_GetTick>
 8004d70:	6178      	str	r0, [r7, #20]

    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8004d72:	e008      	b.n	8004d86 <HAL_RCCEx_PeriphCLKConfig+0x122>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8004d74:	f7fb fc56 	bl	8000624 <HAL_GetTick>
 8004d78:	4602      	mov	r2, r0
 8004d7a:	697b      	ldr	r3, [r7, #20]
 8004d7c:	1ad3      	subs	r3, r2, r3
 8004d7e:	2b64      	cmp	r3, #100	; 0x64
 8004d80:	d901      	bls.n	8004d86 <HAL_RCCEx_PeriphCLKConfig+0x122>
      {
        return HAL_TIMEOUT;
 8004d82:	2303      	movs	r3, #3
 8004d84:	e355      	b.n	8005432 <HAL_RCCEx_PeriphCLKConfig+0x7ce>
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8004d86:	4b2c      	ldr	r3, [pc, #176]	; (8004e38 <HAL_RCCEx_PeriphCLKConfig+0x1d4>)
 8004d88:	681b      	ldr	r3, [r3, #0]
 8004d8a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004d8e:	2b00      	cmp	r3, #0
 8004d90:	d0f0      	beq.n	8004d74 <HAL_RCCEx_PeriphCLKConfig+0x110>
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8004d92:	4b28      	ldr	r3, [pc, #160]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004d94:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004d96:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004d9a:	613b      	str	r3, [r7, #16]

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8004d9c:	693b      	ldr	r3, [r7, #16]
 8004d9e:	2b00      	cmp	r3, #0
 8004da0:	d035      	beq.n	8004e0e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
 8004da2:	687b      	ldr	r3, [r7, #4]
 8004da4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004da6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004daa:	693a      	ldr	r2, [r7, #16]
 8004dac:	429a      	cmp	r2, r3
 8004dae:	d02e      	beq.n	8004e0e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8004db0:	4b20      	ldr	r3, [pc, #128]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004db2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004db4:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8004db8:	613b      	str	r3, [r7, #16]

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8004dba:	4b1e      	ldr	r3, [pc, #120]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004dbc:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004dbe:	4a1d      	ldr	r2, [pc, #116]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004dc0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004dc4:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8004dc6:	4b1b      	ldr	r3, [pc, #108]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004dc8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004dca:	4a1a      	ldr	r2, [pc, #104]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004dcc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8004dd0:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
 8004dd2:	4a18      	ldr	r2, [pc, #96]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004dd4:	693b      	ldr	r3, [r7, #16]
 8004dd6:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8004dd8:	4b16      	ldr	r3, [pc, #88]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004dda:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004ddc:	f003 0301 	and.w	r3, r3, #1
 8004de0:	2b01      	cmp	r3, #1
 8004de2:	d114      	bne.n	8004e0e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8004de4:	f7fb fc1e 	bl	8000624 <HAL_GetTick>
 8004de8:	6178      	str	r0, [r7, #20]

        /* Wait till LSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004dea:	e00a      	b.n	8004e02 <HAL_RCCEx_PeriphCLKConfig+0x19e>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8004dec:	f7fb fc1a 	bl	8000624 <HAL_GetTick>
 8004df0:	4602      	mov	r2, r0
 8004df2:	697b      	ldr	r3, [r7, #20]
 8004df4:	1ad3      	subs	r3, r2, r3
 8004df6:	f241 3288 	movw	r2, #5000	; 0x1388
 8004dfa:	4293      	cmp	r3, r2
 8004dfc:	d901      	bls.n	8004e02 <HAL_RCCEx_PeriphCLKConfig+0x19e>
          {
            return HAL_TIMEOUT;
 8004dfe:	2303      	movs	r3, #3
 8004e00:	e317      	b.n	8005432 <HAL_RCCEx_PeriphCLKConfig+0x7ce>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8004e02:	4b0c      	ldr	r3, [pc, #48]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004e04:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004e06:	f003 0302 	and.w	r3, r3, #2
 8004e0a:	2b00      	cmp	r3, #0
 8004e0c:	d0ee      	beq.n	8004dec <HAL_RCCEx_PeriphCLKConfig+0x188>
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8004e0e:	687b      	ldr	r3, [r7, #4]
 8004e10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004e12:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8004e16:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8004e1a:	d111      	bne.n	8004e40 <HAL_RCCEx_PeriphCLKConfig+0x1dc>
 8004e1c:	4b05      	ldr	r3, [pc, #20]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004e1e:	689b      	ldr	r3, [r3, #8]
 8004e20:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 8004e24:	687b      	ldr	r3, [r7, #4]
 8004e26:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8004e28:	4b04      	ldr	r3, [pc, #16]	; (8004e3c <HAL_RCCEx_PeriphCLKConfig+0x1d8>)
 8004e2a:	400b      	ands	r3, r1
 8004e2c:	4901      	ldr	r1, [pc, #4]	; (8004e34 <HAL_RCCEx_PeriphCLKConfig+0x1d0>)
 8004e2e:	4313      	orrs	r3, r2
 8004e30:	608b      	str	r3, [r1, #8]
 8004e32:	e00b      	b.n	8004e4c <HAL_RCCEx_PeriphCLKConfig+0x1e8>
 8004e34:	40023800 	.word	0x40023800
 8004e38:	40007000 	.word	0x40007000
 8004e3c:	0ffffcff 	.word	0x0ffffcff
 8004e40:	4bb0      	ldr	r3, [pc, #704]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e42:	689b      	ldr	r3, [r3, #8]
 8004e44:	4aaf      	ldr	r2, [pc, #700]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e46:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 8004e4a:	6093      	str	r3, [r2, #8]
 8004e4c:	4bad      	ldr	r3, [pc, #692]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e4e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8004e50:	687b      	ldr	r3, [r7, #4]
 8004e52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8004e54:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8004e58:	49aa      	ldr	r1, [pc, #680]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e5a:	4313      	orrs	r3, r2
 8004e5c:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 8004e5e:	687b      	ldr	r3, [r7, #4]
 8004e60:	681b      	ldr	r3, [r3, #0]
 8004e62:	f003 0310 	and.w	r3, r3, #16
 8004e66:	2b00      	cmp	r3, #0
 8004e68:	d010      	beq.n	8004e8c <HAL_RCCEx_PeriphCLKConfig+0x228>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 8004e6a:	4ba6      	ldr	r3, [pc, #664]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e6c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8004e70:	4aa4      	ldr	r2, [pc, #656]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e72:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8004e76:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 8004e7a:	4ba2      	ldr	r3, [pc, #648]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e7c:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 8004e80:	687b      	ldr	r3, [r7, #4]
 8004e82:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004e84:	499f      	ldr	r1, [pc, #636]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e86:	4313      	orrs	r3, r2
 8004e88:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }

  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8004e8c:	687b      	ldr	r3, [r7, #4]
 8004e8e:	681b      	ldr	r3, [r3, #0]
 8004e90:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8004e94:	2b00      	cmp	r3, #0
 8004e96:	d00a      	beq.n	8004eae <HAL_RCCEx_PeriphCLKConfig+0x24a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8004e98:	4b9a      	ldr	r3, [pc, #616]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004e9a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004e9e:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8004ea2:	687b      	ldr	r3, [r7, #4]
 8004ea4:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8004ea6:	4997      	ldr	r1, [pc, #604]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004ea8:	4313      	orrs	r3, r2
 8004eaa:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8004eae:	687b      	ldr	r3, [r7, #4]
 8004eb0:	681b      	ldr	r3, [r3, #0]
 8004eb2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8004eb6:	2b00      	cmp	r3, #0
 8004eb8:	d00a      	beq.n	8004ed0 <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8004eba:	4b92      	ldr	r3, [pc, #584]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004ebc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004ec0:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 8004ec4:	687b      	ldr	r3, [r7, #4]
 8004ec6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8004ec8:	498e      	ldr	r1, [pc, #568]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004eca:	4313      	orrs	r3, r2
 8004ecc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8004ed0:	687b      	ldr	r3, [r7, #4]
 8004ed2:	681b      	ldr	r3, [r3, #0]
 8004ed4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8004ed8:	2b00      	cmp	r3, #0
 8004eda:	d00a      	beq.n	8004ef2 <HAL_RCCEx_PeriphCLKConfig+0x28e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8004edc:	4b89      	ldr	r3, [pc, #548]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004ede:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004ee2:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8004ee6:	687b      	ldr	r3, [r7, #4]
 8004ee8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8004eea:	4986      	ldr	r1, [pc, #536]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004eec:	4313      	orrs	r3, r2
 8004eee:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8004ef2:	687b      	ldr	r3, [r7, #4]
 8004ef4:	681b      	ldr	r3, [r3, #0]
 8004ef6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8004efa:	2b00      	cmp	r3, #0
 8004efc:	d00a      	beq.n	8004f14 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8004efe:	4b81      	ldr	r3, [pc, #516]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f00:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f04:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8004f08:	687b      	ldr	r3, [r7, #4]
 8004f0a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8004f0c:	497d      	ldr	r1, [pc, #500]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f0e:	4313      	orrs	r3, r2
 8004f10:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8004f14:	687b      	ldr	r3, [r7, #4]
 8004f16:	681b      	ldr	r3, [r3, #0]
 8004f18:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8004f1c:	2b00      	cmp	r3, #0
 8004f1e:	d00a      	beq.n	8004f36 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8004f20:	4b78      	ldr	r3, [pc, #480]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f22:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f26:	f023 0203 	bic.w	r2, r3, #3
 8004f2a:	687b      	ldr	r3, [r7, #4]
 8004f2c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8004f2e:	4975      	ldr	r1, [pc, #468]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f30:	4313      	orrs	r3, r2
 8004f32:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8004f36:	687b      	ldr	r3, [r7, #4]
 8004f38:	681b      	ldr	r3, [r3, #0]
 8004f3a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8004f3e:	2b00      	cmp	r3, #0
 8004f40:	d00a      	beq.n	8004f58 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8004f42:	4b70      	ldr	r3, [pc, #448]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f44:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f48:	f023 020c 	bic.w	r2, r3, #12
 8004f4c:	687b      	ldr	r3, [r7, #4]
 8004f4e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8004f50:	496c      	ldr	r1, [pc, #432]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f52:	4313      	orrs	r3, r2
 8004f54:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8004f58:	687b      	ldr	r3, [r7, #4]
 8004f5a:	681b      	ldr	r3, [r3, #0]
 8004f5c:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8004f60:	2b00      	cmp	r3, #0
 8004f62:	d00a      	beq.n	8004f7a <HAL_RCCEx_PeriphCLKConfig+0x316>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8004f64:	4b67      	ldr	r3, [pc, #412]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f66:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f6a:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8004f6e:	687b      	ldr	r3, [r7, #4]
 8004f70:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8004f72:	4964      	ldr	r1, [pc, #400]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f74:	4313      	orrs	r3, r2
 8004f76:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8004f7a:	687b      	ldr	r3, [r7, #4]
 8004f7c:	681b      	ldr	r3, [r3, #0]
 8004f7e:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8004f82:	2b00      	cmp	r3, #0
 8004f84:	d00a      	beq.n	8004f9c <HAL_RCCEx_PeriphCLKConfig+0x338>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8004f86:	4b5f      	ldr	r3, [pc, #380]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f88:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004f8c:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 8004f90:	687b      	ldr	r3, [r7, #4]
 8004f92:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8004f94:	495b      	ldr	r1, [pc, #364]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004f96:	4313      	orrs	r3, r2
 8004f98:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8004f9c:	687b      	ldr	r3, [r7, #4]
 8004f9e:	681b      	ldr	r3, [r3, #0]
 8004fa0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8004fa4:	2b00      	cmp	r3, #0
 8004fa6:	d00a      	beq.n	8004fbe <HAL_RCCEx_PeriphCLKConfig+0x35a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8004fa8:	4b56      	ldr	r3, [pc, #344]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004faa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004fae:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8004fb2:	687b      	ldr	r3, [r7, #4]
 8004fb4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8004fb6:	4953      	ldr	r1, [pc, #332]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004fb8:	4313      	orrs	r3, r2
 8004fba:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8004fbe:	687b      	ldr	r3, [r7, #4]
 8004fc0:	681b      	ldr	r3, [r3, #0]
 8004fc2:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8004fc6:	2b00      	cmp	r3, #0
 8004fc8:	d00a      	beq.n	8004fe0 <HAL_RCCEx_PeriphCLKConfig+0x37c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));

    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8004fca:	4b4e      	ldr	r3, [pc, #312]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004fcc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004fd0:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8004fd4:	687b      	ldr	r3, [r7, #4]
 8004fd6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8004fd8:	494a      	ldr	r1, [pc, #296]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004fda:	4313      	orrs	r3, r2
 8004fdc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8004fe0:	687b      	ldr	r3, [r7, #4]
 8004fe2:	681b      	ldr	r3, [r3, #0]
 8004fe4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8004fe8:	2b00      	cmp	r3, #0
 8004fea:	d00a      	beq.n	8005002 <HAL_RCCEx_PeriphCLKConfig+0x39e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));

    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8004fec:	4b45      	ldr	r3, [pc, #276]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004fee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8004ff2:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8004ff6:	687b      	ldr	r3, [r7, #4]
 8004ff8:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8004ffa:	4942      	ldr	r1, [pc, #264]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8004ffc:	4313      	orrs	r3, r2
 8004ffe:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8005002:	687b      	ldr	r3, [r7, #4]
 8005004:	681b      	ldr	r3, [r3, #0]
 8005006:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 800500a:	2b00      	cmp	r3, #0
 800500c:	d00a      	beq.n	8005024 <HAL_RCCEx_PeriphCLKConfig+0x3c0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));

    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 800500e:	4b3d      	ldr	r3, [pc, #244]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8005010:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005014:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 8005018:	687b      	ldr	r3, [r7, #4]
 800501a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800501c:	4939      	ldr	r1, [pc, #228]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 800501e:	4313      	orrs	r3, r2
 8005020:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8005024:	687b      	ldr	r3, [r7, #4]
 8005026:	681b      	ldr	r3, [r3, #0]
 8005028:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800502c:	2b00      	cmp	r3, #0
 800502e:	d00a      	beq.n	8005046 <HAL_RCCEx_PeriphCLKConfig+0x3e2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8005030:	4b34      	ldr	r3, [pc, #208]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8005032:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005036:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 800503a:	687b      	ldr	r3, [r7, #4]
 800503c:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800503e:	4931      	ldr	r1, [pc, #196]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8005040:	4313      	orrs	r3, r2
 8005042:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8005046:	687b      	ldr	r3, [r7, #4]
 8005048:	681b      	ldr	r3, [r3, #0]
 800504a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800504e:	2b00      	cmp	r3, #0
 8005050:	d011      	beq.n	8005076 <HAL_RCCEx_PeriphCLKConfig+0x412>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));

    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8005052:	4b2c      	ldr	r3, [pc, #176]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8005054:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005058:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
 800505c:	687b      	ldr	r3, [r7, #4]
 800505e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8005060:	4928      	ldr	r1, [pc, #160]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8005062:	4313      	orrs	r3, r2
 8005064:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
 8005068:	687b      	ldr	r3, [r7, #4]
 800506a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800506c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005070:	d101      	bne.n	8005076 <HAL_RCCEx_PeriphCLKConfig+0x412>
    {
      pllsaiused = 1;
 8005072:	2301      	movs	r3, #1
 8005074:	61bb      	str	r3, [r7, #24]
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8005076:	687b      	ldr	r3, [r7, #4]
 8005078:	681b      	ldr	r3, [r3, #0]
 800507a:	f003 0308 	and.w	r3, r3, #8
 800507e:	2b00      	cmp	r3, #0
 8005080:	d001      	beq.n	8005086 <HAL_RCCEx_PeriphCLKConfig+0x422>
  {
    pllsaiused = 1;
 8005082:	2301      	movs	r3, #1
 8005084:	61bb      	str	r3, [r7, #24]
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx */

  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8005086:	687b      	ldr	r3, [r7, #4]
 8005088:	681b      	ldr	r3, [r3, #0]
 800508a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800508e:	2b00      	cmp	r3, #0
 8005090:	d00a      	beq.n	80050a8 <HAL_RCCEx_PeriphCLKConfig+0x444>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8005092:	4b1c      	ldr	r3, [pc, #112]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 8005094:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8005098:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 800509c:	687b      	ldr	r3, [r7, #4]
 800509e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80050a0:	4918      	ldr	r1, [pc, #96]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 80050a2:	4313      	orrs	r3, r2
 80050a4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }

  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 80050a8:	687b      	ldr	r3, [r7, #4]
 80050aa:	681b      	ldr	r3, [r3, #0]
 80050ac:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80050b0:	2b00      	cmp	r3, #0
 80050b2:	d00b      	beq.n	80050cc <HAL_RCCEx_PeriphCLKConfig+0x468>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));

    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80050b4:	4b13      	ldr	r3, [pc, #76]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 80050b6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80050ba:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 80050be:	687b      	ldr	r3, [r7, #4]
 80050c0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80050c4:	490f      	ldr	r1, [pc, #60]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 80050c6:	4313      	orrs	r3, r2
 80050c8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */

  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 80050cc:	69fb      	ldr	r3, [r7, #28]
 80050ce:	2b01      	cmp	r3, #1
 80050d0:	d005      	beq.n	80050de <HAL_RCCEx_PeriphCLKConfig+0x47a>
 80050d2:	687b      	ldr	r3, [r7, #4]
 80050d4:	681b      	ldr	r3, [r3, #0]
 80050d6:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 80050da:	f040 80d8 	bne.w	800528e <HAL_RCCEx_PeriphCLKConfig+0x62a>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();
 80050de:	4b09      	ldr	r3, [pc, #36]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 80050e0:	681b      	ldr	r3, [r3, #0]
 80050e2:	4a08      	ldr	r2, [pc, #32]	; (8005104 <HAL_RCCEx_PeriphCLKConfig+0x4a0>)
 80050e4:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80050e8:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80050ea:	f7fb fa9b 	bl	8000624 <HAL_GetTick>
 80050ee:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 80050f0:	e00a      	b.n	8005108 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 80050f2:	f7fb fa97 	bl	8000624 <HAL_GetTick>
 80050f6:	4602      	mov	r2, r0
 80050f8:	697b      	ldr	r3, [r7, #20]
 80050fa:	1ad3      	subs	r3, r2, r3
 80050fc:	2b64      	cmp	r3, #100	; 0x64
 80050fe:	d903      	bls.n	8005108 <HAL_RCCEx_PeriphCLKConfig+0x4a4>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8005100:	2303      	movs	r3, #3
 8005102:	e196      	b.n	8005432 <HAL_RCCEx_PeriphCLKConfig+0x7ce>
 8005104:	40023800 	.word	0x40023800
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8005108:	4b6c      	ldr	r3, [pc, #432]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 800510a:	681b      	ldr	r3, [r3, #0]
 800510c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8005110:	2b00      	cmp	r3, #0
 8005112:	d1ee      	bne.n	80050f2 <HAL_RCCEx_PeriphCLKConfig+0x48e>

    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));

    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8005114:	687b      	ldr	r3, [r7, #4]
 8005116:	681b      	ldr	r3, [r3, #0]
 8005118:	f003 0301 	and.w	r3, r3, #1
 800511c:	2b00      	cmp	r3, #0
 800511e:	d021      	beq.n	8005164 <HAL_RCCEx_PeriphCLKConfig+0x500>
 8005120:	687b      	ldr	r3, [r7, #4]
 8005122:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005124:	2b00      	cmp	r3, #0
 8005126:	d11d      	bne.n	8005164 <HAL_RCCEx_PeriphCLKConfig+0x500>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));

      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8005128:	4b64      	ldr	r3, [pc, #400]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 800512a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800512e:	0c1b      	lsrs	r3, r3, #16
 8005130:	f003 0303 	and.w	r3, r3, #3
 8005134:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 8005136:	4b61      	ldr	r3, [pc, #388]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005138:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800513c:	0e1b      	lsrs	r3, r3, #24
 800513e:	f003 030f 	and.w	r3, r3, #15
 8005142:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8005144:	687b      	ldr	r3, [r7, #4]
 8005146:	685b      	ldr	r3, [r3, #4]
 8005148:	019a      	lsls	r2, r3, #6
 800514a:	693b      	ldr	r3, [r7, #16]
 800514c:	041b      	lsls	r3, r3, #16
 800514e:	431a      	orrs	r2, r3
 8005150:	68fb      	ldr	r3, [r7, #12]
 8005152:	061b      	lsls	r3, r3, #24
 8005154:	431a      	orrs	r2, r3
 8005156:	687b      	ldr	r3, [r7, #4]
 8005158:	689b      	ldr	r3, [r3, #8]
 800515a:	071b      	lsls	r3, r3, #28
 800515c:	4957      	ldr	r1, [pc, #348]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 800515e:	4313      	orrs	r3, r2
 8005160:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8005164:	687b      	ldr	r3, [r7, #4]
 8005166:	681b      	ldr	r3, [r3, #0]
 8005168:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 800516c:	2b00      	cmp	r3, #0
 800516e:	d004      	beq.n	800517a <HAL_RCCEx_PeriphCLKConfig+0x516>
 8005170:	687b      	ldr	r3, [r7, #4]
 8005172:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005174:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005178:	d00a      	beq.n	8005190 <HAL_RCCEx_PeriphCLKConfig+0x52c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 800517a:	687b      	ldr	r3, [r7, #4]
 800517c:	681b      	ldr	r3, [r3, #0]
 800517e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8005182:	2b00      	cmp	r3, #0
 8005184:	d02e      	beq.n	80051e4 <HAL_RCCEx_PeriphCLKConfig+0x580>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)))
 8005186:	687b      	ldr	r3, [r7, #4]
 8005188:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800518a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800518e:	d129      	bne.n	80051e4 <HAL_RCCEx_PeriphCLKConfig+0x580>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));

      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> RCC_PLLI2SCFGR_PLLI2SP_Pos);
 8005190:	4b4a      	ldr	r3, [pc, #296]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005192:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005196:	0c1b      	lsrs	r3, r3, #16
 8005198:	f003 0303 	and.w	r3, r3, #3
 800519c:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 800519e:	4b47      	ldr	r3, [pc, #284]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 80051a0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80051a4:	0f1b      	lsrs	r3, r3, #28
 80051a6:	f003 0307 	and.w	r3, r3, #7
 80051aa:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 80051ac:	687b      	ldr	r3, [r7, #4]
 80051ae:	685b      	ldr	r3, [r3, #4]
 80051b0:	019a      	lsls	r2, r3, #6
 80051b2:	693b      	ldr	r3, [r7, #16]
 80051b4:	041b      	lsls	r3, r3, #16
 80051b6:	431a      	orrs	r2, r3
 80051b8:	687b      	ldr	r3, [r7, #4]
 80051ba:	68db      	ldr	r3, [r3, #12]
 80051bc:	061b      	lsls	r3, r3, #24
 80051be:	431a      	orrs	r2, r3
 80051c0:	68fb      	ldr	r3, [r7, #12]
 80051c2:	071b      	lsls	r3, r3, #28
 80051c4:	493d      	ldr	r1, [pc, #244]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 80051c6:	4313      	orrs	r3, r2
 80051c8:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84

      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80051cc:	4b3b      	ldr	r3, [pc, #236]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 80051ce:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80051d2:	f023 021f 	bic.w	r2, r3, #31
 80051d6:	687b      	ldr	r3, [r7, #4]
 80051d8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80051da:	3b01      	subs	r3, #1
 80051dc:	4937      	ldr	r1, [pc, #220]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 80051de:	4313      	orrs	r3, r2
 80051e0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 80051e4:	687b      	ldr	r3, [r7, #4]
 80051e6:	681b      	ldr	r3, [r3, #0]
 80051e8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80051ec:	2b00      	cmp	r3, #0
 80051ee:	d01d      	beq.n	800522c <HAL_RCCEx_PeriphCLKConfig+0x5c8>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));

     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> RCC_PLLI2SCFGR_PLLI2SQ_Pos);
 80051f0:	4b32      	ldr	r3, [pc, #200]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 80051f2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80051f6:	0e1b      	lsrs	r3, r3, #24
 80051f8:	f003 030f 	and.w	r3, r3, #15
 80051fc:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLI2SCFGR_PLLI2SR_Pos);
 80051fe:	4b2f      	ldr	r3, [pc, #188]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005200:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005204:	0f1b      	lsrs	r3, r3, #28
 8005206:	f003 0307 	and.w	r3, r3, #7
 800520a:	60fb      	str	r3, [r7, #12]
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 800520c:	687b      	ldr	r3, [r7, #4]
 800520e:	685b      	ldr	r3, [r3, #4]
 8005210:	019a      	lsls	r2, r3, #6
 8005212:	687b      	ldr	r3, [r7, #4]
 8005214:	691b      	ldr	r3, [r3, #16]
 8005216:	041b      	lsls	r3, r3, #16
 8005218:	431a      	orrs	r2, r3
 800521a:	693b      	ldr	r3, [r7, #16]
 800521c:	061b      	lsls	r3, r3, #24
 800521e:	431a      	orrs	r2, r3
 8005220:	68fb      	ldr	r3, [r7, #12]
 8005222:	071b      	lsls	r3, r3, #28
 8005224:	4925      	ldr	r1, [pc, #148]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005226:	4313      	orrs	r3, r2
 8005228:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /*----------------- In Case of PLLI2S is just selected  -----------------*/
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 800522c:	687b      	ldr	r3, [r7, #4]
 800522e:	681b      	ldr	r3, [r3, #0]
 8005230:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8005234:	2b00      	cmp	r3, #0
 8005236:	d011      	beq.n	800525c <HAL_RCCEx_PeriphCLKConfig+0x5f8>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 8005238:	687b      	ldr	r3, [r7, #4]
 800523a:	685b      	ldr	r3, [r3, #4]
 800523c:	019a      	lsls	r2, r3, #6
 800523e:	687b      	ldr	r3, [r7, #4]
 8005240:	691b      	ldr	r3, [r3, #16]
 8005242:	041b      	lsls	r3, r3, #16
 8005244:	431a      	orrs	r2, r3
 8005246:	687b      	ldr	r3, [r7, #4]
 8005248:	68db      	ldr	r3, [r3, #12]
 800524a:	061b      	lsls	r3, r3, #24
 800524c:	431a      	orrs	r2, r3
 800524e:	687b      	ldr	r3, [r7, #4]
 8005250:	689b      	ldr	r3, [r3, #8]
 8005252:	071b      	lsls	r3, r3, #28
 8005254:	4919      	ldr	r1, [pc, #100]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005256:	4313      	orrs	r3, r2
 8005258:	f8c1 3084 	str.w	r3, [r1, #132]	; 0x84
    }

    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 800525c:	4b17      	ldr	r3, [pc, #92]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 800525e:	681b      	ldr	r3, [r3, #0]
 8005260:	4a16      	ldr	r2, [pc, #88]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005262:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8005266:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8005268:	f7fb f9dc 	bl	8000624 <HAL_GetTick>
 800526c:	6178      	str	r0, [r7, #20]

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 800526e:	e008      	b.n	8005282 <HAL_RCCEx_PeriphCLKConfig+0x61e>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8005270:	f7fb f9d8 	bl	8000624 <HAL_GetTick>
 8005274:	4602      	mov	r2, r0
 8005276:	697b      	ldr	r3, [r7, #20]
 8005278:	1ad3      	subs	r3, r2, r3
 800527a:	2b64      	cmp	r3, #100	; 0x64
 800527c:	d901      	bls.n	8005282 <HAL_RCCEx_PeriphCLKConfig+0x61e>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800527e:	2303      	movs	r3, #3
 8005280:	e0d7      	b.n	8005432 <HAL_RCCEx_PeriphCLKConfig+0x7ce>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8005282:	4b0e      	ldr	r3, [pc, #56]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005284:	681b      	ldr	r3, [r3, #0]
 8005286:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800528a:	2b00      	cmp	r3, #0
 800528c:	d0f0      	beq.n	8005270 <HAL_RCCEx_PeriphCLKConfig+0x60c>
    }
  }

  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 800528e:	69bb      	ldr	r3, [r7, #24]
 8005290:	2b01      	cmp	r3, #1
 8005292:	f040 80cd 	bne.w	8005430 <HAL_RCCEx_PeriphCLKConfig+0x7cc>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE();
 8005296:	4b09      	ldr	r3, [pc, #36]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 8005298:	681b      	ldr	r3, [r3, #0]
 800529a:	4a08      	ldr	r2, [pc, #32]	; (80052bc <HAL_RCCEx_PeriphCLKConfig+0x658>)
 800529c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80052a0:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80052a2:	f7fb f9bf 	bl	8000624 <HAL_GetTick>
 80052a6:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80052a8:	e00a      	b.n	80052c0 <HAL_RCCEx_PeriphCLKConfig+0x65c>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 80052aa:	f7fb f9bb 	bl	8000624 <HAL_GetTick>
 80052ae:	4602      	mov	r2, r0
 80052b0:	697b      	ldr	r3, [r7, #20]
 80052b2:	1ad3      	subs	r3, r2, r3
 80052b4:	2b64      	cmp	r3, #100	; 0x64
 80052b6:	d903      	bls.n	80052c0 <HAL_RCCEx_PeriphCLKConfig+0x65c>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 80052b8:	2303      	movs	r3, #3
 80052ba:	e0ba      	b.n	8005432 <HAL_RCCEx_PeriphCLKConfig+0x7ce>
 80052bc:	40023800 	.word	0x40023800
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80052c0:	4b5e      	ldr	r3, [pc, #376]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80052c2:	681b      	ldr	r3, [r3, #0]
 80052c4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80052c8:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 80052cc:	d0ed      	beq.n	80052aa <HAL_RCCEx_PeriphCLKConfig+0x646>

    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));

    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80052ce:	687b      	ldr	r3, [r7, #4]
 80052d0:	681b      	ldr	r3, [r3, #0]
 80052d2:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80052d6:	2b00      	cmp	r3, #0
 80052d8:	d003      	beq.n	80052e2 <HAL_RCCEx_PeriphCLKConfig+0x67e>
 80052da:	687b      	ldr	r3, [r7, #4]
 80052dc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80052de:	2b00      	cmp	r3, #0
 80052e0:	d009      	beq.n	80052f6 <HAL_RCCEx_PeriphCLKConfig+0x692>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 80052e2:	687b      	ldr	r3, [r7, #4]
 80052e4:	681b      	ldr	r3, [r3, #0]
 80052e6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80052ea:	2b00      	cmp	r3, #0
 80052ec:	d02e      	beq.n	800534c <HAL_RCCEx_PeriphCLKConfig+0x6e8>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 80052ee:	687b      	ldr	r3, [r7, #4]
 80052f0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80052f2:	2b00      	cmp	r3, #0
 80052f4:	d12a      	bne.n	800534c <HAL_RCCEx_PeriphCLKConfig+0x6e8>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));

      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80052f6:	4b51      	ldr	r3, [pc, #324]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80052f8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80052fc:	0c1b      	lsrs	r3, r3, #16
 80052fe:	f003 0303 	and.w	r3, r3, #3
 8005302:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8005304:	4b4d      	ldr	r3, [pc, #308]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005306:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800530a:	0f1b      	lsrs	r3, r3, #28
 800530c:	f003 0307 	and.w	r3, r3, #7
 8005310:	60fb      	str	r3, [r7, #12]
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 8005312:	687b      	ldr	r3, [r7, #4]
 8005314:	695b      	ldr	r3, [r3, #20]
 8005316:	019a      	lsls	r2, r3, #6
 8005318:	693b      	ldr	r3, [r7, #16]
 800531a:	041b      	lsls	r3, r3, #16
 800531c:	431a      	orrs	r2, r3
 800531e:	687b      	ldr	r3, [r7, #4]
 8005320:	699b      	ldr	r3, [r3, #24]
 8005322:	061b      	lsls	r3, r3, #24
 8005324:	431a      	orrs	r2, r3
 8005326:	68fb      	ldr	r3, [r7, #12]
 8005328:	071b      	lsls	r3, r3, #28
 800532a:	4944      	ldr	r1, [pc, #272]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 800532c:	4313      	orrs	r3, r2
 800532e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8005332:	4b42      	ldr	r3, [pc, #264]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005334:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005338:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 800533c:	687b      	ldr	r3, [r7, #4]
 800533e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005340:	3b01      	subs	r3, #1
 8005342:	021b      	lsls	r3, r3, #8
 8005344:	493d      	ldr	r1, [pc, #244]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005346:	4313      	orrs	r3, r2
 8005348:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/
    /* In Case of PLLI2S is selected as source clock for CK48 */
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 800534c:	687b      	ldr	r3, [r7, #4]
 800534e:	681b      	ldr	r3, [r3, #0]
 8005350:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8005354:	2b00      	cmp	r3, #0
 8005356:	d022      	beq.n	800539e <HAL_RCCEx_PeriphCLKConfig+0x73a>
 8005358:	687b      	ldr	r3, [r7, #4]
 800535a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800535c:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8005360:	d11d      	bne.n	800539e <HAL_RCCEx_PeriphCLKConfig+0x73a>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 8005362:	4b36      	ldr	r3, [pc, #216]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005364:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005368:	0e1b      	lsrs	r3, r3, #24
 800536a:	f003 030f 	and.w	r3, r3, #15
 800536e:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> RCC_PLLSAICFGR_PLLSAIR_Pos);
 8005370:	4b32      	ldr	r3, [pc, #200]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005372:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8005376:	0f1b      	lsrs	r3, r3, #28
 8005378:	f003 0307 	and.w	r3, r3, #7
 800537c:	60fb      	str	r3, [r7, #12]

      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 800537e:	687b      	ldr	r3, [r7, #4]
 8005380:	695b      	ldr	r3, [r3, #20]
 8005382:	019a      	lsls	r2, r3, #6
 8005384:	687b      	ldr	r3, [r7, #4]
 8005386:	6a1b      	ldr	r3, [r3, #32]
 8005388:	041b      	lsls	r3, r3, #16
 800538a:	431a      	orrs	r2, r3
 800538c:	693b      	ldr	r3, [r7, #16]
 800538e:	061b      	lsls	r3, r3, #24
 8005390:	431a      	orrs	r2, r3
 8005392:	68fb      	ldr	r3, [r7, #12]
 8005394:	071b      	lsls	r3, r3, #28
 8005396:	4929      	ldr	r1, [pc, #164]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005398:	4313      	orrs	r3, r2
 800539a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    }

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) || defined (STM32F750xx)
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 800539e:	687b      	ldr	r3, [r7, #4]
 80053a0:	681b      	ldr	r3, [r3, #0]
 80053a2:	f003 0308 	and.w	r3, r3, #8
 80053a6:	2b00      	cmp	r3, #0
 80053a8:	d028      	beq.n	80053fc <HAL_RCCEx_PeriphCLKConfig+0x798>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));

      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> RCC_PLLSAICFGR_PLLSAIQ_Pos);
 80053aa:	4b24      	ldr	r3, [pc, #144]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80053ac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80053b0:	0e1b      	lsrs	r3, r3, #24
 80053b2:	f003 030f 	and.w	r3, r3, #15
 80053b6:	613b      	str	r3, [r7, #16]
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> RCC_PLLSAICFGR_PLLSAIP_Pos);
 80053b8:	4b20      	ldr	r3, [pc, #128]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80053ba:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80053be:	0c1b      	lsrs	r3, r3, #16
 80053c0:	f003 0303 	and.w	r3, r3, #3
 80053c4:	60fb      	str	r3, [r7, #12]

      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 80053c6:	687b      	ldr	r3, [r7, #4]
 80053c8:	695b      	ldr	r3, [r3, #20]
 80053ca:	019a      	lsls	r2, r3, #6
 80053cc:	68fb      	ldr	r3, [r7, #12]
 80053ce:	041b      	lsls	r3, r3, #16
 80053d0:	431a      	orrs	r2, r3
 80053d2:	693b      	ldr	r3, [r7, #16]
 80053d4:	061b      	lsls	r3, r3, #24
 80053d6:	431a      	orrs	r2, r3
 80053d8:	687b      	ldr	r3, [r7, #4]
 80053da:	69db      	ldr	r3, [r3, #28]
 80053dc:	071b      	lsls	r3, r3, #28
 80053de:	4917      	ldr	r1, [pc, #92]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80053e0:	4313      	orrs	r3, r2
 80053e2:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88

      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 80053e6:	4b15      	ldr	r3, [pc, #84]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80053e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80053ec:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 80053f0:	687b      	ldr	r3, [r7, #4]
 80053f2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80053f4:	4911      	ldr	r1, [pc, #68]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80053f6:	4313      	orrs	r3, r2
 80053f8:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx || STM32F750xx  */

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 80053fc:	4b0f      	ldr	r3, [pc, #60]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 80053fe:	681b      	ldr	r3, [r3, #0]
 8005400:	4a0e      	ldr	r2, [pc, #56]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005402:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8005406:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8005408:	f7fb f90c 	bl	8000624 <HAL_GetTick>
 800540c:	6178      	str	r0, [r7, #20]

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 800540e:	e008      	b.n	8005422 <HAL_RCCEx_PeriphCLKConfig+0x7be>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 8005410:	f7fb f908 	bl	8000624 <HAL_GetTick>
 8005414:	4602      	mov	r2, r0
 8005416:	697b      	ldr	r3, [r7, #20]
 8005418:	1ad3      	subs	r3, r2, r3
 800541a:	2b64      	cmp	r3, #100	; 0x64
 800541c:	d901      	bls.n	8005422 <HAL_RCCEx_PeriphCLKConfig+0x7be>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 800541e:	2303      	movs	r3, #3
 8005420:	e007      	b.n	8005432 <HAL_RCCEx_PeriphCLKConfig+0x7ce>
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 8005422:	4b06      	ldr	r3, [pc, #24]	; (800543c <HAL_RCCEx_PeriphCLKConfig+0x7d8>)
 8005424:	681b      	ldr	r3, [r3, #0]
 8005426:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800542a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800542e:	d1ef      	bne.n	8005410 <HAL_RCCEx_PeriphCLKConfig+0x7ac>
      }
    }
  }
  return HAL_OK;
 8005430:	2300      	movs	r3, #0
}
 8005432:	4618      	mov	r0, r3
 8005434:	3720      	adds	r7, #32
 8005436:	46bd      	mov	sp, r7
 8005438:	bd80      	pop	{r7, pc}
 800543a:	bf00      	nop
 800543c:	40023800 	.word	0x40023800

08005440 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_SAI1: SAI1 peripheral clock
  *            @arg RCC_PERIPHCLK_SAI2: SAI2 peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
 8005440:	b480      	push	{r7}
 8005442:	b087      	sub	sp, #28
 8005444:	af00      	add	r7, sp, #0
 8005446:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8005448:	2300      	movs	r3, #0
 800544a:	60fb      	str	r3, [r7, #12]
  /* This variable is used to store the SAI clock frequency (value in Hz) */
  uint32_t frequency = 0;
 800544c:	2300      	movs	r3, #0
 800544e:	617b      	str	r3, [r7, #20]
  /* This variable is used to store the VCO Input (value in Hz) */
  uint32_t vcoinput = 0;
 8005450:	2300      	movs	r3, #0
 8005452:	613b      	str	r3, [r7, #16]
  /* This variable is used to store the SAI clock source */
  uint32_t saiclocksource = 0;
 8005454:	2300      	movs	r3, #0
 8005456:	60bb      	str	r3, [r7, #8]

  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 8005458:	687b      	ldr	r3, [r7, #4]
 800545a:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 800545e:	f040 8086 	bne.w	800556e <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
  {
    saiclocksource = RCC->DCKCFGR1;
 8005462:	4b8d      	ldr	r3, [pc, #564]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005464:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005468:	60bb      	str	r3, [r7, #8]
    saiclocksource &= RCC_DCKCFGR1_SAI1SEL;
 800546a:	68bb      	ldr	r3, [r7, #8]
 800546c:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8005470:	60bb      	str	r3, [r7, #8]
    switch (saiclocksource)
 8005472:	68bb      	ldr	r3, [r7, #8]
 8005474:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005478:	d03e      	beq.n	80054f8 <HAL_RCCEx_GetPeriphCLKFreq+0xb8>
 800547a:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800547e:	d073      	beq.n	8005568 <HAL_RCCEx_GetPeriphCLKFreq+0x128>
 8005480:	2b00      	cmp	r3, #0
 8005482:	d000      	beq.n	8005486 <HAL_RCCEx_GetPeriphCLKFreq+0x46>
        break;
      }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
    default :
      {
        break;
 8005484:	e074      	b.n	8005570 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8005486:	4b84      	ldr	r3, [pc, #528]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005488:	685b      	ldr	r3, [r3, #4]
 800548a:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800548e:	2b00      	cmp	r3, #0
 8005490:	d108      	bne.n	80054a4 <HAL_RCCEx_GetPeriphCLKFreq+0x64>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8005492:	4b81      	ldr	r3, [pc, #516]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005494:	685b      	ldr	r3, [r3, #4]
 8005496:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800549a:	4a80      	ldr	r2, [pc, #512]	; (800569c <HAL_RCCEx_GetPeriphCLKFreq+0x25c>)
 800549c:	fbb2 f3f3 	udiv	r3, r2, r3
 80054a0:	613b      	str	r3, [r7, #16]
 80054a2:	e007      	b.n	80054b4 <HAL_RCCEx_GetPeriphCLKFreq+0x74>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 80054a4:	4b7c      	ldr	r3, [pc, #496]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80054a6:	685b      	ldr	r3, [r3, #4]
 80054a8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80054ac:	4a7c      	ldr	r2, [pc, #496]	; (80056a0 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
 80054ae:	fbb2 f3f3 	udiv	r3, r2, r3
 80054b2:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 80054b4:	4b78      	ldr	r3, [pc, #480]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80054b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80054ba:	0e1b      	lsrs	r3, r3, #24
 80054bc:	f003 030f 	and.w	r3, r3, #15
 80054c0:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80054c2:	4b75      	ldr	r3, [pc, #468]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80054c4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80054c8:	099b      	lsrs	r3, r3, #6
 80054ca:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80054ce:	693a      	ldr	r2, [r7, #16]
 80054d0:	fb02 f203 	mul.w	r2, r2, r3
 80054d4:	68fb      	ldr	r3, [r7, #12]
 80054d6:	fbb2 f3f3 	udiv	r3, r2, r3
 80054da:	617b      	str	r3, [r7, #20]
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80054dc:	4b6e      	ldr	r3, [pc, #440]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80054de:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80054e2:	0a1b      	lsrs	r3, r3, #8
 80054e4:	f003 031f 	and.w	r3, r3, #31
 80054e8:	3301      	adds	r3, #1
 80054ea:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
 80054ec:	697a      	ldr	r2, [r7, #20]
 80054ee:	68fb      	ldr	r3, [r7, #12]
 80054f0:	fbb2 f3f3 	udiv	r3, r2, r3
 80054f4:	617b      	str	r3, [r7, #20]
        break;
 80054f6:	e03b      	b.n	8005570 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 80054f8:	4b67      	ldr	r3, [pc, #412]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80054fa:	685b      	ldr	r3, [r3, #4]
 80054fc:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005500:	2b00      	cmp	r3, #0
 8005502:	d108      	bne.n	8005516 <HAL_RCCEx_GetPeriphCLKFreq+0xd6>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 8005504:	4b64      	ldr	r3, [pc, #400]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005506:	685b      	ldr	r3, [r3, #4]
 8005508:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800550c:	4a63      	ldr	r2, [pc, #396]	; (800569c <HAL_RCCEx_GetPeriphCLKFreq+0x25c>)
 800550e:	fbb2 f3f3 	udiv	r3, r2, r3
 8005512:	613b      	str	r3, [r7, #16]
 8005514:	e007      	b.n	8005526 <HAL_RCCEx_GetPeriphCLKFreq+0xe6>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 8005516:	4b60      	ldr	r3, [pc, #384]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005518:	685b      	ldr	r3, [r3, #4]
 800551a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800551e:	4a60      	ldr	r2, [pc, #384]	; (80056a0 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
 8005520:	fbb2 f3f3 	udiv	r3, r2, r3
 8005524:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 8005526:	4b5c      	ldr	r3, [pc, #368]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005528:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800552c:	0e1b      	lsrs	r3, r3, #24
 800552e:	f003 030f 	and.w	r3, r3, #15
 8005532:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 8005534:	4b58      	ldr	r3, [pc, #352]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005536:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 800553a:	099b      	lsrs	r3, r3, #6
 800553c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005540:	693a      	ldr	r2, [r7, #16]
 8005542:	fb02 f203 	mul.w	r2, r2, r3
 8005546:	68fb      	ldr	r3, [r7, #12]
 8005548:	fbb2 f3f3 	udiv	r3, r2, r3
 800554c:	617b      	str	r3, [r7, #20]
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 800554e:	4b52      	ldr	r3, [pc, #328]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005550:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005554:	f003 031f 	and.w	r3, r3, #31
 8005558:	3301      	adds	r3, #1
 800555a:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
 800555c:	697a      	ldr	r2, [r7, #20]
 800555e:	68fb      	ldr	r3, [r7, #12]
 8005560:	fbb2 f3f3 	udiv	r3, r2, r3
 8005564:	617b      	str	r3, [r7, #20]
        break;
 8005566:	e003      	b.n	8005570 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
        frequency = EXTERNAL_CLOCK_VALUE;
 8005568:	4b4e      	ldr	r3, [pc, #312]	; (80056a4 <HAL_RCCEx_GetPeriphCLKFreq+0x264>)
 800556a:	617b      	str	r3, [r7, #20]
        break;
 800556c:	e000      	b.n	8005570 <HAL_RCCEx_GetPeriphCLKFreq+0x130>
      }
    }
  }
 800556e:	bf00      	nop

  if (PeriphClk == RCC_PERIPHCLK_SAI2)
 8005570:	687b      	ldr	r3, [r7, #4]
 8005572:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8005576:	f040 8086 	bne.w	8005686 <HAL_RCCEx_GetPeriphCLKFreq+0x246>
  {
    saiclocksource = RCC->DCKCFGR1;
 800557a:	4b47      	ldr	r3, [pc, #284]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 800557c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8005580:	60bb      	str	r3, [r7, #8]
    saiclocksource &= RCC_DCKCFGR1_SAI2SEL;
 8005582:	68bb      	ldr	r3, [r7, #8]
 8005584:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
 8005588:	60bb      	str	r3, [r7, #8]
    switch (saiclocksource)
 800558a:	68bb      	ldr	r3, [r7, #8]
 800558c:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8005590:	d03e      	beq.n	8005610 <HAL_RCCEx_GetPeriphCLKFreq+0x1d0>
 8005592:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 8005596:	d073      	beq.n	8005680 <HAL_RCCEx_GetPeriphCLKFreq+0x240>
 8005598:	2b00      	cmp	r3, #0
 800559a:	d000      	beq.n	800559e <HAL_RCCEx_GetPeriphCLKFreq+0x15e>
        break;
      }
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
    default :
      {
        break;
 800559c:	e074      	b.n	8005688 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 800559e:	4b3e      	ldr	r3, [pc, #248]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80055a0:	685b      	ldr	r3, [r3, #4]
 80055a2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80055a6:	2b00      	cmp	r3, #0
 80055a8:	d108      	bne.n	80055bc <HAL_RCCEx_GetPeriphCLKFreq+0x17c>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 80055aa:	4b3b      	ldr	r3, [pc, #236]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80055ac:	685b      	ldr	r3, [r3, #4]
 80055ae:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80055b2:	4a3a      	ldr	r2, [pc, #232]	; (800569c <HAL_RCCEx_GetPeriphCLKFreq+0x25c>)
 80055b4:	fbb2 f3f3 	udiv	r3, r2, r3
 80055b8:	613b      	str	r3, [r7, #16]
 80055ba:	e007      	b.n	80055cc <HAL_RCCEx_GetPeriphCLKFreq+0x18c>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 80055bc:	4b36      	ldr	r3, [pc, #216]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80055be:	685b      	ldr	r3, [r3, #4]
 80055c0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80055c4:	4a36      	ldr	r2, [pc, #216]	; (80056a0 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
 80055c6:	fbb2 f3f3 	udiv	r3, r2, r3
 80055ca:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> 24;
 80055cc:	4b32      	ldr	r3, [pc, #200]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80055ce:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80055d2:	0e1b      	lsrs	r3, r3, #24
 80055d4:	f003 030f 	and.w	r3, r3, #15
 80055d8:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIN) >> 6))/(tmpreg);
 80055da:	4b2f      	ldr	r3, [pc, #188]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80055dc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80055e0:	099b      	lsrs	r3, r3, #6
 80055e2:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80055e6:	693a      	ldr	r2, [r7, #16]
 80055e8:	fb02 f203 	mul.w	r2, r2, r3
 80055ec:	68fb      	ldr	r3, [r7, #12]
 80055ee:	fbb2 f3f3 	udiv	r3, r2, r3
 80055f2:	617b      	str	r3, [r7, #20]
        tmpreg = (((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLSAIDIVQ) >> 8) + 1);
 80055f4:	4b28      	ldr	r3, [pc, #160]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 80055f6:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80055fa:	0a1b      	lsrs	r3, r3, #8
 80055fc:	f003 031f 	and.w	r3, r3, #31
 8005600:	3301      	adds	r3, #1
 8005602:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
 8005604:	697a      	ldr	r2, [r7, #20]
 8005606:	68fb      	ldr	r3, [r7, #12]
 8005608:	fbb2 f3f3 	udiv	r3, r2, r3
 800560c:	617b      	str	r3, [r7, #20]
        break;
 800560e:	e03b      	b.n	8005688 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
        if((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLSOURCE_HSI)
 8005610:	4b21      	ldr	r3, [pc, #132]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005612:	685b      	ldr	r3, [r3, #4]
 8005614:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8005618:	2b00      	cmp	r3, #0
 800561a:	d108      	bne.n	800562e <HAL_RCCEx_GetPeriphCLKFreq+0x1ee>
          vcoinput = (HSI_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM));
 800561c:	4b1e      	ldr	r3, [pc, #120]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 800561e:	685b      	ldr	r3, [r3, #4]
 8005620:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8005624:	4a1d      	ldr	r2, [pc, #116]	; (800569c <HAL_RCCEx_GetPeriphCLKFreq+0x25c>)
 8005626:	fbb2 f3f3 	udiv	r3, r2, r3
 800562a:	613b      	str	r3, [r7, #16]
 800562c:	e007      	b.n	800563e <HAL_RCCEx_GetPeriphCLKFreq+0x1fe>
          vcoinput = ((HSE_VALUE / (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM)));
 800562e:	4b1a      	ldr	r3, [pc, #104]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005630:	685b      	ldr	r3, [r3, #4]
 8005632:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8005636:	4a1a      	ldr	r2, [pc, #104]	; (80056a0 <HAL_RCCEx_GetPeriphCLKFreq+0x260>)
 8005638:	fbb2 f3f3 	udiv	r3, r2, r3
 800563c:	613b      	str	r3, [r7, #16]
        tmpreg = (RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> 24;
 800563e:	4b16      	ldr	r3, [pc, #88]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005640:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005644:	0e1b      	lsrs	r3, r3, #24
 8005646:	f003 030f 	and.w	r3, r3, #15
 800564a:	60fb      	str	r3, [r7, #12]
        frequency = (vcoinput * ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6))/(tmpreg);
 800564c:	4b12      	ldr	r3, [pc, #72]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 800564e:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8005652:	099b      	lsrs	r3, r3, #6
 8005654:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8005658:	693a      	ldr	r2, [r7, #16]
 800565a:	fb02 f203 	mul.w	r2, r2, r3
 800565e:	68fb      	ldr	r3, [r7, #12]
 8005660:	fbb2 f3f3 	udiv	r3, r2, r3
 8005664:	617b      	str	r3, [r7, #20]
        tmpreg = ((RCC->DCKCFGR1 & RCC_DCKCFGR1_PLLI2SDIVQ) + 1);
 8005666:	4b0c      	ldr	r3, [pc, #48]	; (8005698 <HAL_RCCEx_GetPeriphCLKFreq+0x258>)
 8005668:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800566c:	f003 031f 	and.w	r3, r3, #31
 8005670:	3301      	adds	r3, #1
 8005672:	60fb      	str	r3, [r7, #12]
        frequency = frequency/(tmpreg);
 8005674:	697a      	ldr	r2, [r7, #20]
 8005676:	68fb      	ldr	r3, [r7, #12]
 8005678:	fbb2 f3f3 	udiv	r3, r2, r3
 800567c:	617b      	str	r3, [r7, #20]
        break;
 800567e:	e003      	b.n	8005688 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
        frequency = EXTERNAL_CLOCK_VALUE;
 8005680:	4b08      	ldr	r3, [pc, #32]	; (80056a4 <HAL_RCCEx_GetPeriphCLKFreq+0x264>)
 8005682:	617b      	str	r3, [r7, #20]
        break;
 8005684:	e000      	b.n	8005688 <HAL_RCCEx_GetPeriphCLKFreq+0x248>
      }
    }
  }
 8005686:	bf00      	nop

  return frequency;
 8005688:	697b      	ldr	r3, [r7, #20]
}
 800568a:	4618      	mov	r0, r3
 800568c:	371c      	adds	r7, #28
 800568e:	46bd      	mov	sp, r7
 8005690:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005694:	4770      	bx	lr
 8005696:	bf00      	nop
 8005698:	40023800 	.word	0x40023800
 800569c:	00f42400 	.word	0x00f42400
 80056a0:	017d7840 	.word	0x017d7840
 80056a4:	00bb8000 	.word	0x00bb8000

080056a8 <HAL_RTC_Init>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 80056a8:	b580      	push	{r7, lr}
 80056aa:	b082      	sub	sp, #8
 80056ac:	af00      	add	r7, sp, #0
 80056ae:	6078      	str	r0, [r7, #4]
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 80056b0:	687b      	ldr	r3, [r7, #4]
 80056b2:	2b00      	cmp	r3, #0
 80056b4:	d101      	bne.n	80056ba <HAL_RTC_Init+0x12>
  {
     return HAL_ERROR;
 80056b6:	2301      	movs	r3, #1
 80056b8:	e06b      	b.n	8005792 <HAL_RTC_Init+0xea>
    {
      hrtc->MspDeInitCallback = HAL_RTC_MspDeInit;
    }
  }
#else
  if(hrtc->State == HAL_RTC_STATE_RESET)
 80056ba:	687b      	ldr	r3, [r7, #4]
 80056bc:	7f5b      	ldrb	r3, [r3, #29]
 80056be:	b2db      	uxtb	r3, r3
 80056c0:	2b00      	cmp	r3, #0
 80056c2:	d105      	bne.n	80056d0 <HAL_RTC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 80056c4:	687b      	ldr	r3, [r7, #4]
 80056c6:	2200      	movs	r2, #0
 80056c8:	771a      	strb	r2, [r3, #28]

    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 80056ca:	6878      	ldr	r0, [r7, #4]
 80056cc:	f004 fa7a 	bl	8009bc4 <HAL_RTC_MspInit>
  }
#endif /* (USE_HAL_RTC_REGISTER_CALLBACKS) */

  /* Set RTC state */
  hrtc->State = HAL_RTC_STATE_BUSY;
 80056d0:	687b      	ldr	r3, [r7, #4]
 80056d2:	2202      	movs	r2, #2
 80056d4:	775a      	strb	r2, [r3, #29]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80056d6:	687b      	ldr	r3, [r7, #4]
 80056d8:	681b      	ldr	r3, [r3, #0]
 80056da:	22ca      	movs	r2, #202	; 0xca
 80056dc:	625a      	str	r2, [r3, #36]	; 0x24
 80056de:	687b      	ldr	r3, [r7, #4]
 80056e0:	681b      	ldr	r3, [r3, #0]
 80056e2:	2253      	movs	r2, #83	; 0x53
 80056e4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80056e6:	6878      	ldr	r0, [r7, #4]
 80056e8:	f000 fb00 	bl	8005cec <RTC_EnterInitMode>
 80056ec:	4603      	mov	r3, r0
 80056ee:	2b00      	cmp	r3, #0
 80056f0:	d008      	beq.n	8005704 <HAL_RTC_Init+0x5c>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80056f2:	687b      	ldr	r3, [r7, #4]
 80056f4:	681b      	ldr	r3, [r3, #0]
 80056f6:	22ff      	movs	r2, #255	; 0xff
 80056f8:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 80056fa:	687b      	ldr	r3, [r7, #4]
 80056fc:	2204      	movs	r2, #4
 80056fe:	775a      	strb	r2, [r3, #29]

    return HAL_ERROR;
 8005700:	2301      	movs	r3, #1
 8005702:	e046      	b.n	8005792 <HAL_RTC_Init+0xea>
  }
  else
  {
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8005704:	687b      	ldr	r3, [r7, #4]
 8005706:	681b      	ldr	r3, [r3, #0]
 8005708:	6899      	ldr	r1, [r3, #8]
 800570a:	687b      	ldr	r3, [r7, #4]
 800570c:	681a      	ldr	r2, [r3, #0]
 800570e:	4b23      	ldr	r3, [pc, #140]	; (800579c <HAL_RTC_Init+0xf4>)
 8005710:	400b      	ands	r3, r1
 8005712:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8005714:	687b      	ldr	r3, [r7, #4]
 8005716:	681b      	ldr	r3, [r3, #0]
 8005718:	6899      	ldr	r1, [r3, #8]
 800571a:	687b      	ldr	r3, [r7, #4]
 800571c:	685a      	ldr	r2, [r3, #4]
 800571e:	687b      	ldr	r3, [r7, #4]
 8005720:	691b      	ldr	r3, [r3, #16]
 8005722:	431a      	orrs	r2, r3
 8005724:	687b      	ldr	r3, [r7, #4]
 8005726:	695b      	ldr	r3, [r3, #20]
 8005728:	431a      	orrs	r2, r3
 800572a:	687b      	ldr	r3, [r7, #4]
 800572c:	681b      	ldr	r3, [r3, #0]
 800572e:	430a      	orrs	r2, r1
 8005730:	609a      	str	r2, [r3, #8]

    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8005732:	687b      	ldr	r3, [r7, #4]
 8005734:	681b      	ldr	r3, [r3, #0]
 8005736:	687a      	ldr	r2, [r7, #4]
 8005738:	68d2      	ldr	r2, [r2, #12]
 800573a:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 800573c:	687b      	ldr	r3, [r7, #4]
 800573e:	681b      	ldr	r3, [r3, #0]
 8005740:	6919      	ldr	r1, [r3, #16]
 8005742:	687b      	ldr	r3, [r7, #4]
 8005744:	689b      	ldr	r3, [r3, #8]
 8005746:	041a      	lsls	r2, r3, #16
 8005748:	687b      	ldr	r3, [r7, #4]
 800574a:	681b      	ldr	r3, [r3, #0]
 800574c:	430a      	orrs	r2, r1
 800574e:	611a      	str	r2, [r3, #16]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8005750:	687b      	ldr	r3, [r7, #4]
 8005752:	681b      	ldr	r3, [r3, #0]
 8005754:	68da      	ldr	r2, [r3, #12]
 8005756:	687b      	ldr	r3, [r7, #4]
 8005758:	681b      	ldr	r3, [r3, #0]
 800575a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800575e:	60da      	str	r2, [r3, #12]

    hrtc->Instance->OR &= (uint32_t)~RTC_OR_ALARMTYPE;
 8005760:	687b      	ldr	r3, [r7, #4]
 8005762:	681b      	ldr	r3, [r3, #0]
 8005764:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005766:	687b      	ldr	r3, [r7, #4]
 8005768:	681b      	ldr	r3, [r3, #0]
 800576a:	f022 0208 	bic.w	r2, r2, #8
 800576e:	64da      	str	r2, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType);
 8005770:	687b      	ldr	r3, [r7, #4]
 8005772:	681b      	ldr	r3, [r3, #0]
 8005774:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8005776:	687b      	ldr	r3, [r7, #4]
 8005778:	699a      	ldr	r2, [r3, #24]
 800577a:	687b      	ldr	r3, [r7, #4]
 800577c:	681b      	ldr	r3, [r3, #0]
 800577e:	430a      	orrs	r2, r1
 8005780:	64da      	str	r2, [r3, #76]	; 0x4c

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005782:	687b      	ldr	r3, [r7, #4]
 8005784:	681b      	ldr	r3, [r3, #0]
 8005786:	22ff      	movs	r2, #255	; 0xff
 8005788:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 800578a:	687b      	ldr	r3, [r7, #4]
 800578c:	2201      	movs	r2, #1
 800578e:	775a      	strb	r2, [r3, #29]

    return HAL_OK;
 8005790:	2300      	movs	r3, #0
  }
}
 8005792:	4618      	mov	r0, r3
 8005794:	3708      	adds	r7, #8
 8005796:	46bd      	mov	sp, r7
 8005798:	bd80      	pop	{r7, pc}
 800579a:	bf00      	nop
 800579c:	ff8fffbf 	.word	0xff8fffbf

080057a0 <HAL_RTC_SetTime>:
  *            @arg FORMAT_BIN: Binary data format
  *            @arg FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetTime(RTC_HandleTypeDef *hrtc, RTC_TimeTypeDef *sTime, uint32_t Format)
{
 80057a0:	b590      	push	{r4, r7, lr}
 80057a2:	b087      	sub	sp, #28
 80057a4:	af00      	add	r7, sp, #0
 80057a6:	60f8      	str	r0, [r7, #12]
 80057a8:	60b9      	str	r1, [r7, #8]
 80057aa:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 80057ac:	2300      	movs	r3, #0
 80057ae:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_FORMAT(Format));
  assert_param(IS_RTC_DAYLIGHT_SAVING(sTime->DayLightSaving));
  assert_param(IS_RTC_STORE_OPERATION(sTime->StoreOperation));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 80057b0:	68fb      	ldr	r3, [r7, #12]
 80057b2:	7f1b      	ldrb	r3, [r3, #28]
 80057b4:	2b01      	cmp	r3, #1
 80057b6:	d101      	bne.n	80057bc <HAL_RTC_SetTime+0x1c>
 80057b8:	2302      	movs	r3, #2
 80057ba:	e0a8      	b.n	800590e <HAL_RTC_SetTime+0x16e>
 80057bc:	68fb      	ldr	r3, [r7, #12]
 80057be:	2201      	movs	r2, #1
 80057c0:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 80057c2:	68fb      	ldr	r3, [r7, #12]
 80057c4:	2202      	movs	r2, #2
 80057c6:	775a      	strb	r2, [r3, #29]

  if(Format == RTC_FORMAT_BIN)
 80057c8:	687b      	ldr	r3, [r7, #4]
 80057ca:	2b00      	cmp	r3, #0
 80057cc:	d126      	bne.n	800581c <HAL_RTC_SetTime+0x7c>
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80057ce:	68fb      	ldr	r3, [r7, #12]
 80057d0:	681b      	ldr	r3, [r3, #0]
 80057d2:	689b      	ldr	r3, [r3, #8]
 80057d4:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80057d8:	2b00      	cmp	r3, #0
 80057da:	d102      	bne.n	80057e2 <HAL_RTC_SetTime+0x42>
      assert_param(IS_RTC_HOUR12(sTime->Hours));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00;
 80057dc:	68bb      	ldr	r3, [r7, #8]
 80057de:	2200      	movs	r2, #0
 80057e0:	731a      	strb	r2, [r3, #12]
      assert_param(IS_RTC_HOUR24(sTime->Hours));
    }
    assert_param(IS_RTC_MINUTES(sTime->Minutes));
    assert_param(IS_RTC_SECONDS(sTime->Seconds));

    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 80057e2:	68bb      	ldr	r3, [r7, #8]
 80057e4:	781b      	ldrb	r3, [r3, #0]
 80057e6:	4618      	mov	r0, r3
 80057e8:	f000 faac 	bl	8005d44 <RTC_ByteToBcd2>
 80057ec:	4603      	mov	r3, r0
 80057ee:	041c      	lsls	r4, r3, #16
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 80057f0:	68bb      	ldr	r3, [r7, #8]
 80057f2:	785b      	ldrb	r3, [r3, #1]
 80057f4:	4618      	mov	r0, r3
 80057f6:	f000 faa5 	bl	8005d44 <RTC_ByteToBcd2>
 80057fa:	4603      	mov	r3, r0
 80057fc:	021b      	lsls	r3, r3, #8
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 80057fe:	431c      	orrs	r4, r3
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 8005800:	68bb      	ldr	r3, [r7, #8]
 8005802:	789b      	ldrb	r3, [r3, #2]
 8005804:	4618      	mov	r0, r3
 8005806:	f000 fa9d 	bl	8005d44 <RTC_ByteToBcd2>
 800580a:	4603      	mov	r3, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 800580c:	ea44 0203 	orr.w	r2, r4, r3
                        (((uint32_t)sTime->TimeFormat) << 16));
 8005810:	68bb      	ldr	r3, [r7, #8]
 8005812:	7b1b      	ldrb	r3, [r3, #12]
 8005814:	041b      	lsls	r3, r3, #16
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8005816:	4313      	orrs	r3, r2
 8005818:	617b      	str	r3, [r7, #20]
 800581a:	e018      	b.n	800584e <HAL_RTC_SetTime+0xae>
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 800581c:	68fb      	ldr	r3, [r7, #12]
 800581e:	681b      	ldr	r3, [r3, #0]
 8005820:	689b      	ldr	r3, [r3, #8]
 8005822:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005826:	2b00      	cmp	r3, #0
 8005828:	d102      	bne.n	8005830 <HAL_RTC_SetTime+0x90>
      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sTime->Hours)));
      assert_param(IS_RTC_HOURFORMAT12(sTime->TimeFormat));
    }
    else
    {
      sTime->TimeFormat = 0x00;
 800582a:	68bb      	ldr	r3, [r7, #8]
 800582c:	2200      	movs	r2, #0
 800582e:	731a      	strb	r2, [r3, #12]
      assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(sTime->Hours)));
    }
    assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(sTime->Minutes)));
    assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(sTime->Seconds)));
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 8005830:	68bb      	ldr	r3, [r7, #8]
 8005832:	781b      	ldrb	r3, [r3, #0]
 8005834:	041a      	lsls	r2, r3, #16
              ((uint32_t)(sTime->Minutes) << 8) | \
 8005836:	68bb      	ldr	r3, [r7, #8]
 8005838:	785b      	ldrb	r3, [r3, #1]
 800583a:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 800583c:	4313      	orrs	r3, r2
              ((uint32_t)sTime->Seconds) | \
 800583e:	68ba      	ldr	r2, [r7, #8]
 8005840:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(sTime->Minutes) << 8) | \
 8005842:	431a      	orrs	r2, r3
              ((uint32_t)(sTime->TimeFormat) << 16));
 8005844:	68bb      	ldr	r3, [r7, #8]
 8005846:	7b1b      	ldrb	r3, [r3, #12]
 8005848:	041b      	lsls	r3, r3, #16
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 800584a:	4313      	orrs	r3, r2
 800584c:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 800584e:	68fb      	ldr	r3, [r7, #12]
 8005850:	681b      	ldr	r3, [r3, #0]
 8005852:	22ca      	movs	r2, #202	; 0xca
 8005854:	625a      	str	r2, [r3, #36]	; 0x24
 8005856:	68fb      	ldr	r3, [r7, #12]
 8005858:	681b      	ldr	r3, [r3, #0]
 800585a:	2253      	movs	r2, #83	; 0x53
 800585c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 800585e:	68f8      	ldr	r0, [r7, #12]
 8005860:	f000 fa44 	bl	8005cec <RTC_EnterInitMode>
 8005864:	4603      	mov	r3, r0
 8005866:	2b00      	cmp	r3, #0
 8005868:	d00b      	beq.n	8005882 <HAL_RTC_SetTime+0xe2>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800586a:	68fb      	ldr	r3, [r7, #12]
 800586c:	681b      	ldr	r3, [r3, #0]
 800586e:	22ff      	movs	r2, #255	; 0xff
 8005870:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8005872:	68fb      	ldr	r3, [r7, #12]
 8005874:	2204      	movs	r2, #4
 8005876:	775a      	strb	r2, [r3, #29]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8005878:	68fb      	ldr	r3, [r7, #12]
 800587a:	2200      	movs	r2, #0
 800587c:	771a      	strb	r2, [r3, #28]

    return HAL_ERROR;
 800587e:	2301      	movs	r3, #1
 8005880:	e045      	b.n	800590e <HAL_RTC_SetTime+0x16e>
  }
  else
  {
    /* Set the RTC_TR register */
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 8005882:	68fb      	ldr	r3, [r7, #12]
 8005884:	681a      	ldr	r2, [r3, #0]
 8005886:	6979      	ldr	r1, [r7, #20]
 8005888:	4b23      	ldr	r3, [pc, #140]	; (8005918 <HAL_RTC_SetTime+0x178>)
 800588a:	400b      	ands	r3, r1
 800588c:	6013      	str	r3, [r2, #0]

    /* Clear the bits to be configured */
    hrtc->Instance->CR &= (uint32_t)~RTC_CR_BKP;
 800588e:	68fb      	ldr	r3, [r7, #12]
 8005890:	681b      	ldr	r3, [r3, #0]
 8005892:	689a      	ldr	r2, [r3, #8]
 8005894:	68fb      	ldr	r3, [r7, #12]
 8005896:	681b      	ldr	r3, [r3, #0]
 8005898:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800589c:	609a      	str	r2, [r3, #8]

    /* Configure the RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 800589e:	68fb      	ldr	r3, [r7, #12]
 80058a0:	681b      	ldr	r3, [r3, #0]
 80058a2:	6899      	ldr	r1, [r3, #8]
 80058a4:	68bb      	ldr	r3, [r7, #8]
 80058a6:	691a      	ldr	r2, [r3, #16]
 80058a8:	68bb      	ldr	r3, [r7, #8]
 80058aa:	695b      	ldr	r3, [r3, #20]
 80058ac:	431a      	orrs	r2, r3
 80058ae:	68fb      	ldr	r3, [r7, #12]
 80058b0:	681b      	ldr	r3, [r3, #0]
 80058b2:	430a      	orrs	r2, r1
 80058b4:	609a      	str	r2, [r3, #8]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 80058b6:	68fb      	ldr	r3, [r7, #12]
 80058b8:	681b      	ldr	r3, [r3, #0]
 80058ba:	68da      	ldr	r2, [r3, #12]
 80058bc:	68fb      	ldr	r3, [r7, #12]
 80058be:	681b      	ldr	r3, [r3, #0]
 80058c0:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 80058c4:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 80058c6:	68fb      	ldr	r3, [r7, #12]
 80058c8:	681b      	ldr	r3, [r3, #0]
 80058ca:	689b      	ldr	r3, [r3, #8]
 80058cc:	f003 0320 	and.w	r3, r3, #32
 80058d0:	2b00      	cmp	r3, #0
 80058d2:	d111      	bne.n	80058f8 <HAL_RTC_SetTime+0x158>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 80058d4:	68f8      	ldr	r0, [r7, #12]
 80058d6:	f000 f9e1 	bl	8005c9c <HAL_RTC_WaitForSynchro>
 80058da:	4603      	mov	r3, r0
 80058dc:	2b00      	cmp	r3, #0
 80058de:	d00b      	beq.n	80058f8 <HAL_RTC_SetTime+0x158>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80058e0:	68fb      	ldr	r3, [r7, #12]
 80058e2:	681b      	ldr	r3, [r3, #0]
 80058e4:	22ff      	movs	r2, #255	; 0xff
 80058e6:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 80058e8:	68fb      	ldr	r3, [r7, #12]
 80058ea:	2204      	movs	r2, #4
 80058ec:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 80058ee:	68fb      	ldr	r3, [r7, #12]
 80058f0:	2200      	movs	r2, #0
 80058f2:	771a      	strb	r2, [r3, #28]

        return HAL_ERROR;
 80058f4:	2301      	movs	r3, #1
 80058f6:	e00a      	b.n	800590e <HAL_RTC_SetTime+0x16e>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80058f8:	68fb      	ldr	r3, [r7, #12]
 80058fa:	681b      	ldr	r3, [r3, #0]
 80058fc:	22ff      	movs	r2, #255	; 0xff
 80058fe:	625a      	str	r2, [r3, #36]	; 0x24

   hrtc->State = HAL_RTC_STATE_READY;
 8005900:	68fb      	ldr	r3, [r7, #12]
 8005902:	2201      	movs	r2, #1
 8005904:	775a      	strb	r2, [r3, #29]

   __HAL_UNLOCK(hrtc);
 8005906:	68fb      	ldr	r3, [r7, #12]
 8005908:	2200      	movs	r2, #0
 800590a:	771a      	strb	r2, [r3, #28]

   return HAL_OK;
 800590c:	2300      	movs	r3, #0
  }
}
 800590e:	4618      	mov	r0, r3
 8005910:	371c      	adds	r7, #28
 8005912:	46bd      	mov	sp, r7
 8005914:	bd90      	pop	{r4, r7, pc}
 8005916:	bf00      	nop
 8005918:	007f7f7f 	.word	0x007f7f7f

0800591c <HAL_RTC_SetDate>:
  *            @arg RTC_FORMAT_BIN: Binary data format
  *            @arg RTC_FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetDate(RTC_HandleTypeDef *hrtc, RTC_DateTypeDef *sDate, uint32_t Format)
{
 800591c:	b590      	push	{r4, r7, lr}
 800591e:	b087      	sub	sp, #28
 8005920:	af00      	add	r7, sp, #0
 8005922:	60f8      	str	r0, [r7, #12]
 8005924:	60b9      	str	r1, [r7, #8]
 8005926:	607a      	str	r2, [r7, #4]
  uint32_t datetmpreg = 0;
 8005928:	2300      	movs	r3, #0
 800592a:	617b      	str	r3, [r7, #20]

 /* Check the parameters */
  assert_param(IS_RTC_FORMAT(Format));

 /* Process Locked */
 __HAL_LOCK(hrtc);
 800592c:	68fb      	ldr	r3, [r7, #12]
 800592e:	7f1b      	ldrb	r3, [r3, #28]
 8005930:	2b01      	cmp	r3, #1
 8005932:	d101      	bne.n	8005938 <HAL_RTC_SetDate+0x1c>
 8005934:	2302      	movs	r3, #2
 8005936:	e092      	b.n	8005a5e <HAL_RTC_SetDate+0x142>
 8005938:	68fb      	ldr	r3, [r7, #12]
 800593a:	2201      	movs	r2, #1
 800593c:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 800593e:	68fb      	ldr	r3, [r7, #12]
 8005940:	2202      	movs	r2, #2
 8005942:	775a      	strb	r2, [r3, #29]

  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8005944:	687b      	ldr	r3, [r7, #4]
 8005946:	2b00      	cmp	r3, #0
 8005948:	d10e      	bne.n	8005968 <HAL_RTC_SetDate+0x4c>
 800594a:	68bb      	ldr	r3, [r7, #8]
 800594c:	785b      	ldrb	r3, [r3, #1]
 800594e:	f003 0310 	and.w	r3, r3, #16
 8005952:	2b00      	cmp	r3, #0
 8005954:	d008      	beq.n	8005968 <HAL_RTC_SetDate+0x4c>
  {
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8005956:	68bb      	ldr	r3, [r7, #8]
 8005958:	785b      	ldrb	r3, [r3, #1]
 800595a:	f023 0310 	bic.w	r3, r3, #16
 800595e:	b2db      	uxtb	r3, r3
 8005960:	330a      	adds	r3, #10
 8005962:	b2da      	uxtb	r2, r3
 8005964:	68bb      	ldr	r3, [r7, #8]
 8005966:	705a      	strb	r2, [r3, #1]
  }

  assert_param(IS_RTC_WEEKDAY(sDate->WeekDay));

  if(Format == RTC_FORMAT_BIN)
 8005968:	687b      	ldr	r3, [r7, #4]
 800596a:	2b00      	cmp	r3, #0
 800596c:	d11c      	bne.n	80059a8 <HAL_RTC_SetDate+0x8c>
  {
    assert_param(IS_RTC_YEAR(sDate->Year));
    assert_param(IS_RTC_MONTH(sDate->Month));
    assert_param(IS_RTC_DATE(sDate->Date));

   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 800596e:	68bb      	ldr	r3, [r7, #8]
 8005970:	78db      	ldrb	r3, [r3, #3]
 8005972:	4618      	mov	r0, r3
 8005974:	f000 f9e6 	bl	8005d44 <RTC_ByteToBcd2>
 8005978:	4603      	mov	r3, r0
 800597a:	041c      	lsls	r4, r3, #16
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 800597c:	68bb      	ldr	r3, [r7, #8]
 800597e:	785b      	ldrb	r3, [r3, #1]
 8005980:	4618      	mov	r0, r3
 8005982:	f000 f9df 	bl	8005d44 <RTC_ByteToBcd2>
 8005986:	4603      	mov	r3, r0
 8005988:	021b      	lsls	r3, r3, #8
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 800598a:	431c      	orrs	r4, r3
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 800598c:	68bb      	ldr	r3, [r7, #8]
 800598e:	789b      	ldrb	r3, [r3, #2]
 8005990:	4618      	mov	r0, r3
 8005992:	f000 f9d7 	bl	8005d44 <RTC_ByteToBcd2>
 8005996:	4603      	mov	r3, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8005998:	ea44 0203 	orr.w	r2, r4, r3
                 ((uint32_t)sDate->WeekDay << 13));
 800599c:	68bb      	ldr	r3, [r7, #8]
 800599e:	781b      	ldrb	r3, [r3, #0]
 80059a0:	035b      	lsls	r3, r3, #13
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 80059a2:	4313      	orrs	r3, r2
 80059a4:	617b      	str	r3, [r7, #20]
 80059a6:	e00e      	b.n	80059c6 <HAL_RTC_SetDate+0xaa>
  {
    assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(sDate->Year)));
    assert_param(IS_RTC_MONTH(RTC_Bcd2ToByte(sDate->Month)));
    assert_param(IS_RTC_DATE(RTC_Bcd2ToByte(sDate->Date)));

    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 80059a8:	68bb      	ldr	r3, [r7, #8]
 80059aa:	78db      	ldrb	r3, [r3, #3]
 80059ac:	041a      	lsls	r2, r3, #16
                  (((uint32_t)sDate->Month) << 8) | \
 80059ae:	68bb      	ldr	r3, [r7, #8]
 80059b0:	785b      	ldrb	r3, [r3, #1]
 80059b2:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 80059b4:	4313      	orrs	r3, r2
                  ((uint32_t)sDate->Date) | \
 80059b6:	68ba      	ldr	r2, [r7, #8]
 80059b8:	7892      	ldrb	r2, [r2, #2]
                  (((uint32_t)sDate->Month) << 8) | \
 80059ba:	431a      	orrs	r2, r3
                  (((uint32_t)sDate->WeekDay) << 13));
 80059bc:	68bb      	ldr	r3, [r7, #8]
 80059be:	781b      	ldrb	r3, [r3, #0]
 80059c0:	035b      	lsls	r3, r3, #13
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 80059c2:	4313      	orrs	r3, r2
 80059c4:	617b      	str	r3, [r7, #20]
  }

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80059c6:	68fb      	ldr	r3, [r7, #12]
 80059c8:	681b      	ldr	r3, [r3, #0]
 80059ca:	22ca      	movs	r2, #202	; 0xca
 80059cc:	625a      	str	r2, [r3, #36]	; 0x24
 80059ce:	68fb      	ldr	r3, [r7, #12]
 80059d0:	681b      	ldr	r3, [r3, #0]
 80059d2:	2253      	movs	r2, #83	; 0x53
 80059d4:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80059d6:	68f8      	ldr	r0, [r7, #12]
 80059d8:	f000 f988 	bl	8005cec <RTC_EnterInitMode>
 80059dc:	4603      	mov	r3, r0
 80059de:	2b00      	cmp	r3, #0
 80059e0:	d00b      	beq.n	80059fa <HAL_RTC_SetDate+0xde>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80059e2:	68fb      	ldr	r3, [r7, #12]
 80059e4:	681b      	ldr	r3, [r3, #0]
 80059e6:	22ff      	movs	r2, #255	; 0xff
 80059e8:	625a      	str	r2, [r3, #36]	; 0x24

    /* Set RTC state*/
    hrtc->State = HAL_RTC_STATE_ERROR;
 80059ea:	68fb      	ldr	r3, [r7, #12]
 80059ec:	2204      	movs	r2, #4
 80059ee:	775a      	strb	r2, [r3, #29]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 80059f0:	68fb      	ldr	r3, [r7, #12]
 80059f2:	2200      	movs	r2, #0
 80059f4:	771a      	strb	r2, [r3, #28]

    return HAL_ERROR;
 80059f6:	2301      	movs	r3, #1
 80059f8:	e031      	b.n	8005a5e <HAL_RTC_SetDate+0x142>
  }
  else
  {
    /* Set the RTC_DR register */
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 80059fa:	68fb      	ldr	r3, [r7, #12]
 80059fc:	681a      	ldr	r2, [r3, #0]
 80059fe:	6979      	ldr	r1, [r7, #20]
 8005a00:	4b19      	ldr	r3, [pc, #100]	; (8005a68 <HAL_RTC_SetDate+0x14c>)
 8005a02:	400b      	ands	r3, r1
 8005a04:	6053      	str	r3, [r2, #4]

    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT;
 8005a06:	68fb      	ldr	r3, [r7, #12]
 8005a08:	681b      	ldr	r3, [r3, #0]
 8005a0a:	68da      	ldr	r2, [r3, #12]
 8005a0c:	68fb      	ldr	r3, [r7, #12]
 8005a0e:	681b      	ldr	r3, [r3, #0]
 8005a10:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8005a14:	60da      	str	r2, [r3, #12]

    /* If  CR_BYPSHAD bit = 0, wait for synchro else this check is not needed */
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8005a16:	68fb      	ldr	r3, [r7, #12]
 8005a18:	681b      	ldr	r3, [r3, #0]
 8005a1a:	689b      	ldr	r3, [r3, #8]
 8005a1c:	f003 0320 	and.w	r3, r3, #32
 8005a20:	2b00      	cmp	r3, #0
 8005a22:	d111      	bne.n	8005a48 <HAL_RTC_SetDate+0x12c>
    {
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8005a24:	68f8      	ldr	r0, [r7, #12]
 8005a26:	f000 f939 	bl	8005c9c <HAL_RTC_WaitForSynchro>
 8005a2a:	4603      	mov	r3, r0
 8005a2c:	2b00      	cmp	r3, #0
 8005a2e:	d00b      	beq.n	8005a48 <HAL_RTC_SetDate+0x12c>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005a30:	68fb      	ldr	r3, [r7, #12]
 8005a32:	681b      	ldr	r3, [r3, #0]
 8005a34:	22ff      	movs	r2, #255	; 0xff
 8005a36:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_ERROR;
 8005a38:	68fb      	ldr	r3, [r7, #12]
 8005a3a:	2204      	movs	r2, #4
 8005a3c:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8005a3e:	68fb      	ldr	r3, [r7, #12]
 8005a40:	2200      	movs	r2, #0
 8005a42:	771a      	strb	r2, [r3, #28]

        return HAL_ERROR;
 8005a44:	2301      	movs	r3, #1
 8005a46:	e00a      	b.n	8005a5e <HAL_RTC_SetDate+0x142>
      }
    }

    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005a48:	68fb      	ldr	r3, [r7, #12]
 8005a4a:	681b      	ldr	r3, [r3, #0]
 8005a4c:	22ff      	movs	r2, #255	; 0xff
 8005a4e:	625a      	str	r2, [r3, #36]	; 0x24

    hrtc->State = HAL_RTC_STATE_READY ;
 8005a50:	68fb      	ldr	r3, [r7, #12]
 8005a52:	2201      	movs	r2, #1
 8005a54:	775a      	strb	r2, [r3, #29]

    /* Process Unlocked */
    __HAL_UNLOCK(hrtc);
 8005a56:	68fb      	ldr	r3, [r7, #12]
 8005a58:	2200      	movs	r2, #0
 8005a5a:	771a      	strb	r2, [r3, #28]

    return HAL_OK;
 8005a5c:	2300      	movs	r3, #0
  }
}
 8005a5e:	4618      	mov	r0, r3
 8005a60:	371c      	adds	r7, #28
 8005a62:	46bd      	mov	sp, r7
 8005a64:	bd90      	pop	{r4, r7, pc}
 8005a66:	bf00      	nop
 8005a68:	00ffff3f 	.word	0x00ffff3f

08005a6c <HAL_RTC_SetAlarm>:
  *             @arg FORMAT_BIN: Binary data format
  *             @arg FORMAT_BCD: BCD data format
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_SetAlarm(RTC_HandleTypeDef *hrtc, RTC_AlarmTypeDef *sAlarm, uint32_t Format)
{
 8005a6c:	b590      	push	{r4, r7, lr}
 8005a6e:	b089      	sub	sp, #36	; 0x24
 8005a70:	af00      	add	r7, sp, #0
 8005a72:	60f8      	str	r0, [r7, #12]
 8005a74:	60b9      	str	r1, [r7, #8]
 8005a76:	607a      	str	r2, [r7, #4]
  uint32_t tickstart = 0;
 8005a78:	2300      	movs	r3, #0
 8005a7a:	61bb      	str	r3, [r7, #24]
  uint32_t tmpreg = 0, subsecondtmpreg = 0;
 8005a7c:	2300      	movs	r3, #0
 8005a7e:	61fb      	str	r3, [r7, #28]
 8005a80:	2300      	movs	r3, #0
 8005a82:	617b      	str	r3, [r7, #20]
  assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(sAlarm->AlarmDateWeekDaySel));
  assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(sAlarm->AlarmTime.SubSeconds));
  assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(sAlarm->AlarmSubSecondMask));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8005a84:	68fb      	ldr	r3, [r7, #12]
 8005a86:	7f1b      	ldrb	r3, [r3, #28]
 8005a88:	2b01      	cmp	r3, #1
 8005a8a:	d101      	bne.n	8005a90 <HAL_RTC_SetAlarm+0x24>
 8005a8c:	2302      	movs	r3, #2
 8005a8e:	e101      	b.n	8005c94 <HAL_RTC_SetAlarm+0x228>
 8005a90:	68fb      	ldr	r3, [r7, #12]
 8005a92:	2201      	movs	r2, #1
 8005a94:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8005a96:	68fb      	ldr	r3, [r7, #12]
 8005a98:	2202      	movs	r2, #2
 8005a9a:	775a      	strb	r2, [r3, #29]

  if(Format == RTC_FORMAT_BIN)
 8005a9c:	687b      	ldr	r3, [r7, #4]
 8005a9e:	2b00      	cmp	r3, #0
 8005aa0:	d137      	bne.n	8005b12 <HAL_RTC_SetAlarm+0xa6>
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8005aa2:	68fb      	ldr	r3, [r7, #12]
 8005aa4:	681b      	ldr	r3, [r3, #0]
 8005aa6:	689b      	ldr	r3, [r3, #8]
 8005aa8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005aac:	2b00      	cmp	r3, #0
 8005aae:	d102      	bne.n	8005ab6 <HAL_RTC_SetAlarm+0x4a>
      assert_param(IS_RTC_HOUR12(sAlarm->AlarmTime.Hours));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8005ab0:	68bb      	ldr	r3, [r7, #8]
 8005ab2:	2200      	movs	r2, #0
 8005ab4:	731a      	strb	r2, [r3, #12]
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(sAlarm->AlarmDateWeekDay));
    }

    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8005ab6:	68bb      	ldr	r3, [r7, #8]
 8005ab8:	781b      	ldrb	r3, [r3, #0]
 8005aba:	4618      	mov	r0, r3
 8005abc:	f000 f942 	bl	8005d44 <RTC_ByteToBcd2>
 8005ac0:	4603      	mov	r3, r0
 8005ac2:	041c      	lsls	r4, r3, #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8005ac4:	68bb      	ldr	r3, [r7, #8]
 8005ac6:	785b      	ldrb	r3, [r3, #1]
 8005ac8:	4618      	mov	r0, r3
 8005aca:	f000 f93b 	bl	8005d44 <RTC_ByteToBcd2>
 8005ace:	4603      	mov	r3, r0
 8005ad0:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8005ad2:	431c      	orrs	r4, r3
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8005ad4:	68bb      	ldr	r3, [r7, #8]
 8005ad6:	789b      	ldrb	r3, [r3, #2]
 8005ad8:	4618      	mov	r0, r3
 8005ada:	f000 f933 	bl	8005d44 <RTC_ByteToBcd2>
 8005ade:	4603      	mov	r3, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8005ae0:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
 8005ae4:	68bb      	ldr	r3, [r7, #8]
 8005ae6:	7b1b      	ldrb	r3, [r3, #12]
 8005ae8:	041b      	lsls	r3, r3, #16
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8005aea:	ea42 0403 	orr.w	r4, r2, r3
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8005aee:	68bb      	ldr	r3, [r7, #8]
 8005af0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8005af4:	4618      	mov	r0, r3
 8005af6:	f000 f925 	bl	8005d44 <RTC_ByteToBcd2>
 8005afa:	4603      	mov	r3, r0
 8005afc:	061b      	lsls	r3, r3, #24
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
 8005afe:	ea44 0203 	orr.w	r2, r4, r3
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 8005b02:	68bb      	ldr	r3, [r7, #8]
 8005b04:	6a1b      	ldr	r3, [r3, #32]
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8005b06:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmMask));
 8005b08:	68bb      	ldr	r3, [r7, #8]
 8005b0a:	699b      	ldr	r3, [r3, #24]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8005b0c:	4313      	orrs	r3, r2
 8005b0e:	61fb      	str	r3, [r7, #28]
 8005b10:	e023      	b.n	8005b5a <HAL_RTC_SetAlarm+0xee>
  }
  else
  {
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8005b12:	68fb      	ldr	r3, [r7, #12]
 8005b14:	681b      	ldr	r3, [r3, #0]
 8005b16:	689b      	ldr	r3, [r3, #8]
 8005b18:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005b1c:	2b00      	cmp	r3, #0
 8005b1e:	d102      	bne.n	8005b26 <HAL_RTC_SetAlarm+0xba>
      assert_param(IS_RTC_HOUR12(RTC_Bcd2ToByte(sAlarm->AlarmTime.Hours)));
      assert_param(IS_RTC_HOURFORMAT12(sAlarm->AlarmTime.TimeFormat));
    }
    else
    {
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8005b20:	68bb      	ldr	r3, [r7, #8]
 8005b22:	2200      	movs	r2, #0
 8005b24:	731a      	strb	r2, [r3, #12]
    else
    {
      assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_Bcd2ToByte(sAlarm->AlarmDateWeekDay)));
    }

    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8005b26:	68bb      	ldr	r3, [r7, #8]
 8005b28:	781b      	ldrb	r3, [r3, #0]
 8005b2a:	041a      	lsls	r2, r3, #16
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8) | \
 8005b2c:	68bb      	ldr	r3, [r7, #8]
 8005b2e:	785b      	ldrb	r3, [r3, #1]
 8005b30:	021b      	lsls	r3, r3, #8
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8005b32:	4313      	orrs	r3, r2
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8005b34:	68ba      	ldr	r2, [r7, #8]
 8005b36:	7892      	ldrb	r2, [r2, #2]
              ((uint32_t)(sAlarm->AlarmTime.Minutes) << 8) | \
 8005b38:	431a      	orrs	r2, r3
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
 8005b3a:	68bb      	ldr	r3, [r7, #8]
 8005b3c:	7b1b      	ldrb	r3, [r3, #12]
 8005b3e:	041b      	lsls	r3, r3, #16
              ((uint32_t) sAlarm->AlarmTime.Seconds) | \
 8005b40:	431a      	orrs	r2, r3
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24) | \
 8005b42:	68bb      	ldr	r3, [r7, #8]
 8005b44:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8005b48:	061b      	lsls	r3, r3, #24
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
 8005b4a:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmDateWeekDaySel) | \
 8005b4c:	68bb      	ldr	r3, [r7, #8]
 8005b4e:	6a1b      	ldr	r3, [r3, #32]
              ((uint32_t)(sAlarm->AlarmDateWeekDay) << 24) | \
 8005b50:	431a      	orrs	r2, r3
              ((uint32_t)sAlarm->AlarmMask));
 8005b52:	68bb      	ldr	r3, [r7, #8]
 8005b54:	699b      	ldr	r3, [r3, #24]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8005b56:	4313      	orrs	r3, r2
 8005b58:	61fb      	str	r3, [r7, #28]
  }

  /* Configure the Alarm A or Alarm B Sub Second registers */
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8005b5a:	68bb      	ldr	r3, [r7, #8]
 8005b5c:	685a      	ldr	r2, [r3, #4]
 8005b5e:	68bb      	ldr	r3, [r7, #8]
 8005b60:	69db      	ldr	r3, [r3, #28]
 8005b62:	4313      	orrs	r3, r2
 8005b64:	617b      	str	r3, [r7, #20]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8005b66:	68fb      	ldr	r3, [r7, #12]
 8005b68:	681b      	ldr	r3, [r3, #0]
 8005b6a:	22ca      	movs	r2, #202	; 0xca
 8005b6c:	625a      	str	r2, [r3, #36]	; 0x24
 8005b6e:	68fb      	ldr	r3, [r7, #12]
 8005b70:	681b      	ldr	r3, [r3, #0]
 8005b72:	2253      	movs	r2, #83	; 0x53
 8005b74:	625a      	str	r2, [r3, #36]	; 0x24

  /* Configure the Alarm register */
  if(sAlarm->Alarm == RTC_ALARM_A)
 8005b76:	68bb      	ldr	r3, [r7, #8]
 8005b78:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005b7a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005b7e:	d13f      	bne.n	8005c00 <HAL_RTC_SetAlarm+0x194>
  {
    /* Disable the Alarm A interrupt */
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8005b80:	68fb      	ldr	r3, [r7, #12]
 8005b82:	681b      	ldr	r3, [r3, #0]
 8005b84:	689a      	ldr	r2, [r3, #8]
 8005b86:	68fb      	ldr	r3, [r7, #12]
 8005b88:	681b      	ldr	r3, [r3, #0]
 8005b8a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8005b8e:	609a      	str	r2, [r3, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRA);
 8005b90:	68fb      	ldr	r3, [r7, #12]
 8005b92:	681b      	ldr	r3, [r3, #0]
 8005b94:	689a      	ldr	r2, [r3, #8]
 8005b96:	68fb      	ldr	r3, [r7, #12]
 8005b98:	681b      	ldr	r3, [r3, #0]
 8005b9a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8005b9e:	609a      	str	r2, [r3, #8]

    /* Get tick */
    tickstart = HAL_GetTick();
 8005ba0:	f7fa fd40 	bl	8000624 <HAL_GetTick>
 8005ba4:	61b8      	str	r0, [r7, #24]

    /* Wait till RTC ALRAWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8005ba6:	e013      	b.n	8005bd0 <HAL_RTC_SetAlarm+0x164>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005ba8:	f7fa fd3c 	bl	8000624 <HAL_GetTick>
 8005bac:	4602      	mov	r2, r0
 8005bae:	69bb      	ldr	r3, [r7, #24]
 8005bb0:	1ad3      	subs	r3, r2, r3
 8005bb2:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005bb6:	d90b      	bls.n	8005bd0 <HAL_RTC_SetAlarm+0x164>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005bb8:	68fb      	ldr	r3, [r7, #12]
 8005bba:	681b      	ldr	r3, [r3, #0]
 8005bbc:	22ff      	movs	r2, #255	; 0xff
 8005bbe:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8005bc0:	68fb      	ldr	r3, [r7, #12]
 8005bc2:	2203      	movs	r2, #3
 8005bc4:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8005bc6:	68fb      	ldr	r3, [r7, #12]
 8005bc8:	2200      	movs	r2, #0
 8005bca:	771a      	strb	r2, [r3, #28]

        return HAL_TIMEOUT;
 8005bcc:	2303      	movs	r3, #3
 8005bce:	e061      	b.n	8005c94 <HAL_RTC_SetAlarm+0x228>
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8005bd0:	68fb      	ldr	r3, [r7, #12]
 8005bd2:	681b      	ldr	r3, [r3, #0]
 8005bd4:	68db      	ldr	r3, [r3, #12]
 8005bd6:	f003 0301 	and.w	r3, r3, #1
 8005bda:	2b00      	cmp	r3, #0
 8005bdc:	d0e4      	beq.n	8005ba8 <HAL_RTC_SetAlarm+0x13c>
      }
    }

    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8005bde:	68fb      	ldr	r3, [r7, #12]
 8005be0:	681b      	ldr	r3, [r3, #0]
 8005be2:	69fa      	ldr	r2, [r7, #28]
 8005be4:	61da      	str	r2, [r3, #28]
    /* Configure the Alarm A Sub Second register */
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8005be6:	68fb      	ldr	r3, [r7, #12]
 8005be8:	681b      	ldr	r3, [r3, #0]
 8005bea:	697a      	ldr	r2, [r7, #20]
 8005bec:	645a      	str	r2, [r3, #68]	; 0x44
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8005bee:	68fb      	ldr	r3, [r7, #12]
 8005bf0:	681b      	ldr	r3, [r3, #0]
 8005bf2:	689a      	ldr	r2, [r3, #8]
 8005bf4:	68fb      	ldr	r3, [r7, #12]
 8005bf6:	681b      	ldr	r3, [r3, #0]
 8005bf8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8005bfc:	609a      	str	r2, [r3, #8]
 8005bfe:	e03e      	b.n	8005c7e <HAL_RTC_SetAlarm+0x212>
  }
  else
  {
    /* Disable the Alarm B interrupt */
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8005c00:	68fb      	ldr	r3, [r7, #12]
 8005c02:	681b      	ldr	r3, [r3, #0]
 8005c04:	689a      	ldr	r2, [r3, #8]
 8005c06:	68fb      	ldr	r3, [r7, #12]
 8005c08:	681b      	ldr	r3, [r3, #0]
 8005c0a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8005c0e:	609a      	str	r2, [r3, #8]

    /* In case of interrupt mode is used, the interrupt source must disabled */
    __HAL_RTC_ALARM_DISABLE_IT(hrtc, RTC_IT_ALRB);
 8005c10:	68fb      	ldr	r3, [r7, #12]
 8005c12:	681b      	ldr	r3, [r3, #0]
 8005c14:	689a      	ldr	r2, [r3, #8]
 8005c16:	68fb      	ldr	r3, [r7, #12]
 8005c18:	681b      	ldr	r3, [r3, #0]
 8005c1a:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8005c1e:	609a      	str	r2, [r3, #8]

    /* Get tick */
    tickstart = HAL_GetTick();
 8005c20:	f7fa fd00 	bl	8000624 <HAL_GetTick>
 8005c24:	61b8      	str	r0, [r7, #24]

    /* Wait till RTC ALRBWF flag is set and if Time out is reached exit */
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8005c26:	e013      	b.n	8005c50 <HAL_RTC_SetAlarm+0x1e4>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005c28:	f7fa fcfc 	bl	8000624 <HAL_GetTick>
 8005c2c:	4602      	mov	r2, r0
 8005c2e:	69bb      	ldr	r3, [r7, #24]
 8005c30:	1ad3      	subs	r3, r2, r3
 8005c32:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005c36:	d90b      	bls.n	8005c50 <HAL_RTC_SetAlarm+0x1e4>
      {
        /* Enable the write protection for RTC registers */
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005c38:	68fb      	ldr	r3, [r7, #12]
 8005c3a:	681b      	ldr	r3, [r3, #0]
 8005c3c:	22ff      	movs	r2, #255	; 0xff
 8005c3e:	625a      	str	r2, [r3, #36]	; 0x24

        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8005c40:	68fb      	ldr	r3, [r7, #12]
 8005c42:	2203      	movs	r2, #3
 8005c44:	775a      	strb	r2, [r3, #29]

        /* Process Unlocked */
        __HAL_UNLOCK(hrtc);
 8005c46:	68fb      	ldr	r3, [r7, #12]
 8005c48:	2200      	movs	r2, #0
 8005c4a:	771a      	strb	r2, [r3, #28]

        return HAL_TIMEOUT;
 8005c4c:	2303      	movs	r3, #3
 8005c4e:	e021      	b.n	8005c94 <HAL_RTC_SetAlarm+0x228>
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8005c50:	68fb      	ldr	r3, [r7, #12]
 8005c52:	681b      	ldr	r3, [r3, #0]
 8005c54:	68db      	ldr	r3, [r3, #12]
 8005c56:	f003 0302 	and.w	r3, r3, #2
 8005c5a:	2b00      	cmp	r3, #0
 8005c5c:	d0e4      	beq.n	8005c28 <HAL_RTC_SetAlarm+0x1bc>
      }
    }

    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8005c5e:	68fb      	ldr	r3, [r7, #12]
 8005c60:	681b      	ldr	r3, [r3, #0]
 8005c62:	69fa      	ldr	r2, [r7, #28]
 8005c64:	621a      	str	r2, [r3, #32]
    /* Configure the Alarm B Sub Second register */
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8005c66:	68fb      	ldr	r3, [r7, #12]
 8005c68:	681b      	ldr	r3, [r3, #0]
 8005c6a:	697a      	ldr	r2, [r7, #20]
 8005c6c:	649a      	str	r2, [r3, #72]	; 0x48
    /* Configure the Alarm state: Enable Alarm */
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8005c6e:	68fb      	ldr	r3, [r7, #12]
 8005c70:	681b      	ldr	r3, [r3, #0]
 8005c72:	689a      	ldr	r2, [r3, #8]
 8005c74:	68fb      	ldr	r3, [r7, #12]
 8005c76:	681b      	ldr	r3, [r3, #0]
 8005c78:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8005c7c:	609a      	str	r2, [r3, #8]
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005c7e:	68fb      	ldr	r3, [r7, #12]
 8005c80:	681b      	ldr	r3, [r3, #0]
 8005c82:	22ff      	movs	r2, #255	; 0xff
 8005c84:	625a      	str	r2, [r3, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8005c86:	68fb      	ldr	r3, [r7, #12]
 8005c88:	2201      	movs	r2, #1
 8005c8a:	775a      	strb	r2, [r3, #29]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8005c8c:	68fb      	ldr	r3, [r7, #12]
 8005c8e:	2200      	movs	r2, #0
 8005c90:	771a      	strb	r2, [r3, #28]

  return HAL_OK;
 8005c92:	2300      	movs	r3, #0
}
 8005c94:	4618      	mov	r0, r3
 8005c96:	3724      	adds	r7, #36	; 0x24
 8005c98:	46bd      	mov	sp, r7
 8005c9a:	bd90      	pop	{r4, r7, pc}

08005c9c <HAL_RTC_WaitForSynchro>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
 8005c9c:	b580      	push	{r7, lr}
 8005c9e:	b084      	sub	sp, #16
 8005ca0:	af00      	add	r7, sp, #0
 8005ca2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8005ca4:	2300      	movs	r3, #0
 8005ca6:	60fb      	str	r3, [r7, #12]

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8005ca8:	687b      	ldr	r3, [r7, #4]
 8005caa:	681b      	ldr	r3, [r3, #0]
 8005cac:	68da      	ldr	r2, [r3, #12]
 8005cae:	687b      	ldr	r3, [r7, #4]
 8005cb0:	681b      	ldr	r3, [r3, #0]
 8005cb2:	f022 02a0 	bic.w	r2, r2, #160	; 0xa0
 8005cb6:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8005cb8:	f7fa fcb4 	bl	8000624 <HAL_GetTick>
 8005cbc:	60f8      	str	r0, [r7, #12]

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8005cbe:	e009      	b.n	8005cd4 <HAL_RTC_WaitForSynchro+0x38>
  {
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005cc0:	f7fa fcb0 	bl	8000624 <HAL_GetTick>
 8005cc4:	4602      	mov	r2, r0
 8005cc6:	68fb      	ldr	r3, [r7, #12]
 8005cc8:	1ad3      	subs	r3, r2, r3
 8005cca:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005cce:	d901      	bls.n	8005cd4 <HAL_RTC_WaitForSynchro+0x38>
    {
      return HAL_TIMEOUT;
 8005cd0:	2303      	movs	r3, #3
 8005cd2:	e007      	b.n	8005ce4 <HAL_RTC_WaitForSynchro+0x48>
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8005cd4:	687b      	ldr	r3, [r7, #4]
 8005cd6:	681b      	ldr	r3, [r3, #0]
 8005cd8:	68db      	ldr	r3, [r3, #12]
 8005cda:	f003 0320 	and.w	r3, r3, #32
 8005cde:	2b00      	cmp	r3, #0
 8005ce0:	d0ee      	beq.n	8005cc0 <HAL_RTC_WaitForSynchro+0x24>
    }
  }

  return HAL_OK;
 8005ce2:	2300      	movs	r3, #0
}
 8005ce4:	4618      	mov	r0, r3
 8005ce6:	3710      	adds	r7, #16
 8005ce8:	46bd      	mov	sp, r7
 8005cea:	bd80      	pop	{r7, pc}

08005cec <RTC_EnterInitMode>:
  * @param  hrtc pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8005cec:	b580      	push	{r7, lr}
 8005cee:	b084      	sub	sp, #16
 8005cf0:	af00      	add	r7, sp, #0
 8005cf2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8005cf4:	2300      	movs	r3, #0
 8005cf6:	60fb      	str	r3, [r7, #12]

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8005cf8:	687b      	ldr	r3, [r7, #4]
 8005cfa:	681b      	ldr	r3, [r3, #0]
 8005cfc:	68db      	ldr	r3, [r3, #12]
 8005cfe:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005d02:	2b00      	cmp	r3, #0
 8005d04:	d119      	bne.n	8005d3a <RTC_EnterInitMode+0x4e>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8005d06:	687b      	ldr	r3, [r7, #4]
 8005d08:	681b      	ldr	r3, [r3, #0]
 8005d0a:	f04f 32ff 	mov.w	r2, #4294967295
 8005d0e:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8005d10:	f7fa fc88 	bl	8000624 <HAL_GetTick>
 8005d14:	60f8      	str	r0, [r7, #12]

    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8005d16:	e009      	b.n	8005d2c <RTC_EnterInitMode+0x40>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8005d18:	f7fa fc84 	bl	8000624 <HAL_GetTick>
 8005d1c:	4602      	mov	r2, r0
 8005d1e:	68fb      	ldr	r3, [r7, #12]
 8005d20:	1ad3      	subs	r3, r2, r3
 8005d22:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8005d26:	d901      	bls.n	8005d2c <RTC_EnterInitMode+0x40>
      {
        return HAL_TIMEOUT;
 8005d28:	2303      	movs	r3, #3
 8005d2a:	e007      	b.n	8005d3c <RTC_EnterInitMode+0x50>
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8005d2c:	687b      	ldr	r3, [r7, #4]
 8005d2e:	681b      	ldr	r3, [r3, #0]
 8005d30:	68db      	ldr	r3, [r3, #12]
 8005d32:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8005d36:	2b00      	cmp	r3, #0
 8005d38:	d0ee      	beq.n	8005d18 <RTC_EnterInitMode+0x2c>
      }
    }
  }

  return HAL_OK;
 8005d3a:	2300      	movs	r3, #0
}
 8005d3c:	4618      	mov	r0, r3
 8005d3e:	3710      	adds	r7, #16
 8005d40:	46bd      	mov	sp, r7
 8005d42:	bd80      	pop	{r7, pc}

08005d44 <RTC_ByteToBcd2>:
  * @brief  Converts a 2 digit decimal to BCD format.
  * @param  Value Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
 8005d44:	b480      	push	{r7}
 8005d46:	b085      	sub	sp, #20
 8005d48:	af00      	add	r7, sp, #0
 8005d4a:	4603      	mov	r3, r0
 8005d4c:	71fb      	strb	r3, [r7, #7]
  uint32_t bcdhigh = 0;
 8005d4e:	2300      	movs	r3, #0
 8005d50:	60fb      	str	r3, [r7, #12]

  while(Value >= 10)
 8005d52:	e005      	b.n	8005d60 <RTC_ByteToBcd2+0x1c>
  {
    bcdhigh++;
 8005d54:	68fb      	ldr	r3, [r7, #12]
 8005d56:	3301      	adds	r3, #1
 8005d58:	60fb      	str	r3, [r7, #12]
    Value -= 10;
 8005d5a:	79fb      	ldrb	r3, [r7, #7]
 8005d5c:	3b0a      	subs	r3, #10
 8005d5e:	71fb      	strb	r3, [r7, #7]
  while(Value >= 10)
 8005d60:	79fb      	ldrb	r3, [r7, #7]
 8005d62:	2b09      	cmp	r3, #9
 8005d64:	d8f6      	bhi.n	8005d54 <RTC_ByteToBcd2+0x10>
  }

  return  ((uint8_t)(bcdhigh << 4) | Value);
 8005d66:	68fb      	ldr	r3, [r7, #12]
 8005d68:	b2db      	uxtb	r3, r3
 8005d6a:	011b      	lsls	r3, r3, #4
 8005d6c:	b2da      	uxtb	r2, r3
 8005d6e:	79fb      	ldrb	r3, [r7, #7]
 8005d70:	4313      	orrs	r3, r2
 8005d72:	b2db      	uxtb	r3, r3
}
 8005d74:	4618      	mov	r0, r3
 8005d76:	3714      	adds	r7, #20
 8005d78:	46bd      	mov	sp, r7
 8005d7a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005d7e:	4770      	bx	lr

08005d80 <HAL_RTCEx_SetTimeStamp>:
  *             @arg RTC_TIMESTAMPPIN_PI8: PI8 is selected as RTC TimeStamp Pin.
  *             @arg RTC_TIMESTAMPPIN_PC1: PC1 is selected as RTC TimeStamp Pin.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTCEx_SetTimeStamp(RTC_HandleTypeDef *hrtc, uint32_t TimeStampEdge, uint32_t RTC_TimeStampPin)
{
 8005d80:	b480      	push	{r7}
 8005d82:	b087      	sub	sp, #28
 8005d84:	af00      	add	r7, sp, #0
 8005d86:	60f8      	str	r0, [r7, #12]
 8005d88:	60b9      	str	r1, [r7, #8]
 8005d8a:	607a      	str	r2, [r7, #4]
  uint32_t tmpreg = 0;
 8005d8c:	2300      	movs	r3, #0
 8005d8e:	617b      	str	r3, [r7, #20]
  /* Check the parameters */
  assert_param(IS_TIMESTAMP_EDGE(TimeStampEdge));
  assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));

  /* Process Locked */
  __HAL_LOCK(hrtc);
 8005d90:	68fb      	ldr	r3, [r7, #12]
 8005d92:	7f1b      	ldrb	r3, [r3, #28]
 8005d94:	2b01      	cmp	r3, #1
 8005d96:	d101      	bne.n	8005d9c <HAL_RTCEx_SetTimeStamp+0x1c>
 8005d98:	2302      	movs	r3, #2
 8005d9a:	e03e      	b.n	8005e1a <HAL_RTCEx_SetTimeStamp+0x9a>
 8005d9c:	68fb      	ldr	r3, [r7, #12]
 8005d9e:	2201      	movs	r2, #1
 8005da0:	771a      	strb	r2, [r3, #28]

  hrtc->State = HAL_RTC_STATE_BUSY;
 8005da2:	68fb      	ldr	r3, [r7, #12]
 8005da4:	2202      	movs	r2, #2
 8005da6:	775a      	strb	r2, [r3, #29]

  /* Get the RTC_CR register and clear the bits to be configured */
  tmpreg = (uint32_t)(hrtc->Instance->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
 8005da8:	68fb      	ldr	r3, [r7, #12]
 8005daa:	681b      	ldr	r3, [r3, #0]
 8005dac:	689a      	ldr	r2, [r3, #8]
 8005dae:	4b1e      	ldr	r3, [pc, #120]	; (8005e28 <HAL_RTCEx_SetTimeStamp+0xa8>)
 8005db0:	4013      	ands	r3, r2
 8005db2:	617b      	str	r3, [r7, #20]

  tmpreg|= TimeStampEdge;
 8005db4:	697a      	ldr	r2, [r7, #20]
 8005db6:	68bb      	ldr	r3, [r7, #8]
 8005db8:	4313      	orrs	r3, r2
 8005dba:	617b      	str	r3, [r7, #20]

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8005dbc:	68fb      	ldr	r3, [r7, #12]
 8005dbe:	681b      	ldr	r3, [r3, #0]
 8005dc0:	22ca      	movs	r2, #202	; 0xca
 8005dc2:	625a      	str	r2, [r3, #36]	; 0x24
 8005dc4:	68fb      	ldr	r3, [r7, #12]
 8005dc6:	681b      	ldr	r3, [r3, #0]
 8005dc8:	2253      	movs	r2, #83	; 0x53
 8005dca:	625a      	str	r2, [r3, #36]	; 0x24

  hrtc->Instance->OR &= (uint32_t)~RTC_OR_TSINSEL;
 8005dcc:	68fb      	ldr	r3, [r7, #12]
 8005dce:	681b      	ldr	r3, [r3, #0]
 8005dd0:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8005dd2:	68fb      	ldr	r3, [r7, #12]
 8005dd4:	681b      	ldr	r3, [r3, #0]
 8005dd6:	f022 0206 	bic.w	r2, r2, #6
 8005dda:	64da      	str	r2, [r3, #76]	; 0x4c
  hrtc->Instance->OR |= (uint32_t)(RTC_TimeStampPin);
 8005ddc:	68fb      	ldr	r3, [r7, #12]
 8005dde:	681b      	ldr	r3, [r3, #0]
 8005de0:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8005de2:	68fb      	ldr	r3, [r7, #12]
 8005de4:	681b      	ldr	r3, [r3, #0]
 8005de6:	687a      	ldr	r2, [r7, #4]
 8005de8:	430a      	orrs	r2, r1
 8005dea:	64da      	str	r2, [r3, #76]	; 0x4c

  /* Configure the Time Stamp TSEDGE and Enable bits */
  hrtc->Instance->CR = (uint32_t)tmpreg;
 8005dec:	68fb      	ldr	r3, [r7, #12]
 8005dee:	681b      	ldr	r3, [r3, #0]
 8005df0:	697a      	ldr	r2, [r7, #20]
 8005df2:	609a      	str	r2, [r3, #8]

  __HAL_RTC_TIMESTAMP_ENABLE(hrtc);
 8005df4:	68fb      	ldr	r3, [r7, #12]
 8005df6:	681b      	ldr	r3, [r3, #0]
 8005df8:	689a      	ldr	r2, [r3, #8]
 8005dfa:	68fb      	ldr	r3, [r7, #12]
 8005dfc:	681b      	ldr	r3, [r3, #0]
 8005dfe:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8005e02:	609a      	str	r2, [r3, #8]

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8005e04:	68fb      	ldr	r3, [r7, #12]
 8005e06:	681b      	ldr	r3, [r3, #0]
 8005e08:	22ff      	movs	r2, #255	; 0xff
 8005e0a:	625a      	str	r2, [r3, #36]	; 0x24

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 8005e0c:	68fb      	ldr	r3, [r7, #12]
 8005e0e:	2201      	movs	r2, #1
 8005e10:	775a      	strb	r2, [r3, #29]

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8005e12:	68fb      	ldr	r3, [r7, #12]
 8005e14:	2200      	movs	r2, #0
 8005e16:	771a      	strb	r2, [r3, #28]

  return HAL_OK;
 8005e18:	2300      	movs	r3, #0
}
 8005e1a:	4618      	mov	r0, r3
 8005e1c:	371c      	adds	r7, #28
 8005e1e:	46bd      	mov	sp, r7
 8005e20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e24:	4770      	bx	lr
 8005e26:	bf00      	nop
 8005e28:	fffff7f7 	.word	0xfffff7f7

08005e2c <HAL_SAI_Init>:
  * @param  hsai pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SAI_Init(SAI_HandleTypeDef *hsai)
{
 8005e2c:	b580      	push	{r7, lr}
 8005e2e:	b088      	sub	sp, #32
 8005e30:	af00      	add	r7, sp, #0
 8005e32:	6078      	str	r0, [r7, #4]
  uint32_t tmpregisterGCR = 0;
 8005e34:	2300      	movs	r3, #0
 8005e36:	61fb      	str	r3, [r7, #28]
  uint32_t ckstr_bits = 0;
 8005e38:	2300      	movs	r3, #0
 8005e3a:	61bb      	str	r3, [r7, #24]
  uint32_t syncen_bits = 0;
 8005e3c:	2300      	movs	r3, #0
 8005e3e:	617b      	str	r3, [r7, #20]

  /* Check the SAI handle allocation */
  if(hsai == NULL)
 8005e40:	687b      	ldr	r3, [r7, #4]
 8005e42:	2b00      	cmp	r3, #0
 8005e44:	d101      	bne.n	8005e4a <HAL_SAI_Init+0x1e>
  {
    return HAL_ERROR;
 8005e46:	2301      	movs	r3, #1
 8005e48:	e149      	b.n	80060de <HAL_SAI_Init+0x2b2>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));

  if(hsai->State == HAL_SAI_STATE_RESET)
 8005e4a:	687b      	ldr	r3, [r7, #4]
 8005e4c:	f893 307d 	ldrb.w	r3, [r3, #125]	; 0x7d
 8005e50:	b2db      	uxtb	r3, r3
 8005e52:	2b00      	cmp	r3, #0
 8005e54:	d106      	bne.n	8005e64 <HAL_SAI_Init+0x38>
  {
    /* Allocate lock resource and initialize it */
    hsai->Lock = HAL_UNLOCKED;
 8005e56:	687b      	ldr	r3, [r7, #4]
 8005e58:	2200      	movs	r2, #0
 8005e5a:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
      hsai->MspInitCallback = HAL_SAI_MspInit;
    }
    hsai->MspInitCallback(hsai);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_SAI_MspInit(hsai);
 8005e5e:	6878      	ldr	r0, [r7, #4]
 8005e60:	f004 f9aa 	bl	800a1b8 <HAL_SAI_MspInit>
#endif /* USE_HAL_SAI_REGISTER_CALLBACKS */
  }

  hsai->State = HAL_SAI_STATE_BUSY;
 8005e64:	687b      	ldr	r3, [r7, #4]
 8005e66:	2202      	movs	r2, #2
 8005e68:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

  /* Disable the selected SAI peripheral */
  SAI_Disable(hsai);
 8005e6c:	6878      	ldr	r0, [r7, #4]
 8005e6e:	f000 f94f 	bl	8006110 <SAI_Disable>

  /* SAI Block Synchro Configuration -----------------------------------------*/
  /* This setting must be done with both audio block (A & B) disabled         */
  switch(hsai->Init.SynchroExt)
 8005e72:	687b      	ldr	r3, [r7, #4]
 8005e74:	68db      	ldr	r3, [r3, #12]
 8005e76:	2b01      	cmp	r3, #1
 8005e78:	d007      	beq.n	8005e8a <HAL_SAI_Init+0x5e>
 8005e7a:	2b01      	cmp	r3, #1
 8005e7c:	d302      	bcc.n	8005e84 <HAL_SAI_Init+0x58>
 8005e7e:	2b02      	cmp	r3, #2
 8005e80:	d006      	beq.n	8005e90 <HAL_SAI_Init+0x64>
      break;
    case SAI_SYNCEXT_OUTBLOCKB_ENABLE :
      tmpregisterGCR = SAI_GCR_SYNCOUT_1;
      break;
  default:
    break;
 8005e82:	e008      	b.n	8005e96 <HAL_SAI_Init+0x6a>
      tmpregisterGCR = 0;
 8005e84:	2300      	movs	r3, #0
 8005e86:	61fb      	str	r3, [r7, #28]
      break;
 8005e88:	e005      	b.n	8005e96 <HAL_SAI_Init+0x6a>
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
 8005e8a:	2310      	movs	r3, #16
 8005e8c:	61fb      	str	r3, [r7, #28]
      break;
 8005e8e:	e002      	b.n	8005e96 <HAL_SAI_Init+0x6a>
      tmpregisterGCR = SAI_GCR_SYNCOUT_1;
 8005e90:	2320      	movs	r3, #32
 8005e92:	61fb      	str	r3, [r7, #28]
      break;
 8005e94:	bf00      	nop
  }

  switch(hsai->Init.Synchro)
 8005e96:	687b      	ldr	r3, [r7, #4]
 8005e98:	689b      	ldr	r3, [r3, #8]
 8005e9a:	2b03      	cmp	r3, #3
 8005e9c:	d81d      	bhi.n	8005eda <HAL_SAI_Init+0xae>
 8005e9e:	a201      	add	r2, pc, #4	; (adr r2, 8005ea4 <HAL_SAI_Init+0x78>)
 8005ea0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8005ea4:	08005eb5 	.word	0x08005eb5
 8005ea8:	08005ebb 	.word	0x08005ebb
 8005eac:	08005ec3 	.word	0x08005ec3
 8005eb0:	08005ecb 	.word	0x08005ecb
  {
    case SAI_ASYNCHRONOUS :
      {
        syncen_bits = 0;
 8005eb4:	2300      	movs	r3, #0
 8005eb6:	617b      	str	r3, [r7, #20]
      }
      break;
 8005eb8:	e010      	b.n	8005edc <HAL_SAI_Init+0xb0>
    case SAI_SYNCHRONOUS :
      {
        syncen_bits = SAI_xCR1_SYNCEN_0;
 8005eba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005ebe:	617b      	str	r3, [r7, #20]
      }
      break;
 8005ec0:	e00c      	b.n	8005edc <HAL_SAI_Init+0xb0>
    case SAI_SYNCHRONOUS_EXT_SAI1 :
      {
        syncen_bits = SAI_xCR1_SYNCEN_1;
 8005ec2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8005ec6:	617b      	str	r3, [r7, #20]
      }
      break;
 8005ec8:	e008      	b.n	8005edc <HAL_SAI_Init+0xb0>
    case SAI_SYNCHRONOUS_EXT_SAI2 :
      {
        syncen_bits = SAI_xCR1_SYNCEN_1;
 8005eca:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8005ece:	617b      	str	r3, [r7, #20]
        tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 8005ed0:	69fb      	ldr	r3, [r7, #28]
 8005ed2:	f043 0301 	orr.w	r3, r3, #1
 8005ed6:	61fb      	str	r3, [r7, #28]
      }
      break;
 8005ed8:	e000      	b.n	8005edc <HAL_SAI_Init+0xb0>
  default:
    break;
 8005eda:	bf00      	nop
  }

  if((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 8005edc:	687b      	ldr	r3, [r7, #4]
 8005ede:	681b      	ldr	r3, [r3, #0]
 8005ee0:	4a81      	ldr	r2, [pc, #516]	; (80060e8 <HAL_SAI_Init+0x2bc>)
 8005ee2:	4293      	cmp	r3, r2
 8005ee4:	d004      	beq.n	8005ef0 <HAL_SAI_Init+0xc4>
 8005ee6:	687b      	ldr	r3, [r7, #4]
 8005ee8:	681b      	ldr	r3, [r3, #0]
 8005eea:	4a80      	ldr	r2, [pc, #512]	; (80060ec <HAL_SAI_Init+0x2c0>)
 8005eec:	4293      	cmp	r3, r2
 8005eee:	d103      	bne.n	8005ef8 <HAL_SAI_Init+0xcc>
  {
    SAI1->GCR = tmpregisterGCR;
 8005ef0:	4a7f      	ldr	r2, [pc, #508]	; (80060f0 <HAL_SAI_Init+0x2c4>)
 8005ef2:	69fb      	ldr	r3, [r7, #28]
 8005ef4:	6013      	str	r3, [r2, #0]
 8005ef6:	e002      	b.n	8005efe <HAL_SAI_Init+0xd2>
  }
  else
  {
    SAI2->GCR = tmpregisterGCR;
 8005ef8:	4a7e      	ldr	r2, [pc, #504]	; (80060f4 <HAL_SAI_Init+0x2c8>)
 8005efa:	69fb      	ldr	r3, [r7, #28]
 8005efc:	6013      	str	r3, [r2, #0]
  }

  if(hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 8005efe:	687b      	ldr	r3, [r7, #4]
 8005f00:	69db      	ldr	r3, [r3, #28]
 8005f02:	2b00      	cmp	r3, #0
 8005f04:	d043      	beq.n	8005f8e <HAL_SAI_Init+0x162>
  {
    uint32_t freq = 0;
 8005f06:	2300      	movs	r3, #0
 8005f08:	613b      	str	r3, [r7, #16]
    uint32_t tmpval;

    if((hsai->Instance == SAI1_Block_A ) || (hsai->Instance == SAI1_Block_B ))
 8005f0a:	687b      	ldr	r3, [r7, #4]
 8005f0c:	681b      	ldr	r3, [r3, #0]
 8005f0e:	4a76      	ldr	r2, [pc, #472]	; (80060e8 <HAL_SAI_Init+0x2bc>)
 8005f10:	4293      	cmp	r3, r2
 8005f12:	d004      	beq.n	8005f1e <HAL_SAI_Init+0xf2>
 8005f14:	687b      	ldr	r3, [r7, #4]
 8005f16:	681b      	ldr	r3, [r3, #0]
 8005f18:	4a74      	ldr	r2, [pc, #464]	; (80060ec <HAL_SAI_Init+0x2c0>)
 8005f1a:	4293      	cmp	r3, r2
 8005f1c:	d104      	bne.n	8005f28 <HAL_SAI_Init+0xfc>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 8005f1e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8005f22:	f7ff fa8d 	bl	8005440 <HAL_RCCEx_GetPeriphCLKFreq>
 8005f26:	6138      	str	r0, [r7, #16]
    }
    if((hsai->Instance == SAI2_Block_A ) || (hsai->Instance == SAI2_Block_B ))
 8005f28:	687b      	ldr	r3, [r7, #4]
 8005f2a:	681b      	ldr	r3, [r3, #0]
 8005f2c:	4a72      	ldr	r2, [pc, #456]	; (80060f8 <HAL_SAI_Init+0x2cc>)
 8005f2e:	4293      	cmp	r3, r2
 8005f30:	d004      	beq.n	8005f3c <HAL_SAI_Init+0x110>
 8005f32:	687b      	ldr	r3, [r7, #4]
 8005f34:	681b      	ldr	r3, [r3, #0]
 8005f36:	4a71      	ldr	r2, [pc, #452]	; (80060fc <HAL_SAI_Init+0x2d0>)
 8005f38:	4293      	cmp	r3, r2
 8005f3a:	d104      	bne.n	8005f46 <HAL_SAI_Init+0x11a>
    {
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 8005f3c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005f40:	f7ff fa7e 	bl	8005440 <HAL_RCCEx_GetPeriphCLKFreq>
 8005f44:	6138      	str	r0, [r7, #16]
    /* Configure Master Clock using the following formula :
       MCLK_x = SAI_CK_x / (MCKDIV[3:0] * 2) with MCLK_x = 256 * FS
       FS = SAI_CK_x / (MCKDIV[3:0] * 2) * 256
       MCKDIV[3:0] = SAI_CK_x / FS * 512 */
    /* (freq x 10) to keep Significant digits */
    tmpval = (freq * 10) / (hsai->Init.AudioFrequency * 2 * 256);
 8005f46:	693a      	ldr	r2, [r7, #16]
 8005f48:	4613      	mov	r3, r2
 8005f4a:	009b      	lsls	r3, r3, #2
 8005f4c:	4413      	add	r3, r2
 8005f4e:	005b      	lsls	r3, r3, #1
 8005f50:	461a      	mov	r2, r3
 8005f52:	687b      	ldr	r3, [r7, #4]
 8005f54:	69db      	ldr	r3, [r3, #28]
 8005f56:	025b      	lsls	r3, r3, #9
 8005f58:	fbb2 f3f3 	udiv	r3, r2, r3
 8005f5c:	60fb      	str	r3, [r7, #12]
    hsai->Init.Mckdiv = tmpval / 10;
 8005f5e:	68fb      	ldr	r3, [r7, #12]
 8005f60:	4a67      	ldr	r2, [pc, #412]	; (8006100 <HAL_SAI_Init+0x2d4>)
 8005f62:	fba2 2303 	umull	r2, r3, r2, r3
 8005f66:	08da      	lsrs	r2, r3, #3
 8005f68:	687b      	ldr	r3, [r7, #4]
 8005f6a:	621a      	str	r2, [r3, #32]

    /* Round result to the nearest integer */
    if((tmpval % 10) > 8)
 8005f6c:	68f9      	ldr	r1, [r7, #12]
 8005f6e:	4b64      	ldr	r3, [pc, #400]	; (8006100 <HAL_SAI_Init+0x2d4>)
 8005f70:	fba3 2301 	umull	r2, r3, r3, r1
 8005f74:	08da      	lsrs	r2, r3, #3
 8005f76:	4613      	mov	r3, r2
 8005f78:	009b      	lsls	r3, r3, #2
 8005f7a:	4413      	add	r3, r2
 8005f7c:	005b      	lsls	r3, r3, #1
 8005f7e:	1aca      	subs	r2, r1, r3
 8005f80:	2a08      	cmp	r2, #8
 8005f82:	d904      	bls.n	8005f8e <HAL_SAI_Init+0x162>
    {
      hsai->Init.Mckdiv+= 1;
 8005f84:	687b      	ldr	r3, [r7, #4]
 8005f86:	6a1b      	ldr	r3, [r3, #32]
 8005f88:	1c5a      	adds	r2, r3, #1
 8005f8a:	687b      	ldr	r3, [r7, #4]
 8005f8c:	621a      	str	r2, [r3, #32]
    }
  }

  /* Compute CKSTR bits of SAI CR1 according ClockStrobing and AudioMode */
  if((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 8005f8e:	687b      	ldr	r3, [r7, #4]
 8005f90:	685b      	ldr	r3, [r3, #4]
 8005f92:	2b00      	cmp	r3, #0
 8005f94:	d003      	beq.n	8005f9e <HAL_SAI_Init+0x172>
 8005f96:	687b      	ldr	r3, [r7, #4]
 8005f98:	685b      	ldr	r3, [r3, #4]
 8005f9a:	2b02      	cmp	r3, #2
 8005f9c:	d109      	bne.n	8005fb2 <HAL_SAI_Init+0x186>
  { /* Transmit */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0 : SAI_xCR1_CKSTR;
 8005f9e:	687b      	ldr	r3, [r7, #4]
 8005fa0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005fa2:	2b01      	cmp	r3, #1
 8005fa4:	d101      	bne.n	8005faa <HAL_SAI_Init+0x17e>
 8005fa6:	2300      	movs	r3, #0
 8005fa8:	e001      	b.n	8005fae <HAL_SAI_Init+0x182>
 8005faa:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005fae:	61bb      	str	r3, [r7, #24]
 8005fb0:	e008      	b.n	8005fc4 <HAL_SAI_Init+0x198>
  }
  else
  { /* Receive */
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? SAI_xCR1_CKSTR : 0;
 8005fb2:	687b      	ldr	r3, [r7, #4]
 8005fb4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005fb6:	2b01      	cmp	r3, #1
 8005fb8:	d102      	bne.n	8005fc0 <HAL_SAI_Init+0x194>
 8005fba:	f44f 7300 	mov.w	r3, #512	; 0x200
 8005fbe:	e000      	b.n	8005fc2 <HAL_SAI_Init+0x196>
 8005fc0:	2300      	movs	r3, #0
 8005fc2:	61bb      	str	r3, [r7, #24]
  }

  /* SAI Block Configuration -------------------------------------------------*/
  /* SAI CR1 Configuration */
  hsai->Instance->CR1&=~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 8005fc4:	687b      	ldr	r3, [r7, #4]
 8005fc6:	681b      	ldr	r3, [r3, #0]
 8005fc8:	6819      	ldr	r1, [r3, #0]
 8005fca:	687b      	ldr	r3, [r7, #4]
 8005fcc:	681a      	ldr	r2, [r3, #0]
 8005fce:	4b4d      	ldr	r3, [pc, #308]	; (8006104 <HAL_SAI_Init+0x2d8>)
 8005fd0:	400b      	ands	r3, r1
 8005fd2:	6013      	str	r3, [r2, #0]
                         SAI_xCR1_LSBFIRST | SAI_xCR1_CKSTR | SAI_xCR1_SYNCEN |\
                         SAI_xCR1_MONO | SAI_xCR1_OUTDRIV  | SAI_xCR1_DMAEN |  \
                         SAI_xCR1_NODIV | SAI_xCR1_MCKDIV);

  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8005fd4:	687b      	ldr	r3, [r7, #4]
 8005fd6:	681b      	ldr	r3, [r3, #0]
 8005fd8:	6819      	ldr	r1, [r3, #0]
 8005fda:	687b      	ldr	r3, [r7, #4]
 8005fdc:	685a      	ldr	r2, [r3, #4]
 8005fde:	687b      	ldr	r3, [r7, #4]
 8005fe0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005fe2:	431a      	orrs	r2, r3
                        hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 8005fe4:	687b      	ldr	r3, [r7, #4]
 8005fe6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8005fe8:	431a      	orrs	r2, r3
                        hsai->Init.DataSize | hsai->Init.FirstBit  |           \
 8005fea:	687b      	ldr	r3, [r7, #4]
 8005fec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8005fee:	431a      	orrs	r2, r3
 8005ff0:	69bb      	ldr	r3, [r7, #24]
 8005ff2:	431a      	orrs	r2, r3
                        ckstr_bits | syncen_bits |                               \
 8005ff4:	697b      	ldr	r3, [r7, #20]
 8005ff6:	431a      	orrs	r2, r3
                        hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 8005ff8:	687b      	ldr	r3, [r7, #4]
 8005ffa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        ckstr_bits | syncen_bits |                               \
 8005ffc:	431a      	orrs	r2, r3
                        hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 8005ffe:	687b      	ldr	r3, [r7, #4]
 8006000:	691b      	ldr	r3, [r3, #16]
 8006002:	431a      	orrs	r2, r3
                        hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
 8006004:	687b      	ldr	r3, [r7, #4]
 8006006:	695b      	ldr	r3, [r3, #20]
                        hsai->Init.MonoStereoMode | hsai->Init.OutputDrive |   \
 8006008:	431a      	orrs	r2, r3
                        hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20));
 800600a:	687b      	ldr	r3, [r7, #4]
 800600c:	6a1b      	ldr	r3, [r3, #32]
 800600e:	051b      	lsls	r3, r3, #20
 8006010:	431a      	orrs	r2, r3
  hsai->Instance->CR1|=(hsai->Init.AudioMode | hsai->Init.Protocol |           \
 8006012:	687b      	ldr	r3, [r7, #4]
 8006014:	681b      	ldr	r3, [r3, #0]
 8006016:	430a      	orrs	r2, r1
 8006018:	601a      	str	r2, [r3, #0]

  /* SAI CR2 Configuration */
  hsai->Instance->CR2&= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800601a:	687b      	ldr	r3, [r7, #4]
 800601c:	681b      	ldr	r3, [r3, #0]
 800601e:	6859      	ldr	r1, [r3, #4]
 8006020:	687b      	ldr	r3, [r7, #4]
 8006022:	681a      	ldr	r2, [r3, #0]
 8006024:	4b38      	ldr	r3, [pc, #224]	; (8006108 <HAL_SAI_Init+0x2dc>)
 8006026:	400b      	ands	r3, r1
 8006028:	6053      	str	r3, [r2, #4]
  hsai->Instance->CR2|=  (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 800602a:	687b      	ldr	r3, [r7, #4]
 800602c:	681b      	ldr	r3, [r3, #0]
 800602e:	6859      	ldr	r1, [r3, #4]
 8006030:	687b      	ldr	r3, [r7, #4]
 8006032:	699a      	ldr	r2, [r3, #24]
 8006034:	687b      	ldr	r3, [r7, #4]
 8006036:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006038:	431a      	orrs	r2, r3
 800603a:	687b      	ldr	r3, [r7, #4]
 800603c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800603e:	431a      	orrs	r2, r3
 8006040:	687b      	ldr	r3, [r7, #4]
 8006042:	681b      	ldr	r3, [r3, #0]
 8006044:	430a      	orrs	r2, r1
 8006046:	605a      	str	r2, [r3, #4]

  /* SAI Frame Configuration -----------------------------------------*/
  hsai->Instance->FRCR&=(~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 8006048:	687b      	ldr	r3, [r7, #4]
 800604a:	681b      	ldr	r3, [r3, #0]
 800604c:	6899      	ldr	r1, [r3, #8]
 800604e:	687b      	ldr	r3, [r7, #4]
 8006050:	681a      	ldr	r2, [r3, #0]
 8006052:	4b2e      	ldr	r3, [pc, #184]	; (800610c <HAL_SAI_Init+0x2e0>)
 8006054:	400b      	ands	r3, r1
 8006056:	6093      	str	r3, [r2, #8]
                           SAI_xFRCR_FSPOL | SAI_xFRCR_FSOFF));
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8006058:	687b      	ldr	r3, [r7, #4]
 800605a:	681b      	ldr	r3, [r3, #0]
 800605c:	6899      	ldr	r1, [r3, #8]
 800605e:	687b      	ldr	r3, [r7, #4]
 8006060:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8006062:	1e5a      	subs	r2, r3, #1
                          hsai->FrameInit.FSOffset |
 8006064:	687b      	ldr	r3, [r7, #4]
 8006066:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8006068:	431a      	orrs	r2, r3
                          hsai->FrameInit.FSDefinition |
 800606a:	687b      	ldr	r3, [r7, #4]
 800606c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
                          hsai->FrameInit.FSOffset |
 800606e:	431a      	orrs	r2, r3
                          hsai->FrameInit.FSPolarity   |
 8006070:	687b      	ldr	r3, [r7, #4]
 8006072:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
                          hsai->FrameInit.FSDefinition |
 8006074:	431a      	orrs	r2, r3
                          ((hsai->FrameInit.ActiveFrameLength - 1) << 8));
 8006076:	687b      	ldr	r3, [r7, #4]
 8006078:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800607a:	3b01      	subs	r3, #1
 800607c:	021b      	lsls	r3, r3, #8
                          hsai->FrameInit.FSPolarity   |
 800607e:	431a      	orrs	r2, r3
  hsai->Instance->FRCR|=((hsai->FrameInit.FrameLength - 1) |
 8006080:	687b      	ldr	r3, [r7, #4]
 8006082:	681b      	ldr	r3, [r3, #0]
 8006084:	430a      	orrs	r2, r1
 8006086:	609a      	str	r2, [r3, #8]

  /* SAI Block_x SLOT Configuration ------------------------------------------*/
  /* This register has no meaning in AC 97 and SPDIF audio protocol */
  hsai->Instance->SLOTR&= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |            \
 8006088:	687b      	ldr	r3, [r7, #4]
 800608a:	681b      	ldr	r3, [r3, #0]
 800608c:	68d9      	ldr	r1, [r3, #12]
 800608e:	687b      	ldr	r3, [r7, #4]
 8006090:	681a      	ldr	r2, [r3, #0]
 8006092:	f24f 0320 	movw	r3, #61472	; 0xf020
 8006096:	400b      	ands	r3, r1
 8006098:	60d3      	str	r3, [r2, #12]
                             SAI_xSLOTR_NBSLOT | SAI_xSLOTR_SLOTEN ));

  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 800609a:	687b      	ldr	r3, [r7, #4]
 800609c:	681b      	ldr	r3, [r3, #0]
 800609e:	68d9      	ldr	r1, [r3, #12]
 80060a0:	687b      	ldr	r3, [r7, #4]
 80060a2:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80060a4:	687b      	ldr	r3, [r7, #4]
 80060a6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80060a8:	431a      	orrs	r2, r3
                          | (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1) <<  8);
 80060aa:	687b      	ldr	r3, [r7, #4]
 80060ac:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80060ae:	041b      	lsls	r3, r3, #16
 80060b0:	431a      	orrs	r2, r3
 80060b2:	687b      	ldr	r3, [r7, #4]
 80060b4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80060b6:	3b01      	subs	r3, #1
 80060b8:	021b      	lsls	r3, r3, #8
 80060ba:	431a      	orrs	r2, r3
  hsai->Instance->SLOTR|=  hsai->SlotInit.FirstBitOffset |  hsai->SlotInit.SlotSize
 80060bc:	687b      	ldr	r3, [r7, #4]
 80060be:	681b      	ldr	r3, [r3, #0]
 80060c0:	430a      	orrs	r2, r1
 80060c2:	60da      	str	r2, [r3, #12]

  /* Initialize the error code */
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 80060c4:	687b      	ldr	r3, [r7, #4]
 80060c6:	2200      	movs	r2, #0
 80060c8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

  /* Initialize the SAI state */
  hsai->State= HAL_SAI_STATE_READY;
 80060cc:	687b      	ldr	r3, [r7, #4]
 80060ce:	2201      	movs	r2, #1
 80060d0:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d

  /* Release Lock */
  __HAL_UNLOCK(hsai);
 80060d4:	687b      	ldr	r3, [r7, #4]
 80060d6:	2200      	movs	r2, #0
 80060d8:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c

  return HAL_OK;
 80060dc:	2300      	movs	r3, #0
}
 80060de:	4618      	mov	r0, r3
 80060e0:	3720      	adds	r7, #32
 80060e2:	46bd      	mov	sp, r7
 80060e4:	bd80      	pop	{r7, pc}
 80060e6:	bf00      	nop
 80060e8:	40015804 	.word	0x40015804
 80060ec:	40015824 	.word	0x40015824
 80060f0:	40015800 	.word	0x40015800
 80060f4:	40015c00 	.word	0x40015c00
 80060f8:	40015c04 	.word	0x40015c04
 80060fc:	40015c24 	.word	0x40015c24
 8006100:	cccccccd 	.word	0xcccccccd
 8006104:	ff05c010 	.word	0xff05c010
 8006108:	ffff1ff0 	.word	0xffff1ff0
 800610c:	fff88000 	.word	0xfff88000

08006110 <SAI_Disable>:
  * @param  hsai  pointer to a SAI_HandleTypeDef structure that contains
  *                the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
 8006110:	b490      	push	{r4, r7}
 8006112:	b084      	sub	sp, #16
 8006114:	af00      	add	r7, sp, #0
 8006116:	6078      	str	r0, [r7, #4]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock /7/1000);
 8006118:	4b16      	ldr	r3, [pc, #88]	; (8006174 <SAI_Disable+0x64>)
 800611a:	681b      	ldr	r3, [r3, #0]
 800611c:	4a16      	ldr	r2, [pc, #88]	; (8006178 <SAI_Disable+0x68>)
 800611e:	fba2 2303 	umull	r2, r3, r2, r3
 8006122:	0b1b      	lsrs	r3, r3, #12
 8006124:	009c      	lsls	r4, r3, #2
  HAL_StatusTypeDef status = HAL_OK;
 8006126:	2300      	movs	r3, #0
 8006128:	73fb      	strb	r3, [r7, #15]

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 800612a:	687b      	ldr	r3, [r7, #4]
 800612c:	681b      	ldr	r3, [r3, #0]
 800612e:	681a      	ldr	r2, [r3, #0]
 8006130:	687b      	ldr	r3, [r7, #4]
 8006132:	681b      	ldr	r3, [r3, #0]
 8006134:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8006138:	601a      	str	r2, [r3, #0]

  do
  {
    /* Check for the Timeout */
    if (count-- == 0)
 800613a:	4623      	mov	r3, r4
 800613c:	1e5c      	subs	r4, r3, #1
 800613e:	2b00      	cmp	r3, #0
 8006140:	d10a      	bne.n	8006158 <SAI_Disable+0x48>
    {
      /* Update error code */
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 8006142:	687b      	ldr	r3, [r7, #4]
 8006144:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8006148:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800614c:	687b      	ldr	r3, [r7, #4]
 800614e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
      status = HAL_TIMEOUT;
 8006152:	2303      	movs	r3, #3
 8006154:	73fb      	strb	r3, [r7, #15]
      break;
 8006156:	e006      	b.n	8006166 <SAI_Disable+0x56>
    }
  } while((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != RESET);
 8006158:	687b      	ldr	r3, [r7, #4]
 800615a:	681b      	ldr	r3, [r3, #0]
 800615c:	681b      	ldr	r3, [r3, #0]
 800615e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8006162:	2b00      	cmp	r3, #0
 8006164:	d1e9      	bne.n	800613a <SAI_Disable+0x2a>

  return status;
 8006166:	7bfb      	ldrb	r3, [r7, #15]
}
 8006168:	4618      	mov	r0, r3
 800616a:	3710      	adds	r7, #16
 800616c:	46bd      	mov	sp, r7
 800616e:	bc90      	pop	{r4, r7}
 8006170:	4770      	bx	lr
 8006172:	bf00      	nop
 8006174:	20000004 	.word	0x20000004
 8006178:	95cbec1b 	.word	0x95cbec1b

0800617c <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 800617c:	b580      	push	{r7, lr}
 800617e:	b082      	sub	sp, #8
 8006180:	af00      	add	r7, sp, #0
 8006182:	6078      	str	r0, [r7, #4]
 8006184:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 8006186:	687b      	ldr	r3, [r7, #4]
 8006188:	2b00      	cmp	r3, #0
 800618a:	d101      	bne.n	8006190 <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 800618c:	2301      	movs	r3, #1
 800618e:	e025      	b.n	80061dc <HAL_SDRAM_Init+0x60>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 8006190:	687b      	ldr	r3, [r7, #4]
 8006192:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8006196:	b2db      	uxtb	r3, r3
 8006198:	2b00      	cmp	r3, #0
 800619a:	d106      	bne.n	80061aa <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 800619c:	687b      	ldr	r3, [r7, #4]
 800619e:	2200      	movs	r2, #0
 80061a0:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d

    /* Init the low level hardware */
    hsdram->MspInitCallback(hsdram);
#else
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 80061a4:	6878      	ldr	r0, [r7, #4]
 80061a6:	f003 fffd 	bl	800a1a4 <HAL_SDRAM_MspInit>
#endif
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80061aa:	687b      	ldr	r3, [r7, #4]
 80061ac:	2202      	movs	r2, #2
 80061ae:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 80061b2:	687b      	ldr	r3, [r7, #4]
 80061b4:	681a      	ldr	r2, [r3, #0]
 80061b6:	687b      	ldr	r3, [r7, #4]
 80061b8:	3304      	adds	r3, #4
 80061ba:	4619      	mov	r1, r3
 80061bc:	4610      	mov	r0, r2
 80061be:	f001 fc91 	bl	8007ae4 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 80061c2:	687b      	ldr	r3, [r7, #4]
 80061c4:	6818      	ldr	r0, [r3, #0]
 80061c6:	687b      	ldr	r3, [r7, #4]
 80061c8:	685b      	ldr	r3, [r3, #4]
 80061ca:	461a      	mov	r2, r3
 80061cc:	6839      	ldr	r1, [r7, #0]
 80061ce:	f001 fcfb 	bl	8007bc8 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 80061d2:	687b      	ldr	r3, [r7, #4]
 80061d4:	2201      	movs	r2, #1
 80061d6:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
 80061da:	2300      	movs	r3, #0
}
 80061dc:	4618      	mov	r0, r3
 80061de:	3708      	adds	r7, #8
 80061e0:	46bd      	mov	sp, r7
 80061e2:	bd80      	pop	{r7, pc}

080061e4 <HAL_SDRAM_SendCommand>:
  * @param  Command SDRAM command structure
  * @param  Timeout Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 80061e4:	b580      	push	{r7, lr}
 80061e6:	b084      	sub	sp, #16
 80061e8:	af00      	add	r7, sp, #0
 80061ea:	60f8      	str	r0, [r7, #12]
 80061ec:	60b9      	str	r1, [r7, #8]
 80061ee:	607a      	str	r2, [r7, #4]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80061f0:	68fb      	ldr	r3, [r7, #12]
 80061f2:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80061f6:	b2db      	uxtb	r3, r3
 80061f8:	2b02      	cmp	r3, #2
 80061fa:	d101      	bne.n	8006200 <HAL_SDRAM_SendCommand+0x1c>
  {
    return HAL_BUSY;
 80061fc:	2302      	movs	r3, #2
 80061fe:	e018      	b.n	8006232 <HAL_SDRAM_SendCommand+0x4e>
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8006200:	68fb      	ldr	r3, [r7, #12]
 8006202:	2202      	movs	r2, #2
 8006204:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 8006208:	68fb      	ldr	r3, [r7, #12]
 800620a:	681b      	ldr	r3, [r3, #0]
 800620c:	687a      	ldr	r2, [r7, #4]
 800620e:	68b9      	ldr	r1, [r7, #8]
 8006210:	4618      	mov	r0, r3
 8006212:	f001 fd59 	bl	8007cc8 <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8006216:	68bb      	ldr	r3, [r7, #8]
 8006218:	681b      	ldr	r3, [r3, #0]
 800621a:	2b02      	cmp	r3, #2
 800621c:	d104      	bne.n	8006228 <HAL_SDRAM_SendCommand+0x44>
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800621e:	68fb      	ldr	r3, [r7, #12]
 8006220:	2205      	movs	r2, #5
 8006222:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8006226:	e003      	b.n	8006230 <HAL_SDRAM_SendCommand+0x4c>
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 8006228:	68fb      	ldr	r3, [r7, #12]
 800622a:	2201      	movs	r2, #1
 800622c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  }
  
  return HAL_OK;  
 8006230:	2300      	movs	r3, #0
}
 8006232:	4618      	mov	r0, r3
 8006234:	3710      	adds	r7, #16
 8006236:	46bd      	mov	sp, r7
 8006238:	bd80      	pop	{r7, pc}

0800623a <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800623a:	b580      	push	{r7, lr}
 800623c:	b082      	sub	sp, #8
 800623e:	af00      	add	r7, sp, #0
 8006240:	6078      	str	r0, [r7, #4]
 8006242:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8006244:	687b      	ldr	r3, [r7, #4]
 8006246:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 800624a:	b2db      	uxtb	r3, r3
 800624c:	2b02      	cmp	r3, #2
 800624e:	d101      	bne.n	8006254 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
 8006250:	2302      	movs	r3, #2
 8006252:	e00e      	b.n	8006272 <HAL_SDRAM_ProgramRefreshRate+0x38>
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8006254:	687b      	ldr	r3, [r7, #4]
 8006256:	2202      	movs	r2, #2
 8006258:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 800625c:	687b      	ldr	r3, [r7, #4]
 800625e:	681b      	ldr	r3, [r3, #0]
 8006260:	6839      	ldr	r1, [r7, #0]
 8006262:	4618      	mov	r0, r3
 8006264:	f001 fd51 	bl	8007d0a <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8006268:	687b      	ldr	r3, [r7, #4]
 800626a:	2201      	movs	r2, #1
 800626c:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;   
 8006270:	2300      	movs	r3, #0
}
 8006272:	4618      	mov	r0, r3
 8006274:	3708      	adds	r7, #8
 8006276:	46bd      	mov	sp, r7
 8006278:	bd80      	pop	{r7, pc}

0800627a <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 800627a:	b580      	push	{r7, lr}
 800627c:	b082      	sub	sp, #8
 800627e:	af00      	add	r7, sp, #0
 8006280:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8006282:	687b      	ldr	r3, [r7, #4]
 8006284:	2b00      	cmp	r3, #0
 8006286:	d101      	bne.n	800628c <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8006288:	2301      	movs	r3, #1
 800628a:	e01d      	b.n	80062c8 <HAL_TIM_Base_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 800628c:	687b      	ldr	r3, [r7, #4]
 800628e:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 8006292:	b2db      	uxtb	r3, r3
 8006294:	2b00      	cmp	r3, #0
 8006296:	d106      	bne.n	80062a6 <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8006298:	687b      	ldr	r3, [r7, #4]
 800629a:	2200      	movs	r2, #0
 800629c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80062a0:	6878      	ldr	r0, [r7, #4]
 80062a2:	f003 fcdd 	bl	8009c60 <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 80062a6:	687b      	ldr	r3, [r7, #4]
 80062a8:	2202      	movs	r2, #2
 80062aa:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 80062ae:	687b      	ldr	r3, [r7, #4]
 80062b0:	681a      	ldr	r2, [r3, #0]
 80062b2:	687b      	ldr	r3, [r7, #4]
 80062b4:	3304      	adds	r3, #4
 80062b6:	4619      	mov	r1, r3
 80062b8:	4610      	mov	r0, r2
 80062ba:	f000 fb77 	bl	80069ac <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 80062be:	687b      	ldr	r3, [r7, #4]
 80062c0:	2201      	movs	r2, #1
 80062c2:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 80062c6:	2300      	movs	r3, #0
}
 80062c8:	4618      	mov	r0, r3
 80062ca:	3708      	adds	r7, #8
 80062cc:	46bd      	mov	sp, r7
 80062ce:	bd80      	pop	{r7, pc}

080062d0 <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 80062d0:	b480      	push	{r7}
 80062d2:	b085      	sub	sp, #20
 80062d4:	af00      	add	r7, sp, #0
 80062d6:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80062d8:	687b      	ldr	r3, [r7, #4]
 80062da:	681b      	ldr	r3, [r3, #0]
 80062dc:	68da      	ldr	r2, [r3, #12]
 80062de:	687b      	ldr	r3, [r7, #4]
 80062e0:	681b      	ldr	r3, [r3, #0]
 80062e2:	f042 0201 	orr.w	r2, r2, #1
 80062e6:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 80062e8:	687b      	ldr	r3, [r7, #4]
 80062ea:	681b      	ldr	r3, [r3, #0]
 80062ec:	689a      	ldr	r2, [r3, #8]
 80062ee:	4b0c      	ldr	r3, [pc, #48]	; (8006320 <HAL_TIM_Base_Start_IT+0x50>)
 80062f0:	4013      	ands	r3, r2
 80062f2:	60fb      	str	r3, [r7, #12]
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 80062f4:	68fb      	ldr	r3, [r7, #12]
 80062f6:	2b06      	cmp	r3, #6
 80062f8:	d00b      	beq.n	8006312 <HAL_TIM_Base_Start_IT+0x42>
 80062fa:	68fb      	ldr	r3, [r7, #12]
 80062fc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8006300:	d007      	beq.n	8006312 <HAL_TIM_Base_Start_IT+0x42>
  {
    __HAL_TIM_ENABLE(htim);
 8006302:	687b      	ldr	r3, [r7, #4]
 8006304:	681b      	ldr	r3, [r3, #0]
 8006306:	681a      	ldr	r2, [r3, #0]
 8006308:	687b      	ldr	r3, [r7, #4]
 800630a:	681b      	ldr	r3, [r3, #0]
 800630c:	f042 0201 	orr.w	r2, r2, #1
 8006310:	601a      	str	r2, [r3, #0]
  }

  /* Return function status */
  return HAL_OK;
 8006312:	2300      	movs	r3, #0
}
 8006314:	4618      	mov	r0, r3
 8006316:	3714      	adds	r7, #20
 8006318:	46bd      	mov	sp, r7
 800631a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800631e:	4770      	bx	lr
 8006320:	00010007 	.word	0x00010007

08006324 <HAL_TIM_PWM_Init>:
  *         Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
  * @param  htim TIM PWM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
{
 8006324:	b580      	push	{r7, lr}
 8006326:	b082      	sub	sp, #8
 8006328:	af00      	add	r7, sp, #0
 800632a:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 800632c:	687b      	ldr	r3, [r7, #4]
 800632e:	2b00      	cmp	r3, #0
 8006330:	d101      	bne.n	8006336 <HAL_TIM_PWM_Init+0x12>
  {
    return HAL_ERROR;
 8006332:	2301      	movs	r3, #1
 8006334:	e01d      	b.n	8006372 <HAL_TIM_PWM_Init+0x4e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8006336:	687b      	ldr	r3, [r7, #4]
 8006338:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
 800633c:	b2db      	uxtb	r3, r3
 800633e:	2b00      	cmp	r3, #0
 8006340:	d106      	bne.n	8006350 <HAL_TIM_PWM_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 8006342:	687b      	ldr	r3, [r7, #4]
 8006344:	2200      	movs	r2, #0
 8006346:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->PWM_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    HAL_TIM_PWM_MspInit(htim);
 800634a:	6878      	ldr	r0, [r7, #4]
 800634c:	f003 fc54 	bl	8009bf8 <HAL_TIM_PWM_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 8006350:	687b      	ldr	r3, [r7, #4]
 8006352:	2202      	movs	r2, #2
 8006354:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Init the base time for the PWM */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8006358:	687b      	ldr	r3, [r7, #4]
 800635a:	681a      	ldr	r2, [r3, #0]
 800635c:	687b      	ldr	r3, [r7, #4]
 800635e:	3304      	adds	r3, #4
 8006360:	4619      	mov	r1, r3
 8006362:	4610      	mov	r0, r2
 8006364:	f000 fb22 	bl	80069ac <TIM_Base_SetConfig>

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 8006368:	687b      	ldr	r3, [r7, #4]
 800636a:	2201      	movs	r2, #1
 800636c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  return HAL_OK;
 8006370:	2300      	movs	r3, #0
}
 8006372:	4618      	mov	r0, r3
 8006374:	3708      	adds	r7, #8
 8006376:	46bd      	mov	sp, r7
 8006378:	bd80      	pop	{r7, pc}

0800637a <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 800637a:	b580      	push	{r7, lr}
 800637c:	b082      	sub	sp, #8
 800637e:	af00      	add	r7, sp, #0
 8006380:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8006382:	687b      	ldr	r3, [r7, #4]
 8006384:	681b      	ldr	r3, [r3, #0]
 8006386:	691b      	ldr	r3, [r3, #16]
 8006388:	f003 0302 	and.w	r3, r3, #2
 800638c:	2b02      	cmp	r3, #2
 800638e:	d122      	bne.n	80063d6 <HAL_TIM_IRQHandler+0x5c>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET)
 8006390:	687b      	ldr	r3, [r7, #4]
 8006392:	681b      	ldr	r3, [r3, #0]
 8006394:	68db      	ldr	r3, [r3, #12]
 8006396:	f003 0302 	and.w	r3, r3, #2
 800639a:	2b02      	cmp	r3, #2
 800639c:	d11b      	bne.n	80063d6 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 800639e:	687b      	ldr	r3, [r7, #4]
 80063a0:	681b      	ldr	r3, [r3, #0]
 80063a2:	f06f 0202 	mvn.w	r2, #2
 80063a6:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 80063a8:	687b      	ldr	r3, [r7, #4]
 80063aa:	2201      	movs	r2, #1
 80063ac:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 80063ae:	687b      	ldr	r3, [r7, #4]
 80063b0:	681b      	ldr	r3, [r3, #0]
 80063b2:	699b      	ldr	r3, [r3, #24]
 80063b4:	f003 0303 	and.w	r3, r3, #3
 80063b8:	2b00      	cmp	r3, #0
 80063ba:	d003      	beq.n	80063c4 <HAL_TIM_IRQHandler+0x4a>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 80063bc:	6878      	ldr	r0, [r7, #4]
 80063be:	f000 fad7 	bl	8006970 <HAL_TIM_IC_CaptureCallback>
 80063c2:	e005      	b.n	80063d0 <HAL_TIM_IRQHandler+0x56>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 80063c4:	6878      	ldr	r0, [r7, #4]
 80063c6:	f000 fac9 	bl	800695c <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 80063ca:	6878      	ldr	r0, [r7, #4]
 80063cc:	f000 fada 	bl	8006984 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80063d0:	687b      	ldr	r3, [r7, #4]
 80063d2:	2200      	movs	r2, #0
 80063d4:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 80063d6:	687b      	ldr	r3, [r7, #4]
 80063d8:	681b      	ldr	r3, [r3, #0]
 80063da:	691b      	ldr	r3, [r3, #16]
 80063dc:	f003 0304 	and.w	r3, r3, #4
 80063e0:	2b04      	cmp	r3, #4
 80063e2:	d122      	bne.n	800642a <HAL_TIM_IRQHandler+0xb0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET)
 80063e4:	687b      	ldr	r3, [r7, #4]
 80063e6:	681b      	ldr	r3, [r3, #0]
 80063e8:	68db      	ldr	r3, [r3, #12]
 80063ea:	f003 0304 	and.w	r3, r3, #4
 80063ee:	2b04      	cmp	r3, #4
 80063f0:	d11b      	bne.n	800642a <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 80063f2:	687b      	ldr	r3, [r7, #4]
 80063f4:	681b      	ldr	r3, [r3, #0]
 80063f6:	f06f 0204 	mvn.w	r2, #4
 80063fa:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80063fc:	687b      	ldr	r3, [r7, #4]
 80063fe:	2202      	movs	r2, #2
 8006400:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8006402:	687b      	ldr	r3, [r7, #4]
 8006404:	681b      	ldr	r3, [r3, #0]
 8006406:	699b      	ldr	r3, [r3, #24]
 8006408:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800640c:	2b00      	cmp	r3, #0
 800640e:	d003      	beq.n	8006418 <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8006410:	6878      	ldr	r0, [r7, #4]
 8006412:	f000 faad 	bl	8006970 <HAL_TIM_IC_CaptureCallback>
 8006416:	e005      	b.n	8006424 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8006418:	6878      	ldr	r0, [r7, #4]
 800641a:	f000 fa9f 	bl	800695c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 800641e:	6878      	ldr	r0, [r7, #4]
 8006420:	f000 fab0 	bl	8006984 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006424:	687b      	ldr	r3, [r7, #4]
 8006426:	2200      	movs	r2, #0
 8006428:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 800642a:	687b      	ldr	r3, [r7, #4]
 800642c:	681b      	ldr	r3, [r3, #0]
 800642e:	691b      	ldr	r3, [r3, #16]
 8006430:	f003 0308 	and.w	r3, r3, #8
 8006434:	2b08      	cmp	r3, #8
 8006436:	d122      	bne.n	800647e <HAL_TIM_IRQHandler+0x104>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) != RESET)
 8006438:	687b      	ldr	r3, [r7, #4]
 800643a:	681b      	ldr	r3, [r3, #0]
 800643c:	68db      	ldr	r3, [r3, #12]
 800643e:	f003 0308 	and.w	r3, r3, #8
 8006442:	2b08      	cmp	r3, #8
 8006444:	d11b      	bne.n	800647e <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 8006446:	687b      	ldr	r3, [r7, #4]
 8006448:	681b      	ldr	r3, [r3, #0]
 800644a:	f06f 0208 	mvn.w	r2, #8
 800644e:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8006450:	687b      	ldr	r3, [r7, #4]
 8006452:	2204      	movs	r2, #4
 8006454:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8006456:	687b      	ldr	r3, [r7, #4]
 8006458:	681b      	ldr	r3, [r3, #0]
 800645a:	69db      	ldr	r3, [r3, #28]
 800645c:	f003 0303 	and.w	r3, r3, #3
 8006460:	2b00      	cmp	r3, #0
 8006462:	d003      	beq.n	800646c <HAL_TIM_IRQHandler+0xf2>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8006464:	6878      	ldr	r0, [r7, #4]
 8006466:	f000 fa83 	bl	8006970 <HAL_TIM_IC_CaptureCallback>
 800646a:	e005      	b.n	8006478 <HAL_TIM_IRQHandler+0xfe>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800646c:	6878      	ldr	r0, [r7, #4]
 800646e:	f000 fa75 	bl	800695c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8006472:	6878      	ldr	r0, [r7, #4]
 8006474:	f000 fa86 	bl	8006984 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8006478:	687b      	ldr	r3, [r7, #4]
 800647a:	2200      	movs	r2, #0
 800647c:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 800647e:	687b      	ldr	r3, [r7, #4]
 8006480:	681b      	ldr	r3, [r3, #0]
 8006482:	691b      	ldr	r3, [r3, #16]
 8006484:	f003 0310 	and.w	r3, r3, #16
 8006488:	2b10      	cmp	r3, #16
 800648a:	d122      	bne.n	80064d2 <HAL_TIM_IRQHandler+0x158>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) != RESET)
 800648c:	687b      	ldr	r3, [r7, #4]
 800648e:	681b      	ldr	r3, [r3, #0]
 8006490:	68db      	ldr	r3, [r3, #12]
 8006492:	f003 0310 	and.w	r3, r3, #16
 8006496:	2b10      	cmp	r3, #16
 8006498:	d11b      	bne.n	80064d2 <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 800649a:	687b      	ldr	r3, [r7, #4]
 800649c:	681b      	ldr	r3, [r3, #0]
 800649e:	f06f 0210 	mvn.w	r2, #16
 80064a2:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 80064a4:	687b      	ldr	r3, [r7, #4]
 80064a6:	2208      	movs	r2, #8
 80064a8:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 80064aa:	687b      	ldr	r3, [r7, #4]
 80064ac:	681b      	ldr	r3, [r3, #0]
 80064ae:	69db      	ldr	r3, [r3, #28]
 80064b0:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80064b4:	2b00      	cmp	r3, #0
 80064b6:	d003      	beq.n	80064c0 <HAL_TIM_IRQHandler+0x146>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 80064b8:	6878      	ldr	r0, [r7, #4]
 80064ba:	f000 fa59 	bl	8006970 <HAL_TIM_IC_CaptureCallback>
 80064be:	e005      	b.n	80064cc <HAL_TIM_IRQHandler+0x152>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80064c0:	6878      	ldr	r0, [r7, #4]
 80064c2:	f000 fa4b 	bl	800695c <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80064c6:	6878      	ldr	r0, [r7, #4]
 80064c8:	f000 fa5c 	bl	8006984 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80064cc:	687b      	ldr	r3, [r7, #4]
 80064ce:	2200      	movs	r2, #0
 80064d0:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 80064d2:	687b      	ldr	r3, [r7, #4]
 80064d4:	681b      	ldr	r3, [r3, #0]
 80064d6:	691b      	ldr	r3, [r3, #16]
 80064d8:	f003 0301 	and.w	r3, r3, #1
 80064dc:	2b01      	cmp	r3, #1
 80064de:	d10e      	bne.n	80064fe <HAL_TIM_IRQHandler+0x184>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET)
 80064e0:	687b      	ldr	r3, [r7, #4]
 80064e2:	681b      	ldr	r3, [r3, #0]
 80064e4:	68db      	ldr	r3, [r3, #12]
 80064e6:	f003 0301 	and.w	r3, r3, #1
 80064ea:	2b01      	cmp	r3, #1
 80064ec:	d107      	bne.n	80064fe <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 80064ee:	687b      	ldr	r3, [r7, #4]
 80064f0:	681b      	ldr	r3, [r3, #0]
 80064f2:	f06f 0201 	mvn.w	r2, #1
 80064f6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 80064f8:	6878      	ldr	r0, [r7, #4]
 80064fa:	f003 f92d 	bl	8009758 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80064fe:	687b      	ldr	r3, [r7, #4]
 8006500:	681b      	ldr	r3, [r3, #0]
 8006502:	691b      	ldr	r3, [r3, #16]
 8006504:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006508:	2b80      	cmp	r3, #128	; 0x80
 800650a:	d10e      	bne.n	800652a <HAL_TIM_IRQHandler+0x1b0>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800650c:	687b      	ldr	r3, [r7, #4]
 800650e:	681b      	ldr	r3, [r3, #0]
 8006510:	68db      	ldr	r3, [r3, #12]
 8006512:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006516:	2b80      	cmp	r3, #128	; 0x80
 8006518:	d107      	bne.n	800652a <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 800651a:	687b      	ldr	r3, [r7, #4]
 800651c:	681b      	ldr	r3, [r3, #0]
 800651e:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8006522:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8006524:	6878      	ldr	r0, [r7, #4]
 8006526:	f000 febd 	bl	80072a4 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 800652a:	687b      	ldr	r3, [r7, #4]
 800652c:	681b      	ldr	r3, [r3, #0]
 800652e:	691b      	ldr	r3, [r3, #16]
 8006530:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8006534:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006538:	d10e      	bne.n	8006558 <HAL_TIM_IRQHandler+0x1de>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) != RESET)
 800653a:	687b      	ldr	r3, [r7, #4]
 800653c:	681b      	ldr	r3, [r3, #0]
 800653e:	68db      	ldr	r3, [r3, #12]
 8006540:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006544:	2b80      	cmp	r3, #128	; 0x80
 8006546:	d107      	bne.n	8006558 <HAL_TIM_IRQHandler+0x1de>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8006548:	687b      	ldr	r3, [r7, #4]
 800654a:	681b      	ldr	r3, [r3, #0]
 800654c:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8006550:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8006552:	6878      	ldr	r0, [r7, #4]
 8006554:	f000 feb0 	bl	80072b8 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8006558:	687b      	ldr	r3, [r7, #4]
 800655a:	681b      	ldr	r3, [r3, #0]
 800655c:	691b      	ldr	r3, [r3, #16]
 800655e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006562:	2b40      	cmp	r3, #64	; 0x40
 8006564:	d10e      	bne.n	8006584 <HAL_TIM_IRQHandler+0x20a>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) != RESET)
 8006566:	687b      	ldr	r3, [r7, #4]
 8006568:	681b      	ldr	r3, [r3, #0]
 800656a:	68db      	ldr	r3, [r3, #12]
 800656c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8006570:	2b40      	cmp	r3, #64	; 0x40
 8006572:	d107      	bne.n	8006584 <HAL_TIM_IRQHandler+0x20a>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 8006574:	687b      	ldr	r3, [r7, #4]
 8006576:	681b      	ldr	r3, [r3, #0]
 8006578:	f06f 0240 	mvn.w	r2, #64	; 0x40
 800657c:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 800657e:	6878      	ldr	r0, [r7, #4]
 8006580:	f000 fa0a 	bl	8006998 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8006584:	687b      	ldr	r3, [r7, #4]
 8006586:	681b      	ldr	r3, [r3, #0]
 8006588:	691b      	ldr	r3, [r3, #16]
 800658a:	f003 0320 	and.w	r3, r3, #32
 800658e:	2b20      	cmp	r3, #32
 8006590:	d10e      	bne.n	80065b0 <HAL_TIM_IRQHandler+0x236>
  {
    if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) != RESET)
 8006592:	687b      	ldr	r3, [r7, #4]
 8006594:	681b      	ldr	r3, [r3, #0]
 8006596:	68db      	ldr	r3, [r3, #12]
 8006598:	f003 0320 	and.w	r3, r3, #32
 800659c:	2b20      	cmp	r3, #32
 800659e:	d107      	bne.n	80065b0 <HAL_TIM_IRQHandler+0x236>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 80065a0:	687b      	ldr	r3, [r7, #4]
 80065a2:	681b      	ldr	r3, [r3, #0]
 80065a4:	f06f 0220 	mvn.w	r2, #32
 80065a8:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 80065aa:	6878      	ldr	r0, [r7, #4]
 80065ac:	f000 fe70 	bl	8007290 <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 80065b0:	bf00      	nop
 80065b2:	3708      	adds	r7, #8
 80065b4:	46bd      	mov	sp, r7
 80065b6:	bd80      	pop	{r7, pc}

080065b8 <HAL_TIM_PWM_ConfigChannel>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim,
                                            TIM_OC_InitTypeDef *sConfig,
                                            uint32_t Channel)
{
 80065b8:	b580      	push	{r7, lr}
 80065ba:	b084      	sub	sp, #16
 80065bc:	af00      	add	r7, sp, #0
 80065be:	60f8      	str	r0, [r7, #12]
 80065c0:	60b9      	str	r1, [r7, #8]
 80065c2:	607a      	str	r2, [r7, #4]
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));

  /* Process Locked */
  __HAL_LOCK(htim);
 80065c4:	68fb      	ldr	r3, [r7, #12]
 80065c6:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80065ca:	2b01      	cmp	r3, #1
 80065cc:	d101      	bne.n	80065d2 <HAL_TIM_PWM_ConfigChannel+0x1a>
 80065ce:	2302      	movs	r3, #2
 80065d0:	e105      	b.n	80067de <HAL_TIM_PWM_ConfigChannel+0x226>
 80065d2:	68fb      	ldr	r3, [r7, #12]
 80065d4:	2201      	movs	r2, #1
 80065d6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 80065da:	68fb      	ldr	r3, [r7, #12]
 80065dc:	2202      	movs	r2, #2
 80065de:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  switch (Channel)
 80065e2:	687b      	ldr	r3, [r7, #4]
 80065e4:	2b14      	cmp	r3, #20
 80065e6:	f200 80f0 	bhi.w	80067ca <HAL_TIM_PWM_ConfigChannel+0x212>
 80065ea:	a201      	add	r2, pc, #4	; (adr r2, 80065f0 <HAL_TIM_PWM_ConfigChannel+0x38>)
 80065ec:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80065f0:	08006645 	.word	0x08006645
 80065f4:	080067cb 	.word	0x080067cb
 80065f8:	080067cb 	.word	0x080067cb
 80065fc:	080067cb 	.word	0x080067cb
 8006600:	08006685 	.word	0x08006685
 8006604:	080067cb 	.word	0x080067cb
 8006608:	080067cb 	.word	0x080067cb
 800660c:	080067cb 	.word	0x080067cb
 8006610:	080066c7 	.word	0x080066c7
 8006614:	080067cb 	.word	0x080067cb
 8006618:	080067cb 	.word	0x080067cb
 800661c:	080067cb 	.word	0x080067cb
 8006620:	08006707 	.word	0x08006707
 8006624:	080067cb 	.word	0x080067cb
 8006628:	080067cb 	.word	0x080067cb
 800662c:	080067cb 	.word	0x080067cb
 8006630:	08006749 	.word	0x08006749
 8006634:	080067cb 	.word	0x080067cb
 8006638:	080067cb 	.word	0x080067cb
 800663c:	080067cb 	.word	0x080067cb
 8006640:	08006789 	.word	0x08006789
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));

      /* Configure the Channel 1 in PWM mode */
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 8006644:	68fb      	ldr	r3, [r7, #12]
 8006646:	681b      	ldr	r3, [r3, #0]
 8006648:	68b9      	ldr	r1, [r7, #8]
 800664a:	4618      	mov	r0, r3
 800664c:	f000 fa4e 	bl	8006aec <TIM_OC1_SetConfig>

      /* Set the Preload enable bit for channel1 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 8006650:	68fb      	ldr	r3, [r7, #12]
 8006652:	681b      	ldr	r3, [r3, #0]
 8006654:	699a      	ldr	r2, [r3, #24]
 8006656:	68fb      	ldr	r3, [r7, #12]
 8006658:	681b      	ldr	r3, [r3, #0]
 800665a:	f042 0208 	orr.w	r2, r2, #8
 800665e:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 8006660:	68fb      	ldr	r3, [r7, #12]
 8006662:	681b      	ldr	r3, [r3, #0]
 8006664:	699a      	ldr	r2, [r3, #24]
 8006666:	68fb      	ldr	r3, [r7, #12]
 8006668:	681b      	ldr	r3, [r3, #0]
 800666a:	f022 0204 	bic.w	r2, r2, #4
 800666e:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 8006670:	68fb      	ldr	r3, [r7, #12]
 8006672:	681b      	ldr	r3, [r3, #0]
 8006674:	6999      	ldr	r1, [r3, #24]
 8006676:	68bb      	ldr	r3, [r7, #8]
 8006678:	691a      	ldr	r2, [r3, #16]
 800667a:	68fb      	ldr	r3, [r7, #12]
 800667c:	681b      	ldr	r3, [r3, #0]
 800667e:	430a      	orrs	r2, r1
 8006680:	619a      	str	r2, [r3, #24]
      break;
 8006682:	e0a3      	b.n	80067cc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));

      /* Configure the Channel 2 in PWM mode */
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 8006684:	68fb      	ldr	r3, [r7, #12]
 8006686:	681b      	ldr	r3, [r3, #0]
 8006688:	68b9      	ldr	r1, [r7, #8]
 800668a:	4618      	mov	r0, r3
 800668c:	f000 faa0 	bl	8006bd0 <TIM_OC2_SetConfig>

      /* Set the Preload enable bit for channel2 */
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 8006690:	68fb      	ldr	r3, [r7, #12]
 8006692:	681b      	ldr	r3, [r3, #0]
 8006694:	699a      	ldr	r2, [r3, #24]
 8006696:	68fb      	ldr	r3, [r7, #12]
 8006698:	681b      	ldr	r3, [r3, #0]
 800669a:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800669e:	619a      	str	r2, [r3, #24]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 80066a0:	68fb      	ldr	r3, [r7, #12]
 80066a2:	681b      	ldr	r3, [r3, #0]
 80066a4:	699a      	ldr	r2, [r3, #24]
 80066a6:	68fb      	ldr	r3, [r7, #12]
 80066a8:	681b      	ldr	r3, [r3, #0]
 80066aa:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80066ae:	619a      	str	r2, [r3, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 80066b0:	68fb      	ldr	r3, [r7, #12]
 80066b2:	681b      	ldr	r3, [r3, #0]
 80066b4:	6999      	ldr	r1, [r3, #24]
 80066b6:	68bb      	ldr	r3, [r7, #8]
 80066b8:	691b      	ldr	r3, [r3, #16]
 80066ba:	021a      	lsls	r2, r3, #8
 80066bc:	68fb      	ldr	r3, [r7, #12]
 80066be:	681b      	ldr	r3, [r3, #0]
 80066c0:	430a      	orrs	r2, r1
 80066c2:	619a      	str	r2, [r3, #24]
      break;
 80066c4:	e082      	b.n	80067cc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));

      /* Configure the Channel 3 in PWM mode */
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 80066c6:	68fb      	ldr	r3, [r7, #12]
 80066c8:	681b      	ldr	r3, [r3, #0]
 80066ca:	68b9      	ldr	r1, [r7, #8]
 80066cc:	4618      	mov	r0, r3
 80066ce:	f000 faf7 	bl	8006cc0 <TIM_OC3_SetConfig>

      /* Set the Preload enable bit for channel3 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 80066d2:	68fb      	ldr	r3, [r7, #12]
 80066d4:	681b      	ldr	r3, [r3, #0]
 80066d6:	69da      	ldr	r2, [r3, #28]
 80066d8:	68fb      	ldr	r3, [r7, #12]
 80066da:	681b      	ldr	r3, [r3, #0]
 80066dc:	f042 0208 	orr.w	r2, r2, #8
 80066e0:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 80066e2:	68fb      	ldr	r3, [r7, #12]
 80066e4:	681b      	ldr	r3, [r3, #0]
 80066e6:	69da      	ldr	r2, [r3, #28]
 80066e8:	68fb      	ldr	r3, [r7, #12]
 80066ea:	681b      	ldr	r3, [r3, #0]
 80066ec:	f022 0204 	bic.w	r2, r2, #4
 80066f0:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 80066f2:	68fb      	ldr	r3, [r7, #12]
 80066f4:	681b      	ldr	r3, [r3, #0]
 80066f6:	69d9      	ldr	r1, [r3, #28]
 80066f8:	68bb      	ldr	r3, [r7, #8]
 80066fa:	691a      	ldr	r2, [r3, #16]
 80066fc:	68fb      	ldr	r3, [r7, #12]
 80066fe:	681b      	ldr	r3, [r3, #0]
 8006700:	430a      	orrs	r2, r1
 8006702:	61da      	str	r2, [r3, #28]
      break;
 8006704:	e062      	b.n	80067cc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));

      /* Configure the Channel 4 in PWM mode */
      TIM_OC4_SetConfig(htim->Instance, sConfig);
 8006706:	68fb      	ldr	r3, [r7, #12]
 8006708:	681b      	ldr	r3, [r3, #0]
 800670a:	68b9      	ldr	r1, [r7, #8]
 800670c:	4618      	mov	r0, r3
 800670e:	f000 fb4d 	bl	8006dac <TIM_OC4_SetConfig>

      /* Set the Preload enable bit for channel4 */
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 8006712:	68fb      	ldr	r3, [r7, #12]
 8006714:	681b      	ldr	r3, [r3, #0]
 8006716:	69da      	ldr	r2, [r3, #28]
 8006718:	68fb      	ldr	r3, [r7, #12]
 800671a:	681b      	ldr	r3, [r3, #0]
 800671c:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8006720:	61da      	str	r2, [r3, #28]

      /* Configure the Output Fast mode */
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 8006722:	68fb      	ldr	r3, [r7, #12]
 8006724:	681b      	ldr	r3, [r3, #0]
 8006726:	69da      	ldr	r2, [r3, #28]
 8006728:	68fb      	ldr	r3, [r7, #12]
 800672a:	681b      	ldr	r3, [r3, #0]
 800672c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8006730:	61da      	str	r2, [r3, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 8006732:	68fb      	ldr	r3, [r7, #12]
 8006734:	681b      	ldr	r3, [r3, #0]
 8006736:	69d9      	ldr	r1, [r3, #28]
 8006738:	68bb      	ldr	r3, [r7, #8]
 800673a:	691b      	ldr	r3, [r3, #16]
 800673c:	021a      	lsls	r2, r3, #8
 800673e:	68fb      	ldr	r3, [r7, #12]
 8006740:	681b      	ldr	r3, [r3, #0]
 8006742:	430a      	orrs	r2, r1
 8006744:	61da      	str	r2, [r3, #28]
      break;
 8006746:	e041      	b.n	80067cc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));

      /* Configure the Channel 5 in PWM mode */
      TIM_OC5_SetConfig(htim->Instance, sConfig);
 8006748:	68fb      	ldr	r3, [r7, #12]
 800674a:	681b      	ldr	r3, [r3, #0]
 800674c:	68b9      	ldr	r1, [r7, #8]
 800674e:	4618      	mov	r0, r3
 8006750:	f000 fb84 	bl	8006e5c <TIM_OC5_SetConfig>

      /* Set the Preload enable bit for channel5*/
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 8006754:	68fb      	ldr	r3, [r7, #12]
 8006756:	681b      	ldr	r3, [r3, #0]
 8006758:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800675a:	68fb      	ldr	r3, [r7, #12]
 800675c:	681b      	ldr	r3, [r3, #0]
 800675e:	f042 0208 	orr.w	r2, r2, #8
 8006762:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 8006764:	68fb      	ldr	r3, [r7, #12]
 8006766:	681b      	ldr	r3, [r3, #0]
 8006768:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800676a:	68fb      	ldr	r3, [r7, #12]
 800676c:	681b      	ldr	r3, [r3, #0]
 800676e:	f022 0204 	bic.w	r2, r2, #4
 8006772:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 8006774:	68fb      	ldr	r3, [r7, #12]
 8006776:	681b      	ldr	r3, [r3, #0]
 8006778:	6d59      	ldr	r1, [r3, #84]	; 0x54
 800677a:	68bb      	ldr	r3, [r7, #8]
 800677c:	691a      	ldr	r2, [r3, #16]
 800677e:	68fb      	ldr	r3, [r7, #12]
 8006780:	681b      	ldr	r3, [r3, #0]
 8006782:	430a      	orrs	r2, r1
 8006784:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 8006786:	e021      	b.n	80067cc <HAL_TIM_PWM_ConfigChannel+0x214>
    {
      /* Check the parameters */
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));

      /* Configure the Channel 6 in PWM mode */
      TIM_OC6_SetConfig(htim->Instance, sConfig);
 8006788:	68fb      	ldr	r3, [r7, #12]
 800678a:	681b      	ldr	r3, [r3, #0]
 800678c:	68b9      	ldr	r1, [r7, #8]
 800678e:	4618      	mov	r0, r3
 8006790:	f000 fbb6 	bl	8006f00 <TIM_OC6_SetConfig>

      /* Set the Preload enable bit for channel6 */
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 8006794:	68fb      	ldr	r3, [r7, #12]
 8006796:	681b      	ldr	r3, [r3, #0]
 8006798:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800679a:	68fb      	ldr	r3, [r7, #12]
 800679c:	681b      	ldr	r3, [r3, #0]
 800679e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80067a2:	655a      	str	r2, [r3, #84]	; 0x54

      /* Configure the Output Fast mode */
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 80067a4:	68fb      	ldr	r3, [r7, #12]
 80067a6:	681b      	ldr	r3, [r3, #0]
 80067a8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80067aa:	68fb      	ldr	r3, [r7, #12]
 80067ac:	681b      	ldr	r3, [r3, #0]
 80067ae:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 80067b2:	655a      	str	r2, [r3, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 80067b4:	68fb      	ldr	r3, [r7, #12]
 80067b6:	681b      	ldr	r3, [r3, #0]
 80067b8:	6d59      	ldr	r1, [r3, #84]	; 0x54
 80067ba:	68bb      	ldr	r3, [r7, #8]
 80067bc:	691b      	ldr	r3, [r3, #16]
 80067be:	021a      	lsls	r2, r3, #8
 80067c0:	68fb      	ldr	r3, [r7, #12]
 80067c2:	681b      	ldr	r3, [r3, #0]
 80067c4:	430a      	orrs	r2, r1
 80067c6:	655a      	str	r2, [r3, #84]	; 0x54
      break;
 80067c8:	e000      	b.n	80067cc <HAL_TIM_PWM_ConfigChannel+0x214>
    }

    default:
      break;
 80067ca:	bf00      	nop
  }

  htim->State = HAL_TIM_STATE_READY;
 80067cc:	68fb      	ldr	r3, [r7, #12]
 80067ce:	2201      	movs	r2, #1
 80067d0:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 80067d4:	68fb      	ldr	r3, [r7, #12]
 80067d6:	2200      	movs	r2, #0
 80067d8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 80067dc:	2300      	movs	r3, #0
}
 80067de:	4618      	mov	r0, r3
 80067e0:	3710      	adds	r7, #16
 80067e2:	46bd      	mov	sp, r7
 80067e4:	bd80      	pop	{r7, pc}
 80067e6:	bf00      	nop

080067e8 <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 80067e8:	b580      	push	{r7, lr}
 80067ea:	b084      	sub	sp, #16
 80067ec:	af00      	add	r7, sp, #0
 80067ee:	6078      	str	r0, [r7, #4]
 80067f0:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 80067f2:	687b      	ldr	r3, [r7, #4]
 80067f4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80067f8:	2b01      	cmp	r3, #1
 80067fa:	d101      	bne.n	8006800 <HAL_TIM_ConfigClockSource+0x18>
 80067fc:	2302      	movs	r3, #2
 80067fe:	e0a6      	b.n	800694e <HAL_TIM_ConfigClockSource+0x166>
 8006800:	687b      	ldr	r3, [r7, #4]
 8006802:	2201      	movs	r2, #1
 8006804:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 8006808:	687b      	ldr	r3, [r7, #4]
 800680a:	2202      	movs	r2, #2
 800680c:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 8006810:	687b      	ldr	r3, [r7, #4]
 8006812:	681b      	ldr	r3, [r3, #0]
 8006814:	689b      	ldr	r3, [r3, #8]
 8006816:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8006818:	68fa      	ldr	r2, [r7, #12]
 800681a:	4b4f      	ldr	r3, [pc, #316]	; (8006958 <HAL_TIM_ConfigClockSource+0x170>)
 800681c:	4013      	ands	r3, r2
 800681e:	60fb      	str	r3, [r7, #12]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8006820:	68fb      	ldr	r3, [r7, #12]
 8006822:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8006826:	60fb      	str	r3, [r7, #12]
  htim->Instance->SMCR = tmpsmcr;
 8006828:	687b      	ldr	r3, [r7, #4]
 800682a:	681b      	ldr	r3, [r3, #0]
 800682c:	68fa      	ldr	r2, [r7, #12]
 800682e:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 8006830:	683b      	ldr	r3, [r7, #0]
 8006832:	681b      	ldr	r3, [r3, #0]
 8006834:	2b40      	cmp	r3, #64	; 0x40
 8006836:	d067      	beq.n	8006908 <HAL_TIM_ConfigClockSource+0x120>
 8006838:	2b40      	cmp	r3, #64	; 0x40
 800683a:	d80b      	bhi.n	8006854 <HAL_TIM_ConfigClockSource+0x6c>
 800683c:	2b10      	cmp	r3, #16
 800683e:	d073      	beq.n	8006928 <HAL_TIM_ConfigClockSource+0x140>
 8006840:	2b10      	cmp	r3, #16
 8006842:	d802      	bhi.n	800684a <HAL_TIM_ConfigClockSource+0x62>
 8006844:	2b00      	cmp	r3, #0
 8006846:	d06f      	beq.n	8006928 <HAL_TIM_ConfigClockSource+0x140>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
      break;
    }

    default:
      break;
 8006848:	e078      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 800684a:	2b20      	cmp	r3, #32
 800684c:	d06c      	beq.n	8006928 <HAL_TIM_ConfigClockSource+0x140>
 800684e:	2b30      	cmp	r3, #48	; 0x30
 8006850:	d06a      	beq.n	8006928 <HAL_TIM_ConfigClockSource+0x140>
      break;
 8006852:	e073      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 8006854:	2b70      	cmp	r3, #112	; 0x70
 8006856:	d00d      	beq.n	8006874 <HAL_TIM_ConfigClockSource+0x8c>
 8006858:	2b70      	cmp	r3, #112	; 0x70
 800685a:	d804      	bhi.n	8006866 <HAL_TIM_ConfigClockSource+0x7e>
 800685c:	2b50      	cmp	r3, #80	; 0x50
 800685e:	d033      	beq.n	80068c8 <HAL_TIM_ConfigClockSource+0xe0>
 8006860:	2b60      	cmp	r3, #96	; 0x60
 8006862:	d041      	beq.n	80068e8 <HAL_TIM_ConfigClockSource+0x100>
      break;
 8006864:	e06a      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
  switch (sClockSourceConfig->ClockSource)
 8006866:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800686a:	d066      	beq.n	800693a <HAL_TIM_ConfigClockSource+0x152>
 800686c:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8006870:	d017      	beq.n	80068a2 <HAL_TIM_ConfigClockSource+0xba>
      break;
 8006872:	e063      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
 8006874:	687b      	ldr	r3, [r7, #4]
 8006876:	6818      	ldr	r0, [r3, #0]
 8006878:	683b      	ldr	r3, [r7, #0]
 800687a:	6899      	ldr	r1, [r3, #8]
 800687c:	683b      	ldr	r3, [r7, #0]
 800687e:	685a      	ldr	r2, [r3, #4]
 8006880:	683b      	ldr	r3, [r7, #0]
 8006882:	68db      	ldr	r3, [r3, #12]
 8006884:	f000 fc0a 	bl	800709c <TIM_ETR_SetConfig>
      tmpsmcr = htim->Instance->SMCR;
 8006888:	687b      	ldr	r3, [r7, #4]
 800688a:	681b      	ldr	r3, [r3, #0]
 800688c:	689b      	ldr	r3, [r3, #8]
 800688e:	60fb      	str	r3, [r7, #12]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 8006890:	68fb      	ldr	r3, [r7, #12]
 8006892:	f043 0377 	orr.w	r3, r3, #119	; 0x77
 8006896:	60fb      	str	r3, [r7, #12]
      htim->Instance->SMCR = tmpsmcr;
 8006898:	687b      	ldr	r3, [r7, #4]
 800689a:	681b      	ldr	r3, [r3, #0]
 800689c:	68fa      	ldr	r2, [r7, #12]
 800689e:	609a      	str	r2, [r3, #8]
      break;
 80068a0:	e04c      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      TIM_ETR_SetConfig(htim->Instance,
 80068a2:	687b      	ldr	r3, [r7, #4]
 80068a4:	6818      	ldr	r0, [r3, #0]
 80068a6:	683b      	ldr	r3, [r7, #0]
 80068a8:	6899      	ldr	r1, [r3, #8]
 80068aa:	683b      	ldr	r3, [r7, #0]
 80068ac:	685a      	ldr	r2, [r3, #4]
 80068ae:	683b      	ldr	r3, [r7, #0]
 80068b0:	68db      	ldr	r3, [r3, #12]
 80068b2:	f000 fbf3 	bl	800709c <TIM_ETR_SetConfig>
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 80068b6:	687b      	ldr	r3, [r7, #4]
 80068b8:	681b      	ldr	r3, [r3, #0]
 80068ba:	689a      	ldr	r2, [r3, #8]
 80068bc:	687b      	ldr	r3, [r7, #4]
 80068be:	681b      	ldr	r3, [r3, #0]
 80068c0:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80068c4:	609a      	str	r2, [r3, #8]
      break;
 80068c6:	e039      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
 80068c8:	687b      	ldr	r3, [r7, #4]
 80068ca:	6818      	ldr	r0, [r3, #0]
 80068cc:	683b      	ldr	r3, [r7, #0]
 80068ce:	6859      	ldr	r1, [r3, #4]
 80068d0:	683b      	ldr	r3, [r7, #0]
 80068d2:	68db      	ldr	r3, [r3, #12]
 80068d4:	461a      	mov	r2, r3
 80068d6:	f000 fb67 	bl	8006fa8 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 80068da:	687b      	ldr	r3, [r7, #4]
 80068dc:	681b      	ldr	r3, [r3, #0]
 80068de:	2150      	movs	r1, #80	; 0x50
 80068e0:	4618      	mov	r0, r3
 80068e2:	f000 fbc0 	bl	8007066 <TIM_ITRx_SetConfig>
      break;
 80068e6:	e029      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI2_ConfigInputStage(htim->Instance,
 80068e8:	687b      	ldr	r3, [r7, #4]
 80068ea:	6818      	ldr	r0, [r3, #0]
 80068ec:	683b      	ldr	r3, [r7, #0]
 80068ee:	6859      	ldr	r1, [r3, #4]
 80068f0:	683b      	ldr	r3, [r7, #0]
 80068f2:	68db      	ldr	r3, [r3, #12]
 80068f4:	461a      	mov	r2, r3
 80068f6:	f000 fb86 	bl	8007006 <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 80068fa:	687b      	ldr	r3, [r7, #4]
 80068fc:	681b      	ldr	r3, [r3, #0]
 80068fe:	2160      	movs	r1, #96	; 0x60
 8006900:	4618      	mov	r0, r3
 8006902:	f000 fbb0 	bl	8007066 <TIM_ITRx_SetConfig>
      break;
 8006906:	e019      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      TIM_TI1_ConfigInputStage(htim->Instance,
 8006908:	687b      	ldr	r3, [r7, #4]
 800690a:	6818      	ldr	r0, [r3, #0]
 800690c:	683b      	ldr	r3, [r7, #0]
 800690e:	6859      	ldr	r1, [r3, #4]
 8006910:	683b      	ldr	r3, [r7, #0]
 8006912:	68db      	ldr	r3, [r3, #12]
 8006914:	461a      	mov	r2, r3
 8006916:	f000 fb47 	bl	8006fa8 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800691a:	687b      	ldr	r3, [r7, #4]
 800691c:	681b      	ldr	r3, [r3, #0]
 800691e:	2140      	movs	r1, #64	; 0x40
 8006920:	4618      	mov	r0, r3
 8006922:	f000 fba0 	bl	8007066 <TIM_ITRx_SetConfig>
      break;
 8006926:	e009      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 8006928:	687b      	ldr	r3, [r7, #4]
 800692a:	681a      	ldr	r2, [r3, #0]
 800692c:	683b      	ldr	r3, [r7, #0]
 800692e:	681b      	ldr	r3, [r3, #0]
 8006930:	4619      	mov	r1, r3
 8006932:	4610      	mov	r0, r2
 8006934:	f000 fb97 	bl	8007066 <TIM_ITRx_SetConfig>
      break;
 8006938:	e000      	b.n	800693c <HAL_TIM_ConfigClockSource+0x154>
      break;
 800693a:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 800693c:	687b      	ldr	r3, [r7, #4]
 800693e:	2201      	movs	r2, #1
 8006940:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8006944:	687b      	ldr	r3, [r7, #4]
 8006946:	2200      	movs	r2, #0
 8006948:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800694c:	2300      	movs	r3, #0
}
 800694e:	4618      	mov	r0, r3
 8006950:	3710      	adds	r7, #16
 8006952:	46bd      	mov	sp, r7
 8006954:	bd80      	pop	{r7, pc}
 8006956:	bf00      	nop
 8006958:	fffeff88 	.word	0xfffeff88

0800695c <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 800695c:	b480      	push	{r7}
 800695e:	b083      	sub	sp, #12
 8006960:	af00      	add	r7, sp, #0
 8006962:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8006964:	bf00      	nop
 8006966:	370c      	adds	r7, #12
 8006968:	46bd      	mov	sp, r7
 800696a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800696e:	4770      	bx	lr

08006970 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8006970:	b480      	push	{r7}
 8006972:	b083      	sub	sp, #12
 8006974:	af00      	add	r7, sp, #0
 8006976:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8006978:	bf00      	nop
 800697a:	370c      	adds	r7, #12
 800697c:	46bd      	mov	sp, r7
 800697e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006982:	4770      	bx	lr

08006984 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8006984:	b480      	push	{r7}
 8006986:	b083      	sub	sp, #12
 8006988:	af00      	add	r7, sp, #0
 800698a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 800698c:	bf00      	nop
 800698e:	370c      	adds	r7, #12
 8006990:	46bd      	mov	sp, r7
 8006992:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006996:	4770      	bx	lr

08006998 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8006998:	b480      	push	{r7}
 800699a:	b083      	sub	sp, #12
 800699c:	af00      	add	r7, sp, #0
 800699e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 80069a0:	bf00      	nop
 80069a2:	370c      	adds	r7, #12
 80069a4:	46bd      	mov	sp, r7
 80069a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80069aa:	4770      	bx	lr

080069ac <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 80069ac:	b480      	push	{r7}
 80069ae:	b085      	sub	sp, #20
 80069b0:	af00      	add	r7, sp, #0
 80069b2:	6078      	str	r0, [r7, #4]
 80069b4:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 80069b6:	687b      	ldr	r3, [r7, #4]
 80069b8:	681b      	ldr	r3, [r3, #0]
 80069ba:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 80069bc:	687b      	ldr	r3, [r7, #4]
 80069be:	4a40      	ldr	r2, [pc, #256]	; (8006ac0 <TIM_Base_SetConfig+0x114>)
 80069c0:	4293      	cmp	r3, r2
 80069c2:	d013      	beq.n	80069ec <TIM_Base_SetConfig+0x40>
 80069c4:	687b      	ldr	r3, [r7, #4]
 80069c6:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80069ca:	d00f      	beq.n	80069ec <TIM_Base_SetConfig+0x40>
 80069cc:	687b      	ldr	r3, [r7, #4]
 80069ce:	4a3d      	ldr	r2, [pc, #244]	; (8006ac4 <TIM_Base_SetConfig+0x118>)
 80069d0:	4293      	cmp	r3, r2
 80069d2:	d00b      	beq.n	80069ec <TIM_Base_SetConfig+0x40>
 80069d4:	687b      	ldr	r3, [r7, #4]
 80069d6:	4a3c      	ldr	r2, [pc, #240]	; (8006ac8 <TIM_Base_SetConfig+0x11c>)
 80069d8:	4293      	cmp	r3, r2
 80069da:	d007      	beq.n	80069ec <TIM_Base_SetConfig+0x40>
 80069dc:	687b      	ldr	r3, [r7, #4]
 80069de:	4a3b      	ldr	r2, [pc, #236]	; (8006acc <TIM_Base_SetConfig+0x120>)
 80069e0:	4293      	cmp	r3, r2
 80069e2:	d003      	beq.n	80069ec <TIM_Base_SetConfig+0x40>
 80069e4:	687b      	ldr	r3, [r7, #4]
 80069e6:	4a3a      	ldr	r2, [pc, #232]	; (8006ad0 <TIM_Base_SetConfig+0x124>)
 80069e8:	4293      	cmp	r3, r2
 80069ea:	d108      	bne.n	80069fe <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80069ec:	68fb      	ldr	r3, [r7, #12]
 80069ee:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80069f2:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 80069f4:	683b      	ldr	r3, [r7, #0]
 80069f6:	685b      	ldr	r3, [r3, #4]
 80069f8:	68fa      	ldr	r2, [r7, #12]
 80069fa:	4313      	orrs	r3, r2
 80069fc:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 80069fe:	687b      	ldr	r3, [r7, #4]
 8006a00:	4a2f      	ldr	r2, [pc, #188]	; (8006ac0 <TIM_Base_SetConfig+0x114>)
 8006a02:	4293      	cmp	r3, r2
 8006a04:	d02b      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a06:	687b      	ldr	r3, [r7, #4]
 8006a08:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8006a0c:	d027      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a0e:	687b      	ldr	r3, [r7, #4]
 8006a10:	4a2c      	ldr	r2, [pc, #176]	; (8006ac4 <TIM_Base_SetConfig+0x118>)
 8006a12:	4293      	cmp	r3, r2
 8006a14:	d023      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a16:	687b      	ldr	r3, [r7, #4]
 8006a18:	4a2b      	ldr	r2, [pc, #172]	; (8006ac8 <TIM_Base_SetConfig+0x11c>)
 8006a1a:	4293      	cmp	r3, r2
 8006a1c:	d01f      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a1e:	687b      	ldr	r3, [r7, #4]
 8006a20:	4a2a      	ldr	r2, [pc, #168]	; (8006acc <TIM_Base_SetConfig+0x120>)
 8006a22:	4293      	cmp	r3, r2
 8006a24:	d01b      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a26:	687b      	ldr	r3, [r7, #4]
 8006a28:	4a29      	ldr	r2, [pc, #164]	; (8006ad0 <TIM_Base_SetConfig+0x124>)
 8006a2a:	4293      	cmp	r3, r2
 8006a2c:	d017      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a2e:	687b      	ldr	r3, [r7, #4]
 8006a30:	4a28      	ldr	r2, [pc, #160]	; (8006ad4 <TIM_Base_SetConfig+0x128>)
 8006a32:	4293      	cmp	r3, r2
 8006a34:	d013      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a36:	687b      	ldr	r3, [r7, #4]
 8006a38:	4a27      	ldr	r2, [pc, #156]	; (8006ad8 <TIM_Base_SetConfig+0x12c>)
 8006a3a:	4293      	cmp	r3, r2
 8006a3c:	d00f      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a3e:	687b      	ldr	r3, [r7, #4]
 8006a40:	4a26      	ldr	r2, [pc, #152]	; (8006adc <TIM_Base_SetConfig+0x130>)
 8006a42:	4293      	cmp	r3, r2
 8006a44:	d00b      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a46:	687b      	ldr	r3, [r7, #4]
 8006a48:	4a25      	ldr	r2, [pc, #148]	; (8006ae0 <TIM_Base_SetConfig+0x134>)
 8006a4a:	4293      	cmp	r3, r2
 8006a4c:	d007      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a4e:	687b      	ldr	r3, [r7, #4]
 8006a50:	4a24      	ldr	r2, [pc, #144]	; (8006ae4 <TIM_Base_SetConfig+0x138>)
 8006a52:	4293      	cmp	r3, r2
 8006a54:	d003      	beq.n	8006a5e <TIM_Base_SetConfig+0xb2>
 8006a56:	687b      	ldr	r3, [r7, #4]
 8006a58:	4a23      	ldr	r2, [pc, #140]	; (8006ae8 <TIM_Base_SetConfig+0x13c>)
 8006a5a:	4293      	cmp	r3, r2
 8006a5c:	d108      	bne.n	8006a70 <TIM_Base_SetConfig+0xc4>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8006a5e:	68fb      	ldr	r3, [r7, #12]
 8006a60:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006a64:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8006a66:	683b      	ldr	r3, [r7, #0]
 8006a68:	68db      	ldr	r3, [r3, #12]
 8006a6a:	68fa      	ldr	r2, [r7, #12]
 8006a6c:	4313      	orrs	r3, r2
 8006a6e:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8006a70:	68fb      	ldr	r3, [r7, #12]
 8006a72:	f023 0280 	bic.w	r2, r3, #128	; 0x80
 8006a76:	683b      	ldr	r3, [r7, #0]
 8006a78:	695b      	ldr	r3, [r3, #20]
 8006a7a:	4313      	orrs	r3, r2
 8006a7c:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8006a7e:	687b      	ldr	r3, [r7, #4]
 8006a80:	68fa      	ldr	r2, [r7, #12]
 8006a82:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8006a84:	683b      	ldr	r3, [r7, #0]
 8006a86:	689a      	ldr	r2, [r3, #8]
 8006a88:	687b      	ldr	r3, [r7, #4]
 8006a8a:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8006a8c:	683b      	ldr	r3, [r7, #0]
 8006a8e:	681a      	ldr	r2, [r3, #0]
 8006a90:	687b      	ldr	r3, [r7, #4]
 8006a92:	629a      	str	r2, [r3, #40]	; 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8006a94:	687b      	ldr	r3, [r7, #4]
 8006a96:	4a0a      	ldr	r2, [pc, #40]	; (8006ac0 <TIM_Base_SetConfig+0x114>)
 8006a98:	4293      	cmp	r3, r2
 8006a9a:	d003      	beq.n	8006aa4 <TIM_Base_SetConfig+0xf8>
 8006a9c:	687b      	ldr	r3, [r7, #4]
 8006a9e:	4a0c      	ldr	r2, [pc, #48]	; (8006ad0 <TIM_Base_SetConfig+0x124>)
 8006aa0:	4293      	cmp	r3, r2
 8006aa2:	d103      	bne.n	8006aac <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8006aa4:	683b      	ldr	r3, [r7, #0]
 8006aa6:	691a      	ldr	r2, [r3, #16]
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8006aac:	687b      	ldr	r3, [r7, #4]
 8006aae:	2201      	movs	r2, #1
 8006ab0:	615a      	str	r2, [r3, #20]
}
 8006ab2:	bf00      	nop
 8006ab4:	3714      	adds	r7, #20
 8006ab6:	46bd      	mov	sp, r7
 8006ab8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006abc:	4770      	bx	lr
 8006abe:	bf00      	nop
 8006ac0:	40010000 	.word	0x40010000
 8006ac4:	40000400 	.word	0x40000400
 8006ac8:	40000800 	.word	0x40000800
 8006acc:	40000c00 	.word	0x40000c00
 8006ad0:	40010400 	.word	0x40010400
 8006ad4:	40014000 	.word	0x40014000
 8006ad8:	40014400 	.word	0x40014400
 8006adc:	40014800 	.word	0x40014800
 8006ae0:	40001800 	.word	0x40001800
 8006ae4:	40001c00 	.word	0x40001c00
 8006ae8:	40002000 	.word	0x40002000

08006aec <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8006aec:	b480      	push	{r7}
 8006aee:	b087      	sub	sp, #28
 8006af0:	af00      	add	r7, sp, #0
 8006af2:	6078      	str	r0, [r7, #4]
 8006af4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8006af6:	687b      	ldr	r3, [r7, #4]
 8006af8:	6a1b      	ldr	r3, [r3, #32]
 8006afa:	f023 0201 	bic.w	r2, r3, #1
 8006afe:	687b      	ldr	r3, [r7, #4]
 8006b00:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006b02:	687b      	ldr	r3, [r7, #4]
 8006b04:	6a1b      	ldr	r3, [r3, #32]
 8006b06:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006b08:	687b      	ldr	r3, [r7, #4]
 8006b0a:	685b      	ldr	r3, [r3, #4]
 8006b0c:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8006b0e:	687b      	ldr	r3, [r7, #4]
 8006b10:	699b      	ldr	r3, [r3, #24]
 8006b12:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
 8006b14:	68fa      	ldr	r2, [r7, #12]
 8006b16:	4b2b      	ldr	r3, [pc, #172]	; (8006bc4 <TIM_OC1_SetConfig+0xd8>)
 8006b18:	4013      	ands	r3, r2
 8006b1a:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 8006b1c:	68fb      	ldr	r3, [r7, #12]
 8006b1e:	f023 0303 	bic.w	r3, r3, #3
 8006b22:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8006b24:	683b      	ldr	r3, [r7, #0]
 8006b26:	681b      	ldr	r3, [r3, #0]
 8006b28:	68fa      	ldr	r2, [r7, #12]
 8006b2a:	4313      	orrs	r3, r2
 8006b2c:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
 8006b2e:	697b      	ldr	r3, [r7, #20]
 8006b30:	f023 0302 	bic.w	r3, r3, #2
 8006b34:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;
 8006b36:	683b      	ldr	r3, [r7, #0]
 8006b38:	689b      	ldr	r3, [r3, #8]
 8006b3a:	697a      	ldr	r2, [r7, #20]
 8006b3c:	4313      	orrs	r3, r2
 8006b3e:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 8006b40:	687b      	ldr	r3, [r7, #4]
 8006b42:	4a21      	ldr	r2, [pc, #132]	; (8006bc8 <TIM_OC1_SetConfig+0xdc>)
 8006b44:	4293      	cmp	r3, r2
 8006b46:	d003      	beq.n	8006b50 <TIM_OC1_SetConfig+0x64>
 8006b48:	687b      	ldr	r3, [r7, #4]
 8006b4a:	4a20      	ldr	r2, [pc, #128]	; (8006bcc <TIM_OC1_SetConfig+0xe0>)
 8006b4c:	4293      	cmp	r3, r2
 8006b4e:	d10c      	bne.n	8006b6a <TIM_OC1_SetConfig+0x7e>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC1NP;
 8006b50:	697b      	ldr	r3, [r7, #20]
 8006b52:	f023 0308 	bic.w	r3, r3, #8
 8006b56:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= OC_Config->OCNPolarity;
 8006b58:	683b      	ldr	r3, [r7, #0]
 8006b5a:	68db      	ldr	r3, [r3, #12]
 8006b5c:	697a      	ldr	r2, [r7, #20]
 8006b5e:	4313      	orrs	r3, r2
 8006b60:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
 8006b62:	697b      	ldr	r3, [r7, #20]
 8006b64:	f023 0304 	bic.w	r3, r3, #4
 8006b68:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006b6a:	687b      	ldr	r3, [r7, #4]
 8006b6c:	4a16      	ldr	r2, [pc, #88]	; (8006bc8 <TIM_OC1_SetConfig+0xdc>)
 8006b6e:	4293      	cmp	r3, r2
 8006b70:	d003      	beq.n	8006b7a <TIM_OC1_SetConfig+0x8e>
 8006b72:	687b      	ldr	r3, [r7, #4]
 8006b74:	4a15      	ldr	r2, [pc, #84]	; (8006bcc <TIM_OC1_SetConfig+0xe0>)
 8006b76:	4293      	cmp	r3, r2
 8006b78:	d111      	bne.n	8006b9e <TIM_OC1_SetConfig+0xb2>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
 8006b7a:	693b      	ldr	r3, [r7, #16]
 8006b7c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8006b80:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS1N;
 8006b82:	693b      	ldr	r3, [r7, #16]
 8006b84:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8006b88:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
 8006b8a:	683b      	ldr	r3, [r7, #0]
 8006b8c:	695b      	ldr	r3, [r3, #20]
 8006b8e:	693a      	ldr	r2, [r7, #16]
 8006b90:	4313      	orrs	r3, r2
 8006b92:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 8006b94:	683b      	ldr	r3, [r7, #0]
 8006b96:	699b      	ldr	r3, [r3, #24]
 8006b98:	693a      	ldr	r2, [r7, #16]
 8006b9a:	4313      	orrs	r3, r2
 8006b9c:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8006b9e:	687b      	ldr	r3, [r7, #4]
 8006ba0:	693a      	ldr	r2, [r7, #16]
 8006ba2:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8006ba4:	687b      	ldr	r3, [r7, #4]
 8006ba6:	68fa      	ldr	r2, [r7, #12]
 8006ba8:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 8006baa:	683b      	ldr	r3, [r7, #0]
 8006bac:	685a      	ldr	r2, [r3, #4]
 8006bae:	687b      	ldr	r3, [r7, #4]
 8006bb0:	635a      	str	r2, [r3, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006bb2:	687b      	ldr	r3, [r7, #4]
 8006bb4:	697a      	ldr	r2, [r7, #20]
 8006bb6:	621a      	str	r2, [r3, #32]
}
 8006bb8:	bf00      	nop
 8006bba:	371c      	adds	r7, #28
 8006bbc:	46bd      	mov	sp, r7
 8006bbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006bc2:	4770      	bx	lr
 8006bc4:	fffeff8f 	.word	0xfffeff8f
 8006bc8:	40010000 	.word	0x40010000
 8006bcc:	40010400 	.word	0x40010400

08006bd0 <TIM_OC2_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8006bd0:	b480      	push	{r7}
 8006bd2:	b087      	sub	sp, #28
 8006bd4:	af00      	add	r7, sp, #0
 8006bd6:	6078      	str	r0, [r7, #4]
 8006bd8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8006bda:	687b      	ldr	r3, [r7, #4]
 8006bdc:	6a1b      	ldr	r3, [r3, #32]
 8006bde:	f023 0210 	bic.w	r2, r3, #16
 8006be2:	687b      	ldr	r3, [r7, #4]
 8006be4:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006be6:	687b      	ldr	r3, [r7, #4]
 8006be8:	6a1b      	ldr	r3, [r3, #32]
 8006bea:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006bec:	687b      	ldr	r3, [r7, #4]
 8006bee:	685b      	ldr	r3, [r3, #4]
 8006bf0:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;
 8006bf2:	687b      	ldr	r3, [r7, #4]
 8006bf4:	699b      	ldr	r3, [r3, #24]
 8006bf6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR1_OC2M;
 8006bf8:	68fa      	ldr	r2, [r7, #12]
 8006bfa:	4b2e      	ldr	r3, [pc, #184]	; (8006cb4 <TIM_OC2_SetConfig+0xe4>)
 8006bfc:	4013      	ands	r3, r2
 8006bfe:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 8006c00:	68fb      	ldr	r3, [r7, #12]
 8006c02:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006c06:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8006c08:	683b      	ldr	r3, [r7, #0]
 8006c0a:	681b      	ldr	r3, [r3, #0]
 8006c0c:	021b      	lsls	r3, r3, #8
 8006c0e:	68fa      	ldr	r2, [r7, #12]
 8006c10:	4313      	orrs	r3, r2
 8006c12:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC2P;
 8006c14:	697b      	ldr	r3, [r7, #20]
 8006c16:	f023 0320 	bic.w	r3, r3, #32
 8006c1a:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 4U);
 8006c1c:	683b      	ldr	r3, [r7, #0]
 8006c1e:	689b      	ldr	r3, [r3, #8]
 8006c20:	011b      	lsls	r3, r3, #4
 8006c22:	697a      	ldr	r2, [r7, #20]
 8006c24:	4313      	orrs	r3, r2
 8006c26:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 8006c28:	687b      	ldr	r3, [r7, #4]
 8006c2a:	4a23      	ldr	r2, [pc, #140]	; (8006cb8 <TIM_OC2_SetConfig+0xe8>)
 8006c2c:	4293      	cmp	r3, r2
 8006c2e:	d003      	beq.n	8006c38 <TIM_OC2_SetConfig+0x68>
 8006c30:	687b      	ldr	r3, [r7, #4]
 8006c32:	4a22      	ldr	r2, [pc, #136]	; (8006cbc <TIM_OC2_SetConfig+0xec>)
 8006c34:	4293      	cmp	r3, r2
 8006c36:	d10d      	bne.n	8006c54 <TIM_OC2_SetConfig+0x84>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC2NP;
 8006c38:	697b      	ldr	r3, [r7, #20]
 8006c3a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8006c3e:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 8006c40:	683b      	ldr	r3, [r7, #0]
 8006c42:	68db      	ldr	r3, [r3, #12]
 8006c44:	011b      	lsls	r3, r3, #4
 8006c46:	697a      	ldr	r2, [r7, #20]
 8006c48:	4313      	orrs	r3, r2
 8006c4a:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC2NE;
 8006c4c:	697b      	ldr	r3, [r7, #20]
 8006c4e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8006c52:	617b      	str	r3, [r7, #20]

  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006c54:	687b      	ldr	r3, [r7, #4]
 8006c56:	4a18      	ldr	r2, [pc, #96]	; (8006cb8 <TIM_OC2_SetConfig+0xe8>)
 8006c58:	4293      	cmp	r3, r2
 8006c5a:	d003      	beq.n	8006c64 <TIM_OC2_SetConfig+0x94>
 8006c5c:	687b      	ldr	r3, [r7, #4]
 8006c5e:	4a17      	ldr	r2, [pc, #92]	; (8006cbc <TIM_OC2_SetConfig+0xec>)
 8006c60:	4293      	cmp	r3, r2
 8006c62:	d113      	bne.n	8006c8c <TIM_OC2_SetConfig+0xbc>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS2;
 8006c64:	693b      	ldr	r3, [r7, #16]
 8006c66:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8006c6a:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS2N;
 8006c6c:	693b      	ldr	r3, [r7, #16]
 8006c6e:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8006c72:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 2U);
 8006c74:	683b      	ldr	r3, [r7, #0]
 8006c76:	695b      	ldr	r3, [r3, #20]
 8006c78:	009b      	lsls	r3, r3, #2
 8006c7a:	693a      	ldr	r2, [r7, #16]
 8006c7c:	4313      	orrs	r3, r2
 8006c7e:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 8006c80:	683b      	ldr	r3, [r7, #0]
 8006c82:	699b      	ldr	r3, [r3, #24]
 8006c84:	009b      	lsls	r3, r3, #2
 8006c86:	693a      	ldr	r2, [r7, #16]
 8006c88:	4313      	orrs	r3, r2
 8006c8a:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8006c8c:	687b      	ldr	r3, [r7, #4]
 8006c8e:	693a      	ldr	r2, [r7, #16]
 8006c90:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 8006c92:	687b      	ldr	r3, [r7, #4]
 8006c94:	68fa      	ldr	r2, [r7, #12]
 8006c96:	619a      	str	r2, [r3, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR2 = OC_Config->Pulse;
 8006c98:	683b      	ldr	r3, [r7, #0]
 8006c9a:	685a      	ldr	r2, [r3, #4]
 8006c9c:	687b      	ldr	r3, [r7, #4]
 8006c9e:	639a      	str	r2, [r3, #56]	; 0x38

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006ca0:	687b      	ldr	r3, [r7, #4]
 8006ca2:	697a      	ldr	r2, [r7, #20]
 8006ca4:	621a      	str	r2, [r3, #32]
}
 8006ca6:	bf00      	nop
 8006ca8:	371c      	adds	r7, #28
 8006caa:	46bd      	mov	sp, r7
 8006cac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006cb0:	4770      	bx	lr
 8006cb2:	bf00      	nop
 8006cb4:	feff8fff 	.word	0xfeff8fff
 8006cb8:	40010000 	.word	0x40010000
 8006cbc:	40010400 	.word	0x40010400

08006cc0 <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8006cc0:	b480      	push	{r7}
 8006cc2:	b087      	sub	sp, #28
 8006cc4:	af00      	add	r7, sp, #0
 8006cc6:	6078      	str	r0, [r7, #4]
 8006cc8:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 8006cca:	687b      	ldr	r3, [r7, #4]
 8006ccc:	6a1b      	ldr	r3, [r3, #32]
 8006cce:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 8006cd2:	687b      	ldr	r3, [r7, #4]
 8006cd4:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006cd6:	687b      	ldr	r3, [r7, #4]
 8006cd8:	6a1b      	ldr	r3, [r3, #32]
 8006cda:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006cdc:	687b      	ldr	r3, [r7, #4]
 8006cde:	685b      	ldr	r3, [r3, #4]
 8006ce0:	613b      	str	r3, [r7, #16]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8006ce2:	687b      	ldr	r3, [r7, #4]
 8006ce4:	69db      	ldr	r3, [r3, #28]
 8006ce6:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC3M;
 8006ce8:	68fa      	ldr	r2, [r7, #12]
 8006cea:	4b2d      	ldr	r3, [pc, #180]	; (8006da0 <TIM_OC3_SetConfig+0xe0>)
 8006cec:	4013      	ands	r3, r2
 8006cee:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 8006cf0:	68fb      	ldr	r3, [r7, #12]
 8006cf2:	f023 0303 	bic.w	r3, r3, #3
 8006cf6:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8006cf8:	683b      	ldr	r3, [r7, #0]
 8006cfa:	681b      	ldr	r3, [r3, #0]
 8006cfc:	68fa      	ldr	r2, [r7, #12]
 8006cfe:	4313      	orrs	r3, r2
 8006d00:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
 8006d02:	697b      	ldr	r3, [r7, #20]
 8006d04:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8006d08:	617b      	str	r3, [r7, #20]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);
 8006d0a:	683b      	ldr	r3, [r7, #0]
 8006d0c:	689b      	ldr	r3, [r3, #8]
 8006d0e:	021b      	lsls	r3, r3, #8
 8006d10:	697a      	ldr	r2, [r7, #20]
 8006d12:	4313      	orrs	r3, r2
 8006d14:	617b      	str	r3, [r7, #20]

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 8006d16:	687b      	ldr	r3, [r7, #4]
 8006d18:	4a22      	ldr	r2, [pc, #136]	; (8006da4 <TIM_OC3_SetConfig+0xe4>)
 8006d1a:	4293      	cmp	r3, r2
 8006d1c:	d003      	beq.n	8006d26 <TIM_OC3_SetConfig+0x66>
 8006d1e:	687b      	ldr	r3, [r7, #4]
 8006d20:	4a21      	ldr	r2, [pc, #132]	; (8006da8 <TIM_OC3_SetConfig+0xe8>)
 8006d22:	4293      	cmp	r3, r2
 8006d24:	d10d      	bne.n	8006d42 <TIM_OC3_SetConfig+0x82>
  {
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));

    /* Reset the Output N Polarity level */
    tmpccer &= ~TIM_CCER_CC3NP;
 8006d26:	697b      	ldr	r3, [r7, #20]
 8006d28:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8006d2c:	617b      	str	r3, [r7, #20]
    /* Set the Output N Polarity */
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 8006d2e:	683b      	ldr	r3, [r7, #0]
 8006d30:	68db      	ldr	r3, [r3, #12]
 8006d32:	021b      	lsls	r3, r3, #8
 8006d34:	697a      	ldr	r2, [r7, #20]
 8006d36:	4313      	orrs	r3, r2
 8006d38:	617b      	str	r3, [r7, #20]
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
 8006d3a:	697b      	ldr	r3, [r7, #20]
 8006d3c:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8006d40:	617b      	str	r3, [r7, #20]
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006d42:	687b      	ldr	r3, [r7, #4]
 8006d44:	4a17      	ldr	r2, [pc, #92]	; (8006da4 <TIM_OC3_SetConfig+0xe4>)
 8006d46:	4293      	cmp	r3, r2
 8006d48:	d003      	beq.n	8006d52 <TIM_OC3_SetConfig+0x92>
 8006d4a:	687b      	ldr	r3, [r7, #4]
 8006d4c:	4a16      	ldr	r2, [pc, #88]	; (8006da8 <TIM_OC3_SetConfig+0xe8>)
 8006d4e:	4293      	cmp	r3, r2
 8006d50:	d113      	bne.n	8006d7a <TIM_OC3_SetConfig+0xba>
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
 8006d52:	693b      	ldr	r3, [r7, #16]
 8006d54:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8006d58:	613b      	str	r3, [r7, #16]
    tmpcr2 &= ~TIM_CR2_OIS3N;
 8006d5a:	693b      	ldr	r3, [r7, #16]
 8006d5c:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8006d60:	613b      	str	r3, [r7, #16]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
 8006d62:	683b      	ldr	r3, [r7, #0]
 8006d64:	695b      	ldr	r3, [r3, #20]
 8006d66:	011b      	lsls	r3, r3, #4
 8006d68:	693a      	ldr	r2, [r7, #16]
 8006d6a:	4313      	orrs	r3, r2
 8006d6c:	613b      	str	r3, [r7, #16]
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 8006d6e:	683b      	ldr	r3, [r7, #0]
 8006d70:	699b      	ldr	r3, [r3, #24]
 8006d72:	011b      	lsls	r3, r3, #4
 8006d74:	693a      	ldr	r2, [r7, #16]
 8006d76:	4313      	orrs	r3, r2
 8006d78:	613b      	str	r3, [r7, #16]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8006d7a:	687b      	ldr	r3, [r7, #4]
 8006d7c:	693a      	ldr	r2, [r7, #16]
 8006d7e:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8006d80:	687b      	ldr	r3, [r7, #4]
 8006d82:	68fa      	ldr	r2, [r7, #12]
 8006d84:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 8006d86:	683b      	ldr	r3, [r7, #0]
 8006d88:	685a      	ldr	r2, [r3, #4]
 8006d8a:	687b      	ldr	r3, [r7, #4]
 8006d8c:	63da      	str	r2, [r3, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006d8e:	687b      	ldr	r3, [r7, #4]
 8006d90:	697a      	ldr	r2, [r7, #20]
 8006d92:	621a      	str	r2, [r3, #32]
}
 8006d94:	bf00      	nop
 8006d96:	371c      	adds	r7, #28
 8006d98:	46bd      	mov	sp, r7
 8006d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d9e:	4770      	bx	lr
 8006da0:	fffeff8f 	.word	0xfffeff8f
 8006da4:	40010000 	.word	0x40010000
 8006da8:	40010400 	.word	0x40010400

08006dac <TIM_OC4_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 8006dac:	b480      	push	{r7}
 8006dae:	b087      	sub	sp, #28
 8006db0:	af00      	add	r7, sp, #0
 8006db2:	6078      	str	r0, [r7, #4]
 8006db4:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 4: Reset the CC4E Bit */
  TIMx->CCER &= ~TIM_CCER_CC4E;
 8006db6:	687b      	ldr	r3, [r7, #4]
 8006db8:	6a1b      	ldr	r3, [r3, #32]
 8006dba:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 8006dbe:	687b      	ldr	r3, [r7, #4]
 8006dc0:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006dc2:	687b      	ldr	r3, [r7, #4]
 8006dc4:	6a1b      	ldr	r3, [r3, #32]
 8006dc6:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006dc8:	687b      	ldr	r3, [r7, #4]
 8006dca:	685b      	ldr	r3, [r3, #4]
 8006dcc:	617b      	str	r3, [r7, #20]

  /* Get the TIMx CCMR2 register value */
  tmpccmrx = TIMx->CCMR2;
 8006dce:	687b      	ldr	r3, [r7, #4]
 8006dd0:	69db      	ldr	r3, [r3, #28]
 8006dd2:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare mode and Capture/Compare selection Bits */
  tmpccmrx &= ~TIM_CCMR2_OC4M;
 8006dd4:	68fa      	ldr	r2, [r7, #12]
 8006dd6:	4b1e      	ldr	r3, [pc, #120]	; (8006e50 <TIM_OC4_SetConfig+0xa4>)
 8006dd8:	4013      	ands	r3, r2
 8006dda:	60fb      	str	r3, [r7, #12]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 8006ddc:	68fb      	ldr	r3, [r7, #12]
 8006dde:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8006de2:	60fb      	str	r3, [r7, #12]

  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8006de4:	683b      	ldr	r3, [r7, #0]
 8006de6:	681b      	ldr	r3, [r3, #0]
 8006de8:	021b      	lsls	r3, r3, #8
 8006dea:	68fa      	ldr	r2, [r7, #12]
 8006dec:	4313      	orrs	r3, r2
 8006dee:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC4P;
 8006df0:	693b      	ldr	r3, [r7, #16]
 8006df2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8006df6:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 12U);
 8006df8:	683b      	ldr	r3, [r7, #0]
 8006dfa:	689b      	ldr	r3, [r3, #8]
 8006dfc:	031b      	lsls	r3, r3, #12
 8006dfe:	693a      	ldr	r2, [r7, #16]
 8006e00:	4313      	orrs	r3, r2
 8006e02:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006e04:	687b      	ldr	r3, [r7, #4]
 8006e06:	4a13      	ldr	r2, [pc, #76]	; (8006e54 <TIM_OC4_SetConfig+0xa8>)
 8006e08:	4293      	cmp	r3, r2
 8006e0a:	d003      	beq.n	8006e14 <TIM_OC4_SetConfig+0x68>
 8006e0c:	687b      	ldr	r3, [r7, #4]
 8006e0e:	4a12      	ldr	r2, [pc, #72]	; (8006e58 <TIM_OC4_SetConfig+0xac>)
 8006e10:	4293      	cmp	r3, r2
 8006e12:	d109      	bne.n	8006e28 <TIM_OC4_SetConfig+0x7c>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));

    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS4;
 8006e14:	697b      	ldr	r3, [r7, #20]
 8006e16:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8006e1a:	617b      	str	r3, [r7, #20]

    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 8006e1c:	683b      	ldr	r3, [r7, #0]
 8006e1e:	695b      	ldr	r3, [r3, #20]
 8006e20:	019b      	lsls	r3, r3, #6
 8006e22:	697a      	ldr	r2, [r7, #20]
 8006e24:	4313      	orrs	r3, r2
 8006e26:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8006e28:	687b      	ldr	r3, [r7, #4]
 8006e2a:	697a      	ldr	r2, [r7, #20]
 8006e2c:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 8006e2e:	687b      	ldr	r3, [r7, #4]
 8006e30:	68fa      	ldr	r2, [r7, #12]
 8006e32:	61da      	str	r2, [r3, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR4 = OC_Config->Pulse;
 8006e34:	683b      	ldr	r3, [r7, #0]
 8006e36:	685a      	ldr	r2, [r3, #4]
 8006e38:	687b      	ldr	r3, [r7, #4]
 8006e3a:	641a      	str	r2, [r3, #64]	; 0x40

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006e3c:	687b      	ldr	r3, [r7, #4]
 8006e3e:	693a      	ldr	r2, [r7, #16]
 8006e40:	621a      	str	r2, [r3, #32]
}
 8006e42:	bf00      	nop
 8006e44:	371c      	adds	r7, #28
 8006e46:	46bd      	mov	sp, r7
 8006e48:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e4c:	4770      	bx	lr
 8006e4e:	bf00      	nop
 8006e50:	feff8fff 	.word	0xfeff8fff
 8006e54:	40010000 	.word	0x40010000
 8006e58:	40010400 	.word	0x40010400

08006e5c <TIM_OC5_SetConfig>:
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC5_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8006e5c:	b480      	push	{r7}
 8006e5e:	b087      	sub	sp, #28
 8006e60:	af00      	add	r7, sp, #0
 8006e62:	6078      	str	r0, [r7, #4]
 8006e64:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC5E;
 8006e66:	687b      	ldr	r3, [r7, #4]
 8006e68:	6a1b      	ldr	r3, [r3, #32]
 8006e6a:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8006e6e:	687b      	ldr	r3, [r7, #4]
 8006e70:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006e72:	687b      	ldr	r3, [r7, #4]
 8006e74:	6a1b      	ldr	r3, [r3, #32]
 8006e76:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006e78:	687b      	ldr	r3, [r7, #4]
 8006e7a:	685b      	ldr	r3, [r3, #4]
 8006e7c:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8006e7e:	687b      	ldr	r3, [r7, #4]
 8006e80:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006e82:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 8006e84:	68fa      	ldr	r2, [r7, #12]
 8006e86:	4b1b      	ldr	r3, [pc, #108]	; (8006ef4 <TIM_OC5_SetConfig+0x98>)
 8006e88:	4013      	ands	r3, r2
 8006e8a:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= OC_Config->OCMode;
 8006e8c:	683b      	ldr	r3, [r7, #0]
 8006e8e:	681b      	ldr	r3, [r3, #0]
 8006e90:	68fa      	ldr	r2, [r7, #12]
 8006e92:	4313      	orrs	r3, r2
 8006e94:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC5P;
 8006e96:	693b      	ldr	r3, [r7, #16]
 8006e98:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8006e9c:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 16U);
 8006e9e:	683b      	ldr	r3, [r7, #0]
 8006ea0:	689b      	ldr	r3, [r3, #8]
 8006ea2:	041b      	lsls	r3, r3, #16
 8006ea4:	693a      	ldr	r2, [r7, #16]
 8006ea6:	4313      	orrs	r3, r2
 8006ea8:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006eaa:	687b      	ldr	r3, [r7, #4]
 8006eac:	4a12      	ldr	r2, [pc, #72]	; (8006ef8 <TIM_OC5_SetConfig+0x9c>)
 8006eae:	4293      	cmp	r3, r2
 8006eb0:	d003      	beq.n	8006eba <TIM_OC5_SetConfig+0x5e>
 8006eb2:	687b      	ldr	r3, [r7, #4]
 8006eb4:	4a11      	ldr	r2, [pc, #68]	; (8006efc <TIM_OC5_SetConfig+0xa0>)
 8006eb6:	4293      	cmp	r3, r2
 8006eb8:	d109      	bne.n	8006ece <TIM_OC5_SetConfig+0x72>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS5;
 8006eba:	697b      	ldr	r3, [r7, #20]
 8006ebc:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8006ec0:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 8006ec2:	683b      	ldr	r3, [r7, #0]
 8006ec4:	695b      	ldr	r3, [r3, #20]
 8006ec6:	021b      	lsls	r3, r3, #8
 8006ec8:	697a      	ldr	r2, [r7, #20]
 8006eca:	4313      	orrs	r3, r2
 8006ecc:	617b      	str	r3, [r7, #20]
  }
  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8006ece:	687b      	ldr	r3, [r7, #4]
 8006ed0:	697a      	ldr	r2, [r7, #20]
 8006ed2:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8006ed4:	687b      	ldr	r3, [r7, #4]
 8006ed6:	68fa      	ldr	r2, [r7, #12]
 8006ed8:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR5 = OC_Config->Pulse;
 8006eda:	683b      	ldr	r3, [r7, #0]
 8006edc:	685a      	ldr	r2, [r3, #4]
 8006ede:	687b      	ldr	r3, [r7, #4]
 8006ee0:	659a      	str	r2, [r3, #88]	; 0x58

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006ee2:	687b      	ldr	r3, [r7, #4]
 8006ee4:	693a      	ldr	r2, [r7, #16]
 8006ee6:	621a      	str	r2, [r3, #32]
}
 8006ee8:	bf00      	nop
 8006eea:	371c      	adds	r7, #28
 8006eec:	46bd      	mov	sp, r7
 8006eee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006ef2:	4770      	bx	lr
 8006ef4:	fffeff8f 	.word	0xfffeff8f
 8006ef8:	40010000 	.word	0x40010000
 8006efc:	40010400 	.word	0x40010400

08006f00 <TIM_OC6_SetConfig>:
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC6_SetConfig(TIM_TypeDef *TIMx,
                              TIM_OC_InitTypeDef *OC_Config)
{
 8006f00:	b480      	push	{r7}
 8006f02:	b087      	sub	sp, #28
 8006f04:	af00      	add	r7, sp, #0
 8006f06:	6078      	str	r0, [r7, #4]
 8006f08:	6039      	str	r1, [r7, #0]
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the output: Reset the CCxE Bit */
  TIMx->CCER &= ~TIM_CCER_CC6E;
 8006f0a:	687b      	ldr	r3, [r7, #4]
 8006f0c:	6a1b      	ldr	r3, [r3, #32]
 8006f0e:	f423 1280 	bic.w	r2, r3, #1048576	; 0x100000
 8006f12:	687b      	ldr	r3, [r7, #4]
 8006f14:	621a      	str	r2, [r3, #32]

  /* Get the TIMx CCER register value */
  tmpccer = TIMx->CCER;
 8006f16:	687b      	ldr	r3, [r7, #4]
 8006f18:	6a1b      	ldr	r3, [r3, #32]
 8006f1a:	613b      	str	r3, [r7, #16]
  /* Get the TIMx CR2 register value */
  tmpcr2 =  TIMx->CR2;
 8006f1c:	687b      	ldr	r3, [r7, #4]
 8006f1e:	685b      	ldr	r3, [r3, #4]
 8006f20:	617b      	str	r3, [r7, #20]
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR3;
 8006f22:	687b      	ldr	r3, [r7, #4]
 8006f24:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8006f26:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 8006f28:	68fa      	ldr	r2, [r7, #12]
 8006f2a:	4b1c      	ldr	r3, [pc, #112]	; (8006f9c <TIM_OC6_SetConfig+0x9c>)
 8006f2c:	4013      	ands	r3, r2
 8006f2e:	60fb      	str	r3, [r7, #12]
  /* Select the Output Compare Mode */
  tmpccmrx |= (OC_Config->OCMode << 8U);
 8006f30:	683b      	ldr	r3, [r7, #0]
 8006f32:	681b      	ldr	r3, [r3, #0]
 8006f34:	021b      	lsls	r3, r3, #8
 8006f36:	68fa      	ldr	r2, [r7, #12]
 8006f38:	4313      	orrs	r3, r2
 8006f3a:	60fb      	str	r3, [r7, #12]

  /* Reset the Output Polarity level */
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 8006f3c:	693b      	ldr	r3, [r7, #16]
 8006f3e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8006f42:	613b      	str	r3, [r7, #16]
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 20U);
 8006f44:	683b      	ldr	r3, [r7, #0]
 8006f46:	689b      	ldr	r3, [r3, #8]
 8006f48:	051b      	lsls	r3, r3, #20
 8006f4a:	693a      	ldr	r2, [r7, #16]
 8006f4c:	4313      	orrs	r3, r2
 8006f4e:	613b      	str	r3, [r7, #16]

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 8006f50:	687b      	ldr	r3, [r7, #4]
 8006f52:	4a13      	ldr	r2, [pc, #76]	; (8006fa0 <TIM_OC6_SetConfig+0xa0>)
 8006f54:	4293      	cmp	r3, r2
 8006f56:	d003      	beq.n	8006f60 <TIM_OC6_SetConfig+0x60>
 8006f58:	687b      	ldr	r3, [r7, #4]
 8006f5a:	4a12      	ldr	r2, [pc, #72]	; (8006fa4 <TIM_OC6_SetConfig+0xa4>)
 8006f5c:	4293      	cmp	r3, r2
 8006f5e:	d109      	bne.n	8006f74 <TIM_OC6_SetConfig+0x74>
  {
    /* Reset the Output Compare IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS6;
 8006f60:	697b      	ldr	r3, [r7, #20]
 8006f62:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8006f66:	617b      	str	r3, [r7, #20]
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 8006f68:	683b      	ldr	r3, [r7, #0]
 8006f6a:	695b      	ldr	r3, [r3, #20]
 8006f6c:	029b      	lsls	r3, r3, #10
 8006f6e:	697a      	ldr	r2, [r7, #20]
 8006f70:	4313      	orrs	r3, r2
 8006f72:	617b      	str	r3, [r7, #20]
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 8006f74:	687b      	ldr	r3, [r7, #4]
 8006f76:	697a      	ldr	r2, [r7, #20]
 8006f78:	605a      	str	r2, [r3, #4]

  /* Write to TIMx CCMR3 */
  TIMx->CCMR3 = tmpccmrx;
 8006f7a:	687b      	ldr	r3, [r7, #4]
 8006f7c:	68fa      	ldr	r2, [r7, #12]
 8006f7e:	655a      	str	r2, [r3, #84]	; 0x54

  /* Set the Capture Compare Register value */
  TIMx->CCR6 = OC_Config->Pulse;
 8006f80:	683b      	ldr	r3, [r7, #0]
 8006f82:	685a      	ldr	r2, [r3, #4]
 8006f84:	687b      	ldr	r3, [r7, #4]
 8006f86:	65da      	str	r2, [r3, #92]	; 0x5c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 8006f88:	687b      	ldr	r3, [r7, #4]
 8006f8a:	693a      	ldr	r2, [r7, #16]
 8006f8c:	621a      	str	r2, [r3, #32]
}
 8006f8e:	bf00      	nop
 8006f90:	371c      	adds	r7, #28
 8006f92:	46bd      	mov	sp, r7
 8006f94:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006f98:	4770      	bx	lr
 8006f9a:	bf00      	nop
 8006f9c:	feff8fff 	.word	0xfeff8fff
 8006fa0:	40010000 	.word	0x40010000
 8006fa4:	40010400 	.word	0x40010400

08006fa8 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8006fa8:	b480      	push	{r7}
 8006faa:	b087      	sub	sp, #28
 8006fac:	af00      	add	r7, sp, #0
 8006fae:	60f8      	str	r0, [r7, #12]
 8006fb0:	60b9      	str	r1, [r7, #8]
 8006fb2:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8006fb4:	68fb      	ldr	r3, [r7, #12]
 8006fb6:	6a1b      	ldr	r3, [r3, #32]
 8006fb8:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8006fba:	68fb      	ldr	r3, [r7, #12]
 8006fbc:	6a1b      	ldr	r3, [r3, #32]
 8006fbe:	f023 0201 	bic.w	r2, r3, #1
 8006fc2:	68fb      	ldr	r3, [r7, #12]
 8006fc4:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8006fc6:	68fb      	ldr	r3, [r7, #12]
 8006fc8:	699b      	ldr	r3, [r3, #24]
 8006fca:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8006fcc:	693b      	ldr	r3, [r7, #16]
 8006fce:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8006fd2:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8006fd4:	687b      	ldr	r3, [r7, #4]
 8006fd6:	011b      	lsls	r3, r3, #4
 8006fd8:	693a      	ldr	r2, [r7, #16]
 8006fda:	4313      	orrs	r3, r2
 8006fdc:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8006fde:	697b      	ldr	r3, [r7, #20]
 8006fe0:	f023 030a 	bic.w	r3, r3, #10
 8006fe4:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 8006fe6:	697a      	ldr	r2, [r7, #20]
 8006fe8:	68bb      	ldr	r3, [r7, #8]
 8006fea:	4313      	orrs	r3, r2
 8006fec:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8006fee:	68fb      	ldr	r3, [r7, #12]
 8006ff0:	693a      	ldr	r2, [r7, #16]
 8006ff2:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8006ff4:	68fb      	ldr	r3, [r7, #12]
 8006ff6:	697a      	ldr	r2, [r7, #20]
 8006ff8:	621a      	str	r2, [r3, #32]
}
 8006ffa:	bf00      	nop
 8006ffc:	371c      	adds	r7, #28
 8006ffe:	46bd      	mov	sp, r7
 8007000:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007004:	4770      	bx	lr

08007006 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8007006:	b480      	push	{r7}
 8007008:	b087      	sub	sp, #28
 800700a:	af00      	add	r7, sp, #0
 800700c:	60f8      	str	r0, [r7, #12]
 800700e:	60b9      	str	r1, [r7, #8]
 8007010:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8007012:	68fb      	ldr	r3, [r7, #12]
 8007014:	6a1b      	ldr	r3, [r3, #32]
 8007016:	f023 0210 	bic.w	r2, r3, #16
 800701a:	68fb      	ldr	r3, [r7, #12]
 800701c:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 800701e:	68fb      	ldr	r3, [r7, #12]
 8007020:	699b      	ldr	r3, [r3, #24]
 8007022:	617b      	str	r3, [r7, #20]
  tmpccer = TIMx->CCER;
 8007024:	68fb      	ldr	r3, [r7, #12]
 8007026:	6a1b      	ldr	r3, [r3, #32]
 8007028:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800702a:	697b      	ldr	r3, [r7, #20]
 800702c:	f423 4370 	bic.w	r3, r3, #61440	; 0xf000
 8007030:	617b      	str	r3, [r7, #20]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8007032:	687b      	ldr	r3, [r7, #4]
 8007034:	031b      	lsls	r3, r3, #12
 8007036:	697a      	ldr	r2, [r7, #20]
 8007038:	4313      	orrs	r3, r2
 800703a:	617b      	str	r3, [r7, #20]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800703c:	693b      	ldr	r3, [r7, #16]
 800703e:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8007042:	613b      	str	r3, [r7, #16]
  tmpccer |= (TIM_ICPolarity << 4U);
 8007044:	68bb      	ldr	r3, [r7, #8]
 8007046:	011b      	lsls	r3, r3, #4
 8007048:	693a      	ldr	r2, [r7, #16]
 800704a:	4313      	orrs	r3, r2
 800704c:	613b      	str	r3, [r7, #16]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 800704e:	68fb      	ldr	r3, [r7, #12]
 8007050:	697a      	ldr	r2, [r7, #20]
 8007052:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8007054:	68fb      	ldr	r3, [r7, #12]
 8007056:	693a      	ldr	r2, [r7, #16]
 8007058:	621a      	str	r2, [r3, #32]
}
 800705a:	bf00      	nop
 800705c:	371c      	adds	r7, #28
 800705e:	46bd      	mov	sp, r7
 8007060:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007064:	4770      	bx	lr

08007066 <TIM_ITRx_SetConfig>:
  *            @arg TIM_TS_TI2FP2: Filtered Timer Input 2
  *            @arg TIM_TS_ETRF: External Trigger input
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 8007066:	b480      	push	{r7}
 8007068:	b085      	sub	sp, #20
 800706a:	af00      	add	r7, sp, #0
 800706c:	6078      	str	r0, [r7, #4]
 800706e:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8007070:	687b      	ldr	r3, [r7, #4]
 8007072:	689b      	ldr	r3, [r3, #8]
 8007074:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8007076:	68fb      	ldr	r3, [r7, #12]
 8007078:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800707c:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800707e:	683a      	ldr	r2, [r7, #0]
 8007080:	68fb      	ldr	r3, [r7, #12]
 8007082:	4313      	orrs	r3, r2
 8007084:	f043 0307 	orr.w	r3, r3, #7
 8007088:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 800708a:	687b      	ldr	r3, [r7, #4]
 800708c:	68fa      	ldr	r2, [r7, #12]
 800708e:	609a      	str	r2, [r3, #8]
}
 8007090:	bf00      	nop
 8007092:	3714      	adds	r7, #20
 8007094:	46bd      	mov	sp, r7
 8007096:	f85d 7b04 	ldr.w	r7, [sp], #4
 800709a:	4770      	bx	lr

0800709c <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 800709c:	b480      	push	{r7}
 800709e:	b087      	sub	sp, #28
 80070a0:	af00      	add	r7, sp, #0
 80070a2:	60f8      	str	r0, [r7, #12]
 80070a4:	60b9      	str	r1, [r7, #8]
 80070a6:	607a      	str	r2, [r7, #4]
 80070a8:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 80070aa:	68fb      	ldr	r3, [r7, #12]
 80070ac:	689b      	ldr	r3, [r3, #8]
 80070ae:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 80070b0:	697b      	ldr	r3, [r7, #20]
 80070b2:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80070b6:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 80070b8:	683b      	ldr	r3, [r7, #0]
 80070ba:	021a      	lsls	r2, r3, #8
 80070bc:	687b      	ldr	r3, [r7, #4]
 80070be:	431a      	orrs	r2, r3
 80070c0:	68bb      	ldr	r3, [r7, #8]
 80070c2:	4313      	orrs	r3, r2
 80070c4:	697a      	ldr	r2, [r7, #20]
 80070c6:	4313      	orrs	r3, r2
 80070c8:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 80070ca:	68fb      	ldr	r3, [r7, #12]
 80070cc:	697a      	ldr	r2, [r7, #20]
 80070ce:	609a      	str	r2, [r3, #8]
}
 80070d0:	bf00      	nop
 80070d2:	371c      	adds	r7, #28
 80070d4:	46bd      	mov	sp, r7
 80070d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80070da:	4770      	bx	lr

080070dc <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 80070dc:	b480      	push	{r7}
 80070de:	b085      	sub	sp, #20
 80070e0:	af00      	add	r7, sp, #0
 80070e2:	6078      	str	r0, [r7, #4]
 80070e4:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_SYNCHRO_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 80070e6:	687b      	ldr	r3, [r7, #4]
 80070e8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80070ec:	2b01      	cmp	r3, #1
 80070ee:	d101      	bne.n	80070f4 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 80070f0:	2302      	movs	r3, #2
 80070f2:	e045      	b.n	8007180 <HAL_TIMEx_MasterConfigSynchronization+0xa4>
 80070f4:	687b      	ldr	r3, [r7, #4]
 80070f6:	2201      	movs	r2, #1
 80070f8:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 80070fc:	687b      	ldr	r3, [r7, #4]
 80070fe:	2202      	movs	r2, #2
 8007100:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8007104:	687b      	ldr	r3, [r7, #4]
 8007106:	681b      	ldr	r3, [r3, #0]
 8007108:	685b      	ldr	r3, [r3, #4]
 800710a:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 800710c:	687b      	ldr	r3, [r7, #4]
 800710e:	681b      	ldr	r3, [r3, #0]
 8007110:	689b      	ldr	r3, [r3, #8]
 8007112:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8007114:	687b      	ldr	r3, [r7, #4]
 8007116:	681b      	ldr	r3, [r3, #0]
 8007118:	4a1c      	ldr	r2, [pc, #112]	; (800718c <HAL_TIMEx_MasterConfigSynchronization+0xb0>)
 800711a:	4293      	cmp	r3, r2
 800711c:	d004      	beq.n	8007128 <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 800711e:	687b      	ldr	r3, [r7, #4]
 8007120:	681b      	ldr	r3, [r3, #0]
 8007122:	4a1b      	ldr	r2, [pc, #108]	; (8007190 <HAL_TIMEx_MasterConfigSynchronization+0xb4>)
 8007124:	4293      	cmp	r3, r2
 8007126:	d108      	bne.n	800713a <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8007128:	68fb      	ldr	r3, [r7, #12]
 800712a:	f423 0370 	bic.w	r3, r3, #15728640	; 0xf00000
 800712e:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8007130:	683b      	ldr	r3, [r7, #0]
 8007132:	685b      	ldr	r3, [r3, #4]
 8007134:	68fa      	ldr	r2, [r7, #12]
 8007136:	4313      	orrs	r3, r2
 8007138:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 800713a:	68fb      	ldr	r3, [r7, #12]
 800713c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8007140:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8007142:	683b      	ldr	r3, [r7, #0]
 8007144:	681b      	ldr	r3, [r3, #0]
 8007146:	68fa      	ldr	r2, [r7, #12]
 8007148:	4313      	orrs	r3, r2
 800714a:	60fb      	str	r3, [r7, #12]

  /* Reset the MSM Bit */
  tmpsmcr &= ~TIM_SMCR_MSM;
 800714c:	68bb      	ldr	r3, [r7, #8]
 800714e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8007152:	60bb      	str	r3, [r7, #8]
  /* Set master mode */
  tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8007154:	683b      	ldr	r3, [r7, #0]
 8007156:	689b      	ldr	r3, [r3, #8]
 8007158:	68ba      	ldr	r2, [r7, #8]
 800715a:	4313      	orrs	r3, r2
 800715c:	60bb      	str	r3, [r7, #8]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 800715e:	687b      	ldr	r3, [r7, #4]
 8007160:	681b      	ldr	r3, [r3, #0]
 8007162:	68fa      	ldr	r2, [r7, #12]
 8007164:	605a      	str	r2, [r3, #4]

  /* Update TIMx SMCR */
  htim->Instance->SMCR = tmpsmcr;
 8007166:	687b      	ldr	r3, [r7, #4]
 8007168:	681b      	ldr	r3, [r3, #0]
 800716a:	68ba      	ldr	r2, [r7, #8]
 800716c:	609a      	str	r2, [r3, #8]

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 800716e:	687b      	ldr	r3, [r7, #4]
 8007170:	2201      	movs	r2, #1
 8007172:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

  __HAL_UNLOCK(htim);
 8007176:	687b      	ldr	r3, [r7, #4]
 8007178:	2200      	movs	r2, #0
 800717a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800717e:	2300      	movs	r3, #0
}
 8007180:	4618      	mov	r0, r3
 8007182:	3714      	adds	r7, #20
 8007184:	46bd      	mov	sp, r7
 8007186:	f85d 7b04 	ldr.w	r7, [sp], #4
 800718a:	4770      	bx	lr
 800718c:	40010000 	.word	0x40010000
 8007190:	40010400 	.word	0x40010400

08007194 <HAL_TIMEx_ConfigBreakDeadTime>:
  *         contains the BDTR Register configuration  information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_ConfigBreakDeadTime(TIM_HandleTypeDef *htim,
                                                TIM_BreakDeadTimeConfigTypeDef *sBreakDeadTimeConfig)
{
 8007194:	b480      	push	{r7}
 8007196:	b085      	sub	sp, #20
 8007198:	af00      	add	r7, sp, #0
 800719a:	6078      	str	r0, [r7, #4]
 800719c:	6039      	str	r1, [r7, #0]
  /* Keep this variable initialized to 0 as it is used to configure BDTR register */
  uint32_t tmpbdtr = 0U;
 800719e:	2300      	movs	r3, #0
 80071a0:	60fb      	str	r3, [r7, #12]
  assert_param(IS_TIM_BREAK_POLARITY(sBreakDeadTimeConfig->BreakPolarity));
  assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->BreakFilter));
  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(sBreakDeadTimeConfig->AutomaticOutput));

  /* Check input state */
  __HAL_LOCK(htim);
 80071a2:	687b      	ldr	r3, [r7, #4]
 80071a4:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 80071a8:	2b01      	cmp	r3, #1
 80071aa:	d101      	bne.n	80071b0 <HAL_TIMEx_ConfigBreakDeadTime+0x1c>
 80071ac:	2302      	movs	r3, #2
 80071ae:	e065      	b.n	800727c <HAL_TIMEx_ConfigBreakDeadTime+0xe8>
 80071b0:	687b      	ldr	r3, [r7, #4]
 80071b2:	2201      	movs	r2, #1
 80071b4:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
     the OSSI State, the dead time value and the Automatic Output Enable Bit */

  /* Set the BDTR bits */
  MODIFY_REG(tmpbdtr, TIM_BDTR_DTG, sBreakDeadTimeConfig->DeadTime);
 80071b8:	68fb      	ldr	r3, [r7, #12]
 80071ba:	f023 02ff 	bic.w	r2, r3, #255	; 0xff
 80071be:	683b      	ldr	r3, [r7, #0]
 80071c0:	68db      	ldr	r3, [r3, #12]
 80071c2:	4313      	orrs	r3, r2
 80071c4:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_LOCK, sBreakDeadTimeConfig->LockLevel);
 80071c6:	68fb      	ldr	r3, [r7, #12]
 80071c8:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 80071cc:	683b      	ldr	r3, [r7, #0]
 80071ce:	689b      	ldr	r3, [r3, #8]
 80071d0:	4313      	orrs	r3, r2
 80071d2:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSI, sBreakDeadTimeConfig->OffStateIDLEMode);
 80071d4:	68fb      	ldr	r3, [r7, #12]
 80071d6:	f423 6280 	bic.w	r2, r3, #1024	; 0x400
 80071da:	683b      	ldr	r3, [r7, #0]
 80071dc:	685b      	ldr	r3, [r3, #4]
 80071de:	4313      	orrs	r3, r2
 80071e0:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_OSSR, sBreakDeadTimeConfig->OffStateRunMode);
 80071e2:	68fb      	ldr	r3, [r7, #12]
 80071e4:	f423 6200 	bic.w	r2, r3, #2048	; 0x800
 80071e8:	683b      	ldr	r3, [r7, #0]
 80071ea:	681b      	ldr	r3, [r3, #0]
 80071ec:	4313      	orrs	r3, r2
 80071ee:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKE, sBreakDeadTimeConfig->BreakState);
 80071f0:	68fb      	ldr	r3, [r7, #12]
 80071f2:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
 80071f6:	683b      	ldr	r3, [r7, #0]
 80071f8:	691b      	ldr	r3, [r3, #16]
 80071fa:	4313      	orrs	r3, r2
 80071fc:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKP, sBreakDeadTimeConfig->BreakPolarity);
 80071fe:	68fb      	ldr	r3, [r7, #12]
 8007200:	f423 5200 	bic.w	r2, r3, #8192	; 0x2000
 8007204:	683b      	ldr	r3, [r7, #0]
 8007206:	695b      	ldr	r3, [r3, #20]
 8007208:	4313      	orrs	r3, r2
 800720a:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_AOE, sBreakDeadTimeConfig->AutomaticOutput);
 800720c:	68fb      	ldr	r3, [r7, #12]
 800720e:	f423 4280 	bic.w	r2, r3, #16384	; 0x4000
 8007212:	683b      	ldr	r3, [r7, #0]
 8007214:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8007216:	4313      	orrs	r3, r2
 8007218:	60fb      	str	r3, [r7, #12]
  MODIFY_REG(tmpbdtr, TIM_BDTR_BKF, (sBreakDeadTimeConfig->BreakFilter << TIM_BDTR_BKF_Pos));
 800721a:	68fb      	ldr	r3, [r7, #12]
 800721c:	f423 2270 	bic.w	r2, r3, #983040	; 0xf0000
 8007220:	683b      	ldr	r3, [r7, #0]
 8007222:	699b      	ldr	r3, [r3, #24]
 8007224:	041b      	lsls	r3, r3, #16
 8007226:	4313      	orrs	r3, r2
 8007228:	60fb      	str	r3, [r7, #12]

  if (IS_TIM_BKIN2_INSTANCE(htim->Instance))
 800722a:	687b      	ldr	r3, [r7, #4]
 800722c:	681b      	ldr	r3, [r3, #0]
 800722e:	4a16      	ldr	r2, [pc, #88]	; (8007288 <HAL_TIMEx_ConfigBreakDeadTime+0xf4>)
 8007230:	4293      	cmp	r3, r2
 8007232:	d004      	beq.n	800723e <HAL_TIMEx_ConfigBreakDeadTime+0xaa>
 8007234:	687b      	ldr	r3, [r7, #4]
 8007236:	681b      	ldr	r3, [r3, #0]
 8007238:	4a14      	ldr	r2, [pc, #80]	; (800728c <HAL_TIMEx_ConfigBreakDeadTime+0xf8>)
 800723a:	4293      	cmp	r3, r2
 800723c:	d115      	bne.n	800726a <HAL_TIMEx_ConfigBreakDeadTime+0xd6>
    assert_param(IS_TIM_BREAK2_STATE(sBreakDeadTimeConfig->Break2State));
    assert_param(IS_TIM_BREAK2_POLARITY(sBreakDeadTimeConfig->Break2Polarity));
    assert_param(IS_TIM_BREAK_FILTER(sBreakDeadTimeConfig->Break2Filter));

    /* Set the BREAK2 input related BDTR bits */
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2F, (sBreakDeadTimeConfig->Break2Filter << TIM_BDTR_BK2F_Pos));
 800723e:	68fb      	ldr	r3, [r7, #12]
 8007240:	f423 0270 	bic.w	r2, r3, #15728640	; 0xf00000
 8007244:	683b      	ldr	r3, [r7, #0]
 8007246:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007248:	051b      	lsls	r3, r3, #20
 800724a:	4313      	orrs	r3, r2
 800724c:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2E, sBreakDeadTimeConfig->Break2State);
 800724e:	68fb      	ldr	r3, [r7, #12]
 8007250:	f023 7280 	bic.w	r2, r3, #16777216	; 0x1000000
 8007254:	683b      	ldr	r3, [r7, #0]
 8007256:	69db      	ldr	r3, [r3, #28]
 8007258:	4313      	orrs	r3, r2
 800725a:	60fb      	str	r3, [r7, #12]
    MODIFY_REG(tmpbdtr, TIM_BDTR_BK2P, sBreakDeadTimeConfig->Break2Polarity);
 800725c:	68fb      	ldr	r3, [r7, #12]
 800725e:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 8007262:	683b      	ldr	r3, [r7, #0]
 8007264:	6a1b      	ldr	r3, [r3, #32]
 8007266:	4313      	orrs	r3, r2
 8007268:	60fb      	str	r3, [r7, #12]
  }

  /* Set TIMx_BDTR */
  htim->Instance->BDTR = tmpbdtr;
 800726a:	687b      	ldr	r3, [r7, #4]
 800726c:	681b      	ldr	r3, [r3, #0]
 800726e:	68fa      	ldr	r2, [r7, #12]
 8007270:	645a      	str	r2, [r3, #68]	; 0x44

  __HAL_UNLOCK(htim);
 8007272:	687b      	ldr	r3, [r7, #4]
 8007274:	2200      	movs	r2, #0
 8007276:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

  return HAL_OK;
 800727a:	2300      	movs	r3, #0
}
 800727c:	4618      	mov	r0, r3
 800727e:	3714      	adds	r7, #20
 8007280:	46bd      	mov	sp, r7
 8007282:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007286:	4770      	bx	lr
 8007288:	40010000 	.word	0x40010000
 800728c:	40010400 	.word	0x40010400

08007290 <HAL_TIMEx_CommutCallback>:
  * @brief  Hall commutation changed callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8007290:	b480      	push	{r7}
 8007292:	b083      	sub	sp, #12
 8007294:	af00      	add	r7, sp, #0
 8007296:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8007298:	bf00      	nop
 800729a:	370c      	adds	r7, #12
 800729c:	46bd      	mov	sp, r7
 800729e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072a2:	4770      	bx	lr

080072a4 <HAL_TIMEx_BreakCallback>:
  * @brief  Hall Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 80072a4:	b480      	push	{r7}
 80072a6:	b083      	sub	sp, #12
 80072a8:	af00      	add	r7, sp, #0
 80072aa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 80072ac:	bf00      	nop
 80072ae:	370c      	adds	r7, #12
 80072b0:	46bd      	mov	sp, r7
 80072b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072b6:	4770      	bx	lr

080072b8 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 80072b8:	b480      	push	{r7}
 80072ba:	b083      	sub	sp, #12
 80072bc:	af00      	add	r7, sp, #0
 80072be:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 80072c0:	bf00      	nop
 80072c2:	370c      	adds	r7, #12
 80072c4:	46bd      	mov	sp, r7
 80072c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80072ca:	4770      	bx	lr

080072cc <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 80072cc:	b580      	push	{r7, lr}
 80072ce:	b082      	sub	sp, #8
 80072d0:	af00      	add	r7, sp, #0
 80072d2:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
 80072d4:	687b      	ldr	r3, [r7, #4]
 80072d6:	2b00      	cmp	r3, #0
 80072d8:	d101      	bne.n	80072de <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
 80072da:	2301      	movs	r3, #1
 80072dc:	e040      	b.n	8007360 <HAL_UART_Init+0x94>
  {
    /* Check the parameters */
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
 80072de:	687b      	ldr	r3, [r7, #4]
 80072e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80072e2:	2b00      	cmp	r3, #0
 80072e4:	d106      	bne.n	80072f4 <HAL_UART_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 80072e6:	687b      	ldr	r3, [r7, #4]
 80072e8:	2200      	movs	r2, #0
 80072ea:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
 80072ee:	6878      	ldr	r0, [r7, #4]
 80072f0:	f002 fdde 	bl	8009eb0 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
 80072f4:	687b      	ldr	r3, [r7, #4]
 80072f6:	2224      	movs	r2, #36	; 0x24
 80072f8:	675a      	str	r2, [r3, #116]	; 0x74

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 80072fa:	687b      	ldr	r3, [r7, #4]
 80072fc:	681b      	ldr	r3, [r3, #0]
 80072fe:	681a      	ldr	r2, [r3, #0]
 8007300:	687b      	ldr	r3, [r7, #4]
 8007302:	681b      	ldr	r3, [r3, #0]
 8007304:	f022 0201 	bic.w	r2, r2, #1
 8007308:	601a      	str	r2, [r3, #0]

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
 800730a:	6878      	ldr	r0, [r7, #4]
 800730c:	f000 f82c 	bl	8007368 <UART_SetConfig>
 8007310:	4603      	mov	r3, r0
 8007312:	2b01      	cmp	r3, #1
 8007314:	d101      	bne.n	800731a <HAL_UART_Init+0x4e>
  {
    return HAL_ERROR;
 8007316:	2301      	movs	r3, #1
 8007318:	e022      	b.n	8007360 <HAL_UART_Init+0x94>
  }

  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 800731a:	687b      	ldr	r3, [r7, #4]
 800731c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800731e:	2b00      	cmp	r3, #0
 8007320:	d002      	beq.n	8007328 <HAL_UART_Init+0x5c>
  {
    UART_AdvFeatureConfig(huart);
 8007322:	6878      	ldr	r0, [r7, #4]
 8007324:	f000 fac4 	bl	80078b0 <UART_AdvFeatureConfig>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8007328:	687b      	ldr	r3, [r7, #4]
 800732a:	681b      	ldr	r3, [r3, #0]
 800732c:	685a      	ldr	r2, [r3, #4]
 800732e:	687b      	ldr	r3, [r7, #4]
 8007330:	681b      	ldr	r3, [r3, #0]
 8007332:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8007336:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8007338:	687b      	ldr	r3, [r7, #4]
 800733a:	681b      	ldr	r3, [r3, #0]
 800733c:	689a      	ldr	r2, [r3, #8]
 800733e:	687b      	ldr	r3, [r7, #4]
 8007340:	681b      	ldr	r3, [r3, #0]
 8007342:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8007346:	609a      	str	r2, [r3, #8]

  /* Enable the Peripheral */
  __HAL_UART_ENABLE(huart);
 8007348:	687b      	ldr	r3, [r7, #4]
 800734a:	681b      	ldr	r3, [r3, #0]
 800734c:	681a      	ldr	r2, [r3, #0]
 800734e:	687b      	ldr	r3, [r7, #4]
 8007350:	681b      	ldr	r3, [r3, #0]
 8007352:	f042 0201 	orr.w	r2, r2, #1
 8007356:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
 8007358:	6878      	ldr	r0, [r7, #4]
 800735a:	f000 fb4b 	bl	80079f4 <UART_CheckIdleState>
 800735e:	4603      	mov	r3, r0
}
 8007360:	4618      	mov	r0, r3
 8007362:	3708      	adds	r7, #8
 8007364:	46bd      	mov	sp, r7
 8007366:	bd80      	pop	{r7, pc}

08007368 <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
 8007368:	b580      	push	{r7, lr}
 800736a:	b088      	sub	sp, #32
 800736c:	af00      	add	r7, sp, #0
 800736e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv                   = 0x00000000U;
 8007370:	2300      	movs	r3, #0
 8007372:	61bb      	str	r3, [r7, #24]
  HAL_StatusTypeDef ret               = HAL_OK;
 8007374:	2300      	movs	r3, #0
 8007376:	75fb      	strb	r3, [r7, #23]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8007378:	687b      	ldr	r3, [r7, #4]
 800737a:	689a      	ldr	r2, [r3, #8]
 800737c:	687b      	ldr	r3, [r7, #4]
 800737e:	691b      	ldr	r3, [r3, #16]
 8007380:	431a      	orrs	r2, r3
 8007382:	687b      	ldr	r3, [r7, #4]
 8007384:	695b      	ldr	r3, [r3, #20]
 8007386:	431a      	orrs	r2, r3
 8007388:	687b      	ldr	r3, [r7, #4]
 800738a:	69db      	ldr	r3, [r3, #28]
 800738c:	4313      	orrs	r3, r2
 800738e:	613b      	str	r3, [r7, #16]
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8007390:	687b      	ldr	r3, [r7, #4]
 8007392:	681b      	ldr	r3, [r3, #0]
 8007394:	681a      	ldr	r2, [r3, #0]
 8007396:	4bb1      	ldr	r3, [pc, #708]	; (800765c <UART_SetConfig+0x2f4>)
 8007398:	4013      	ands	r3, r2
 800739a:	687a      	ldr	r2, [r7, #4]
 800739c:	6812      	ldr	r2, [r2, #0]
 800739e:	6939      	ldr	r1, [r7, #16]
 80073a0:	430b      	orrs	r3, r1
 80073a2:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80073a4:	687b      	ldr	r3, [r7, #4]
 80073a6:	681b      	ldr	r3, [r3, #0]
 80073a8:	685b      	ldr	r3, [r3, #4]
 80073aa:	f423 5140 	bic.w	r1, r3, #12288	; 0x3000
 80073ae:	687b      	ldr	r3, [r7, #4]
 80073b0:	68da      	ldr	r2, [r3, #12]
 80073b2:	687b      	ldr	r3, [r7, #4]
 80073b4:	681b      	ldr	r3, [r3, #0]
 80073b6:	430a      	orrs	r2, r1
 80073b8:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80073ba:	687b      	ldr	r3, [r7, #4]
 80073bc:	699b      	ldr	r3, [r3, #24]
 80073be:	613b      	str	r3, [r7, #16]

  tmpreg |= huart->Init.OneBitSampling;
 80073c0:	687b      	ldr	r3, [r7, #4]
 80073c2:	6a1b      	ldr	r3, [r3, #32]
 80073c4:	693a      	ldr	r2, [r7, #16]
 80073c6:	4313      	orrs	r3, r2
 80073c8:	613b      	str	r3, [r7, #16]
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80073ca:	687b      	ldr	r3, [r7, #4]
 80073cc:	681b      	ldr	r3, [r3, #0]
 80073ce:	689b      	ldr	r3, [r3, #8]
 80073d0:	f423 6130 	bic.w	r1, r3, #2816	; 0xb00
 80073d4:	687b      	ldr	r3, [r7, #4]
 80073d6:	681b      	ldr	r3, [r3, #0]
 80073d8:	693a      	ldr	r2, [r7, #16]
 80073da:	430a      	orrs	r2, r1
 80073dc:	609a      	str	r2, [r3, #8]


  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80073de:	687b      	ldr	r3, [r7, #4]
 80073e0:	681b      	ldr	r3, [r3, #0]
 80073e2:	4a9f      	ldr	r2, [pc, #636]	; (8007660 <UART_SetConfig+0x2f8>)
 80073e4:	4293      	cmp	r3, r2
 80073e6:	d121      	bne.n	800742c <UART_SetConfig+0xc4>
 80073e8:	4b9e      	ldr	r3, [pc, #632]	; (8007664 <UART_SetConfig+0x2fc>)
 80073ea:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80073ee:	f003 0303 	and.w	r3, r3, #3
 80073f2:	2b03      	cmp	r3, #3
 80073f4:	d816      	bhi.n	8007424 <UART_SetConfig+0xbc>
 80073f6:	a201      	add	r2, pc, #4	; (adr r2, 80073fc <UART_SetConfig+0x94>)
 80073f8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80073fc:	0800740d 	.word	0x0800740d
 8007400:	08007419 	.word	0x08007419
 8007404:	08007413 	.word	0x08007413
 8007408:	0800741f 	.word	0x0800741f
 800740c:	2301      	movs	r3, #1
 800740e:	77fb      	strb	r3, [r7, #31]
 8007410:	e151      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007412:	2302      	movs	r3, #2
 8007414:	77fb      	strb	r3, [r7, #31]
 8007416:	e14e      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007418:	2304      	movs	r3, #4
 800741a:	77fb      	strb	r3, [r7, #31]
 800741c:	e14b      	b.n	80076b6 <UART_SetConfig+0x34e>
 800741e:	2308      	movs	r3, #8
 8007420:	77fb      	strb	r3, [r7, #31]
 8007422:	e148      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007424:	2310      	movs	r3, #16
 8007426:	77fb      	strb	r3, [r7, #31]
 8007428:	bf00      	nop
 800742a:	e144      	b.n	80076b6 <UART_SetConfig+0x34e>
 800742c:	687b      	ldr	r3, [r7, #4]
 800742e:	681b      	ldr	r3, [r3, #0]
 8007430:	4a8d      	ldr	r2, [pc, #564]	; (8007668 <UART_SetConfig+0x300>)
 8007432:	4293      	cmp	r3, r2
 8007434:	d134      	bne.n	80074a0 <UART_SetConfig+0x138>
 8007436:	4b8b      	ldr	r3, [pc, #556]	; (8007664 <UART_SetConfig+0x2fc>)
 8007438:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800743c:	f003 030c 	and.w	r3, r3, #12
 8007440:	2b0c      	cmp	r3, #12
 8007442:	d829      	bhi.n	8007498 <UART_SetConfig+0x130>
 8007444:	a201      	add	r2, pc, #4	; (adr r2, 800744c <UART_SetConfig+0xe4>)
 8007446:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800744a:	bf00      	nop
 800744c:	08007481 	.word	0x08007481
 8007450:	08007499 	.word	0x08007499
 8007454:	08007499 	.word	0x08007499
 8007458:	08007499 	.word	0x08007499
 800745c:	0800748d 	.word	0x0800748d
 8007460:	08007499 	.word	0x08007499
 8007464:	08007499 	.word	0x08007499
 8007468:	08007499 	.word	0x08007499
 800746c:	08007487 	.word	0x08007487
 8007470:	08007499 	.word	0x08007499
 8007474:	08007499 	.word	0x08007499
 8007478:	08007499 	.word	0x08007499
 800747c:	08007493 	.word	0x08007493
 8007480:	2300      	movs	r3, #0
 8007482:	77fb      	strb	r3, [r7, #31]
 8007484:	e117      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007486:	2302      	movs	r3, #2
 8007488:	77fb      	strb	r3, [r7, #31]
 800748a:	e114      	b.n	80076b6 <UART_SetConfig+0x34e>
 800748c:	2304      	movs	r3, #4
 800748e:	77fb      	strb	r3, [r7, #31]
 8007490:	e111      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007492:	2308      	movs	r3, #8
 8007494:	77fb      	strb	r3, [r7, #31]
 8007496:	e10e      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007498:	2310      	movs	r3, #16
 800749a:	77fb      	strb	r3, [r7, #31]
 800749c:	bf00      	nop
 800749e:	e10a      	b.n	80076b6 <UART_SetConfig+0x34e>
 80074a0:	687b      	ldr	r3, [r7, #4]
 80074a2:	681b      	ldr	r3, [r3, #0]
 80074a4:	4a71      	ldr	r2, [pc, #452]	; (800766c <UART_SetConfig+0x304>)
 80074a6:	4293      	cmp	r3, r2
 80074a8:	d120      	bne.n	80074ec <UART_SetConfig+0x184>
 80074aa:	4b6e      	ldr	r3, [pc, #440]	; (8007664 <UART_SetConfig+0x2fc>)
 80074ac:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80074b0:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80074b4:	2b10      	cmp	r3, #16
 80074b6:	d00f      	beq.n	80074d8 <UART_SetConfig+0x170>
 80074b8:	2b10      	cmp	r3, #16
 80074ba:	d802      	bhi.n	80074c2 <UART_SetConfig+0x15a>
 80074bc:	2b00      	cmp	r3, #0
 80074be:	d005      	beq.n	80074cc <UART_SetConfig+0x164>
 80074c0:	e010      	b.n	80074e4 <UART_SetConfig+0x17c>
 80074c2:	2b20      	cmp	r3, #32
 80074c4:	d005      	beq.n	80074d2 <UART_SetConfig+0x16a>
 80074c6:	2b30      	cmp	r3, #48	; 0x30
 80074c8:	d009      	beq.n	80074de <UART_SetConfig+0x176>
 80074ca:	e00b      	b.n	80074e4 <UART_SetConfig+0x17c>
 80074cc:	2300      	movs	r3, #0
 80074ce:	77fb      	strb	r3, [r7, #31]
 80074d0:	e0f1      	b.n	80076b6 <UART_SetConfig+0x34e>
 80074d2:	2302      	movs	r3, #2
 80074d4:	77fb      	strb	r3, [r7, #31]
 80074d6:	e0ee      	b.n	80076b6 <UART_SetConfig+0x34e>
 80074d8:	2304      	movs	r3, #4
 80074da:	77fb      	strb	r3, [r7, #31]
 80074dc:	e0eb      	b.n	80076b6 <UART_SetConfig+0x34e>
 80074de:	2308      	movs	r3, #8
 80074e0:	77fb      	strb	r3, [r7, #31]
 80074e2:	e0e8      	b.n	80076b6 <UART_SetConfig+0x34e>
 80074e4:	2310      	movs	r3, #16
 80074e6:	77fb      	strb	r3, [r7, #31]
 80074e8:	bf00      	nop
 80074ea:	e0e4      	b.n	80076b6 <UART_SetConfig+0x34e>
 80074ec:	687b      	ldr	r3, [r7, #4]
 80074ee:	681b      	ldr	r3, [r3, #0]
 80074f0:	4a5f      	ldr	r2, [pc, #380]	; (8007670 <UART_SetConfig+0x308>)
 80074f2:	4293      	cmp	r3, r2
 80074f4:	d120      	bne.n	8007538 <UART_SetConfig+0x1d0>
 80074f6:	4b5b      	ldr	r3, [pc, #364]	; (8007664 <UART_SetConfig+0x2fc>)
 80074f8:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80074fc:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8007500:	2b40      	cmp	r3, #64	; 0x40
 8007502:	d00f      	beq.n	8007524 <UART_SetConfig+0x1bc>
 8007504:	2b40      	cmp	r3, #64	; 0x40
 8007506:	d802      	bhi.n	800750e <UART_SetConfig+0x1a6>
 8007508:	2b00      	cmp	r3, #0
 800750a:	d005      	beq.n	8007518 <UART_SetConfig+0x1b0>
 800750c:	e010      	b.n	8007530 <UART_SetConfig+0x1c8>
 800750e:	2b80      	cmp	r3, #128	; 0x80
 8007510:	d005      	beq.n	800751e <UART_SetConfig+0x1b6>
 8007512:	2bc0      	cmp	r3, #192	; 0xc0
 8007514:	d009      	beq.n	800752a <UART_SetConfig+0x1c2>
 8007516:	e00b      	b.n	8007530 <UART_SetConfig+0x1c8>
 8007518:	2300      	movs	r3, #0
 800751a:	77fb      	strb	r3, [r7, #31]
 800751c:	e0cb      	b.n	80076b6 <UART_SetConfig+0x34e>
 800751e:	2302      	movs	r3, #2
 8007520:	77fb      	strb	r3, [r7, #31]
 8007522:	e0c8      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007524:	2304      	movs	r3, #4
 8007526:	77fb      	strb	r3, [r7, #31]
 8007528:	e0c5      	b.n	80076b6 <UART_SetConfig+0x34e>
 800752a:	2308      	movs	r3, #8
 800752c:	77fb      	strb	r3, [r7, #31]
 800752e:	e0c2      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007530:	2310      	movs	r3, #16
 8007532:	77fb      	strb	r3, [r7, #31]
 8007534:	bf00      	nop
 8007536:	e0be      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007538:	687b      	ldr	r3, [r7, #4]
 800753a:	681b      	ldr	r3, [r3, #0]
 800753c:	4a4d      	ldr	r2, [pc, #308]	; (8007674 <UART_SetConfig+0x30c>)
 800753e:	4293      	cmp	r3, r2
 8007540:	d124      	bne.n	800758c <UART_SetConfig+0x224>
 8007542:	4b48      	ldr	r3, [pc, #288]	; (8007664 <UART_SetConfig+0x2fc>)
 8007544:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007548:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800754c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007550:	d012      	beq.n	8007578 <UART_SetConfig+0x210>
 8007552:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8007556:	d802      	bhi.n	800755e <UART_SetConfig+0x1f6>
 8007558:	2b00      	cmp	r3, #0
 800755a:	d007      	beq.n	800756c <UART_SetConfig+0x204>
 800755c:	e012      	b.n	8007584 <UART_SetConfig+0x21c>
 800755e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8007562:	d006      	beq.n	8007572 <UART_SetConfig+0x20a>
 8007564:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8007568:	d009      	beq.n	800757e <UART_SetConfig+0x216>
 800756a:	e00b      	b.n	8007584 <UART_SetConfig+0x21c>
 800756c:	2300      	movs	r3, #0
 800756e:	77fb      	strb	r3, [r7, #31]
 8007570:	e0a1      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007572:	2302      	movs	r3, #2
 8007574:	77fb      	strb	r3, [r7, #31]
 8007576:	e09e      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007578:	2304      	movs	r3, #4
 800757a:	77fb      	strb	r3, [r7, #31]
 800757c:	e09b      	b.n	80076b6 <UART_SetConfig+0x34e>
 800757e:	2308      	movs	r3, #8
 8007580:	77fb      	strb	r3, [r7, #31]
 8007582:	e098      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007584:	2310      	movs	r3, #16
 8007586:	77fb      	strb	r3, [r7, #31]
 8007588:	bf00      	nop
 800758a:	e094      	b.n	80076b6 <UART_SetConfig+0x34e>
 800758c:	687b      	ldr	r3, [r7, #4]
 800758e:	681b      	ldr	r3, [r3, #0]
 8007590:	4a39      	ldr	r2, [pc, #228]	; (8007678 <UART_SetConfig+0x310>)
 8007592:	4293      	cmp	r3, r2
 8007594:	d124      	bne.n	80075e0 <UART_SetConfig+0x278>
 8007596:	4b33      	ldr	r3, [pc, #204]	; (8007664 <UART_SetConfig+0x2fc>)
 8007598:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800759c:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 80075a0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80075a4:	d012      	beq.n	80075cc <UART_SetConfig+0x264>
 80075a6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80075aa:	d802      	bhi.n	80075b2 <UART_SetConfig+0x24a>
 80075ac:	2b00      	cmp	r3, #0
 80075ae:	d007      	beq.n	80075c0 <UART_SetConfig+0x258>
 80075b0:	e012      	b.n	80075d8 <UART_SetConfig+0x270>
 80075b2:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80075b6:	d006      	beq.n	80075c6 <UART_SetConfig+0x25e>
 80075b8:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80075bc:	d009      	beq.n	80075d2 <UART_SetConfig+0x26a>
 80075be:	e00b      	b.n	80075d8 <UART_SetConfig+0x270>
 80075c0:	2301      	movs	r3, #1
 80075c2:	77fb      	strb	r3, [r7, #31]
 80075c4:	e077      	b.n	80076b6 <UART_SetConfig+0x34e>
 80075c6:	2302      	movs	r3, #2
 80075c8:	77fb      	strb	r3, [r7, #31]
 80075ca:	e074      	b.n	80076b6 <UART_SetConfig+0x34e>
 80075cc:	2304      	movs	r3, #4
 80075ce:	77fb      	strb	r3, [r7, #31]
 80075d0:	e071      	b.n	80076b6 <UART_SetConfig+0x34e>
 80075d2:	2308      	movs	r3, #8
 80075d4:	77fb      	strb	r3, [r7, #31]
 80075d6:	e06e      	b.n	80076b6 <UART_SetConfig+0x34e>
 80075d8:	2310      	movs	r3, #16
 80075da:	77fb      	strb	r3, [r7, #31]
 80075dc:	bf00      	nop
 80075de:	e06a      	b.n	80076b6 <UART_SetConfig+0x34e>
 80075e0:	687b      	ldr	r3, [r7, #4]
 80075e2:	681b      	ldr	r3, [r3, #0]
 80075e4:	4a25      	ldr	r2, [pc, #148]	; (800767c <UART_SetConfig+0x314>)
 80075e6:	4293      	cmp	r3, r2
 80075e8:	d124      	bne.n	8007634 <UART_SetConfig+0x2cc>
 80075ea:	4b1e      	ldr	r3, [pc, #120]	; (8007664 <UART_SetConfig+0x2fc>)
 80075ec:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80075f0:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80075f4:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80075f8:	d012      	beq.n	8007620 <UART_SetConfig+0x2b8>
 80075fa:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 80075fe:	d802      	bhi.n	8007606 <UART_SetConfig+0x29e>
 8007600:	2b00      	cmp	r3, #0
 8007602:	d007      	beq.n	8007614 <UART_SetConfig+0x2ac>
 8007604:	e012      	b.n	800762c <UART_SetConfig+0x2c4>
 8007606:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800760a:	d006      	beq.n	800761a <UART_SetConfig+0x2b2>
 800760c:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 8007610:	d009      	beq.n	8007626 <UART_SetConfig+0x2be>
 8007612:	e00b      	b.n	800762c <UART_SetConfig+0x2c4>
 8007614:	2300      	movs	r3, #0
 8007616:	77fb      	strb	r3, [r7, #31]
 8007618:	e04d      	b.n	80076b6 <UART_SetConfig+0x34e>
 800761a:	2302      	movs	r3, #2
 800761c:	77fb      	strb	r3, [r7, #31]
 800761e:	e04a      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007620:	2304      	movs	r3, #4
 8007622:	77fb      	strb	r3, [r7, #31]
 8007624:	e047      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007626:	2308      	movs	r3, #8
 8007628:	77fb      	strb	r3, [r7, #31]
 800762a:	e044      	b.n	80076b6 <UART_SetConfig+0x34e>
 800762c:	2310      	movs	r3, #16
 800762e:	77fb      	strb	r3, [r7, #31]
 8007630:	bf00      	nop
 8007632:	e040      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007634:	687b      	ldr	r3, [r7, #4]
 8007636:	681b      	ldr	r3, [r3, #0]
 8007638:	4a11      	ldr	r2, [pc, #68]	; (8007680 <UART_SetConfig+0x318>)
 800763a:	4293      	cmp	r3, r2
 800763c:	d139      	bne.n	80076b2 <UART_SetConfig+0x34a>
 800763e:	4b09      	ldr	r3, [pc, #36]	; (8007664 <UART_SetConfig+0x2fc>)
 8007640:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007644:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8007648:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800764c:	d027      	beq.n	800769e <UART_SetConfig+0x336>
 800764e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8007652:	d817      	bhi.n	8007684 <UART_SetConfig+0x31c>
 8007654:	2b00      	cmp	r3, #0
 8007656:	d01c      	beq.n	8007692 <UART_SetConfig+0x32a>
 8007658:	e027      	b.n	80076aa <UART_SetConfig+0x342>
 800765a:	bf00      	nop
 800765c:	efff69f3 	.word	0xefff69f3
 8007660:	40011000 	.word	0x40011000
 8007664:	40023800 	.word	0x40023800
 8007668:	40004400 	.word	0x40004400
 800766c:	40004800 	.word	0x40004800
 8007670:	40004c00 	.word	0x40004c00
 8007674:	40005000 	.word	0x40005000
 8007678:	40011400 	.word	0x40011400
 800767c:	40007800 	.word	0x40007800
 8007680:	40007c00 	.word	0x40007c00
 8007684:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8007688:	d006      	beq.n	8007698 <UART_SetConfig+0x330>
 800768a:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800768e:	d009      	beq.n	80076a4 <UART_SetConfig+0x33c>
 8007690:	e00b      	b.n	80076aa <UART_SetConfig+0x342>
 8007692:	2300      	movs	r3, #0
 8007694:	77fb      	strb	r3, [r7, #31]
 8007696:	e00e      	b.n	80076b6 <UART_SetConfig+0x34e>
 8007698:	2302      	movs	r3, #2
 800769a:	77fb      	strb	r3, [r7, #31]
 800769c:	e00b      	b.n	80076b6 <UART_SetConfig+0x34e>
 800769e:	2304      	movs	r3, #4
 80076a0:	77fb      	strb	r3, [r7, #31]
 80076a2:	e008      	b.n	80076b6 <UART_SetConfig+0x34e>
 80076a4:	2308      	movs	r3, #8
 80076a6:	77fb      	strb	r3, [r7, #31]
 80076a8:	e005      	b.n	80076b6 <UART_SetConfig+0x34e>
 80076aa:	2310      	movs	r3, #16
 80076ac:	77fb      	strb	r3, [r7, #31]
 80076ae:	bf00      	nop
 80076b0:	e001      	b.n	80076b6 <UART_SetConfig+0x34e>
 80076b2:	2310      	movs	r3, #16
 80076b4:	77fb      	strb	r3, [r7, #31]

  if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80076b6:	687b      	ldr	r3, [r7, #4]
 80076b8:	69db      	ldr	r3, [r3, #28]
 80076ba:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 80076be:	d17c      	bne.n	80077ba <UART_SetConfig+0x452>
  {
    switch (clocksource)
 80076c0:	7ffb      	ldrb	r3, [r7, #31]
 80076c2:	2b08      	cmp	r3, #8
 80076c4:	d859      	bhi.n	800777a <UART_SetConfig+0x412>
 80076c6:	a201      	add	r2, pc, #4	; (adr r2, 80076cc <UART_SetConfig+0x364>)
 80076c8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80076cc:	080076f1 	.word	0x080076f1
 80076d0:	0800770f 	.word	0x0800770f
 80076d4:	0800772d 	.word	0x0800772d
 80076d8:	0800777b 	.word	0x0800777b
 80076dc:	08007745 	.word	0x08007745
 80076e0:	0800777b 	.word	0x0800777b
 80076e4:	0800777b 	.word	0x0800777b
 80076e8:	0800777b 	.word	0x0800777b
 80076ec:	08007763 	.word	0x08007763
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80076f0:	f7fd fa5e 	bl	8004bb0 <HAL_RCC_GetPCLK1Freq>
 80076f4:	4603      	mov	r3, r0
 80076f6:	005a      	lsls	r2, r3, #1
 80076f8:	687b      	ldr	r3, [r7, #4]
 80076fa:	685b      	ldr	r3, [r3, #4]
 80076fc:	085b      	lsrs	r3, r3, #1
 80076fe:	441a      	add	r2, r3
 8007700:	687b      	ldr	r3, [r7, #4]
 8007702:	685b      	ldr	r3, [r3, #4]
 8007704:	fbb2 f3f3 	udiv	r3, r2, r3
 8007708:	b29b      	uxth	r3, r3
 800770a:	61bb      	str	r3, [r7, #24]
        break;
 800770c:	e038      	b.n	8007780 <UART_SetConfig+0x418>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800770e:	f7fd fa63 	bl	8004bd8 <HAL_RCC_GetPCLK2Freq>
 8007712:	4603      	mov	r3, r0
 8007714:	005a      	lsls	r2, r3, #1
 8007716:	687b      	ldr	r3, [r7, #4]
 8007718:	685b      	ldr	r3, [r3, #4]
 800771a:	085b      	lsrs	r3, r3, #1
 800771c:	441a      	add	r2, r3
 800771e:	687b      	ldr	r3, [r7, #4]
 8007720:	685b      	ldr	r3, [r3, #4]
 8007722:	fbb2 f3f3 	udiv	r3, r2, r3
 8007726:	b29b      	uxth	r3, r3
 8007728:	61bb      	str	r3, [r7, #24]
        break;
 800772a:	e029      	b.n	8007780 <UART_SetConfig+0x418>
      case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 800772c:	687b      	ldr	r3, [r7, #4]
 800772e:	685b      	ldr	r3, [r3, #4]
 8007730:	085a      	lsrs	r2, r3, #1
 8007732:	4b5d      	ldr	r3, [pc, #372]	; (80078a8 <UART_SetConfig+0x540>)
 8007734:	4413      	add	r3, r2
 8007736:	687a      	ldr	r2, [r7, #4]
 8007738:	6852      	ldr	r2, [r2, #4]
 800773a:	fbb3 f3f2 	udiv	r3, r3, r2
 800773e:	b29b      	uxth	r3, r3
 8007740:	61bb      	str	r3, [r7, #24]
        break;
 8007742:	e01d      	b.n	8007780 <UART_SetConfig+0x418>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8007744:	f7fd f976 	bl	8004a34 <HAL_RCC_GetSysClockFreq>
 8007748:	4603      	mov	r3, r0
 800774a:	005a      	lsls	r2, r3, #1
 800774c:	687b      	ldr	r3, [r7, #4]
 800774e:	685b      	ldr	r3, [r3, #4]
 8007750:	085b      	lsrs	r3, r3, #1
 8007752:	441a      	add	r2, r3
 8007754:	687b      	ldr	r3, [r7, #4]
 8007756:	685b      	ldr	r3, [r3, #4]
 8007758:	fbb2 f3f3 	udiv	r3, r2, r3
 800775c:	b29b      	uxth	r3, r3
 800775e:	61bb      	str	r3, [r7, #24]
        break;
 8007760:	e00e      	b.n	8007780 <UART_SetConfig+0x418>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 8007762:	687b      	ldr	r3, [r7, #4]
 8007764:	685b      	ldr	r3, [r3, #4]
 8007766:	085b      	lsrs	r3, r3, #1
 8007768:	f503 3280 	add.w	r2, r3, #65536	; 0x10000
 800776c:	687b      	ldr	r3, [r7, #4]
 800776e:	685b      	ldr	r3, [r3, #4]
 8007770:	fbb2 f3f3 	udiv	r3, r2, r3
 8007774:	b29b      	uxth	r3, r3
 8007776:	61bb      	str	r3, [r7, #24]
        break;
 8007778:	e002      	b.n	8007780 <UART_SetConfig+0x418>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 800777a:	2301      	movs	r3, #1
 800777c:	75fb      	strb	r3, [r7, #23]
        break;
 800777e:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8007780:	69bb      	ldr	r3, [r7, #24]
 8007782:	2b0f      	cmp	r3, #15
 8007784:	d916      	bls.n	80077b4 <UART_SetConfig+0x44c>
 8007786:	69bb      	ldr	r3, [r7, #24]
 8007788:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800778c:	d212      	bcs.n	80077b4 <UART_SetConfig+0x44c>
    {
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 800778e:	69bb      	ldr	r3, [r7, #24]
 8007790:	b29b      	uxth	r3, r3
 8007792:	f023 030f 	bic.w	r3, r3, #15
 8007796:	81fb      	strh	r3, [r7, #14]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8007798:	69bb      	ldr	r3, [r7, #24]
 800779a:	085b      	lsrs	r3, r3, #1
 800779c:	b29b      	uxth	r3, r3
 800779e:	f003 0307 	and.w	r3, r3, #7
 80077a2:	b29a      	uxth	r2, r3
 80077a4:	89fb      	ldrh	r3, [r7, #14]
 80077a6:	4313      	orrs	r3, r2
 80077a8:	81fb      	strh	r3, [r7, #14]
      huart->Instance->BRR = brrtemp;
 80077aa:	687b      	ldr	r3, [r7, #4]
 80077ac:	681b      	ldr	r3, [r3, #0]
 80077ae:	89fa      	ldrh	r2, [r7, #14]
 80077b0:	60da      	str	r2, [r3, #12]
 80077b2:	e06e      	b.n	8007892 <UART_SetConfig+0x52a>
    }
    else
    {
      ret = HAL_ERROR;
 80077b4:	2301      	movs	r3, #1
 80077b6:	75fb      	strb	r3, [r7, #23]
 80077b8:	e06b      	b.n	8007892 <UART_SetConfig+0x52a>
    }
  }
  else
  {
    switch (clocksource)
 80077ba:	7ffb      	ldrb	r3, [r7, #31]
 80077bc:	2b08      	cmp	r3, #8
 80077be:	d857      	bhi.n	8007870 <UART_SetConfig+0x508>
 80077c0:	a201      	add	r2, pc, #4	; (adr r2, 80077c8 <UART_SetConfig+0x460>)
 80077c2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80077c6:	bf00      	nop
 80077c8:	080077ed 	.word	0x080077ed
 80077cc:	08007809 	.word	0x08007809
 80077d0:	08007825 	.word	0x08007825
 80077d4:	08007871 	.word	0x08007871
 80077d8:	0800783d 	.word	0x0800783d
 80077dc:	08007871 	.word	0x08007871
 80077e0:	08007871 	.word	0x08007871
 80077e4:	08007871 	.word	0x08007871
 80077e8:	08007859 	.word	0x08007859
    {
      case UART_CLOCKSOURCE_PCLK1:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80077ec:	f7fd f9e0 	bl	8004bb0 <HAL_RCC_GetPCLK1Freq>
 80077f0:	4602      	mov	r2, r0
 80077f2:	687b      	ldr	r3, [r7, #4]
 80077f4:	685b      	ldr	r3, [r3, #4]
 80077f6:	085b      	lsrs	r3, r3, #1
 80077f8:	441a      	add	r2, r3
 80077fa:	687b      	ldr	r3, [r7, #4]
 80077fc:	685b      	ldr	r3, [r3, #4]
 80077fe:	fbb2 f3f3 	udiv	r3, r2, r3
 8007802:	b29b      	uxth	r3, r3
 8007804:	61bb      	str	r3, [r7, #24]
        break;
 8007806:	e036      	b.n	8007876 <UART_SetConfig+0x50e>
      case UART_CLOCKSOURCE_PCLK2:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8007808:	f7fd f9e6 	bl	8004bd8 <HAL_RCC_GetPCLK2Freq>
 800780c:	4602      	mov	r2, r0
 800780e:	687b      	ldr	r3, [r7, #4]
 8007810:	685b      	ldr	r3, [r3, #4]
 8007812:	085b      	lsrs	r3, r3, #1
 8007814:	441a      	add	r2, r3
 8007816:	687b      	ldr	r3, [r7, #4]
 8007818:	685b      	ldr	r3, [r3, #4]
 800781a:	fbb2 f3f3 	udiv	r3, r2, r3
 800781e:	b29b      	uxth	r3, r3
 8007820:	61bb      	str	r3, [r7, #24]
        break;
 8007822:	e028      	b.n	8007876 <UART_SetConfig+0x50e>
      case UART_CLOCKSOURCE_HSI:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8007824:	687b      	ldr	r3, [r7, #4]
 8007826:	685b      	ldr	r3, [r3, #4]
 8007828:	085a      	lsrs	r2, r3, #1
 800782a:	4b20      	ldr	r3, [pc, #128]	; (80078ac <UART_SetConfig+0x544>)
 800782c:	4413      	add	r3, r2
 800782e:	687a      	ldr	r2, [r7, #4]
 8007830:	6852      	ldr	r2, [r2, #4]
 8007832:	fbb3 f3f2 	udiv	r3, r3, r2
 8007836:	b29b      	uxth	r3, r3
 8007838:	61bb      	str	r3, [r7, #24]
        break;
 800783a:	e01c      	b.n	8007876 <UART_SetConfig+0x50e>
      case UART_CLOCKSOURCE_SYSCLK:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800783c:	f7fd f8fa 	bl	8004a34 <HAL_RCC_GetSysClockFreq>
 8007840:	4602      	mov	r2, r0
 8007842:	687b      	ldr	r3, [r7, #4]
 8007844:	685b      	ldr	r3, [r3, #4]
 8007846:	085b      	lsrs	r3, r3, #1
 8007848:	441a      	add	r2, r3
 800784a:	687b      	ldr	r3, [r7, #4]
 800784c:	685b      	ldr	r3, [r3, #4]
 800784e:	fbb2 f3f3 	udiv	r3, r2, r3
 8007852:	b29b      	uxth	r3, r3
 8007854:	61bb      	str	r3, [r7, #24]
        break;
 8007856:	e00e      	b.n	8007876 <UART_SetConfig+0x50e>
      case UART_CLOCKSOURCE_LSE:
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8007858:	687b      	ldr	r3, [r7, #4]
 800785a:	685b      	ldr	r3, [r3, #4]
 800785c:	085b      	lsrs	r3, r3, #1
 800785e:	f503 4200 	add.w	r2, r3, #32768	; 0x8000
 8007862:	687b      	ldr	r3, [r7, #4]
 8007864:	685b      	ldr	r3, [r3, #4]
 8007866:	fbb2 f3f3 	udiv	r3, r2, r3
 800786a:	b29b      	uxth	r3, r3
 800786c:	61bb      	str	r3, [r7, #24]
        break;
 800786e:	e002      	b.n	8007876 <UART_SetConfig+0x50e>
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 8007870:	2301      	movs	r3, #1
 8007872:	75fb      	strb	r3, [r7, #23]
        break;
 8007874:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8007876:	69bb      	ldr	r3, [r7, #24]
 8007878:	2b0f      	cmp	r3, #15
 800787a:	d908      	bls.n	800788e <UART_SetConfig+0x526>
 800787c:	69bb      	ldr	r3, [r7, #24]
 800787e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8007882:	d204      	bcs.n	800788e <UART_SetConfig+0x526>
    {
      huart->Instance->BRR = usartdiv;
 8007884:	687b      	ldr	r3, [r7, #4]
 8007886:	681b      	ldr	r3, [r3, #0]
 8007888:	69ba      	ldr	r2, [r7, #24]
 800788a:	60da      	str	r2, [r3, #12]
 800788c:	e001      	b.n	8007892 <UART_SetConfig+0x52a>
    }
    else
    {
      ret = HAL_ERROR;
 800788e:	2301      	movs	r3, #1
 8007890:	75fb      	strb	r3, [r7, #23]
    }
  }


  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 8007892:	687b      	ldr	r3, [r7, #4]
 8007894:	2200      	movs	r2, #0
 8007896:	661a      	str	r2, [r3, #96]	; 0x60
  huart->TxISR = NULL;
 8007898:	687b      	ldr	r3, [r7, #4]
 800789a:	2200      	movs	r2, #0
 800789c:	665a      	str	r2, [r3, #100]	; 0x64

  return ret;
 800789e:	7dfb      	ldrb	r3, [r7, #23]
}
 80078a0:	4618      	mov	r0, r3
 80078a2:	3720      	adds	r7, #32
 80078a4:	46bd      	mov	sp, r7
 80078a6:	bd80      	pop	{r7, pc}
 80078a8:	01e84800 	.word	0x01e84800
 80078ac:	00f42400 	.word	0x00f42400

080078b0 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
 80078b0:	b480      	push	{r7}
 80078b2:	b083      	sub	sp, #12
 80078b4:	af00      	add	r7, sp, #0
 80078b6:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 80078b8:	687b      	ldr	r3, [r7, #4]
 80078ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80078bc:	f003 0301 	and.w	r3, r3, #1
 80078c0:	2b00      	cmp	r3, #0
 80078c2:	d00a      	beq.n	80078da <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 80078c4:	687b      	ldr	r3, [r7, #4]
 80078c6:	681b      	ldr	r3, [r3, #0]
 80078c8:	685b      	ldr	r3, [r3, #4]
 80078ca:	f423 3100 	bic.w	r1, r3, #131072	; 0x20000
 80078ce:	687b      	ldr	r3, [r7, #4]
 80078d0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80078d2:	687b      	ldr	r3, [r7, #4]
 80078d4:	681b      	ldr	r3, [r3, #0]
 80078d6:	430a      	orrs	r2, r1
 80078d8:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 80078da:	687b      	ldr	r3, [r7, #4]
 80078dc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80078de:	f003 0302 	and.w	r3, r3, #2
 80078e2:	2b00      	cmp	r3, #0
 80078e4:	d00a      	beq.n	80078fc <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80078e6:	687b      	ldr	r3, [r7, #4]
 80078e8:	681b      	ldr	r3, [r3, #0]
 80078ea:	685b      	ldr	r3, [r3, #4]
 80078ec:	f423 3180 	bic.w	r1, r3, #65536	; 0x10000
 80078f0:	687b      	ldr	r3, [r7, #4]
 80078f2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80078f4:	687b      	ldr	r3, [r7, #4]
 80078f6:	681b      	ldr	r3, [r3, #0]
 80078f8:	430a      	orrs	r2, r1
 80078fa:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80078fc:	687b      	ldr	r3, [r7, #4]
 80078fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007900:	f003 0304 	and.w	r3, r3, #4
 8007904:	2b00      	cmp	r3, #0
 8007906:	d00a      	beq.n	800791e <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8007908:	687b      	ldr	r3, [r7, #4]
 800790a:	681b      	ldr	r3, [r3, #0]
 800790c:	685b      	ldr	r3, [r3, #4]
 800790e:	f423 2180 	bic.w	r1, r3, #262144	; 0x40000
 8007912:	687b      	ldr	r3, [r7, #4]
 8007914:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8007916:	687b      	ldr	r3, [r7, #4]
 8007918:	681b      	ldr	r3, [r3, #0]
 800791a:	430a      	orrs	r2, r1
 800791c:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 800791e:	687b      	ldr	r3, [r7, #4]
 8007920:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007922:	f003 0308 	and.w	r3, r3, #8
 8007926:	2b00      	cmp	r3, #0
 8007928:	d00a      	beq.n	8007940 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 800792a:	687b      	ldr	r3, [r7, #4]
 800792c:	681b      	ldr	r3, [r3, #0]
 800792e:	685b      	ldr	r3, [r3, #4]
 8007930:	f423 4100 	bic.w	r1, r3, #32768	; 0x8000
 8007934:	687b      	ldr	r3, [r7, #4]
 8007936:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8007938:	687b      	ldr	r3, [r7, #4]
 800793a:	681b      	ldr	r3, [r3, #0]
 800793c:	430a      	orrs	r2, r1
 800793e:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8007940:	687b      	ldr	r3, [r7, #4]
 8007942:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007944:	f003 0310 	and.w	r3, r3, #16
 8007948:	2b00      	cmp	r3, #0
 800794a:	d00a      	beq.n	8007962 <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 800794c:	687b      	ldr	r3, [r7, #4]
 800794e:	681b      	ldr	r3, [r3, #0]
 8007950:	689b      	ldr	r3, [r3, #8]
 8007952:	f423 5180 	bic.w	r1, r3, #4096	; 0x1000
 8007956:	687b      	ldr	r3, [r7, #4]
 8007958:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800795a:	687b      	ldr	r3, [r7, #4]
 800795c:	681b      	ldr	r3, [r3, #0]
 800795e:	430a      	orrs	r2, r1
 8007960:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8007962:	687b      	ldr	r3, [r7, #4]
 8007964:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007966:	f003 0320 	and.w	r3, r3, #32
 800796a:	2b00      	cmp	r3, #0
 800796c:	d00a      	beq.n	8007984 <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800796e:	687b      	ldr	r3, [r7, #4]
 8007970:	681b      	ldr	r3, [r3, #0]
 8007972:	689b      	ldr	r3, [r3, #8]
 8007974:	f423 5100 	bic.w	r1, r3, #8192	; 0x2000
 8007978:	687b      	ldr	r3, [r7, #4]
 800797a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800797c:	687b      	ldr	r3, [r7, #4]
 800797e:	681b      	ldr	r3, [r3, #0]
 8007980:	430a      	orrs	r2, r1
 8007982:	609a      	str	r2, [r3, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8007984:	687b      	ldr	r3, [r7, #4]
 8007986:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8007988:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800798c:	2b00      	cmp	r3, #0
 800798e:	d01a      	beq.n	80079c6 <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 8007990:	687b      	ldr	r3, [r7, #4]
 8007992:	681b      	ldr	r3, [r3, #0]
 8007994:	685b      	ldr	r3, [r3, #4]
 8007996:	f423 1180 	bic.w	r1, r3, #1048576	; 0x100000
 800799a:	687b      	ldr	r3, [r7, #4]
 800799c:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800799e:	687b      	ldr	r3, [r7, #4]
 80079a0:	681b      	ldr	r3, [r3, #0]
 80079a2:	430a      	orrs	r2, r1
 80079a4:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 80079a6:	687b      	ldr	r3, [r7, #4]
 80079a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80079aa:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 80079ae:	d10a      	bne.n	80079c6 <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80079b0:	687b      	ldr	r3, [r7, #4]
 80079b2:	681b      	ldr	r3, [r3, #0]
 80079b4:	685b      	ldr	r3, [r3, #4]
 80079b6:	f423 01c0 	bic.w	r1, r3, #6291456	; 0x600000
 80079ba:	687b      	ldr	r3, [r7, #4]
 80079bc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80079be:	687b      	ldr	r3, [r7, #4]
 80079c0:	681b      	ldr	r3, [r3, #0]
 80079c2:	430a      	orrs	r2, r1
 80079c4:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80079c6:	687b      	ldr	r3, [r7, #4]
 80079c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80079ca:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80079ce:	2b00      	cmp	r3, #0
 80079d0:	d00a      	beq.n	80079e8 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80079d2:	687b      	ldr	r3, [r7, #4]
 80079d4:	681b      	ldr	r3, [r3, #0]
 80079d6:	685b      	ldr	r3, [r3, #4]
 80079d8:	f423 2100 	bic.w	r1, r3, #524288	; 0x80000
 80079dc:	687b      	ldr	r3, [r7, #4]
 80079de:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 80079e0:	687b      	ldr	r3, [r7, #4]
 80079e2:	681b      	ldr	r3, [r3, #0]
 80079e4:	430a      	orrs	r2, r1
 80079e6:	605a      	str	r2, [r3, #4]
  }
}
 80079e8:	bf00      	nop
 80079ea:	370c      	adds	r7, #12
 80079ec:	46bd      	mov	sp, r7
 80079ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80079f2:	4770      	bx	lr

080079f4 <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
 80079f4:	b580      	push	{r7, lr}
 80079f6:	b086      	sub	sp, #24
 80079f8:	af02      	add	r7, sp, #8
 80079fa:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 80079fc:	687b      	ldr	r3, [r7, #4]
 80079fe:	2200      	movs	r2, #0
 8007a00:	67da      	str	r2, [r3, #124]	; 0x7c

  /* Init tickstart for timeout managment*/
  tickstart = HAL_GetTick();
 8007a02:	f7f8 fe0f 	bl	8000624 <HAL_GetTick>
 8007a06:	60f8      	str	r0, [r7, #12]

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8007a08:	687b      	ldr	r3, [r7, #4]
 8007a0a:	681b      	ldr	r3, [r3, #0]
 8007a0c:	681b      	ldr	r3, [r3, #0]
 8007a0e:	f003 0308 	and.w	r3, r3, #8
 8007a12:	2b08      	cmp	r3, #8
 8007a14:	d10e      	bne.n	8007a34 <UART_CheckIdleState+0x40>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8007a16:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8007a1a:	9300      	str	r3, [sp, #0]
 8007a1c:	68fb      	ldr	r3, [r7, #12]
 8007a1e:	2200      	movs	r2, #0
 8007a20:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8007a24:	6878      	ldr	r0, [r7, #4]
 8007a26:	f000 f814 	bl	8007a52 <UART_WaitOnFlagUntilTimeout>
 8007a2a:	4603      	mov	r3, r0
 8007a2c:	2b00      	cmp	r3, #0
 8007a2e:	d001      	beq.n	8007a34 <UART_CheckIdleState+0x40>
    {
      /* Timeout occurred */
      return HAL_TIMEOUT;
 8007a30:	2303      	movs	r3, #3
 8007a32:	e00a      	b.n	8007a4a <UART_CheckIdleState+0x56>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
 8007a34:	687b      	ldr	r3, [r7, #4]
 8007a36:	2220      	movs	r2, #32
 8007a38:	675a      	str	r2, [r3, #116]	; 0x74
  huart->RxState = HAL_UART_STATE_READY;
 8007a3a:	687b      	ldr	r3, [r7, #4]
 8007a3c:	2220      	movs	r2, #32
 8007a3e:	679a      	str	r2, [r3, #120]	; 0x78

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
 8007a40:	687b      	ldr	r3, [r7, #4]
 8007a42:	2200      	movs	r2, #0
 8007a44:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70

  return HAL_OK;
 8007a48:	2300      	movs	r3, #0
}
 8007a4a:	4618      	mov	r0, r3
 8007a4c:	3710      	adds	r7, #16
 8007a4e:	46bd      	mov	sp, r7
 8007a50:	bd80      	pop	{r7, pc}

08007a52 <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8007a52:	b580      	push	{r7, lr}
 8007a54:	b084      	sub	sp, #16
 8007a56:	af00      	add	r7, sp, #0
 8007a58:	60f8      	str	r0, [r7, #12]
 8007a5a:	60b9      	str	r1, [r7, #8]
 8007a5c:	603b      	str	r3, [r7, #0]
 8007a5e:	4613      	mov	r3, r2
 8007a60:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8007a62:	e02a      	b.n	8007aba <UART_WaitOnFlagUntilTimeout+0x68>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
 8007a64:	69bb      	ldr	r3, [r7, #24]
 8007a66:	f1b3 3fff 	cmp.w	r3, #4294967295
 8007a6a:	d026      	beq.n	8007aba <UART_WaitOnFlagUntilTimeout+0x68>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007a6c:	f7f8 fdda 	bl	8000624 <HAL_GetTick>
 8007a70:	4602      	mov	r2, r0
 8007a72:	683b      	ldr	r3, [r7, #0]
 8007a74:	1ad3      	subs	r3, r2, r3
 8007a76:	69ba      	ldr	r2, [r7, #24]
 8007a78:	429a      	cmp	r2, r3
 8007a7a:	d302      	bcc.n	8007a82 <UART_WaitOnFlagUntilTimeout+0x30>
 8007a7c:	69bb      	ldr	r3, [r7, #24]
 8007a7e:	2b00      	cmp	r3, #0
 8007a80:	d11b      	bne.n	8007aba <UART_WaitOnFlagUntilTimeout+0x68>
      {
        /* Disable TXE, RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts for the interrupt process */
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 8007a82:	68fb      	ldr	r3, [r7, #12]
 8007a84:	681b      	ldr	r3, [r3, #0]
 8007a86:	681a      	ldr	r2, [r3, #0]
 8007a88:	68fb      	ldr	r3, [r7, #12]
 8007a8a:	681b      	ldr	r3, [r3, #0]
 8007a8c:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8007a90:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8007a92:	68fb      	ldr	r3, [r7, #12]
 8007a94:	681b      	ldr	r3, [r3, #0]
 8007a96:	689a      	ldr	r2, [r3, #8]
 8007a98:	68fb      	ldr	r3, [r7, #12]
 8007a9a:	681b      	ldr	r3, [r3, #0]
 8007a9c:	f022 0201 	bic.w	r2, r2, #1
 8007aa0:	609a      	str	r2, [r3, #8]

        huart->gState = HAL_UART_STATE_READY;
 8007aa2:	68fb      	ldr	r3, [r7, #12]
 8007aa4:	2220      	movs	r2, #32
 8007aa6:	675a      	str	r2, [r3, #116]	; 0x74
        huart->RxState = HAL_UART_STATE_READY;
 8007aa8:	68fb      	ldr	r3, [r7, #12]
 8007aaa:	2220      	movs	r2, #32
 8007aac:	679a      	str	r2, [r3, #120]	; 0x78

        /* Process Unlocked */
        __HAL_UNLOCK(huart);
 8007aae:	68fb      	ldr	r3, [r7, #12]
 8007ab0:	2200      	movs	r2, #0
 8007ab2:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70

        return HAL_TIMEOUT;
 8007ab6:	2303      	movs	r3, #3
 8007ab8:	e00f      	b.n	8007ada <UART_WaitOnFlagUntilTimeout+0x88>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 8007aba:	68fb      	ldr	r3, [r7, #12]
 8007abc:	681b      	ldr	r3, [r3, #0]
 8007abe:	69da      	ldr	r2, [r3, #28]
 8007ac0:	68bb      	ldr	r3, [r7, #8]
 8007ac2:	4013      	ands	r3, r2
 8007ac4:	68ba      	ldr	r2, [r7, #8]
 8007ac6:	429a      	cmp	r2, r3
 8007ac8:	bf0c      	ite	eq
 8007aca:	2301      	moveq	r3, #1
 8007acc:	2300      	movne	r3, #0
 8007ace:	b2db      	uxtb	r3, r3
 8007ad0:	461a      	mov	r2, r3
 8007ad2:	79fb      	ldrb	r3, [r7, #7]
 8007ad4:	429a      	cmp	r2, r3
 8007ad6:	d0c5      	beq.n	8007a64 <UART_WaitOnFlagUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
 8007ad8:	2300      	movs	r3, #0
}
 8007ada:	4618      	mov	r0, r3
 8007adc:	3710      	adds	r7, #16
 8007ade:	46bd      	mov	sp, r7
 8007ae0:	bd80      	pop	{r7, pc}
	...

08007ae4 <FMC_SDRAM_Init>:
  * @param  Device Pointer to SDRAM device instance
  * @param  Init Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 8007ae4:	b480      	push	{r7}
 8007ae6:	b085      	sub	sp, #20
 8007ae8:	af00      	add	r7, sp, #0
 8007aea:	6078      	str	r0, [r7, #4]
 8007aec:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
 8007aee:	2300      	movs	r3, #0
 8007af0:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
 8007af2:	2300      	movs	r3, #0
 8007af4:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8007af6:	683b      	ldr	r3, [r7, #0]
 8007af8:	681b      	ldr	r3, [r3, #0]
 8007afa:	2b01      	cmp	r3, #1
 8007afc:	d027      	beq.n	8007b4e <FMC_SDRAM_Init+0x6a>
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8007afe:	687b      	ldr	r3, [r7, #4]
 8007b00:	681b      	ldr	r3, [r3, #0]
 8007b02:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8007b04:	68fa      	ldr	r2, [r7, #12]
 8007b06:	4b2f      	ldr	r3, [pc, #188]	; (8007bc4 <FMC_SDRAM_Init+0xe0>)
 8007b08:	4013      	ands	r3, r2
 8007b0a:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8007b0c:	683b      	ldr	r3, [r7, #0]
 8007b0e:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
 8007b10:	683b      	ldr	r3, [r7, #0]
 8007b12:	689b      	ldr	r3, [r3, #8]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8007b14:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
 8007b16:	683b      	ldr	r3, [r7, #0]
 8007b18:	68db      	ldr	r3, [r3, #12]
                        Init->RowBitsNumber      |\
 8007b1a:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
 8007b1c:	683b      	ldr	r3, [r7, #0]
 8007b1e:	691b      	ldr	r3, [r3, #16]
                        Init->MemoryDataWidth    |\
 8007b20:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
 8007b22:	683b      	ldr	r3, [r7, #0]
 8007b24:	695b      	ldr	r3, [r3, #20]
                        Init->InternalBankNumber |\
 8007b26:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
 8007b28:	683b      	ldr	r3, [r7, #0]
 8007b2a:	699b      	ldr	r3, [r3, #24]
                        Init->CASLatency         |\
 8007b2c:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
 8007b2e:	683b      	ldr	r3, [r7, #0]
 8007b30:	69db      	ldr	r3, [r3, #28]
                        Init->WriteProtection    |\
 8007b32:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
 8007b34:	683b      	ldr	r3, [r7, #0]
 8007b36:	6a1b      	ldr	r3, [r3, #32]
                        Init->SDClockPeriod      |\
 8007b38:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay
 8007b3a:	683b      	ldr	r3, [r7, #0]
 8007b3c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
 8007b3e:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8007b40:	68fa      	ldr	r2, [r7, #12]
 8007b42:	4313      	orrs	r3, r2
 8007b44:	60fb      	str	r3, [r7, #12]
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8007b46:	687b      	ldr	r3, [r7, #4]
 8007b48:	68fa      	ldr	r2, [r7, #12]
 8007b4a:	601a      	str	r2, [r3, #0]
 8007b4c:	e032      	b.n	8007bb4 <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8007b4e:	687b      	ldr	r3, [r7, #4]
 8007b50:	681b      	ldr	r3, [r3, #0]
 8007b52:	60fb      	str	r3, [r7, #12]
    
    /* Clear SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 8007b54:	68fb      	ldr	r3, [r7, #12]
 8007b56:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8007b5a:	60fb      	str	r3, [r7, #12]
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8007b5c:	683b      	ldr	r3, [r7, #0]
 8007b5e:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
 8007b60:	683b      	ldr	r3, [r7, #0]
 8007b62:	6a1b      	ldr	r3, [r3, #32]
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8007b64:	431a      	orrs	r2, r3
                        Init->ReadPipeDelay);
 8007b66:	683b      	ldr	r3, [r7, #0]
 8007b68:	6a5b      	ldr	r3, [r3, #36]	; 0x24
                        Init->ReadBurst          |\
 8007b6a:	4313      	orrs	r3, r2
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8007b6c:	68fa      	ldr	r2, [r7, #12]
 8007b6e:	4313      	orrs	r3, r2
 8007b70:	60fb      	str	r3, [r7, #12]
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 8007b72:	687b      	ldr	r3, [r7, #4]
 8007b74:	685b      	ldr	r3, [r3, #4]
 8007b76:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8007b78:	68ba      	ldr	r2, [r7, #8]
 8007b7a:	4b12      	ldr	r3, [pc, #72]	; (8007bc4 <FMC_SDRAM_Init+0xe0>)
 8007b7c:	4013      	ands	r3, r2
 8007b7e:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8007b80:	683b      	ldr	r3, [r7, #0]
 8007b82:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber       |\
 8007b84:	683b      	ldr	r3, [r7, #0]
 8007b86:	689b      	ldr	r3, [r3, #8]
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8007b88:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth     |\
 8007b8a:	683b      	ldr	r3, [r7, #0]
 8007b8c:	68db      	ldr	r3, [r3, #12]
                       Init->RowBitsNumber       |\
 8007b8e:	431a      	orrs	r2, r3
                       Init->InternalBankNumber  |\
 8007b90:	683b      	ldr	r3, [r7, #0]
 8007b92:	691b      	ldr	r3, [r3, #16]
                       Init->MemoryDataWidth     |\
 8007b94:	431a      	orrs	r2, r3
                       Init->CASLatency          |\
 8007b96:	683b      	ldr	r3, [r7, #0]
 8007b98:	695b      	ldr	r3, [r3, #20]
                       Init->InternalBankNumber  |\
 8007b9a:	431a      	orrs	r2, r3
                       Init->WriteProtection);
 8007b9c:	683b      	ldr	r3, [r7, #0]
 8007b9e:	699b      	ldr	r3, [r3, #24]
                       Init->CASLatency          |\
 8007ba0:	4313      	orrs	r3, r2
    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8007ba2:	68ba      	ldr	r2, [r7, #8]
 8007ba4:	4313      	orrs	r3, r2
 8007ba6:	60bb      	str	r3, [r7, #8]

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8007ba8:	687b      	ldr	r3, [r7, #4]
 8007baa:	68fa      	ldr	r2, [r7, #12]
 8007bac:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 8007bae:	687b      	ldr	r3, [r7, #4]
 8007bb0:	68ba      	ldr	r2, [r7, #8]
 8007bb2:	605a      	str	r2, [r3, #4]
  }
  
  return HAL_OK;
 8007bb4:	2300      	movs	r3, #0
}
 8007bb6:	4618      	mov	r0, r3
 8007bb8:	3714      	adds	r7, #20
 8007bba:	46bd      	mov	sp, r7
 8007bbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007bc0:	4770      	bx	lr
 8007bc2:	bf00      	nop
 8007bc4:	ffff8000 	.word	0xffff8000

08007bc8 <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 8007bc8:	b480      	push	{r7}
 8007bca:	b087      	sub	sp, #28
 8007bcc:	af00      	add	r7, sp, #0
 8007bce:	60f8      	str	r0, [r7, #12]
 8007bd0:	60b9      	str	r1, [r7, #8]
 8007bd2:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
 8007bd4:	2300      	movs	r3, #0
 8007bd6:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
 8007bd8:	2300      	movs	r3, #0
 8007bda:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 8007bdc:	687b      	ldr	r3, [r7, #4]
 8007bde:	2b01      	cmp	r3, #1
 8007be0:	d02e      	beq.n	8007c40 <FMC_SDRAM_Timing_Init+0x78>
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8007be2:	68fb      	ldr	r3, [r7, #12]
 8007be4:	689b      	ldr	r3, [r3, #8]
 8007be6:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8007be8:	697b      	ldr	r3, [r7, #20]
 8007bea:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8007bee:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007bf0:	68bb      	ldr	r3, [r7, #8]
 8007bf2:	681b      	ldr	r3, [r3, #0]
 8007bf4:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8007bf6:	68bb      	ldr	r3, [r7, #8]
 8007bf8:	685b      	ldr	r3, [r3, #4]
 8007bfa:	3b01      	subs	r3, #1
 8007bfc:	011b      	lsls	r3, r3, #4
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007bfe:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8007c00:	68bb      	ldr	r3, [r7, #8]
 8007c02:	689b      	ldr	r3, [r3, #8]
 8007c04:	3b01      	subs	r3, #1
 8007c06:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8007c08:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 8007c0a:	68bb      	ldr	r3, [r7, #8]
 8007c0c:	68db      	ldr	r3, [r3, #12]
 8007c0e:	3b01      	subs	r3, #1
 8007c10:	031b      	lsls	r3, r3, #12
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8007c12:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8007c14:	68bb      	ldr	r3, [r7, #8]
 8007c16:	691b      	ldr	r3, [r3, #16]
 8007c18:	3b01      	subs	r3, #1
 8007c1a:	041b      	lsls	r3, r3, #16
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 8007c1c:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
 8007c1e:	68bb      	ldr	r3, [r7, #8]
 8007c20:	695b      	ldr	r3, [r3, #20]
 8007c22:	3b01      	subs	r3, #1
 8007c24:	051b      	lsls	r3, r3, #20
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8007c26:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1) << 24));
 8007c28:	68bb      	ldr	r3, [r7, #8]
 8007c2a:	699b      	ldr	r3, [r3, #24]
 8007c2c:	3b01      	subs	r3, #1
 8007c2e:	061b      	lsls	r3, r3, #24
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007c30:	4313      	orrs	r3, r2
 8007c32:	697a      	ldr	r2, [r7, #20]
 8007c34:	4313      	orrs	r3, r2
 8007c36:	617b      	str	r3, [r7, #20]
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8007c38:	68fb      	ldr	r3, [r7, #12]
 8007c3a:	697a      	ldr	r2, [r7, #20]
 8007c3c:	609a      	str	r2, [r3, #8]
 8007c3e:	e039      	b.n	8007cb4 <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8007c40:	68fb      	ldr	r3, [r7, #12]
 8007c42:	689b      	ldr	r3, [r3, #8]
 8007c44:	617b      	str	r3, [r7, #20]
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8007c46:	697a      	ldr	r2, [r7, #20]
 8007c48:	4b1e      	ldr	r3, [pc, #120]	; (8007cc4 <FMC_SDRAM_Timing_Init+0xfc>)
 8007c4a:	4013      	ands	r3, r2
 8007c4c:	617b      	str	r3, [r7, #20]
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8007c4e:	68bb      	ldr	r3, [r7, #8]
 8007c50:	68db      	ldr	r3, [r3, #12]
 8007c52:	3b01      	subs	r3, #1
 8007c54:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
 8007c56:	68bb      	ldr	r3, [r7, #8]
 8007c58:	695b      	ldr	r3, [r3, #20]
 8007c5a:	3b01      	subs	r3, #1
 8007c5c:	051b      	lsls	r3, r3, #20
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8007c5e:	4313      	orrs	r3, r2
 8007c60:	697a      	ldr	r2, [r7, #20]
 8007c62:	4313      	orrs	r3, r2
 8007c64:	617b      	str	r3, [r7, #20]
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 8007c66:	68fb      	ldr	r3, [r7, #12]
 8007c68:	68db      	ldr	r3, [r3, #12]
 8007c6a:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8007c6c:	693b      	ldr	r3, [r7, #16]
 8007c6e:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8007c72:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007c74:	68bb      	ldr	r3, [r7, #8]
 8007c76:	681b      	ldr	r3, [r3, #0]
 8007c78:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 8007c7a:	68bb      	ldr	r3, [r7, #8]
 8007c7c:	685b      	ldr	r3, [r3, #4]
 8007c7e:	3b01      	subs	r3, #1
 8007c80:	011b      	lsls	r3, r3, #4
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007c82:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 8007c84:	68bb      	ldr	r3, [r7, #8]
 8007c86:	689b      	ldr	r3, [r3, #8]
 8007c88:	3b01      	subs	r3, #1
 8007c8a:	021b      	lsls	r3, r3, #8
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 8007c8c:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
 8007c8e:	68bb      	ldr	r3, [r7, #8]
 8007c90:	691b      	ldr	r3, [r3, #16]
 8007c92:	3b01      	subs	r3, #1
 8007c94:	041b      	lsls	r3, r3, #16
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 8007c96:	431a      	orrs	r2, r3
                       (((Timing->RCDDelay)-1) << 24));   
 8007c98:	68bb      	ldr	r3, [r7, #8]
 8007c9a:	699b      	ldr	r3, [r3, #24]
 8007c9c:	3b01      	subs	r3, #1
 8007c9e:	061b      	lsls	r3, r3, #24
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8007ca0:	4313      	orrs	r3, r2
 8007ca2:	693a      	ldr	r2, [r7, #16]
 8007ca4:	4313      	orrs	r3, r2
 8007ca6:	613b      	str	r3, [r7, #16]

    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8007ca8:	68fb      	ldr	r3, [r7, #12]
 8007caa:	697a      	ldr	r2, [r7, #20]
 8007cac:	609a      	str	r2, [r3, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 8007cae:	68fb      	ldr	r3, [r7, #12]
 8007cb0:	693a      	ldr	r2, [r7, #16]
 8007cb2:	60da      	str	r2, [r3, #12]
  }
  
  return HAL_OK;
 8007cb4:	2300      	movs	r3, #0
}
 8007cb6:	4618      	mov	r0, r3
 8007cb8:	371c      	adds	r7, #28
 8007cba:	46bd      	mov	sp, r7
 8007cbc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007cc0:	4770      	bx	lr
 8007cc2:	bf00      	nop
 8007cc4:	ff0f0fff 	.word	0xff0f0fff

08007cc8 <FMC_SDRAM_SendCommand>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Timeout Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8007cc8:	b480      	push	{r7}
 8007cca:	b087      	sub	sp, #28
 8007ccc:	af00      	add	r7, sp, #0
 8007cce:	60f8      	str	r0, [r7, #12]
 8007cd0:	60b9      	str	r1, [r7, #8]
 8007cd2:	607a      	str	r2, [r7, #4]
  __IO uint32_t tmpr = 0;
 8007cd4:	2300      	movs	r3, #0
 8007cd6:	617b      	str	r3, [r7, #20]
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8007cd8:	68bb      	ldr	r3, [r7, #8]
 8007cda:	681a      	ldr	r2, [r3, #0]
                    (Command->CommandTarget)                |\
 8007cdc:	68bb      	ldr	r3, [r7, #8]
 8007cde:	685b      	ldr	r3, [r3, #4]
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8007ce0:	431a      	orrs	r2, r3
                    (((Command->AutoRefreshNumber)-1) << 5) |\
 8007ce2:	68bb      	ldr	r3, [r7, #8]
 8007ce4:	689b      	ldr	r3, [r3, #8]
 8007ce6:	3b01      	subs	r3, #1
 8007ce8:	015b      	lsls	r3, r3, #5
                    (Command->CommandTarget)                |\
 8007cea:	431a      	orrs	r2, r3
                    ((Command->ModeRegisterDefinition) << 9)
 8007cec:	68bb      	ldr	r3, [r7, #8]
 8007cee:	68db      	ldr	r3, [r3, #12]
 8007cf0:	025b      	lsls	r3, r3, #9
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8007cf2:	4313      	orrs	r3, r2
 8007cf4:	617b      	str	r3, [r7, #20]
                    );
    
  Device->SDCMR = tmpr;
 8007cf6:	697a      	ldr	r2, [r7, #20]
 8007cf8:	68fb      	ldr	r3, [r7, #12]
 8007cfa:	611a      	str	r2, [r3, #16]
  
  return HAL_OK;  
 8007cfc:	2300      	movs	r3, #0
}
 8007cfe:	4618      	mov	r0, r3
 8007d00:	371c      	adds	r7, #28
 8007d02:	46bd      	mov	sp, r7
 8007d04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d08:	4770      	bx	lr

08007d0a <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance  
  * @param  RefreshRate The SDRAM refresh rate value.       
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 8007d0a:	b480      	push	{r7}
 8007d0c:	b083      	sub	sp, #12
 8007d0e:	af00      	add	r7, sp, #0
 8007d10:	6078      	str	r0, [r7, #4]
 8007d12:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1);
 8007d14:	687b      	ldr	r3, [r7, #4]
 8007d16:	695a      	ldr	r2, [r3, #20]
 8007d18:	683b      	ldr	r3, [r7, #0]
 8007d1a:	005b      	lsls	r3, r3, #1
 8007d1c:	431a      	orrs	r2, r3
 8007d1e:	687b      	ldr	r3, [r7, #4]
 8007d20:	615a      	str	r2, [r3, #20]
  
  return HAL_OK;   
 8007d22:	2300      	movs	r3, #0
}
 8007d24:	4618      	mov	r0, r3
 8007d26:	370c      	adds	r7, #12
 8007d28:	46bd      	mov	sp, r7
 8007d2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d2e:	4770      	bx	lr

08007d30 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8007d30:	b084      	sub	sp, #16
 8007d32:	b580      	push	{r7, lr}
 8007d34:	b084      	sub	sp, #16
 8007d36:	af00      	add	r7, sp, #0
 8007d38:	6078      	str	r0, [r7, #4]
 8007d3a:	f107 001c 	add.w	r0, r7, #28
 8007d3e:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 8007d42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8007d44:	2b01      	cmp	r3, #1
 8007d46:	d120      	bne.n	8007d8a <USB_CoreInit+0x5a>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8007d48:	687b      	ldr	r3, [r7, #4]
 8007d4a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d4c:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
 8007d50:	687b      	ldr	r3, [r7, #4]
 8007d52:	639a      	str	r2, [r3, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 8007d54:	687b      	ldr	r3, [r7, #4]
 8007d56:	68da      	ldr	r2, [r3, #12]
 8007d58:	4b20      	ldr	r3, [pc, #128]	; (8007ddc <USB_CoreInit+0xac>)
 8007d5a:	4013      	ands	r3, r2
 8007d5c:	687a      	ldr	r2, [r7, #4]
 8007d5e:	60d3      	str	r3, [r2, #12]

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 8007d60:	687b      	ldr	r3, [r7, #4]
 8007d62:	68db      	ldr	r3, [r3, #12]
 8007d64:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8007d68:	687b      	ldr	r3, [r7, #4]
 8007d6a:	60da      	str	r2, [r3, #12]
    if (cfg.use_external_vbus == 1U)
 8007d6c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8007d6e:	2b01      	cmp	r3, #1
 8007d70:	d105      	bne.n	8007d7e <USB_CoreInit+0x4e>
    {
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 8007d72:	687b      	ldr	r3, [r7, #4]
 8007d74:	68db      	ldr	r3, [r3, #12]
 8007d76:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
 8007d7a:	687b      	ldr	r3, [r7, #4]
 8007d7c:	60da      	str	r2, [r3, #12]
    }
    /* Reset after a PHY select  */
    ret = USB_CoreReset(USBx);
 8007d7e:	6878      	ldr	r0, [r7, #4]
 8007d80:	f000 f8fc 	bl	8007f7c <USB_CoreReset>
 8007d84:	4603      	mov	r3, r0
 8007d86:	73fb      	strb	r3, [r7, #15]
 8007d88:	e010      	b.n	8007dac <USB_CoreInit+0x7c>
  }
#endif
  else /* FS interface (embedded Phy) */
  {
    /* Select FS Embedded PHY */
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 8007d8a:	687b      	ldr	r3, [r7, #4]
 8007d8c:	68db      	ldr	r3, [r3, #12]
 8007d8e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 8007d92:	687b      	ldr	r3, [r7, #4]
 8007d94:	60da      	str	r2, [r3, #12]

    /* Reset after a PHY select and set Host mode */
    ret = USB_CoreReset(USBx);
 8007d96:	6878      	ldr	r0, [r7, #4]
 8007d98:	f000 f8f0 	bl	8007f7c <USB_CoreReset>
 8007d9c:	4603      	mov	r3, r0
 8007d9e:	73fb      	strb	r3, [r7, #15]

    /* Activate the USB Transceiver */
    USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8007da0:	687b      	ldr	r3, [r7, #4]
 8007da2:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007da4:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
 8007da8:	687b      	ldr	r3, [r7, #4]
 8007daa:	639a      	str	r2, [r3, #56]	; 0x38
  }

  if (cfg.dma_enable == 1U)
 8007dac:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8007dae:	2b01      	cmp	r3, #1
 8007db0:	d10b      	bne.n	8007dca <USB_CoreInit+0x9a>
  {
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8007db2:	687b      	ldr	r3, [r7, #4]
 8007db4:	689b      	ldr	r3, [r3, #8]
 8007db6:	f043 0206 	orr.w	r2, r3, #6
 8007dba:	687b      	ldr	r3, [r7, #4]
 8007dbc:	609a      	str	r2, [r3, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 8007dbe:	687b      	ldr	r3, [r7, #4]
 8007dc0:	689b      	ldr	r3, [r3, #8]
 8007dc2:	f043 0220 	orr.w	r2, r3, #32
 8007dc6:	687b      	ldr	r3, [r7, #4]
 8007dc8:	609a      	str	r2, [r3, #8]
  }

  return ret;
 8007dca:	7bfb      	ldrb	r3, [r7, #15]
}
 8007dcc:	4618      	mov	r0, r3
 8007dce:	3710      	adds	r7, #16
 8007dd0:	46bd      	mov	sp, r7
 8007dd2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 8007dd6:	b004      	add	sp, #16
 8007dd8:	4770      	bx	lr
 8007dda:	bf00      	nop
 8007ddc:	ffbdffbf 	.word	0xffbdffbf

08007de0 <USB_DisableGlobalInt>:
  *         Disable the controller's Global Int in the AHB Config reg
  * @param  USBx  Selected device
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DisableGlobalInt(USB_OTG_GlobalTypeDef *USBx)
{
 8007de0:	b480      	push	{r7}
 8007de2:	b083      	sub	sp, #12
 8007de4:	af00      	add	r7, sp, #0
 8007de6:	6078      	str	r0, [r7, #4]
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8007de8:	687b      	ldr	r3, [r7, #4]
 8007dea:	689b      	ldr	r3, [r3, #8]
 8007dec:	f023 0201 	bic.w	r2, r3, #1
 8007df0:	687b      	ldr	r3, [r7, #4]
 8007df2:	609a      	str	r2, [r3, #8]
  return HAL_OK;
 8007df4:	2300      	movs	r3, #0
}
 8007df6:	4618      	mov	r0, r3
 8007df8:	370c      	adds	r7, #12
 8007dfa:	46bd      	mov	sp, r7
 8007dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e00:	4770      	bx	lr

08007e02 <USB_SetCurrentMode>:
  *            @arg USB_HOST_MODE: Host mode
  *            @arg USB_DRD_MODE: Dual Role Device mode
  * @retval HAL status
  */
HAL_StatusTypeDef USB_SetCurrentMode(USB_OTG_GlobalTypeDef *USBx, USB_OTG_ModeTypeDef mode)
{
 8007e02:	b580      	push	{r7, lr}
 8007e04:	b082      	sub	sp, #8
 8007e06:	af00      	add	r7, sp, #0
 8007e08:	6078      	str	r0, [r7, #4]
 8007e0a:	460b      	mov	r3, r1
 8007e0c:	70fb      	strb	r3, [r7, #3]
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 8007e0e:	687b      	ldr	r3, [r7, #4]
 8007e10:	68db      	ldr	r3, [r3, #12]
 8007e12:	f023 42c0 	bic.w	r2, r3, #1610612736	; 0x60000000
 8007e16:	687b      	ldr	r3, [r7, #4]
 8007e18:	60da      	str	r2, [r3, #12]

  if (mode == USB_HOST_MODE)
 8007e1a:	78fb      	ldrb	r3, [r7, #3]
 8007e1c:	2b01      	cmp	r3, #1
 8007e1e:	d106      	bne.n	8007e2e <USB_SetCurrentMode+0x2c>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 8007e20:	687b      	ldr	r3, [r7, #4]
 8007e22:	68db      	ldr	r3, [r3, #12]
 8007e24:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
 8007e28:	687b      	ldr	r3, [r7, #4]
 8007e2a:	60da      	str	r2, [r3, #12]
 8007e2c:	e00b      	b.n	8007e46 <USB_SetCurrentMode+0x44>
  }
  else if (mode == USB_DEVICE_MODE)
 8007e2e:	78fb      	ldrb	r3, [r7, #3]
 8007e30:	2b00      	cmp	r3, #0
 8007e32:	d106      	bne.n	8007e42 <USB_SetCurrentMode+0x40>
  {
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 8007e34:	687b      	ldr	r3, [r7, #4]
 8007e36:	68db      	ldr	r3, [r3, #12]
 8007e38:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
 8007e3c:	687b      	ldr	r3, [r7, #4]
 8007e3e:	60da      	str	r2, [r3, #12]
 8007e40:	e001      	b.n	8007e46 <USB_SetCurrentMode+0x44>
  }
  else
  {
    return HAL_ERROR;
 8007e42:	2301      	movs	r3, #1
 8007e44:	e003      	b.n	8007e4e <USB_SetCurrentMode+0x4c>
  }
  HAL_Delay(50U);
 8007e46:	2032      	movs	r0, #50	; 0x32
 8007e48:	f7f8 fbf8 	bl	800063c <HAL_Delay>

  return HAL_OK;
 8007e4c:	2300      	movs	r3, #0
}
 8007e4e:	4618      	mov	r0, r3
 8007e50:	3708      	adds	r7, #8
 8007e52:	46bd      	mov	sp, r7
 8007e54:	bd80      	pop	{r7, pc}
	...

08007e58 <USB_FlushTxFifo>:
  *         This parameter can be a value from 1 to 15
            15 means Flush all Tx FIFOs
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushTxFifo(USB_OTG_GlobalTypeDef *USBx, uint32_t num)
{
 8007e58:	b480      	push	{r7}
 8007e5a:	b085      	sub	sp, #20
 8007e5c:	af00      	add	r7, sp, #0
 8007e5e:	6078      	str	r0, [r7, #4]
 8007e60:	6039      	str	r1, [r7, #0]
  uint32_t count = 0U;
 8007e62:	2300      	movs	r3, #0
 8007e64:	60fb      	str	r3, [r7, #12]

  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8007e66:	683b      	ldr	r3, [r7, #0]
 8007e68:	019b      	lsls	r3, r3, #6
 8007e6a:	f043 0220 	orr.w	r2, r3, #32
 8007e6e:	687b      	ldr	r3, [r7, #4]
 8007e70:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8007e72:	68fb      	ldr	r3, [r7, #12]
 8007e74:	3301      	adds	r3, #1
 8007e76:	60fb      	str	r3, [r7, #12]
 8007e78:	68fb      	ldr	r3, [r7, #12]
 8007e7a:	4a09      	ldr	r2, [pc, #36]	; (8007ea0 <USB_FlushTxFifo+0x48>)
 8007e7c:	4293      	cmp	r3, r2
 8007e7e:	d901      	bls.n	8007e84 <USB_FlushTxFifo+0x2c>
    {
      return HAL_TIMEOUT;
 8007e80:	2303      	movs	r3, #3
 8007e82:	e006      	b.n	8007e92 <USB_FlushTxFifo+0x3a>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8007e84:	687b      	ldr	r3, [r7, #4]
 8007e86:	691b      	ldr	r3, [r3, #16]
 8007e88:	f003 0320 	and.w	r3, r3, #32
 8007e8c:	2b20      	cmp	r3, #32
 8007e8e:	d0f0      	beq.n	8007e72 <USB_FlushTxFifo+0x1a>

  return HAL_OK;
 8007e90:	2300      	movs	r3, #0
}
 8007e92:	4618      	mov	r0, r3
 8007e94:	3714      	adds	r7, #20
 8007e96:	46bd      	mov	sp, r7
 8007e98:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007e9c:	4770      	bx	lr
 8007e9e:	bf00      	nop
 8007ea0:	00030d40 	.word	0x00030d40

08007ea4 <USB_FlushRxFifo>:
  * @brief  USB_FlushRxFifo : Flush Rx FIFO
  * @param  USBx  Selected device
  * @retval HAL status
  */
HAL_StatusTypeDef USB_FlushRxFifo(USB_OTG_GlobalTypeDef *USBx)
{
 8007ea4:	b480      	push	{r7}
 8007ea6:	b085      	sub	sp, #20
 8007ea8:	af00      	add	r7, sp, #0
 8007eaa:	6078      	str	r0, [r7, #4]
  uint32_t count = 0;
 8007eac:	2300      	movs	r3, #0
 8007eae:	60fb      	str	r3, [r7, #12]

  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8007eb0:	687b      	ldr	r3, [r7, #4]
 8007eb2:	2210      	movs	r2, #16
 8007eb4:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8007eb6:	68fb      	ldr	r3, [r7, #12]
 8007eb8:	3301      	adds	r3, #1
 8007eba:	60fb      	str	r3, [r7, #12]
 8007ebc:	68fb      	ldr	r3, [r7, #12]
 8007ebe:	4a09      	ldr	r2, [pc, #36]	; (8007ee4 <USB_FlushRxFifo+0x40>)
 8007ec0:	4293      	cmp	r3, r2
 8007ec2:	d901      	bls.n	8007ec8 <USB_FlushRxFifo+0x24>
    {
      return HAL_TIMEOUT;
 8007ec4:	2303      	movs	r3, #3
 8007ec6:	e006      	b.n	8007ed6 <USB_FlushRxFifo+0x32>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8007ec8:	687b      	ldr	r3, [r7, #4]
 8007eca:	691b      	ldr	r3, [r3, #16]
 8007ecc:	f003 0310 	and.w	r3, r3, #16
 8007ed0:	2b10      	cmp	r3, #16
 8007ed2:	d0f0      	beq.n	8007eb6 <USB_FlushRxFifo+0x12>

  return HAL_OK;
 8007ed4:	2300      	movs	r3, #0
}
 8007ed6:	4618      	mov	r0, r3
 8007ed8:	3714      	adds	r7, #20
 8007eda:	46bd      	mov	sp, r7
 8007edc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ee0:	4770      	bx	lr
 8007ee2:	bf00      	nop
 8007ee4:	00030d40 	.word	0x00030d40

08007ee8 <USB_ReadPacket>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval pointer to destination buffer
  */
void *USB_ReadPacket(USB_OTG_GlobalTypeDef *USBx, uint8_t *dest, uint16_t len)
{
 8007ee8:	b480      	push	{r7}
 8007eea:	b089      	sub	sp, #36	; 0x24
 8007eec:	af00      	add	r7, sp, #0
 8007eee:	60f8      	str	r0, [r7, #12]
 8007ef0:	60b9      	str	r1, [r7, #8]
 8007ef2:	4613      	mov	r3, r2
 8007ef4:	80fb      	strh	r3, [r7, #6]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007ef6:	68fb      	ldr	r3, [r7, #12]
 8007ef8:	617b      	str	r3, [r7, #20]
  uint32_t *pDest = (uint32_t *)dest;
 8007efa:	68bb      	ldr	r3, [r7, #8]
 8007efc:	61fb      	str	r3, [r7, #28]
  uint32_t i;
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 8007efe:	88fb      	ldrh	r3, [r7, #6]
 8007f00:	3303      	adds	r3, #3
 8007f02:	089b      	lsrs	r3, r3, #2
 8007f04:	613b      	str	r3, [r7, #16]

  for (i = 0U; i < count32b; i++)
 8007f06:	2300      	movs	r3, #0
 8007f08:	61bb      	str	r3, [r7, #24]
 8007f0a:	e00b      	b.n	8007f24 <USB_ReadPacket+0x3c>
  {
    *(__packed uint32_t *)pDest = USBx_DFIFO(0U);
 8007f0c:	697b      	ldr	r3, [r7, #20]
 8007f0e:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8007f12:	681a      	ldr	r2, [r3, #0]
 8007f14:	69fb      	ldr	r3, [r7, #28]
 8007f16:	601a      	str	r2, [r3, #0]
    pDest++;
 8007f18:	69fb      	ldr	r3, [r7, #28]
 8007f1a:	3304      	adds	r3, #4
 8007f1c:	61fb      	str	r3, [r7, #28]
  for (i = 0U; i < count32b; i++)
 8007f1e:	69bb      	ldr	r3, [r7, #24]
 8007f20:	3301      	adds	r3, #1
 8007f22:	61bb      	str	r3, [r7, #24]
 8007f24:	69ba      	ldr	r2, [r7, #24]
 8007f26:	693b      	ldr	r3, [r7, #16]
 8007f28:	429a      	cmp	r2, r3
 8007f2a:	d3ef      	bcc.n	8007f0c <USB_ReadPacket+0x24>
  }

  return ((void *)pDest);
 8007f2c:	69fb      	ldr	r3, [r7, #28]
}
 8007f2e:	4618      	mov	r0, r3
 8007f30:	3724      	adds	r7, #36	; 0x24
 8007f32:	46bd      	mov	sp, r7
 8007f34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f38:	4770      	bx	lr

08007f3a <USB_ReadInterrupts>:
  * @brief  USB_ReadInterrupts: return the global USB interrupt status
  * @param  USBx  Selected device
  * @retval HAL status
  */
uint32_t  USB_ReadInterrupts(USB_OTG_GlobalTypeDef *USBx)
{
 8007f3a:	b480      	push	{r7}
 8007f3c:	b085      	sub	sp, #20
 8007f3e:	af00      	add	r7, sp, #0
 8007f40:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;

  tmpreg = USBx->GINTSTS;
 8007f42:	687b      	ldr	r3, [r7, #4]
 8007f44:	695b      	ldr	r3, [r3, #20]
 8007f46:	60fb      	str	r3, [r7, #12]
  tmpreg &= USBx->GINTMSK;
 8007f48:	687b      	ldr	r3, [r7, #4]
 8007f4a:	699b      	ldr	r3, [r3, #24]
 8007f4c:	68fa      	ldr	r2, [r7, #12]
 8007f4e:	4013      	ands	r3, r2
 8007f50:	60fb      	str	r3, [r7, #12]

  return tmpreg;
 8007f52:	68fb      	ldr	r3, [r7, #12]
}
 8007f54:	4618      	mov	r0, r3
 8007f56:	3714      	adds	r7, #20
 8007f58:	46bd      	mov	sp, r7
 8007f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f5e:	4770      	bx	lr

08007f60 <USB_GetMode>:
  *          This parameter can be one of these values:
  *           0 : Host
  *           1 : Device
  */
uint32_t USB_GetMode(USB_OTG_GlobalTypeDef *USBx)
{
 8007f60:	b480      	push	{r7}
 8007f62:	b083      	sub	sp, #12
 8007f64:	af00      	add	r7, sp, #0
 8007f66:	6078      	str	r0, [r7, #4]
  return ((USBx->GINTSTS) & 0x1U);
 8007f68:	687b      	ldr	r3, [r7, #4]
 8007f6a:	695b      	ldr	r3, [r3, #20]
 8007f6c:	f003 0301 	and.w	r3, r3, #1
}
 8007f70:	4618      	mov	r0, r3
 8007f72:	370c      	adds	r7, #12
 8007f74:	46bd      	mov	sp, r7
 8007f76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f7a:	4770      	bx	lr

08007f7c <USB_CoreReset>:
  * @brief  Reset the USB Core (needed after USB clock settings change)
  * @param  USBx  Selected device
  * @retval HAL status
  */
static HAL_StatusTypeDef USB_CoreReset(USB_OTG_GlobalTypeDef *USBx)
{
 8007f7c:	b480      	push	{r7}
 8007f7e:	b085      	sub	sp, #20
 8007f80:	af00      	add	r7, sp, #0
 8007f82:	6078      	str	r0, [r7, #4]
  uint32_t count = 0U;
 8007f84:	2300      	movs	r3, #0
 8007f86:	60fb      	str	r3, [r7, #12]

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 8007f88:	68fb      	ldr	r3, [r7, #12]
 8007f8a:	3301      	adds	r3, #1
 8007f8c:	60fb      	str	r3, [r7, #12]
 8007f8e:	68fb      	ldr	r3, [r7, #12]
 8007f90:	4a13      	ldr	r2, [pc, #76]	; (8007fe0 <USB_CoreReset+0x64>)
 8007f92:	4293      	cmp	r3, r2
 8007f94:	d901      	bls.n	8007f9a <USB_CoreReset+0x1e>
    {
      return HAL_TIMEOUT;
 8007f96:	2303      	movs	r3, #3
 8007f98:	e01b      	b.n	8007fd2 <USB_CoreReset+0x56>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8007f9a:	687b      	ldr	r3, [r7, #4]
 8007f9c:	691b      	ldr	r3, [r3, #16]
 8007f9e:	2b00      	cmp	r3, #0
 8007fa0:	daf2      	bge.n	8007f88 <USB_CoreReset+0xc>

  /* Core Soft Reset */
  count = 0U;
 8007fa2:	2300      	movs	r3, #0
 8007fa4:	60fb      	str	r3, [r7, #12]
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8007fa6:	687b      	ldr	r3, [r7, #4]
 8007fa8:	691b      	ldr	r3, [r3, #16]
 8007faa:	f043 0201 	orr.w	r2, r3, #1
 8007fae:	687b      	ldr	r3, [r7, #4]
 8007fb0:	611a      	str	r2, [r3, #16]

  do
  {
    if (++count > 200000U)
 8007fb2:	68fb      	ldr	r3, [r7, #12]
 8007fb4:	3301      	adds	r3, #1
 8007fb6:	60fb      	str	r3, [r7, #12]
 8007fb8:	68fb      	ldr	r3, [r7, #12]
 8007fba:	4a09      	ldr	r2, [pc, #36]	; (8007fe0 <USB_CoreReset+0x64>)
 8007fbc:	4293      	cmp	r3, r2
 8007fbe:	d901      	bls.n	8007fc4 <USB_CoreReset+0x48>
    {
      return HAL_TIMEOUT;
 8007fc0:	2303      	movs	r3, #3
 8007fc2:	e006      	b.n	8007fd2 <USB_CoreReset+0x56>
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8007fc4:	687b      	ldr	r3, [r7, #4]
 8007fc6:	691b      	ldr	r3, [r3, #16]
 8007fc8:	f003 0301 	and.w	r3, r3, #1
 8007fcc:	2b01      	cmp	r3, #1
 8007fce:	d0f0      	beq.n	8007fb2 <USB_CoreReset+0x36>

  return HAL_OK;
 8007fd0:	2300      	movs	r3, #0
}
 8007fd2:	4618      	mov	r0, r3
 8007fd4:	3714      	adds	r7, #20
 8007fd6:	46bd      	mov	sp, r7
 8007fd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007fdc:	4770      	bx	lr
 8007fde:	bf00      	nop
 8007fe0:	00030d40 	.word	0x00030d40

08007fe4 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8007fe4:	b084      	sub	sp, #16
 8007fe6:	b580      	push	{r7, lr}
 8007fe8:	b084      	sub	sp, #16
 8007fea:	af00      	add	r7, sp, #0
 8007fec:	6078      	str	r0, [r7, #4]
 8007fee:	f107 001c 	add.w	r0, r7, #28
 8007ff2:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  uint32_t USBx_BASE = (uint32_t)USBx;
 8007ff6:	687b      	ldr	r3, [r7, #4]
 8007ff8:	60bb      	str	r3, [r7, #8]
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 8007ffa:	68bb      	ldr	r3, [r7, #8]
 8007ffc:	f503 6360 	add.w	r3, r3, #3584	; 0xe00
 8008000:	461a      	mov	r2, r3
 8008002:	2300      	movs	r3, #0
 8008004:	6013      	str	r3, [r2, #0]

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 8008006:	687b      	ldr	r3, [r7, #4]
 8008008:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800800a:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
 800800e:	687b      	ldr	r3, [r7, #4]
 8008010:	639a      	str	r2, [r3, #56]	; 0x38

  if ((USBx->CID & (0x1U << 8)) != 0U)
 8008012:	687b      	ldr	r3, [r7, #4]
 8008014:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8008016:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800801a:	2b00      	cmp	r3, #0
 800801c:	d018      	beq.n	8008050 <USB_HostInit+0x6c>
  {
    if (cfg.speed == USB_OTG_SPEED_FULL)
 800801e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008020:	2b03      	cmp	r3, #3
 8008022:	d10a      	bne.n	800803a <USB_HostInit+0x56>
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 8008024:	68bb      	ldr	r3, [r7, #8]
 8008026:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800802a:	681b      	ldr	r3, [r3, #0]
 800802c:	68ba      	ldr	r2, [r7, #8]
 800802e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008032:	f043 0304 	orr.w	r3, r3, #4
 8008036:	6013      	str	r3, [r2, #0]
 8008038:	e014      	b.n	8008064 <USB_HostInit+0x80>
    }
    else
    {
      /* Set default Max speed support */
      USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 800803a:	68bb      	ldr	r3, [r7, #8]
 800803c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8008040:	681b      	ldr	r3, [r3, #0]
 8008042:	68ba      	ldr	r2, [r7, #8]
 8008044:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008048:	f023 0304 	bic.w	r3, r3, #4
 800804c:	6013      	str	r3, [r2, #0]
 800804e:	e009      	b.n	8008064 <USB_HostInit+0x80>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8008050:	68bb      	ldr	r3, [r7, #8]
 8008052:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8008056:	681b      	ldr	r3, [r3, #0]
 8008058:	68ba      	ldr	r2, [r7, #8]
 800805a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800805e:	f023 0304 	bic.w	r3, r3, #4
 8008062:	6013      	str	r3, [r2, #0]
  }

  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
 8008064:	2110      	movs	r1, #16
 8008066:	6878      	ldr	r0, [r7, #4]
 8008068:	f7ff fef6 	bl	8007e58 <USB_FlushTxFifo>
  (void)USB_FlushRxFifo(USBx);
 800806c:	6878      	ldr	r0, [r7, #4]
 800806e:	f7ff ff19 	bl	8007ea4 <USB_FlushRxFifo>

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 8008072:	2300      	movs	r3, #0
 8008074:	60fb      	str	r3, [r7, #12]
 8008076:	e015      	b.n	80080a4 <USB_HostInit+0xc0>
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 8008078:	68fb      	ldr	r3, [r7, #12]
 800807a:	015a      	lsls	r2, r3, #5
 800807c:	68bb      	ldr	r3, [r7, #8]
 800807e:	4413      	add	r3, r2
 8008080:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8008084:	461a      	mov	r2, r3
 8008086:	f04f 33ff 	mov.w	r3, #4294967295
 800808a:	6093      	str	r3, [r2, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 800808c:	68fb      	ldr	r3, [r7, #12]
 800808e:	015a      	lsls	r2, r3, #5
 8008090:	68bb      	ldr	r3, [r7, #8]
 8008092:	4413      	add	r3, r2
 8008094:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8008098:	461a      	mov	r2, r3
 800809a:	2300      	movs	r3, #0
 800809c:	60d3      	str	r3, [r2, #12]
  for (i = 0U; i < cfg.Host_channels; i++)
 800809e:	68fb      	ldr	r3, [r7, #12]
 80080a0:	3301      	adds	r3, #1
 80080a2:	60fb      	str	r3, [r7, #12]
 80080a4:	6a3b      	ldr	r3, [r7, #32]
 80080a6:	68fa      	ldr	r2, [r7, #12]
 80080a8:	429a      	cmp	r2, r3
 80080aa:	d3e5      	bcc.n	8008078 <USB_HostInit+0x94>
  }

  /* Enable VBUS driving */
  (void)USB_DriveVbus(USBx, 1U);
 80080ac:	2101      	movs	r1, #1
 80080ae:	6878      	ldr	r0, [r7, #4]
 80080b0:	f000 f882 	bl	80081b8 <USB_DriveVbus>

  HAL_Delay(200U);
 80080b4:	20c8      	movs	r0, #200	; 0xc8
 80080b6:	f7f8 fac1 	bl	800063c <HAL_Delay>

  /* Disable all interrupts. */
  USBx->GINTMSK = 0U;
 80080ba:	687b      	ldr	r3, [r7, #4]
 80080bc:	2200      	movs	r2, #0
 80080be:	619a      	str	r2, [r3, #24]

  /* Clear any pending interrupts */
  USBx->GINTSTS = 0xFFFFFFFFU;
 80080c0:	687b      	ldr	r3, [r7, #4]
 80080c2:	f04f 32ff 	mov.w	r2, #4294967295
 80080c6:	615a      	str	r2, [r3, #20]

  if ((USBx->CID & (0x1U << 8)) != 0U)
 80080c8:	687b      	ldr	r3, [r7, #4]
 80080ca:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80080cc:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80080d0:	2b00      	cmp	r3, #0
 80080d2:	d00b      	beq.n	80080ec <USB_HostInit+0x108>
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x200U;
 80080d4:	687b      	ldr	r3, [r7, #4]
 80080d6:	f44f 7200 	mov.w	r2, #512	; 0x200
 80080da:	625a      	str	r2, [r3, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 80080dc:	687b      	ldr	r3, [r7, #4]
 80080de:	4a14      	ldr	r2, [pc, #80]	; (8008130 <USB_HostInit+0x14c>)
 80080e0:	629a      	str	r2, [r3, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 80080e2:	687b      	ldr	r3, [r7, #4]
 80080e4:	4a13      	ldr	r2, [pc, #76]	; (8008134 <USB_HostInit+0x150>)
 80080e6:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
 80080ea:	e009      	b.n	8008100 <USB_HostInit+0x11c>
  }
  else
  {
    /* set Rx FIFO size */
    USBx->GRXFSIZ  = 0x80U;
 80080ec:	687b      	ldr	r3, [r7, #4]
 80080ee:	2280      	movs	r2, #128	; 0x80
 80080f0:	625a      	str	r2, [r3, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 80080f2:	687b      	ldr	r3, [r7, #4]
 80080f4:	4a10      	ldr	r2, [pc, #64]	; (8008138 <USB_HostInit+0x154>)
 80080f6:	629a      	str	r2, [r3, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 80080f8:	687b      	ldr	r3, [r7, #4]
 80080fa:	4a10      	ldr	r2, [pc, #64]	; (800813c <USB_HostInit+0x158>)
 80080fc:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
  }

  /* Enable the common interrupts */
  if (cfg.dma_enable == 0U)
 8008100:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008102:	2b00      	cmp	r3, #0
 8008104:	d105      	bne.n	8008112 <USB_HostInit+0x12e>
  {
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 8008106:	687b      	ldr	r3, [r7, #4]
 8008108:	699b      	ldr	r3, [r3, #24]
 800810a:	f043 0210 	orr.w	r2, r3, #16
 800810e:	687b      	ldr	r3, [r7, #4]
 8008110:	619a      	str	r2, [r3, #24]
  }

  /* Enable interrupts matching to the Host mode ONLY */
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 8008112:	687b      	ldr	r3, [r7, #4]
 8008114:	699a      	ldr	r2, [r3, #24]
 8008116:	4b0a      	ldr	r3, [pc, #40]	; (8008140 <USB_HostInit+0x15c>)
 8008118:	4313      	orrs	r3, r2
 800811a:	687a      	ldr	r2, [r7, #4]
 800811c:	6193      	str	r3, [r2, #24]
                    USB_OTG_GINTMSK_SOFM             | USB_OTG_GINTSTS_DISCINT | \
                    USB_OTG_GINTMSK_PXFRM_IISOOXFRM  | USB_OTG_GINTMSK_WUIM);

  return HAL_OK;
 800811e:	2300      	movs	r3, #0
}
 8008120:	4618      	mov	r0, r3
 8008122:	3710      	adds	r7, #16
 8008124:	46bd      	mov	sp, r7
 8008126:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800812a:	b004      	add	sp, #16
 800812c:	4770      	bx	lr
 800812e:	bf00      	nop
 8008130:	01000200 	.word	0x01000200
 8008134:	00e00300 	.word	0x00e00300
 8008138:	00600080 	.word	0x00600080
 800813c:	004000e0 	.word	0x004000e0
 8008140:	a3200008 	.word	0xa3200008

08008144 <USB_InitFSLSPClkSel>:
  *           HCFG_48_MHZ : Full Speed 48 MHz Clock
  *           HCFG_6_MHZ : Low Speed 6 MHz Clock
  * @retval HAL status
  */
HAL_StatusTypeDef USB_InitFSLSPClkSel(USB_OTG_GlobalTypeDef *USBx, uint8_t freq)
{
 8008144:	b480      	push	{r7}
 8008146:	b085      	sub	sp, #20
 8008148:	af00      	add	r7, sp, #0
 800814a:	6078      	str	r0, [r7, #4]
 800814c:	460b      	mov	r3, r1
 800814e:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8008150:	687b      	ldr	r3, [r7, #4]
 8008152:	60fb      	str	r3, [r7, #12]

  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 8008154:	68fb      	ldr	r3, [r7, #12]
 8008156:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800815a:	681b      	ldr	r3, [r3, #0]
 800815c:	68fa      	ldr	r2, [r7, #12]
 800815e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8008162:	f023 0303 	bic.w	r3, r3, #3
 8008166:	6013      	str	r3, [r2, #0]
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 8008168:	68fb      	ldr	r3, [r7, #12]
 800816a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800816e:	681a      	ldr	r2, [r3, #0]
 8008170:	78fb      	ldrb	r3, [r7, #3]
 8008172:	f003 0303 	and.w	r3, r3, #3
 8008176:	68f9      	ldr	r1, [r7, #12]
 8008178:	f501 6180 	add.w	r1, r1, #1024	; 0x400
 800817c:	4313      	orrs	r3, r2
 800817e:	600b      	str	r3, [r1, #0]

  if (freq == HCFG_48_MHZ)
 8008180:	78fb      	ldrb	r3, [r7, #3]
 8008182:	2b01      	cmp	r3, #1
 8008184:	d107      	bne.n	8008196 <USB_InitFSLSPClkSel+0x52>
  {
    USBx_HOST->HFIR = 48000U;
 8008186:	68fb      	ldr	r3, [r7, #12]
 8008188:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800818c:	461a      	mov	r2, r3
 800818e:	f64b 3380 	movw	r3, #48000	; 0xbb80
 8008192:	6053      	str	r3, [r2, #4]
 8008194:	e009      	b.n	80081aa <USB_InitFSLSPClkSel+0x66>
  }
  else if (freq == HCFG_6_MHZ)
 8008196:	78fb      	ldrb	r3, [r7, #3]
 8008198:	2b02      	cmp	r3, #2
 800819a:	d106      	bne.n	80081aa <USB_InitFSLSPClkSel+0x66>
  {
    USBx_HOST->HFIR = 6000U;
 800819c:	68fb      	ldr	r3, [r7, #12]
 800819e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80081a2:	461a      	mov	r2, r3
 80081a4:	f241 7370 	movw	r3, #6000	; 0x1770
 80081a8:	6053      	str	r3, [r2, #4]
  else
  {
    /* ... */
  }

  return HAL_OK;
 80081aa:	2300      	movs	r3, #0
}
 80081ac:	4618      	mov	r0, r3
 80081ae:	3714      	adds	r7, #20
 80081b0:	46bd      	mov	sp, r7
 80081b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081b6:	4770      	bx	lr

080081b8 <USB_DriveVbus>:
  *           0 : VBUS Active
  *           1 : VBUS Inactive
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
 80081b8:	b480      	push	{r7}
 80081ba:	b085      	sub	sp, #20
 80081bc:	af00      	add	r7, sp, #0
 80081be:	6078      	str	r0, [r7, #4]
 80081c0:	460b      	mov	r3, r1
 80081c2:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 80081c4:	687b      	ldr	r3, [r7, #4]
 80081c6:	60fb      	str	r3, [r7, #12]
  __IO uint32_t hprt0 = 0U;
 80081c8:	2300      	movs	r3, #0
 80081ca:	60bb      	str	r3, [r7, #8]

  hprt0 = USBx_HPRT0;
 80081cc:	68fb      	ldr	r3, [r7, #12]
 80081ce:	f503 6388 	add.w	r3, r3, #1088	; 0x440
 80081d2:	681b      	ldr	r3, [r3, #0]
 80081d4:	60bb      	str	r3, [r7, #8]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 80081d6:	68bb      	ldr	r3, [r7, #8]
 80081d8:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 80081dc:	60bb      	str	r3, [r7, #8]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 80081de:	68bb      	ldr	r3, [r7, #8]
 80081e0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80081e4:	2b00      	cmp	r3, #0
 80081e6:	d109      	bne.n	80081fc <USB_DriveVbus+0x44>
 80081e8:	78fb      	ldrb	r3, [r7, #3]
 80081ea:	2b01      	cmp	r3, #1
 80081ec:	d106      	bne.n	80081fc <USB_DriveVbus+0x44>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 80081ee:	68bb      	ldr	r3, [r7, #8]
 80081f0:	68fa      	ldr	r2, [r7, #12]
 80081f2:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 80081f6:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80081fa:	6013      	str	r3, [r2, #0]
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 80081fc:	68bb      	ldr	r3, [r7, #8]
 80081fe:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008202:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8008206:	d109      	bne.n	800821c <USB_DriveVbus+0x64>
 8008208:	78fb      	ldrb	r3, [r7, #3]
 800820a:	2b00      	cmp	r3, #0
 800820c:	d106      	bne.n	800821c <USB_DriveVbus+0x64>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 800820e:	68bb      	ldr	r3, [r7, #8]
 8008210:	68fa      	ldr	r2, [r7, #12]
 8008212:	f502 6288 	add.w	r2, r2, #1088	; 0x440
 8008216:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800821a:	6013      	str	r3, [r2, #0]
  }
  return HAL_OK;
 800821c:	2300      	movs	r3, #0
}
 800821e:	4618      	mov	r0, r3
 8008220:	3714      	adds	r7, #20
 8008222:	46bd      	mov	sp, r7
 8008224:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008228:	4770      	bx	lr

0800822a <USB_HC_ReadInterrupt>:
  * @brief Read all host channel interrupts status
  * @param  USBx  Selected device
  * @retval HAL state
  */
uint32_t USB_HC_ReadInterrupt(USB_OTG_GlobalTypeDef *USBx)
{
 800822a:	b480      	push	{r7}
 800822c:	b085      	sub	sp, #20
 800822e:	af00      	add	r7, sp, #0
 8008230:	6078      	str	r0, [r7, #4]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8008232:	687b      	ldr	r3, [r7, #4]
 8008234:	60fb      	str	r3, [r7, #12]

  return ((USBx_HOST->HAINT) & 0xFFFFU);
 8008236:	68fb      	ldr	r3, [r7, #12]
 8008238:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800823c:	695b      	ldr	r3, [r3, #20]
 800823e:	b29b      	uxth	r3, r3
}
 8008240:	4618      	mov	r0, r3
 8008242:	3714      	adds	r7, #20
 8008244:	46bd      	mov	sp, r7
 8008246:	f85d 7b04 	ldr.w	r7, [sp], #4
 800824a:	4770      	bx	lr

0800824c <USB_HC_Halt>:
  * @param  hc_num  Host Channel number
  *         This parameter can be a value from 1 to 15
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_Halt(USB_OTG_GlobalTypeDef *USBx, uint8_t hc_num)
{
 800824c:	b480      	push	{r7}
 800824e:	b087      	sub	sp, #28
 8008250:	af00      	add	r7, sp, #0
 8008252:	6078      	str	r0, [r7, #4]
 8008254:	460b      	mov	r3, r1
 8008256:	70fb      	strb	r3, [r7, #3]
  uint32_t USBx_BASE = (uint32_t)USBx;
 8008258:	687b      	ldr	r3, [r7, #4]
 800825a:	613b      	str	r3, [r7, #16]
  uint32_t hcnum = (uint32_t)hc_num;
 800825c:	78fb      	ldrb	r3, [r7, #3]
 800825e:	60fb      	str	r3, [r7, #12]
  uint32_t count = 0U;
 8008260:	2300      	movs	r3, #0
 8008262:	617b      	str	r3, [r7, #20]
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8008264:	68fb      	ldr	r3, [r7, #12]
 8008266:	015a      	lsls	r2, r3, #5
 8008268:	693b      	ldr	r3, [r7, #16]
 800826a:	4413      	add	r3, r2
 800826c:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8008270:	681b      	ldr	r3, [r3, #0]
 8008272:	0c9b      	lsrs	r3, r3, #18
 8008274:	f003 0303 	and.w	r3, r3, #3
 8008278:	60bb      	str	r3, [r7, #8]

  /* Check for space in the request queue to issue the halt. */
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 800827a:	68bb      	ldr	r3, [r7, #8]
 800827c:	2b00      	cmp	r3, #0
 800827e:	d002      	beq.n	8008286 <USB_HC_Halt+0x3a>
 8008280:	68bb      	ldr	r3, [r7, #8]
 8008282:	2b02      	cmp	r3, #2
 8008284:	d16c      	bne.n	8008360 <USB_HC_Halt+0x114>
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8008286:	68fb      	ldr	r3, [r7, #12]
 8008288:	015a      	lsls	r2, r3, #5
 800828a:	693b      	ldr	r3, [r7, #16]
 800828c:	4413      	add	r3, r2
 800828e:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8008292:	681b      	ldr	r3, [r3, #0]
 8008294:	68fa      	ldr	r2, [r7, #12]
 8008296:	0151      	lsls	r1, r2, #5
 8008298:	693a      	ldr	r2, [r7, #16]
 800829a:	440a      	add	r2, r1
 800829c:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80082a0:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80082a4:	6013      	str	r3, [r2, #0]

    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 80082a6:	687b      	ldr	r3, [r7, #4]
 80082a8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80082aa:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 80082ae:	2b00      	cmp	r3, #0
 80082b0:	d143      	bne.n	800833a <USB_HC_Halt+0xee>
    {
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 80082b2:	68fb      	ldr	r3, [r7, #12]
 80082b4:	015a      	lsls	r2, r3, #5
 80082b6:	693b      	ldr	r3, [r7, #16]
 80082b8:	4413      	add	r3, r2
 80082ba:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80082be:	681b      	ldr	r3, [r3, #0]
 80082c0:	68fa      	ldr	r2, [r7, #12]
 80082c2:	0151      	lsls	r1, r2, #5
 80082c4:	693a      	ldr	r2, [r7, #16]
 80082c6:	440a      	add	r2, r1
 80082c8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80082cc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80082d0:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80082d2:	68fb      	ldr	r3, [r7, #12]
 80082d4:	015a      	lsls	r2, r3, #5
 80082d6:	693b      	ldr	r3, [r7, #16]
 80082d8:	4413      	add	r3, r2
 80082da:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80082de:	681b      	ldr	r3, [r3, #0]
 80082e0:	68fa      	ldr	r2, [r7, #12]
 80082e2:	0151      	lsls	r1, r2, #5
 80082e4:	693a      	ldr	r2, [r7, #16]
 80082e6:	440a      	add	r2, r1
 80082e8:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80082ec:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80082f0:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 80082f2:	68fb      	ldr	r3, [r7, #12]
 80082f4:	015a      	lsls	r2, r3, #5
 80082f6:	693b      	ldr	r3, [r7, #16]
 80082f8:	4413      	add	r3, r2
 80082fa:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80082fe:	681b      	ldr	r3, [r3, #0]
 8008300:	68fa      	ldr	r2, [r7, #12]
 8008302:	0151      	lsls	r1, r2, #5
 8008304:	693a      	ldr	r2, [r7, #16]
 8008306:	440a      	add	r2, r1
 8008308:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800830c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8008310:	6013      	str	r3, [r2, #0]
      do
      {
        if (++count > 1000U)
 8008312:	697b      	ldr	r3, [r7, #20]
 8008314:	3301      	adds	r3, #1
 8008316:	617b      	str	r3, [r7, #20]
 8008318:	697b      	ldr	r3, [r7, #20]
 800831a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800831e:	d81d      	bhi.n	800835c <USB_HC_Halt+0x110>
        {
          break;
        }
      }
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8008320:	68fb      	ldr	r3, [r7, #12]
 8008322:	015a      	lsls	r2, r3, #5
 8008324:	693b      	ldr	r3, [r7, #16]
 8008326:	4413      	add	r3, r2
 8008328:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800832c:	681b      	ldr	r3, [r3, #0]
 800832e:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8008332:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8008336:	d0ec      	beq.n	8008312 <USB_HC_Halt+0xc6>
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8008338:	e080      	b.n	800843c <USB_HC_Halt+0x1f0>
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 800833a:	68fb      	ldr	r3, [r7, #12]
 800833c:	015a      	lsls	r2, r3, #5
 800833e:	693b      	ldr	r3, [r7, #16]
 8008340:	4413      	add	r3, r2
 8008342:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8008346:	681b      	ldr	r3, [r3, #0]
 8008348:	68fa      	ldr	r2, [r7, #12]
 800834a:	0151      	lsls	r1, r2, #5
 800834c:	693a      	ldr	r2, [r7, #16]
 800834e:	440a      	add	r2, r1
 8008350:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8008354:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8008358:	6013      	str	r3, [r2, #0]
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 800835a:	e06f      	b.n	800843c <USB_HC_Halt+0x1f0>
          break;
 800835c:	bf00      	nop
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 800835e:	e06d      	b.n	800843c <USB_HC_Halt+0x1f0>
    }
  }
  else
  {
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8008360:	68fb      	ldr	r3, [r7, #12]
 8008362:	015a      	lsls	r2, r3, #5
 8008364:	693b      	ldr	r3, [r7, #16]
 8008366:	4413      	add	r3, r2
 8008368:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800836c:	681b      	ldr	r3, [r3, #0]
 800836e:	68fa      	ldr	r2, [r7, #12]
 8008370:	0151      	lsls	r1, r2, #5
 8008372:	693a      	ldr	r2, [r7, #16]
 8008374:	440a      	add	r2, r1
 8008376:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 800837a:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 800837e:	6013      	str	r3, [r2, #0]

    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8008380:	693b      	ldr	r3, [r7, #16]
 8008382:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8008386:	691b      	ldr	r3, [r3, #16]
 8008388:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800838c:	2b00      	cmp	r3, #0
 800838e:	d143      	bne.n	8008418 <USB_HC_Halt+0x1cc>
    {
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8008390:	68fb      	ldr	r3, [r7, #12]
 8008392:	015a      	lsls	r2, r3, #5
 8008394:	693b      	ldr	r3, [r7, #16]
 8008396:	4413      	add	r3, r2
 8008398:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800839c:	681b      	ldr	r3, [r3, #0]
 800839e:	68fa      	ldr	r2, [r7, #12]
 80083a0:	0151      	lsls	r1, r2, #5
 80083a2:	693a      	ldr	r2, [r7, #16]
 80083a4:	440a      	add	r2, r1
 80083a6:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80083aa:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80083ae:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 80083b0:	68fb      	ldr	r3, [r7, #12]
 80083b2:	015a      	lsls	r2, r3, #5
 80083b4:	693b      	ldr	r3, [r7, #16]
 80083b6:	4413      	add	r3, r2
 80083b8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80083bc:	681b      	ldr	r3, [r3, #0]
 80083be:	68fa      	ldr	r2, [r7, #12]
 80083c0:	0151      	lsls	r1, r2, #5
 80083c2:	693a      	ldr	r2, [r7, #16]
 80083c4:	440a      	add	r2, r1
 80083c6:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80083ca:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80083ce:	6013      	str	r3, [r2, #0]
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 80083d0:	68fb      	ldr	r3, [r7, #12]
 80083d2:	015a      	lsls	r2, r3, #5
 80083d4:	693b      	ldr	r3, [r7, #16]
 80083d6:	4413      	add	r3, r2
 80083d8:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 80083dc:	681b      	ldr	r3, [r3, #0]
 80083de:	68fa      	ldr	r2, [r7, #12]
 80083e0:	0151      	lsls	r1, r2, #5
 80083e2:	693a      	ldr	r2, [r7, #16]
 80083e4:	440a      	add	r2, r1
 80083e6:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 80083ea:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80083ee:	6013      	str	r3, [r2, #0]
      do
      {
        if (++count > 1000U)
 80083f0:	697b      	ldr	r3, [r7, #20]
 80083f2:	3301      	adds	r3, #1
 80083f4:	617b      	str	r3, [r7, #20]
 80083f6:	697b      	ldr	r3, [r7, #20]
 80083f8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80083fc:	d81d      	bhi.n	800843a <USB_HC_Halt+0x1ee>
        {
          break;
        }
      }
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 80083fe:	68fb      	ldr	r3, [r7, #12]
 8008400:	015a      	lsls	r2, r3, #5
 8008402:	693b      	ldr	r3, [r7, #16]
 8008404:	4413      	add	r3, r2
 8008406:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 800840a:	681b      	ldr	r3, [r3, #0]
 800840c:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 8008410:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8008414:	d0ec      	beq.n	80083f0 <USB_HC_Halt+0x1a4>
 8008416:	e011      	b.n	800843c <USB_HC_Halt+0x1f0>
    }
    else
    {
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8008418:	68fb      	ldr	r3, [r7, #12]
 800841a:	015a      	lsls	r2, r3, #5
 800841c:	693b      	ldr	r3, [r7, #16]
 800841e:	4413      	add	r3, r2
 8008420:	f503 63a0 	add.w	r3, r3, #1280	; 0x500
 8008424:	681b      	ldr	r3, [r3, #0]
 8008426:	68fa      	ldr	r2, [r7, #12]
 8008428:	0151      	lsls	r1, r2, #5
 800842a:	693a      	ldr	r2, [r7, #16]
 800842c:	440a      	add	r2, r1
 800842e:	f502 62a0 	add.w	r2, r2, #1280	; 0x500
 8008432:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8008436:	6013      	str	r3, [r2, #0]
 8008438:	e000      	b.n	800843c <USB_HC_Halt+0x1f0>
          break;
 800843a:	bf00      	nop
    }
  }

  return HAL_OK;
 800843c:	2300      	movs	r3, #0
}
 800843e:	4618      	mov	r0, r3
 8008440:	371c      	adds	r7, #28
 8008442:	46bd      	mov	sp, r7
 8008444:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008448:	4770      	bx	lr

0800844a <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 800844a:	b580      	push	{r7, lr}
 800844c:	b082      	sub	sp, #8
 800844e:	af00      	add	r7, sp, #0
  

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 8008450:	f7f8 f8c6 	bl	80005e0 <HAL_Init>
  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();
 8008454:	f000 f83c 	bl	80084d0 <SystemClock_Config>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 8008458:	f000 fece 	bl	80091f8 <MX_GPIO_Init>
  MX_ADC3_Init();
 800845c:	f000 f8e6 	bl	800862c <MX_ADC3_Init>
  MX_DCMI_Init();
 8008460:	f000 f936 	bl	80086d0 <MX_DCMI_Init>
  MX_DMA2D_Init();
 8008464:	f000 f968 	bl	8008738 <MX_DMA2D_Init>
  MX_FMC_Init();
 8008468:	f000 fe76 	bl	8009158 <MX_FMC_Init>
  MX_LTDC_Init();
 800846c:	f000 f996 	bl	800879c <MX_LTDC_Init>
  MX_RTC_Init();
 8008470:	f000 fa16 	bl	80088a0 <MX_RTC_Init>
  MX_SAI2_Init();
 8008474:	f000 fabc 	bl	80089f0 <MX_SAI2_Init>
  MX_TIM1_Init();
 8008478:	f000 fb62 	bl	8008b40 <MX_TIM1_Init>
  MX_TIM2_Init();
 800847c:	f000 fbf0 	bl	8008c60 <MX_TIM2_Init>
  MX_TIM3_Init();
 8008480:	f000 fc64 	bl	8008d4c <MX_TIM3_Init>
  MX_TIM5_Init();
 8008484:	f000 fcda 	bl	8008e3c <MX_TIM5_Init>
  MX_TIM8_Init();
 8008488:	f000 fd4e 	bl	8008f28 <MX_TIM8_Init>
  MX_TIM12_Init();
 800848c:	f000 fd9e 	bl	8008fcc <MX_TIM12_Init>
  MX_USART1_UART_Init();
 8008490:	f000 fde0 	bl	8009054 <MX_USART1_UART_Init>
  MX_USART6_UART_Init();
 8008494:	f000 fe0e 	bl	80090b4 <MX_USART6_UART_Init>
  MX_USB_OTG_FS_HCD_Init();
 8008498:	f000 fe3c 	bl	8009114 <MX_USB_OTG_FS_HCD_Init>
  /* USER CODE BEGIN 2 */
  lv_init();
 800849c:	f008 f938 	bl	8010710 <lv_init>

  tft_init();
 80084a0:	f003 f950 	bl	800b744 <tft_init>
  touchpad_init();
 80084a4:	f003 fda2 	bl	800bfec <touchpad_init>

  /*HAL_TIM_PWM_Start(&htim1,TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim2,TIM_CHANNEL_1);
  HAL_TIM_PWM_Start(&htim3,TIM_CHANNEL_1);*/
  uint8_t pwmRValue=0;
 80084a8:	2300      	movs	r3, #0
 80084aa:	71fb      	strb	r3, [r7, #7]
  uint8_t pwmGValue=0;
 80084ac:	2300      	movs	r3, #0
 80084ae:	71bb      	strb	r3, [r7, #6]
  uint8_t pwmBValue=0;
 80084b0:	2300      	movs	r3, #0
 80084b2:	717b      	strb	r3, [r7, #5]
  ledSurucuMain();
 80084b4:	f003 fe97 	bl	800c1e6 <ledSurucuMain>
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  ledRgbValuesSet(&pwmRValue,&pwmGValue,&pwmBValue);
 80084b8:	1d7a      	adds	r2, r7, #5
 80084ba:	1db9      	adds	r1, r7, #6
 80084bc:	1dfb      	adds	r3, r7, #7
 80084be:	4618      	mov	r0, r3
 80084c0:	f005 fcae 	bl	800de20 <ledRgbValuesSet>
      HAL_Delay(10);
 80084c4:	200a      	movs	r0, #10
 80084c6:	f7f8 f8b9 	bl	800063c <HAL_Delay>
      lv_task_handler();
 80084ca:	f014 fba1 	bl	801cc10 <lv_task_handler>
	  ledRgbValuesSet(&pwmRValue,&pwmGValue,&pwmBValue);
 80084ce:	e7f3      	b.n	80084b8 <main+0x6e>

080084d0 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 80084d0:	b580      	push	{r7, lr}
 80084d2:	b0b4      	sub	sp, #208	; 0xd0
 80084d4:	af00      	add	r7, sp, #0
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 80084d6:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 80084da:	2230      	movs	r2, #48	; 0x30
 80084dc:	2100      	movs	r1, #0
 80084de:	4618      	mov	r0, r3
 80084e0:	f01e fe77 	bl	80271d2 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 80084e4:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 80084e8:	2200      	movs	r2, #0
 80084ea:	601a      	str	r2, [r3, #0]
 80084ec:	605a      	str	r2, [r3, #4]
 80084ee:	609a      	str	r2, [r3, #8]
 80084f0:	60da      	str	r2, [r3, #12]
 80084f2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 80084f4:	f107 0308 	add.w	r3, r7, #8
 80084f8:	2284      	movs	r2, #132	; 0x84
 80084fa:	2100      	movs	r1, #0
 80084fc:	4618      	mov	r0, r3
 80084fe:	f01e fe68 	bl	80271d2 <memset>

  /** Configure LSE Drive Capability 
  */
  HAL_PWR_EnableBkUpAccess();
 8008502:	f7fb fedf 	bl	80042c4 <HAL_PWR_EnableBkUpAccess>
  /** Configure the main internal regulator output voltage 
  */
  __HAL_RCC_PWR_CLK_ENABLE();
 8008506:	4b46      	ldr	r3, [pc, #280]	; (8008620 <SystemClock_Config+0x150>)
 8008508:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800850a:	4a45      	ldr	r2, [pc, #276]	; (8008620 <SystemClock_Config+0x150>)
 800850c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8008510:	6413      	str	r3, [r2, #64]	; 0x40
 8008512:	4b43      	ldr	r3, [pc, #268]	; (8008620 <SystemClock_Config+0x150>)
 8008514:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8008516:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800851a:	607b      	str	r3, [r7, #4]
 800851c:	687b      	ldr	r3, [r7, #4]
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800851e:	4b41      	ldr	r3, [pc, #260]	; (8008624 <SystemClock_Config+0x154>)
 8008520:	681b      	ldr	r3, [r3, #0]
 8008522:	4a40      	ldr	r2, [pc, #256]	; (8008624 <SystemClock_Config+0x154>)
 8008524:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8008528:	6013      	str	r3, [r2, #0]
 800852a:	4b3e      	ldr	r3, [pc, #248]	; (8008624 <SystemClock_Config+0x154>)
 800852c:	681b      	ldr	r3, [r3, #0]
 800852e:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 8008532:	603b      	str	r3, [r7, #0]
 8008534:	683b      	ldr	r3, [r7, #0]
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;
 8008536:	2309      	movs	r3, #9
 8008538:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800853c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8008540:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
 8008544:	2301      	movs	r3, #1
 8008546:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800854a:	2302      	movs	r3, #2
 800854c:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8008550:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8008554:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  RCC_OscInitStruct.PLL.PLLM = 25;
 8008558:	2319      	movs	r3, #25
 800855a:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
  RCC_OscInitStruct.PLL.PLLN = 400;
 800855e:	f44f 73c8 	mov.w	r3, #400	; 0x190
 8008562:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 8008566:	2302      	movs	r3, #2
 8008568:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  RCC_OscInitStruct.PLL.PLLQ = 8;
 800856c:	2308      	movs	r3, #8
 800856e:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8008572:	f107 03a0 	add.w	r3, r7, #160	; 0xa0
 8008576:	4618      	mov	r0, r3
 8008578:	f7fb ff04 	bl	8004384 <HAL_RCC_OscConfig>
 800857c:	4603      	mov	r3, r0
 800857e:	2b00      	cmp	r3, #0
 8008580:	d001      	beq.n	8008586 <SystemClock_Config+0xb6>
  {
    Error_Handler();
 8008582:	f001 f8fb 	bl	800977c <Error_Handler>
  }
  /** Activate the Over-Drive mode 
  */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 8008586:	f7fb fead 	bl	80042e4 <HAL_PWREx_EnableOverDrive>
 800858a:	4603      	mov	r3, r0
 800858c:	2b00      	cmp	r3, #0
 800858e:	d001      	beq.n	8008594 <SystemClock_Config+0xc4>
  {
    Error_Handler();
 8008590:	f001 f8f4 	bl	800977c <Error_Handler>
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8008594:	230f      	movs	r3, #15
 8008596:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800859a:	2302      	movs	r3, #2
 800859c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80085a0:	2300      	movs	r3, #0
 80085a2:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80085a6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80085aa:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80085ae:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80085b2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
 80085b6:	f107 038c 	add.w	r3, r7, #140	; 0x8c
 80085ba:	2106      	movs	r1, #6
 80085bc:	4618      	mov	r0, r3
 80085be:	f7fc f951 	bl	8004864 <HAL_RCC_ClockConfig>
 80085c2:	4603      	mov	r3, r0
 80085c4:	2b00      	cmp	r3, #0
 80085c6:	d001      	beq.n	80085cc <SystemClock_Config+0xfc>
  {
    Error_Handler();
 80085c8:	f001 f8d8 	bl	800977c <Error_Handler>
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_RTC
 80085cc:	4b16      	ldr	r3, [pc, #88]	; (8008628 <SystemClock_Config+0x158>)
 80085ce:	60bb      	str	r3, [r7, #8]
                              |RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART6
                              |RCC_PERIPHCLK_SAI2|RCC_PERIPHCLK_CLK48;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
 80085d0:	23c0      	movs	r3, #192	; 0xc0
 80085d2:	61fb      	str	r3, [r7, #28]
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 5;
 80085d4:	2305      	movs	r3, #5
 80085d6:	627b      	str	r3, [r7, #36]	; 0x24
  PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
 80085d8:	2302      	movs	r3, #2
 80085da:	623b      	str	r3, [r7, #32]
  PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV4;
 80085dc:	2301      	movs	r3, #1
 80085de:	62bb      	str	r3, [r7, #40]	; 0x28
  PeriphClkInitStruct.PLLSAIDivQ = 1;
 80085e0:	2301      	movs	r3, #1
 80085e2:	633b      	str	r3, [r7, #48]	; 0x30
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
 80085e4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80085e8:	637b      	str	r3, [r7, #52]	; 0x34
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 80085ea:	f44f 7300 	mov.w	r3, #512	; 0x200
 80085ee:	63bb      	str	r3, [r7, #56]	; 0x38
  PeriphClkInitStruct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLSAI;
 80085f0:	2300      	movs	r3, #0
 80085f2:	64bb      	str	r3, [r7, #72]	; 0x48
  PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
 80085f4:	2300      	movs	r3, #0
 80085f6:	64fb      	str	r3, [r7, #76]	; 0x4c
  PeriphClkInitStruct.Usart6ClockSelection = RCC_USART6CLKSOURCE_PCLK2;
 80085f8:	2300      	movs	r3, #0
 80085fa:	663b      	str	r3, [r7, #96]	; 0x60
  PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
 80085fc:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8008600:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 8008604:	f107 0308 	add.w	r3, r7, #8
 8008608:	4618      	mov	r0, r3
 800860a:	f7fc fb2b 	bl	8004c64 <HAL_RCCEx_PeriphCLKConfig>
 800860e:	4603      	mov	r3, r0
 8008610:	2b00      	cmp	r3, #0
 8008612:	d001      	beq.n	8008618 <SystemClock_Config+0x148>
  {
    Error_Handler();
 8008614:	f001 f8b2 	bl	800977c <Error_Handler>
  }
}
 8008618:	bf00      	nop
 800861a:	37d0      	adds	r7, #208	; 0xd0
 800861c:	46bd      	mov	sp, r7
 800861e:	bd80      	pop	{r7, pc}
 8008620:	40023800 	.word	0x40023800
 8008624:	40007000 	.word	0x40007000
 8008628:	00300868 	.word	0x00300868

0800862c <MX_ADC3_Init>:
  * @brief ADC3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC3_Init(void)
{
 800862c:	b580      	push	{r7, lr}
 800862e:	b084      	sub	sp, #16
 8008630:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN ADC3_Init 0 */

  /* USER CODE END ADC3_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
 8008632:	463b      	mov	r3, r7
 8008634:	2200      	movs	r2, #0
 8008636:	601a      	str	r2, [r3, #0]
 8008638:	605a      	str	r2, [r3, #4]
 800863a:	609a      	str	r2, [r3, #8]
 800863c:	60da      	str	r2, [r3, #12]
  /* USER CODE BEGIN ADC3_Init 1 */

  /* USER CODE END ADC3_Init 1 */
  /** Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion) 
  */
  hadc3.Instance = ADC3;
 800863e:	4b21      	ldr	r3, [pc, #132]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008640:	4a21      	ldr	r2, [pc, #132]	; (80086c8 <MX_ADC3_Init+0x9c>)
 8008642:	601a      	str	r2, [r3, #0]
  hadc3.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
 8008644:	4b1f      	ldr	r3, [pc, #124]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008646:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800864a:	605a      	str	r2, [r3, #4]
  hadc3.Init.Resolution = ADC_RESOLUTION_12B;
 800864c:	4b1d      	ldr	r3, [pc, #116]	; (80086c4 <MX_ADC3_Init+0x98>)
 800864e:	2200      	movs	r2, #0
 8008650:	609a      	str	r2, [r3, #8]
  hadc3.Init.ScanConvMode = DISABLE;
 8008652:	4b1c      	ldr	r3, [pc, #112]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008654:	2200      	movs	r2, #0
 8008656:	611a      	str	r2, [r3, #16]
  hadc3.Init.ContinuousConvMode = DISABLE;
 8008658:	4b1a      	ldr	r3, [pc, #104]	; (80086c4 <MX_ADC3_Init+0x98>)
 800865a:	2200      	movs	r2, #0
 800865c:	619a      	str	r2, [r3, #24]
  hadc3.Init.DiscontinuousConvMode = DISABLE;
 800865e:	4b19      	ldr	r3, [pc, #100]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008660:	2200      	movs	r2, #0
 8008662:	f883 2020 	strb.w	r2, [r3, #32]
  hadc3.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8008666:	4b17      	ldr	r3, [pc, #92]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008668:	2200      	movs	r2, #0
 800866a:	62da      	str	r2, [r3, #44]	; 0x2c
  hadc3.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800866c:	4b15      	ldr	r3, [pc, #84]	; (80086c4 <MX_ADC3_Init+0x98>)
 800866e:	4a17      	ldr	r2, [pc, #92]	; (80086cc <MX_ADC3_Init+0xa0>)
 8008670:	629a      	str	r2, [r3, #40]	; 0x28
  hadc3.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8008672:	4b14      	ldr	r3, [pc, #80]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008674:	2200      	movs	r2, #0
 8008676:	60da      	str	r2, [r3, #12]
  hadc3.Init.NbrOfConversion = 1;
 8008678:	4b12      	ldr	r3, [pc, #72]	; (80086c4 <MX_ADC3_Init+0x98>)
 800867a:	2201      	movs	r2, #1
 800867c:	61da      	str	r2, [r3, #28]
  hadc3.Init.DMAContinuousRequests = DISABLE;
 800867e:	4b11      	ldr	r3, [pc, #68]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008680:	2200      	movs	r2, #0
 8008682:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
  hadc3.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8008686:	4b0f      	ldr	r3, [pc, #60]	; (80086c4 <MX_ADC3_Init+0x98>)
 8008688:	2201      	movs	r2, #1
 800868a:	615a      	str	r2, [r3, #20]
  if (HAL_ADC_Init(&hadc3) != HAL_OK)
 800868c:	480d      	ldr	r0, [pc, #52]	; (80086c4 <MX_ADC3_Init+0x98>)
 800868e:	f7f7 fff7 	bl	8000680 <HAL_ADC_Init>
 8008692:	4603      	mov	r3, r0
 8008694:	2b00      	cmp	r3, #0
 8008696:	d001      	beq.n	800869c <MX_ADC3_Init+0x70>
  {
    Error_Handler();
 8008698:	f001 f870 	bl	800977c <Error_Handler>
  }
  /** Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time. 
  */
  sConfig.Channel = ADC_CHANNEL_4;
 800869c:	2304      	movs	r3, #4
 800869e:	603b      	str	r3, [r7, #0]
  sConfig.Rank = ADC_REGULAR_RANK_1;
 80086a0:	2301      	movs	r3, #1
 80086a2:	607b      	str	r3, [r7, #4]
  sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
 80086a4:	2300      	movs	r3, #0
 80086a6:	60bb      	str	r3, [r7, #8]
  if (HAL_ADC_ConfigChannel(&hadc3, &sConfig) != HAL_OK)
 80086a8:	463b      	mov	r3, r7
 80086aa:	4619      	mov	r1, r3
 80086ac:	4805      	ldr	r0, [pc, #20]	; (80086c4 <MX_ADC3_Init+0x98>)
 80086ae:	f7f8 f82b 	bl	8000708 <HAL_ADC_ConfigChannel>
 80086b2:	4603      	mov	r3, r0
 80086b4:	2b00      	cmp	r3, #0
 80086b6:	d001      	beq.n	80086bc <MX_ADC3_Init+0x90>
  {
    Error_Handler();
 80086b8:	f001 f860 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN ADC3_Init 2 */

  /* USER CODE END ADC3_Init 2 */

}
 80086bc:	bf00      	nop
 80086be:	3710      	adds	r7, #16
 80086c0:	46bd      	mov	sp, r7
 80086c2:	bd80      	pop	{r7, pc}
 80086c4:	2000d600 	.word	0x2000d600
 80086c8:	40012200 	.word	0x40012200
 80086cc:	0f000001 	.word	0x0f000001

080086d0 <MX_DCMI_Init>:
  * @brief DCMI Initialization Function
  * @param None
  * @retval None
  */
static void MX_DCMI_Init(void)
{
 80086d0:	b580      	push	{r7, lr}
 80086d2:	af00      	add	r7, sp, #0
  /* USER CODE END DCMI_Init 0 */

  /* USER CODE BEGIN DCMI_Init 1 */

  /* USER CODE END DCMI_Init 1 */
  hdcmi.Instance = DCMI;
 80086d4:	4b16      	ldr	r3, [pc, #88]	; (8008730 <MX_DCMI_Init+0x60>)
 80086d6:	4a17      	ldr	r2, [pc, #92]	; (8008734 <MX_DCMI_Init+0x64>)
 80086d8:	601a      	str	r2, [r3, #0]
  hdcmi.Init.SynchroMode = DCMI_SYNCHRO_HARDWARE;
 80086da:	4b15      	ldr	r3, [pc, #84]	; (8008730 <MX_DCMI_Init+0x60>)
 80086dc:	2200      	movs	r2, #0
 80086de:	605a      	str	r2, [r3, #4]
  hdcmi.Init.PCKPolarity = DCMI_PCKPOLARITY_FALLING;
 80086e0:	4b13      	ldr	r3, [pc, #76]	; (8008730 <MX_DCMI_Init+0x60>)
 80086e2:	2200      	movs	r2, #0
 80086e4:	609a      	str	r2, [r3, #8]
  hdcmi.Init.VSPolarity = DCMI_VSPOLARITY_LOW;
 80086e6:	4b12      	ldr	r3, [pc, #72]	; (8008730 <MX_DCMI_Init+0x60>)
 80086e8:	2200      	movs	r2, #0
 80086ea:	60da      	str	r2, [r3, #12]
  hdcmi.Init.HSPolarity = DCMI_HSPOLARITY_LOW;
 80086ec:	4b10      	ldr	r3, [pc, #64]	; (8008730 <MX_DCMI_Init+0x60>)
 80086ee:	2200      	movs	r2, #0
 80086f0:	611a      	str	r2, [r3, #16]
  hdcmi.Init.CaptureRate = DCMI_CR_ALL_FRAME;
 80086f2:	4b0f      	ldr	r3, [pc, #60]	; (8008730 <MX_DCMI_Init+0x60>)
 80086f4:	2200      	movs	r2, #0
 80086f6:	615a      	str	r2, [r3, #20]
  hdcmi.Init.ExtendedDataMode = DCMI_EXTEND_DATA_8B;
 80086f8:	4b0d      	ldr	r3, [pc, #52]	; (8008730 <MX_DCMI_Init+0x60>)
 80086fa:	2200      	movs	r2, #0
 80086fc:	619a      	str	r2, [r3, #24]
  hdcmi.Init.JPEGMode = DCMI_JPEG_DISABLE;
 80086fe:	4b0c      	ldr	r3, [pc, #48]	; (8008730 <MX_DCMI_Init+0x60>)
 8008700:	2200      	movs	r2, #0
 8008702:	621a      	str	r2, [r3, #32]
  hdcmi.Init.ByteSelectMode = DCMI_BSM_ALL;
 8008704:	4b0a      	ldr	r3, [pc, #40]	; (8008730 <MX_DCMI_Init+0x60>)
 8008706:	2200      	movs	r2, #0
 8008708:	625a      	str	r2, [r3, #36]	; 0x24
  hdcmi.Init.ByteSelectStart = DCMI_OEBS_ODD;
 800870a:	4b09      	ldr	r3, [pc, #36]	; (8008730 <MX_DCMI_Init+0x60>)
 800870c:	2200      	movs	r2, #0
 800870e:	629a      	str	r2, [r3, #40]	; 0x28
  hdcmi.Init.LineSelectMode = DCMI_LSM_ALL;
 8008710:	4b07      	ldr	r3, [pc, #28]	; (8008730 <MX_DCMI_Init+0x60>)
 8008712:	2200      	movs	r2, #0
 8008714:	62da      	str	r2, [r3, #44]	; 0x2c
  hdcmi.Init.LineSelectStart = DCMI_OELS_ODD;
 8008716:	4b06      	ldr	r3, [pc, #24]	; (8008730 <MX_DCMI_Init+0x60>)
 8008718:	2200      	movs	r2, #0
 800871a:	631a      	str	r2, [r3, #48]	; 0x30
  if (HAL_DCMI_Init(&hdcmi) != HAL_OK)
 800871c:	4804      	ldr	r0, [pc, #16]	; (8008730 <MX_DCMI_Init+0x60>)
 800871e:	f7f8 fb03 	bl	8000d28 <HAL_DCMI_Init>
 8008722:	4603      	mov	r3, r0
 8008724:	2b00      	cmp	r3, #0
 8008726:	d001      	beq.n	800872c <MX_DCMI_Init+0x5c>
  {
    Error_Handler();
 8008728:	f001 f828 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN DCMI_Init 2 */

  /* USER CODE END DCMI_Init 2 */

}
 800872c:	bf00      	nop
 800872e:	bd80      	pop	{r7, pc}
 8008730:	2000d648 	.word	0x2000d648
 8008734:	50050000 	.word	0x50050000

08008738 <MX_DMA2D_Init>:
  * @brief DMA2D Initialization Function
  * @param None
  * @retval None
  */
static void MX_DMA2D_Init(void)
{
 8008738:	b580      	push	{r7, lr}
 800873a:	af00      	add	r7, sp, #0
  /* USER CODE END DMA2D_Init 0 */

  /* USER CODE BEGIN DMA2D_Init 1 */

  /* USER CODE END DMA2D_Init 1 */
  hdma2d.Instance = DMA2D;
 800873c:	4b15      	ldr	r3, [pc, #84]	; (8008794 <MX_DMA2D_Init+0x5c>)
 800873e:	4a16      	ldr	r2, [pc, #88]	; (8008798 <MX_DMA2D_Init+0x60>)
 8008740:	601a      	str	r2, [r3, #0]
  hdma2d.Init.Mode = DMA2D_M2M;
 8008742:	4b14      	ldr	r3, [pc, #80]	; (8008794 <MX_DMA2D_Init+0x5c>)
 8008744:	2200      	movs	r2, #0
 8008746:	605a      	str	r2, [r3, #4]
  hdma2d.Init.ColorMode = DMA2D_OUTPUT_ARGB8888;
 8008748:	4b12      	ldr	r3, [pc, #72]	; (8008794 <MX_DMA2D_Init+0x5c>)
 800874a:	2200      	movs	r2, #0
 800874c:	609a      	str	r2, [r3, #8]
  hdma2d.Init.OutputOffset = 0;
 800874e:	4b11      	ldr	r3, [pc, #68]	; (8008794 <MX_DMA2D_Init+0x5c>)
 8008750:	2200      	movs	r2, #0
 8008752:	60da      	str	r2, [r3, #12]
  hdma2d.LayerCfg[1].InputOffset = 0;
 8008754:	4b0f      	ldr	r3, [pc, #60]	; (8008794 <MX_DMA2D_Init+0x5c>)
 8008756:	2200      	movs	r2, #0
 8008758:	629a      	str	r2, [r3, #40]	; 0x28
  hdma2d.LayerCfg[1].InputColorMode = DMA2D_INPUT_ARGB8888;
 800875a:	4b0e      	ldr	r3, [pc, #56]	; (8008794 <MX_DMA2D_Init+0x5c>)
 800875c:	2200      	movs	r2, #0
 800875e:	62da      	str	r2, [r3, #44]	; 0x2c
  hdma2d.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
 8008760:	4b0c      	ldr	r3, [pc, #48]	; (8008794 <MX_DMA2D_Init+0x5c>)
 8008762:	2200      	movs	r2, #0
 8008764:	631a      	str	r2, [r3, #48]	; 0x30
  hdma2d.LayerCfg[1].InputAlpha = 0;
 8008766:	4b0b      	ldr	r3, [pc, #44]	; (8008794 <MX_DMA2D_Init+0x5c>)
 8008768:	2200      	movs	r2, #0
 800876a:	635a      	str	r2, [r3, #52]	; 0x34
  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 800876c:	4809      	ldr	r0, [pc, #36]	; (8008794 <MX_DMA2D_Init+0x5c>)
 800876e:	f7f8 ff75 	bl	800165c <HAL_DMA2D_Init>
 8008772:	4603      	mov	r3, r0
 8008774:	2b00      	cmp	r3, #0
 8008776:	d001      	beq.n	800877c <MX_DMA2D_Init+0x44>
  {
    Error_Handler();
 8008778:	f001 f800 	bl	800977c <Error_Handler>
  }
  if (HAL_DMA2D_ConfigLayer(&hdma2d, 1) != HAL_OK)
 800877c:	2101      	movs	r1, #1
 800877e:	4805      	ldr	r0, [pc, #20]	; (8008794 <MX_DMA2D_Init+0x5c>)
 8008780:	f7f9 f8ce 	bl	8001920 <HAL_DMA2D_ConfigLayer>
 8008784:	4603      	mov	r3, r0
 8008786:	2b00      	cmp	r3, #0
 8008788:	d001      	beq.n	800878e <MX_DMA2D_Init+0x56>
  {
    Error_Handler();
 800878a:	f000 fff7 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN DMA2D_Init 2 */

  /* USER CODE END DMA2D_Init 2 */

}
 800878e:	bf00      	nop
 8008790:	bd80      	pop	{r7, pc}
 8008792:	bf00      	nop
 8008794:	2000d7f8 	.word	0x2000d7f8
 8008798:	4002b000 	.word	0x4002b000

0800879c <MX_LTDC_Init>:
  * @brief LTDC Initialization Function
  * @param None
  * @retval None
  */
static void MX_LTDC_Init(void)
{
 800879c:	b580      	push	{r7, lr}
 800879e:	b08e      	sub	sp, #56	; 0x38
 80087a0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN LTDC_Init 0 */

  /* USER CODE END LTDC_Init 0 */

  LTDC_LayerCfgTypeDef pLayerCfg = {0};
 80087a2:	1d3b      	adds	r3, r7, #4
 80087a4:	2234      	movs	r2, #52	; 0x34
 80087a6:	2100      	movs	r1, #0
 80087a8:	4618      	mov	r0, r3
 80087aa:	f01e fd12 	bl	80271d2 <memset>

  /* USER CODE BEGIN LTDC_Init 1 */

  /* USER CODE END LTDC_Init 1 */
  hltdc.Instance = LTDC;
 80087ae:	4b3a      	ldr	r3, [pc, #232]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087b0:	4a3a      	ldr	r2, [pc, #232]	; (800889c <MX_LTDC_Init+0x100>)
 80087b2:	601a      	str	r2, [r3, #0]
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
 80087b4:	4b38      	ldr	r3, [pc, #224]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087b6:	2200      	movs	r2, #0
 80087b8:	605a      	str	r2, [r3, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 80087ba:	4b37      	ldr	r3, [pc, #220]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087bc:	2200      	movs	r2, #0
 80087be:	609a      	str	r2, [r3, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 80087c0:	4b35      	ldr	r3, [pc, #212]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087c2:	2200      	movs	r2, #0
 80087c4:	60da      	str	r2, [r3, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 80087c6:	4b34      	ldr	r3, [pc, #208]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087c8:	2200      	movs	r2, #0
 80087ca:	611a      	str	r2, [r3, #16]
  hltdc.Init.HorizontalSync = 40;
 80087cc:	4b32      	ldr	r3, [pc, #200]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087ce:	2228      	movs	r2, #40	; 0x28
 80087d0:	615a      	str	r2, [r3, #20]
  hltdc.Init.VerticalSync = 9;
 80087d2:	4b31      	ldr	r3, [pc, #196]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087d4:	2209      	movs	r2, #9
 80087d6:	619a      	str	r2, [r3, #24]
  hltdc.Init.AccumulatedHBP = 53;
 80087d8:	4b2f      	ldr	r3, [pc, #188]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087da:	2235      	movs	r2, #53	; 0x35
 80087dc:	61da      	str	r2, [r3, #28]
  hltdc.Init.AccumulatedVBP = 11;
 80087de:	4b2e      	ldr	r3, [pc, #184]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087e0:	220b      	movs	r2, #11
 80087e2:	621a      	str	r2, [r3, #32]
  hltdc.Init.AccumulatedActiveW = 533;
 80087e4:	4b2c      	ldr	r3, [pc, #176]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087e6:	f240 2215 	movw	r2, #533	; 0x215
 80087ea:	625a      	str	r2, [r3, #36]	; 0x24
  hltdc.Init.AccumulatedActiveH = 283;
 80087ec:	4b2a      	ldr	r3, [pc, #168]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087ee:	f240 121b 	movw	r2, #283	; 0x11b
 80087f2:	629a      	str	r2, [r3, #40]	; 0x28
  hltdc.Init.TotalWidth = 565;
 80087f4:	4b28      	ldr	r3, [pc, #160]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087f6:	f240 2235 	movw	r2, #565	; 0x235
 80087fa:	62da      	str	r2, [r3, #44]	; 0x2c
  hltdc.Init.TotalHeigh = 285;
 80087fc:	4b26      	ldr	r3, [pc, #152]	; (8008898 <MX_LTDC_Init+0xfc>)
 80087fe:	f240 121d 	movw	r2, #285	; 0x11d
 8008802:	631a      	str	r2, [r3, #48]	; 0x30
  hltdc.Init.Backcolor.Blue = 0;
 8008804:	4b24      	ldr	r3, [pc, #144]	; (8008898 <MX_LTDC_Init+0xfc>)
 8008806:	2200      	movs	r2, #0
 8008808:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
  hltdc.Init.Backcolor.Green = 0;
 800880c:	4b22      	ldr	r3, [pc, #136]	; (8008898 <MX_LTDC_Init+0xfc>)
 800880e:	2200      	movs	r2, #0
 8008810:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
  hltdc.Init.Backcolor.Red = 0;
 8008814:	4b20      	ldr	r3, [pc, #128]	; (8008898 <MX_LTDC_Init+0xfc>)
 8008816:	2200      	movs	r2, #0
 8008818:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36
  if (HAL_LTDC_Init(&hltdc) != HAL_OK)
 800881c:	481e      	ldr	r0, [pc, #120]	; (8008898 <MX_LTDC_Init+0xfc>)
 800881e:	f7fb fa9b 	bl	8003d58 <HAL_LTDC_Init>
 8008822:	4603      	mov	r3, r0
 8008824:	2b00      	cmp	r3, #0
 8008826:	d001      	beq.n	800882c <MX_LTDC_Init+0x90>
  {
    Error_Handler();
 8008828:	f000 ffa8 	bl	800977c <Error_Handler>
  }
  pLayerCfg.WindowX0 = 0;
 800882c:	2300      	movs	r3, #0
 800882e:	607b      	str	r3, [r7, #4]
  pLayerCfg.WindowX1 = 480;
 8008830:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8008834:	60bb      	str	r3, [r7, #8]
  pLayerCfg.WindowY0 = 0;
 8008836:	2300      	movs	r3, #0
 8008838:	60fb      	str	r3, [r7, #12]
  pLayerCfg.WindowY1 = 272;
 800883a:	f44f 7388 	mov.w	r3, #272	; 0x110
 800883e:	613b      	str	r3, [r7, #16]
  pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 8008840:	2302      	movs	r3, #2
 8008842:	617b      	str	r3, [r7, #20]
  pLayerCfg.Alpha = 255;
 8008844:	23ff      	movs	r3, #255	; 0xff
 8008846:	61bb      	str	r3, [r7, #24]
  pLayerCfg.Alpha0 = 0;
 8008848:	2300      	movs	r3, #0
 800884a:	61fb      	str	r3, [r7, #28]
  pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
 800884c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8008850:	623b      	str	r3, [r7, #32]
  pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8008852:	2307      	movs	r3, #7
 8008854:	627b      	str	r3, [r7, #36]	; 0x24
  pLayerCfg.FBStartAdress = 0xC0000000;
 8008856:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
 800885a:	62bb      	str	r3, [r7, #40]	; 0x28
  pLayerCfg.ImageWidth = 480;
 800885c:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 8008860:	62fb      	str	r3, [r7, #44]	; 0x2c
  pLayerCfg.ImageHeight = 272;
 8008862:	f44f 7388 	mov.w	r3, #272	; 0x110
 8008866:	633b      	str	r3, [r7, #48]	; 0x30
  pLayerCfg.Backcolor.Blue = 0;
 8008868:	2300      	movs	r3, #0
 800886a:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
  pLayerCfg.Backcolor.Green = 0;
 800886e:	2300      	movs	r3, #0
 8008870:	f887 3035 	strb.w	r3, [r7, #53]	; 0x35
  pLayerCfg.Backcolor.Red = 0;
 8008874:	2300      	movs	r3, #0
 8008876:	f887 3036 	strb.w	r3, [r7, #54]	; 0x36
  if (HAL_LTDC_ConfigLayer(&hltdc, &pLayerCfg, 0) != HAL_OK)
 800887a:	1d3b      	adds	r3, r7, #4
 800887c:	2200      	movs	r2, #0
 800887e:	4619      	mov	r1, r3
 8008880:	4805      	ldr	r0, [pc, #20]	; (8008898 <MX_LTDC_Init+0xfc>)
 8008882:	f7fb fb39 	bl	8003ef8 <HAL_LTDC_ConfigLayer>
 8008886:	4603      	mov	r3, r0
 8008888:	2b00      	cmp	r3, #0
 800888a:	d001      	beq.n	8008890 <MX_LTDC_Init+0xf4>
  {
    Error_Handler();
 800888c:	f000 ff76 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN LTDC_Init 2 */

  /* USER CODE END LTDC_Init 2 */

}
 8008890:	bf00      	nop
 8008892:	3738      	adds	r7, #56	; 0x38
 8008894:	46bd      	mov	sp, r7
 8008896:	bd80      	pop	{r7, pc}
 8008898:	2000d558 	.word	0x2000d558
 800889c:	40016800 	.word	0x40016800

080088a0 <MX_RTC_Init>:
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{
 80088a0:	b580      	push	{r7, lr}
 80088a2:	b092      	sub	sp, #72	; 0x48
 80088a4:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_TimeTypeDef sTime = {0};
 80088a6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80088aa:	2200      	movs	r2, #0
 80088ac:	601a      	str	r2, [r3, #0]
 80088ae:	605a      	str	r2, [r3, #4]
 80088b0:	609a      	str	r2, [r3, #8]
 80088b2:	60da      	str	r2, [r3, #12]
 80088b4:	611a      	str	r2, [r3, #16]
 80088b6:	615a      	str	r2, [r3, #20]
  RTC_DateTypeDef sDate = {0};
 80088b8:	2300      	movs	r3, #0
 80088ba:	62fb      	str	r3, [r7, #44]	; 0x2c
  RTC_AlarmTypeDef sAlarm = {0};
 80088bc:	463b      	mov	r3, r7
 80088be:	222c      	movs	r2, #44	; 0x2c
 80088c0:	2100      	movs	r1, #0
 80088c2:	4618      	mov	r0, r3
 80088c4:	f01e fc85 	bl	80271d2 <memset>
  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */
  /** Initialize RTC Only 
  */
  hrtc.Instance = RTC;
 80088c8:	4b47      	ldr	r3, [pc, #284]	; (80089e8 <MX_RTC_Init+0x148>)
 80088ca:	4a48      	ldr	r2, [pc, #288]	; (80089ec <MX_RTC_Init+0x14c>)
 80088cc:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 80088ce:	4b46      	ldr	r3, [pc, #280]	; (80089e8 <MX_RTC_Init+0x148>)
 80088d0:	2200      	movs	r2, #0
 80088d2:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = 127;
 80088d4:	4b44      	ldr	r3, [pc, #272]	; (80089e8 <MX_RTC_Init+0x148>)
 80088d6:	227f      	movs	r2, #127	; 0x7f
 80088d8:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = 255;
 80088da:	4b43      	ldr	r3, [pc, #268]	; (80089e8 <MX_RTC_Init+0x148>)
 80088dc:	22ff      	movs	r2, #255	; 0xff
 80088de:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 80088e0:	4b41      	ldr	r3, [pc, #260]	; (80089e8 <MX_RTC_Init+0x148>)
 80088e2:	2200      	movs	r2, #0
 80088e4:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 80088e6:	4b40      	ldr	r3, [pc, #256]	; (80089e8 <MX_RTC_Init+0x148>)
 80088e8:	2200      	movs	r2, #0
 80088ea:	615a      	str	r2, [r3, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 80088ec:	4b3e      	ldr	r3, [pc, #248]	; (80089e8 <MX_RTC_Init+0x148>)
 80088ee:	2200      	movs	r2, #0
 80088f0:	619a      	str	r2, [r3, #24]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 80088f2:	483d      	ldr	r0, [pc, #244]	; (80089e8 <MX_RTC_Init+0x148>)
 80088f4:	f7fc fed8 	bl	80056a8 <HAL_RTC_Init>
 80088f8:	4603      	mov	r3, r0
 80088fa:	2b00      	cmp	r3, #0
 80088fc:	d001      	beq.n	8008902 <MX_RTC_Init+0x62>
  {
    Error_Handler();
 80088fe:	f000 ff3d 	bl	800977c <Error_Handler>
    
  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date 
  */
  sTime.Hours = 0x0;
 8008902:	2300      	movs	r3, #0
 8008904:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
  sTime.Minutes = 0x0;
 8008908:	2300      	movs	r3, #0
 800890a:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
  sTime.Seconds = 0x0;
 800890e:	2300      	movs	r3, #0
 8008910:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8008914:	2300      	movs	r3, #0
 8008916:	643b      	str	r3, [r7, #64]	; 0x40
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8008918:	2300      	movs	r3, #0
 800891a:	647b      	str	r3, [r7, #68]	; 0x44
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
 800891c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008920:	2201      	movs	r2, #1
 8008922:	4619      	mov	r1, r3
 8008924:	4830      	ldr	r0, [pc, #192]	; (80089e8 <MX_RTC_Init+0x148>)
 8008926:	f7fc ff3b 	bl	80057a0 <HAL_RTC_SetTime>
 800892a:	4603      	mov	r3, r0
 800892c:	2b00      	cmp	r3, #0
 800892e:	d001      	beq.n	8008934 <MX_RTC_Init+0x94>
  {
    Error_Handler();
 8008930:	f000 ff24 	bl	800977c <Error_Handler>
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 8008934:	2301      	movs	r3, #1
 8008936:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
  sDate.Month = RTC_MONTH_JANUARY;
 800893a:	2301      	movs	r3, #1
 800893c:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
  sDate.Date = 0x1;
 8008940:	2301      	movs	r3, #1
 8008942:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
  sDate.Year = 0x0;
 8008946:	2300      	movs	r3, #0
 8008948:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
 800894c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8008950:	2201      	movs	r2, #1
 8008952:	4619      	mov	r1, r3
 8008954:	4824      	ldr	r0, [pc, #144]	; (80089e8 <MX_RTC_Init+0x148>)
 8008956:	f7fc ffe1 	bl	800591c <HAL_RTC_SetDate>
 800895a:	4603      	mov	r3, r0
 800895c:	2b00      	cmp	r3, #0
 800895e:	d001      	beq.n	8008964 <MX_RTC_Init+0xc4>
  {
    Error_Handler();
 8008960:	f000 ff0c 	bl	800977c <Error_Handler>
  }
  /** Enable the Alarm A 
  */
  sAlarm.AlarmTime.Hours = 0x0;
 8008964:	2300      	movs	r3, #0
 8008966:	703b      	strb	r3, [r7, #0]
  sAlarm.AlarmTime.Minutes = 0x0;
 8008968:	2300      	movs	r3, #0
 800896a:	707b      	strb	r3, [r7, #1]
  sAlarm.AlarmTime.Seconds = 0x0;
 800896c:	2300      	movs	r3, #0
 800896e:	70bb      	strb	r3, [r7, #2]
  sAlarm.AlarmTime.SubSeconds = 0x0;
 8008970:	2300      	movs	r3, #0
 8008972:	607b      	str	r3, [r7, #4]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 8008974:	2300      	movs	r3, #0
 8008976:	613b      	str	r3, [r7, #16]
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 8008978:	2300      	movs	r3, #0
 800897a:	617b      	str	r3, [r7, #20]
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 800897c:	2300      	movs	r3, #0
 800897e:	61bb      	str	r3, [r7, #24]
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 8008980:	2300      	movs	r3, #0
 8008982:	61fb      	str	r3, [r7, #28]
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 8008984:	2300      	movs	r3, #0
 8008986:	623b      	str	r3, [r7, #32]
  sAlarm.AlarmDateWeekDay = 0x1;
 8008988:	2301      	movs	r3, #1
 800898a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  sAlarm.Alarm = RTC_ALARM_A;
 800898e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008992:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 8008994:	463b      	mov	r3, r7
 8008996:	2201      	movs	r2, #1
 8008998:	4619      	mov	r1, r3
 800899a:	4813      	ldr	r0, [pc, #76]	; (80089e8 <MX_RTC_Init+0x148>)
 800899c:	f7fd f866 	bl	8005a6c <HAL_RTC_SetAlarm>
 80089a0:	4603      	mov	r3, r0
 80089a2:	2b00      	cmp	r3, #0
 80089a4:	d001      	beq.n	80089aa <MX_RTC_Init+0x10a>
  {
    Error_Handler();
 80089a6:	f000 fee9 	bl	800977c <Error_Handler>
  }
  /** Enable the Alarm B 
  */
  sAlarm.AlarmDateWeekDay = 0x1;
 80089aa:	2301      	movs	r3, #1
 80089ac:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  sAlarm.Alarm = RTC_ALARM_B;
 80089b0:	f44f 7300 	mov.w	r3, #512	; 0x200
 80089b4:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_RTC_SetAlarm(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
 80089b6:	463b      	mov	r3, r7
 80089b8:	2201      	movs	r2, #1
 80089ba:	4619      	mov	r1, r3
 80089bc:	480a      	ldr	r0, [pc, #40]	; (80089e8 <MX_RTC_Init+0x148>)
 80089be:	f7fd f855 	bl	8005a6c <HAL_RTC_SetAlarm>
 80089c2:	4603      	mov	r3, r0
 80089c4:	2b00      	cmp	r3, #0
 80089c6:	d001      	beq.n	80089cc <MX_RTC_Init+0x12c>
  {
    Error_Handler();
 80089c8:	f000 fed8 	bl	800977c <Error_Handler>
  }
  /** Enable the TimeStamp 
  */
  if (HAL_RTCEx_SetTimeStamp(&hrtc, RTC_TIMESTAMPEDGE_RISING, RTC_TIMESTAMPPIN_POS1) != HAL_OK)
 80089cc:	2202      	movs	r2, #2
 80089ce:	2100      	movs	r1, #0
 80089d0:	4805      	ldr	r0, [pc, #20]	; (80089e8 <MX_RTC_Init+0x148>)
 80089d2:	f7fd f9d5 	bl	8005d80 <HAL_RTCEx_SetTimeStamp>
 80089d6:	4603      	mov	r3, r0
 80089d8:	2b00      	cmp	r3, #0
 80089da:	d001      	beq.n	80089e0 <MX_RTC_Init+0x140>
  {
    Error_Handler();
 80089dc:	f000 fece 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}
 80089e0:	bf00      	nop
 80089e2:	3748      	adds	r7, #72	; 0x48
 80089e4:	46bd      	mov	sp, r7
 80089e6:	bd80      	pop	{r7, pc}
 80089e8:	2000d718 	.word	0x2000d718
 80089ec:	40002800 	.word	0x40002800

080089f0 <MX_SAI2_Init>:
  * @brief SAI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SAI2_Init(void)
{
 80089f0:	b580      	push	{r7, lr}
 80089f2:	af00      	add	r7, sp, #0
  /* USER CODE END SAI2_Init 0 */

  /* USER CODE BEGIN SAI2_Init 1 */

  /* USER CODE END SAI2_Init 1 */
  hsai_BlockA2.Instance = SAI2_Block_A;
 80089f4:	4b4d      	ldr	r3, [pc, #308]	; (8008b2c <MX_SAI2_Init+0x13c>)
 80089f6:	4a4e      	ldr	r2, [pc, #312]	; (8008b30 <MX_SAI2_Init+0x140>)
 80089f8:	601a      	str	r2, [r3, #0]
  hsai_BlockA2.Init.Protocol = SAI_FREE_PROTOCOL;
 80089fa:	4b4c      	ldr	r3, [pc, #304]	; (8008b2c <MX_SAI2_Init+0x13c>)
 80089fc:	2200      	movs	r2, #0
 80089fe:	631a      	str	r2, [r3, #48]	; 0x30
  hsai_BlockA2.Init.AudioMode = SAI_MODEMASTER_TX;
 8008a00:	4b4a      	ldr	r3, [pc, #296]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a02:	2200      	movs	r2, #0
 8008a04:	605a      	str	r2, [r3, #4]
  hsai_BlockA2.Init.DataSize = SAI_DATASIZE_8;
 8008a06:	4b49      	ldr	r3, [pc, #292]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a08:	2240      	movs	r2, #64	; 0x40
 8008a0a:	635a      	str	r2, [r3, #52]	; 0x34
  hsai_BlockA2.Init.FirstBit = SAI_FIRSTBIT_MSB;
 8008a0c:	4b47      	ldr	r3, [pc, #284]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a0e:	2200      	movs	r2, #0
 8008a10:	639a      	str	r2, [r3, #56]	; 0x38
  hsai_BlockA2.Init.ClockStrobing = SAI_CLOCKSTROBING_FALLINGEDGE;
 8008a12:	4b46      	ldr	r3, [pc, #280]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a14:	2200      	movs	r2, #0
 8008a16:	63da      	str	r2, [r3, #60]	; 0x3c
  hsai_BlockA2.Init.Synchro = SAI_ASYNCHRONOUS;
 8008a18:	4b44      	ldr	r3, [pc, #272]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a1a:	2200      	movs	r2, #0
 8008a1c:	609a      	str	r2, [r3, #8]
  hsai_BlockA2.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 8008a1e:	4b43      	ldr	r3, [pc, #268]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a20:	2200      	movs	r2, #0
 8008a22:	611a      	str	r2, [r3, #16]
  hsai_BlockA2.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 8008a24:	4b41      	ldr	r3, [pc, #260]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a26:	2200      	movs	r2, #0
 8008a28:	615a      	str	r2, [r3, #20]
  hsai_BlockA2.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_EMPTY;
 8008a2a:	4b40      	ldr	r3, [pc, #256]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a2c:	2200      	movs	r2, #0
 8008a2e:	619a      	str	r2, [r3, #24]
  hsai_BlockA2.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_192K;
 8008a30:	4b3e      	ldr	r3, [pc, #248]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a32:	4a40      	ldr	r2, [pc, #256]	; (8008b34 <MX_SAI2_Init+0x144>)
 8008a34:	61da      	str	r2, [r3, #28]
  hsai_BlockA2.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8008a36:	4b3d      	ldr	r3, [pc, #244]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a38:	2200      	movs	r2, #0
 8008a3a:	60da      	str	r2, [r3, #12]
  hsai_BlockA2.Init.MonoStereoMode = SAI_STEREOMODE;
 8008a3c:	4b3b      	ldr	r3, [pc, #236]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a3e:	2200      	movs	r2, #0
 8008a40:	625a      	str	r2, [r3, #36]	; 0x24
  hsai_BlockA2.Init.CompandingMode = SAI_NOCOMPANDING;
 8008a42:	4b3a      	ldr	r3, [pc, #232]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a44:	2200      	movs	r2, #0
 8008a46:	629a      	str	r2, [r3, #40]	; 0x28
  hsai_BlockA2.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 8008a48:	4b38      	ldr	r3, [pc, #224]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a4a:	2200      	movs	r2, #0
 8008a4c:	62da      	str	r2, [r3, #44]	; 0x2c
  hsai_BlockA2.FrameInit.FrameLength = 8;
 8008a4e:	4b37      	ldr	r3, [pc, #220]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a50:	2208      	movs	r2, #8
 8008a52:	641a      	str	r2, [r3, #64]	; 0x40
  hsai_BlockA2.FrameInit.ActiveFrameLength = 1;
 8008a54:	4b35      	ldr	r3, [pc, #212]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a56:	2201      	movs	r2, #1
 8008a58:	645a      	str	r2, [r3, #68]	; 0x44
  hsai_BlockA2.FrameInit.FSDefinition = SAI_FS_STARTFRAME;
 8008a5a:	4b34      	ldr	r3, [pc, #208]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a5c:	2200      	movs	r2, #0
 8008a5e:	649a      	str	r2, [r3, #72]	; 0x48
  hsai_BlockA2.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 8008a60:	4b32      	ldr	r3, [pc, #200]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a62:	2200      	movs	r2, #0
 8008a64:	64da      	str	r2, [r3, #76]	; 0x4c
  hsai_BlockA2.FrameInit.FSOffset = SAI_FS_FIRSTBIT;
 8008a66:	4b31      	ldr	r3, [pc, #196]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a68:	2200      	movs	r2, #0
 8008a6a:	651a      	str	r2, [r3, #80]	; 0x50
  hsai_BlockA2.SlotInit.FirstBitOffset = 0;
 8008a6c:	4b2f      	ldr	r3, [pc, #188]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a6e:	2200      	movs	r2, #0
 8008a70:	655a      	str	r2, [r3, #84]	; 0x54
  hsai_BlockA2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 8008a72:	4b2e      	ldr	r3, [pc, #184]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a74:	2200      	movs	r2, #0
 8008a76:	659a      	str	r2, [r3, #88]	; 0x58
  hsai_BlockA2.SlotInit.SlotNumber = 1;
 8008a78:	4b2c      	ldr	r3, [pc, #176]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a7a:	2201      	movs	r2, #1
 8008a7c:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai_BlockA2.SlotInit.SlotActive = 0x00000000;
 8008a7e:	4b2b      	ldr	r3, [pc, #172]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a80:	2200      	movs	r2, #0
 8008a82:	661a      	str	r2, [r3, #96]	; 0x60
  if (HAL_SAI_Init(&hsai_BlockA2) != HAL_OK)
 8008a84:	4829      	ldr	r0, [pc, #164]	; (8008b2c <MX_SAI2_Init+0x13c>)
 8008a86:	f7fd f9d1 	bl	8005e2c <HAL_SAI_Init>
 8008a8a:	4603      	mov	r3, r0
 8008a8c:	2b00      	cmp	r3, #0
 8008a8e:	d001      	beq.n	8008a94 <MX_SAI2_Init+0xa4>
  {
    Error_Handler();
 8008a90:	f000 fe74 	bl	800977c <Error_Handler>
  }
  hsai_BlockB2.Instance = SAI2_Block_B;
 8008a94:	4b28      	ldr	r3, [pc, #160]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008a96:	4a29      	ldr	r2, [pc, #164]	; (8008b3c <MX_SAI2_Init+0x14c>)
 8008a98:	601a      	str	r2, [r3, #0]
  hsai_BlockB2.Init.Protocol = SAI_FREE_PROTOCOL;
 8008a9a:	4b27      	ldr	r3, [pc, #156]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008a9c:	2200      	movs	r2, #0
 8008a9e:	631a      	str	r2, [r3, #48]	; 0x30
  hsai_BlockB2.Init.AudioMode = SAI_MODESLAVE_RX;
 8008aa0:	4b25      	ldr	r3, [pc, #148]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008aa2:	2203      	movs	r2, #3
 8008aa4:	605a      	str	r2, [r3, #4]
  hsai_BlockB2.Init.DataSize = SAI_DATASIZE_8;
 8008aa6:	4b24      	ldr	r3, [pc, #144]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008aa8:	2240      	movs	r2, #64	; 0x40
 8008aaa:	635a      	str	r2, [r3, #52]	; 0x34
  hsai_BlockB2.Init.FirstBit = SAI_FIRSTBIT_MSB;
 8008aac:	4b22      	ldr	r3, [pc, #136]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008aae:	2200      	movs	r2, #0
 8008ab0:	639a      	str	r2, [r3, #56]	; 0x38
  hsai_BlockB2.Init.ClockStrobing = SAI_CLOCKSTROBING_FALLINGEDGE;
 8008ab2:	4b21      	ldr	r3, [pc, #132]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ab4:	2200      	movs	r2, #0
 8008ab6:	63da      	str	r2, [r3, #60]	; 0x3c
  hsai_BlockB2.Init.Synchro = SAI_SYNCHRONOUS;
 8008ab8:	4b1f      	ldr	r3, [pc, #124]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008aba:	2201      	movs	r2, #1
 8008abc:	609a      	str	r2, [r3, #8]
  hsai_BlockB2.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 8008abe:	4b1e      	ldr	r3, [pc, #120]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ac0:	2200      	movs	r2, #0
 8008ac2:	611a      	str	r2, [r3, #16]
  hsai_BlockB2.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_EMPTY;
 8008ac4:	4b1c      	ldr	r3, [pc, #112]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ac6:	2200      	movs	r2, #0
 8008ac8:	619a      	str	r2, [r3, #24]
  hsai_BlockB2.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 8008aca:	4b1b      	ldr	r3, [pc, #108]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008acc:	2200      	movs	r2, #0
 8008ace:	60da      	str	r2, [r3, #12]
  hsai_BlockB2.Init.MonoStereoMode = SAI_STEREOMODE;
 8008ad0:	4b19      	ldr	r3, [pc, #100]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ad2:	2200      	movs	r2, #0
 8008ad4:	625a      	str	r2, [r3, #36]	; 0x24
  hsai_BlockB2.Init.CompandingMode = SAI_NOCOMPANDING;
 8008ad6:	4b18      	ldr	r3, [pc, #96]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ad8:	2200      	movs	r2, #0
 8008ada:	629a      	str	r2, [r3, #40]	; 0x28
  hsai_BlockB2.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 8008adc:	4b16      	ldr	r3, [pc, #88]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ade:	2200      	movs	r2, #0
 8008ae0:	62da      	str	r2, [r3, #44]	; 0x2c
  hsai_BlockB2.FrameInit.FrameLength = 8;
 8008ae2:	4b15      	ldr	r3, [pc, #84]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008ae4:	2208      	movs	r2, #8
 8008ae6:	641a      	str	r2, [r3, #64]	; 0x40
  hsai_BlockB2.FrameInit.ActiveFrameLength = 1;
 8008ae8:	4b13      	ldr	r3, [pc, #76]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008aea:	2201      	movs	r2, #1
 8008aec:	645a      	str	r2, [r3, #68]	; 0x44
  hsai_BlockB2.FrameInit.FSDefinition = SAI_FS_STARTFRAME;
 8008aee:	4b12      	ldr	r3, [pc, #72]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008af0:	2200      	movs	r2, #0
 8008af2:	649a      	str	r2, [r3, #72]	; 0x48
  hsai_BlockB2.FrameInit.FSPolarity = SAI_FS_ACTIVE_LOW;
 8008af4:	4b10      	ldr	r3, [pc, #64]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008af6:	2200      	movs	r2, #0
 8008af8:	64da      	str	r2, [r3, #76]	; 0x4c
  hsai_BlockB2.FrameInit.FSOffset = SAI_FS_FIRSTBIT;
 8008afa:	4b0f      	ldr	r3, [pc, #60]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008afc:	2200      	movs	r2, #0
 8008afe:	651a      	str	r2, [r3, #80]	; 0x50
  hsai_BlockB2.SlotInit.FirstBitOffset = 0;
 8008b00:	4b0d      	ldr	r3, [pc, #52]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008b02:	2200      	movs	r2, #0
 8008b04:	655a      	str	r2, [r3, #84]	; 0x54
  hsai_BlockB2.SlotInit.SlotSize = SAI_SLOTSIZE_DATASIZE;
 8008b06:	4b0c      	ldr	r3, [pc, #48]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008b08:	2200      	movs	r2, #0
 8008b0a:	659a      	str	r2, [r3, #88]	; 0x58
  hsai_BlockB2.SlotInit.SlotNumber = 1;
 8008b0c:	4b0a      	ldr	r3, [pc, #40]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008b0e:	2201      	movs	r2, #1
 8008b10:	65da      	str	r2, [r3, #92]	; 0x5c
  hsai_BlockB2.SlotInit.SlotActive = 0x00000000;
 8008b12:	4b09      	ldr	r3, [pc, #36]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008b14:	2200      	movs	r2, #0
 8008b16:	661a      	str	r2, [r3, #96]	; 0x60
  if (HAL_SAI_Init(&hsai_BlockB2) != HAL_OK)
 8008b18:	4807      	ldr	r0, [pc, #28]	; (8008b38 <MX_SAI2_Init+0x148>)
 8008b1a:	f7fd f987 	bl	8005e2c <HAL_SAI_Init>
 8008b1e:	4603      	mov	r3, r0
 8008b20:	2b00      	cmp	r3, #0
 8008b22:	d001      	beq.n	8008b28 <MX_SAI2_Init+0x138>
  {
    Error_Handler();
 8008b24:	f000 fe2a 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN SAI2_Init 2 */

  /* USER CODE END SAI2_Init 2 */

}
 8008b28:	bf00      	nop
 8008b2a:	bd80      	pop	{r7, pc}
 8008b2c:	2000d454 	.word	0x2000d454
 8008b30:	40015c04 	.word	0x40015c04
 8008b34:	0002ee00 	.word	0x0002ee00
 8008b38:	2000d390 	.word	0x2000d390
 8008b3c:	40015c24 	.word	0x40015c24

08008b40 <MX_TIM1_Init>:
  * @brief TIM1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM1_Init(void)
{
 8008b40:	b580      	push	{r7, lr}
 8008b42:	b096      	sub	sp, #88	; 0x58
 8008b44:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM1_Init 0 */

  /* USER CODE END TIM1_Init 0 */

  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8008b46:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8008b4a:	2200      	movs	r2, #0
 8008b4c:	601a      	str	r2, [r3, #0]
 8008b4e:	605a      	str	r2, [r3, #4]
 8008b50:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8008b52:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008b56:	2200      	movs	r2, #0
 8008b58:	601a      	str	r2, [r3, #0]
 8008b5a:	605a      	str	r2, [r3, #4]
 8008b5c:	609a      	str	r2, [r3, #8]
 8008b5e:	60da      	str	r2, [r3, #12]
 8008b60:	611a      	str	r2, [r3, #16]
 8008b62:	615a      	str	r2, [r3, #20]
 8008b64:	619a      	str	r2, [r3, #24]
  TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
 8008b66:	1d3b      	adds	r3, r7, #4
 8008b68:	222c      	movs	r2, #44	; 0x2c
 8008b6a:	2100      	movs	r1, #0
 8008b6c:	4618      	mov	r0, r3
 8008b6e:	f01e fb30 	bl	80271d2 <memset>

  /* USER CODE BEGIN TIM1_Init 1 */

  /* USER CODE END TIM1_Init 1 */
  htim1.Instance = TIM1;
 8008b72:	4b39      	ldr	r3, [pc, #228]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b74:	4a39      	ldr	r2, [pc, #228]	; (8008c5c <MX_TIM1_Init+0x11c>)
 8008b76:	601a      	str	r2, [r3, #0]
  htim1.Init.Prescaler = 7843;
 8008b78:	4b37      	ldr	r3, [pc, #220]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b7a:	f641 62a3 	movw	r2, #7843	; 0x1ea3
 8008b7e:	605a      	str	r2, [r3, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008b80:	4b35      	ldr	r3, [pc, #212]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b82:	2200      	movs	r2, #0
 8008b84:	609a      	str	r2, [r3, #8]
  htim1.Init.Period = 254;
 8008b86:	4b34      	ldr	r3, [pc, #208]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b88:	22fe      	movs	r2, #254	; 0xfe
 8008b8a:	60da      	str	r2, [r3, #12]
  htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008b8c:	4b32      	ldr	r3, [pc, #200]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b8e:	2200      	movs	r2, #0
 8008b90:	611a      	str	r2, [r3, #16]
  htim1.Init.RepetitionCounter = 0;
 8008b92:	4b31      	ldr	r3, [pc, #196]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b94:	2200      	movs	r2, #0
 8008b96:	615a      	str	r2, [r3, #20]
  htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008b98:	4b2f      	ldr	r3, [pc, #188]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008b9a:	2200      	movs	r2, #0
 8008b9c:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 8008b9e:	482e      	ldr	r0, [pc, #184]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008ba0:	f7fd fbc0 	bl	8006324 <HAL_TIM_PWM_Init>
 8008ba4:	4603      	mov	r3, r0
 8008ba6:	2b00      	cmp	r3, #0
 8008ba8:	d001      	beq.n	8008bae <MX_TIM1_Init+0x6e>
  {
    Error_Handler();
 8008baa:	f000 fde7 	bl	800977c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008bae:	2300      	movs	r3, #0
 8008bb0:	64fb      	str	r3, [r7, #76]	; 0x4c
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8008bb2:	2300      	movs	r3, #0
 8008bb4:	653b      	str	r3, [r7, #80]	; 0x50
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8008bb6:	2300      	movs	r3, #0
 8008bb8:	657b      	str	r3, [r7, #84]	; 0x54
  if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 8008bba:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 8008bbe:	4619      	mov	r1, r3
 8008bc0:	4825      	ldr	r0, [pc, #148]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008bc2:	f7fe fa8b 	bl	80070dc <HAL_TIMEx_MasterConfigSynchronization>
 8008bc6:	4603      	mov	r3, r0
 8008bc8:	2b00      	cmp	r3, #0
 8008bca:	d001      	beq.n	8008bd0 <MX_TIM1_Init+0x90>
  {
    Error_Handler();
 8008bcc:	f000 fdd6 	bl	800977c <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8008bd0:	2360      	movs	r3, #96	; 0x60
 8008bd2:	633b      	str	r3, [r7, #48]	; 0x30
  sConfigOC.Pulse = 0;
 8008bd4:	2300      	movs	r3, #0
 8008bd6:	637b      	str	r3, [r7, #52]	; 0x34
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8008bd8:	2300      	movs	r3, #0
 8008bda:	63bb      	str	r3, [r7, #56]	; 0x38
  sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 8008bdc:	2300      	movs	r3, #0
 8008bde:	63fb      	str	r3, [r7, #60]	; 0x3c
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8008be0:	2300      	movs	r3, #0
 8008be2:	643b      	str	r3, [r7, #64]	; 0x40
  sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 8008be4:	2300      	movs	r3, #0
 8008be6:	647b      	str	r3, [r7, #68]	; 0x44
  sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 8008be8:	2300      	movs	r3, #0
 8008bea:	64bb      	str	r3, [r7, #72]	; 0x48
  if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8008bec:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8008bf0:	2200      	movs	r2, #0
 8008bf2:	4619      	mov	r1, r3
 8008bf4:	4818      	ldr	r0, [pc, #96]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008bf6:	f7fd fcdf 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8008bfa:	4603      	mov	r3, r0
 8008bfc:	2b00      	cmp	r3, #0
 8008bfe:	d001      	beq.n	8008c04 <MX_TIM1_Init+0xc4>
  {
    Error_Handler();
 8008c00:	f000 fdbc 	bl	800977c <Error_Handler>
  }
  sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 8008c04:	2300      	movs	r3, #0
 8008c06:	607b      	str	r3, [r7, #4]
  sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 8008c08:	2300      	movs	r3, #0
 8008c0a:	60bb      	str	r3, [r7, #8]
  sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 8008c0c:	2300      	movs	r3, #0
 8008c0e:	60fb      	str	r3, [r7, #12]
  sBreakDeadTimeConfig.DeadTime = 0;
 8008c10:	2300      	movs	r3, #0
 8008c12:	613b      	str	r3, [r7, #16]
  sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 8008c14:	2300      	movs	r3, #0
 8008c16:	617b      	str	r3, [r7, #20]
  sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 8008c18:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8008c1c:	61bb      	str	r3, [r7, #24]
  sBreakDeadTimeConfig.BreakFilter = 0;
 8008c1e:	2300      	movs	r3, #0
 8008c20:	61fb      	str	r3, [r7, #28]
  sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
 8008c22:	2300      	movs	r3, #0
 8008c24:	623b      	str	r3, [r7, #32]
  sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
 8008c26:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8008c2a:	627b      	str	r3, [r7, #36]	; 0x24
  sBreakDeadTimeConfig.Break2Filter = 0;
 8008c2c:	2300      	movs	r3, #0
 8008c2e:	62bb      	str	r3, [r7, #40]	; 0x28
  sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 8008c30:	2300      	movs	r3, #0
 8008c32:	62fb      	str	r3, [r7, #44]	; 0x2c
  if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 8008c34:	1d3b      	adds	r3, r7, #4
 8008c36:	4619      	mov	r1, r3
 8008c38:	4807      	ldr	r0, [pc, #28]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008c3a:	f7fe faab 	bl	8007194 <HAL_TIMEx_ConfigBreakDeadTime>
 8008c3e:	4603      	mov	r3, r0
 8008c40:	2b00      	cmp	r3, #0
 8008c42:	d001      	beq.n	8008c48 <MX_TIM1_Init+0x108>
  {
    Error_Handler();
 8008c44:	f000 fd9a 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN TIM1_Init 2 */

  /* USER CODE END TIM1_Init 2 */
  HAL_TIM_MspPostInit(&htim1);
 8008c48:	4803      	ldr	r0, [pc, #12]	; (8008c58 <MX_TIM1_Init+0x118>)
 8008c4a:	f001 f863 	bl	8009d14 <HAL_TIM_MspPostInit>

}
 8008c4e:	bf00      	nop
 8008c50:	3758      	adds	r7, #88	; 0x58
 8008c52:	46bd      	mov	sp, r7
 8008c54:	bd80      	pop	{r7, pc}
 8008c56:	bf00      	nop
 8008c58:	2000d738 	.word	0x2000d738
 8008c5c:	40010000 	.word	0x40010000

08008c60 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 8008c60:	b580      	push	{r7, lr}
 8008c62:	b08e      	sub	sp, #56	; 0x38
 8008c64:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8008c66:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008c6a:	2200      	movs	r2, #0
 8008c6c:	601a      	str	r2, [r3, #0]
 8008c6e:	605a      	str	r2, [r3, #4]
 8008c70:	609a      	str	r2, [r3, #8]
 8008c72:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8008c74:	f107 031c 	add.w	r3, r7, #28
 8008c78:	2200      	movs	r2, #0
 8008c7a:	601a      	str	r2, [r3, #0]
 8008c7c:	605a      	str	r2, [r3, #4]
 8008c7e:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8008c80:	463b      	mov	r3, r7
 8008c82:	2200      	movs	r2, #0
 8008c84:	601a      	str	r2, [r3, #0]
 8008c86:	605a      	str	r2, [r3, #4]
 8008c88:	609a      	str	r2, [r3, #8]
 8008c8a:	60da      	str	r2, [r3, #12]
 8008c8c:	611a      	str	r2, [r3, #16]
 8008c8e:	615a      	str	r2, [r3, #20]
 8008c90:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8008c92:	4b2d      	ldr	r3, [pc, #180]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008c94:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8008c98:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 7843;
 8008c9a:	4b2b      	ldr	r3, [pc, #172]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008c9c:	f641 62a3 	movw	r2, #7843	; 0x1ea3
 8008ca0:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008ca2:	4b29      	ldr	r3, [pc, #164]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008ca4:	2200      	movs	r2, #0
 8008ca6:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 254;
 8008ca8:	4b27      	ldr	r3, [pc, #156]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008caa:	22fe      	movs	r2, #254	; 0xfe
 8008cac:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008cae:	4b26      	ldr	r3, [pc, #152]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008cb0:	2200      	movs	r2, #0
 8008cb2:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008cb4:	4b24      	ldr	r3, [pc, #144]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008cb6:	2200      	movs	r2, #0
 8008cb8:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8008cba:	4823      	ldr	r0, [pc, #140]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008cbc:	f7fd fadd 	bl	800627a <HAL_TIM_Base_Init>
 8008cc0:	4603      	mov	r3, r0
 8008cc2:	2b00      	cmp	r3, #0
 8008cc4:	d001      	beq.n	8008cca <MX_TIM2_Init+0x6a>
  {
    Error_Handler();
 8008cc6:	f000 fd59 	bl	800977c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008cca:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008cce:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8008cd0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008cd4:	4619      	mov	r1, r3
 8008cd6:	481c      	ldr	r0, [pc, #112]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008cd8:	f7fd fd86 	bl	80067e8 <HAL_TIM_ConfigClockSource>
 8008cdc:	4603      	mov	r3, r0
 8008cde:	2b00      	cmp	r3, #0
 8008ce0:	d001      	beq.n	8008ce6 <MX_TIM2_Init+0x86>
  {
    Error_Handler();
 8008ce2:	f000 fd4b 	bl	800977c <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
 8008ce6:	4818      	ldr	r0, [pc, #96]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008ce8:	f7fd fb1c 	bl	8006324 <HAL_TIM_PWM_Init>
 8008cec:	4603      	mov	r3, r0
 8008cee:	2b00      	cmp	r3, #0
 8008cf0:	d001      	beq.n	8008cf6 <MX_TIM2_Init+0x96>
  {
    Error_Handler();
 8008cf2:	f000 fd43 	bl	800977c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008cf6:	2300      	movs	r3, #0
 8008cf8:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8008cfa:	2300      	movs	r3, #0
 8008cfc:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8008cfe:	f107 031c 	add.w	r3, r7, #28
 8008d02:	4619      	mov	r1, r3
 8008d04:	4810      	ldr	r0, [pc, #64]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008d06:	f7fe f9e9 	bl	80070dc <HAL_TIMEx_MasterConfigSynchronization>
 8008d0a:	4603      	mov	r3, r0
 8008d0c:	2b00      	cmp	r3, #0
 8008d0e:	d001      	beq.n	8008d14 <MX_TIM2_Init+0xb4>
  {
    Error_Handler();
 8008d10:	f000 fd34 	bl	800977c <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8008d14:	2360      	movs	r3, #96	; 0x60
 8008d16:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 0;
 8008d18:	2300      	movs	r3, #0
 8008d1a:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8008d1c:	2300      	movs	r3, #0
 8008d1e:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8008d20:	2300      	movs	r3, #0
 8008d22:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8008d24:	463b      	mov	r3, r7
 8008d26:	2200      	movs	r2, #0
 8008d28:	4619      	mov	r1, r3
 8008d2a:	4807      	ldr	r0, [pc, #28]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008d2c:	f7fd fc44 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8008d30:	4603      	mov	r3, r0
 8008d32:	2b00      	cmp	r3, #0
 8008d34:	d001      	beq.n	8008d3a <MX_TIM2_Init+0xda>
  {
    Error_Handler();
 8008d36:	f000 fd21 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */
  HAL_TIM_MspPostInit(&htim2);
 8008d3a:	4803      	ldr	r0, [pc, #12]	; (8008d48 <MX_TIM2_Init+0xe8>)
 8008d3c:	f000 ffea 	bl	8009d14 <HAL_TIM_MspPostInit>

}
 8008d40:	bf00      	nop
 8008d42:	3738      	adds	r7, #56	; 0x38
 8008d44:	46bd      	mov	sp, r7
 8008d46:	bd80      	pop	{r7, pc}
 8008d48:	2000d838 	.word	0x2000d838

08008d4c <MX_TIM3_Init>:
  * @brief TIM3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM3_Init(void)
{
 8008d4c:	b580      	push	{r7, lr}
 8008d4e:	b08e      	sub	sp, #56	; 0x38
 8008d50:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM3_Init 0 */

  /* USER CODE END TIM3_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8008d52:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008d56:	2200      	movs	r2, #0
 8008d58:	601a      	str	r2, [r3, #0]
 8008d5a:	605a      	str	r2, [r3, #4]
 8008d5c:	609a      	str	r2, [r3, #8]
 8008d5e:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8008d60:	f107 031c 	add.w	r3, r7, #28
 8008d64:	2200      	movs	r2, #0
 8008d66:	601a      	str	r2, [r3, #0]
 8008d68:	605a      	str	r2, [r3, #4]
 8008d6a:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8008d6c:	463b      	mov	r3, r7
 8008d6e:	2200      	movs	r2, #0
 8008d70:	601a      	str	r2, [r3, #0]
 8008d72:	605a      	str	r2, [r3, #4]
 8008d74:	609a      	str	r2, [r3, #8]
 8008d76:	60da      	str	r2, [r3, #12]
 8008d78:	611a      	str	r2, [r3, #16]
 8008d7a:	615a      	str	r2, [r3, #20]
 8008d7c:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM3_Init 1 */

  /* USER CODE END TIM3_Init 1 */
  htim3.Instance = TIM3;
 8008d7e:	4b2d      	ldr	r3, [pc, #180]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008d80:	4a2d      	ldr	r2, [pc, #180]	; (8008e38 <MX_TIM3_Init+0xec>)
 8008d82:	601a      	str	r2, [r3, #0]
  htim3.Init.Prescaler = 7843;
 8008d84:	4b2b      	ldr	r3, [pc, #172]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008d86:	f641 62a3 	movw	r2, #7843	; 0x1ea3
 8008d8a:	605a      	str	r2, [r3, #4]
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008d8c:	4b29      	ldr	r3, [pc, #164]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008d8e:	2200      	movs	r2, #0
 8008d90:	609a      	str	r2, [r3, #8]
  htim3.Init.Period = 254;
 8008d92:	4b28      	ldr	r3, [pc, #160]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008d94:	22fe      	movs	r2, #254	; 0xfe
 8008d96:	60da      	str	r2, [r3, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008d98:	4b26      	ldr	r3, [pc, #152]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008d9a:	2200      	movs	r2, #0
 8008d9c:	611a      	str	r2, [r3, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008d9e:	4b25      	ldr	r3, [pc, #148]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008da0:	2200      	movs	r2, #0
 8008da2:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
 8008da4:	4823      	ldr	r0, [pc, #140]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008da6:	f7fd fa68 	bl	800627a <HAL_TIM_Base_Init>
 8008daa:	4603      	mov	r3, r0
 8008dac:	2b00      	cmp	r3, #0
 8008dae:	d001      	beq.n	8008db4 <MX_TIM3_Init+0x68>
  {
    Error_Handler();
 8008db0:	f000 fce4 	bl	800977c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008db4:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008db8:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
 8008dba:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008dbe:	4619      	mov	r1, r3
 8008dc0:	481c      	ldr	r0, [pc, #112]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008dc2:	f7fd fd11 	bl	80067e8 <HAL_TIM_ConfigClockSource>
 8008dc6:	4603      	mov	r3, r0
 8008dc8:	2b00      	cmp	r3, #0
 8008dca:	d001      	beq.n	8008dd0 <MX_TIM3_Init+0x84>
  {
    Error_Handler();
 8008dcc:	f000 fcd6 	bl	800977c <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 8008dd0:	4818      	ldr	r0, [pc, #96]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008dd2:	f7fd faa7 	bl	8006324 <HAL_TIM_PWM_Init>
 8008dd6:	4603      	mov	r3, r0
 8008dd8:	2b00      	cmp	r3, #0
 8008dda:	d001      	beq.n	8008de0 <MX_TIM3_Init+0x94>
  {
    Error_Handler();
 8008ddc:	f000 fcce 	bl	800977c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008de0:	2300      	movs	r3, #0
 8008de2:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8008de4:	2300      	movs	r3, #0
 8008de6:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 8008de8:	f107 031c 	add.w	r3, r7, #28
 8008dec:	4619      	mov	r1, r3
 8008dee:	4811      	ldr	r0, [pc, #68]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008df0:	f7fe f974 	bl	80070dc <HAL_TIMEx_MasterConfigSynchronization>
 8008df4:	4603      	mov	r3, r0
 8008df6:	2b00      	cmp	r3, #0
 8008df8:	d001      	beq.n	8008dfe <MX_TIM3_Init+0xb2>
  {
    Error_Handler();
 8008dfa:	f000 fcbf 	bl	800977c <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8008dfe:	2360      	movs	r3, #96	; 0x60
 8008e00:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 0;
 8008e02:	2300      	movs	r3, #0
 8008e04:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8008e06:	2300      	movs	r3, #0
 8008e08:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8008e0a:	2300      	movs	r3, #0
 8008e0c:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8008e0e:	463b      	mov	r3, r7
 8008e10:	2200      	movs	r2, #0
 8008e12:	4619      	mov	r1, r3
 8008e14:	4807      	ldr	r0, [pc, #28]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008e16:	f7fd fbcf 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8008e1a:	4603      	mov	r3, r0
 8008e1c:	2b00      	cmp	r3, #0
 8008e1e:	d001      	beq.n	8008e24 <MX_TIM3_Init+0xd8>
  {
    Error_Handler();
 8008e20:	f000 fcac 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN TIM3_Init 2 */

  /* USER CODE END TIM3_Init 2 */
  HAL_TIM_MspPostInit(&htim3);
 8008e24:	4803      	ldr	r0, [pc, #12]	; (8008e34 <MX_TIM3_Init+0xe8>)
 8008e26:	f000 ff75 	bl	8009d14 <HAL_TIM_MspPostInit>

}
 8008e2a:	bf00      	nop
 8008e2c:	3738      	adds	r7, #56	; 0x38
 8008e2e:	46bd      	mov	sp, r7
 8008e30:	bd80      	pop	{r7, pc}
 8008e32:	bf00      	nop
 8008e34:	2000d518 	.word	0x2000d518
 8008e38:	40000400 	.word	0x40000400

08008e3c <MX_TIM5_Init>:
  * @brief TIM5 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM5_Init(void)
{
 8008e3c:	b580      	push	{r7, lr}
 8008e3e:	b08e      	sub	sp, #56	; 0x38
 8008e40:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM5_Init 0 */

  /* USER CODE END TIM5_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8008e42:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008e46:	2200      	movs	r2, #0
 8008e48:	601a      	str	r2, [r3, #0]
 8008e4a:	605a      	str	r2, [r3, #4]
 8008e4c:	609a      	str	r2, [r3, #8]
 8008e4e:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8008e50:	f107 031c 	add.w	r3, r7, #28
 8008e54:	2200      	movs	r2, #0
 8008e56:	601a      	str	r2, [r3, #0]
 8008e58:	605a      	str	r2, [r3, #4]
 8008e5a:	609a      	str	r2, [r3, #8]
  TIM_OC_InitTypeDef sConfigOC = {0};
 8008e5c:	463b      	mov	r3, r7
 8008e5e:	2200      	movs	r2, #0
 8008e60:	601a      	str	r2, [r3, #0]
 8008e62:	605a      	str	r2, [r3, #4]
 8008e64:	609a      	str	r2, [r3, #8]
 8008e66:	60da      	str	r2, [r3, #12]
 8008e68:	611a      	str	r2, [r3, #16]
 8008e6a:	615a      	str	r2, [r3, #20]
 8008e6c:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM5_Init 1 */

  /* USER CODE END TIM5_Init 1 */
  htim5.Instance = TIM5;
 8008e6e:	4b2c      	ldr	r3, [pc, #176]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e70:	4a2c      	ldr	r2, [pc, #176]	; (8008f24 <MX_TIM5_Init+0xe8>)
 8008e72:	601a      	str	r2, [r3, #0]
  htim5.Init.Prescaler = 0;
 8008e74:	4b2a      	ldr	r3, [pc, #168]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e76:	2200      	movs	r2, #0
 8008e78:	605a      	str	r2, [r3, #4]
  htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008e7a:	4b29      	ldr	r3, [pc, #164]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e7c:	2200      	movs	r2, #0
 8008e7e:	609a      	str	r2, [r3, #8]
  htim5.Init.Period = 0;
 8008e80:	4b27      	ldr	r3, [pc, #156]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e82:	2200      	movs	r2, #0
 8008e84:	60da      	str	r2, [r3, #12]
  htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008e86:	4b26      	ldr	r3, [pc, #152]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e88:	2200      	movs	r2, #0
 8008e8a:	611a      	str	r2, [r3, #16]
  htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008e8c:	4b24      	ldr	r3, [pc, #144]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e8e:	2200      	movs	r2, #0
 8008e90:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
 8008e92:	4823      	ldr	r0, [pc, #140]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008e94:	f7fd f9f1 	bl	800627a <HAL_TIM_Base_Init>
 8008e98:	4603      	mov	r3, r0
 8008e9a:	2b00      	cmp	r3, #0
 8008e9c:	d001      	beq.n	8008ea2 <MX_TIM5_Init+0x66>
  {
    Error_Handler();
 8008e9e:	f000 fc6d 	bl	800977c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008ea2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008ea6:	62bb      	str	r3, [r7, #40]	; 0x28
  if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
 8008ea8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8008eac:	4619      	mov	r1, r3
 8008eae:	481c      	ldr	r0, [pc, #112]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008eb0:	f7fd fc9a 	bl	80067e8 <HAL_TIM_ConfigClockSource>
 8008eb4:	4603      	mov	r3, r0
 8008eb6:	2b00      	cmp	r3, #0
 8008eb8:	d001      	beq.n	8008ebe <MX_TIM5_Init+0x82>
  {
    Error_Handler();
 8008eba:	f000 fc5f 	bl	800977c <Error_Handler>
  }
  if (HAL_TIM_PWM_Init(&htim5) != HAL_OK)
 8008ebe:	4818      	ldr	r0, [pc, #96]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008ec0:	f7fd fa30 	bl	8006324 <HAL_TIM_PWM_Init>
 8008ec4:	4603      	mov	r3, r0
 8008ec6:	2b00      	cmp	r3, #0
 8008ec8:	d001      	beq.n	8008ece <MX_TIM5_Init+0x92>
  {
    Error_Handler();
 8008eca:	f000 fc57 	bl	800977c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008ece:	2300      	movs	r3, #0
 8008ed0:	61fb      	str	r3, [r7, #28]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8008ed2:	2300      	movs	r3, #0
 8008ed4:	627b      	str	r3, [r7, #36]	; 0x24
  if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
 8008ed6:	f107 031c 	add.w	r3, r7, #28
 8008eda:	4619      	mov	r1, r3
 8008edc:	4810      	ldr	r0, [pc, #64]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008ede:	f7fe f8fd 	bl	80070dc <HAL_TIMEx_MasterConfigSynchronization>
 8008ee2:	4603      	mov	r3, r0
 8008ee4:	2b00      	cmp	r3, #0
 8008ee6:	d001      	beq.n	8008eec <MX_TIM5_Init+0xb0>
  {
    Error_Handler();
 8008ee8:	f000 fc48 	bl	800977c <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8008eec:	2360      	movs	r3, #96	; 0x60
 8008eee:	603b      	str	r3, [r7, #0]
  sConfigOC.Pulse = 0;
 8008ef0:	2300      	movs	r3, #0
 8008ef2:	607b      	str	r3, [r7, #4]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8008ef4:	2300      	movs	r3, #0
 8008ef6:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8008ef8:	2300      	movs	r3, #0
 8008efa:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_PWM_ConfigChannel(&htim5, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
 8008efc:	463b      	mov	r3, r7
 8008efe:	220c      	movs	r2, #12
 8008f00:	4619      	mov	r1, r3
 8008f02:	4807      	ldr	r0, [pc, #28]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008f04:	f7fd fb58 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8008f08:	4603      	mov	r3, r0
 8008f0a:	2b00      	cmp	r3, #0
 8008f0c:	d001      	beq.n	8008f12 <MX_TIM5_Init+0xd6>
  {
    Error_Handler();
 8008f0e:	f000 fc35 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN TIM5_Init 2 */

  /* USER CODE END TIM5_Init 2 */
  HAL_TIM_MspPostInit(&htim5);
 8008f12:	4803      	ldr	r0, [pc, #12]	; (8008f20 <MX_TIM5_Init+0xe4>)
 8008f14:	f000 fefe 	bl	8009d14 <HAL_TIM_MspPostInit>

}
 8008f18:	bf00      	nop
 8008f1a:	3738      	adds	r7, #56	; 0x38
 8008f1c:	46bd      	mov	sp, r7
 8008f1e:	bd80      	pop	{r7, pc}
 8008f20:	2000d4d8 	.word	0x2000d4d8
 8008f24:	40000c00 	.word	0x40000c00

08008f28 <MX_TIM8_Init>:
  * @brief TIM8 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM8_Init(void)
{
 8008f28:	b580      	push	{r7, lr}
 8008f2a:	b088      	sub	sp, #32
 8008f2c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM8_Init 0 */

  /* USER CODE END TIM8_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8008f2e:	f107 0310 	add.w	r3, r7, #16
 8008f32:	2200      	movs	r2, #0
 8008f34:	601a      	str	r2, [r3, #0]
 8008f36:	605a      	str	r2, [r3, #4]
 8008f38:	609a      	str	r2, [r3, #8]
 8008f3a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8008f3c:	1d3b      	adds	r3, r7, #4
 8008f3e:	2200      	movs	r2, #0
 8008f40:	601a      	str	r2, [r3, #0]
 8008f42:	605a      	str	r2, [r3, #4]
 8008f44:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM8_Init 1 */

  /* USER CODE END TIM8_Init 1 */
  htim8.Instance = TIM8;
 8008f46:	4b1f      	ldr	r3, [pc, #124]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f48:	4a1f      	ldr	r2, [pc, #124]	; (8008fc8 <MX_TIM8_Init+0xa0>)
 8008f4a:	601a      	str	r2, [r3, #0]
  htim8.Init.Prescaler = 0;
 8008f4c:	4b1d      	ldr	r3, [pc, #116]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f4e:	2200      	movs	r2, #0
 8008f50:	605a      	str	r2, [r3, #4]
  htim8.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008f52:	4b1c      	ldr	r3, [pc, #112]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f54:	2200      	movs	r2, #0
 8008f56:	609a      	str	r2, [r3, #8]
  htim8.Init.Period = 0;
 8008f58:	4b1a      	ldr	r3, [pc, #104]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f5a:	2200      	movs	r2, #0
 8008f5c:	60da      	str	r2, [r3, #12]
  htim8.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008f5e:	4b19      	ldr	r3, [pc, #100]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f60:	2200      	movs	r2, #0
 8008f62:	611a      	str	r2, [r3, #16]
  htim8.Init.RepetitionCounter = 0;
 8008f64:	4b17      	ldr	r3, [pc, #92]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f66:	2200      	movs	r2, #0
 8008f68:	615a      	str	r2, [r3, #20]
  htim8.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8008f6a:	4b16      	ldr	r3, [pc, #88]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f6c:	2200      	movs	r2, #0
 8008f6e:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim8) != HAL_OK)
 8008f70:	4814      	ldr	r0, [pc, #80]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f72:	f7fd f982 	bl	800627a <HAL_TIM_Base_Init>
 8008f76:	4603      	mov	r3, r0
 8008f78:	2b00      	cmp	r3, #0
 8008f7a:	d001      	beq.n	8008f80 <MX_TIM8_Init+0x58>
  {
    Error_Handler();
 8008f7c:	f000 fbfe 	bl	800977c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8008f80:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008f84:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim8, &sClockSourceConfig) != HAL_OK)
 8008f86:	f107 0310 	add.w	r3, r7, #16
 8008f8a:	4619      	mov	r1, r3
 8008f8c:	480d      	ldr	r0, [pc, #52]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008f8e:	f7fd fc2b 	bl	80067e8 <HAL_TIM_ConfigClockSource>
 8008f92:	4603      	mov	r3, r0
 8008f94:	2b00      	cmp	r3, #0
 8008f96:	d001      	beq.n	8008f9c <MX_TIM8_Init+0x74>
  {
    Error_Handler();
 8008f98:	f000 fbf0 	bl	800977c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8008f9c:	2300      	movs	r3, #0
 8008f9e:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
 8008fa0:	2300      	movs	r3, #0
 8008fa2:	60bb      	str	r3, [r7, #8]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8008fa4:	2300      	movs	r3, #0
 8008fa6:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim8, &sMasterConfig) != HAL_OK)
 8008fa8:	1d3b      	adds	r3, r7, #4
 8008faa:	4619      	mov	r1, r3
 8008fac:	4805      	ldr	r0, [pc, #20]	; (8008fc4 <MX_TIM8_Init+0x9c>)
 8008fae:	f7fe f895 	bl	80070dc <HAL_TIMEx_MasterConfigSynchronization>
 8008fb2:	4603      	mov	r3, r0
 8008fb4:	2b00      	cmp	r3, #0
 8008fb6:	d001      	beq.n	8008fbc <MX_TIM8_Init+0x94>
  {
    Error_Handler();
 8008fb8:	f000 fbe0 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN TIM8_Init 2 */

  /* USER CODE END TIM8_Init 2 */

}
 8008fbc:	bf00      	nop
 8008fbe:	3720      	adds	r7, #32
 8008fc0:	46bd      	mov	sp, r7
 8008fc2:	bd80      	pop	{r7, pc}
 8008fc4:	2000d414 	.word	0x2000d414
 8008fc8:	40010400 	.word	0x40010400

08008fcc <MX_TIM12_Init>:
  * @brief TIM12 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM12_Init(void)
{
 8008fcc:	b580      	push	{r7, lr}
 8008fce:	b088      	sub	sp, #32
 8008fd0:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM12_Init 0 */

  /* USER CODE END TIM12_Init 0 */

  TIM_OC_InitTypeDef sConfigOC = {0};
 8008fd2:	1d3b      	adds	r3, r7, #4
 8008fd4:	2200      	movs	r2, #0
 8008fd6:	601a      	str	r2, [r3, #0]
 8008fd8:	605a      	str	r2, [r3, #4]
 8008fda:	609a      	str	r2, [r3, #8]
 8008fdc:	60da      	str	r2, [r3, #12]
 8008fde:	611a      	str	r2, [r3, #16]
 8008fe0:	615a      	str	r2, [r3, #20]
 8008fe2:	619a      	str	r2, [r3, #24]

  /* USER CODE BEGIN TIM12_Init 1 */

  /* USER CODE END TIM12_Init 1 */
  htim12.Instance = TIM12;
 8008fe4:	4b19      	ldr	r3, [pc, #100]	; (800904c <MX_TIM12_Init+0x80>)
 8008fe6:	4a1a      	ldr	r2, [pc, #104]	; (8009050 <MX_TIM12_Init+0x84>)
 8008fe8:	601a      	str	r2, [r3, #0]
  htim12.Init.Prescaler = 0;
 8008fea:	4b18      	ldr	r3, [pc, #96]	; (800904c <MX_TIM12_Init+0x80>)
 8008fec:	2200      	movs	r2, #0
 8008fee:	605a      	str	r2, [r3, #4]
  htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
 8008ff0:	4b16      	ldr	r3, [pc, #88]	; (800904c <MX_TIM12_Init+0x80>)
 8008ff2:	2200      	movs	r2, #0
 8008ff4:	609a      	str	r2, [r3, #8]
  htim12.Init.Period = 0;
 8008ff6:	4b15      	ldr	r3, [pc, #84]	; (800904c <MX_TIM12_Init+0x80>)
 8008ff8:	2200      	movs	r2, #0
 8008ffa:	60da      	str	r2, [r3, #12]
  htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8008ffc:	4b13      	ldr	r3, [pc, #76]	; (800904c <MX_TIM12_Init+0x80>)
 8008ffe:	2200      	movs	r2, #0
 8009000:	611a      	str	r2, [r3, #16]
  htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8009002:	4b12      	ldr	r3, [pc, #72]	; (800904c <MX_TIM12_Init+0x80>)
 8009004:	2200      	movs	r2, #0
 8009006:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_PWM_Init(&htim12) != HAL_OK)
 8009008:	4810      	ldr	r0, [pc, #64]	; (800904c <MX_TIM12_Init+0x80>)
 800900a:	f7fd f98b 	bl	8006324 <HAL_TIM_PWM_Init>
 800900e:	4603      	mov	r3, r0
 8009010:	2b00      	cmp	r3, #0
 8009012:	d001      	beq.n	8009018 <MX_TIM12_Init+0x4c>
  {
    Error_Handler();
 8009014:	f000 fbb2 	bl	800977c <Error_Handler>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 8009018:	2360      	movs	r3, #96	; 0x60
 800901a:	607b      	str	r3, [r7, #4]
  sConfigOC.Pulse = 0;
 800901c:	2300      	movs	r3, #0
 800901e:	60bb      	str	r3, [r7, #8]
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 8009020:	2300      	movs	r3, #0
 8009022:	60fb      	str	r3, [r7, #12]
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 8009024:	2300      	movs	r3, #0
 8009026:	617b      	str	r3, [r7, #20]
  if (HAL_TIM_PWM_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 8009028:	1d3b      	adds	r3, r7, #4
 800902a:	2200      	movs	r2, #0
 800902c:	4619      	mov	r1, r3
 800902e:	4807      	ldr	r0, [pc, #28]	; (800904c <MX_TIM12_Init+0x80>)
 8009030:	f7fd fac2 	bl	80065b8 <HAL_TIM_PWM_ConfigChannel>
 8009034:	4603      	mov	r3, r0
 8009036:	2b00      	cmp	r3, #0
 8009038:	d001      	beq.n	800903e <MX_TIM12_Init+0x72>
  {
    Error_Handler();
 800903a:	f000 fb9f 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN TIM12_Init 2 */

  /* USER CODE END TIM12_Init 2 */
  HAL_TIM_MspPostInit(&htim12);
 800903e:	4803      	ldr	r0, [pc, #12]	; (800904c <MX_TIM12_Init+0x80>)
 8009040:	f000 fe68 	bl	8009d14 <HAL_TIM_MspPostInit>

}
 8009044:	bf00      	nop
 8009046:	3720      	adds	r7, #32
 8009048:	46bd      	mov	sp, r7
 800904a:	bd80      	pop	{r7, pc}
 800904c:	2000db3c 	.word	0x2000db3c
 8009050:	40001800 	.word	0x40001800

08009054 <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
 8009054:	b580      	push	{r7, lr}
 8009056:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 8009058:	4b14      	ldr	r3, [pc, #80]	; (80090ac <MX_USART1_UART_Init+0x58>)
 800905a:	4a15      	ldr	r2, [pc, #84]	; (80090b0 <MX_USART1_UART_Init+0x5c>)
 800905c:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
 800905e:	4b13      	ldr	r3, [pc, #76]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009060:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 8009064:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8009066:	4b11      	ldr	r3, [pc, #68]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009068:	2200      	movs	r2, #0
 800906a:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
 800906c:	4b0f      	ldr	r3, [pc, #60]	; (80090ac <MX_USART1_UART_Init+0x58>)
 800906e:	2200      	movs	r2, #0
 8009070:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
 8009072:	4b0e      	ldr	r3, [pc, #56]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009074:	2200      	movs	r2, #0
 8009076:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
 8009078:	4b0c      	ldr	r3, [pc, #48]	; (80090ac <MX_USART1_UART_Init+0x58>)
 800907a:	220c      	movs	r2, #12
 800907c:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800907e:	4b0b      	ldr	r3, [pc, #44]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009080:	2200      	movs	r2, #0
 8009082:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
 8009084:	4b09      	ldr	r3, [pc, #36]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009086:	2200      	movs	r2, #0
 8009088:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800908a:	4b08      	ldr	r3, [pc, #32]	; (80090ac <MX_USART1_UART_Init+0x58>)
 800908c:	2200      	movs	r2, #0
 800908e:	621a      	str	r2, [r3, #32]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8009090:	4b06      	ldr	r3, [pc, #24]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009092:	2200      	movs	r2, #0
 8009094:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8009096:	4805      	ldr	r0, [pc, #20]	; (80090ac <MX_USART1_UART_Init+0x58>)
 8009098:	f7fe f918 	bl	80072cc <HAL_UART_Init>
 800909c:	4603      	mov	r3, r0
 800909e:	2b00      	cmp	r3, #0
 80090a0:	d001      	beq.n	80090a6 <MX_USART1_UART_Init+0x52>
  {
    Error_Handler();
 80090a2:	f000 fb6b 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
 80090a6:	bf00      	nop
 80090a8:	bd80      	pop	{r7, pc}
 80090aa:	bf00      	nop
 80090ac:	2000d698 	.word	0x2000d698
 80090b0:	40011000 	.word	0x40011000

080090b4 <MX_USART6_UART_Init>:
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{
 80090b4:	b580      	push	{r7, lr}
 80090b6:	af00      	add	r7, sp, #0
  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
 80090b8:	4b14      	ldr	r3, [pc, #80]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090ba:	4a15      	ldr	r2, [pc, #84]	; (8009110 <MX_USART6_UART_Init+0x5c>)
 80090bc:	601a      	str	r2, [r3, #0]
  huart6.Init.BaudRate = 115200;
 80090be:	4b13      	ldr	r3, [pc, #76]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090c0:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
 80090c4:	605a      	str	r2, [r3, #4]
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
 80090c6:	4b11      	ldr	r3, [pc, #68]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090c8:	2200      	movs	r2, #0
 80090ca:	609a      	str	r2, [r3, #8]
  huart6.Init.StopBits = UART_STOPBITS_1;
 80090cc:	4b0f      	ldr	r3, [pc, #60]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090ce:	2200      	movs	r2, #0
 80090d0:	60da      	str	r2, [r3, #12]
  huart6.Init.Parity = UART_PARITY_NONE;
 80090d2:	4b0e      	ldr	r3, [pc, #56]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090d4:	2200      	movs	r2, #0
 80090d6:	611a      	str	r2, [r3, #16]
  huart6.Init.Mode = UART_MODE_TX_RX;
 80090d8:	4b0c      	ldr	r3, [pc, #48]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090da:	220c      	movs	r2, #12
 80090dc:	615a      	str	r2, [r3, #20]
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 80090de:	4b0b      	ldr	r3, [pc, #44]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090e0:	2200      	movs	r2, #0
 80090e2:	619a      	str	r2, [r3, #24]
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
 80090e4:	4b09      	ldr	r3, [pc, #36]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090e6:	2200      	movs	r2, #0
 80090e8:	61da      	str	r2, [r3, #28]
  huart6.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 80090ea:	4b08      	ldr	r3, [pc, #32]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090ec:	2200      	movs	r2, #0
 80090ee:	621a      	str	r2, [r3, #32]
  huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 80090f0:	4b06      	ldr	r3, [pc, #24]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090f2:	2200      	movs	r2, #0
 80090f4:	625a      	str	r2, [r3, #36]	; 0x24
  if (HAL_UART_Init(&huart6) != HAL_OK)
 80090f6:	4805      	ldr	r0, [pc, #20]	; (800910c <MX_USART6_UART_Init+0x58>)
 80090f8:	f7fe f8e8 	bl	80072cc <HAL_UART_Init>
 80090fc:	4603      	mov	r3, r0
 80090fe:	2b00      	cmp	r3, #0
 8009100:	d001      	beq.n	8009106 <MX_USART6_UART_Init+0x52>
  {
    Error_Handler();
 8009102:	f000 fb3b 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}
 8009106:	bf00      	nop
 8009108:	bd80      	pop	{r7, pc}
 800910a:	bf00      	nop
 800910c:	2000d778 	.word	0x2000d778
 8009110:	40011400 	.word	0x40011400

08009114 <MX_USB_OTG_FS_HCD_Init>:
  * @brief USB_OTG_FS Initialization Function
  * @param None
  * @retval None
  */
static void MX_USB_OTG_FS_HCD_Init(void)
{
 8009114:	b580      	push	{r7, lr}
 8009116:	af00      	add	r7, sp, #0
  /* USER CODE END USB_OTG_FS_Init 0 */

  /* USER CODE BEGIN USB_OTG_FS_Init 1 */

  /* USER CODE END USB_OTG_FS_Init 1 */
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 8009118:	4b0e      	ldr	r3, [pc, #56]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 800911a:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 800911e:	601a      	str	r2, [r3, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 8;
 8009120:	4b0c      	ldr	r3, [pc, #48]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 8009122:	2208      	movs	r2, #8
 8009124:	609a      	str	r2, [r3, #8]
  hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL;
 8009126:	4b0b      	ldr	r3, [pc, #44]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 8009128:	2203      	movs	r2, #3
 800912a:	60da      	str	r2, [r3, #12]
  hhcd_USB_OTG_FS.Init.dma_enable = DISABLE;
 800912c:	4b09      	ldr	r3, [pc, #36]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 800912e:	2200      	movs	r2, #0
 8009130:	611a      	str	r2, [r3, #16]
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 8009132:	4b08      	ldr	r3, [pc, #32]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 8009134:	2202      	movs	r2, #2
 8009136:	619a      	str	r2, [r3, #24]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 8009138:	4b06      	ldr	r3, [pc, #24]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 800913a:	2200      	movs	r2, #0
 800913c:	61da      	str	r2, [r3, #28]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 800913e:	4805      	ldr	r0, [pc, #20]	; (8009154 <MX_USB_OTG_FS_HCD_Init+0x40>)
 8009140:	f7f8 fefa 	bl	8001f38 <HAL_HCD_Init>
 8009144:	4603      	mov	r3, r0
 8009146:	2b00      	cmp	r3, #0
 8009148:	d001      	beq.n	800914e <MX_USB_OTG_FS_HCD_Init+0x3a>
  {
    Error_Handler();
 800914a:	f000 fb17 	bl	800977c <Error_Handler>
  }
  /* USER CODE BEGIN USB_OTG_FS_Init 2 */

  /* USER CODE END USB_OTG_FS_Init 2 */

}
 800914e:	bf00      	nop
 8009150:	bd80      	pop	{r7, pc}
 8009152:	bf00      	nop
 8009154:	2000d878 	.word	0x2000d878

08009158 <MX_FMC_Init>:

/* FMC initialization function */
static void MX_FMC_Init(void)
{
 8009158:	b580      	push	{r7, lr}
 800915a:	b088      	sub	sp, #32
 800915c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN FMC_Init 0 */

  /* USER CODE END FMC_Init 0 */

  FMC_SDRAM_TimingTypeDef SdramTiming = {0};
 800915e:	1d3b      	adds	r3, r7, #4
 8009160:	2200      	movs	r2, #0
 8009162:	601a      	str	r2, [r3, #0]
 8009164:	605a      	str	r2, [r3, #4]
 8009166:	609a      	str	r2, [r3, #8]
 8009168:	60da      	str	r2, [r3, #12]
 800916a:	611a      	str	r2, [r3, #16]
 800916c:	615a      	str	r2, [r3, #20]
 800916e:	619a      	str	r2, [r3, #24]

  /* USER CODE END FMC_Init 1 */

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8009170:	4b1f      	ldr	r3, [pc, #124]	; (80091f0 <MX_FMC_Init+0x98>)
 8009172:	4a20      	ldr	r2, [pc, #128]	; (80091f4 <MX_FMC_Init+0x9c>)
 8009174:	601a      	str	r2, [r3, #0]
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8009176:	4b1e      	ldr	r3, [pc, #120]	; (80091f0 <MX_FMC_Init+0x98>)
 8009178:	2200      	movs	r2, #0
 800917a:	605a      	str	r2, [r3, #4]
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
 800917c:	4b1c      	ldr	r3, [pc, #112]	; (80091f0 <MX_FMC_Init+0x98>)
 800917e:	2200      	movs	r2, #0
 8009180:	609a      	str	r2, [r3, #8]
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
 8009182:	4b1b      	ldr	r3, [pc, #108]	; (80091f0 <MX_FMC_Init+0x98>)
 8009184:	2204      	movs	r2, #4
 8009186:	60da      	str	r2, [r3, #12]
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8009188:	4b19      	ldr	r3, [pc, #100]	; (80091f0 <MX_FMC_Init+0x98>)
 800918a:	2210      	movs	r2, #16
 800918c:	611a      	str	r2, [r3, #16]
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800918e:	4b18      	ldr	r3, [pc, #96]	; (80091f0 <MX_FMC_Init+0x98>)
 8009190:	2240      	movs	r2, #64	; 0x40
 8009192:	615a      	str	r2, [r3, #20]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_3;
 8009194:	4b16      	ldr	r3, [pc, #88]	; (80091f0 <MX_FMC_Init+0x98>)
 8009196:	f44f 72c0 	mov.w	r2, #384	; 0x180
 800919a:	619a      	str	r2, [r3, #24]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 800919c:	4b14      	ldr	r3, [pc, #80]	; (80091f0 <MX_FMC_Init+0x98>)
 800919e:	2200      	movs	r2, #0
 80091a0:	61da      	str	r2, [r3, #28]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
 80091a2:	4b13      	ldr	r3, [pc, #76]	; (80091f0 <MX_FMC_Init+0x98>)
 80091a4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 80091a8:	621a      	str	r2, [r3, #32]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 80091aa:	4b11      	ldr	r3, [pc, #68]	; (80091f0 <MX_FMC_Init+0x98>)
 80091ac:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 80091b0:	625a      	str	r2, [r3, #36]	; 0x24
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 80091b2:	4b0f      	ldr	r3, [pc, #60]	; (80091f0 <MX_FMC_Init+0x98>)
 80091b4:	2200      	movs	r2, #0
 80091b6:	629a      	str	r2, [r3, #40]	; 0x28
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
 80091b8:	2302      	movs	r3, #2
 80091ba:	607b      	str	r3, [r7, #4]
  SdramTiming.ExitSelfRefreshDelay = 7;
 80091bc:	2307      	movs	r3, #7
 80091be:	60bb      	str	r3, [r7, #8]
  SdramTiming.SelfRefreshTime = 4;
 80091c0:	2304      	movs	r3, #4
 80091c2:	60fb      	str	r3, [r7, #12]
  SdramTiming.RowCycleDelay = 7;
 80091c4:	2307      	movs	r3, #7
 80091c6:	613b      	str	r3, [r7, #16]
  SdramTiming.WriteRecoveryTime = 3;
 80091c8:	2303      	movs	r3, #3
 80091ca:	617b      	str	r3, [r7, #20]
  SdramTiming.RPDelay = 2;
 80091cc:	2302      	movs	r3, #2
 80091ce:	61bb      	str	r3, [r7, #24]
  SdramTiming.RCDDelay = 2;
 80091d0:	2302      	movs	r3, #2
 80091d2:	61fb      	str	r3, [r7, #28]

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 80091d4:	1d3b      	adds	r3, r7, #4
 80091d6:	4619      	mov	r1, r3
 80091d8:	4805      	ldr	r0, [pc, #20]	; (80091f0 <MX_FMC_Init+0x98>)
 80091da:	f7fc ffcf 	bl	800617c <HAL_SDRAM_Init>
 80091de:	4603      	mov	r3, r0
 80091e0:	2b00      	cmp	r3, #0
 80091e2:	d001      	beq.n	80091e8 <MX_FMC_Init+0x90>
  {
    Error_Handler( );
 80091e4:	f000 faca 	bl	800977c <Error_Handler>
  }

  /* USER CODE BEGIN FMC_Init 2 */

  /* USER CODE END FMC_Init 2 */
}
 80091e8:	bf00      	nop
 80091ea:	3720      	adds	r7, #32
 80091ec:	46bd      	mov	sp, r7
 80091ee:	bd80      	pop	{r7, pc}
 80091f0:	2000db7c 	.word	0x2000db7c
 80091f4:	a0000140 	.word	0xa0000140

080091f8 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 80091f8:	b580      	push	{r7, lr}
 80091fa:	b090      	sub	sp, #64	; 0x40
 80091fc:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80091fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009202:	2200      	movs	r2, #0
 8009204:	601a      	str	r2, [r3, #0]
 8009206:	605a      	str	r2, [r3, #4]
 8009208:	609a      	str	r2, [r3, #8]
 800920a:	60da      	str	r2, [r3, #12]
 800920c:	611a      	str	r2, [r3, #16]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800920e:	4bae      	ldr	r3, [pc, #696]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009210:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009212:	4aad      	ldr	r2, [pc, #692]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009214:	f043 0310 	orr.w	r3, r3, #16
 8009218:	6313      	str	r3, [r2, #48]	; 0x30
 800921a:	4bab      	ldr	r3, [pc, #684]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800921c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800921e:	f003 0310 	and.w	r3, r3, #16
 8009222:	62bb      	str	r3, [r7, #40]	; 0x28
 8009224:	6abb      	ldr	r3, [r7, #40]	; 0x28
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8009226:	4ba8      	ldr	r3, [pc, #672]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009228:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800922a:	4aa7      	ldr	r2, [pc, #668]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800922c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009230:	6313      	str	r3, [r2, #48]	; 0x30
 8009232:	4ba5      	ldr	r3, [pc, #660]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009234:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009236:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800923a:	627b      	str	r3, [r7, #36]	; 0x24
 800923c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800923e:	4ba2      	ldr	r3, [pc, #648]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009240:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009242:	4aa1      	ldr	r2, [pc, #644]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009244:	f043 0302 	orr.w	r3, r3, #2
 8009248:	6313      	str	r3, [r2, #48]	; 0x30
 800924a:	4b9f      	ldr	r3, [pc, #636]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800924c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800924e:	f003 0302 	and.w	r3, r3, #2
 8009252:	623b      	str	r3, [r7, #32]
 8009254:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8009256:	4b9c      	ldr	r3, [pc, #624]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009258:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800925a:	4a9b      	ldr	r2, [pc, #620]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800925c:	f043 0308 	orr.w	r3, r3, #8
 8009260:	6313      	str	r3, [r2, #48]	; 0x30
 8009262:	4b99      	ldr	r3, [pc, #612]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009264:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009266:	f003 0308 	and.w	r3, r3, #8
 800926a:	61fb      	str	r3, [r7, #28]
 800926c:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800926e:	4b96      	ldr	r3, [pc, #600]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009270:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009272:	4a95      	ldr	r2, [pc, #596]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009274:	f043 0304 	orr.w	r3, r3, #4
 8009278:	6313      	str	r3, [r2, #48]	; 0x30
 800927a:	4b93      	ldr	r3, [pc, #588]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800927c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800927e:	f003 0304 	and.w	r3, r3, #4
 8009282:	61bb      	str	r3, [r7, #24]
 8009284:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8009286:	4b90      	ldr	r3, [pc, #576]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009288:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800928a:	4a8f      	ldr	r2, [pc, #572]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800928c:	f043 0301 	orr.w	r3, r3, #1
 8009290:	6313      	str	r3, [r2, #48]	; 0x30
 8009292:	4b8d      	ldr	r3, [pc, #564]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009294:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009296:	f003 0301 	and.w	r3, r3, #1
 800929a:	617b      	str	r3, [r7, #20]
 800929c:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 800929e:	4b8a      	ldr	r3, [pc, #552]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092a0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092a2:	4a89      	ldr	r2, [pc, #548]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092a4:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80092a8:	6313      	str	r3, [r2, #48]	; 0x30
 80092aa:	4b87      	ldr	r3, [pc, #540]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092ac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092ae:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80092b2:	613b      	str	r3, [r7, #16]
 80092b4:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 80092b6:	4b84      	ldr	r3, [pc, #528]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092b8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092ba:	4a83      	ldr	r2, [pc, #524]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092bc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80092c0:	6313      	str	r3, [r2, #48]	; 0x30
 80092c2:	4b81      	ldr	r3, [pc, #516]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092c4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092c6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80092ca:	60fb      	str	r3, [r7, #12]
 80092cc:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOK_CLK_ENABLE();
 80092ce:	4b7e      	ldr	r3, [pc, #504]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092d2:	4a7d      	ldr	r2, [pc, #500]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092d4:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 80092d8:	6313      	str	r3, [r2, #48]	; 0x30
 80092da:	4b7b      	ldr	r3, [pc, #492]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092dc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092de:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 80092e2:	60bb      	str	r3, [r7, #8]
 80092e4:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80092e6:	4b78      	ldr	r3, [pc, #480]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092ea:	4a77      	ldr	r2, [pc, #476]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092ec:	f043 0320 	orr.w	r3, r3, #32
 80092f0:	6313      	str	r3, [r2, #48]	; 0x30
 80092f2:	4b75      	ldr	r3, [pc, #468]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 80092f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80092f6:	f003 0320 	and.w	r3, r3, #32
 80092fa:	607b      	str	r3, [r7, #4]
 80092fc:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 80092fe:	4b72      	ldr	r3, [pc, #456]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009300:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009302:	4a71      	ldr	r2, [pc, #452]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 8009304:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009308:	6313      	str	r3, [r2, #48]	; 0x30
 800930a:	4b6f      	ldr	r3, [pc, #444]	; (80094c8 <MX_GPIO_Init+0x2d0>)
 800930c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800930e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009312:	603b      	str	r3, [r7, #0]
 8009314:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
 8009316:	2201      	movs	r2, #1
 8009318:	2120      	movs	r1, #32
 800931a:	486c      	ldr	r0, [pc, #432]	; (80094cc <MX_GPIO_Init+0x2d4>)
 800931c:	f7f8 fdd8 	bl	8001ed0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOI, ARDUINO_D7_Pin|ARDUINO_D8_Pin, GPIO_PIN_RESET);
 8009320:	2200      	movs	r2, #0
 8009322:	210c      	movs	r1, #12
 8009324:	486a      	ldr	r0, [pc, #424]	; (80094d0 <MX_GPIO_Init+0x2d8>)
 8009326:	f7f8 fdd3 	bl	8001ed0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_Port, LCD_BL_CTRL_Pin, GPIO_PIN_SET);
 800932a:	2201      	movs	r2, #1
 800932c:	2108      	movs	r1, #8
 800932e:	4869      	ldr	r0, [pc, #420]	; (80094d4 <MX_GPIO_Init+0x2dc>)
 8009330:	f7f8 fdce 	bl	8001ed0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LCD_DISP_GPIO_Port, LCD_DISP_Pin, GPIO_PIN_SET);
 8009334:	2201      	movs	r2, #1
 8009336:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800933a:	4865      	ldr	r0, [pc, #404]	; (80094d0 <MX_GPIO_Init+0x2d8>)
 800933c:	f7f8 fdc8 	bl	8001ed0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(DCMI_PWR_EN_GPIO_Port, DCMI_PWR_EN_Pin, GPIO_PIN_RESET);
 8009340:	2200      	movs	r2, #0
 8009342:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8009346:	4864      	ldr	r0, [pc, #400]	; (80094d8 <MX_GPIO_Init+0x2e0>)
 8009348:	f7f8 fdc2 	bl	8001ed0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin, GPIO_PIN_RESET);
 800934c:	2200      	movs	r2, #0
 800934e:	21c8      	movs	r1, #200	; 0xc8
 8009350:	4862      	ldr	r0, [pc, #392]	; (80094dc <MX_GPIO_Init+0x2e4>)
 8009352:	f7f8 fdbd 	bl	8001ed0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : OTG_HS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_HS_OverCurrent_Pin;
 8009356:	2308      	movs	r3, #8
 8009358:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800935a:	2300      	movs	r3, #0
 800935c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800935e:	2300      	movs	r3, #0
 8009360:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(OTG_HS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 8009362:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009366:	4619      	mov	r1, r3
 8009368:	485d      	ldr	r0, [pc, #372]	; (80094e0 <MX_GPIO_Init+0x2e8>)
 800936a:	f7f8 fc07 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_D2_Pin */
  GPIO_InitStruct.Pin = QSPI_D2_Pin;
 800936e:	2304      	movs	r3, #4
 8009370:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009372:	2302      	movs	r3, #2
 8009374:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009376:	2300      	movs	r3, #0
 8009378:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800937a:	2303      	movs	r3, #3
 800937c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800937e:	2309      	movs	r3, #9
 8009380:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D2_GPIO_Port, &GPIO_InitStruct);
 8009382:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009386:	4619      	mov	r1, r3
 8009388:	4855      	ldr	r0, [pc, #340]	; (80094e0 <MX_GPIO_Init+0x2e8>)
 800938a:	f7f8 fbf7 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_TXD1_Pin RMII_TXD0_Pin RMII_TX_EN_Pin */
  GPIO_InitStruct.Pin = RMII_TXD1_Pin|RMII_TXD0_Pin|RMII_TX_EN_Pin;
 800938e:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
 8009392:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009394:	2302      	movs	r3, #2
 8009396:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009398:	2300      	movs	r3, #0
 800939a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800939c:	2303      	movs	r3, #3
 800939e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80093a0:	230b      	movs	r3, #11
 80093a2:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 80093a4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80093a8:	4619      	mov	r1, r3
 80093aa:	484c      	ldr	r0, [pc, #304]	; (80094dc <MX_GPIO_Init+0x2e4>)
 80093ac:	f7f8 fbe6 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_SCL_D15_Pin ARDUINO_SDA_D14_Pin */
  GPIO_InitStruct.Pin = ARDUINO_SCL_D15_Pin|ARDUINO_SDA_D14_Pin;
 80093b0:	f44f 7340 	mov.w	r3, #768	; 0x300
 80093b4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80093b6:	2312      	movs	r3, #18
 80093b8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80093ba:	2301      	movs	r3, #1
 80093bc:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80093be:	2300      	movs	r3, #0
 80093c0:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 80093c2:	2304      	movs	r3, #4
 80093c4:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80093c6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80093ca:	4619      	mov	r1, r3
 80093cc:	4845      	ldr	r0, [pc, #276]	; (80094e4 <MX_GPIO_Init+0x2ec>)
 80093ce:	f7f8 fbd5 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_D7_Pin ULPI_D6_Pin ULPI_D5_Pin ULPI_D3_Pin 
                           ULPI_D2_Pin ULPI_D1_Pin ULPI_D4_Pin */
  GPIO_InitStruct.Pin = ULPI_D7_Pin|ULPI_D6_Pin|ULPI_D5_Pin|ULPI_D3_Pin 
 80093d2:	f643 4323 	movw	r3, #15395	; 0x3c23
 80093d6:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |ULPI_D2_Pin|ULPI_D1_Pin|ULPI_D4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80093d8:	2302      	movs	r3, #2
 80093da:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80093dc:	2300      	movs	r3, #0
 80093de:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80093e0:	2303      	movs	r3, #3
 80093e2:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 80093e4:	230a      	movs	r3, #10
 80093e6:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80093e8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80093ec:	4619      	mov	r1, r3
 80093ee:	483d      	ldr	r0, [pc, #244]	; (80094e4 <MX_GPIO_Init+0x2ec>)
 80093f0:	f7f8 fbc4 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : SPDIF_RX0_Pin */
  GPIO_InitStruct.Pin = SPDIF_RX0_Pin;
 80093f4:	2380      	movs	r3, #128	; 0x80
 80093f6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80093f8:	2302      	movs	r3, #2
 80093fa:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80093fc:	2300      	movs	r3, #0
 80093fe:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009400:	2300      	movs	r3, #0
 8009402:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF8_SPDIFRX;
 8009404:	2308      	movs	r3, #8
 8009406:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SPDIF_RX0_GPIO_Port, &GPIO_InitStruct);
 8009408:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800940c:	4619      	mov	r1, r3
 800940e:	482f      	ldr	r0, [pc, #188]	; (80094cc <MX_GPIO_Init+0x2d4>)
 8009410:	f7f8 fbb4 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : SDMMC_CK_Pin SDMMC_D3_Pin SDMMC_D2_Pin PC9 
                           PC8 */
  GPIO_InitStruct.Pin = SDMMC_CK_Pin|SDMMC_D3_Pin|SDMMC_D2_Pin|GPIO_PIN_9 
 8009414:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
 8009418:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |GPIO_PIN_8;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800941a:	2302      	movs	r3, #2
 800941c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800941e:	2300      	movs	r3, #0
 8009420:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009422:	2303      	movs	r3, #3
 8009424:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8009426:	230c      	movs	r3, #12
 8009428:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800942a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800942e:	4619      	mov	r1, r3
 8009430:	482d      	ldr	r0, [pc, #180]	; (80094e8 <MX_GPIO_Init+0x2f0>)
 8009432:	f7f8 fba3 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_NCS_Pin */
  GPIO_InitStruct.Pin = QSPI_NCS_Pin;
 8009436:	2340      	movs	r3, #64	; 0x40
 8009438:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800943a:	2302      	movs	r3, #2
 800943c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800943e:	2300      	movs	r3, #0
 8009440:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009442:	2303      	movs	r3, #3
 8009444:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 8009446:	230a      	movs	r3, #10
 8009448:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_NCS_GPIO_Port, &GPIO_InitStruct);
 800944a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800944e:	4619      	mov	r1, r3
 8009450:	4824      	ldr	r0, [pc, #144]	; (80094e4 <MX_GPIO_Init+0x2ec>)
 8009452:	f7f8 fb93 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_VBUS_Pin */
  GPIO_InitStruct.Pin = OTG_FS_VBUS_Pin;
 8009456:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800945a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800945c:	2300      	movs	r3, #0
 800945e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009460:	2300      	movs	r3, #0
 8009462:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(OTG_FS_VBUS_GPIO_Port, &GPIO_InitStruct);
 8009464:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009468:	4619      	mov	r1, r3
 800946a:	4820      	ldr	r0, [pc, #128]	; (80094ec <MX_GPIO_Init+0x2f4>)
 800946c:	f7f8 fb86 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : Audio_INT_Pin */
  GPIO_InitStruct.Pin = Audio_INT_Pin;
 8009470:	2340      	movs	r3, #64	; 0x40
 8009472:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 8009474:	4b1e      	ldr	r3, [pc, #120]	; (80094f0 <MX_GPIO_Init+0x2f8>)
 8009476:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009478:	2300      	movs	r3, #0
 800947a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(Audio_INT_GPIO_Port, &GPIO_InitStruct);
 800947c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009480:	4619      	mov	r1, r3
 8009482:	4812      	ldr	r0, [pc, #72]	; (80094cc <MX_GPIO_Init+0x2d4>)
 8009484:	f7f8 fb7a 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_PowerSwitchOn_Pin */
  GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
 8009488:	2320      	movs	r3, #32
 800948a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800948c:	2301      	movs	r3, #1
 800948e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009490:	2300      	movs	r3, #0
 8009492:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009494:	2300      	movs	r3, #0
 8009496:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
 8009498:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800949c:	4619      	mov	r1, r3
 800949e:	480b      	ldr	r0, [pc, #44]	; (80094cc <MX_GPIO_Init+0x2d4>)
 80094a0:	f7f8 fb6c 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_D7_Pin ARDUINO_D8_Pin LCD_DISP_Pin */
  GPIO_InitStruct.Pin = ARDUINO_D7_Pin|ARDUINO_D8_Pin|LCD_DISP_Pin;
 80094a4:	f241 030c 	movw	r3, #4108	; 0x100c
 80094a8:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80094aa:	2301      	movs	r3, #1
 80094ac:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80094ae:	2300      	movs	r3, #0
 80094b0:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80094b2:	2300      	movs	r3, #0
 80094b4:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 80094b6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80094ba:	4619      	mov	r1, r3
 80094bc:	4804      	ldr	r0, [pc, #16]	; (80094d0 <MX_GPIO_Init+0x2d8>)
 80094be:	f7f8 fb5d 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : uSD_Detect_Pin */
  GPIO_InitStruct.Pin = uSD_Detect_Pin;
 80094c2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80094c6:	e015      	b.n	80094f4 <MX_GPIO_Init+0x2fc>
 80094c8:	40023800 	.word	0x40023800
 80094cc:	40020c00 	.word	0x40020c00
 80094d0:	40022000 	.word	0x40022000
 80094d4:	40022800 	.word	0x40022800
 80094d8:	40021c00 	.word	0x40021c00
 80094dc:	40021800 	.word	0x40021800
 80094e0:	40021000 	.word	0x40021000
 80094e4:	40020400 	.word	0x40020400
 80094e8:	40020800 	.word	0x40020800
 80094ec:	40022400 	.word	0x40022400
 80094f0:	10120000 	.word	0x10120000
 80094f4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80094f6:	2300      	movs	r3, #0
 80094f8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80094fa:	2300      	movs	r3, #0
 80094fc:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(uSD_Detect_GPIO_Port, &GPIO_InitStruct);
 80094fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009502:	4619      	mov	r1, r3
 8009504:	488b      	ldr	r0, [pc, #556]	; (8009734 <MX_GPIO_Init+0x53c>)
 8009506:	f7f8 fb39 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_BL_CTRL_Pin */
  GPIO_InitStruct.Pin = LCD_BL_CTRL_Pin;
 800950a:	2308      	movs	r3, #8
 800950c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800950e:	2301      	movs	r3, #1
 8009510:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009512:	2300      	movs	r3, #0
 8009514:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009516:	2300      	movs	r3, #0
 8009518:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(LCD_BL_CTRL_GPIO_Port, &GPIO_InitStruct);
 800951a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800951e:	4619      	mov	r1, r3
 8009520:	4885      	ldr	r0, [pc, #532]	; (8009738 <MX_GPIO_Init+0x540>)
 8009522:	f7f8 fb2b 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
 8009526:	2310      	movs	r3, #16
 8009528:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800952a:	2300      	movs	r3, #0
 800952c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800952e:	2300      	movs	r3, #0
 8009530:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
 8009532:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009536:	4619      	mov	r1, r3
 8009538:	4880      	ldr	r0, [pc, #512]	; (800973c <MX_GPIO_Init+0x544>)
 800953a:	f7f8 fb1f 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : SDMMC_CMD_Pin */
  GPIO_InitStruct.Pin = SDMMC_CMD_Pin;
 800953e:	2304      	movs	r3, #4
 8009540:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009542:	2302      	movs	r3, #2
 8009544:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009546:	2300      	movs	r3, #0
 8009548:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800954a:	2303      	movs	r3, #3
 800954c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 800954e:	230c      	movs	r3, #12
 8009550:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SDMMC_CMD_GPIO_Port, &GPIO_InitStruct);
 8009552:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009556:	4619      	mov	r1, r3
 8009558:	4878      	ldr	r0, [pc, #480]	; (800973c <MX_GPIO_Init+0x544>)
 800955a:	f7f8 fb0f 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : TP3_Pin NC2_Pin */
  GPIO_InitStruct.Pin = TP3_Pin|NC2_Pin;
 800955e:	f248 0304 	movw	r3, #32772	; 0x8004
 8009562:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009564:	2300      	movs	r3, #0
 8009566:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009568:	2300      	movs	r3, #0
 800956a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 800956c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009570:	4619      	mov	r1, r3
 8009572:	4873      	ldr	r0, [pc, #460]	; (8009740 <MX_GPIO_Init+0x548>)
 8009574:	f7f8 fb02 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_SCK_D13_Pin */
  GPIO_InitStruct.Pin = ARDUINO_SCK_D13_Pin;
 8009578:	2302      	movs	r3, #2
 800957a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800957c:	2302      	movs	r3, #2
 800957e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009580:	2300      	movs	r3, #0
 8009582:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009584:	2300      	movs	r3, #0
 8009586:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 8009588:	2305      	movs	r3, #5
 800958a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_SCK_D13_GPIO_Port, &GPIO_InitStruct);
 800958c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009590:	4619      	mov	r1, r3
 8009592:	486c      	ldr	r0, [pc, #432]	; (8009744 <MX_GPIO_Init+0x54c>)
 8009594:	f7f8 faf2 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : DCMI_PWR_EN_Pin */
  GPIO_InitStruct.Pin = DCMI_PWR_EN_Pin;
 8009598:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800959c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800959e:	2301      	movs	r3, #1
 80095a0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80095a2:	2300      	movs	r3, #0
 80095a4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80095a6:	2300      	movs	r3, #0
 80095a8:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(DCMI_PWR_EN_GPIO_Port, &GPIO_InitStruct);
 80095aa:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80095ae:	4619      	mov	r1, r3
 80095b0:	4863      	ldr	r0, [pc, #396]	; (8009740 <MX_GPIO_Init+0x548>)
 80095b2:	f7f8 fae3 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_INT_Pin */
  GPIO_InitStruct.Pin = LCD_INT_Pin;
 80095b6:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80095ba:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 80095bc:	4b62      	ldr	r3, [pc, #392]	; (8009748 <MX_GPIO_Init+0x550>)
 80095be:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80095c0:	2300      	movs	r3, #0
 80095c2:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
 80095c4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80095c8:	4619      	mov	r1, r3
 80095ca:	485e      	ldr	r0, [pc, #376]	; (8009744 <MX_GPIO_Init+0x54c>)
 80095cc:	f7f8 fad6 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : ULPI_NXT_Pin */
  GPIO_InitStruct.Pin = ULPI_NXT_Pin;
 80095d0:	2310      	movs	r3, #16
 80095d2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80095d4:	2302      	movs	r3, #2
 80095d6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80095d8:	2300      	movs	r3, #0
 80095da:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80095dc:	2303      	movs	r3, #3
 80095de:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 80095e0:	230a      	movs	r3, #10
 80095e2:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ULPI_NXT_GPIO_Port, &GPIO_InitStruct);
 80095e4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80095e8:	4619      	mov	r1, r3
 80095ea:	4855      	ldr	r0, [pc, #340]	; (8009740 <MX_GPIO_Init+0x548>)
 80095ec:	f7f8 fac6 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_D4_Pin ARDUINO_D2_Pin EXT_RST_Pin */
  GPIO_InitStruct.Pin = ARDUINO_D4_Pin|ARDUINO_D2_Pin|EXT_RST_Pin;
 80095f0:	23c8      	movs	r3, #200	; 0xc8
 80095f2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80095f4:	2301      	movs	r3, #1
 80095f6:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80095f8:	2300      	movs	r3, #0
 80095fa:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80095fc:	2300      	movs	r3, #0
 80095fe:	63bb      	str	r3, [r7, #56]	; 0x38
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8009600:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009604:	4619      	mov	r1, r3
 8009606:	4851      	ldr	r0, [pc, #324]	; (800974c <MX_GPIO_Init+0x554>)
 8009608:	f7f8 fab8 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_STP_Pin ULPI_DIR_Pin */
  GPIO_InitStruct.Pin = ULPI_STP_Pin|ULPI_DIR_Pin;
 800960c:	2305      	movs	r3, #5
 800960e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009610:	2302      	movs	r3, #2
 8009612:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009614:	2300      	movs	r3, #0
 8009616:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009618:	2303      	movs	r3, #3
 800961a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 800961c:	230a      	movs	r3, #10
 800961e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009620:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009624:	4619      	mov	r1, r3
 8009626:	4843      	ldr	r0, [pc, #268]	; (8009734 <MX_GPIO_Init+0x53c>)
 8009628:	f7f8 faa8 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_MDC_Pin RMII_RXD0_Pin RMII_RXD1_Pin */
  GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 800962c:	2332      	movs	r3, #50	; 0x32
 800962e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009630:	2302      	movs	r3, #2
 8009632:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009634:	2300      	movs	r3, #0
 8009636:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009638:	2303      	movs	r3, #3
 800963a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800963c:	230b      	movs	r3, #11
 800963e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009640:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009644:	4619      	mov	r1, r3
 8009646:	483b      	ldr	r0, [pc, #236]	; (8009734 <MX_GPIO_Init+0x53c>)
 8009648:	f7f8 fa98 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : PB2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
 800964c:	2304      	movs	r3, #4
 800964e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009650:	2302      	movs	r3, #2
 8009652:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009654:	2300      	movs	r3, #0
 8009656:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009658:	2303      	movs	r3, #3
 800965a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800965c:	2309      	movs	r3, #9
 800965e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009660:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009664:	4619      	mov	r1, r3
 8009666:	483a      	ldr	r0, [pc, #232]	; (8009750 <MX_GPIO_Init+0x558>)
 8009668:	f7f8 fa88 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : QSPI_D1_Pin QSPI_D3_Pin QSPI_D0_Pin */
  GPIO_InitStruct.Pin = QSPI_D1_Pin|QSPI_D3_Pin|QSPI_D0_Pin;
 800966c:	f44f 5360 	mov.w	r3, #14336	; 0x3800
 8009670:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009672:	2302      	movs	r3, #2
 8009674:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009676:	2300      	movs	r3, #0
 8009678:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800967a:	2303      	movs	r3, #3
 800967c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800967e:	2309      	movs	r3, #9
 8009680:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8009682:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009686:	4619      	mov	r1, r3
 8009688:	482c      	ldr	r0, [pc, #176]	; (800973c <MX_GPIO_Init+0x544>)
 800968a:	f7f8 fa77 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pin : RMII_RXER_Pin */
  GPIO_InitStruct.Pin = RMII_RXER_Pin;
 800968e:	2304      	movs	r3, #4
 8009690:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009692:	2300      	movs	r3, #0
 8009694:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009696:	2300      	movs	r3, #0
 8009698:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(RMII_RXER_GPIO_Port, &GPIO_InitStruct);
 800969a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800969e:	4619      	mov	r1, r3
 80096a0:	482a      	ldr	r0, [pc, #168]	; (800974c <MX_GPIO_Init+0x554>)
 80096a2:	f7f8 fa6b 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_REF_CLK_Pin RMII_MDIO_Pin RMII_CRS_DV_Pin */
  GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 80096a6:	2386      	movs	r3, #134	; 0x86
 80096a8:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80096aa:	2302      	movs	r3, #2
 80096ac:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80096ae:	2300      	movs	r3, #0
 80096b0:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80096b2:	2303      	movs	r3, #3
 80096b4:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 80096b6:	230b      	movs	r3, #11
 80096b8:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80096ba:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80096be:	4619      	mov	r1, r3
 80096c0:	4824      	ldr	r0, [pc, #144]	; (8009754 <MX_GPIO_Init+0x55c>)
 80096c2:	f7f8 fa5b 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : LCD_SCL_Pin LCD_SDA_Pin */
  GPIO_InitStruct.Pin = LCD_SCL_Pin|LCD_SDA_Pin;
 80096c6:	f44f 73c0 	mov.w	r3, #384	; 0x180
 80096ca:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 80096cc:	2312      	movs	r3, #18
 80096ce:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 80096d0:	2301      	movs	r3, #1
 80096d2:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80096d4:	2303      	movs	r3, #3
 80096d6:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 80096d8:	2304      	movs	r3, #4
 80096da:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80096dc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80096e0:	4619      	mov	r1, r3
 80096e2:	4817      	ldr	r0, [pc, #92]	; (8009740 <MX_GPIO_Init+0x548>)
 80096e4:	f7f8 fa4a 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_CLK_Pin ULPI_D0_Pin */
  GPIO_InitStruct.Pin = ULPI_CLK_Pin|ULPI_D0_Pin;
 80096e8:	2328      	movs	r3, #40	; 0x28
 80096ea:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80096ec:	2302      	movs	r3, #2
 80096ee:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80096f0:	2300      	movs	r3, #0
 80096f2:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80096f4:	2303      	movs	r3, #3
 80096f6:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 80096f8:	230a      	movs	r3, #10
 80096fa:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80096fc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009700:	4619      	mov	r1, r3
 8009702:	4814      	ldr	r0, [pc, #80]	; (8009754 <MX_GPIO_Init+0x55c>)
 8009704:	f7f8 fa3a 	bl	8001b7c <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_MISO_D12_Pin ARDUINO_MOSI_PWM_D11_Pin */
  GPIO_InitStruct.Pin = ARDUINO_MISO_D12_Pin|ARDUINO_MOSI_PWM_D11_Pin;
 8009708:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 800970c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800970e:	2302      	movs	r3, #2
 8009710:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009712:	2300      	movs	r3, #0
 8009714:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009716:	2300      	movs	r3, #0
 8009718:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800971a:	2305      	movs	r3, #5
 800971c:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800971e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8009722:	4619      	mov	r1, r3
 8009724:	480a      	ldr	r0, [pc, #40]	; (8009750 <MX_GPIO_Init+0x558>)
 8009726:	f7f8 fa29 	bl	8001b7c <HAL_GPIO_Init>

}
 800972a:	bf00      	nop
 800972c:	3740      	adds	r7, #64	; 0x40
 800972e:	46bd      	mov	sp, r7
 8009730:	bd80      	pop	{r7, pc}
 8009732:	bf00      	nop
 8009734:	40020800 	.word	0x40020800
 8009738:	40022800 	.word	0x40022800
 800973c:	40020c00 	.word	0x40020c00
 8009740:	40021c00 	.word	0x40021c00
 8009744:	40022000 	.word	0x40022000
 8009748:	10120000 	.word	0x10120000
 800974c:	40021800 	.word	0x40021800
 8009750:	40020400 	.word	0x40020400
 8009754:	40020000 	.word	0x40020000

08009758 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8009758:	b580      	push	{r7, lr}
 800975a:	b082      	sub	sp, #8
 800975c:	af00      	add	r7, sp, #0
 800975e:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM6) {
 8009760:	687b      	ldr	r3, [r7, #4]
 8009762:	681b      	ldr	r3, [r3, #0]
 8009764:	4a04      	ldr	r2, [pc, #16]	; (8009778 <HAL_TIM_PeriodElapsedCallback+0x20>)
 8009766:	4293      	cmp	r3, r2
 8009768:	d101      	bne.n	800976e <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 800976a:	f7f6 ff47 	bl	80005fc <HAL_IncTick>
  }
  /* USER CODE BEGIN Callback 1 */

  /* USER CODE END Callback 1 */
}
 800976e:	bf00      	nop
 8009770:	3708      	adds	r7, #8
 8009772:	46bd      	mov	sp, r7
 8009774:	bd80      	pop	{r7, pc}
 8009776:	bf00      	nop
 8009778:	40001000 	.word	0x40001000

0800977c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 800977c:	b480      	push	{r7}
 800977e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */

  /* USER CODE END Error_Handler_Debug */
}
 8009780:	bf00      	nop
 8009782:	46bd      	mov	sp, r7
 8009784:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009788:	4770      	bx	lr
	...

0800978c <HAL_MspInit>:
void HAL_TIM_MspPostInit(TIM_HandleTypeDef *htim);
                                                                                                    /**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 800978c:	b480      	push	{r7}
 800978e:	b083      	sub	sp, #12
 8009790:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_PWR_CLK_ENABLE();
 8009792:	4b0f      	ldr	r3, [pc, #60]	; (80097d0 <HAL_MspInit+0x44>)
 8009794:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009796:	4a0e      	ldr	r2, [pc, #56]	; (80097d0 <HAL_MspInit+0x44>)
 8009798:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800979c:	6413      	str	r3, [r2, #64]	; 0x40
 800979e:	4b0c      	ldr	r3, [pc, #48]	; (80097d0 <HAL_MspInit+0x44>)
 80097a0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80097a2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80097a6:	607b      	str	r3, [r7, #4]
 80097a8:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 80097aa:	4b09      	ldr	r3, [pc, #36]	; (80097d0 <HAL_MspInit+0x44>)
 80097ac:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80097ae:	4a08      	ldr	r2, [pc, #32]	; (80097d0 <HAL_MspInit+0x44>)
 80097b0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80097b4:	6453      	str	r3, [r2, #68]	; 0x44
 80097b6:	4b06      	ldr	r3, [pc, #24]	; (80097d0 <HAL_MspInit+0x44>)
 80097b8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80097ba:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80097be:	603b      	str	r3, [r7, #0]
 80097c0:	683b      	ldr	r3, [r7, #0]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80097c2:	bf00      	nop
 80097c4:	370c      	adds	r7, #12
 80097c6:	46bd      	mov	sp, r7
 80097c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80097cc:	4770      	bx	lr
 80097ce:	bf00      	nop
 80097d0:	40023800 	.word	0x40023800

080097d4 <HAL_ADC_MspInit>:
* This function configures the hardware resources used in this example
* @param hadc: ADC handle pointer
* @retval None
*/
void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
{
 80097d4:	b580      	push	{r7, lr}
 80097d6:	b08a      	sub	sp, #40	; 0x28
 80097d8:	af00      	add	r7, sp, #0
 80097da:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80097dc:	f107 0314 	add.w	r3, r7, #20
 80097e0:	2200      	movs	r2, #0
 80097e2:	601a      	str	r2, [r3, #0]
 80097e4:	605a      	str	r2, [r3, #4]
 80097e6:	609a      	str	r2, [r3, #8]
 80097e8:	60da      	str	r2, [r3, #12]
 80097ea:	611a      	str	r2, [r3, #16]
  if(hadc->Instance==ADC3)
 80097ec:	687b      	ldr	r3, [r7, #4]
 80097ee:	681b      	ldr	r3, [r3, #0]
 80097f0:	4a21      	ldr	r2, [pc, #132]	; (8009878 <HAL_ADC_MspInit+0xa4>)
 80097f2:	4293      	cmp	r3, r2
 80097f4:	d13c      	bne.n	8009870 <HAL_ADC_MspInit+0x9c>
  {
  /* USER CODE BEGIN ADC3_MspInit 0 */

  /* USER CODE END ADC3_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_ADC3_CLK_ENABLE();
 80097f6:	4b21      	ldr	r3, [pc, #132]	; (800987c <HAL_ADC_MspInit+0xa8>)
 80097f8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80097fa:	4a20      	ldr	r2, [pc, #128]	; (800987c <HAL_ADC_MspInit+0xa8>)
 80097fc:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8009800:	6453      	str	r3, [r2, #68]	; 0x44
 8009802:	4b1e      	ldr	r3, [pc, #120]	; (800987c <HAL_ADC_MspInit+0xa8>)
 8009804:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009806:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800980a:	613b      	str	r3, [r7, #16]
 800980c:	693b      	ldr	r3, [r7, #16]
  
    __HAL_RCC_GPIOF_CLK_ENABLE();
 800980e:	4b1b      	ldr	r3, [pc, #108]	; (800987c <HAL_ADC_MspInit+0xa8>)
 8009810:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009812:	4a1a      	ldr	r2, [pc, #104]	; (800987c <HAL_ADC_MspInit+0xa8>)
 8009814:	f043 0320 	orr.w	r3, r3, #32
 8009818:	6313      	str	r3, [r2, #48]	; 0x30
 800981a:	4b18      	ldr	r3, [pc, #96]	; (800987c <HAL_ADC_MspInit+0xa8>)
 800981c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800981e:	f003 0320 	and.w	r3, r3, #32
 8009822:	60fb      	str	r3, [r7, #12]
 8009824:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8009826:	4b15      	ldr	r3, [pc, #84]	; (800987c <HAL_ADC_MspInit+0xa8>)
 8009828:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800982a:	4a14      	ldr	r2, [pc, #80]	; (800987c <HAL_ADC_MspInit+0xa8>)
 800982c:	f043 0301 	orr.w	r3, r3, #1
 8009830:	6313      	str	r3, [r2, #48]	; 0x30
 8009832:	4b12      	ldr	r3, [pc, #72]	; (800987c <HAL_ADC_MspInit+0xa8>)
 8009834:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009836:	f003 0301 	and.w	r3, r3, #1
 800983a:	60bb      	str	r3, [r7, #8]
 800983c:	68bb      	ldr	r3, [r7, #8]
    PF10     ------> ADC3_IN8
    PF9     ------> ADC3_IN7
    PF8     ------> ADC3_IN6
    PA0/WKUP     ------> ADC3_IN0 
    */
    GPIO_InitStruct.Pin = ARDUINO_A4_Pin|ARDUINO_A5_Pin|ARDUINO_A1_Pin|ARDUINO_A2_Pin 
 800983e:	f44f 63f8 	mov.w	r3, #1984	; 0x7c0
 8009842:	617b      	str	r3, [r7, #20]
                          |ARDUINO_A3_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009844:	2303      	movs	r3, #3
 8009846:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009848:	2300      	movs	r3, #0
 800984a:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 800984c:	f107 0314 	add.w	r3, r7, #20
 8009850:	4619      	mov	r1, r3
 8009852:	480b      	ldr	r0, [pc, #44]	; (8009880 <HAL_ADC_MspInit+0xac>)
 8009854:	f7f8 f992 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = ARDUINO_A0_Pin;
 8009858:	2301      	movs	r3, #1
 800985a:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800985c:	2303      	movs	r3, #3
 800985e:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009860:	2300      	movs	r3, #0
 8009862:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(ARDUINO_A0_GPIO_Port, &GPIO_InitStruct);
 8009864:	f107 0314 	add.w	r3, r7, #20
 8009868:	4619      	mov	r1, r3
 800986a:	4806      	ldr	r0, [pc, #24]	; (8009884 <HAL_ADC_MspInit+0xb0>)
 800986c:	f7f8 f986 	bl	8001b7c <HAL_GPIO_Init>
  /* USER CODE BEGIN ADC3_MspInit 1 */

  /* USER CODE END ADC3_MspInit 1 */
  }

}
 8009870:	bf00      	nop
 8009872:	3728      	adds	r7, #40	; 0x28
 8009874:	46bd      	mov	sp, r7
 8009876:	bd80      	pop	{r7, pc}
 8009878:	40012200 	.word	0x40012200
 800987c:	40023800 	.word	0x40023800
 8009880:	40021400 	.word	0x40021400
 8009884:	40020000 	.word	0x40020000

08009888 <HAL_DCMI_MspInit>:
* This function configures the hardware resources used in this example
* @param hdcmi: DCMI handle pointer
* @retval None
*/
void HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi)
{
 8009888:	b580      	push	{r7, lr}
 800988a:	b08e      	sub	sp, #56	; 0x38
 800988c:	af00      	add	r7, sp, #0
 800988e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009890:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009894:	2200      	movs	r2, #0
 8009896:	601a      	str	r2, [r3, #0]
 8009898:	605a      	str	r2, [r3, #4]
 800989a:	609a      	str	r2, [r3, #8]
 800989c:	60da      	str	r2, [r3, #12]
 800989e:	611a      	str	r2, [r3, #16]
  if(hdcmi->Instance==DCMI)
 80098a0:	687b      	ldr	r3, [r7, #4]
 80098a2:	681b      	ldr	r3, [r3, #0]
 80098a4:	4a50      	ldr	r2, [pc, #320]	; (80099e8 <HAL_DCMI_MspInit+0x160>)
 80098a6:	4293      	cmp	r3, r2
 80098a8:	f040 809a 	bne.w	80099e0 <HAL_DCMI_MspInit+0x158>
  {
  /* USER CODE BEGIN DCMI_MspInit 0 */

  /* USER CODE END DCMI_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DCMI_CLK_ENABLE();
 80098ac:	4b4f      	ldr	r3, [pc, #316]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80098b0:	4a4e      	ldr	r2, [pc, #312]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098b2:	f043 0301 	orr.w	r3, r3, #1
 80098b6:	6353      	str	r3, [r2, #52]	; 0x34
 80098b8:	4b4c      	ldr	r3, [pc, #304]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098ba:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80098bc:	f003 0301 	and.w	r3, r3, #1
 80098c0:	623b      	str	r3, [r7, #32]
 80098c2:	6a3b      	ldr	r3, [r7, #32]
  
    __HAL_RCC_GPIOE_CLK_ENABLE();
 80098c4:	4b49      	ldr	r3, [pc, #292]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098c8:	4a48      	ldr	r2, [pc, #288]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098ca:	f043 0310 	orr.w	r3, r3, #16
 80098ce:	6313      	str	r3, [r2, #48]	; 0x30
 80098d0:	4b46      	ldr	r3, [pc, #280]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098d4:	f003 0310 	and.w	r3, r3, #16
 80098d8:	61fb      	str	r3, [r7, #28]
 80098da:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80098dc:	4b43      	ldr	r3, [pc, #268]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098e0:	4a42      	ldr	r2, [pc, #264]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098e2:	f043 0308 	orr.w	r3, r3, #8
 80098e6:	6313      	str	r3, [r2, #48]	; 0x30
 80098e8:	4b40      	ldr	r3, [pc, #256]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098ec:	f003 0308 	and.w	r3, r3, #8
 80098f0:	61bb      	str	r3, [r7, #24]
 80098f2:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 80098f4:	4b3d      	ldr	r3, [pc, #244]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80098f8:	4a3c      	ldr	r2, [pc, #240]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 80098fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80098fe:	6313      	str	r3, [r2, #48]	; 0x30
 8009900:	4b3a      	ldr	r3, [pc, #232]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 8009902:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009904:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009908:	617b      	str	r3, [r7, #20]
 800990a:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOH_CLK_ENABLE();
 800990c:	4b37      	ldr	r3, [pc, #220]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 800990e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009910:	4a36      	ldr	r2, [pc, #216]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 8009912:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009916:	6313      	str	r3, [r2, #48]	; 0x30
 8009918:	4b34      	ldr	r3, [pc, #208]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 800991a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800991c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009920:	613b      	str	r3, [r7, #16]
 8009922:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8009924:	4b31      	ldr	r3, [pc, #196]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 8009926:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009928:	4a30      	ldr	r2, [pc, #192]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 800992a:	f043 0301 	orr.w	r3, r3, #1
 800992e:	6313      	str	r3, [r2, #48]	; 0x30
 8009930:	4b2e      	ldr	r3, [pc, #184]	; (80099ec <HAL_DCMI_MspInit+0x164>)
 8009932:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009934:	f003 0301 	and.w	r3, r3, #1
 8009938:	60fb      	str	r3, [r7, #12]
 800993a:	68fb      	ldr	r3, [r7, #12]
    PH9     ------> DCMI_D0
    PH11     ------> DCMI_D2
    PA6     ------> DCMI_PIXCLK
    PH10     ------> DCMI_D1 
    */
    GPIO_InitStruct.Pin = DCMI_D6_Pin|DCMI_D7_Pin;
 800993c:	2360      	movs	r3, #96	; 0x60
 800993e:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009940:	2302      	movs	r3, #2
 8009942:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009944:	2300      	movs	r3, #0
 8009946:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009948:	2300      	movs	r3, #0
 800994a:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 800994c:	230d      	movs	r3, #13
 800994e:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8009950:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009954:	4619      	mov	r1, r3
 8009956:	4826      	ldr	r0, [pc, #152]	; (80099f0 <HAL_DCMI_MspInit+0x168>)
 8009958:	f7f8 f910 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = DCMI_D5_Pin;
 800995c:	2308      	movs	r3, #8
 800995e:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009960:	2302      	movs	r3, #2
 8009962:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009964:	2300      	movs	r3, #0
 8009966:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009968:	2300      	movs	r3, #0
 800996a:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 800996c:	230d      	movs	r3, #13
 800996e:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(DCMI_D5_GPIO_Port, &GPIO_InitStruct);
 8009970:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009974:	4619      	mov	r1, r3
 8009976:	481f      	ldr	r0, [pc, #124]	; (80099f4 <HAL_DCMI_MspInit+0x16c>)
 8009978:	f7f8 f900 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = DCMI_VSYNC_Pin;
 800997c:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009980:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009982:	2302      	movs	r3, #2
 8009984:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009986:	2300      	movs	r3, #0
 8009988:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800998a:	2300      	movs	r3, #0
 800998c:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 800998e:	230d      	movs	r3, #13
 8009990:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(DCMI_VSYNC_GPIO_Port, &GPIO_InitStruct);
 8009992:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009996:	4619      	mov	r1, r3
 8009998:	4817      	ldr	r0, [pc, #92]	; (80099f8 <HAL_DCMI_MspInit+0x170>)
 800999a:	f7f8 f8ef 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = DCMI_D4_Pin|DCMI_D3_Pin|DCMI_D0_Pin|DCMI_D2_Pin 
 800999e:	f44f 43bc 	mov.w	r3, #24064	; 0x5e00
 80099a2:	627b      	str	r3, [r7, #36]	; 0x24
                          |DCMI_D1_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80099a4:	2302      	movs	r3, #2
 80099a6:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80099a8:	2300      	movs	r3, #0
 80099aa:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80099ac:	2300      	movs	r3, #0
 80099ae:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 80099b0:	230d      	movs	r3, #13
 80099b2:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 80099b4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80099b8:	4619      	mov	r1, r3
 80099ba:	4810      	ldr	r0, [pc, #64]	; (80099fc <HAL_DCMI_MspInit+0x174>)
 80099bc:	f7f8 f8de 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = DCMI_HSYNC_Pin|GPIO_PIN_6;
 80099c0:	2350      	movs	r3, #80	; 0x50
 80099c2:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80099c4:	2302      	movs	r3, #2
 80099c6:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80099c8:	2300      	movs	r3, #0
 80099ca:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80099cc:	2300      	movs	r3, #0
 80099ce:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF13_DCMI;
 80099d0:	230d      	movs	r3, #13
 80099d2:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80099d4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 80099d8:	4619      	mov	r1, r3
 80099da:	4809      	ldr	r0, [pc, #36]	; (8009a00 <HAL_DCMI_MspInit+0x178>)
 80099dc:	f7f8 f8ce 	bl	8001b7c <HAL_GPIO_Init>
  /* USER CODE BEGIN DCMI_MspInit 1 */

  /* USER CODE END DCMI_MspInit 1 */
  }

}
 80099e0:	bf00      	nop
 80099e2:	3738      	adds	r7, #56	; 0x38
 80099e4:	46bd      	mov	sp, r7
 80099e6:	bd80      	pop	{r7, pc}
 80099e8:	50050000 	.word	0x50050000
 80099ec:	40023800 	.word	0x40023800
 80099f0:	40021000 	.word	0x40021000
 80099f4:	40020c00 	.word	0x40020c00
 80099f8:	40021800 	.word	0x40021800
 80099fc:	40021c00 	.word	0x40021c00
 8009a00:	40020000 	.word	0x40020000

08009a04 <HAL_DMA2D_MspInit>:
* This function configures the hardware resources used in this example
* @param hdma2d: DMA2D handle pointer
* @retval None
*/
void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef* hdma2d)
{
 8009a04:	b480      	push	{r7}
 8009a06:	b085      	sub	sp, #20
 8009a08:	af00      	add	r7, sp, #0
 8009a0a:	6078      	str	r0, [r7, #4]
  if(hdma2d->Instance==DMA2D)
 8009a0c:	687b      	ldr	r3, [r7, #4]
 8009a0e:	681b      	ldr	r3, [r3, #0]
 8009a10:	4a0a      	ldr	r2, [pc, #40]	; (8009a3c <HAL_DMA2D_MspInit+0x38>)
 8009a12:	4293      	cmp	r3, r2
 8009a14:	d10b      	bne.n	8009a2e <HAL_DMA2D_MspInit+0x2a>
  {
  /* USER CODE BEGIN DMA2D_MspInit 0 */

  /* USER CODE END DMA2D_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_DMA2D_CLK_ENABLE();
 8009a16:	4b0a      	ldr	r3, [pc, #40]	; (8009a40 <HAL_DMA2D_MspInit+0x3c>)
 8009a18:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a1a:	4a09      	ldr	r2, [pc, #36]	; (8009a40 <HAL_DMA2D_MspInit+0x3c>)
 8009a1c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8009a20:	6313      	str	r3, [r2, #48]	; 0x30
 8009a22:	4b07      	ldr	r3, [pc, #28]	; (8009a40 <HAL_DMA2D_MspInit+0x3c>)
 8009a24:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a26:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8009a2a:	60fb      	str	r3, [r7, #12]
 8009a2c:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN DMA2D_MspInit 1 */

  /* USER CODE END DMA2D_MspInit 1 */
  }

}
 8009a2e:	bf00      	nop
 8009a30:	3714      	adds	r7, #20
 8009a32:	46bd      	mov	sp, r7
 8009a34:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009a38:	4770      	bx	lr
 8009a3a:	bf00      	nop
 8009a3c:	4002b000 	.word	0x4002b000
 8009a40:	40023800 	.word	0x40023800

08009a44 <HAL_LTDC_MspInit>:
* This function configures the hardware resources used in this example
* @param hltdc: LTDC handle pointer
* @retval None
*/
void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
 8009a44:	b580      	push	{r7, lr}
 8009a46:	b08e      	sub	sp, #56	; 0x38
 8009a48:	af00      	add	r7, sp, #0
 8009a4a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009a4c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009a50:	2200      	movs	r2, #0
 8009a52:	601a      	str	r2, [r3, #0]
 8009a54:	605a      	str	r2, [r3, #4]
 8009a56:	609a      	str	r2, [r3, #8]
 8009a58:	60da      	str	r2, [r3, #12]
 8009a5a:	611a      	str	r2, [r3, #16]
  if(hltdc->Instance==LTDC)
 8009a5c:	687b      	ldr	r3, [r7, #4]
 8009a5e:	681b      	ldr	r3, [r3, #0]
 8009a60:	4a51      	ldr	r2, [pc, #324]	; (8009ba8 <HAL_LTDC_MspInit+0x164>)
 8009a62:	4293      	cmp	r3, r2
 8009a64:	f040 809b 	bne.w	8009b9e <HAL_LTDC_MspInit+0x15a>
  {
  /* USER CODE BEGIN LTDC_MspInit 0 */

  /* USER CODE END LTDC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_LTDC_CLK_ENABLE();
 8009a68:	4b50      	ldr	r3, [pc, #320]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a6a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009a6c:	4a4f      	ldr	r2, [pc, #316]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a6e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8009a72:	6453      	str	r3, [r2, #68]	; 0x44
 8009a74:	4b4d      	ldr	r3, [pc, #308]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009a78:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8009a7c:	623b      	str	r3, [r7, #32]
 8009a7e:	6a3b      	ldr	r3, [r7, #32]
  
    __HAL_RCC_GPIOE_CLK_ENABLE();
 8009a80:	4b4a      	ldr	r3, [pc, #296]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a84:	4a49      	ldr	r2, [pc, #292]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a86:	f043 0310 	orr.w	r3, r3, #16
 8009a8a:	6313      	str	r3, [r2, #48]	; 0x30
 8009a8c:	4b47      	ldr	r3, [pc, #284]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a90:	f003 0310 	and.w	r3, r3, #16
 8009a94:	61fb      	str	r3, [r7, #28]
 8009a96:	69fb      	ldr	r3, [r7, #28]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 8009a98:	4b44      	ldr	r3, [pc, #272]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a9a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009a9c:	4a43      	ldr	r2, [pc, #268]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009a9e:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8009aa2:	6313      	str	r3, [r2, #48]	; 0x30
 8009aa4:	4b41      	ldr	r3, [pc, #260]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009aa6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009aa8:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8009aac:	61bb      	str	r3, [r7, #24]
 8009aae:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOK_CLK_ENABLE();
 8009ab0:	4b3e      	ldr	r3, [pc, #248]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009ab2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ab4:	4a3d      	ldr	r2, [pc, #244]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009ab6:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8009aba:	6313      	str	r3, [r2, #48]	; 0x30
 8009abc:	4b3b      	ldr	r3, [pc, #236]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009abe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ac0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8009ac4:	617b      	str	r3, [r7, #20]
 8009ac6:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 8009ac8:	4b38      	ldr	r3, [pc, #224]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009aca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009acc:	4a37      	ldr	r2, [pc, #220]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009ace:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009ad2:	6313      	str	r3, [r2, #48]	; 0x30
 8009ad4:	4b35      	ldr	r3, [pc, #212]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009ad6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ad8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009adc:	613b      	str	r3, [r7, #16]
 8009ade:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8009ae0:	4b32      	ldr	r3, [pc, #200]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009ae2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ae4:	4a31      	ldr	r2, [pc, #196]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009ae6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009aea:	6313      	str	r3, [r2, #48]	; 0x30
 8009aec:	4b2f      	ldr	r3, [pc, #188]	; (8009bac <HAL_LTDC_MspInit+0x168>)
 8009aee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009af0:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8009af4:	60fb      	str	r3, [r7, #12]
 8009af6:	68fb      	ldr	r3, [r7, #12]
    PJ3     ------> LTDC_R4
    PJ2     ------> LTDC_R3
    PJ0     ------> LTDC_R1
    PJ1     ------> LTDC_R2 
    */
    GPIO_InitStruct.Pin = LCD_B0_Pin;
 8009af8:	2310      	movs	r3, #16
 8009afa:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009afc:	2302      	movs	r3, #2
 8009afe:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b00:	2300      	movs	r3, #0
 8009b02:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b04:	2300      	movs	r3, #0
 8009b06:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8009b08:	230e      	movs	r3, #14
 8009b0a:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(LCD_B0_GPIO_Port, &GPIO_InitStruct);
 8009b0c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009b10:	4619      	mov	r1, r3
 8009b12:	4827      	ldr	r0, [pc, #156]	; (8009bb0 <HAL_LTDC_MspInit+0x16c>)
 8009b14:	f7f8 f832 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = LCD_B1_Pin|LCD_B2_Pin|LCD_B3_Pin|LCD_G4_Pin 
 8009b18:	f64e 73ff 	movw	r3, #61439	; 0xefff
 8009b1c:	627b      	str	r3, [r7, #36]	; 0x24
                          |LCD_G1_Pin|LCD_G3_Pin|LCD_G0_Pin|LCD_G2_Pin 
                          |LCD_R7_Pin|LCD_R5_Pin|LCD_R6_Pin|LCD_R4_Pin 
                          |LCD_R3_Pin|LCD_R1_Pin|LCD_R2_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009b1e:	2302      	movs	r3, #2
 8009b20:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b22:	2300      	movs	r3, #0
 8009b24:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b26:	2300      	movs	r3, #0
 8009b28:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8009b2a:	230e      	movs	r3, #14
 8009b2c:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 8009b2e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009b32:	4619      	mov	r1, r3
 8009b34:	481f      	ldr	r0, [pc, #124]	; (8009bb4 <HAL_LTDC_MspInit+0x170>)
 8009b36:	f7f8 f821 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = LCD_DE_Pin|LCD_B7_Pin|LCD_B6_Pin|LCD_B5_Pin 
 8009b3a:	23f7      	movs	r3, #247	; 0xf7
 8009b3c:	627b      	str	r3, [r7, #36]	; 0x24
                          |LCD_G6_Pin|LCD_G7_Pin|LCD_G5_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009b3e:	2302      	movs	r3, #2
 8009b40:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b42:	2300      	movs	r3, #0
 8009b44:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b46:	2300      	movs	r3, #0
 8009b48:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8009b4a:	230e      	movs	r3, #14
 8009b4c:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 8009b4e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009b52:	4619      	mov	r1, r3
 8009b54:	4818      	ldr	r0, [pc, #96]	; (8009bb8 <HAL_LTDC_MspInit+0x174>)
 8009b56:	f7f8 f811 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = LCD_B4_Pin;
 8009b5a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8009b5e:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009b60:	2302      	movs	r3, #2
 8009b62:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b64:	2300      	movs	r3, #0
 8009b66:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b68:	2300      	movs	r3, #0
 8009b6a:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF9_LTDC;
 8009b6c:	2309      	movs	r3, #9
 8009b6e:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(LCD_B4_GPIO_Port, &GPIO_InitStruct);
 8009b70:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009b74:	4619      	mov	r1, r3
 8009b76:	4811      	ldr	r0, [pc, #68]	; (8009bbc <HAL_LTDC_MspInit+0x178>)
 8009b78:	f7f8 f800 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = LCD_HSYNC_Pin|LCD_VSYNC_Pin|LCD_R0_Pin|LCD_CLK_Pin;
 8009b7c:	f44f 4346 	mov.w	r3, #50688	; 0xc600
 8009b80:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009b82:	2302      	movs	r3, #2
 8009b84:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b86:	2300      	movs	r3, #0
 8009b88:	62fb      	str	r3, [r7, #44]	; 0x2c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b8a:	2300      	movs	r3, #0
 8009b8c:	633b      	str	r3, [r7, #48]	; 0x30
    GPIO_InitStruct.Alternate = GPIO_AF14_LTDC;
 8009b8e:	230e      	movs	r3, #14
 8009b90:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 8009b92:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8009b96:	4619      	mov	r1, r3
 8009b98:	4809      	ldr	r0, [pc, #36]	; (8009bc0 <HAL_LTDC_MspInit+0x17c>)
 8009b9a:	f7f7 ffef 	bl	8001b7c <HAL_GPIO_Init>
  /* USER CODE BEGIN LTDC_MspInit 1 */

  /* USER CODE END LTDC_MspInit 1 */
  }

}
 8009b9e:	bf00      	nop
 8009ba0:	3738      	adds	r7, #56	; 0x38
 8009ba2:	46bd      	mov	sp, r7
 8009ba4:	bd80      	pop	{r7, pc}
 8009ba6:	bf00      	nop
 8009ba8:	40016800 	.word	0x40016800
 8009bac:	40023800 	.word	0x40023800
 8009bb0:	40021000 	.word	0x40021000
 8009bb4:	40022400 	.word	0x40022400
 8009bb8:	40022800 	.word	0x40022800
 8009bbc:	40021800 	.word	0x40021800
 8009bc0:	40022000 	.word	0x40022000

08009bc4 <HAL_RTC_MspInit>:
* This function configures the hardware resources used in this example
* @param hrtc: RTC handle pointer
* @retval None
*/
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 8009bc4:	b480      	push	{r7}
 8009bc6:	b083      	sub	sp, #12
 8009bc8:	af00      	add	r7, sp, #0
 8009bca:	6078      	str	r0, [r7, #4]
  if(hrtc->Instance==RTC)
 8009bcc:	687b      	ldr	r3, [r7, #4]
 8009bce:	681b      	ldr	r3, [r3, #0]
 8009bd0:	4a07      	ldr	r2, [pc, #28]	; (8009bf0 <HAL_RTC_MspInit+0x2c>)
 8009bd2:	4293      	cmp	r3, r2
 8009bd4:	d105      	bne.n	8009be2 <HAL_RTC_MspInit+0x1e>
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 8009bd6:	4b07      	ldr	r3, [pc, #28]	; (8009bf4 <HAL_RTC_MspInit+0x30>)
 8009bd8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009bda:	4a06      	ldr	r2, [pc, #24]	; (8009bf4 <HAL_RTC_MspInit+0x30>)
 8009bdc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009be0:	6713      	str	r3, [r2, #112]	; 0x70
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 8009be2:	bf00      	nop
 8009be4:	370c      	adds	r7, #12
 8009be6:	46bd      	mov	sp, r7
 8009be8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009bec:	4770      	bx	lr
 8009bee:	bf00      	nop
 8009bf0:	40002800 	.word	0x40002800
 8009bf4:	40023800 	.word	0x40023800

08009bf8 <HAL_TIM_PWM_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_pwm: TIM_PWM handle pointer
* @retval None
*/
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef* htim_pwm)
{
 8009bf8:	b480      	push	{r7}
 8009bfa:	b085      	sub	sp, #20
 8009bfc:	af00      	add	r7, sp, #0
 8009bfe:	6078      	str	r0, [r7, #4]
  if(htim_pwm->Instance==TIM1)
 8009c00:	687b      	ldr	r3, [r7, #4]
 8009c02:	681b      	ldr	r3, [r3, #0]
 8009c04:	4a13      	ldr	r2, [pc, #76]	; (8009c54 <HAL_TIM_PWM_MspInit+0x5c>)
 8009c06:	4293      	cmp	r3, r2
 8009c08:	d10c      	bne.n	8009c24 <HAL_TIM_PWM_MspInit+0x2c>
  {
  /* USER CODE BEGIN TIM1_MspInit 0 */

  /* USER CODE END TIM1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM1_CLK_ENABLE();
 8009c0a:	4b13      	ldr	r3, [pc, #76]	; (8009c58 <HAL_TIM_PWM_MspInit+0x60>)
 8009c0c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009c0e:	4a12      	ldr	r2, [pc, #72]	; (8009c58 <HAL_TIM_PWM_MspInit+0x60>)
 8009c10:	f043 0301 	orr.w	r3, r3, #1
 8009c14:	6453      	str	r3, [r2, #68]	; 0x44
 8009c16:	4b10      	ldr	r3, [pc, #64]	; (8009c58 <HAL_TIM_PWM_MspInit+0x60>)
 8009c18:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009c1a:	f003 0301 	and.w	r3, r3, #1
 8009c1e:	60fb      	str	r3, [r7, #12]
 8009c20:	68fb      	ldr	r3, [r7, #12]
  /* USER CODE BEGIN TIM12_MspInit 1 */

  /* USER CODE END TIM12_MspInit 1 */
  }

}
 8009c22:	e010      	b.n	8009c46 <HAL_TIM_PWM_MspInit+0x4e>
  else if(htim_pwm->Instance==TIM12)
 8009c24:	687b      	ldr	r3, [r7, #4]
 8009c26:	681b      	ldr	r3, [r3, #0]
 8009c28:	4a0c      	ldr	r2, [pc, #48]	; (8009c5c <HAL_TIM_PWM_MspInit+0x64>)
 8009c2a:	4293      	cmp	r3, r2
 8009c2c:	d10b      	bne.n	8009c46 <HAL_TIM_PWM_MspInit+0x4e>
    __HAL_RCC_TIM12_CLK_ENABLE();
 8009c2e:	4b0a      	ldr	r3, [pc, #40]	; (8009c58 <HAL_TIM_PWM_MspInit+0x60>)
 8009c30:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c32:	4a09      	ldr	r2, [pc, #36]	; (8009c58 <HAL_TIM_PWM_MspInit+0x60>)
 8009c34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8009c38:	6413      	str	r3, [r2, #64]	; 0x40
 8009c3a:	4b07      	ldr	r3, [pc, #28]	; (8009c58 <HAL_TIM_PWM_MspInit+0x60>)
 8009c3c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c3e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8009c42:	60bb      	str	r3, [r7, #8]
 8009c44:	68bb      	ldr	r3, [r7, #8]
}
 8009c46:	bf00      	nop
 8009c48:	3714      	adds	r7, #20
 8009c4a:	46bd      	mov	sp, r7
 8009c4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009c50:	4770      	bx	lr
 8009c52:	bf00      	nop
 8009c54:	40010000 	.word	0x40010000
 8009c58:	40023800 	.word	0x40023800
 8009c5c:	40001800 	.word	0x40001800

08009c60 <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 8009c60:	b480      	push	{r7}
 8009c62:	b087      	sub	sp, #28
 8009c64:	af00      	add	r7, sp, #0
 8009c66:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM2)
 8009c68:	687b      	ldr	r3, [r7, #4]
 8009c6a:	681b      	ldr	r3, [r3, #0]
 8009c6c:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8009c70:	d10c      	bne.n	8009c8c <HAL_TIM_Base_MspInit+0x2c>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 8009c72:	4b24      	ldr	r3, [pc, #144]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009c74:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c76:	4a23      	ldr	r2, [pc, #140]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009c78:	f043 0301 	orr.w	r3, r3, #1
 8009c7c:	6413      	str	r3, [r2, #64]	; 0x40
 8009c7e:	4b21      	ldr	r3, [pc, #132]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009c80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c82:	f003 0301 	and.w	r3, r3, #1
 8009c86:	617b      	str	r3, [r7, #20]
 8009c88:	697b      	ldr	r3, [r7, #20]
  /* USER CODE BEGIN TIM8_MspInit 1 */

  /* USER CODE END TIM8_MspInit 1 */
  }

}
 8009c8a:	e034      	b.n	8009cf6 <HAL_TIM_Base_MspInit+0x96>
  else if(htim_base->Instance==TIM3)
 8009c8c:	687b      	ldr	r3, [r7, #4]
 8009c8e:	681b      	ldr	r3, [r3, #0]
 8009c90:	4a1d      	ldr	r2, [pc, #116]	; (8009d08 <HAL_TIM_Base_MspInit+0xa8>)
 8009c92:	4293      	cmp	r3, r2
 8009c94:	d10c      	bne.n	8009cb0 <HAL_TIM_Base_MspInit+0x50>
    __HAL_RCC_TIM3_CLK_ENABLE();
 8009c96:	4b1b      	ldr	r3, [pc, #108]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009c98:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009c9a:	4a1a      	ldr	r2, [pc, #104]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009c9c:	f043 0302 	orr.w	r3, r3, #2
 8009ca0:	6413      	str	r3, [r2, #64]	; 0x40
 8009ca2:	4b18      	ldr	r3, [pc, #96]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009ca4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009ca6:	f003 0302 	and.w	r3, r3, #2
 8009caa:	613b      	str	r3, [r7, #16]
 8009cac:	693b      	ldr	r3, [r7, #16]
}
 8009cae:	e022      	b.n	8009cf6 <HAL_TIM_Base_MspInit+0x96>
  else if(htim_base->Instance==TIM5)
 8009cb0:	687b      	ldr	r3, [r7, #4]
 8009cb2:	681b      	ldr	r3, [r3, #0]
 8009cb4:	4a15      	ldr	r2, [pc, #84]	; (8009d0c <HAL_TIM_Base_MspInit+0xac>)
 8009cb6:	4293      	cmp	r3, r2
 8009cb8:	d10c      	bne.n	8009cd4 <HAL_TIM_Base_MspInit+0x74>
    __HAL_RCC_TIM5_CLK_ENABLE();
 8009cba:	4b12      	ldr	r3, [pc, #72]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009cbc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009cbe:	4a11      	ldr	r2, [pc, #68]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009cc0:	f043 0308 	orr.w	r3, r3, #8
 8009cc4:	6413      	str	r3, [r2, #64]	; 0x40
 8009cc6:	4b0f      	ldr	r3, [pc, #60]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009cc8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8009cca:	f003 0308 	and.w	r3, r3, #8
 8009cce:	60fb      	str	r3, [r7, #12]
 8009cd0:	68fb      	ldr	r3, [r7, #12]
}
 8009cd2:	e010      	b.n	8009cf6 <HAL_TIM_Base_MspInit+0x96>
  else if(htim_base->Instance==TIM8)
 8009cd4:	687b      	ldr	r3, [r7, #4]
 8009cd6:	681b      	ldr	r3, [r3, #0]
 8009cd8:	4a0d      	ldr	r2, [pc, #52]	; (8009d10 <HAL_TIM_Base_MspInit+0xb0>)
 8009cda:	4293      	cmp	r3, r2
 8009cdc:	d10b      	bne.n	8009cf6 <HAL_TIM_Base_MspInit+0x96>
    __HAL_RCC_TIM8_CLK_ENABLE();
 8009cde:	4b09      	ldr	r3, [pc, #36]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009ce0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ce2:	4a08      	ldr	r2, [pc, #32]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009ce4:	f043 0302 	orr.w	r3, r3, #2
 8009ce8:	6453      	str	r3, [r2, #68]	; 0x44
 8009cea:	4b06      	ldr	r3, [pc, #24]	; (8009d04 <HAL_TIM_Base_MspInit+0xa4>)
 8009cec:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009cee:	f003 0302 	and.w	r3, r3, #2
 8009cf2:	60bb      	str	r3, [r7, #8]
 8009cf4:	68bb      	ldr	r3, [r7, #8]
}
 8009cf6:	bf00      	nop
 8009cf8:	371c      	adds	r7, #28
 8009cfa:	46bd      	mov	sp, r7
 8009cfc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8009d00:	4770      	bx	lr
 8009d02:	bf00      	nop
 8009d04:	40023800 	.word	0x40023800
 8009d08:	40000400 	.word	0x40000400
 8009d0c:	40000c00 	.word	0x40000c00
 8009d10:	40010400 	.word	0x40010400

08009d14 <HAL_TIM_MspPostInit>:

void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim)
{
 8009d14:	b580      	push	{r7, lr}
 8009d16:	b08c      	sub	sp, #48	; 0x30
 8009d18:	af00      	add	r7, sp, #0
 8009d1a:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009d1c:	f107 031c 	add.w	r3, r7, #28
 8009d20:	2200      	movs	r2, #0
 8009d22:	601a      	str	r2, [r3, #0]
 8009d24:	605a      	str	r2, [r3, #4]
 8009d26:	609a      	str	r2, [r3, #8]
 8009d28:	60da      	str	r2, [r3, #12]
 8009d2a:	611a      	str	r2, [r3, #16]
  if(htim->Instance==TIM1)
 8009d2c:	687b      	ldr	r3, [r7, #4]
 8009d2e:	681b      	ldr	r3, [r3, #0]
 8009d30:	4a56      	ldr	r2, [pc, #344]	; (8009e8c <HAL_TIM_MspPostInit+0x178>)
 8009d32:	4293      	cmp	r3, r2
 8009d34:	d11d      	bne.n	8009d72 <HAL_TIM_MspPostInit+0x5e>
  {
  /* USER CODE BEGIN TIM1_MspPostInit 0 */

  /* USER CODE END TIM1_MspPostInit 0 */
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8009d36:	4b56      	ldr	r3, [pc, #344]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009d38:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d3a:	4a55      	ldr	r2, [pc, #340]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009d3c:	f043 0301 	orr.w	r3, r3, #1
 8009d40:	6313      	str	r3, [r2, #48]	; 0x30
 8009d42:	4b53      	ldr	r3, [pc, #332]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009d44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d46:	f003 0301 	and.w	r3, r3, #1
 8009d4a:	61bb      	str	r3, [r7, #24]
 8009d4c:	69bb      	ldr	r3, [r7, #24]
    /**TIM1 GPIO Configuration    
    PA8     ------> TIM1_CH1 
    */
    GPIO_InitStruct.Pin = ARDUINO_PWM_D10_Pin;
 8009d4e:	f44f 7380 	mov.w	r3, #256	; 0x100
 8009d52:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009d54:	2302      	movs	r3, #2
 8009d56:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d58:	2300      	movs	r3, #0
 8009d5a:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009d5c:	2300      	movs	r3, #0
 8009d5e:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM1;
 8009d60:	2301      	movs	r3, #1
 8009d62:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(ARDUINO_PWM_D10_GPIO_Port, &GPIO_InitStruct);
 8009d64:	f107 031c 	add.w	r3, r7, #28
 8009d68:	4619      	mov	r1, r3
 8009d6a:	484a      	ldr	r0, [pc, #296]	; (8009e94 <HAL_TIM_MspPostInit+0x180>)
 8009d6c:	f7f7 ff06 	bl	8001b7c <HAL_GPIO_Init>
  /* USER CODE BEGIN TIM12_MspPostInit 1 */

  /* USER CODE END TIM12_MspPostInit 1 */
  }

}
 8009d70:	e087      	b.n	8009e82 <HAL_TIM_MspPostInit+0x16e>
  else if(htim->Instance==TIM2)
 8009d72:	687b      	ldr	r3, [r7, #4]
 8009d74:	681b      	ldr	r3, [r3, #0]
 8009d76:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8009d7a:	d11d      	bne.n	8009db8 <HAL_TIM_MspPostInit+0xa4>
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8009d7c:	4b44      	ldr	r3, [pc, #272]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009d7e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d80:	4a43      	ldr	r2, [pc, #268]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009d82:	f043 0301 	orr.w	r3, r3, #1
 8009d86:	6313      	str	r3, [r2, #48]	; 0x30
 8009d88:	4b41      	ldr	r3, [pc, #260]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009d8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009d8c:	f003 0301 	and.w	r3, r3, #1
 8009d90:	617b      	str	r3, [r7, #20]
 8009d92:	697b      	ldr	r3, [r7, #20]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D9_Pin;
 8009d94:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8009d98:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009d9a:	2302      	movs	r3, #2
 8009d9c:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d9e:	2300      	movs	r3, #0
 8009da0:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009da2:	2300      	movs	r3, #0
 8009da4:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;
 8009da6:	2301      	movs	r3, #1
 8009da8:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(ARDUINO_PWM_D9_GPIO_Port, &GPIO_InitStruct);
 8009daa:	f107 031c 	add.w	r3, r7, #28
 8009dae:	4619      	mov	r1, r3
 8009db0:	4838      	ldr	r0, [pc, #224]	; (8009e94 <HAL_TIM_MspPostInit+0x180>)
 8009db2:	f7f7 fee3 	bl	8001b7c <HAL_GPIO_Init>
}
 8009db6:	e064      	b.n	8009e82 <HAL_TIM_MspPostInit+0x16e>
  else if(htim->Instance==TIM3)
 8009db8:	687b      	ldr	r3, [r7, #4]
 8009dba:	681b      	ldr	r3, [r3, #0]
 8009dbc:	4a36      	ldr	r2, [pc, #216]	; (8009e98 <HAL_TIM_MspPostInit+0x184>)
 8009dbe:	4293      	cmp	r3, r2
 8009dc0:	d11c      	bne.n	8009dfc <HAL_TIM_MspPostInit+0xe8>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8009dc2:	4b33      	ldr	r3, [pc, #204]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009dc4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009dc6:	4a32      	ldr	r2, [pc, #200]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009dc8:	f043 0302 	orr.w	r3, r3, #2
 8009dcc:	6313      	str	r3, [r2, #48]	; 0x30
 8009dce:	4b30      	ldr	r3, [pc, #192]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009dd0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009dd2:	f003 0302 	and.w	r3, r3, #2
 8009dd6:	613b      	str	r3, [r7, #16]
 8009dd8:	693b      	ldr	r3, [r7, #16]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D3_Pin;
 8009dda:	2310      	movs	r3, #16
 8009ddc:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009dde:	2302      	movs	r3, #2
 8009de0:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009de2:	2300      	movs	r3, #0
 8009de4:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009de6:	2300      	movs	r3, #0
 8009de8:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 8009dea:	2302      	movs	r3, #2
 8009dec:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(ARDUINO_PWM_D3_GPIO_Port, &GPIO_InitStruct);
 8009dee:	f107 031c 	add.w	r3, r7, #28
 8009df2:	4619      	mov	r1, r3
 8009df4:	4829      	ldr	r0, [pc, #164]	; (8009e9c <HAL_TIM_MspPostInit+0x188>)
 8009df6:	f7f7 fec1 	bl	8001b7c <HAL_GPIO_Init>
}
 8009dfa:	e042      	b.n	8009e82 <HAL_TIM_MspPostInit+0x16e>
  else if(htim->Instance==TIM5)
 8009dfc:	687b      	ldr	r3, [r7, #4]
 8009dfe:	681b      	ldr	r3, [r3, #0]
 8009e00:	4a27      	ldr	r2, [pc, #156]	; (8009ea0 <HAL_TIM_MspPostInit+0x18c>)
 8009e02:	4293      	cmp	r3, r2
 8009e04:	d11c      	bne.n	8009e40 <HAL_TIM_MspPostInit+0x12c>
    __HAL_RCC_GPIOI_CLK_ENABLE();
 8009e06:	4b22      	ldr	r3, [pc, #136]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009e08:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009e0a:	4a21      	ldr	r2, [pc, #132]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009e0c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8009e10:	6313      	str	r3, [r2, #48]	; 0x30
 8009e12:	4b1f      	ldr	r3, [pc, #124]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009e14:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009e16:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8009e1a:	60fb      	str	r3, [r7, #12]
 8009e1c:	68fb      	ldr	r3, [r7, #12]
    GPIO_InitStruct.Pin = ARDUINO_PWM_CS_D5_Pin;
 8009e1e:	2301      	movs	r3, #1
 8009e20:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009e22:	2302      	movs	r3, #2
 8009e24:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e26:	2300      	movs	r3, #0
 8009e28:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009e2a:	2300      	movs	r3, #0
 8009e2c:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM5;
 8009e2e:	2302      	movs	r3, #2
 8009e30:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(ARDUINO_PWM_CS_D5_GPIO_Port, &GPIO_InitStruct);
 8009e32:	f107 031c 	add.w	r3, r7, #28
 8009e36:	4619      	mov	r1, r3
 8009e38:	481a      	ldr	r0, [pc, #104]	; (8009ea4 <HAL_TIM_MspPostInit+0x190>)
 8009e3a:	f7f7 fe9f 	bl	8001b7c <HAL_GPIO_Init>
}
 8009e3e:	e020      	b.n	8009e82 <HAL_TIM_MspPostInit+0x16e>
  else if(htim->Instance==TIM12)
 8009e40:	687b      	ldr	r3, [r7, #4]
 8009e42:	681b      	ldr	r3, [r3, #0]
 8009e44:	4a18      	ldr	r2, [pc, #96]	; (8009ea8 <HAL_TIM_MspPostInit+0x194>)
 8009e46:	4293      	cmp	r3, r2
 8009e48:	d11b      	bne.n	8009e82 <HAL_TIM_MspPostInit+0x16e>
    __HAL_RCC_GPIOH_CLK_ENABLE();
 8009e4a:	4b11      	ldr	r3, [pc, #68]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009e4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009e4e:	4a10      	ldr	r2, [pc, #64]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009e50:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009e54:	6313      	str	r3, [r2, #48]	; 0x30
 8009e56:	4b0e      	ldr	r3, [pc, #56]	; (8009e90 <HAL_TIM_MspPostInit+0x17c>)
 8009e58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009e5a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009e5e:	60bb      	str	r3, [r7, #8]
 8009e60:	68bb      	ldr	r3, [r7, #8]
    GPIO_InitStruct.Pin = ARDUINO_PWM_D6_Pin;
 8009e62:	2340      	movs	r3, #64	; 0x40
 8009e64:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009e66:	2302      	movs	r3, #2
 8009e68:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e6a:	2300      	movs	r3, #0
 8009e6c:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009e6e:	2300      	movs	r3, #0
 8009e70:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 8009e72:	2309      	movs	r3, #9
 8009e74:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(ARDUINO_PWM_D6_GPIO_Port, &GPIO_InitStruct);
 8009e76:	f107 031c 	add.w	r3, r7, #28
 8009e7a:	4619      	mov	r1, r3
 8009e7c:	480b      	ldr	r0, [pc, #44]	; (8009eac <HAL_TIM_MspPostInit+0x198>)
 8009e7e:	f7f7 fe7d 	bl	8001b7c <HAL_GPIO_Init>
}
 8009e82:	bf00      	nop
 8009e84:	3730      	adds	r7, #48	; 0x30
 8009e86:	46bd      	mov	sp, r7
 8009e88:	bd80      	pop	{r7, pc}
 8009e8a:	bf00      	nop
 8009e8c:	40010000 	.word	0x40010000
 8009e90:	40023800 	.word	0x40023800
 8009e94:	40020000 	.word	0x40020000
 8009e98:	40000400 	.word	0x40000400
 8009e9c:	40020400 	.word	0x40020400
 8009ea0:	40000c00 	.word	0x40000c00
 8009ea4:	40022000 	.word	0x40022000
 8009ea8:	40001800 	.word	0x40001800
 8009eac:	40021c00 	.word	0x40021c00

08009eb0 <HAL_UART_MspInit>:
* This function configures the hardware resources used in this example
* @param huart: UART handle pointer
* @retval None
*/
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8009eb0:	b580      	push	{r7, lr}
 8009eb2:	b08c      	sub	sp, #48	; 0x30
 8009eb4:	af00      	add	r7, sp, #0
 8009eb6:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009eb8:	f107 031c 	add.w	r3, r7, #28
 8009ebc:	2200      	movs	r2, #0
 8009ebe:	601a      	str	r2, [r3, #0]
 8009ec0:	605a      	str	r2, [r3, #4]
 8009ec2:	609a      	str	r2, [r3, #8]
 8009ec4:	60da      	str	r2, [r3, #12]
 8009ec6:	611a      	str	r2, [r3, #16]
  if(huart->Instance==USART1)
 8009ec8:	687b      	ldr	r3, [r7, #4]
 8009eca:	681b      	ldr	r3, [r3, #0]
 8009ecc:	4a3c      	ldr	r2, [pc, #240]	; (8009fc0 <HAL_UART_MspInit+0x110>)
 8009ece:	4293      	cmp	r3, r2
 8009ed0:	d145      	bne.n	8009f5e <HAL_UART_MspInit+0xae>
  {
  /* USER CODE BEGIN USART1_MspInit 0 */

  /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8009ed2:	4b3c      	ldr	r3, [pc, #240]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009ed4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ed6:	4a3b      	ldr	r2, [pc, #236]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009ed8:	f043 0310 	orr.w	r3, r3, #16
 8009edc:	6453      	str	r3, [r2, #68]	; 0x44
 8009ede:	4b39      	ldr	r3, [pc, #228]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009ee0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009ee2:	f003 0310 	and.w	r3, r3, #16
 8009ee6:	61bb      	str	r3, [r7, #24]
 8009ee8:	69bb      	ldr	r3, [r7, #24]
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8009eea:	4b36      	ldr	r3, [pc, #216]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009eec:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009eee:	4a35      	ldr	r2, [pc, #212]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009ef0:	f043 0302 	orr.w	r3, r3, #2
 8009ef4:	6313      	str	r3, [r2, #48]	; 0x30
 8009ef6:	4b33      	ldr	r3, [pc, #204]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009ef8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009efa:	f003 0302 	and.w	r3, r3, #2
 8009efe:	617b      	str	r3, [r7, #20]
 8009f00:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8009f02:	4b30      	ldr	r3, [pc, #192]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009f06:	4a2f      	ldr	r2, [pc, #188]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f08:	f043 0301 	orr.w	r3, r3, #1
 8009f0c:	6313      	str	r3, [r2, #48]	; 0x30
 8009f0e:	4b2d      	ldr	r3, [pc, #180]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009f12:	f003 0301 	and.w	r3, r3, #1
 8009f16:	613b      	str	r3, [r7, #16]
 8009f18:	693b      	ldr	r3, [r7, #16]
    /**USART1 GPIO Configuration    
    PB7     ------> USART1_RX
    PA9     ------> USART1_TX 
    */
    GPIO_InitStruct.Pin = VCP_RX_Pin;
 8009f1a:	2380      	movs	r3, #128	; 0x80
 8009f1c:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009f1e:	2302      	movs	r3, #2
 8009f20:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009f22:	2300      	movs	r3, #0
 8009f24:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009f26:	2300      	movs	r3, #0
 8009f28:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8009f2a:	2307      	movs	r3, #7
 8009f2c:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 8009f2e:	f107 031c 	add.w	r3, r7, #28
 8009f32:	4619      	mov	r1, r3
 8009f34:	4824      	ldr	r0, [pc, #144]	; (8009fc8 <HAL_UART_MspInit+0x118>)
 8009f36:	f7f7 fe21 	bl	8001b7c <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = VCP_TX_Pin;
 8009f3a:	f44f 7300 	mov.w	r3, #512	; 0x200
 8009f3e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009f40:	2302      	movs	r3, #2
 8009f42:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009f44:	2300      	movs	r3, #0
 8009f46:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009f48:	2300      	movs	r3, #0
 8009f4a:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8009f4c:	2307      	movs	r3, #7
 8009f4e:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 8009f50:	f107 031c 	add.w	r3, r7, #28
 8009f54:	4619      	mov	r1, r3
 8009f56:	481d      	ldr	r0, [pc, #116]	; (8009fcc <HAL_UART_MspInit+0x11c>)
 8009f58:	f7f7 fe10 	bl	8001b7c <HAL_GPIO_Init>
  /* USER CODE BEGIN USART6_MspInit 1 */

  /* USER CODE END USART6_MspInit 1 */
  }

}
 8009f5c:	e02c      	b.n	8009fb8 <HAL_UART_MspInit+0x108>
  else if(huart->Instance==USART6)
 8009f5e:	687b      	ldr	r3, [r7, #4]
 8009f60:	681b      	ldr	r3, [r3, #0]
 8009f62:	4a1b      	ldr	r2, [pc, #108]	; (8009fd0 <HAL_UART_MspInit+0x120>)
 8009f64:	4293      	cmp	r3, r2
 8009f66:	d127      	bne.n	8009fb8 <HAL_UART_MspInit+0x108>
    __HAL_RCC_USART6_CLK_ENABLE();
 8009f68:	4b16      	ldr	r3, [pc, #88]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f6a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f6c:	4a15      	ldr	r2, [pc, #84]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f6e:	f043 0320 	orr.w	r3, r3, #32
 8009f72:	6453      	str	r3, [r2, #68]	; 0x44
 8009f74:	4b13      	ldr	r3, [pc, #76]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f76:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009f78:	f003 0320 	and.w	r3, r3, #32
 8009f7c:	60fb      	str	r3, [r7, #12]
 8009f7e:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8009f80:	4b10      	ldr	r3, [pc, #64]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009f84:	4a0f      	ldr	r2, [pc, #60]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f86:	f043 0304 	orr.w	r3, r3, #4
 8009f8a:	6313      	str	r3, [r2, #48]	; 0x30
 8009f8c:	4b0d      	ldr	r3, [pc, #52]	; (8009fc4 <HAL_UART_MspInit+0x114>)
 8009f8e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009f90:	f003 0304 	and.w	r3, r3, #4
 8009f94:	60bb      	str	r3, [r7, #8]
 8009f96:	68bb      	ldr	r3, [r7, #8]
    GPIO_InitStruct.Pin = ARDUINO_RX_D0_Pin|ARDUINO_TX_D1_Pin;
 8009f98:	23c0      	movs	r3, #192	; 0xc0
 8009f9a:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009f9c:	2302      	movs	r3, #2
 8009f9e:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009fa0:	2300      	movs	r3, #0
 8009fa2:	627b      	str	r3, [r7, #36]	; 0x24
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009fa4:	2303      	movs	r3, #3
 8009fa6:	62bb      	str	r3, [r7, #40]	; 0x28
    GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 8009fa8:	2308      	movs	r3, #8
 8009faa:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009fac:	f107 031c 	add.w	r3, r7, #28
 8009fb0:	4619      	mov	r1, r3
 8009fb2:	4808      	ldr	r0, [pc, #32]	; (8009fd4 <HAL_UART_MspInit+0x124>)
 8009fb4:	f7f7 fde2 	bl	8001b7c <HAL_GPIO_Init>
}
 8009fb8:	bf00      	nop
 8009fba:	3730      	adds	r7, #48	; 0x30
 8009fbc:	46bd      	mov	sp, r7
 8009fbe:	bd80      	pop	{r7, pc}
 8009fc0:	40011000 	.word	0x40011000
 8009fc4:	40023800 	.word	0x40023800
 8009fc8:	40020400 	.word	0x40020400
 8009fcc:	40020000 	.word	0x40020000
 8009fd0:	40011400 	.word	0x40011400
 8009fd4:	40020800 	.word	0x40020800

08009fd8 <HAL_HCD_MspInit>:
* This function configures the hardware resources used in this example
* @param hhcd: HCD handle pointer
* @retval None
*/
void HAL_HCD_MspInit(HCD_HandleTypeDef* hhcd)
{
 8009fd8:	b580      	push	{r7, lr}
 8009fda:	b08a      	sub	sp, #40	; 0x28
 8009fdc:	af00      	add	r7, sp, #0
 8009fde:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8009fe0:	f107 0314 	add.w	r3, r7, #20
 8009fe4:	2200      	movs	r2, #0
 8009fe6:	601a      	str	r2, [r3, #0]
 8009fe8:	605a      	str	r2, [r3, #4]
 8009fea:	609a      	str	r2, [r3, #8]
 8009fec:	60da      	str	r2, [r3, #12]
 8009fee:	611a      	str	r2, [r3, #16]
  if(hhcd->Instance==USB_OTG_FS)
 8009ff0:	687b      	ldr	r3, [r7, #4]
 8009ff2:	681b      	ldr	r3, [r3, #0]
 8009ff4:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 8009ff8:	d13c      	bne.n	800a074 <HAL_HCD_MspInit+0x9c>
  {
  /* USER CODE BEGIN USB_OTG_FS_MspInit 0 */

  /* USER CODE END USB_OTG_FS_MspInit 0 */
  
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8009ffa:	4b20      	ldr	r3, [pc, #128]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 8009ffc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009ffe:	4a1f      	ldr	r2, [pc, #124]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a000:	f043 0301 	orr.w	r3, r3, #1
 800a004:	6313      	str	r3, [r2, #48]	; 0x30
 800a006:	4b1d      	ldr	r3, [pc, #116]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a008:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a00a:	f003 0301 	and.w	r3, r3, #1
 800a00e:	613b      	str	r3, [r7, #16]
 800a010:	693b      	ldr	r3, [r7, #16]
    /**USB_OTG_FS GPIO Configuration    
    PA12     ------> USB_OTG_FS_DP
    PA11     ------> USB_OTG_FS_DM
    PA10     ------> USB_OTG_FS_ID 
    */
    GPIO_InitStruct.Pin = OTG_FS_P_Pin|OTG_FS_N_Pin|OTG_FS_ID_Pin;
 800a012:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800a016:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a018:	2302      	movs	r3, #2
 800a01a:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a01c:	2300      	movs	r3, #0
 800a01e:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a020:	2303      	movs	r3, #3
 800a022:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
 800a024:	230a      	movs	r3, #10
 800a026:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a028:	f107 0314 	add.w	r3, r7, #20
 800a02c:	4619      	mov	r1, r3
 800a02e:	4814      	ldr	r0, [pc, #80]	; (800a080 <HAL_HCD_MspInit+0xa8>)
 800a030:	f7f7 fda4 	bl	8001b7c <HAL_GPIO_Init>

    /* Peripheral clock enable */
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 800a034:	4b11      	ldr	r3, [pc, #68]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a036:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a038:	4a10      	ldr	r2, [pc, #64]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a03a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800a03e:	6353      	str	r3, [r2, #52]	; 0x34
 800a040:	4b0e      	ldr	r3, [pc, #56]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a042:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a044:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a048:	60fb      	str	r3, [r7, #12]
 800a04a:	68fb      	ldr	r3, [r7, #12]
 800a04c:	4b0b      	ldr	r3, [pc, #44]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a04e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a050:	4a0a      	ldr	r2, [pc, #40]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a052:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800a056:	6453      	str	r3, [r2, #68]	; 0x44
 800a058:	4b08      	ldr	r3, [pc, #32]	; (800a07c <HAL_HCD_MspInit+0xa4>)
 800a05a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a05c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800a060:	60bb      	str	r3, [r7, #8]
 800a062:	68bb      	ldr	r3, [r7, #8]
    /* USB_OTG_FS interrupt Init */
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 0, 0);
 800a064:	2200      	movs	r2, #0
 800a066:	2100      	movs	r1, #0
 800a068:	2043      	movs	r0, #67	; 0x43
 800a06a:	f7f6 fe33 	bl	8000cd4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 800a06e:	2043      	movs	r0, #67	; 0x43
 800a070:	f7f6 fe4c 	bl	8000d0c <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */

  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }

}
 800a074:	bf00      	nop
 800a076:	3728      	adds	r7, #40	; 0x28
 800a078:	46bd      	mov	sp, r7
 800a07a:	bd80      	pop	{r7, pc}
 800a07c:	40023800 	.word	0x40023800
 800a080:	40020000 	.word	0x40020000

0800a084 <HAL_FMC_MspInit>:

}

static uint32_t FMC_Initialized = 0;

static void HAL_FMC_MspInit(void){
 800a084:	b580      	push	{r7, lr}
 800a086:	b086      	sub	sp, #24
 800a088:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct ={0};
 800a08a:	1d3b      	adds	r3, r7, #4
 800a08c:	2200      	movs	r2, #0
 800a08e:	601a      	str	r2, [r3, #0]
 800a090:	605a      	str	r2, [r3, #4]
 800a092:	609a      	str	r2, [r3, #8]
 800a094:	60da      	str	r2, [r3, #12]
 800a096:	611a      	str	r2, [r3, #16]
  if (FMC_Initialized) {
 800a098:	4b3a      	ldr	r3, [pc, #232]	; (800a184 <HAL_FMC_MspInit+0x100>)
 800a09a:	681b      	ldr	r3, [r3, #0]
 800a09c:	2b00      	cmp	r3, #0
 800a09e:	d16d      	bne.n	800a17c <HAL_FMC_MspInit+0xf8>
    return;
  }
  FMC_Initialized = 1;
 800a0a0:	4b38      	ldr	r3, [pc, #224]	; (800a184 <HAL_FMC_MspInit+0x100>)
 800a0a2:	2201      	movs	r2, #1
 800a0a4:	601a      	str	r2, [r3, #0]
  /* Peripheral clock enable */
  __HAL_RCC_FMC_CLK_ENABLE();
 800a0a6:	4b38      	ldr	r3, [pc, #224]	; (800a188 <HAL_FMC_MspInit+0x104>)
 800a0a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a0aa:	4a37      	ldr	r2, [pc, #220]	; (800a188 <HAL_FMC_MspInit+0x104>)
 800a0ac:	f043 0301 	orr.w	r3, r3, #1
 800a0b0:	6393      	str	r3, [r2, #56]	; 0x38
 800a0b2:	4b35      	ldr	r3, [pc, #212]	; (800a188 <HAL_FMC_MspInit+0x104>)
 800a0b4:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800a0b6:	f003 0301 	and.w	r3, r3, #1
 800a0ba:	603b      	str	r3, [r7, #0]
 800a0bc:	683b      	ldr	r3, [r7, #0]
  PE10   ------> FMC_D7
  PE12   ------> FMC_D9
  PE15   ------> FMC_D12
  PE13   ------> FMC_D10
  */
  GPIO_InitStruct.Pin = FMC_NBL1_Pin|FMC_NBL0_Pin|FMC_D5_Pin|FMC_D6_Pin 
 800a0be:	f64f 7383 	movw	r3, #65411	; 0xff83
 800a0c2:	607b      	str	r3, [r7, #4]
                          |FMC_D8_Pin|FMC_D11_Pin|FMC_D4_Pin|FMC_D7_Pin 
                          |FMC_D9_Pin|FMC_D12_Pin|FMC_D10_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a0c4:	2302      	movs	r3, #2
 800a0c6:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a0c8:	2300      	movs	r3, #0
 800a0ca:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a0cc:	2303      	movs	r3, #3
 800a0ce:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800a0d0:	230c      	movs	r3, #12
 800a0d2:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800a0d4:	1d3b      	adds	r3, r7, #4
 800a0d6:	4619      	mov	r1, r3
 800a0d8:	482c      	ldr	r0, [pc, #176]	; (800a18c <HAL_FMC_MspInit+0x108>)
 800a0da:	f7f7 fd4f 	bl	8001b7c <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = FMC_SDNCAS_Pin|FMC_SDCLK_Pin|FMC_A11_Pin|FMC_A10_Pin 
 800a0de:	f248 1333 	movw	r3, #33075	; 0x8133
 800a0e2:	607b      	str	r3, [r7, #4]
                          |FMC_BA1_Pin|FMC_BA0_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a0e4:	2302      	movs	r3, #2
 800a0e6:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a0e8:	2300      	movs	r3, #0
 800a0ea:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a0ec:	2303      	movs	r3, #3
 800a0ee:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800a0f0:	230c      	movs	r3, #12
 800a0f2:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800a0f4:	1d3b      	adds	r3, r7, #4
 800a0f6:	4619      	mov	r1, r3
 800a0f8:	4825      	ldr	r0, [pc, #148]	; (800a190 <HAL_FMC_MspInit+0x10c>)
 800a0fa:	f7f7 fd3f 	bl	8001b7c <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = FMC_D2_Pin|FMC_D3_Pin|FMC_D1_Pin|FMC_D15_Pin 
 800a0fe:	f24c 7303 	movw	r3, #50947	; 0xc703
 800a102:	607b      	str	r3, [r7, #4]
                          |FMC_D0_Pin|FMC_D14_Pin|FMC_D13_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a104:	2302      	movs	r3, #2
 800a106:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a108:	2300      	movs	r3, #0
 800a10a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a10c:	2303      	movs	r3, #3
 800a10e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800a110:	230c      	movs	r3, #12
 800a112:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800a114:	1d3b      	adds	r3, r7, #4
 800a116:	4619      	mov	r1, r3
 800a118:	481e      	ldr	r0, [pc, #120]	; (800a194 <HAL_FMC_MspInit+0x110>)
 800a11a:	f7f7 fd2f 	bl	8001b7c <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = FMC_A0_Pin|FMC_A1_Pin|FMC_A2_Pin|FMC_A3_Pin 
 800a11e:	f64f 033f 	movw	r3, #63551	; 0xf83f
 800a122:	607b      	str	r3, [r7, #4]
                          |FMC_A4_Pin|FMC_A5_Pin|FMC_A6_Pin|FMC_A9_Pin 
                          |FMC_A7_Pin|FMC_A8_Pin|FMC_SDNRAS_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a124:	2302      	movs	r3, #2
 800a126:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a128:	2300      	movs	r3, #0
 800a12a:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a12c:	2303      	movs	r3, #3
 800a12e:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800a130:	230c      	movs	r3, #12
 800a132:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 800a134:	1d3b      	adds	r3, r7, #4
 800a136:	4619      	mov	r1, r3
 800a138:	4817      	ldr	r0, [pc, #92]	; (800a198 <HAL_FMC_MspInit+0x114>)
 800a13a:	f7f7 fd1f 	bl	8001b7c <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = FMC_SDNME_Pin|FMC_SDNE0_Pin;
 800a13e:	2328      	movs	r3, #40	; 0x28
 800a140:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a142:	2302      	movs	r3, #2
 800a144:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a146:	2300      	movs	r3, #0
 800a148:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a14a:	2303      	movs	r3, #3
 800a14c:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800a14e:	230c      	movs	r3, #12
 800a150:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 800a152:	1d3b      	adds	r3, r7, #4
 800a154:	4619      	mov	r1, r3
 800a156:	4811      	ldr	r0, [pc, #68]	; (800a19c <HAL_FMC_MspInit+0x118>)
 800a158:	f7f7 fd10 	bl	8001b7c <HAL_GPIO_Init>

  GPIO_InitStruct.Pin = FMC_SDCKE0_Pin;
 800a15c:	2308      	movs	r3, #8
 800a15e:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a160:	2302      	movs	r3, #2
 800a162:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a164:	2300      	movs	r3, #0
 800a166:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a168:	2303      	movs	r3, #3
 800a16a:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 800a16c:	230c      	movs	r3, #12
 800a16e:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(FMC_SDCKE0_GPIO_Port, &GPIO_InitStruct);
 800a170:	1d3b      	adds	r3, r7, #4
 800a172:	4619      	mov	r1, r3
 800a174:	480a      	ldr	r0, [pc, #40]	; (800a1a0 <HAL_FMC_MspInit+0x11c>)
 800a176:	f7f7 fd01 	bl	8001b7c <HAL_GPIO_Init>
 800a17a:	e000      	b.n	800a17e <HAL_FMC_MspInit+0xfa>
    return;
 800a17c:	bf00      	nop

  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}
 800a17e:	3718      	adds	r7, #24
 800a180:	46bd      	mov	sp, r7
 800a182:	bd80      	pop	{r7, pc}
 800a184:	20000cc8 	.word	0x20000cc8
 800a188:	40023800 	.word	0x40023800
 800a18c:	40021000 	.word	0x40021000
 800a190:	40021800 	.word	0x40021800
 800a194:	40020c00 	.word	0x40020c00
 800a198:	40021400 	.word	0x40021400
 800a19c:	40021c00 	.word	0x40021c00
 800a1a0:	40020800 	.word	0x40020800

0800a1a4 <HAL_SDRAM_MspInit>:

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* hsdram){
 800a1a4:	b580      	push	{r7, lr}
 800a1a6:	b082      	sub	sp, #8
 800a1a8:	af00      	add	r7, sp, #0
 800a1aa:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN SDRAM_MspInit 0 */

  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
 800a1ac:	f7ff ff6a 	bl	800a084 <HAL_FMC_MspInit>
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 800a1b0:	bf00      	nop
 800a1b2:	3708      	adds	r7, #8
 800a1b4:	46bd      	mov	sp, r7
 800a1b6:	bd80      	pop	{r7, pc}

0800a1b8 <HAL_SAI_MspInit>:
}

static uint32_t SAI2_client =0;

void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{
 800a1b8:	b580      	push	{r7, lr}
 800a1ba:	b08a      	sub	sp, #40	; 0x28
 800a1bc:	af00      	add	r7, sp, #0
 800a1be:	6078      	str	r0, [r7, #4]

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI2 */
    if(hsai->Instance==SAI2_Block_A)
 800a1c0:	687b      	ldr	r3, [r7, #4]
 800a1c2:	681b      	ldr	r3, [r3, #0]
 800a1c4:	4a2b      	ldr	r2, [pc, #172]	; (800a274 <HAL_SAI_MspInit+0xbc>)
 800a1c6:	4293      	cmp	r3, r2
 800a1c8:	d124      	bne.n	800a214 <HAL_SAI_MspInit+0x5c>
    {
    /* Peripheral clock enable */
    if (SAI2_client == 0)
 800a1ca:	4b2b      	ldr	r3, [pc, #172]	; (800a278 <HAL_SAI_MspInit+0xc0>)
 800a1cc:	681b      	ldr	r3, [r3, #0]
 800a1ce:	2b00      	cmp	r3, #0
 800a1d0:	d10b      	bne.n	800a1ea <HAL_SAI_MspInit+0x32>
    {
       __HAL_RCC_SAI2_CLK_ENABLE();
 800a1d2:	4b2a      	ldr	r3, [pc, #168]	; (800a27c <HAL_SAI_MspInit+0xc4>)
 800a1d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a1d6:	4a29      	ldr	r2, [pc, #164]	; (800a27c <HAL_SAI_MspInit+0xc4>)
 800a1d8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800a1dc:	6453      	str	r3, [r2, #68]	; 0x44
 800a1de:	4b27      	ldr	r3, [pc, #156]	; (800a27c <HAL_SAI_MspInit+0xc4>)
 800a1e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a1e2:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800a1e6:	613b      	str	r3, [r7, #16]
 800a1e8:	693b      	ldr	r3, [r7, #16]
    }
    SAI2_client ++;
 800a1ea:	4b23      	ldr	r3, [pc, #140]	; (800a278 <HAL_SAI_MspInit+0xc0>)
 800a1ec:	681b      	ldr	r3, [r3, #0]
 800a1ee:	3301      	adds	r3, #1
 800a1f0:	4a21      	ldr	r2, [pc, #132]	; (800a278 <HAL_SAI_MspInit+0xc0>)
 800a1f2:	6013      	str	r3, [r2, #0]
    PI4     ------> SAI2_MCLK_A
    PI5     ------> SAI2_SCK_A
    PI7     ------> SAI2_FS_A
    PI6     ------> SAI2_SD_A 
    */
    GPIO_InitStruct.Pin = SAI2_MCLKA_Pin|SAI2_SCKA_Pin|SAI2_FSA_Pin|SAI2_SDA_Pin;
 800a1f4:	23f0      	movs	r3, #240	; 0xf0
 800a1f6:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a1f8:	2302      	movs	r3, #2
 800a1fa:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a1fc:	2300      	movs	r3, #0
 800a1fe:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a200:	2300      	movs	r3, #0
 800a202:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 800a204:	230a      	movs	r3, #10
 800a206:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 800a208:	f107 0314 	add.w	r3, r7, #20
 800a20c:	4619      	mov	r1, r3
 800a20e:	481c      	ldr	r0, [pc, #112]	; (800a280 <HAL_SAI_MspInit+0xc8>)
 800a210:	f7f7 fcb4 	bl	8001b7c <HAL_GPIO_Init>

    }
    if(hsai->Instance==SAI2_Block_B)
 800a214:	687b      	ldr	r3, [r7, #4]
 800a216:	681b      	ldr	r3, [r3, #0]
 800a218:	4a1a      	ldr	r2, [pc, #104]	; (800a284 <HAL_SAI_MspInit+0xcc>)
 800a21a:	4293      	cmp	r3, r2
 800a21c:	d125      	bne.n	800a26a <HAL_SAI_MspInit+0xb2>
    {
      /* Peripheral clock enable */
      if (SAI2_client == 0)
 800a21e:	4b16      	ldr	r3, [pc, #88]	; (800a278 <HAL_SAI_MspInit+0xc0>)
 800a220:	681b      	ldr	r3, [r3, #0]
 800a222:	2b00      	cmp	r3, #0
 800a224:	d10b      	bne.n	800a23e <HAL_SAI_MspInit+0x86>
      {
       __HAL_RCC_SAI2_CLK_ENABLE();
 800a226:	4b15      	ldr	r3, [pc, #84]	; (800a27c <HAL_SAI_MspInit+0xc4>)
 800a228:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a22a:	4a14      	ldr	r2, [pc, #80]	; (800a27c <HAL_SAI_MspInit+0xc4>)
 800a22c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800a230:	6453      	str	r3, [r2, #68]	; 0x44
 800a232:	4b12      	ldr	r3, [pc, #72]	; (800a27c <HAL_SAI_MspInit+0xc4>)
 800a234:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a236:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800a23a:	60fb      	str	r3, [r7, #12]
 800a23c:	68fb      	ldr	r3, [r7, #12]
      }
    SAI2_client ++;
 800a23e:	4b0e      	ldr	r3, [pc, #56]	; (800a278 <HAL_SAI_MspInit+0xc0>)
 800a240:	681b      	ldr	r3, [r3, #0]
 800a242:	3301      	adds	r3, #1
 800a244:	4a0c      	ldr	r2, [pc, #48]	; (800a278 <HAL_SAI_MspInit+0xc0>)
 800a246:	6013      	str	r3, [r2, #0]
    
    /**SAI2_B_Block_B GPIO Configuration    
    PG10     ------> SAI2_SD_B 
    */
    GPIO_InitStruct.Pin = SAI2_SDB_Pin;
 800a248:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800a24c:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a24e:	2302      	movs	r3, #2
 800a250:	61bb      	str	r3, [r7, #24]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a252:	2300      	movs	r3, #0
 800a254:	61fb      	str	r3, [r7, #28]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800a256:	2300      	movs	r3, #0
 800a258:	623b      	str	r3, [r7, #32]
    GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 800a25a:	230a      	movs	r3, #10
 800a25c:	627b      	str	r3, [r7, #36]	; 0x24
    HAL_GPIO_Init(SAI2_SDB_GPIO_Port, &GPIO_InitStruct);
 800a25e:	f107 0314 	add.w	r3, r7, #20
 800a262:	4619      	mov	r1, r3
 800a264:	4808      	ldr	r0, [pc, #32]	; (800a288 <HAL_SAI_MspInit+0xd0>)
 800a266:	f7f7 fc89 	bl	8001b7c <HAL_GPIO_Init>

    }
}
 800a26a:	bf00      	nop
 800a26c:	3728      	adds	r7, #40	; 0x28
 800a26e:	46bd      	mov	sp, r7
 800a270:	bd80      	pop	{r7, pc}
 800a272:	bf00      	nop
 800a274:	40015c04 	.word	0x40015c04
 800a278:	20000ccc 	.word	0x20000ccc
 800a27c:	40023800 	.word	0x40023800
 800a280:	40022000 	.word	0x40022000
 800a284:	40015c24 	.word	0x40015c24
 800a288:	40021800 	.word	0x40021800

0800a28c <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 800a28c:	b580      	push	{r7, lr}
 800a28e:	b08c      	sub	sp, #48	; 0x30
 800a290:	af00      	add	r7, sp, #0
 800a292:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
 800a294:	2300      	movs	r3, #0
 800a296:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              uwPrescalerValue = 0;
 800a298:	2300      	movs	r3, #0
 800a29a:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t              pFLatency;
  
  /*Configure the TIM6 IRQ priority */
  HAL_NVIC_SetPriority(TIM6_DAC_IRQn, TickPriority ,0); 
 800a29c:	2200      	movs	r2, #0
 800a29e:	6879      	ldr	r1, [r7, #4]
 800a2a0:	2036      	movs	r0, #54	; 0x36
 800a2a2:	f7f6 fd17 	bl	8000cd4 <HAL_NVIC_SetPriority>
  
  /* Enable the TIM6 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM6_DAC_IRQn); 
 800a2a6:	2036      	movs	r0, #54	; 0x36
 800a2a8:	f7f6 fd30 	bl	8000d0c <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM6 clock */
  __HAL_RCC_TIM6_CLK_ENABLE();
 800a2ac:	4b1f      	ldr	r3, [pc, #124]	; (800a32c <HAL_InitTick+0xa0>)
 800a2ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a2b0:	4a1e      	ldr	r2, [pc, #120]	; (800a32c <HAL_InitTick+0xa0>)
 800a2b2:	f043 0310 	orr.w	r3, r3, #16
 800a2b6:	6413      	str	r3, [r2, #64]	; 0x40
 800a2b8:	4b1c      	ldr	r3, [pc, #112]	; (800a32c <HAL_InitTick+0xa0>)
 800a2ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a2bc:	f003 0310 	and.w	r3, r3, #16
 800a2c0:	60fb      	str	r3, [r7, #12]
 800a2c2:	68fb      	ldr	r3, [r7, #12]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800a2c4:	f107 0210 	add.w	r2, r7, #16
 800a2c8:	f107 0314 	add.w	r3, r7, #20
 800a2cc:	4611      	mov	r1, r2
 800a2ce:	4618      	mov	r0, r3
 800a2d0:	f7fa fc96 	bl	8004c00 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM6 clock */
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 800a2d4:	f7fa fc6c 	bl	8004bb0 <HAL_RCC_GetPCLK1Freq>
 800a2d8:	4603      	mov	r3, r0
 800a2da:	005b      	lsls	r3, r3, #1
 800a2dc:	62fb      	str	r3, [r7, #44]	; 0x2c
   
  /* Compute the prescaler value to have TIM6 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800a2de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800a2e0:	4a13      	ldr	r2, [pc, #76]	; (800a330 <HAL_InitTick+0xa4>)
 800a2e2:	fba2 2303 	umull	r2, r3, r2, r3
 800a2e6:	0c9b      	lsrs	r3, r3, #18
 800a2e8:	3b01      	subs	r3, #1
 800a2ea:	62bb      	str	r3, [r7, #40]	; 0x28
  
  /* Initialize TIM6 */
  htim6.Instance = TIM6;
 800a2ec:	4b11      	ldr	r3, [pc, #68]	; (800a334 <HAL_InitTick+0xa8>)
 800a2ee:	4a12      	ldr	r2, [pc, #72]	; (800a338 <HAL_InitTick+0xac>)
 800a2f0:	601a      	str	r2, [r3, #0]
  + Period = [(TIM6CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim6.Init.Period = (1000000 / 1000) - 1;
 800a2f2:	4b10      	ldr	r3, [pc, #64]	; (800a334 <HAL_InitTick+0xa8>)
 800a2f4:	f240 32e7 	movw	r2, #999	; 0x3e7
 800a2f8:	60da      	str	r2, [r3, #12]
  htim6.Init.Prescaler = uwPrescalerValue;
 800a2fa:	4a0e      	ldr	r2, [pc, #56]	; (800a334 <HAL_InitTick+0xa8>)
 800a2fc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800a2fe:	6053      	str	r3, [r2, #4]
  htim6.Init.ClockDivision = 0;
 800a300:	4b0c      	ldr	r3, [pc, #48]	; (800a334 <HAL_InitTick+0xa8>)
 800a302:	2200      	movs	r2, #0
 800a304:	611a      	str	r2, [r3, #16]
  htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
 800a306:	4b0b      	ldr	r3, [pc, #44]	; (800a334 <HAL_InitTick+0xa8>)
 800a308:	2200      	movs	r2, #0
 800a30a:	609a      	str	r2, [r3, #8]
  if(HAL_TIM_Base_Init(&htim6) == HAL_OK)
 800a30c:	4809      	ldr	r0, [pc, #36]	; (800a334 <HAL_InitTick+0xa8>)
 800a30e:	f7fb ffb4 	bl	800627a <HAL_TIM_Base_Init>
 800a312:	4603      	mov	r3, r0
 800a314:	2b00      	cmp	r3, #0
 800a316:	d104      	bne.n	800a322 <HAL_InitTick+0x96>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim6);
 800a318:	4806      	ldr	r0, [pc, #24]	; (800a334 <HAL_InitTick+0xa8>)
 800a31a:	f7fb ffd9 	bl	80062d0 <HAL_TIM_Base_Start_IT>
 800a31e:	4603      	mov	r3, r0
 800a320:	e000      	b.n	800a324 <HAL_InitTick+0x98>
  }
  
  /* Return function status */
  return HAL_ERROR;
 800a322:	2301      	movs	r3, #1
}
 800a324:	4618      	mov	r0, r3
 800a326:	3730      	adds	r7, #48	; 0x30
 800a328:	46bd      	mov	sp, r7
 800a32a:	bd80      	pop	{r7, pc}
 800a32c:	40023800 	.word	0x40023800
 800a330:	431bde83 	.word	0x431bde83
 800a334:	2000dbb0 	.word	0x2000dbb0
 800a338:	40001000 	.word	0x40001000

0800a33c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 800a33c:	b480      	push	{r7}
 800a33e:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 800a340:	bf00      	nop
 800a342:	46bd      	mov	sp, r7
 800a344:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a348:	4770      	bx	lr

0800a34a <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 800a34a:	b480      	push	{r7}
 800a34c:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 800a34e:	e7fe      	b.n	800a34e <HardFault_Handler+0x4>

0800a350 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 800a350:	b480      	push	{r7}
 800a352:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 800a354:	e7fe      	b.n	800a354 <MemManage_Handler+0x4>

0800a356 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 800a356:	b480      	push	{r7}
 800a358:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 800a35a:	e7fe      	b.n	800a35a <BusFault_Handler+0x4>

0800a35c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 800a35c:	b480      	push	{r7}
 800a35e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 800a360:	e7fe      	b.n	800a360 <UsageFault_Handler+0x4>

0800a362 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 800a362:	b480      	push	{r7}
 800a364:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 800a366:	bf00      	nop
 800a368:	46bd      	mov	sp, r7
 800a36a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a36e:	4770      	bx	lr

0800a370 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 800a370:	b480      	push	{r7}
 800a372:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 800a374:	bf00      	nop
 800a376:	46bd      	mov	sp, r7
 800a378:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a37c:	4770      	bx	lr

0800a37e <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 800a37e:	b480      	push	{r7}
 800a380:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 800a382:	bf00      	nop
 800a384:	46bd      	mov	sp, r7
 800a386:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a38a:	4770      	bx	lr

0800a38c <TIM6_DAC_IRQHandler>:

/**
  * @brief This function handles TIM6 global interrupt, DAC1 and DAC2 underrun error interrupts.
  */
void TIM6_DAC_IRQHandler(void)
{
 800a38c:	b580      	push	{r7, lr}
 800a38e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM6_DAC_IRQn 0 */

  /* USER CODE END TIM6_DAC_IRQn 0 */
  HAL_TIM_IRQHandler(&htim6);
 800a390:	4802      	ldr	r0, [pc, #8]	; (800a39c <TIM6_DAC_IRQHandler+0x10>)
 800a392:	f7fb fff2 	bl	800637a <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM6_DAC_IRQn 1 */

  /* USER CODE END TIM6_DAC_IRQn 1 */
}
 800a396:	bf00      	nop
 800a398:	bd80      	pop	{r7, pc}
 800a39a:	bf00      	nop
 800a39c:	2000dbb0 	.word	0x2000dbb0

0800a3a0 <OTG_FS_IRQHandler>:

/**
  * @brief This function handles USB On The Go FS global interrupt.
  */
void OTG_FS_IRQHandler(void)
{
 800a3a0:	b580      	push	{r7, lr}
 800a3a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN OTG_FS_IRQn 0 */

  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 800a3a4:	4802      	ldr	r0, [pc, #8]	; (800a3b0 <OTG_FS_IRQHandler+0x10>)
 800a3a6:	f7f7 fe1d 	bl	8001fe4 <HAL_HCD_IRQHandler>
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 800a3aa:	bf00      	nop
 800a3ac:	bd80      	pop	{r7, pc}
 800a3ae:	bf00      	nop
 800a3b0:	2000d878 	.word	0x2000d878

0800a3b4 <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 800a3b4:	b480      	push	{r7}
 800a3b6:	af00      	add	r7, sp, #0
	return 1;
 800a3b8:	2301      	movs	r3, #1
}
 800a3ba:	4618      	mov	r0, r3
 800a3bc:	46bd      	mov	sp, r7
 800a3be:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3c2:	4770      	bx	lr

0800a3c4 <_kill>:

int _kill(int pid, int sig)
{
 800a3c4:	b580      	push	{r7, lr}
 800a3c6:	b082      	sub	sp, #8
 800a3c8:	af00      	add	r7, sp, #0
 800a3ca:	6078      	str	r0, [r7, #4]
 800a3cc:	6039      	str	r1, [r7, #0]
	errno = EINVAL;
 800a3ce:	f01c fecb 	bl	8027168 <__errno>
 800a3d2:	4602      	mov	r2, r0
 800a3d4:	2316      	movs	r3, #22
 800a3d6:	6013      	str	r3, [r2, #0]
	return -1;
 800a3d8:	f04f 33ff 	mov.w	r3, #4294967295
}
 800a3dc:	4618      	mov	r0, r3
 800a3de:	3708      	adds	r7, #8
 800a3e0:	46bd      	mov	sp, r7
 800a3e2:	bd80      	pop	{r7, pc}

0800a3e4 <_exit>:

void _exit (int status)
{
 800a3e4:	b580      	push	{r7, lr}
 800a3e6:	b082      	sub	sp, #8
 800a3e8:	af00      	add	r7, sp, #0
 800a3ea:	6078      	str	r0, [r7, #4]
	_kill(status, -1);
 800a3ec:	f04f 31ff 	mov.w	r1, #4294967295
 800a3f0:	6878      	ldr	r0, [r7, #4]
 800a3f2:	f7ff ffe7 	bl	800a3c4 <_kill>
	while (1) {}		/* Make sure we hang here */
 800a3f6:	e7fe      	b.n	800a3f6 <_exit+0x12>

0800a3f8 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 800a3f8:	b580      	push	{r7, lr}
 800a3fa:	b086      	sub	sp, #24
 800a3fc:	af00      	add	r7, sp, #0
 800a3fe:	60f8      	str	r0, [r7, #12]
 800a400:	60b9      	str	r1, [r7, #8]
 800a402:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a404:	2300      	movs	r3, #0
 800a406:	617b      	str	r3, [r7, #20]
 800a408:	e00a      	b.n	800a420 <_read+0x28>
	{
		*ptr++ = __io_getchar();
 800a40a:	f3af 8000 	nop.w
 800a40e:	4601      	mov	r1, r0
 800a410:	68bb      	ldr	r3, [r7, #8]
 800a412:	1c5a      	adds	r2, r3, #1
 800a414:	60ba      	str	r2, [r7, #8]
 800a416:	b2ca      	uxtb	r2, r1
 800a418:	701a      	strb	r2, [r3, #0]
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a41a:	697b      	ldr	r3, [r7, #20]
 800a41c:	3301      	adds	r3, #1
 800a41e:	617b      	str	r3, [r7, #20]
 800a420:	697a      	ldr	r2, [r7, #20]
 800a422:	687b      	ldr	r3, [r7, #4]
 800a424:	429a      	cmp	r2, r3
 800a426:	dbf0      	blt.n	800a40a <_read+0x12>
	}

return len;
 800a428:	687b      	ldr	r3, [r7, #4]
}
 800a42a:	4618      	mov	r0, r3
 800a42c:	3718      	adds	r7, #24
 800a42e:	46bd      	mov	sp, r7
 800a430:	bd80      	pop	{r7, pc}

0800a432 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800a432:	b580      	push	{r7, lr}
 800a434:	b086      	sub	sp, #24
 800a436:	af00      	add	r7, sp, #0
 800a438:	60f8      	str	r0, [r7, #12]
 800a43a:	60b9      	str	r1, [r7, #8]
 800a43c:	607a      	str	r2, [r7, #4]
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a43e:	2300      	movs	r3, #0
 800a440:	617b      	str	r3, [r7, #20]
 800a442:	e009      	b.n	800a458 <_write+0x26>
	{
		__io_putchar(*ptr++);
 800a444:	68bb      	ldr	r3, [r7, #8]
 800a446:	1c5a      	adds	r2, r3, #1
 800a448:	60ba      	str	r2, [r7, #8]
 800a44a:	781b      	ldrb	r3, [r3, #0]
 800a44c:	4618      	mov	r0, r3
 800a44e:	f3af 8000 	nop.w
	for (DataIdx = 0; DataIdx < len; DataIdx++)
 800a452:	697b      	ldr	r3, [r7, #20]
 800a454:	3301      	adds	r3, #1
 800a456:	617b      	str	r3, [r7, #20]
 800a458:	697a      	ldr	r2, [r7, #20]
 800a45a:	687b      	ldr	r3, [r7, #4]
 800a45c:	429a      	cmp	r2, r3
 800a45e:	dbf1      	blt.n	800a444 <_write+0x12>
	}
	return len;
 800a460:	687b      	ldr	r3, [r7, #4]
}
 800a462:	4618      	mov	r0, r3
 800a464:	3718      	adds	r7, #24
 800a466:	46bd      	mov	sp, r7
 800a468:	bd80      	pop	{r7, pc}

0800a46a <_close>:

int _close(int file)
{
 800a46a:	b480      	push	{r7}
 800a46c:	b083      	sub	sp, #12
 800a46e:	af00      	add	r7, sp, #0
 800a470:	6078      	str	r0, [r7, #4]
	return -1;
 800a472:	f04f 33ff 	mov.w	r3, #4294967295
}
 800a476:	4618      	mov	r0, r3
 800a478:	370c      	adds	r7, #12
 800a47a:	46bd      	mov	sp, r7
 800a47c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a480:	4770      	bx	lr

0800a482 <_fstat>:


int _fstat(int file, struct stat *st)
{
 800a482:	b480      	push	{r7}
 800a484:	b083      	sub	sp, #12
 800a486:	af00      	add	r7, sp, #0
 800a488:	6078      	str	r0, [r7, #4]
 800a48a:	6039      	str	r1, [r7, #0]
	st->st_mode = S_IFCHR;
 800a48c:	683b      	ldr	r3, [r7, #0]
 800a48e:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800a492:	605a      	str	r2, [r3, #4]
	return 0;
 800a494:	2300      	movs	r3, #0
}
 800a496:	4618      	mov	r0, r3
 800a498:	370c      	adds	r7, #12
 800a49a:	46bd      	mov	sp, r7
 800a49c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4a0:	4770      	bx	lr

0800a4a2 <_isatty>:

int _isatty(int file)
{
 800a4a2:	b480      	push	{r7}
 800a4a4:	b083      	sub	sp, #12
 800a4a6:	af00      	add	r7, sp, #0
 800a4a8:	6078      	str	r0, [r7, #4]
	return 1;
 800a4aa:	2301      	movs	r3, #1
}
 800a4ac:	4618      	mov	r0, r3
 800a4ae:	370c      	adds	r7, #12
 800a4b0:	46bd      	mov	sp, r7
 800a4b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4b6:	4770      	bx	lr

0800a4b8 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 800a4b8:	b480      	push	{r7}
 800a4ba:	b085      	sub	sp, #20
 800a4bc:	af00      	add	r7, sp, #0
 800a4be:	60f8      	str	r0, [r7, #12]
 800a4c0:	60b9      	str	r1, [r7, #8]
 800a4c2:	607a      	str	r2, [r7, #4]
	return 0;
 800a4c4:	2300      	movs	r3, #0
}
 800a4c6:	4618      	mov	r0, r3
 800a4c8:	3714      	adds	r7, #20
 800a4ca:	46bd      	mov	sp, r7
 800a4cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4d0:	4770      	bx	lr
	...

0800a4d4 <_sbrk>:
/**
 _sbrk
 Increase program data space. Malloc and related functions depend on this
**/
caddr_t _sbrk(int incr)
{
 800a4d4:	b580      	push	{r7, lr}
 800a4d6:	b084      	sub	sp, #16
 800a4d8:	af00      	add	r7, sp, #0
 800a4da:	6078      	str	r0, [r7, #4]
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800a4dc:	4b11      	ldr	r3, [pc, #68]	; (800a524 <_sbrk+0x50>)
 800a4de:	681b      	ldr	r3, [r3, #0]
 800a4e0:	2b00      	cmp	r3, #0
 800a4e2:	d102      	bne.n	800a4ea <_sbrk+0x16>
		heap_end = &end;
 800a4e4:	4b0f      	ldr	r3, [pc, #60]	; (800a524 <_sbrk+0x50>)
 800a4e6:	4a10      	ldr	r2, [pc, #64]	; (800a528 <_sbrk+0x54>)
 800a4e8:	601a      	str	r2, [r3, #0]

	prev_heap_end = heap_end;
 800a4ea:	4b0e      	ldr	r3, [pc, #56]	; (800a524 <_sbrk+0x50>)
 800a4ec:	681b      	ldr	r3, [r3, #0]
 800a4ee:	60fb      	str	r3, [r7, #12]
	if (heap_end + incr > stack_ptr)
 800a4f0:	4b0c      	ldr	r3, [pc, #48]	; (800a524 <_sbrk+0x50>)
 800a4f2:	681a      	ldr	r2, [r3, #0]
 800a4f4:	687b      	ldr	r3, [r7, #4]
 800a4f6:	4413      	add	r3, r2
 800a4f8:	466a      	mov	r2, sp
 800a4fa:	4293      	cmp	r3, r2
 800a4fc:	d907      	bls.n	800a50e <_sbrk+0x3a>
	{
		errno = ENOMEM;
 800a4fe:	f01c fe33 	bl	8027168 <__errno>
 800a502:	4602      	mov	r2, r0
 800a504:	230c      	movs	r3, #12
 800a506:	6013      	str	r3, [r2, #0]
		return (caddr_t) -1;
 800a508:	f04f 33ff 	mov.w	r3, #4294967295
 800a50c:	e006      	b.n	800a51c <_sbrk+0x48>
	}

	heap_end += incr;
 800a50e:	4b05      	ldr	r3, [pc, #20]	; (800a524 <_sbrk+0x50>)
 800a510:	681a      	ldr	r2, [r3, #0]
 800a512:	687b      	ldr	r3, [r7, #4]
 800a514:	4413      	add	r3, r2
 800a516:	4a03      	ldr	r2, [pc, #12]	; (800a524 <_sbrk+0x50>)
 800a518:	6013      	str	r3, [r2, #0]

	return (caddr_t) prev_heap_end;
 800a51a:	68fb      	ldr	r3, [r7, #12]
}
 800a51c:	4618      	mov	r0, r3
 800a51e:	3710      	adds	r7, #16
 800a520:	46bd      	mov	sp, r7
 800a522:	bd80      	pop	{r7, pc}
 800a524:	20000cd0 	.word	0x20000cd0
 800a528:	2000dfb8 	.word	0x2000dfb8

0800a52c <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 800a52c:	b480      	push	{r7}
 800a52e:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a530:	4b15      	ldr	r3, [pc, #84]	; (800a588 <SystemInit+0x5c>)
 800a532:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800a536:	4a14      	ldr	r2, [pc, #80]	; (800a588 <SystemInit+0x5c>)
 800a538:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800a53c:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800a540:	4b12      	ldr	r3, [pc, #72]	; (800a58c <SystemInit+0x60>)
 800a542:	681b      	ldr	r3, [r3, #0]
 800a544:	4a11      	ldr	r2, [pc, #68]	; (800a58c <SystemInit+0x60>)
 800a546:	f043 0301 	orr.w	r3, r3, #1
 800a54a:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800a54c:	4b0f      	ldr	r3, [pc, #60]	; (800a58c <SystemInit+0x60>)
 800a54e:	2200      	movs	r2, #0
 800a550:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 800a552:	4b0e      	ldr	r3, [pc, #56]	; (800a58c <SystemInit+0x60>)
 800a554:	681a      	ldr	r2, [r3, #0]
 800a556:	490d      	ldr	r1, [pc, #52]	; (800a58c <SystemInit+0x60>)
 800a558:	4b0d      	ldr	r3, [pc, #52]	; (800a590 <SystemInit+0x64>)
 800a55a:	4013      	ands	r3, r2
 800a55c:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 800a55e:	4b0b      	ldr	r3, [pc, #44]	; (800a58c <SystemInit+0x60>)
 800a560:	4a0c      	ldr	r2, [pc, #48]	; (800a594 <SystemInit+0x68>)
 800a562:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800a564:	4b09      	ldr	r3, [pc, #36]	; (800a58c <SystemInit+0x60>)
 800a566:	681b      	ldr	r3, [r3, #0]
 800a568:	4a08      	ldr	r2, [pc, #32]	; (800a58c <SystemInit+0x60>)
 800a56a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800a56e:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 800a570:	4b06      	ldr	r3, [pc, #24]	; (800a58c <SystemInit+0x60>)
 800a572:	2200      	movs	r2, #0
 800a574:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800a576:	4b04      	ldr	r3, [pc, #16]	; (800a588 <SystemInit+0x5c>)
 800a578:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800a57c:	609a      	str	r2, [r3, #8]
#endif
}
 800a57e:	bf00      	nop
 800a580:	46bd      	mov	sp, r7
 800a582:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a586:	4770      	bx	lr
 800a588:	e000ed00 	.word	0xe000ed00
 800a58c:	40023800 	.word	0x40023800
 800a590:	fef6ffff 	.word	0xfef6ffff
 800a594:	24003010 	.word	0x24003010

0800a598 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 800a598:	f8df d034 	ldr.w	sp, [pc, #52]	; 800a5d0 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 800a59c:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 800a59e:	e003      	b.n	800a5a8 <LoopCopyDataInit>

0800a5a0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 800a5a0:	4b0c      	ldr	r3, [pc, #48]	; (800a5d4 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 800a5a2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 800a5a4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 800a5a6:	3104      	adds	r1, #4

0800a5a8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800a5a8:	480b      	ldr	r0, [pc, #44]	; (800a5d8 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 800a5aa:	4b0c      	ldr	r3, [pc, #48]	; (800a5dc <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 800a5ac:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 800a5ae:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 800a5b0:	d3f6      	bcc.n	800a5a0 <CopyDataInit>
  ldr  r2, =_sbss
 800a5b2:	4a0b      	ldr	r2, [pc, #44]	; (800a5e0 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 800a5b4:	e002      	b.n	800a5bc <LoopFillZerobss>

0800a5b6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800a5b6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800a5b8:	f842 3b04 	str.w	r3, [r2], #4

0800a5bc <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 800a5bc:	4b09      	ldr	r3, [pc, #36]	; (800a5e4 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 800a5be:	429a      	cmp	r2, r3
  bcc  FillZerobss
 800a5c0:	d3f9      	bcc.n	800a5b6 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 800a5c2:	f7ff ffb3 	bl	800a52c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800a5c6:	f01c fdd5 	bl	8027174 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800a5ca:	f7fd ff3e 	bl	800844a <main>
  bx  lr    
 800a5ce:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 800a5d0:	20050000 	.word	0x20050000
  ldr  r3, =_sidata
 800a5d4:	0802b60c 	.word	0x0802b60c
  ldr  r0, =_sdata
 800a5d8:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800a5dc:	20000cac 	.word	0x20000cac
  ldr  r2, =_sbss
 800a5e0:	20000cac 	.word	0x20000cac
  ldr  r3, = _ebss
 800a5e4:	2000dfb4 	.word	0x2000dfb4

0800a5e8 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800a5e8:	e7fe      	b.n	800a5e8 <ADC_IRQHandler>

0800a5ea <ft5336_Init>:
  *         from MCU to FT5336 : ie I2C channel initialization (if required).
  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT5336).
  * @retval None
  */
void ft5336_Init(uint16_t DeviceAddr)
{
 800a5ea:	b580      	push	{r7, lr}
 800a5ec:	b082      	sub	sp, #8
 800a5ee:	af00      	add	r7, sp, #0
 800a5f0:	4603      	mov	r3, r0
 800a5f2:	80fb      	strh	r3, [r7, #6]
  /* Wait at least 200ms after power up before accessing registers
   * Trsi timing (Time of starting to report point after resetting) from FT5336GQQ datasheet */
  TS_IO_Delay(200);
 800a5f4:	20c8      	movs	r0, #200	; 0xc8
 800a5f6:	f000 fc49 	bl	800ae8c <TS_IO_Delay>

  /* Initialize I2C link if needed */
  ft5336_I2C_InitializeIfRequired();
 800a5fa:	f000 fa7b 	bl	800aaf4 <ft5336_I2C_InitializeIfRequired>
}
 800a5fe:	bf00      	nop
 800a600:	3708      	adds	r7, #8
 800a602:	46bd      	mov	sp, r7
 800a604:	bd80      	pop	{r7, pc}

0800a606 <ft5336_Reset>:
  *         @note : Not applicable to FT5336.
  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT5336).
  * @retval None
  */
void ft5336_Reset(uint16_t DeviceAddr)
{
 800a606:	b480      	push	{r7}
 800a608:	b083      	sub	sp, #12
 800a60a:	af00      	add	r7, sp, #0
 800a60c:	4603      	mov	r3, r0
 800a60e:	80fb      	strh	r3, [r7, #6]
  /* Do nothing */
  /* No software reset sequence available in FT5336 IC */
}
 800a610:	bf00      	nop
 800a612:	370c      	adds	r7, #12
 800a614:	46bd      	mov	sp, r7
 800a616:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a61a:	4770      	bx	lr

0800a61c <ft5336_ReadID>:
  *         able to read the FT5336 device ID, and verify this is a FT5336.
  * @param  DeviceAddr: I2C FT5336 Slave address.
  * @retval The Device ID (two bytes).
  */
uint16_t ft5336_ReadID(uint16_t DeviceAddr)
{
 800a61c:	b580      	push	{r7, lr}
 800a61e:	b084      	sub	sp, #16
 800a620:	af00      	add	r7, sp, #0
 800a622:	4603      	mov	r3, r0
 800a624:	80fb      	strh	r3, [r7, #6]
  volatile uint8_t ucReadId = 0;
 800a626:	2300      	movs	r3, #0
 800a628:	737b      	strb	r3, [r7, #13]
  uint8_t nbReadAttempts = 0;
 800a62a:	2300      	movs	r3, #0
 800a62c:	73fb      	strb	r3, [r7, #15]
  uint8_t bFoundDevice = 0; /* Device not found by default */
 800a62e:	2300      	movs	r3, #0
 800a630:	73bb      	strb	r3, [r7, #14]

  /* Initialize I2C link if needed */
  ft5336_I2C_InitializeIfRequired();
 800a632:	f000 fa5f 	bl	800aaf4 <ft5336_I2C_InitializeIfRequired>

  /* At maximum 4 attempts to read ID : exit at first finding of the searched device ID */
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 800a636:	2300      	movs	r3, #0
 800a638:	73fb      	strb	r3, [r7, #15]
 800a63a:	e010      	b.n	800a65e <ft5336_ReadID+0x42>
  {
    /* Read register FT5336_CHIP_ID_REG as DeviceID detection */
    ucReadId = TS_IO_Read(DeviceAddr, FT5336_CHIP_ID_REG);
 800a63c:	88fb      	ldrh	r3, [r7, #6]
 800a63e:	b2db      	uxtb	r3, r3
 800a640:	21a8      	movs	r1, #168	; 0xa8
 800a642:	4618      	mov	r0, r3
 800a644:	f000 fc04 	bl	800ae50 <TS_IO_Read>
 800a648:	4603      	mov	r3, r0
 800a64a:	737b      	strb	r3, [r7, #13]

    /* Found the searched device ID ? */
    if(ucReadId == FT5336_ID_VALUE)
 800a64c:	7b7b      	ldrb	r3, [r7, #13]
 800a64e:	b2db      	uxtb	r3, r3
 800a650:	2b51      	cmp	r3, #81	; 0x51
 800a652:	d101      	bne.n	800a658 <ft5336_ReadID+0x3c>
    {
      /* Set device as found */
      bFoundDevice = 1;
 800a654:	2301      	movs	r3, #1
 800a656:	73bb      	strb	r3, [r7, #14]
  for(nbReadAttempts = 0; ((nbReadAttempts < 3) && !(bFoundDevice)); nbReadAttempts++)
 800a658:	7bfb      	ldrb	r3, [r7, #15]
 800a65a:	3301      	adds	r3, #1
 800a65c:	73fb      	strb	r3, [r7, #15]
 800a65e:	7bfb      	ldrb	r3, [r7, #15]
 800a660:	2b02      	cmp	r3, #2
 800a662:	d802      	bhi.n	800a66a <ft5336_ReadID+0x4e>
 800a664:	7bbb      	ldrb	r3, [r7, #14]
 800a666:	2b00      	cmp	r3, #0
 800a668:	d0e8      	beq.n	800a63c <ft5336_ReadID+0x20>
    }
  }

  /* Return the device ID value */
  return (ucReadId);
 800a66a:	7b7b      	ldrb	r3, [r7, #13]
 800a66c:	b2db      	uxtb	r3, r3
 800a66e:	b29b      	uxth	r3, r3
}
 800a670:	4618      	mov	r0, r3
 800a672:	3710      	adds	r7, #16
 800a674:	46bd      	mov	sp, r7
 800a676:	bd80      	pop	{r7, pc}

0800a678 <ft5336_TS_Start>:
  * @brief  Configures the touch Screen IC device to start detecting touches
  * @param  DeviceAddr: Device address on communication Bus (I2C slave address).
  * @retval None.
  */
void ft5336_TS_Start(uint16_t DeviceAddr)
{
 800a678:	b580      	push	{r7, lr}
 800a67a:	b082      	sub	sp, #8
 800a67c:	af00      	add	r7, sp, #0
 800a67e:	4603      	mov	r3, r0
 800a680:	80fb      	strh	r3, [r7, #6]
  /* Minimum static configuration of FT5336 */
  FT5336_ASSERT(ft5336_TS_Configure(DeviceAddr));
 800a682:	88fb      	ldrh	r3, [r7, #6]
 800a684:	4618      	mov	r0, r3
 800a686:	f000 fa45 	bl	800ab14 <ft5336_TS_Configure>

  /* By default set FT5336 IC in Polling mode : no INT generation on FT5336 for new touch available */
  /* Note TS_INT is active low                                                                      */
  ft5336_TS_DisableIT(DeviceAddr);
 800a68a:	88fb      	ldrh	r3, [r7, #6]
 800a68c:	4618      	mov	r0, r3
 800a68e:	f000 f933 	bl	800a8f8 <ft5336_TS_DisableIT>
}
 800a692:	bf00      	nop
 800a694:	3708      	adds	r7, #8
 800a696:	46bd      	mov	sp, r7
 800a698:	bd80      	pop	{r7, pc}
	...

0800a69c <ft5336_TS_DetectTouch>:
  *         variables).
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval : Number of active touches detected (can be 0, 1 or 2).
  */
uint8_t ft5336_TS_DetectTouch(uint16_t DeviceAddr)
{
 800a69c:	b580      	push	{r7, lr}
 800a69e:	b084      	sub	sp, #16
 800a6a0:	af00      	add	r7, sp, #0
 800a6a2:	4603      	mov	r3, r0
 800a6a4:	80fb      	strh	r3, [r7, #6]
  volatile uint8_t nbTouch = 0;
 800a6a6:	2300      	movs	r3, #0
 800a6a8:	73fb      	strb	r3, [r7, #15]

  /* Read register FT5336_TD_STAT_REG to check number of touches detection */
  nbTouch = TS_IO_Read(DeviceAddr, FT5336_TD_STAT_REG);
 800a6aa:	88fb      	ldrh	r3, [r7, #6]
 800a6ac:	b2db      	uxtb	r3, r3
 800a6ae:	2102      	movs	r1, #2
 800a6b0:	4618      	mov	r0, r3
 800a6b2:	f000 fbcd 	bl	800ae50 <TS_IO_Read>
 800a6b6:	4603      	mov	r3, r0
 800a6b8:	73fb      	strb	r3, [r7, #15]
  nbTouch &= FT5336_TD_STAT_MASK;
 800a6ba:	7bfb      	ldrb	r3, [r7, #15]
 800a6bc:	b2db      	uxtb	r3, r3
 800a6be:	f003 030f 	and.w	r3, r3, #15
 800a6c2:	b2db      	uxtb	r3, r3
 800a6c4:	73fb      	strb	r3, [r7, #15]

  if(nbTouch > FT5336_MAX_DETECTABLE_TOUCH)
 800a6c6:	7bfb      	ldrb	r3, [r7, #15]
 800a6c8:	b2db      	uxtb	r3, r3
 800a6ca:	2b05      	cmp	r3, #5
 800a6cc:	d901      	bls.n	800a6d2 <ft5336_TS_DetectTouch+0x36>
  {
    /* If invalid number of touch detected, set it to zero */
    nbTouch = 0;
 800a6ce:	2300      	movs	r3, #0
 800a6d0:	73fb      	strb	r3, [r7, #15]
  }

  /* Update ft5336 driver internal global : current number of active touches */
  ft5336_handle.currActiveTouchNb = nbTouch;
 800a6d2:	7bfb      	ldrb	r3, [r7, #15]
 800a6d4:	b2da      	uxtb	r2, r3
 800a6d6:	4b05      	ldr	r3, [pc, #20]	; (800a6ec <ft5336_TS_DetectTouch+0x50>)
 800a6d8:	705a      	strb	r2, [r3, #1]

  /* Reset current active touch index on which to work on */
  ft5336_handle.currActiveTouchIdx = 0;
 800a6da:	4b04      	ldr	r3, [pc, #16]	; (800a6ec <ft5336_TS_DetectTouch+0x50>)
 800a6dc:	2200      	movs	r2, #0
 800a6de:	709a      	strb	r2, [r3, #2]

  return(nbTouch);
 800a6e0:	7bfb      	ldrb	r3, [r7, #15]
 800a6e2:	b2db      	uxtb	r3, r3
}
 800a6e4:	4618      	mov	r0, r3
 800a6e6:	3710      	adds	r7, #16
 800a6e8:	46bd      	mov	sp, r7
 800a6ea:	bd80      	pop	{r7, pc}
 800a6ec:	20000cd4 	.word	0x20000cd4

0800a6f0 <ft5336_TS_GetXY>:
  * @param  X: Pointer to X position value
  * @param  Y: Pointer to Y position value
  * @retval None.
  */
void ft5336_TS_GetXY(uint16_t DeviceAddr, uint16_t *X, uint16_t *Y)
{
 800a6f0:	b580      	push	{r7, lr}
 800a6f2:	b086      	sub	sp, #24
 800a6f4:	af00      	add	r7, sp, #0
 800a6f6:	4603      	mov	r3, r0
 800a6f8:	60b9      	str	r1, [r7, #8]
 800a6fa:	607a      	str	r2, [r7, #4]
 800a6fc:	81fb      	strh	r3, [r7, #14]
  volatile uint8_t ucReadData = 0;
 800a6fe:	2300      	movs	r3, #0
 800a700:	74fb      	strb	r3, [r7, #19]
  static uint16_t coord;
  uint8_t regAddressXLow = 0;
 800a702:	2300      	movs	r3, #0
 800a704:	75fb      	strb	r3, [r7, #23]
  uint8_t regAddressXHigh = 0;
 800a706:	2300      	movs	r3, #0
 800a708:	75bb      	strb	r3, [r7, #22]
  uint8_t regAddressYLow = 0;
 800a70a:	2300      	movs	r3, #0
 800a70c:	757b      	strb	r3, [r7, #21]
  uint8_t regAddressYHigh = 0;
 800a70e:	2300      	movs	r3, #0
 800a710:	753b      	strb	r3, [r7, #20]

  if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb)
 800a712:	4b6d      	ldr	r3, [pc, #436]	; (800a8c8 <ft5336_TS_GetXY+0x1d8>)
 800a714:	789a      	ldrb	r2, [r3, #2]
 800a716:	4b6c      	ldr	r3, [pc, #432]	; (800a8c8 <ft5336_TS_GetXY+0x1d8>)
 800a718:	785b      	ldrb	r3, [r3, #1]
 800a71a:	429a      	cmp	r2, r3
 800a71c:	f080 80cf 	bcs.w	800a8be <ft5336_TS_GetXY+0x1ce>
  {
    switch(ft5336_handle.currActiveTouchIdx)
 800a720:	4b69      	ldr	r3, [pc, #420]	; (800a8c8 <ft5336_TS_GetXY+0x1d8>)
 800a722:	789b      	ldrb	r3, [r3, #2]
 800a724:	2b09      	cmp	r3, #9
 800a726:	d871      	bhi.n	800a80c <ft5336_TS_GetXY+0x11c>
 800a728:	a201      	add	r2, pc, #4	; (adr r2, 800a730 <ft5336_TS_GetXY+0x40>)
 800a72a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a72e:	bf00      	nop
 800a730:	0800a759 	.word	0x0800a759
 800a734:	0800a76b 	.word	0x0800a76b
 800a738:	0800a77d 	.word	0x0800a77d
 800a73c:	0800a78f 	.word	0x0800a78f
 800a740:	0800a7a1 	.word	0x0800a7a1
 800a744:	0800a7b3 	.word	0x0800a7b3
 800a748:	0800a7c5 	.word	0x0800a7c5
 800a74c:	0800a7d7 	.word	0x0800a7d7
 800a750:	0800a7e9 	.word	0x0800a7e9
 800a754:	0800a7fb 	.word	0x0800a7fb
    {
    case 0 :
      regAddressXLow  = FT5336_P1_XL_REG;
 800a758:	2304      	movs	r3, #4
 800a75a:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P1_XH_REG;
 800a75c:	2303      	movs	r3, #3
 800a75e:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P1_YL_REG;
 800a760:	2306      	movs	r3, #6
 800a762:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P1_YH_REG;
 800a764:	2305      	movs	r3, #5
 800a766:	753b      	strb	r3, [r7, #20]
      break;
 800a768:	e051      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 1 :
      regAddressXLow  = FT5336_P2_XL_REG;
 800a76a:	230a      	movs	r3, #10
 800a76c:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P2_XH_REG;
 800a76e:	2309      	movs	r3, #9
 800a770:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P2_YL_REG;
 800a772:	230c      	movs	r3, #12
 800a774:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P2_YH_REG;
 800a776:	230b      	movs	r3, #11
 800a778:	753b      	strb	r3, [r7, #20]
      break;
 800a77a:	e048      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 2 :
      regAddressXLow  = FT5336_P3_XL_REG;
 800a77c:	2310      	movs	r3, #16
 800a77e:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P3_XH_REG;
 800a780:	230f      	movs	r3, #15
 800a782:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P3_YL_REG;
 800a784:	2312      	movs	r3, #18
 800a786:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P3_YH_REG;
 800a788:	2311      	movs	r3, #17
 800a78a:	753b      	strb	r3, [r7, #20]
      break;
 800a78c:	e03f      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 3 :
      regAddressXLow  = FT5336_P4_XL_REG;
 800a78e:	2316      	movs	r3, #22
 800a790:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P4_XH_REG;
 800a792:	2315      	movs	r3, #21
 800a794:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P4_YL_REG;
 800a796:	2318      	movs	r3, #24
 800a798:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P4_YH_REG;
 800a79a:	2317      	movs	r3, #23
 800a79c:	753b      	strb	r3, [r7, #20]
      break;
 800a79e:	e036      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 4 :
      regAddressXLow  = FT5336_P5_XL_REG;
 800a7a0:	231c      	movs	r3, #28
 800a7a2:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P5_XH_REG;
 800a7a4:	231b      	movs	r3, #27
 800a7a6:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P5_YL_REG;
 800a7a8:	231e      	movs	r3, #30
 800a7aa:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P5_YH_REG;
 800a7ac:	231d      	movs	r3, #29
 800a7ae:	753b      	strb	r3, [r7, #20]
      break;
 800a7b0:	e02d      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 5 :
      regAddressXLow  = FT5336_P6_XL_REG;
 800a7b2:	2322      	movs	r3, #34	; 0x22
 800a7b4:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P6_XH_REG;
 800a7b6:	2321      	movs	r3, #33	; 0x21
 800a7b8:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P6_YL_REG;
 800a7ba:	2324      	movs	r3, #36	; 0x24
 800a7bc:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P6_YH_REG;
 800a7be:	2323      	movs	r3, #35	; 0x23
 800a7c0:	753b      	strb	r3, [r7, #20]
      break;
 800a7c2:	e024      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 6 :
      regAddressXLow  = FT5336_P7_XL_REG;
 800a7c4:	2328      	movs	r3, #40	; 0x28
 800a7c6:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P7_XH_REG;
 800a7c8:	2327      	movs	r3, #39	; 0x27
 800a7ca:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P7_YL_REG;
 800a7cc:	232a      	movs	r3, #42	; 0x2a
 800a7ce:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P7_YH_REG;
 800a7d0:	2329      	movs	r3, #41	; 0x29
 800a7d2:	753b      	strb	r3, [r7, #20]
      break;
 800a7d4:	e01b      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 7 :
      regAddressXLow  = FT5336_P8_XL_REG;
 800a7d6:	232e      	movs	r3, #46	; 0x2e
 800a7d8:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P8_XH_REG;
 800a7da:	232d      	movs	r3, #45	; 0x2d
 800a7dc:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P8_YL_REG;
 800a7de:	2330      	movs	r3, #48	; 0x30
 800a7e0:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P8_YH_REG;
 800a7e2:	232f      	movs	r3, #47	; 0x2f
 800a7e4:	753b      	strb	r3, [r7, #20]
      break;
 800a7e6:	e012      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 8 :
      regAddressXLow  = FT5336_P9_XL_REG;
 800a7e8:	2334      	movs	r3, #52	; 0x34
 800a7ea:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P9_XH_REG;
 800a7ec:	2333      	movs	r3, #51	; 0x33
 800a7ee:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P9_YL_REG;
 800a7f0:	2336      	movs	r3, #54	; 0x36
 800a7f2:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P9_YH_REG;
 800a7f4:	2335      	movs	r3, #53	; 0x35
 800a7f6:	753b      	strb	r3, [r7, #20]
      break;
 800a7f8:	e009      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    case 9 :
      regAddressXLow  = FT5336_P10_XL_REG;
 800a7fa:	233a      	movs	r3, #58	; 0x3a
 800a7fc:	75fb      	strb	r3, [r7, #23]
      regAddressXHigh = FT5336_P10_XH_REG;
 800a7fe:	2339      	movs	r3, #57	; 0x39
 800a800:	75bb      	strb	r3, [r7, #22]
      regAddressYLow  = FT5336_P10_YL_REG;
 800a802:	233c      	movs	r3, #60	; 0x3c
 800a804:	757b      	strb	r3, [r7, #21]
      regAddressYHigh = FT5336_P10_YH_REG;
 800a806:	233b      	movs	r3, #59	; 0x3b
 800a808:	753b      	strb	r3, [r7, #20]
      break;
 800a80a:	e000      	b.n	800a80e <ft5336_TS_GetXY+0x11e>

    default :
      break;
 800a80c:	bf00      	nop

    } /* end switch(ft5336_handle.currActiveTouchIdx) */

    /* Read low part of X position */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXLow);
 800a80e:	89fb      	ldrh	r3, [r7, #14]
 800a810:	b2db      	uxtb	r3, r3
 800a812:	7dfa      	ldrb	r2, [r7, #23]
 800a814:	4611      	mov	r1, r2
 800a816:	4618      	mov	r0, r3
 800a818:	f000 fb1a 	bl	800ae50 <TS_IO_Read>
 800a81c:	4603      	mov	r3, r0
 800a81e:	74fb      	strb	r3, [r7, #19]
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 800a820:	7cfb      	ldrb	r3, [r7, #19]
 800a822:	b2db      	uxtb	r3, r3
 800a824:	b29a      	uxth	r2, r3
 800a826:	4b29      	ldr	r3, [pc, #164]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a828:	801a      	strh	r2, [r3, #0]

    /* Read high part of X position */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 800a82a:	89fb      	ldrh	r3, [r7, #14]
 800a82c:	b2db      	uxtb	r3, r3
 800a82e:	7dba      	ldrb	r2, [r7, #22]
 800a830:	4611      	mov	r1, r2
 800a832:	4618      	mov	r0, r3
 800a834:	f000 fb0c 	bl	800ae50 <TS_IO_Read>
 800a838:	4603      	mov	r3, r0
 800a83a:	74fb      	strb	r3, [r7, #19]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 800a83c:	7cfb      	ldrb	r3, [r7, #19]
 800a83e:	b2db      	uxtb	r3, r3
 800a840:	021b      	lsls	r3, r3, #8
 800a842:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800a846:	b21a      	sxth	r2, r3
 800a848:	4b20      	ldr	r3, [pc, #128]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a84a:	881b      	ldrh	r3, [r3, #0]
 800a84c:	b21b      	sxth	r3, r3
 800a84e:	4313      	orrs	r3, r2
 800a850:	b21b      	sxth	r3, r3
 800a852:	b29a      	uxth	r2, r3
 800a854:	4b1d      	ldr	r3, [pc, #116]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a856:	801a      	strh	r2, [r3, #0]

    /* Send back ready X position to caller */
    *X = coord;
 800a858:	4b1c      	ldr	r3, [pc, #112]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a85a:	881a      	ldrh	r2, [r3, #0]
 800a85c:	68bb      	ldr	r3, [r7, #8]
 800a85e:	801a      	strh	r2, [r3, #0]

    /* Read low part of Y position */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYLow);
 800a860:	89fb      	ldrh	r3, [r7, #14]
 800a862:	b2db      	uxtb	r3, r3
 800a864:	7d7a      	ldrb	r2, [r7, #21]
 800a866:	4611      	mov	r1, r2
 800a868:	4618      	mov	r0, r3
 800a86a:	f000 faf1 	bl	800ae50 <TS_IO_Read>
 800a86e:	4603      	mov	r3, r0
 800a870:	74fb      	strb	r3, [r7, #19]
    coord = (ucReadData & FT5336_TOUCH_POS_LSB_MASK) >> FT5336_TOUCH_POS_LSB_SHIFT;
 800a872:	7cfb      	ldrb	r3, [r7, #19]
 800a874:	b2db      	uxtb	r3, r3
 800a876:	b29a      	uxth	r2, r3
 800a878:	4b14      	ldr	r3, [pc, #80]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a87a:	801a      	strh	r2, [r3, #0]

    /* Read high part of Y position */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressYHigh);
 800a87c:	89fb      	ldrh	r3, [r7, #14]
 800a87e:	b2db      	uxtb	r3, r3
 800a880:	7d3a      	ldrb	r2, [r7, #20]
 800a882:	4611      	mov	r1, r2
 800a884:	4618      	mov	r0, r3
 800a886:	f000 fae3 	bl	800ae50 <TS_IO_Read>
 800a88a:	4603      	mov	r3, r0
 800a88c:	74fb      	strb	r3, [r7, #19]
    coord |= ((ucReadData & FT5336_TOUCH_POS_MSB_MASK) >> FT5336_TOUCH_POS_MSB_SHIFT) << 8;
 800a88e:	7cfb      	ldrb	r3, [r7, #19]
 800a890:	b2db      	uxtb	r3, r3
 800a892:	021b      	lsls	r3, r3, #8
 800a894:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800a898:	b21a      	sxth	r2, r3
 800a89a:	4b0c      	ldr	r3, [pc, #48]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a89c:	881b      	ldrh	r3, [r3, #0]
 800a89e:	b21b      	sxth	r3, r3
 800a8a0:	4313      	orrs	r3, r2
 800a8a2:	b21b      	sxth	r3, r3
 800a8a4:	b29a      	uxth	r2, r3
 800a8a6:	4b09      	ldr	r3, [pc, #36]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a8a8:	801a      	strh	r2, [r3, #0]

    /* Send back ready Y position to caller */
    *Y = coord;
 800a8aa:	4b08      	ldr	r3, [pc, #32]	; (800a8cc <ft5336_TS_GetXY+0x1dc>)
 800a8ac:	881a      	ldrh	r2, [r3, #0]
 800a8ae:	687b      	ldr	r3, [r7, #4]
 800a8b0:	801a      	strh	r2, [r3, #0]

    ft5336_handle.currActiveTouchIdx++; /* next call will work on next touch */
 800a8b2:	4b05      	ldr	r3, [pc, #20]	; (800a8c8 <ft5336_TS_GetXY+0x1d8>)
 800a8b4:	789b      	ldrb	r3, [r3, #2]
 800a8b6:	3301      	adds	r3, #1
 800a8b8:	b2da      	uxtb	r2, r3
 800a8ba:	4b03      	ldr	r3, [pc, #12]	; (800a8c8 <ft5336_TS_GetXY+0x1d8>)
 800a8bc:	709a      	strb	r2, [r3, #2]

  } /* of if(ft5336_handle.currActiveTouchIdx < ft5336_handle.currActiveTouchNb) */
}
 800a8be:	bf00      	nop
 800a8c0:	3718      	adds	r7, #24
 800a8c2:	46bd      	mov	sp, r7
 800a8c4:	bd80      	pop	{r7, pc}
 800a8c6:	bf00      	nop
 800a8c8:	20000cd4 	.word	0x20000cd4
 800a8cc:	20000cd8 	.word	0x20000cd8

0800a8d0 <ft5336_TS_EnableIT>:
  *         connected to MCU as EXTI.
  * @param  DeviceAddr: Device address on communication Bus (Slave I2C address of FT5336).
  * @retval None
  */
void ft5336_TS_EnableIT(uint16_t DeviceAddr)
{
 800a8d0:	b580      	push	{r7, lr}
 800a8d2:	b084      	sub	sp, #16
 800a8d4:	af00      	add	r7, sp, #0
 800a8d6:	4603      	mov	r3, r0
 800a8d8:	80fb      	strh	r3, [r7, #6]
   uint8_t regValue = 0;
 800a8da:	2300      	movs	r3, #0
 800a8dc:	73fb      	strb	r3, [r7, #15]
   regValue = (FT5336_G_MODE_INTERRUPT_TRIGGER & (FT5336_G_MODE_INTERRUPT_MASK >> FT5336_G_MODE_INTERRUPT_SHIFT)) << FT5336_G_MODE_INTERRUPT_SHIFT;
 800a8de:	2301      	movs	r3, #1
 800a8e0:	73fb      	strb	r3, [r7, #15]

   /* Set interrupt trigger mode in FT5336_GMODE_REG */
   TS_IO_Write(DeviceAddr, FT5336_GMODE_REG, regValue);
 800a8e2:	88fb      	ldrh	r3, [r7, #6]
 800a8e4:	b2db      	uxtb	r3, r3
 800a8e6:	7bfa      	ldrb	r2, [r7, #15]
 800a8e8:	21a4      	movs	r1, #164	; 0xa4
 800a8ea:	4618      	mov	r0, r3
 800a8ec:	f000 fa96 	bl	800ae1c <TS_IO_Write>
}
 800a8f0:	bf00      	nop
 800a8f2:	3710      	adds	r7, #16
 800a8f4:	46bd      	mov	sp, r7
 800a8f6:	bd80      	pop	{r7, pc}

0800a8f8 <ft5336_TS_DisableIT>:
  *         connected to MCU as EXTI.
  * @param  DeviceAddr: Device address on communication Bus (Slave I2C address of FT5336).
  * @retval None
  */
void ft5336_TS_DisableIT(uint16_t DeviceAddr)
{
 800a8f8:	b580      	push	{r7, lr}
 800a8fa:	b084      	sub	sp, #16
 800a8fc:	af00      	add	r7, sp, #0
 800a8fe:	4603      	mov	r3, r0
 800a900:	80fb      	strh	r3, [r7, #6]
  uint8_t regValue = 0;
 800a902:	2300      	movs	r3, #0
 800a904:	73fb      	strb	r3, [r7, #15]
  regValue = (FT5336_G_MODE_INTERRUPT_POLLING & (FT5336_G_MODE_INTERRUPT_MASK >> FT5336_G_MODE_INTERRUPT_SHIFT)) << FT5336_G_MODE_INTERRUPT_SHIFT;
 800a906:	2300      	movs	r3, #0
 800a908:	73fb      	strb	r3, [r7, #15]

  /* Set interrupt polling mode in FT5336_GMODE_REG */
  TS_IO_Write(DeviceAddr, FT5336_GMODE_REG, regValue);
 800a90a:	88fb      	ldrh	r3, [r7, #6]
 800a90c:	b2db      	uxtb	r3, r3
 800a90e:	7bfa      	ldrb	r2, [r7, #15]
 800a910:	21a4      	movs	r1, #164	; 0xa4
 800a912:	4618      	mov	r0, r3
 800a914:	f000 fa82 	bl	800ae1c <TS_IO_Write>
}
 800a918:	bf00      	nop
 800a91a:	3710      	adds	r7, #16
 800a91c:	46bd      	mov	sp, r7
 800a91e:	bd80      	pop	{r7, pc}

0800a920 <ft5336_TS_ITStatus>:
  *         @note : This feature is not applicable to FT5336.
  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT5336).
  * @retval TS interrupts status : always return 0 here
  */
uint8_t ft5336_TS_ITStatus(uint16_t DeviceAddr)
{
 800a920:	b480      	push	{r7}
 800a922:	b083      	sub	sp, #12
 800a924:	af00      	add	r7, sp, #0
 800a926:	4603      	mov	r3, r0
 800a928:	80fb      	strh	r3, [r7, #6]
  /* Always return 0 as feature not applicable to FT5336 */
  return 0;
 800a92a:	2300      	movs	r3, #0
}
 800a92c:	4618      	mov	r0, r3
 800a92e:	370c      	adds	r7, #12
 800a930:	46bd      	mov	sp, r7
 800a932:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a936:	4770      	bx	lr

0800a938 <ft5336_TS_ClearIT>:
  *         @note : This feature is not applicable to FT5336.
  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT5336).
  * @retval None
  */
void ft5336_TS_ClearIT(uint16_t DeviceAddr)
{
 800a938:	b480      	push	{r7}
 800a93a:	b083      	sub	sp, #12
 800a93c:	af00      	add	r7, sp, #0
 800a93e:	4603      	mov	r3, r0
 800a940:	80fb      	strh	r3, [r7, #6]
  /* Nothing to be done here for FT5336 */
}
 800a942:	bf00      	nop
 800a944:	370c      	adds	r7, #12
 800a946:	46bd      	mov	sp, r7
 800a948:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a94c:	4770      	bx	lr

0800a94e <ft5336_TS_GetGestureID>:
  * @param  DeviceAddr: Device address on communication Bus (I2C slave address of FT5336).
  * @param  pGestureId : Pointer to get last touch gesture Identification.
  * @retval None.
  */
void ft5336_TS_GetGestureID(uint16_t DeviceAddr, uint32_t * pGestureId)
{
 800a94e:	b580      	push	{r7, lr}
 800a950:	b084      	sub	sp, #16
 800a952:	af00      	add	r7, sp, #0
 800a954:	4603      	mov	r3, r0
 800a956:	6039      	str	r1, [r7, #0]
 800a958:	80fb      	strh	r3, [r7, #6]
  volatile uint8_t ucReadData = 0;
 800a95a:	2300      	movs	r3, #0
 800a95c:	73fb      	strb	r3, [r7, #15]

  ucReadData = TS_IO_Read(DeviceAddr, FT5336_GEST_ID_REG);
 800a95e:	88fb      	ldrh	r3, [r7, #6]
 800a960:	b2db      	uxtb	r3, r3
 800a962:	2101      	movs	r1, #1
 800a964:	4618      	mov	r0, r3
 800a966:	f000 fa73 	bl	800ae50 <TS_IO_Read>
 800a96a:	4603      	mov	r3, r0
 800a96c:	73fb      	strb	r3, [r7, #15]

  * pGestureId = ucReadData;
 800a96e:	7bfb      	ldrb	r3, [r7, #15]
 800a970:	b2db      	uxtb	r3, r3
 800a972:	461a      	mov	r2, r3
 800a974:	683b      	ldr	r3, [r7, #0]
 800a976:	601a      	str	r2, [r3, #0]
}
 800a978:	bf00      	nop
 800a97a:	3710      	adds	r7, #16
 800a97c:	46bd      	mov	sp, r7
 800a97e:	bd80      	pop	{r7, pc}

0800a980 <ft5336_TS_GetTouchInfo>:
void ft5336_TS_GetTouchInfo(uint16_t   DeviceAddr,
                            uint32_t   touchIdx,
                            uint32_t * pWeight,
                            uint32_t * pArea,
                            uint32_t * pEvent)
{
 800a980:	b580      	push	{r7, lr}
 800a982:	b086      	sub	sp, #24
 800a984:	af00      	add	r7, sp, #0
 800a986:	60b9      	str	r1, [r7, #8]
 800a988:	607a      	str	r2, [r7, #4]
 800a98a:	603b      	str	r3, [r7, #0]
 800a98c:	4603      	mov	r3, r0
 800a98e:	81fb      	strh	r3, [r7, #14]
  volatile uint8_t ucReadData = 0;
 800a990:	2300      	movs	r3, #0
 800a992:	753b      	strb	r3, [r7, #20]
  uint8_t regAddressXHigh = 0;
 800a994:	2300      	movs	r3, #0
 800a996:	75fb      	strb	r3, [r7, #23]
  uint8_t regAddressPWeight = 0;
 800a998:	2300      	movs	r3, #0
 800a99a:	75bb      	strb	r3, [r7, #22]
  uint8_t regAddressPMisc = 0;
 800a99c:	2300      	movs	r3, #0
 800a99e:	757b      	strb	r3, [r7, #21]

  if(touchIdx < ft5336_handle.currActiveTouchNb)
 800a9a0:	4b4d      	ldr	r3, [pc, #308]	; (800aad8 <ft5336_TS_GetTouchInfo+0x158>)
 800a9a2:	785b      	ldrb	r3, [r3, #1]
 800a9a4:	461a      	mov	r2, r3
 800a9a6:	68bb      	ldr	r3, [r7, #8]
 800a9a8:	4293      	cmp	r3, r2
 800a9aa:	f080 8090 	bcs.w	800aace <ft5336_TS_GetTouchInfo+0x14e>
  {
    switch(touchIdx)
 800a9ae:	68bb      	ldr	r3, [r7, #8]
 800a9b0:	2b09      	cmp	r3, #9
 800a9b2:	d85d      	bhi.n	800aa70 <ft5336_TS_GetTouchInfo+0xf0>
 800a9b4:	a201      	add	r2, pc, #4	; (adr r2, 800a9bc <ft5336_TS_GetTouchInfo+0x3c>)
 800a9b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a9ba:	bf00      	nop
 800a9bc:	0800a9e5 	.word	0x0800a9e5
 800a9c0:	0800a9f3 	.word	0x0800a9f3
 800a9c4:	0800aa01 	.word	0x0800aa01
 800a9c8:	0800aa0f 	.word	0x0800aa0f
 800a9cc:	0800aa1d 	.word	0x0800aa1d
 800a9d0:	0800aa2b 	.word	0x0800aa2b
 800a9d4:	0800aa39 	.word	0x0800aa39
 800a9d8:	0800aa47 	.word	0x0800aa47
 800a9dc:	0800aa55 	.word	0x0800aa55
 800a9e0:	0800aa63 	.word	0x0800aa63
    {
    case 0 :
      regAddressXHigh   = FT5336_P1_XH_REG;
 800a9e4:	2303      	movs	r3, #3
 800a9e6:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P1_WEIGHT_REG;
 800a9e8:	2307      	movs	r3, #7
 800a9ea:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P1_MISC_REG;
 800a9ec:	2308      	movs	r3, #8
 800a9ee:	757b      	strb	r3, [r7, #21]
      break;
 800a9f0:	e03f      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 1 :
      regAddressXHigh   = FT5336_P2_XH_REG;
 800a9f2:	2309      	movs	r3, #9
 800a9f4:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P2_WEIGHT_REG;
 800a9f6:	230d      	movs	r3, #13
 800a9f8:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P2_MISC_REG;
 800a9fa:	230e      	movs	r3, #14
 800a9fc:	757b      	strb	r3, [r7, #21]
      break;
 800a9fe:	e038      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 2 :
      regAddressXHigh   = FT5336_P3_XH_REG;
 800aa00:	230f      	movs	r3, #15
 800aa02:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P3_WEIGHT_REG;
 800aa04:	2313      	movs	r3, #19
 800aa06:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P3_MISC_REG;
 800aa08:	2314      	movs	r3, #20
 800aa0a:	757b      	strb	r3, [r7, #21]
      break;
 800aa0c:	e031      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 3 :
      regAddressXHigh   = FT5336_P4_XH_REG;
 800aa0e:	2315      	movs	r3, #21
 800aa10:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P4_WEIGHT_REG;
 800aa12:	2319      	movs	r3, #25
 800aa14:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P4_MISC_REG;
 800aa16:	231a      	movs	r3, #26
 800aa18:	757b      	strb	r3, [r7, #21]
      break;
 800aa1a:	e02a      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 4 :
      regAddressXHigh   = FT5336_P5_XH_REG;
 800aa1c:	231b      	movs	r3, #27
 800aa1e:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P5_WEIGHT_REG;
 800aa20:	231f      	movs	r3, #31
 800aa22:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P5_MISC_REG;
 800aa24:	2320      	movs	r3, #32
 800aa26:	757b      	strb	r3, [r7, #21]
      break;
 800aa28:	e023      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 5 :
      regAddressXHigh   = FT5336_P6_XH_REG;
 800aa2a:	2321      	movs	r3, #33	; 0x21
 800aa2c:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P6_WEIGHT_REG;
 800aa2e:	2325      	movs	r3, #37	; 0x25
 800aa30:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P6_MISC_REG;
 800aa32:	2326      	movs	r3, #38	; 0x26
 800aa34:	757b      	strb	r3, [r7, #21]
      break;
 800aa36:	e01c      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 6 :
      regAddressXHigh   = FT5336_P7_XH_REG;
 800aa38:	2327      	movs	r3, #39	; 0x27
 800aa3a:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P7_WEIGHT_REG;
 800aa3c:	232b      	movs	r3, #43	; 0x2b
 800aa3e:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P7_MISC_REG;
 800aa40:	232c      	movs	r3, #44	; 0x2c
 800aa42:	757b      	strb	r3, [r7, #21]
      break;
 800aa44:	e015      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 7 :
      regAddressXHigh   = FT5336_P8_XH_REG;
 800aa46:	232d      	movs	r3, #45	; 0x2d
 800aa48:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P8_WEIGHT_REG;
 800aa4a:	2331      	movs	r3, #49	; 0x31
 800aa4c:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P8_MISC_REG;
 800aa4e:	2332      	movs	r3, #50	; 0x32
 800aa50:	757b      	strb	r3, [r7, #21]
      break;
 800aa52:	e00e      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 8 :
      regAddressXHigh   = FT5336_P9_XH_REG;
 800aa54:	2333      	movs	r3, #51	; 0x33
 800aa56:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P9_WEIGHT_REG;
 800aa58:	2337      	movs	r3, #55	; 0x37
 800aa5a:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P9_MISC_REG;
 800aa5c:	2338      	movs	r3, #56	; 0x38
 800aa5e:	757b      	strb	r3, [r7, #21]
      break;
 800aa60:	e007      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    case 9 :
      regAddressXHigh   = FT5336_P10_XH_REG;
 800aa62:	2339      	movs	r3, #57	; 0x39
 800aa64:	75fb      	strb	r3, [r7, #23]
      regAddressPWeight = FT5336_P10_WEIGHT_REG;
 800aa66:	233d      	movs	r3, #61	; 0x3d
 800aa68:	75bb      	strb	r3, [r7, #22]
      regAddressPMisc   = FT5336_P10_MISC_REG;
 800aa6a:	233e      	movs	r3, #62	; 0x3e
 800aa6c:	757b      	strb	r3, [r7, #21]
      break;
 800aa6e:	e000      	b.n	800aa72 <ft5336_TS_GetTouchInfo+0xf2>

    default :
      break;
 800aa70:	bf00      	nop

    } /* end switch(touchIdx) */

    /* Read Event Id of touch index */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressXHigh);
 800aa72:	89fb      	ldrh	r3, [r7, #14]
 800aa74:	b2db      	uxtb	r3, r3
 800aa76:	7dfa      	ldrb	r2, [r7, #23]
 800aa78:	4611      	mov	r1, r2
 800aa7a:	4618      	mov	r0, r3
 800aa7c:	f000 f9e8 	bl	800ae50 <TS_IO_Read>
 800aa80:	4603      	mov	r3, r0
 800aa82:	753b      	strb	r3, [r7, #20]
    * pEvent = (ucReadData & FT5336_TOUCH_EVT_FLAG_MASK) >> FT5336_TOUCH_EVT_FLAG_SHIFT;
 800aa84:	7d3b      	ldrb	r3, [r7, #20]
 800aa86:	b2db      	uxtb	r3, r3
 800aa88:	119b      	asrs	r3, r3, #6
 800aa8a:	f003 0203 	and.w	r2, r3, #3
 800aa8e:	6a3b      	ldr	r3, [r7, #32]
 800aa90:	601a      	str	r2, [r3, #0]

    /* Read weight of touch index */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPWeight);
 800aa92:	89fb      	ldrh	r3, [r7, #14]
 800aa94:	b2db      	uxtb	r3, r3
 800aa96:	7dba      	ldrb	r2, [r7, #22]
 800aa98:	4611      	mov	r1, r2
 800aa9a:	4618      	mov	r0, r3
 800aa9c:	f000 f9d8 	bl	800ae50 <TS_IO_Read>
 800aaa0:	4603      	mov	r3, r0
 800aaa2:	753b      	strb	r3, [r7, #20]
    * pWeight = (ucReadData & FT5336_TOUCH_WEIGHT_MASK) >> FT5336_TOUCH_WEIGHT_SHIFT;
 800aaa4:	7d3b      	ldrb	r3, [r7, #20]
 800aaa6:	b2db      	uxtb	r3, r3
 800aaa8:	461a      	mov	r2, r3
 800aaaa:	687b      	ldr	r3, [r7, #4]
 800aaac:	601a      	str	r2, [r3, #0]

    /* Read area of touch index */
    ucReadData = TS_IO_Read(DeviceAddr, regAddressPMisc);
 800aaae:	89fb      	ldrh	r3, [r7, #14]
 800aab0:	b2db      	uxtb	r3, r3
 800aab2:	7d7a      	ldrb	r2, [r7, #21]
 800aab4:	4611      	mov	r1, r2
 800aab6:	4618      	mov	r0, r3
 800aab8:	f000 f9ca 	bl	800ae50 <TS_IO_Read>
 800aabc:	4603      	mov	r3, r0
 800aabe:	753b      	strb	r3, [r7, #20]
    * pArea = (ucReadData & FT5336_TOUCH_AREA_MASK) >> FT5336_TOUCH_AREA_SHIFT;
 800aac0:	7d3b      	ldrb	r3, [r7, #20]
 800aac2:	b2db      	uxtb	r3, r3
 800aac4:	111b      	asrs	r3, r3, #4
 800aac6:	f003 0204 	and.w	r2, r3, #4
 800aaca:	683b      	ldr	r3, [r7, #0]
 800aacc:	601a      	str	r2, [r3, #0]

  } /* of if(touchIdx < ft5336_handle.currActiveTouchNb) */
}
 800aace:	bf00      	nop
 800aad0:	3718      	adds	r7, #24
 800aad2:	46bd      	mov	sp, r7
 800aad4:	bd80      	pop	{r7, pc}
 800aad6:	bf00      	nop
 800aad8:	20000cd4 	.word	0x20000cd4

0800aadc <ft5336_Get_I2C_InitializedStatus>:
  * @brief  Return the status of I2C was initialized or not.
  * @param  None.
  * @retval : I2C initialization status.
  */
static uint8_t ft5336_Get_I2C_InitializedStatus(void)
{
 800aadc:	b480      	push	{r7}
 800aade:	af00      	add	r7, sp, #0
  return(ft5336_handle.i2cInitialized);
 800aae0:	4b03      	ldr	r3, [pc, #12]	; (800aaf0 <ft5336_Get_I2C_InitializedStatus+0x14>)
 800aae2:	781b      	ldrb	r3, [r3, #0]
}
 800aae4:	4618      	mov	r0, r3
 800aae6:	46bd      	mov	sp, r7
 800aae8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800aaec:	4770      	bx	lr
 800aaee:	bf00      	nop
 800aaf0:	20000cd4 	.word	0x20000cd4

0800aaf4 <ft5336_I2C_InitializeIfRequired>:
  * @brief  I2C initialize if needed.
  * @param  None.
  * @retval : None.
  */
static void ft5336_I2C_InitializeIfRequired(void)
{
 800aaf4:	b580      	push	{r7, lr}
 800aaf6:	af00      	add	r7, sp, #0
  if(ft5336_Get_I2C_InitializedStatus() == FT5336_I2C_NOT_INITIALIZED)
 800aaf8:	f7ff fff0 	bl	800aadc <ft5336_Get_I2C_InitializedStatus>
 800aafc:	4603      	mov	r3, r0
 800aafe:	2b00      	cmp	r3, #0
 800ab00:	d104      	bne.n	800ab0c <ft5336_I2C_InitializeIfRequired+0x18>
  {
    /* Initialize TS IO BUS layer (I2C) */
    TS_IO_Init();
 800ab02:	f000 f981 	bl	800ae08 <TS_IO_Init>

    /* Set state to initialized */
    ft5336_handle.i2cInitialized = FT5336_I2C_INITIALIZED;
 800ab06:	4b02      	ldr	r3, [pc, #8]	; (800ab10 <ft5336_I2C_InitializeIfRequired+0x1c>)
 800ab08:	2201      	movs	r2, #1
 800ab0a:	701a      	strb	r2, [r3, #0]
  }
}
 800ab0c:	bf00      	nop
 800ab0e:	bd80      	pop	{r7, pc}
 800ab10:	20000cd4 	.word	0x20000cd4

0800ab14 <ft5336_TS_Configure>:
  * @brief  Basic static configuration of TouchScreen
  * @param  DeviceAddr: FT5336 Device address for communication on I2C Bus.
  * @retval Status FT5336_STATUS_OK or FT5336_STATUS_NOT_OK.
  */
static uint32_t ft5336_TS_Configure(uint16_t DeviceAddr)
{
 800ab14:	b480      	push	{r7}
 800ab16:	b085      	sub	sp, #20
 800ab18:	af00      	add	r7, sp, #0
 800ab1a:	4603      	mov	r3, r0
 800ab1c:	80fb      	strh	r3, [r7, #6]
  uint32_t status = FT5336_STATUS_OK;
 800ab1e:	2300      	movs	r3, #0
 800ab20:	60fb      	str	r3, [r7, #12]

  /* Nothing special to be done for FT5336 */

  return(status);
 800ab22:	68fb      	ldr	r3, [r7, #12]
}
 800ab24:	4618      	mov	r0, r3
 800ab26:	3714      	adds	r7, #20
 800ab28:	46bd      	mov	sp, r7
 800ab2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ab2e:	4770      	bx	lr

0800ab30 <BSP_LED_Toggle>:
  *          This parameter can be one of the following values:
  *            @arg  LED1
  * @retval None
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
 800ab30:	b580      	push	{r7, lr}
 800ab32:	b084      	sub	sp, #16
 800ab34:	af00      	add	r7, sp, #0
 800ab36:	4603      	mov	r3, r0
 800ab38:	71fb      	strb	r3, [r7, #7]
  GPIO_TypeDef*     gpio_led;

  if (Led == LED1)	/* Toggle LED connected to GPIO */
 800ab3a:	79fb      	ldrb	r3, [r7, #7]
 800ab3c:	2b00      	cmp	r3, #0
 800ab3e:	d107      	bne.n	800ab50 <BSP_LED_Toggle+0x20>
  {
    gpio_led = LED1_GPIO_PORT;
 800ab40:	4b05      	ldr	r3, [pc, #20]	; (800ab58 <BSP_LED_Toggle+0x28>)
 800ab42:	60fb      	str	r3, [r7, #12]
    HAL_GPIO_TogglePin(gpio_led, GPIO_PIN[Led]);
 800ab44:	2302      	movs	r3, #2
 800ab46:	b29b      	uxth	r3, r3
 800ab48:	4619      	mov	r1, r3
 800ab4a:	68f8      	ldr	r0, [r7, #12]
 800ab4c:	f7f7 f9d9 	bl	8001f02 <HAL_GPIO_TogglePin>
  }
}
 800ab50:	bf00      	nop
 800ab52:	3710      	adds	r7, #16
 800ab54:	46bd      	mov	sp, r7
 800ab56:	bd80      	pop	{r7, pc}
 800ab58:	40022000 	.word	0x40022000

0800ab5c <I2Cx_MspInit>:
  * @brief  Initializes I2C MSP.
  * @param  i2c_handler : I2C handler
  * @retval None
  */
static void I2Cx_MspInit(I2C_HandleTypeDef *i2c_handler)
{
 800ab5c:	b580      	push	{r7, lr}
 800ab5e:	b08c      	sub	sp, #48	; 0x30
 800ab60:	af00      	add	r7, sp, #0
 800ab62:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef  gpio_init_structure;
  
  if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
 800ab64:	687b      	ldr	r3, [r7, #4]
 800ab66:	4a51      	ldr	r2, [pc, #324]	; (800acac <I2Cx_MspInit+0x150>)
 800ab68:	4293      	cmp	r3, r2
 800ab6a:	d14d      	bne.n	800ac08 <I2Cx_MspInit+0xac>
  {
    /* AUDIO and LCD I2C MSP init */

    /*** Configure the GPIOs ***/
    /* Enable GPIO clock */
    DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 800ab6c:	4b50      	ldr	r3, [pc, #320]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ab6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ab70:	4a4f      	ldr	r2, [pc, #316]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ab72:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800ab76:	6313      	str	r3, [r2, #48]	; 0x30
 800ab78:	4b4d      	ldr	r3, [pc, #308]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ab7a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ab7c:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800ab80:	61bb      	str	r3, [r7, #24]
 800ab82:	69bb      	ldr	r3, [r7, #24]

    /* Configure I2C Tx as alternate function */
    gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SCL_PIN;
 800ab84:	2380      	movs	r3, #128	; 0x80
 800ab86:	61fb      	str	r3, [r7, #28]
    gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 800ab88:	2312      	movs	r3, #18
 800ab8a:	623b      	str	r3, [r7, #32]
    gpio_init_structure.Pull = GPIO_NOPULL;
 800ab8c:	2300      	movs	r3, #0
 800ab8e:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Speed = GPIO_SPEED_FAST;
 800ab90:	2302      	movs	r3, #2
 800ab92:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = DISCOVERY_AUDIO_I2Cx_SCL_SDA_AF;
 800ab94:	2304      	movs	r3, #4
 800ab96:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 800ab98:	f107 031c 	add.w	r3, r7, #28
 800ab9c:	4619      	mov	r1, r3
 800ab9e:	4845      	ldr	r0, [pc, #276]	; (800acb4 <I2Cx_MspInit+0x158>)
 800aba0:	f7f6 ffec 	bl	8001b7c <HAL_GPIO_Init>

    /* Configure I2C Rx as alternate function */
    gpio_init_structure.Pin = DISCOVERY_AUDIO_I2Cx_SDA_PIN;
 800aba4:	f44f 7380 	mov.w	r3, #256	; 0x100
 800aba8:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(DISCOVERY_AUDIO_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 800abaa:	f107 031c 	add.w	r3, r7, #28
 800abae:	4619      	mov	r1, r3
 800abb0:	4840      	ldr	r0, [pc, #256]	; (800acb4 <I2Cx_MspInit+0x158>)
 800abb2:	f7f6 ffe3 	bl	8001b7c <HAL_GPIO_Init>

    /*** Configure the I2C peripheral ***/
    /* Enable I2C clock */
    DISCOVERY_AUDIO_I2Cx_CLK_ENABLE();
 800abb6:	4b3e      	ldr	r3, [pc, #248]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abb8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800abba:	4a3d      	ldr	r2, [pc, #244]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abbc:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800abc0:	6413      	str	r3, [r2, #64]	; 0x40
 800abc2:	4b3b      	ldr	r3, [pc, #236]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abc4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800abc6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800abca:	617b      	str	r3, [r7, #20]
 800abcc:	697b      	ldr	r3, [r7, #20]

    /* Force the I2C peripheral clock reset */
    DISCOVERY_AUDIO_I2Cx_FORCE_RESET();
 800abce:	4b38      	ldr	r3, [pc, #224]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abd0:	6a1b      	ldr	r3, [r3, #32]
 800abd2:	4a37      	ldr	r2, [pc, #220]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abd4:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800abd8:	6213      	str	r3, [r2, #32]

    /* Release the I2C peripheral clock reset */
    DISCOVERY_AUDIO_I2Cx_RELEASE_RESET();
 800abda:	4b35      	ldr	r3, [pc, #212]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abdc:	6a1b      	ldr	r3, [r3, #32]
 800abde:	4a34      	ldr	r2, [pc, #208]	; (800acb0 <I2Cx_MspInit+0x154>)
 800abe0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 800abe4:	6213      	str	r3, [r2, #32]

    /* Enable and set I2Cx Interrupt to a lower priority */
    HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_EV_IRQn, 0x0F, 0);
 800abe6:	2200      	movs	r2, #0
 800abe8:	210f      	movs	r1, #15
 800abea:	2048      	movs	r0, #72	; 0x48
 800abec:	f7f6 f872 	bl	8000cd4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_EV_IRQn);
 800abf0:	2048      	movs	r0, #72	; 0x48
 800abf2:	f7f6 f88b 	bl	8000d0c <HAL_NVIC_EnableIRQ>

    /* Enable and set I2Cx Interrupt to a lower priority */
    HAL_NVIC_SetPriority(DISCOVERY_AUDIO_I2Cx_ER_IRQn, 0x0F, 0);
 800abf6:	2200      	movs	r2, #0
 800abf8:	210f      	movs	r1, #15
 800abfa:	2049      	movs	r0, #73	; 0x49
 800abfc:	f7f6 f86a 	bl	8000cd4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_AUDIO_I2Cx_ER_IRQn);
 800ac00:	2049      	movs	r0, #73	; 0x49
 800ac02:	f7f6 f883 	bl	8000d0c <HAL_NVIC_EnableIRQ>

    /* Enable and set I2Cx Interrupt to a lower priority */
    HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
    HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
  }
}
 800ac06:	e04d      	b.n	800aca4 <I2Cx_MspInit+0x148>
    DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_CLK_ENABLE();
 800ac08:	4b29      	ldr	r3, [pc, #164]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac0a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ac0c:	4a28      	ldr	r2, [pc, #160]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac0e:	f043 0302 	orr.w	r3, r3, #2
 800ac12:	6313      	str	r3, [r2, #48]	; 0x30
 800ac14:	4b26      	ldr	r3, [pc, #152]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac16:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ac18:	f003 0302 	and.w	r3, r3, #2
 800ac1c:	613b      	str	r3, [r7, #16]
 800ac1e:	693b      	ldr	r3, [r7, #16]
    gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SCL_PIN;
 800ac20:	f44f 7380 	mov.w	r3, #256	; 0x100
 800ac24:	61fb      	str	r3, [r7, #28]
    gpio_init_structure.Mode = GPIO_MODE_AF_OD;
 800ac26:	2312      	movs	r3, #18
 800ac28:	623b      	str	r3, [r7, #32]
    gpio_init_structure.Pull = GPIO_NOPULL;
 800ac2a:	2300      	movs	r3, #0
 800ac2c:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Speed = GPIO_SPEED_FAST;
 800ac2e:	2302      	movs	r3, #2
 800ac30:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = DISCOVERY_EXT_I2Cx_SCL_SDA_AF;
 800ac32:	2304      	movs	r3, #4
 800ac34:	62fb      	str	r3, [r7, #44]	; 0x2c
    HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 800ac36:	f107 031c 	add.w	r3, r7, #28
 800ac3a:	4619      	mov	r1, r3
 800ac3c:	481e      	ldr	r0, [pc, #120]	; (800acb8 <I2Cx_MspInit+0x15c>)
 800ac3e:	f7f6 ff9d 	bl	8001b7c <HAL_GPIO_Init>
    gpio_init_structure.Pin = DISCOVERY_EXT_I2Cx_SDA_PIN;
 800ac42:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ac46:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(DISCOVERY_EXT_I2Cx_SCL_SDA_GPIO_PORT, &gpio_init_structure);
 800ac48:	f107 031c 	add.w	r3, r7, #28
 800ac4c:	4619      	mov	r1, r3
 800ac4e:	481a      	ldr	r0, [pc, #104]	; (800acb8 <I2Cx_MspInit+0x15c>)
 800ac50:	f7f6 ff94 	bl	8001b7c <HAL_GPIO_Init>
    DISCOVERY_EXT_I2Cx_CLK_ENABLE();
 800ac54:	4b16      	ldr	r3, [pc, #88]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac56:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ac58:	4a15      	ldr	r2, [pc, #84]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac5a:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800ac5e:	6413      	str	r3, [r2, #64]	; 0x40
 800ac60:	4b13      	ldr	r3, [pc, #76]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac62:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ac64:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800ac68:	60fb      	str	r3, [r7, #12]
 800ac6a:	68fb      	ldr	r3, [r7, #12]
    DISCOVERY_EXT_I2Cx_FORCE_RESET();
 800ac6c:	4b10      	ldr	r3, [pc, #64]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac6e:	6a1b      	ldr	r3, [r3, #32]
 800ac70:	4a0f      	ldr	r2, [pc, #60]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac72:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 800ac76:	6213      	str	r3, [r2, #32]
    DISCOVERY_EXT_I2Cx_RELEASE_RESET();
 800ac78:	4b0d      	ldr	r3, [pc, #52]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac7a:	6a1b      	ldr	r3, [r3, #32]
 800ac7c:	4a0c      	ldr	r2, [pc, #48]	; (800acb0 <I2Cx_MspInit+0x154>)
 800ac7e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 800ac82:	6213      	str	r3, [r2, #32]
    HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_EV_IRQn, 0x0F, 0);
 800ac84:	2200      	movs	r2, #0
 800ac86:	210f      	movs	r1, #15
 800ac88:	201f      	movs	r0, #31
 800ac8a:	f7f6 f823 	bl	8000cd4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_EV_IRQn);
 800ac8e:	201f      	movs	r0, #31
 800ac90:	f7f6 f83c 	bl	8000d0c <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(DISCOVERY_EXT_I2Cx_ER_IRQn, 0x0F, 0);
 800ac94:	2200      	movs	r2, #0
 800ac96:	210f      	movs	r1, #15
 800ac98:	2020      	movs	r0, #32
 800ac9a:	f7f6 f81b 	bl	8000cd4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_EXT_I2Cx_ER_IRQn);
 800ac9e:	2020      	movs	r0, #32
 800aca0:	f7f6 f834 	bl	8000d0c <HAL_NVIC_EnableIRQ>
}
 800aca4:	bf00      	nop
 800aca6:	3730      	adds	r7, #48	; 0x30
 800aca8:	46bd      	mov	sp, r7
 800acaa:	bd80      	pop	{r7, pc}
 800acac:	20000cdc 	.word	0x20000cdc
 800acb0:	40023800 	.word	0x40023800
 800acb4:	40021c00 	.word	0x40021c00
 800acb8:	40020400 	.word	0x40020400

0800acbc <I2Cx_Init>:
  * @brief  Initializes I2C HAL.
  * @param  i2c_handler : I2C handler
  * @retval None
  */
static void I2Cx_Init(I2C_HandleTypeDef *i2c_handler)
{
 800acbc:	b580      	push	{r7, lr}
 800acbe:	b082      	sub	sp, #8
 800acc0:	af00      	add	r7, sp, #0
 800acc2:	6078      	str	r0, [r7, #4]
  if(HAL_I2C_GetState(i2c_handler) == HAL_I2C_STATE_RESET)
 800acc4:	6878      	ldr	r0, [r7, #4]
 800acc6:	f7f8 fe1d 	bl	8003904 <HAL_I2C_GetState>
 800acca:	4603      	mov	r3, r0
 800accc:	2b00      	cmp	r3, #0
 800acce:	d125      	bne.n	800ad1c <I2Cx_Init+0x60>
  {
    if (i2c_handler == (I2C_HandleTypeDef*)(&hI2cAudioHandler))
 800acd0:	687b      	ldr	r3, [r7, #4]
 800acd2:	4a14      	ldr	r2, [pc, #80]	; (800ad24 <I2Cx_Init+0x68>)
 800acd4:	4293      	cmp	r3, r2
 800acd6:	d103      	bne.n	800ace0 <I2Cx_Init+0x24>
    {
      /* Audio and LCD I2C configuration */
      i2c_handler->Instance = DISCOVERY_AUDIO_I2Cx;
 800acd8:	687b      	ldr	r3, [r7, #4]
 800acda:	4a13      	ldr	r2, [pc, #76]	; (800ad28 <I2Cx_Init+0x6c>)
 800acdc:	601a      	str	r2, [r3, #0]
 800acde:	e002      	b.n	800ace6 <I2Cx_Init+0x2a>
    }
    else
    {
      /* External, camera and Arduino connector  I2C configuration */
      i2c_handler->Instance = DISCOVERY_EXT_I2Cx;
 800ace0:	687b      	ldr	r3, [r7, #4]
 800ace2:	4a12      	ldr	r2, [pc, #72]	; (800ad2c <I2Cx_Init+0x70>)
 800ace4:	601a      	str	r2, [r3, #0]
    }
    i2c_handler->Init.Timing           = DISCOVERY_I2Cx_TIMING;
 800ace6:	687b      	ldr	r3, [r7, #4]
 800ace8:	4a11      	ldr	r2, [pc, #68]	; (800ad30 <I2Cx_Init+0x74>)
 800acea:	605a      	str	r2, [r3, #4]
    i2c_handler->Init.OwnAddress1      = 0;
 800acec:	687b      	ldr	r3, [r7, #4]
 800acee:	2200      	movs	r2, #0
 800acf0:	609a      	str	r2, [r3, #8]
    i2c_handler->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 800acf2:	687b      	ldr	r3, [r7, #4]
 800acf4:	2201      	movs	r2, #1
 800acf6:	60da      	str	r2, [r3, #12]
    i2c_handler->Init.DualAddressMode  = I2C_DUALADDRESS_DISABLE;
 800acf8:	687b      	ldr	r3, [r7, #4]
 800acfa:	2200      	movs	r2, #0
 800acfc:	611a      	str	r2, [r3, #16]
    i2c_handler->Init.OwnAddress2      = 0;
 800acfe:	687b      	ldr	r3, [r7, #4]
 800ad00:	2200      	movs	r2, #0
 800ad02:	615a      	str	r2, [r3, #20]
    i2c_handler->Init.GeneralCallMode  = I2C_GENERALCALL_DISABLE;
 800ad04:	687b      	ldr	r3, [r7, #4]
 800ad06:	2200      	movs	r2, #0
 800ad08:	61da      	str	r2, [r3, #28]
    i2c_handler->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
 800ad0a:	687b      	ldr	r3, [r7, #4]
 800ad0c:	2200      	movs	r2, #0
 800ad0e:	621a      	str	r2, [r3, #32]

    /* Init the I2C */
    I2Cx_MspInit(i2c_handler);
 800ad10:	6878      	ldr	r0, [r7, #4]
 800ad12:	f7ff ff23 	bl	800ab5c <I2Cx_MspInit>
    HAL_I2C_Init(i2c_handler);
 800ad16:	6878      	ldr	r0, [r7, #4]
 800ad18:	f7f8 faf2 	bl	8003300 <HAL_I2C_Init>
  }
}
 800ad1c:	bf00      	nop
 800ad1e:	3708      	adds	r7, #8
 800ad20:	46bd      	mov	sp, r7
 800ad22:	bd80      	pop	{r7, pc}
 800ad24:	20000cdc 	.word	0x20000cdc
 800ad28:	40005c00 	.word	0x40005c00
 800ad2c:	40005400 	.word	0x40005400
 800ad30:	40912732 	.word	0x40912732

0800ad34 <I2Cx_ReadMultiple>:
                                           uint8_t Addr,
                                           uint16_t Reg,
                                           uint16_t MemAddress,
                                           uint8_t *Buffer,
                                           uint16_t Length)
{
 800ad34:	b580      	push	{r7, lr}
 800ad36:	b08a      	sub	sp, #40	; 0x28
 800ad38:	af04      	add	r7, sp, #16
 800ad3a:	60f8      	str	r0, [r7, #12]
 800ad3c:	4608      	mov	r0, r1
 800ad3e:	4611      	mov	r1, r2
 800ad40:	461a      	mov	r2, r3
 800ad42:	4603      	mov	r3, r0
 800ad44:	72fb      	strb	r3, [r7, #11]
 800ad46:	460b      	mov	r3, r1
 800ad48:	813b      	strh	r3, [r7, #8]
 800ad4a:	4613      	mov	r3, r2
 800ad4c:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef status = HAL_OK;
 800ad4e:	2300      	movs	r3, #0
 800ad50:	75fb      	strb	r3, [r7, #23]

  status = HAL_I2C_Mem_Read(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 800ad52:	7afb      	ldrb	r3, [r7, #11]
 800ad54:	b299      	uxth	r1, r3
 800ad56:	88f8      	ldrh	r0, [r7, #6]
 800ad58:	893a      	ldrh	r2, [r7, #8]
 800ad5a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800ad5e:	9302      	str	r3, [sp, #8]
 800ad60:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800ad62:	9301      	str	r3, [sp, #4]
 800ad64:	6a3b      	ldr	r3, [r7, #32]
 800ad66:	9300      	str	r3, [sp, #0]
 800ad68:	4603      	mov	r3, r0
 800ad6a:	68f8      	ldr	r0, [r7, #12]
 800ad6c:	f7f8 fcb0 	bl	80036d0 <HAL_I2C_Mem_Read>
 800ad70:	4603      	mov	r3, r0
 800ad72:	75fb      	strb	r3, [r7, #23]

  /* Check the communication status */
  if(status != HAL_OK)
 800ad74:	7dfb      	ldrb	r3, [r7, #23]
 800ad76:	2b00      	cmp	r3, #0
 800ad78:	d004      	beq.n	800ad84 <I2Cx_ReadMultiple+0x50>
  {
    /* I2C error occurred */
    I2Cx_Error(i2c_handler, Addr);
 800ad7a:	7afb      	ldrb	r3, [r7, #11]
 800ad7c:	4619      	mov	r1, r3
 800ad7e:	68f8      	ldr	r0, [r7, #12]
 800ad80:	f000 f832 	bl	800ade8 <I2Cx_Error>
  }
  return status;    
 800ad84:	7dfb      	ldrb	r3, [r7, #23]
}
 800ad86:	4618      	mov	r0, r3
 800ad88:	3718      	adds	r7, #24
 800ad8a:	46bd      	mov	sp, r7
 800ad8c:	bd80      	pop	{r7, pc}

0800ad8e <I2Cx_WriteMultiple>:
                                            uint8_t Addr,
                                            uint16_t Reg,
                                            uint16_t MemAddress,
                                            uint8_t *Buffer,
                                            uint16_t Length)
{
 800ad8e:	b580      	push	{r7, lr}
 800ad90:	b08a      	sub	sp, #40	; 0x28
 800ad92:	af04      	add	r7, sp, #16
 800ad94:	60f8      	str	r0, [r7, #12]
 800ad96:	4608      	mov	r0, r1
 800ad98:	4611      	mov	r1, r2
 800ad9a:	461a      	mov	r2, r3
 800ad9c:	4603      	mov	r3, r0
 800ad9e:	72fb      	strb	r3, [r7, #11]
 800ada0:	460b      	mov	r3, r1
 800ada2:	813b      	strh	r3, [r7, #8]
 800ada4:	4613      	mov	r3, r2
 800ada6:	80fb      	strh	r3, [r7, #6]
  HAL_StatusTypeDef status = HAL_OK;
 800ada8:	2300      	movs	r3, #0
 800adaa:	75fb      	strb	r3, [r7, #23]
  
  status = HAL_I2C_Mem_Write(i2c_handler, Addr, (uint16_t)Reg, MemAddress, Buffer, Length, 1000);
 800adac:	7afb      	ldrb	r3, [r7, #11]
 800adae:	b299      	uxth	r1, r3
 800adb0:	88f8      	ldrh	r0, [r7, #6]
 800adb2:	893a      	ldrh	r2, [r7, #8]
 800adb4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800adb8:	9302      	str	r3, [sp, #8]
 800adba:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800adbc:	9301      	str	r3, [sp, #4]
 800adbe:	6a3b      	ldr	r3, [r7, #32]
 800adc0:	9300      	str	r3, [sp, #0]
 800adc2:	4603      	mov	r3, r0
 800adc4:	68f8      	ldr	r0, [r7, #12]
 800adc6:	f7f8 fb6f 	bl	80034a8 <HAL_I2C_Mem_Write>
 800adca:	4603      	mov	r3, r0
 800adcc:	75fb      	strb	r3, [r7, #23]
  
  /* Check the communication status */
  if(status != HAL_OK)
 800adce:	7dfb      	ldrb	r3, [r7, #23]
 800add0:	2b00      	cmp	r3, #0
 800add2:	d004      	beq.n	800adde <I2Cx_WriteMultiple+0x50>
  {
    /* Re-Initiaize the I2C Bus */
    I2Cx_Error(i2c_handler, Addr);
 800add4:	7afb      	ldrb	r3, [r7, #11]
 800add6:	4619      	mov	r1, r3
 800add8:	68f8      	ldr	r0, [r7, #12]
 800adda:	f000 f805 	bl	800ade8 <I2Cx_Error>
  }
  return status;
 800adde:	7dfb      	ldrb	r3, [r7, #23]
}
 800ade0:	4618      	mov	r0, r3
 800ade2:	3718      	adds	r7, #24
 800ade4:	46bd      	mov	sp, r7
 800ade6:	bd80      	pop	{r7, pc}

0800ade8 <I2Cx_Error>:
  * @param  i2c_handler : I2C handler
  * @param  Addr: I2C Address
  * @retval None
  */
static void I2Cx_Error(I2C_HandleTypeDef *i2c_handler, uint8_t Addr)
{
 800ade8:	b580      	push	{r7, lr}
 800adea:	b082      	sub	sp, #8
 800adec:	af00      	add	r7, sp, #0
 800adee:	6078      	str	r0, [r7, #4]
 800adf0:	460b      	mov	r3, r1
 800adf2:	70fb      	strb	r3, [r7, #3]
  /* De-initialize the I2C communication bus */
  HAL_I2C_DeInit(i2c_handler);
 800adf4:	6878      	ldr	r0, [r7, #4]
 800adf6:	f7f8 fb13 	bl	8003420 <HAL_I2C_DeInit>
  
  /* Re-Initialize the I2C communication bus */
  I2Cx_Init(i2c_handler);
 800adfa:	6878      	ldr	r0, [r7, #4]
 800adfc:	f7ff ff5e 	bl	800acbc <I2Cx_Init>
}
 800ae00:	bf00      	nop
 800ae02:	3708      	adds	r7, #8
 800ae04:	46bd      	mov	sp, r7
 800ae06:	bd80      	pop	{r7, pc}

0800ae08 <TS_IO_Init>:
/**
  * @brief  Initializes Touchscreen low level.
  * @retval None
  */
void TS_IO_Init(void)
{
 800ae08:	b580      	push	{r7, lr}
 800ae0a:	af00      	add	r7, sp, #0
  I2Cx_Init(&hI2cAudioHandler);
 800ae0c:	4802      	ldr	r0, [pc, #8]	; (800ae18 <TS_IO_Init+0x10>)
 800ae0e:	f7ff ff55 	bl	800acbc <I2Cx_Init>
}
 800ae12:	bf00      	nop
 800ae14:	bd80      	pop	{r7, pc}
 800ae16:	bf00      	nop
 800ae18:	20000cdc 	.word	0x20000cdc

0800ae1c <TS_IO_Write>:
  * @param  Reg: Reg address
  * @param  Value: Data to be written
  * @retval None
  */
void TS_IO_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 800ae1c:	b580      	push	{r7, lr}
 800ae1e:	b084      	sub	sp, #16
 800ae20:	af02      	add	r7, sp, #8
 800ae22:	4603      	mov	r3, r0
 800ae24:	71fb      	strb	r3, [r7, #7]
 800ae26:	460b      	mov	r3, r1
 800ae28:	71bb      	strb	r3, [r7, #6]
 800ae2a:	4613      	mov	r3, r2
 800ae2c:	717b      	strb	r3, [r7, #5]
  I2Cx_WriteMultiple(&hI2cAudioHandler, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT,(uint8_t*)&Value, 1);
 800ae2e:	79bb      	ldrb	r3, [r7, #6]
 800ae30:	b29a      	uxth	r2, r3
 800ae32:	79f9      	ldrb	r1, [r7, #7]
 800ae34:	2301      	movs	r3, #1
 800ae36:	9301      	str	r3, [sp, #4]
 800ae38:	1d7b      	adds	r3, r7, #5
 800ae3a:	9300      	str	r3, [sp, #0]
 800ae3c:	2301      	movs	r3, #1
 800ae3e:	4803      	ldr	r0, [pc, #12]	; (800ae4c <TS_IO_Write+0x30>)
 800ae40:	f7ff ffa5 	bl	800ad8e <I2Cx_WriteMultiple>
}
 800ae44:	bf00      	nop
 800ae46:	3708      	adds	r7, #8
 800ae48:	46bd      	mov	sp, r7
 800ae4a:	bd80      	pop	{r7, pc}
 800ae4c:	20000cdc 	.word	0x20000cdc

0800ae50 <TS_IO_Read>:
  * @param  Addr: I2C address
  * @param  Reg: Reg address
  * @retval Data to be read
  */
uint8_t TS_IO_Read(uint8_t Addr, uint8_t Reg)
{
 800ae50:	b580      	push	{r7, lr}
 800ae52:	b086      	sub	sp, #24
 800ae54:	af02      	add	r7, sp, #8
 800ae56:	4603      	mov	r3, r0
 800ae58:	460a      	mov	r2, r1
 800ae5a:	71fb      	strb	r3, [r7, #7]
 800ae5c:	4613      	mov	r3, r2
 800ae5e:	71bb      	strb	r3, [r7, #6]
  uint8_t read_value = 0;
 800ae60:	2300      	movs	r3, #0
 800ae62:	73fb      	strb	r3, [r7, #15]

  I2Cx_ReadMultiple(&hI2cAudioHandler, Addr, Reg, I2C_MEMADD_SIZE_8BIT, (uint8_t*)&read_value, 1);
 800ae64:	79bb      	ldrb	r3, [r7, #6]
 800ae66:	b29a      	uxth	r2, r3
 800ae68:	79f9      	ldrb	r1, [r7, #7]
 800ae6a:	2301      	movs	r3, #1
 800ae6c:	9301      	str	r3, [sp, #4]
 800ae6e:	f107 030f 	add.w	r3, r7, #15
 800ae72:	9300      	str	r3, [sp, #0]
 800ae74:	2301      	movs	r3, #1
 800ae76:	4804      	ldr	r0, [pc, #16]	; (800ae88 <TS_IO_Read+0x38>)
 800ae78:	f7ff ff5c 	bl	800ad34 <I2Cx_ReadMultiple>

  return read_value;
 800ae7c:	7bfb      	ldrb	r3, [r7, #15]
}
 800ae7e:	4618      	mov	r0, r3
 800ae80:	3710      	adds	r7, #16
 800ae82:	46bd      	mov	sp, r7
 800ae84:	bd80      	pop	{r7, pc}
 800ae86:	bf00      	nop
 800ae88:	20000cdc 	.word	0x20000cdc

0800ae8c <TS_IO_Delay>:
  * @brief  TS delay
  * @param  Delay: Delay in ms
  * @retval None
  */
void TS_IO_Delay(uint32_t Delay)
{
 800ae8c:	b580      	push	{r7, lr}
 800ae8e:	b082      	sub	sp, #8
 800ae90:	af00      	add	r7, sp, #0
 800ae92:	6078      	str	r0, [r7, #4]
  HAL_Delay(Delay);
 800ae94:	6878      	ldr	r0, [r7, #4]
 800ae96:	f7f5 fbd1 	bl	800063c <HAL_Delay>
}
 800ae9a:	bf00      	nop
 800ae9c:	3708      	adds	r7, #8
 800ae9e:	46bd      	mov	sp, r7
 800aea0:	bd80      	pop	{r7, pc}
	...

0800aea4 <BSP_SDRAM_Init>:
/**
  * @brief  Initializes the SDRAM device.
  * @retval SDRAM status
  */
uint8_t BSP_SDRAM_Init(void)
{ 
 800aea4:	b580      	push	{r7, lr}
 800aea6:	af00      	add	r7, sp, #0
  static uint8_t sdramstatus = SDRAM_ERROR;
  /* SDRAM device configuration */
  sdramHandle.Instance = FMC_SDRAM_DEVICE;
 800aea8:	4b29      	ldr	r3, [pc, #164]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aeaa:	4a2a      	ldr	r2, [pc, #168]	; (800af54 <BSP_SDRAM_Init+0xb0>)
 800aeac:	601a      	str	r2, [r3, #0]
    
  /* Timing configuration for 100Mhz as SD clock frequency (System clock is up to 200Mhz) */
  Timing.LoadToActiveDelay    = 2;
 800aeae:	4b2a      	ldr	r3, [pc, #168]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aeb0:	2202      	movs	r2, #2
 800aeb2:	601a      	str	r2, [r3, #0]
  Timing.ExitSelfRefreshDelay = 7;
 800aeb4:	4b28      	ldr	r3, [pc, #160]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aeb6:	2207      	movs	r2, #7
 800aeb8:	605a      	str	r2, [r3, #4]
  Timing.SelfRefreshTime      = 4;
 800aeba:	4b27      	ldr	r3, [pc, #156]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aebc:	2204      	movs	r2, #4
 800aebe:	609a      	str	r2, [r3, #8]
  Timing.RowCycleDelay        = 7;
 800aec0:	4b25      	ldr	r3, [pc, #148]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aec2:	2207      	movs	r2, #7
 800aec4:	60da      	str	r2, [r3, #12]
  Timing.WriteRecoveryTime    = 2;
 800aec6:	4b24      	ldr	r3, [pc, #144]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aec8:	2202      	movs	r2, #2
 800aeca:	611a      	str	r2, [r3, #16]
  Timing.RPDelay              = 2;
 800aecc:	4b22      	ldr	r3, [pc, #136]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aece:	2202      	movs	r2, #2
 800aed0:	615a      	str	r2, [r3, #20]
  Timing.RCDDelay             = 2;
 800aed2:	4b21      	ldr	r3, [pc, #132]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800aed4:	2202      	movs	r2, #2
 800aed6:	619a      	str	r2, [r3, #24]
  
  sdramHandle.Init.SDBank             = FMC_SDRAM_BANK1;
 800aed8:	4b1d      	ldr	r3, [pc, #116]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aeda:	2200      	movs	r2, #0
 800aedc:	605a      	str	r2, [r3, #4]
  sdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 800aede:	4b1c      	ldr	r3, [pc, #112]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aee0:	2200      	movs	r2, #0
 800aee2:	609a      	str	r2, [r3, #8]
  sdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 800aee4:	4b1a      	ldr	r3, [pc, #104]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aee6:	2204      	movs	r2, #4
 800aee8:	60da      	str	r2, [r3, #12]
  sdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 800aeea:	4b19      	ldr	r3, [pc, #100]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aeec:	2210      	movs	r2, #16
 800aeee:	611a      	str	r2, [r3, #16]
  sdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800aef0:	4b17      	ldr	r3, [pc, #92]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aef2:	2240      	movs	r2, #64	; 0x40
 800aef4:	615a      	str	r2, [r3, #20]
  sdramHandle.Init.CASLatency         = FMC_SDRAM_CAS_LATENCY_2;
 800aef6:	4b16      	ldr	r3, [pc, #88]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800aef8:	f44f 7280 	mov.w	r2, #256	; 0x100
 800aefc:	619a      	str	r2, [r3, #24]
  sdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 800aefe:	4b14      	ldr	r3, [pc, #80]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800af00:	2200      	movs	r2, #0
 800af02:	61da      	str	r2, [r3, #28]
  sdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 800af04:	4b12      	ldr	r3, [pc, #72]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800af06:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800af0a:	621a      	str	r2, [r3, #32]
  sdramHandle.Init.ReadBurst          = FMC_SDRAM_RBURST_ENABLE;
 800af0c:	4b10      	ldr	r3, [pc, #64]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800af0e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800af12:	625a      	str	r2, [r3, #36]	; 0x24
  sdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_0;
 800af14:	4b0e      	ldr	r3, [pc, #56]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800af16:	2200      	movs	r2, #0
 800af18:	629a      	str	r2, [r3, #40]	; 0x28
  
  /* SDRAM controller initialization */

  BSP_SDRAM_MspInit(&sdramHandle, NULL); /* __weak function can be rewritten by the application */
 800af1a:	2100      	movs	r1, #0
 800af1c:	480c      	ldr	r0, [pc, #48]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800af1e:	f000 f87f 	bl	800b020 <BSP_SDRAM_MspInit>

  if(HAL_SDRAM_Init(&sdramHandle, &Timing) != HAL_OK)
 800af22:	490d      	ldr	r1, [pc, #52]	; (800af58 <BSP_SDRAM_Init+0xb4>)
 800af24:	480a      	ldr	r0, [pc, #40]	; (800af50 <BSP_SDRAM_Init+0xac>)
 800af26:	f7fb f929 	bl	800617c <HAL_SDRAM_Init>
 800af2a:	4603      	mov	r3, r0
 800af2c:	2b00      	cmp	r3, #0
 800af2e:	d003      	beq.n	800af38 <BSP_SDRAM_Init+0x94>
  {
    sdramstatus = SDRAM_ERROR;
 800af30:	4b0a      	ldr	r3, [pc, #40]	; (800af5c <BSP_SDRAM_Init+0xb8>)
 800af32:	2201      	movs	r2, #1
 800af34:	701a      	strb	r2, [r3, #0]
 800af36:	e002      	b.n	800af3e <BSP_SDRAM_Init+0x9a>
  }
  else
  {
    sdramstatus = SDRAM_OK;
 800af38:	4b08      	ldr	r3, [pc, #32]	; (800af5c <BSP_SDRAM_Init+0xb8>)
 800af3a:	2200      	movs	r2, #0
 800af3c:	701a      	strb	r2, [r3, #0]
  }
  
  /* SDRAM initialization sequence */
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 800af3e:	f240 6003 	movw	r0, #1539	; 0x603
 800af42:	f000 f80d 	bl	800af60 <BSP_SDRAM_Initialization_sequence>
  
  return sdramstatus;
 800af46:	4b05      	ldr	r3, [pc, #20]	; (800af5c <BSP_SDRAM_Init+0xb8>)
 800af48:	781b      	ldrb	r3, [r3, #0]
}
 800af4a:	4618      	mov	r0, r3
 800af4c:	bd80      	pop	{r7, pc}
 800af4e:	bf00      	nop
 800af50:	2000dbf0 	.word	0x2000dbf0
 800af54:	a0000140 	.word	0xa0000140
 800af58:	20000d28 	.word	0x20000d28
 800af5c:	20000030 	.word	0x20000030

0800af60 <BSP_SDRAM_Initialization_sequence>:
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value 
  * @retval None
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
 800af60:	b580      	push	{r7, lr}
 800af62:	b084      	sub	sp, #16
 800af64:	af00      	add	r7, sp, #0
 800af66:	6078      	str	r0, [r7, #4]
  __IO uint32_t tmpmrd = 0;
 800af68:	2300      	movs	r3, #0
 800af6a:	60fb      	str	r3, [r7, #12]
  
  /* Step 1: Configure a clock configuration enable command */
  Command.CommandMode            = FMC_SDRAM_CMD_CLK_ENABLE;
 800af6c:	4b2a      	ldr	r3, [pc, #168]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af6e:	2201      	movs	r2, #1
 800af70:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800af72:	4b29      	ldr	r3, [pc, #164]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af74:	2210      	movs	r2, #16
 800af76:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 800af78:	4b27      	ldr	r3, [pc, #156]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af7a:	2201      	movs	r2, #1
 800af7c:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 800af7e:	4b26      	ldr	r3, [pc, #152]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af80:	2200      	movs	r2, #0
 800af82:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800af84:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800af88:	4923      	ldr	r1, [pc, #140]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af8a:	4824      	ldr	r0, [pc, #144]	; (800b01c <BSP_SDRAM_Initialization_sequence+0xbc>)
 800af8c:	f7fb f92a 	bl	80061e4 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */ 
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
 800af90:	2001      	movs	r0, #1
 800af92:	f7f5 fb53 	bl	800063c <HAL_Delay>
    
  /* Step 3: Configure a PALL (precharge all) command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_PALL;
 800af96:	4b20      	ldr	r3, [pc, #128]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af98:	2202      	movs	r2, #2
 800af9a:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800af9c:	4b1e      	ldr	r3, [pc, #120]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800af9e:	2210      	movs	r2, #16
 800afa0:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 800afa2:	4b1d      	ldr	r3, [pc, #116]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afa4:	2201      	movs	r2, #1
 800afa6:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 800afa8:	4b1b      	ldr	r3, [pc, #108]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afaa:	2200      	movs	r2, #0
 800afac:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);  
 800afae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800afb2:	4919      	ldr	r1, [pc, #100]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afb4:	4819      	ldr	r0, [pc, #100]	; (800b01c <BSP_SDRAM_Initialization_sequence+0xbc>)
 800afb6:	f7fb f915 	bl	80061e4 <HAL_SDRAM_SendCommand>
  
  /* Step 4: Configure an Auto Refresh command */ 
  Command.CommandMode            = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 800afba:	4b17      	ldr	r3, [pc, #92]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afbc:	2203      	movs	r2, #3
 800afbe:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800afc0:	4b15      	ldr	r3, [pc, #84]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afc2:	2210      	movs	r2, #16
 800afc4:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 8;
 800afc6:	4b14      	ldr	r3, [pc, #80]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afc8:	2208      	movs	r2, #8
 800afca:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = 0;
 800afcc:	4b12      	ldr	r3, [pc, #72]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afce:	2200      	movs	r2, #0
 800afd0:	60da      	str	r2, [r3, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800afd2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800afd6:	4910      	ldr	r1, [pc, #64]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afd8:	4810      	ldr	r0, [pc, #64]	; (800b01c <BSP_SDRAM_Initialization_sequence+0xbc>)
 800afda:	f7fb f903 	bl	80061e4 <HAL_SDRAM_SendCommand>
  
  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |\
 800afde:	f44f 7308 	mov.w	r3, #544	; 0x220
 800afe2:	60fb      	str	r3, [r7, #12]
                     SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |\
                     SDRAM_MODEREG_CAS_LATENCY_2           |\
                     SDRAM_MODEREG_OPERATING_MODE_STANDARD |\
                     SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;
  
  Command.CommandMode            = FMC_SDRAM_CMD_LOAD_MODE;
 800afe4:	4b0c      	ldr	r3, [pc, #48]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afe6:	2204      	movs	r2, #4
 800afe8:	601a      	str	r2, [r3, #0]
  Command.CommandTarget          = FMC_SDRAM_CMD_TARGET_BANK1;
 800afea:	4b0b      	ldr	r3, [pc, #44]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800afec:	2210      	movs	r2, #16
 800afee:	605a      	str	r2, [r3, #4]
  Command.AutoRefreshNumber      = 1;
 800aff0:	4b09      	ldr	r3, [pc, #36]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800aff2:	2201      	movs	r2, #1
 800aff4:	609a      	str	r2, [r3, #8]
  Command.ModeRegisterDefinition = tmpmrd;
 800aff6:	68fb      	ldr	r3, [r7, #12]
 800aff8:	4a07      	ldr	r2, [pc, #28]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800affa:	60d3      	str	r3, [r2, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&sdramHandle, &Command, SDRAM_TIMEOUT);
 800affc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800b000:	4905      	ldr	r1, [pc, #20]	; (800b018 <BSP_SDRAM_Initialization_sequence+0xb8>)
 800b002:	4806      	ldr	r0, [pc, #24]	; (800b01c <BSP_SDRAM_Initialization_sequence+0xbc>)
 800b004:	f7fb f8ee 	bl	80061e4 <HAL_SDRAM_SendCommand>
  
  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&sdramHandle, RefreshCount); 
 800b008:	6879      	ldr	r1, [r7, #4]
 800b00a:	4804      	ldr	r0, [pc, #16]	; (800b01c <BSP_SDRAM_Initialization_sequence+0xbc>)
 800b00c:	f7fb f915 	bl	800623a <HAL_SDRAM_ProgramRefreshRate>
}
 800b010:	bf00      	nop
 800b012:	3710      	adds	r7, #16
 800b014:	46bd      	mov	sp, r7
 800b016:	bd80      	pop	{r7, pc}
 800b018:	20000d44 	.word	0x20000d44
 800b01c:	2000dbf0 	.word	0x2000dbf0

0800b020 <BSP_SDRAM_MspInit>:
  * @param  hsdram: SDRAM handle
  * @param  Params
  * @retval None
  */
__weak void BSP_SDRAM_MspInit(SDRAM_HandleTypeDef  *hsdram, void *Params)
{  
 800b020:	b580      	push	{r7, lr}
 800b022:	b090      	sub	sp, #64	; 0x40
 800b024:	af00      	add	r7, sp, #0
 800b026:	6078      	str	r0, [r7, #4]
 800b028:	6039      	str	r1, [r7, #0]
  static DMA_HandleTypeDef dma_handle;
  GPIO_InitTypeDef gpio_init_structure;
  
  /* Enable FMC clock */
  __HAL_RCC_FMC_CLK_ENABLE();
 800b02a:	4b70      	ldr	r3, [pc, #448]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b02c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b02e:	4a6f      	ldr	r2, [pc, #444]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b030:	f043 0301 	orr.w	r3, r3, #1
 800b034:	6393      	str	r3, [r2, #56]	; 0x38
 800b036:	4b6d      	ldr	r3, [pc, #436]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b038:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800b03a:	f003 0301 	and.w	r3, r3, #1
 800b03e:	62bb      	str	r3, [r7, #40]	; 0x28
 800b040:	6abb      	ldr	r3, [r7, #40]	; 0x28
  
  /* Enable chosen DMAx clock */
  __DMAx_CLK_ENABLE();
 800b042:	4b6a      	ldr	r3, [pc, #424]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b044:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b046:	4a69      	ldr	r2, [pc, #420]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b048:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800b04c:	6313      	str	r3, [r2, #48]	; 0x30
 800b04e:	4b67      	ldr	r3, [pc, #412]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b050:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b052:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800b056:	627b      	str	r3, [r7, #36]	; 0x24
 800b058:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /* Enable GPIOs clock */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800b05a:	4b64      	ldr	r3, [pc, #400]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b05c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b05e:	4a63      	ldr	r2, [pc, #396]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b060:	f043 0304 	orr.w	r3, r3, #4
 800b064:	6313      	str	r3, [r2, #48]	; 0x30
 800b066:	4b61      	ldr	r3, [pc, #388]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b068:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b06a:	f003 0304 	and.w	r3, r3, #4
 800b06e:	623b      	str	r3, [r7, #32]
 800b070:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800b072:	4b5e      	ldr	r3, [pc, #376]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b074:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b076:	4a5d      	ldr	r2, [pc, #372]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b078:	f043 0308 	orr.w	r3, r3, #8
 800b07c:	6313      	str	r3, [r2, #48]	; 0x30
 800b07e:	4b5b      	ldr	r3, [pc, #364]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b080:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b082:	f003 0308 	and.w	r3, r3, #8
 800b086:	61fb      	str	r3, [r7, #28]
 800b088:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800b08a:	4b58      	ldr	r3, [pc, #352]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b08c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b08e:	4a57      	ldr	r2, [pc, #348]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b090:	f043 0310 	orr.w	r3, r3, #16
 800b094:	6313      	str	r3, [r2, #48]	; 0x30
 800b096:	4b55      	ldr	r3, [pc, #340]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b098:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b09a:	f003 0310 	and.w	r3, r3, #16
 800b09e:	61bb      	str	r3, [r7, #24]
 800b0a0:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800b0a2:	4b52      	ldr	r3, [pc, #328]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0a6:	4a51      	ldr	r2, [pc, #324]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0a8:	f043 0320 	orr.w	r3, r3, #32
 800b0ac:	6313      	str	r3, [r2, #48]	; 0x30
 800b0ae:	4b4f      	ldr	r3, [pc, #316]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0b0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0b2:	f003 0320 	and.w	r3, r3, #32
 800b0b6:	617b      	str	r3, [r7, #20]
 800b0b8:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800b0ba:	4b4c      	ldr	r3, [pc, #304]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0be:	4a4b      	ldr	r2, [pc, #300]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0c0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b0c4:	6313      	str	r3, [r2, #48]	; 0x30
 800b0c6:	4b49      	ldr	r3, [pc, #292]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0ca:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b0ce:	613b      	str	r3, [r7, #16]
 800b0d0:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800b0d2:	4b46      	ldr	r3, [pc, #280]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0d6:	4a45      	ldr	r2, [pc, #276]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0d8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b0dc:	6313      	str	r3, [r2, #48]	; 0x30
 800b0de:	4b43      	ldr	r3, [pc, #268]	; (800b1ec <BSP_SDRAM_MspInit+0x1cc>)
 800b0e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b0e2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b0e6:	60fb      	str	r3, [r7, #12]
 800b0e8:	68fb      	ldr	r3, [r7, #12]
  
  /* Common GPIO configuration */
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800b0ea:	2302      	movs	r3, #2
 800b0ec:	633b      	str	r3, [r7, #48]	; 0x30
  gpio_init_structure.Pull      = GPIO_PULLUP;
 800b0ee:	2301      	movs	r3, #1
 800b0f0:	637b      	str	r3, [r7, #52]	; 0x34
  gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 800b0f2:	2302      	movs	r3, #2
 800b0f4:	63bb      	str	r3, [r7, #56]	; 0x38
  gpio_init_structure.Alternate = GPIO_AF12_FMC;
 800b0f6:	230c      	movs	r3, #12
 800b0f8:	63fb      	str	r3, [r7, #60]	; 0x3c
  
  /* GPIOC configuration */
  gpio_init_structure.Pin   = GPIO_PIN_3;
 800b0fa:	2308      	movs	r3, #8
 800b0fc:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &gpio_init_structure);
 800b0fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b102:	4619      	mov	r1, r3
 800b104:	483a      	ldr	r0, [pc, #232]	; (800b1f0 <BSP_SDRAM_MspInit+0x1d0>)
 800b106:	f7f6 fd39 	bl	8001b7c <HAL_GPIO_Init>

  /* GPIOD configuration */
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_8 | GPIO_PIN_9 |
 800b10a:	f24c 7303 	movw	r3, #50947	; 0xc703
 800b10e:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &gpio_init_structure);
 800b110:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b114:	4619      	mov	r1, r3
 800b116:	4837      	ldr	r0, [pc, #220]	; (800b1f4 <BSP_SDRAM_MspInit+0x1d4>)
 800b118:	f7f6 fd30 	bl	8001b7c <HAL_GPIO_Init>

  /* GPIOE configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_7| GPIO_PIN_8 | GPIO_PIN_9 |\
 800b11c:	f64f 7383 	movw	r3, #65411	; 0xff83
 800b120:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 800b122:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b126:	4619      	mov	r1, r3
 800b128:	4833      	ldr	r0, [pc, #204]	; (800b1f8 <BSP_SDRAM_MspInit+0x1d8>)
 800b12a:	f7f6 fd27 	bl	8001b7c <HAL_GPIO_Init>
  
  /* GPIOF configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2| GPIO_PIN_3 | GPIO_PIN_4 |\
 800b12e:	f64f 033f 	movw	r3, #63551	; 0xf83f
 800b132:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_5 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 |\
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &gpio_init_structure);
 800b134:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b138:	4619      	mov	r1, r3
 800b13a:	4830      	ldr	r0, [pc, #192]	; (800b1fc <BSP_SDRAM_MspInit+0x1dc>)
 800b13c:	f7f6 fd1e 	bl	8001b7c <HAL_GPIO_Init>
  
  /* GPIOG configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4| GPIO_PIN_5 | GPIO_PIN_8 |\
 800b140:	f248 1333 	movw	r3, #33075	; 0x8133
 800b144:	62fb      	str	r3, [r7, #44]	; 0x2c
                              GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 800b146:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b14a:	4619      	mov	r1, r3
 800b14c:	482c      	ldr	r0, [pc, #176]	; (800b200 <BSP_SDRAM_MspInit+0x1e0>)
 800b14e:	f7f6 fd15 	bl	8001b7c <HAL_GPIO_Init>

  /* GPIOH configuration */  
  gpio_init_structure.Pin   = GPIO_PIN_3 | GPIO_PIN_5;
 800b152:	2328      	movs	r3, #40	; 0x28
 800b154:	62fb      	str	r3, [r7, #44]	; 0x2c
  HAL_GPIO_Init(GPIOH, &gpio_init_structure); 
 800b156:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800b15a:	4619      	mov	r1, r3
 800b15c:	4829      	ldr	r0, [pc, #164]	; (800b204 <BSP_SDRAM_MspInit+0x1e4>)
 800b15e:	f7f6 fd0d 	bl	8001b7c <HAL_GPIO_Init>
  
  /* Configure common DMA parameters */
  dma_handle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 800b162:	4b29      	ldr	r3, [pc, #164]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b164:	2200      	movs	r2, #0
 800b166:	605a      	str	r2, [r3, #4]
  dma_handle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 800b168:	4b27      	ldr	r3, [pc, #156]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b16a:	2280      	movs	r2, #128	; 0x80
 800b16c:	609a      	str	r2, [r3, #8]
  dma_handle.Init.PeriphInc           = DMA_PINC_ENABLE;
 800b16e:	4b26      	ldr	r3, [pc, #152]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b170:	f44f 7200 	mov.w	r2, #512	; 0x200
 800b174:	60da      	str	r2, [r3, #12]
  dma_handle.Init.MemInc              = DMA_MINC_ENABLE;
 800b176:	4b24      	ldr	r3, [pc, #144]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b178:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800b17c:	611a      	str	r2, [r3, #16]
  dma_handle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 800b17e:	4b22      	ldr	r3, [pc, #136]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b180:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800b184:	615a      	str	r2, [r3, #20]
  dma_handle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 800b186:	4b20      	ldr	r3, [pc, #128]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b188:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800b18c:	619a      	str	r2, [r3, #24]
  dma_handle.Init.Mode                = DMA_NORMAL;
 800b18e:	4b1e      	ldr	r3, [pc, #120]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b190:	2200      	movs	r2, #0
 800b192:	61da      	str	r2, [r3, #28]
  dma_handle.Init.Priority            = DMA_PRIORITY_HIGH;
 800b194:	4b1c      	ldr	r3, [pc, #112]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b196:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800b19a:	621a      	str	r2, [r3, #32]
  dma_handle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;         
 800b19c:	4b1a      	ldr	r3, [pc, #104]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b19e:	2200      	movs	r2, #0
 800b1a0:	625a      	str	r2, [r3, #36]	; 0x24
  dma_handle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 800b1a2:	4b19      	ldr	r3, [pc, #100]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1a4:	2203      	movs	r2, #3
 800b1a6:	629a      	str	r2, [r3, #40]	; 0x28
  dma_handle.Init.MemBurst            = DMA_MBURST_SINGLE;
 800b1a8:	4b17      	ldr	r3, [pc, #92]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1aa:	2200      	movs	r2, #0
 800b1ac:	62da      	str	r2, [r3, #44]	; 0x2c
  dma_handle.Init.PeriphBurst         = DMA_PBURST_SINGLE; 
 800b1ae:	4b16      	ldr	r3, [pc, #88]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1b0:	2200      	movs	r2, #0
 800b1b2:	631a      	str	r2, [r3, #48]	; 0x30
  
  dma_handle.Instance = SDRAM_DMAx_STREAM;
 800b1b4:	4b14      	ldr	r3, [pc, #80]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1b6:	4a15      	ldr	r2, [pc, #84]	; (800b20c <BSP_SDRAM_MspInit+0x1ec>)
 800b1b8:	601a      	str	r2, [r3, #0]
  
   /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dma_handle);
 800b1ba:	687b      	ldr	r3, [r7, #4]
 800b1bc:	4a12      	ldr	r2, [pc, #72]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1be:	631a      	str	r2, [r3, #48]	; 0x30
 800b1c0:	4a11      	ldr	r2, [pc, #68]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1c2:	687b      	ldr	r3, [r7, #4]
 800b1c4:	6393      	str	r3, [r2, #56]	; 0x38
  
  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dma_handle);
 800b1c6:	4810      	ldr	r0, [pc, #64]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1c8:	f7f5 fece 	bl	8000f68 <HAL_DMA_DeInit>
  
  /* Configure the DMA stream */
  HAL_DMA_Init(&dma_handle); 
 800b1cc:	480e      	ldr	r0, [pc, #56]	; (800b208 <BSP_SDRAM_MspInit+0x1e8>)
 800b1ce:	f7f5 fe1d 	bl	8000e0c <HAL_DMA_Init>
  
  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0x0F, 0);
 800b1d2:	2200      	movs	r2, #0
 800b1d4:	210f      	movs	r1, #15
 800b1d6:	2038      	movs	r0, #56	; 0x38
 800b1d8:	f7f5 fd7c 	bl	8000cd4 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
 800b1dc:	2038      	movs	r0, #56	; 0x38
 800b1de:	f7f5 fd95 	bl	8000d0c <HAL_NVIC_EnableIRQ>
}
 800b1e2:	bf00      	nop
 800b1e4:	3740      	adds	r7, #64	; 0x40
 800b1e6:	46bd      	mov	sp, r7
 800b1e8:	bd80      	pop	{r7, pc}
 800b1ea:	bf00      	nop
 800b1ec:	40023800 	.word	0x40023800
 800b1f0:	40020800 	.word	0x40020800
 800b1f4:	40020c00 	.word	0x40020c00
 800b1f8:	40021000 	.word	0x40021000
 800b1fc:	40021400 	.word	0x40021400
 800b200:	40021800 	.word	0x40021800
 800b204:	40021c00 	.word	0x40021c00
 800b208:	20000d54 	.word	0x20000d54
 800b20c:	40026410 	.word	0x40026410

0800b210 <BSP_TS_Init>:
  * @param  ts_SizeX: Maximum X size of the TS area on LCD
  * @param  ts_SizeY: Maximum Y size of the TS area on LCD
  * @retval TS_OK if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_Init(uint16_t ts_SizeX, uint16_t ts_SizeY)
{
 800b210:	b580      	push	{r7, lr}
 800b212:	b084      	sub	sp, #16
 800b214:	af00      	add	r7, sp, #0
 800b216:	4603      	mov	r3, r0
 800b218:	460a      	mov	r2, r1
 800b21a:	80fb      	strh	r3, [r7, #6]
 800b21c:	4613      	mov	r3, r2
 800b21e:	80bb      	strh	r3, [r7, #4]
  uint8_t status = TS_OK;
 800b220:	2300      	movs	r3, #0
 800b222:	73fb      	strb	r3, [r7, #15]
  tsXBoundary = ts_SizeX;
 800b224:	4a14      	ldr	r2, [pc, #80]	; (800b278 <BSP_TS_Init+0x68>)
 800b226:	88fb      	ldrh	r3, [r7, #6]
 800b228:	8013      	strh	r3, [r2, #0]
  tsYBoundary = ts_SizeY;
 800b22a:	4a14      	ldr	r2, [pc, #80]	; (800b27c <BSP_TS_Init+0x6c>)
 800b22c:	88bb      	ldrh	r3, [r7, #4]
 800b22e:	8013      	strh	r3, [r2, #0]
  
  /* Read ID and verify if the touch screen driver is ready */
  ft5336_ts_drv.Init(TS_I2C_ADDRESS);
 800b230:	4b13      	ldr	r3, [pc, #76]	; (800b280 <BSP_TS_Init+0x70>)
 800b232:	681b      	ldr	r3, [r3, #0]
 800b234:	2070      	movs	r0, #112	; 0x70
 800b236:	4798      	blx	r3
  if(ft5336_ts_drv.ReadID(TS_I2C_ADDRESS) == FT5336_ID_VALUE)
 800b238:	4b11      	ldr	r3, [pc, #68]	; (800b280 <BSP_TS_Init+0x70>)
 800b23a:	685b      	ldr	r3, [r3, #4]
 800b23c:	2070      	movs	r0, #112	; 0x70
 800b23e:	4798      	blx	r3
 800b240:	4603      	mov	r3, r0
 800b242:	2b51      	cmp	r3, #81	; 0x51
 800b244:	d111      	bne.n	800b26a <BSP_TS_Init+0x5a>
  { 
    /* Initialize the TS driver structure */
    tsDriver = &ft5336_ts_drv;
 800b246:	4b0f      	ldr	r3, [pc, #60]	; (800b284 <BSP_TS_Init+0x74>)
 800b248:	4a0d      	ldr	r2, [pc, #52]	; (800b280 <BSP_TS_Init+0x70>)
 800b24a:	601a      	str	r2, [r3, #0]
    I2cAddress = TS_I2C_ADDRESS;
 800b24c:	4b0e      	ldr	r3, [pc, #56]	; (800b288 <BSP_TS_Init+0x78>)
 800b24e:	2270      	movs	r2, #112	; 0x70
 800b250:	701a      	strb	r2, [r3, #0]
    tsOrientation = TS_SWAP_XY;
 800b252:	4b0e      	ldr	r3, [pc, #56]	; (800b28c <BSP_TS_Init+0x7c>)
 800b254:	2208      	movs	r2, #8
 800b256:	701a      	strb	r2, [r3, #0]

    /* Initialize the TS driver */
    tsDriver->Start(I2cAddress);
 800b258:	4b0a      	ldr	r3, [pc, #40]	; (800b284 <BSP_TS_Init+0x74>)
 800b25a:	681b      	ldr	r3, [r3, #0]
 800b25c:	68db      	ldr	r3, [r3, #12]
 800b25e:	4a0a      	ldr	r2, [pc, #40]	; (800b288 <BSP_TS_Init+0x78>)
 800b260:	7812      	ldrb	r2, [r2, #0]
 800b262:	b292      	uxth	r2, r2
 800b264:	4610      	mov	r0, r2
 800b266:	4798      	blx	r3
 800b268:	e001      	b.n	800b26e <BSP_TS_Init+0x5e>
  }
  else
  {
    status = TS_DEVICE_NOT_FOUND;
 800b26a:	2303      	movs	r3, #3
 800b26c:	73fb      	strb	r3, [r7, #15]
  }

  return status;
 800b26e:	7bfb      	ldrb	r3, [r7, #15]
}
 800b270:	4618      	mov	r0, r3
 800b272:	3710      	adds	r7, #16
 800b274:	46bd      	mov	sp, r7
 800b276:	bd80      	pop	{r7, pc}
 800b278:	20000db8 	.word	0x20000db8
 800b27c:	20000dba 	.word	0x20000dba
 800b280:	20000008 	.word	0x20000008
 800b284:	20000db4 	.word	0x20000db4
 800b288:	20000dbd 	.word	0x20000dbd
 800b28c:	20000dbc 	.word	0x20000dbc

0800b290 <BSP_TS_GetState>:
  * @brief  Returns status and positions of the touch screen.
  * @param  TS_State: Pointer to touch screen current state structure
  * @retval TS_OK if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_GetState(TS_StateTypeDef *TS_State)
{
 800b290:	b590      	push	{r4, r7, lr}
 800b292:	b097      	sub	sp, #92	; 0x5c
 800b294:	af02      	add	r7, sp, #8
 800b296:	6078      	str	r0, [r7, #4]
  static uint32_t _x[TS_MAX_NB_TOUCH] = {0, 0};
  static uint32_t _y[TS_MAX_NB_TOUCH] = {0, 0};
  uint8_t ts_status = TS_OK;
 800b298:	2300      	movs	r3, #0
 800b29a:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
  uint16_t brute_y[TS_MAX_NB_TOUCH];
  uint16_t x_diff;
  uint16_t y_diff;
  uint32_t index;
#if (TS_MULTI_TOUCH_SUPPORTED == 1)
  uint32_t weight = 0;
 800b29e:	2300      	movs	r3, #0
 800b2a0:	613b      	str	r3, [r7, #16]
  uint32_t area = 0;
 800b2a2:	2300      	movs	r3, #0
 800b2a4:	60fb      	str	r3, [r7, #12]
  uint32_t event = 0;
 800b2a6:	2300      	movs	r3, #0
 800b2a8:	60bb      	str	r3, [r7, #8]
#endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */

  /* Check and update the number of touches active detected */
  TS_State->touchDetected = tsDriver->DetectTouch(I2cAddress);
 800b2aa:	4b97      	ldr	r3, [pc, #604]	; (800b508 <BSP_TS_GetState+0x278>)
 800b2ac:	681b      	ldr	r3, [r3, #0]
 800b2ae:	691b      	ldr	r3, [r3, #16]
 800b2b0:	4a96      	ldr	r2, [pc, #600]	; (800b50c <BSP_TS_GetState+0x27c>)
 800b2b2:	7812      	ldrb	r2, [r2, #0]
 800b2b4:	b292      	uxth	r2, r2
 800b2b6:	4610      	mov	r0, r2
 800b2b8:	4798      	blx	r3
 800b2ba:	4603      	mov	r3, r0
 800b2bc:	461a      	mov	r2, r3
 800b2be:	687b      	ldr	r3, [r7, #4]
 800b2c0:	701a      	strb	r2, [r3, #0]
  
  if(TS_State->touchDetected)
 800b2c2:	687b      	ldr	r3, [r7, #4]
 800b2c4:	781b      	ldrb	r3, [r3, #0]
 800b2c6:	2b00      	cmp	r3, #0
 800b2c8:	f000 81a8 	beq.w	800b61c <BSP_TS_GetState+0x38c>
  {
    for(index=0; index < TS_State->touchDetected; index++)
 800b2cc:	2300      	movs	r3, #0
 800b2ce:	64bb      	str	r3, [r7, #72]	; 0x48
 800b2d0:	e197      	b.n	800b602 <BSP_TS_GetState+0x372>
    {
      /* Get each touch coordinates */
      tsDriver->GetXY(I2cAddress, &(brute_x[index]), &(brute_y[index]));
 800b2d2:	4b8d      	ldr	r3, [pc, #564]	; (800b508 <BSP_TS_GetState+0x278>)
 800b2d4:	681b      	ldr	r3, [r3, #0]
 800b2d6:	695b      	ldr	r3, [r3, #20]
 800b2d8:	4a8c      	ldr	r2, [pc, #560]	; (800b50c <BSP_TS_GetState+0x27c>)
 800b2da:	7812      	ldrb	r2, [r2, #0]
 800b2dc:	b290      	uxth	r0, r2
 800b2de:	f107 0120 	add.w	r1, r7, #32
 800b2e2:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b2e4:	0052      	lsls	r2, r2, #1
 800b2e6:	188c      	adds	r4, r1, r2
 800b2e8:	f107 0114 	add.w	r1, r7, #20
 800b2ec:	6cba      	ldr	r2, [r7, #72]	; 0x48
 800b2ee:	0052      	lsls	r2, r2, #1
 800b2f0:	440a      	add	r2, r1
 800b2f2:	4621      	mov	r1, r4
 800b2f4:	4798      	blx	r3

      if(tsOrientation == TS_SWAP_NONE)
 800b2f6:	4b86      	ldr	r3, [pc, #536]	; (800b510 <BSP_TS_GetState+0x280>)
 800b2f8:	781b      	ldrb	r3, [r3, #0]
 800b2fa:	2b01      	cmp	r3, #1
 800b2fc:	d11b      	bne.n	800b336 <BSP_TS_GetState+0xa6>
      {
        x[index] = brute_x[index];
 800b2fe:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b300:	005b      	lsls	r3, r3, #1
 800b302:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b306:	4413      	add	r3, r2
 800b308:	f833 2c30 	ldrh.w	r2, [r3, #-48]
 800b30c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b30e:	005b      	lsls	r3, r3, #1
 800b310:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b314:	440b      	add	r3, r1
 800b316:	f823 2c18 	strh.w	r2, [r3, #-24]
        y[index] = brute_y[index];
 800b31a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b31c:	005b      	lsls	r3, r3, #1
 800b31e:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b322:	4413      	add	r3, r2
 800b324:	f833 2c3c 	ldrh.w	r2, [r3, #-60]
 800b328:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b32a:	005b      	lsls	r3, r3, #1
 800b32c:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b330:	440b      	add	r3, r1
 800b332:	f823 2c24 	strh.w	r2, [r3, #-36]
      }

      if(tsOrientation & TS_SWAP_X)
 800b336:	4b76      	ldr	r3, [pc, #472]	; (800b510 <BSP_TS_GetState+0x280>)
 800b338:	781b      	ldrb	r3, [r3, #0]
 800b33a:	f003 0302 	and.w	r3, r3, #2
 800b33e:	2b00      	cmp	r3, #0
 800b340:	d010      	beq.n	800b364 <BSP_TS_GetState+0xd4>
      {
        x[index] = 4096 - brute_x[index];
 800b342:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b344:	005b      	lsls	r3, r3, #1
 800b346:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b34a:	4413      	add	r3, r2
 800b34c:	f833 3c30 	ldrh.w	r3, [r3, #-48]
 800b350:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 800b354:	b29a      	uxth	r2, r3
 800b356:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b358:	005b      	lsls	r3, r3, #1
 800b35a:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b35e:	440b      	add	r3, r1
 800b360:	f823 2c18 	strh.w	r2, [r3, #-24]
      }

      if(tsOrientation & TS_SWAP_Y)
 800b364:	4b6a      	ldr	r3, [pc, #424]	; (800b510 <BSP_TS_GetState+0x280>)
 800b366:	781b      	ldrb	r3, [r3, #0]
 800b368:	f003 0304 	and.w	r3, r3, #4
 800b36c:	2b00      	cmp	r3, #0
 800b36e:	d010      	beq.n	800b392 <BSP_TS_GetState+0x102>
      {
        y[index] = 4096 - brute_y[index];
 800b370:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b372:	005b      	lsls	r3, r3, #1
 800b374:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b378:	4413      	add	r3, r2
 800b37a:	f833 3c3c 	ldrh.w	r3, [r3, #-60]
 800b37e:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 800b382:	b29a      	uxth	r2, r3
 800b384:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b386:	005b      	lsls	r3, r3, #1
 800b388:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b38c:	440b      	add	r3, r1
 800b38e:	f823 2c24 	strh.w	r2, [r3, #-36]
      }

      if(tsOrientation & TS_SWAP_XY)
 800b392:	4b5f      	ldr	r3, [pc, #380]	; (800b510 <BSP_TS_GetState+0x280>)
 800b394:	781b      	ldrb	r3, [r3, #0]
 800b396:	f003 0308 	and.w	r3, r3, #8
 800b39a:	2b00      	cmp	r3, #0
 800b39c:	d01b      	beq.n	800b3d6 <BSP_TS_GetState+0x146>
      {
        y[index] = brute_x[index];
 800b39e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3a0:	005b      	lsls	r3, r3, #1
 800b3a2:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b3a6:	4413      	add	r3, r2
 800b3a8:	f833 2c30 	ldrh.w	r2, [r3, #-48]
 800b3ac:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3ae:	005b      	lsls	r3, r3, #1
 800b3b0:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b3b4:	440b      	add	r3, r1
 800b3b6:	f823 2c24 	strh.w	r2, [r3, #-36]
        x[index] = brute_y[index];
 800b3ba:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3bc:	005b      	lsls	r3, r3, #1
 800b3be:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b3c2:	4413      	add	r3, r2
 800b3c4:	f833 2c3c 	ldrh.w	r2, [r3, #-60]
 800b3c8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3ca:	005b      	lsls	r3, r3, #1
 800b3cc:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b3d0:	440b      	add	r3, r1
 800b3d2:	f823 2c18 	strh.w	r2, [r3, #-24]
      }

      x_diff = x[index] > _x[index]? (x[index] - _x[index]): (_x[index] - x[index]);
 800b3d6:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3d8:	005b      	lsls	r3, r3, #1
 800b3da:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b3de:	4413      	add	r3, r2
 800b3e0:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 800b3e4:	4619      	mov	r1, r3
 800b3e6:	4a4b      	ldr	r2, [pc, #300]	; (800b514 <BSP_TS_GetState+0x284>)
 800b3e8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b3ee:	4299      	cmp	r1, r3
 800b3f0:	d90e      	bls.n	800b410 <BSP_TS_GetState+0x180>
 800b3f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b3f4:	005b      	lsls	r3, r3, #1
 800b3f6:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b3fa:	4413      	add	r3, r2
 800b3fc:	f833 2c18 	ldrh.w	r2, [r3, #-24]
 800b400:	4944      	ldr	r1, [pc, #272]	; (800b514 <BSP_TS_GetState+0x284>)
 800b402:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b404:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800b408:	b29b      	uxth	r3, r3
 800b40a:	1ad3      	subs	r3, r2, r3
 800b40c:	b29b      	uxth	r3, r3
 800b40e:	e00d      	b.n	800b42c <BSP_TS_GetState+0x19c>
 800b410:	4a40      	ldr	r2, [pc, #256]	; (800b514 <BSP_TS_GetState+0x284>)
 800b412:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b414:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b418:	b29a      	uxth	r2, r3
 800b41a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b41c:	005b      	lsls	r3, r3, #1
 800b41e:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b422:	440b      	add	r3, r1
 800b424:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 800b428:	1ad3      	subs	r3, r2, r3
 800b42a:	b29b      	uxth	r3, r3
 800b42c:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
      y_diff = y[index] > _y[index]? (y[index] - _y[index]): (_y[index] - y[index]);
 800b430:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b432:	005b      	lsls	r3, r3, #1
 800b434:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b438:	4413      	add	r3, r2
 800b43a:	f833 3c24 	ldrh.w	r3, [r3, #-36]
 800b43e:	4619      	mov	r1, r3
 800b440:	4a35      	ldr	r2, [pc, #212]	; (800b518 <BSP_TS_GetState+0x288>)
 800b442:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b444:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b448:	4299      	cmp	r1, r3
 800b44a:	d90e      	bls.n	800b46a <BSP_TS_GetState+0x1da>
 800b44c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b44e:	005b      	lsls	r3, r3, #1
 800b450:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b454:	4413      	add	r3, r2
 800b456:	f833 2c24 	ldrh.w	r2, [r3, #-36]
 800b45a:	492f      	ldr	r1, [pc, #188]	; (800b518 <BSP_TS_GetState+0x288>)
 800b45c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b45e:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 800b462:	b29b      	uxth	r3, r3
 800b464:	1ad3      	subs	r3, r2, r3
 800b466:	b29b      	uxth	r3, r3
 800b468:	e00d      	b.n	800b486 <BSP_TS_GetState+0x1f6>
 800b46a:	4a2b      	ldr	r2, [pc, #172]	; (800b518 <BSP_TS_GetState+0x288>)
 800b46c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b46e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b472:	b29a      	uxth	r2, r3
 800b474:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b476:	005b      	lsls	r3, r3, #1
 800b478:	f107 0150 	add.w	r1, r7, #80	; 0x50
 800b47c:	440b      	add	r3, r1
 800b47e:	f833 3c24 	ldrh.w	r3, [r3, #-36]
 800b482:	1ad3      	subs	r3, r2, r3
 800b484:	b29b      	uxth	r3, r3
 800b486:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44

      if ((x_diff + y_diff) > 5)
 800b48a:	f8b7 2046 	ldrh.w	r2, [r7, #70]	; 0x46
 800b48e:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 800b492:	4413      	add	r3, r2
 800b494:	2b05      	cmp	r3, #5
 800b496:	dd17      	ble.n	800b4c8 <BSP_TS_GetState+0x238>
      {
        _x[index] = x[index];
 800b498:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b49a:	005b      	lsls	r3, r3, #1
 800b49c:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b4a0:	4413      	add	r3, r2
 800b4a2:	f833 3c18 	ldrh.w	r3, [r3, #-24]
 800b4a6:	4619      	mov	r1, r3
 800b4a8:	4a1a      	ldr	r2, [pc, #104]	; (800b514 <BSP_TS_GetState+0x284>)
 800b4aa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4ac:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        _y[index] = y[index];
 800b4b0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4b2:	005b      	lsls	r3, r3, #1
 800b4b4:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b4b8:	4413      	add	r3, r2
 800b4ba:	f833 3c24 	ldrh.w	r3, [r3, #-36]
 800b4be:	4619      	mov	r1, r3
 800b4c0:	4a15      	ldr	r2, [pc, #84]	; (800b518 <BSP_TS_GetState+0x288>)
 800b4c2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4c4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
      }

      if(I2cAddress == FT5336_I2C_SLAVE_ADDRESS)
 800b4c8:	4b10      	ldr	r3, [pc, #64]	; (800b50c <BSP_TS_GetState+0x27c>)
 800b4ca:	781b      	ldrb	r3, [r3, #0]
 800b4cc:	2b70      	cmp	r3, #112	; 0x70
 800b4ce:	d125      	bne.n	800b51c <BSP_TS_GetState+0x28c>
      {
        TS_State->touchX[index] = x[index];
 800b4d0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4d2:	005b      	lsls	r3, r3, #1
 800b4d4:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b4d8:	4413      	add	r3, r2
 800b4da:	f833 1c18 	ldrh.w	r1, [r3, #-24]
 800b4de:	687a      	ldr	r2, [r7, #4]
 800b4e0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4e2:	005b      	lsls	r3, r3, #1
 800b4e4:	4413      	add	r3, r2
 800b4e6:	460a      	mov	r2, r1
 800b4e8:	805a      	strh	r2, [r3, #2]
        TS_State->touchY[index] = y[index];
 800b4ea:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4ec:	005b      	lsls	r3, r3, #1
 800b4ee:	f107 0250 	add.w	r2, r7, #80	; 0x50
 800b4f2:	4413      	add	r3, r2
 800b4f4:	f833 1c24 	ldrh.w	r1, [r3, #-36]
 800b4f8:	687a      	ldr	r2, [r7, #4]
 800b4fa:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b4fc:	3304      	adds	r3, #4
 800b4fe:	005b      	lsls	r3, r3, #1
 800b500:	4413      	add	r3, r2
 800b502:	460a      	mov	r2, r1
 800b504:	809a      	strh	r2, [r3, #4]
 800b506:	e02c      	b.n	800b562 <BSP_TS_GetState+0x2d2>
 800b508:	20000db4 	.word	0x20000db4
 800b50c:	20000dbd 	.word	0x20000dbd
 800b510:	20000dbc 	.word	0x20000dbc
 800b514:	20000dc0 	.word	0x20000dc0
 800b518:	20000dd4 	.word	0x20000dd4
      }
      else
      {
        /* 2^12 = 4096 : indexes are expressed on a dynamic of 4096 */
        TS_State->touchX[index] = (tsXBoundary * _x[index]) >> 12;
 800b51c:	4b42      	ldr	r3, [pc, #264]	; (800b628 <BSP_TS_GetState+0x398>)
 800b51e:	881b      	ldrh	r3, [r3, #0]
 800b520:	4619      	mov	r1, r3
 800b522:	4a42      	ldr	r2, [pc, #264]	; (800b62c <BSP_TS_GetState+0x39c>)
 800b524:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b526:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b52a:	fb03 f301 	mul.w	r3, r3, r1
 800b52e:	0b1b      	lsrs	r3, r3, #12
 800b530:	b299      	uxth	r1, r3
 800b532:	687a      	ldr	r2, [r7, #4]
 800b534:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b536:	005b      	lsls	r3, r3, #1
 800b538:	4413      	add	r3, r2
 800b53a:	460a      	mov	r2, r1
 800b53c:	805a      	strh	r2, [r3, #2]
        TS_State->touchY[index] = (tsYBoundary * _y[index]) >> 12;
 800b53e:	4b3c      	ldr	r3, [pc, #240]	; (800b630 <BSP_TS_GetState+0x3a0>)
 800b540:	881b      	ldrh	r3, [r3, #0]
 800b542:	4619      	mov	r1, r3
 800b544:	4a3b      	ldr	r2, [pc, #236]	; (800b634 <BSP_TS_GetState+0x3a4>)
 800b546:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b548:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800b54c:	fb03 f301 	mul.w	r3, r3, r1
 800b550:	0b1b      	lsrs	r3, r3, #12
 800b552:	b299      	uxth	r1, r3
 800b554:	687a      	ldr	r2, [r7, #4]
 800b556:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b558:	3304      	adds	r3, #4
 800b55a:	005b      	lsls	r3, r3, #1
 800b55c:	4413      	add	r3, r2
 800b55e:	460a      	mov	r2, r1
 800b560:	809a      	strh	r2, [r3, #4]
      }

#if (TS_MULTI_TOUCH_SUPPORTED == 1)

      /* Get touch info related to the current touch */
      ft5336_TS_GetTouchInfo(I2cAddress, index, &weight, &area, &event);
 800b562:	4b35      	ldr	r3, [pc, #212]	; (800b638 <BSP_TS_GetState+0x3a8>)
 800b564:	781b      	ldrb	r3, [r3, #0]
 800b566:	b298      	uxth	r0, r3
 800b568:	f107 010c 	add.w	r1, r7, #12
 800b56c:	f107 0210 	add.w	r2, r7, #16
 800b570:	f107 0308 	add.w	r3, r7, #8
 800b574:	9300      	str	r3, [sp, #0]
 800b576:	460b      	mov	r3, r1
 800b578:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 800b57a:	f7ff fa01 	bl	800a980 <ft5336_TS_GetTouchInfo>

      /* Update TS_State structure */
      TS_State->touchWeight[index] = weight;
 800b57e:	693b      	ldr	r3, [r7, #16]
 800b580:	b2d9      	uxtb	r1, r3
 800b582:	687a      	ldr	r2, [r7, #4]
 800b584:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b586:	4413      	add	r3, r2
 800b588:	3316      	adds	r3, #22
 800b58a:	460a      	mov	r2, r1
 800b58c:	701a      	strb	r2, [r3, #0]
      TS_State->touchArea[index]   = area;
 800b58e:	68fb      	ldr	r3, [r7, #12]
 800b590:	b2d9      	uxtb	r1, r3
 800b592:	687a      	ldr	r2, [r7, #4]
 800b594:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b596:	4413      	add	r3, r2
 800b598:	3320      	adds	r3, #32
 800b59a:	460a      	mov	r2, r1
 800b59c:	701a      	strb	r2, [r3, #0]

      /* Remap touch event */
      switch(event)
 800b59e:	68bb      	ldr	r3, [r7, #8]
 800b5a0:	2b03      	cmp	r3, #3
 800b5a2:	d827      	bhi.n	800b5f4 <BSP_TS_GetState+0x364>
 800b5a4:	a201      	add	r2, pc, #4	; (adr r2, 800b5ac <BSP_TS_GetState+0x31c>)
 800b5a6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b5aa:	bf00      	nop
 800b5ac:	0800b5bd 	.word	0x0800b5bd
 800b5b0:	0800b5cb 	.word	0x0800b5cb
 800b5b4:	0800b5d9 	.word	0x0800b5d9
 800b5b8:	0800b5e7 	.word	0x0800b5e7
      {
        case FT5336_TOUCH_EVT_FLAG_PRESS_DOWN	:
          TS_State->touchEventId[index] = TOUCH_EVENT_PRESS_DOWN;
 800b5bc:	687a      	ldr	r2, [r7, #4]
 800b5be:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5c0:	4413      	add	r3, r2
 800b5c2:	331b      	adds	r3, #27
 800b5c4:	2201      	movs	r2, #1
 800b5c6:	701a      	strb	r2, [r3, #0]
          break;
 800b5c8:	e018      	b.n	800b5fc <BSP_TS_GetState+0x36c>
        case FT5336_TOUCH_EVT_FLAG_LIFT_UP :
          TS_State->touchEventId[index] = TOUCH_EVENT_LIFT_UP;
 800b5ca:	687a      	ldr	r2, [r7, #4]
 800b5cc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5ce:	4413      	add	r3, r2
 800b5d0:	331b      	adds	r3, #27
 800b5d2:	2202      	movs	r2, #2
 800b5d4:	701a      	strb	r2, [r3, #0]
          break;
 800b5d6:	e011      	b.n	800b5fc <BSP_TS_GetState+0x36c>
        case FT5336_TOUCH_EVT_FLAG_CONTACT :
          TS_State->touchEventId[index] = TOUCH_EVENT_CONTACT;
 800b5d8:	687a      	ldr	r2, [r7, #4]
 800b5da:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5dc:	4413      	add	r3, r2
 800b5de:	331b      	adds	r3, #27
 800b5e0:	2203      	movs	r2, #3
 800b5e2:	701a      	strb	r2, [r3, #0]
          break;
 800b5e4:	e00a      	b.n	800b5fc <BSP_TS_GetState+0x36c>
        case FT5336_TOUCH_EVT_FLAG_NO_EVENT :
          TS_State->touchEventId[index] = TOUCH_EVENT_NO_EVT;
 800b5e6:	687a      	ldr	r2, [r7, #4]
 800b5e8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5ea:	4413      	add	r3, r2
 800b5ec:	331b      	adds	r3, #27
 800b5ee:	2200      	movs	r2, #0
 800b5f0:	701a      	strb	r2, [r3, #0]
          break;
 800b5f2:	e003      	b.n	800b5fc <BSP_TS_GetState+0x36c>
        default :
          ts_status = TS_ERROR;
 800b5f4:	2301      	movs	r3, #1
 800b5f6:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
          break;
 800b5fa:	bf00      	nop
    for(index=0; index < TS_State->touchDetected; index++)
 800b5fc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b5fe:	3301      	adds	r3, #1
 800b600:	64bb      	str	r3, [r7, #72]	; 0x48
 800b602:	687b      	ldr	r3, [r7, #4]
 800b604:	781b      	ldrb	r3, [r3, #0]
 800b606:	461a      	mov	r2, r3
 800b608:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800b60a:	4293      	cmp	r3, r2
 800b60c:	f4ff ae61 	bcc.w	800b2d2 <BSP_TS_GetState+0x42>

    } /* of for(index=0; index < TS_State->touchDetected; index++) */

#if (TS_MULTI_TOUCH_SUPPORTED == 1)
    /* Get gesture Id */
    ts_status = BSP_TS_Get_GestureId(TS_State);
 800b610:	6878      	ldr	r0, [r7, #4]
 800b612:	f000 f813 	bl	800b63c <BSP_TS_Get_GestureId>
 800b616:	4603      	mov	r3, r0
 800b618:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f
#endif /* TS_MULTI_TOUCH_SUPPORTED == 1 */

  } /* end of if(TS_State->touchDetected != 0) */

  return (ts_status);
 800b61c:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
}
 800b620:	4618      	mov	r0, r3
 800b622:	3754      	adds	r7, #84	; 0x54
 800b624:	46bd      	mov	sp, r7
 800b626:	bd90      	pop	{r4, r7, pc}
 800b628:	20000db8 	.word	0x20000db8
 800b62c:	20000dc0 	.word	0x20000dc0
 800b630:	20000dba 	.word	0x20000dba
 800b634:	20000dd4 	.word	0x20000dd4
 800b638:	20000dbd 	.word	0x20000dbd

0800b63c <BSP_TS_Get_GestureId>:
  * @brief  Update gesture Id following a touch detected.
  * @param  TS_State: Pointer to touch screen current state structure
  * @retval TS_OK if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_Get_GestureId(TS_StateTypeDef *TS_State)
{
 800b63c:	b580      	push	{r7, lr}
 800b63e:	b084      	sub	sp, #16
 800b640:	af00      	add	r7, sp, #0
 800b642:	6078      	str	r0, [r7, #4]
  uint32_t gestureId = 0;
 800b644:	2300      	movs	r3, #0
 800b646:	60bb      	str	r3, [r7, #8]
  uint8_t  ts_status = TS_OK;
 800b648:	2300      	movs	r3, #0
 800b64a:	73fb      	strb	r3, [r7, #15]

  /* Get gesture Id */
  ft5336_TS_GetGestureID(I2cAddress, &gestureId);
 800b64c:	4b1f      	ldr	r3, [pc, #124]	; (800b6cc <BSP_TS_Get_GestureId+0x90>)
 800b64e:	781b      	ldrb	r3, [r3, #0]
 800b650:	b29b      	uxth	r3, r3
 800b652:	f107 0208 	add.w	r2, r7, #8
 800b656:	4611      	mov	r1, r2
 800b658:	4618      	mov	r0, r3
 800b65a:	f7ff f978 	bl	800a94e <ft5336_TS_GetGestureID>

  /* Remap gesture Id to a TS_GestureIdTypeDef value */
  switch(gestureId)
 800b65e:	68bb      	ldr	r3, [r7, #8]
 800b660:	2b18      	cmp	r3, #24
 800b662:	d01b      	beq.n	800b69c <BSP_TS_Get_GestureId+0x60>
 800b664:	2b18      	cmp	r3, #24
 800b666:	d806      	bhi.n	800b676 <BSP_TS_Get_GestureId+0x3a>
 800b668:	2b10      	cmp	r3, #16
 800b66a:	d00f      	beq.n	800b68c <BSP_TS_Get_GestureId+0x50>
 800b66c:	2b14      	cmp	r3, #20
 800b66e:	d011      	beq.n	800b694 <BSP_TS_Get_GestureId+0x58>
 800b670:	2b00      	cmp	r3, #0
 800b672:	d007      	beq.n	800b684 <BSP_TS_Get_GestureId+0x48>
 800b674:	e022      	b.n	800b6bc <BSP_TS_Get_GestureId+0x80>
 800b676:	2b40      	cmp	r3, #64	; 0x40
 800b678:	d018      	beq.n	800b6ac <BSP_TS_Get_GestureId+0x70>
 800b67a:	2b49      	cmp	r3, #73	; 0x49
 800b67c:	d01a      	beq.n	800b6b4 <BSP_TS_Get_GestureId+0x78>
 800b67e:	2b1c      	cmp	r3, #28
 800b680:	d010      	beq.n	800b6a4 <BSP_TS_Get_GestureId+0x68>
 800b682:	e01b      	b.n	800b6bc <BSP_TS_Get_GestureId+0x80>
  {
    case FT5336_GEST_ID_NO_GESTURE :
      TS_State->gestureId = GEST_ID_NO_GESTURE;
 800b684:	687b      	ldr	r3, [r7, #4]
 800b686:	2200      	movs	r2, #0
 800b688:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b68a:	e01a      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    case FT5336_GEST_ID_MOVE_UP :
      TS_State->gestureId = GEST_ID_MOVE_UP;
 800b68c:	687b      	ldr	r3, [r7, #4]
 800b68e:	2201      	movs	r2, #1
 800b690:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b692:	e016      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    case FT5336_GEST_ID_MOVE_RIGHT :
      TS_State->gestureId = GEST_ID_MOVE_RIGHT;
 800b694:	687b      	ldr	r3, [r7, #4]
 800b696:	2202      	movs	r2, #2
 800b698:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b69a:	e012      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    case FT5336_GEST_ID_MOVE_DOWN :
      TS_State->gestureId = GEST_ID_MOVE_DOWN;
 800b69c:	687b      	ldr	r3, [r7, #4]
 800b69e:	2203      	movs	r2, #3
 800b6a0:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b6a2:	e00e      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    case FT5336_GEST_ID_MOVE_LEFT :
      TS_State->gestureId = GEST_ID_MOVE_LEFT;
 800b6a4:	687b      	ldr	r3, [r7, #4]
 800b6a6:	2204      	movs	r2, #4
 800b6a8:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b6aa:	e00a      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    case FT5336_GEST_ID_ZOOM_IN :
      TS_State->gestureId = GEST_ID_ZOOM_IN;
 800b6ac:	687b      	ldr	r3, [r7, #4]
 800b6ae:	2205      	movs	r2, #5
 800b6b0:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b6b2:	e006      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    case FT5336_GEST_ID_ZOOM_OUT :
      TS_State->gestureId = GEST_ID_ZOOM_OUT;
 800b6b4:	687b      	ldr	r3, [r7, #4]
 800b6b6:	2206      	movs	r2, #6
 800b6b8:	629a      	str	r2, [r3, #40]	; 0x28
      break;
 800b6ba:	e002      	b.n	800b6c2 <BSP_TS_Get_GestureId+0x86>
    default :
      ts_status = TS_ERROR;
 800b6bc:	2301      	movs	r3, #1
 800b6be:	73fb      	strb	r3, [r7, #15]
      break;
 800b6c0:	bf00      	nop
  } /* of switch(gestureId) */

  return(ts_status);
 800b6c2:	7bfb      	ldrb	r3, [r7, #15]
}
 800b6c4:	4618      	mov	r0, r3
 800b6c6:	3710      	adds	r7, #16
 800b6c8:	46bd      	mov	sp, r7
 800b6ca:	bd80      	pop	{r7, pc}
 800b6cc:	20000dbd 	.word	0x20000dbd

0800b6d0 <lv_color_to32>:
    return ret.full;
#endif
}

static inline uint32_t lv_color_to32(lv_color_t color)
{
 800b6d0:	b480      	push	{r7}
 800b6d2:	b085      	sub	sp, #20
 800b6d4:	af00      	add	r7, sp, #0
 800b6d6:	80b8      	strh	r0, [r7, #4]
    ret.ch.alpha = 0xFF;
    return ret.full;
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
    lv_color32_t ret;
    ret.ch.red   = color.ch.red * 8;   /*(2^8 - 1)/(2^5 - 1) = 255/31 = 8*/
 800b6d8:	797b      	ldrb	r3, [r7, #5]
 800b6da:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800b6de:	b2db      	uxtb	r3, r3
 800b6e0:	00db      	lsls	r3, r3, #3
 800b6e2:	b2db      	uxtb	r3, r3
 800b6e4:	73bb      	strb	r3, [r7, #14]
    ret.ch.green = color.ch.green * 4; /*(2^8 - 1)/(2^6 - 1) = 255/63 = 4*/
 800b6e6:	88bb      	ldrh	r3, [r7, #4]
 800b6e8:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800b6ec:	b2db      	uxtb	r3, r3
 800b6ee:	009b      	lsls	r3, r3, #2
 800b6f0:	b2db      	uxtb	r3, r3
 800b6f2:	737b      	strb	r3, [r7, #13]
    ret.ch.blue  = color.ch.blue * 8;  /*(2^8 - 1)/(2^5 - 1) = 255/31 = 8*/
 800b6f4:	793b      	ldrb	r3, [r7, #4]
 800b6f6:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800b6fa:	b2db      	uxtb	r3, r3
 800b6fc:	00db      	lsls	r3, r3, #3
 800b6fe:	b2db      	uxtb	r3, r3
 800b700:	733b      	strb	r3, [r7, #12]
    ret.ch.alpha = 0xFF;
 800b702:	23ff      	movs	r3, #255	; 0xff
 800b704:	73fb      	strb	r3, [r7, #15]
    return ret.full;
 800b706:	68fb      	ldr	r3, [r7, #12]
    return ret.full;
#endif
#elif LV_COLOR_DEPTH == 32
    return color.full;
#endif
}
 800b708:	4618      	mov	r0, r3
 800b70a:	3714      	adds	r7, #20
 800b70c:	46bd      	mov	sp, r7
 800b70e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b712:	4770      	bx	lr

0800b714 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 800b714:	b480      	push	{r7}
 800b716:	b083      	sub	sp, #12
 800b718:	af00      	add	r7, sp, #0
 800b71a:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 800b71c:	687b      	ldr	r3, [r7, #4]
 800b71e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800b722:	b29a      	uxth	r2, r3
 800b724:	687b      	ldr	r3, [r7, #4]
 800b726:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b72a:	b29b      	uxth	r3, r3
 800b72c:	1ad3      	subs	r3, r2, r3
 800b72e:	b29b      	uxth	r3, r3
 800b730:	3301      	adds	r3, #1
 800b732:	b29b      	uxth	r3, r3
 800b734:	b21b      	sxth	r3, r3
}
 800b736:	4618      	mov	r0, r3
 800b738:	370c      	adds	r7, #12
 800b73a:	46bd      	mov	sp, r7
 800b73c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800b740:	4770      	bx	lr
	...

0800b744 <tft_init>:
/**
 * Initialize your display here
 */

void tft_init(void)
{
 800b744:	b580      	push	{r7, lr}
 800b746:	b08c      	sub	sp, #48	; 0x30
 800b748:	af00      	add	r7, sp, #0
	/* There is only one display on STM32 */
	if(our_disp != NULL)
 800b74a:	4b1b      	ldr	r3, [pc, #108]	; (800b7b8 <tft_init+0x74>)
 800b74c:	681b      	ldr	r3, [r3, #0]
 800b74e:	2b00      	cmp	r3, #0
 800b750:	d001      	beq.n	800b756 <tft_init+0x12>
		abort();
 800b752:	f01b fd01 	bl	8027158 <abort>
    /* LCD Initialization */
    LCD_Init();
 800b756:	f000 fa4b 	bl	800bbf0 <LCD_Init>

    /* LCD Initialization */
    LCD_LayerRgb565Init((uint32_t)my_fb);
 800b75a:	4b18      	ldr	r3, [pc, #96]	; (800b7bc <tft_init+0x78>)
 800b75c:	681b      	ldr	r3, [r3, #0]
 800b75e:	4618      	mov	r0, r3
 800b760:	f000 fac2 	bl	800bce8 <LCD_LayerRgb565Init>

    /* Enable the LCD */
    LCD_DisplayOn();
 800b764:	f000 faf8 	bl	800bd58 <LCD_DisplayOn>

    DMA_Config();
 800b768:	f000 fb14 	bl	800bd94 <DMA_Config>

#if LV_USE_GPU != 0
    DMA2D_Config();
 800b76c:	f000 fbf6 	bl	800bf5c <DMA2D_Config>

   /* LittlevGL requires a buffer where it draws the objects. The buffer's has to be greater than 1 display row*/

	static lv_disp_buf_t disp_buf_1;
	static lv_color_t buf1_1[LV_HOR_RES_MAX * 10];                      /*A buffer for 10 rows*/
	lv_disp_buf_init(&disp_buf_1, buf1_1, NULL, LV_HOR_RES_MAX * 10);   /*Initialize the display buffer*/
 800b770:	f44f 5396 	mov.w	r3, #4800	; 0x12c0
 800b774:	2200      	movs	r2, #0
 800b776:	4912      	ldr	r1, [pc, #72]	; (800b7c0 <tft_init+0x7c>)
 800b778:	4812      	ldr	r0, [pc, #72]	; (800b7c4 <tft_init+0x80>)
 800b77a:	f00f fbea 	bl	801af52 <lv_disp_buf_init>
	/*-----------------------------------
	* Register the display in LittlevGL
	*----------------------------------*/

	lv_disp_drv_t disp_drv;                         /*Descriptor of a display driver*/
	lv_disp_drv_init(&disp_drv);                    /*Basic initialization*/
 800b77e:	1d3b      	adds	r3, r7, #4
 800b780:	4618      	mov	r0, r3
 800b782:	f00f fba2 	bl	801aeca <lv_disp_drv_init>

	/*Set up the functions to access to your display*/

	/*Set the resolution of the display*/
	disp_drv.hor_res = 480;
 800b786:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 800b78a:	80bb      	strh	r3, [r7, #4]
	disp_drv.ver_res = 272;
 800b78c:	f44f 7388 	mov.w	r3, #272	; 0x110
 800b790:	80fb      	strh	r3, [r7, #6]

	/*Used to copy the buffer's content to the display*/
	disp_drv.flush_cb = ex_disp_flush;
 800b792:	4b0d      	ldr	r3, [pc, #52]	; (800b7c8 <tft_init+0x84>)
 800b794:	613b      	str	r3, [r7, #16]

	/*Set a display buffer*/
	disp_drv.buffer = &disp_buf_1;
 800b796:	4b0b      	ldr	r3, [pc, #44]	; (800b7c4 <tft_init+0x80>)
 800b798:	60bb      	str	r3, [r7, #8]

#if LV_USE_GPU
	/*Optionally add functions to access the GPU. (Only in buffered mode, LV_VDB_SIZE != 0)*/

	/*Blend two color array using opacity*/
	disp_drv.gpu_blend_cb = gpu_mem_blend;
 800b79a:	4b0c      	ldr	r3, [pc, #48]	; (800b7cc <tft_init+0x88>)
 800b79c:	623b      	str	r3, [r7, #32]

	/*Fill a memory array with a color*/
	disp_drv.gpu_fill_cb = gpu_mem_fill;
 800b79e:	4b0c      	ldr	r3, [pc, #48]	; (800b7d0 <tft_init+0x8c>)
 800b7a0:	627b      	str	r3, [r7, #36]	; 0x24
#endif

	/*Finally register the driver*/
	our_disp = lv_disp_drv_register(&disp_drv);
 800b7a2:	1d3b      	adds	r3, r7, #4
 800b7a4:	4618      	mov	r0, r3
 800b7a6:	f00f fbf1 	bl	801af8c <lv_disp_drv_register>
 800b7aa:	4602      	mov	r2, r0
 800b7ac:	4b02      	ldr	r3, [pc, #8]	; (800b7b8 <tft_init+0x74>)
 800b7ae:	601a      	str	r2, [r3, #0]
}
 800b7b0:	bf00      	nop
 800b7b2:	3730      	adds	r7, #48	; 0x30
 800b7b4:	46bd      	mov	sp, r7
 800b7b6:	bd80      	pop	{r7, pc}
 800b7b8:	20000f48 	.word	0x20000f48
 800b7bc:	20000034 	.word	0x20000034
 800b7c0:	20000f68 	.word	0x20000f68
 800b7c4:	20000f4c 	.word	0x20000f4c
 800b7c8:	0800b7d5 	.word	0x0800b7d5
 800b7cc:	0800b8e9 	.word	0x0800b8e9
 800b7d0:	0800b945 	.word	0x0800b945

0800b7d4 <ex_disp_flush>:
/* Flush the content of the internal buffer the specific area on the display
 * You can use DMA or any hardware acceleration to do this operation in the background but
 * 'lv_flush_ready()' has to be called when finished
 * This function is required only when LV_VDB_SIZE != 0 in lv_conf.h*/
static void ex_disp_flush(lv_disp_drv_t *drv, const lv_area_t *area, lv_color_t * color_p)
{
 800b7d4:	b580      	push	{r7, lr}
 800b7d6:	b08e      	sub	sp, #56	; 0x38
 800b7d8:	af00      	add	r7, sp, #0
 800b7da:	60f8      	str	r0, [r7, #12]
 800b7dc:	60b9      	str	r1, [r7, #8]
 800b7de:	607a      	str	r2, [r7, #4]
	int32_t x1 = area->x1;
 800b7e0:	68bb      	ldr	r3, [r7, #8]
 800b7e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b7e6:	637b      	str	r3, [r7, #52]	; 0x34
	int32_t x2 = area->x2;
 800b7e8:	68bb      	ldr	r3, [r7, #8]
 800b7ea:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800b7ee:	633b      	str	r3, [r7, #48]	; 0x30
	int32_t y1 = area->y1;
 800b7f0:	68bb      	ldr	r3, [r7, #8]
 800b7f2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800b7f6:	62fb      	str	r3, [r7, #44]	; 0x2c
	int32_t y2 = area->y2;
 800b7f8:	68bb      	ldr	r3, [r7, #8]
 800b7fa:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800b7fe:	62bb      	str	r3, [r7, #40]	; 0x28
    /*Return if the area is out the screen*/

    if(x2 < 0) return;
 800b800:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b802:	2b00      	cmp	r3, #0
 800b804:	db56      	blt.n	800b8b4 <ex_disp_flush+0xe0>
    if(y2 < 0) return;
 800b806:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b808:	2b00      	cmp	r3, #0
 800b80a:	db55      	blt.n	800b8b8 <ex_disp_flush+0xe4>
    if(x1 > TFT_HOR_RES - 1) return;
 800b80c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b80e:	f5b3 7ff0 	cmp.w	r3, #480	; 0x1e0
 800b812:	da53      	bge.n	800b8bc <ex_disp_flush+0xe8>
    if(y1 > TFT_VER_RES - 1) return;
 800b814:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b816:	f5b3 7f88 	cmp.w	r3, #272	; 0x110
 800b81a:	da51      	bge.n	800b8c0 <ex_disp_flush+0xec>

    /*Truncate the area to the screen*/
    int32_t act_x1 = x1 < 0 ? 0 : x1;
 800b81c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b81e:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800b822:	627b      	str	r3, [r7, #36]	; 0x24
    int32_t act_y1 = y1 < 0 ? 0 : y1;
 800b824:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b826:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
 800b82a:	623b      	str	r3, [r7, #32]
    int32_t act_x2 = x2 > TFT_HOR_RES - 1 ? TFT_HOR_RES - 1 : x2;
 800b82c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b82e:	f240 12df 	movw	r2, #479	; 0x1df
 800b832:	4293      	cmp	r3, r2
 800b834:	bfa8      	it	ge
 800b836:	4613      	movge	r3, r2
 800b838:	61fb      	str	r3, [r7, #28]
    int32_t act_y2 = y2 > TFT_VER_RES - 1 ? TFT_VER_RES - 1 : y2;
 800b83a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b83c:	f240 120f 	movw	r2, #271	; 0x10f
 800b840:	4293      	cmp	r3, r2
 800b842:	bfa8      	it	ge
 800b844:	4613      	movge	r3, r2
 800b846:	61bb      	str	r3, [r7, #24]

    x1_flush = act_x1;
 800b848:	4a1f      	ldr	r2, [pc, #124]	; (800b8c8 <ex_disp_flush+0xf4>)
 800b84a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b84c:	6013      	str	r3, [r2, #0]
    y1_flush = act_y1;
 800b84e:	4a1f      	ldr	r2, [pc, #124]	; (800b8cc <ex_disp_flush+0xf8>)
 800b850:	6a3b      	ldr	r3, [r7, #32]
 800b852:	6013      	str	r3, [r2, #0]
    x2_flush = act_x2;
 800b854:	4a1e      	ldr	r2, [pc, #120]	; (800b8d0 <ex_disp_flush+0xfc>)
 800b856:	69fb      	ldr	r3, [r7, #28]
 800b858:	6013      	str	r3, [r2, #0]
    y2_fill = act_y2;
 800b85a:	4a1e      	ldr	r2, [pc, #120]	; (800b8d4 <ex_disp_flush+0x100>)
 800b85c:	69bb      	ldr	r3, [r7, #24]
 800b85e:	6013      	str	r3, [r2, #0]
    y_fill_act = act_y1;
 800b860:	4a1d      	ldr	r2, [pc, #116]	; (800b8d8 <ex_disp_flush+0x104>)
 800b862:	6a3b      	ldr	r3, [r7, #32]
 800b864:	6013      	str	r3, [r2, #0]
    buf_to_flush = color_p;
 800b866:	4a1d      	ldr	r2, [pc, #116]	; (800b8dc <ex_disp_flush+0x108>)
 800b868:	687b      	ldr	r3, [r7, #4]
 800b86a:	6013      	str	r3, [r2, #0]

    /*##-7- Start the DMA transfer using the interrupt mode #*/
    /* Configure the source, destination and buffer size DMA fields and Start DMA Stream transfer */
    /* Enable All the DMA interrupts */
    HAL_StatusTypeDef err;
    uint32_t length = (x2_flush - x1_flush + 1);
 800b86c:	4b18      	ldr	r3, [pc, #96]	; (800b8d0 <ex_disp_flush+0xfc>)
 800b86e:	681a      	ldr	r2, [r3, #0]
 800b870:	4b15      	ldr	r3, [pc, #84]	; (800b8c8 <ex_disp_flush+0xf4>)
 800b872:	681b      	ldr	r3, [r3, #0]
 800b874:	1ad3      	subs	r3, r2, r3
 800b876:	3301      	adds	r3, #1
 800b878:	617b      	str	r3, [r7, #20]
#if LV_COLOR_DEPTH == 24 || LV_COLOR_DEPTH == 32
    length *= 2; /* STM32 DMA uses 16-bit chunks so multiply by 2 for 32-bit color */
#endif
    err = HAL_DMA_Start_IT(&DmaHandle,(uint32_t)buf_to_flush, (uint32_t)&my_fb[y_fill_act * TFT_HOR_RES + x1_flush],
 800b87a:	4b18      	ldr	r3, [pc, #96]	; (800b8dc <ex_disp_flush+0x108>)
 800b87c:	681b      	ldr	r3, [r3, #0]
 800b87e:	4618      	mov	r0, r3
 800b880:	4b17      	ldr	r3, [pc, #92]	; (800b8e0 <ex_disp_flush+0x10c>)
 800b882:	6819      	ldr	r1, [r3, #0]
 800b884:	4b14      	ldr	r3, [pc, #80]	; (800b8d8 <ex_disp_flush+0x104>)
 800b886:	681a      	ldr	r2, [r3, #0]
 800b888:	4613      	mov	r3, r2
 800b88a:	011b      	lsls	r3, r3, #4
 800b88c:	1a9b      	subs	r3, r3, r2
 800b88e:	015b      	lsls	r3, r3, #5
 800b890:	461a      	mov	r2, r3
 800b892:	4b0d      	ldr	r3, [pc, #52]	; (800b8c8 <ex_disp_flush+0xf4>)
 800b894:	681b      	ldr	r3, [r3, #0]
 800b896:	4413      	add	r3, r2
 800b898:	005b      	lsls	r3, r3, #1
 800b89a:	440b      	add	r3, r1
 800b89c:	461a      	mov	r2, r3
 800b89e:	697b      	ldr	r3, [r7, #20]
 800b8a0:	4601      	mov	r1, r0
 800b8a2:	4810      	ldr	r0, [pc, #64]	; (800b8e4 <ex_disp_flush+0x110>)
 800b8a4:	f7f5 fbbe 	bl	8001024 <HAL_DMA_Start_IT>
 800b8a8:	4603      	mov	r3, r0
 800b8aa:	74fb      	strb	r3, [r7, #19]
             length);
    if(err != HAL_OK)
 800b8ac:	7cfb      	ldrb	r3, [r7, #19]
 800b8ae:	2b00      	cmp	r3, #0
 800b8b0:	d007      	beq.n	800b8c2 <ex_disp_flush+0xee>
    {
        while(1);	/*Halt on error*/
 800b8b2:	e7fe      	b.n	800b8b2 <ex_disp_flush+0xde>
    if(x2 < 0) return;
 800b8b4:	bf00      	nop
 800b8b6:	e004      	b.n	800b8c2 <ex_disp_flush+0xee>
    if(y2 < 0) return;
 800b8b8:	bf00      	nop
 800b8ba:	e002      	b.n	800b8c2 <ex_disp_flush+0xee>
    if(x1 > TFT_HOR_RES - 1) return;
 800b8bc:	bf00      	nop
 800b8be:	e000      	b.n	800b8c2 <ex_disp_flush+0xee>
    if(y1 > TFT_VER_RES - 1) return;
 800b8c0:	bf00      	nop
    }
}
 800b8c2:	3738      	adds	r7, #56	; 0x38
 800b8c4:	46bd      	mov	sp, r7
 800b8c6:	bd80      	pop	{r7, pc}
 800b8c8:	20000f30 	.word	0x20000f30
 800b8cc:	20000f34 	.word	0x20000f34
 800b8d0:	20000f38 	.word	0x20000f38
 800b8d4:	20000f3c 	.word	0x20000f3c
 800b8d8:	20000f40 	.word	0x20000f40
 800b8dc:	20000f44 	.word	0x20000f44
 800b8e0:	20000034 	.word	0x20000034
 800b8e4:	20000ed0 	.word	0x20000ed0

0800b8e8 <gpu_mem_blend>:
 * @param src pointer to pixel map. Copy it to 'dest'.
 * @param length number of pixels in 'src'
 * @param opa opacity (0, OPA_TRANSP: transparent ... 255, OPA_COVER, fully cover)
 */
static void gpu_mem_blend(lv_disp_drv_t *disp_drv, lv_color_t * dest, const lv_color_t * src, uint32_t length, lv_opa_t opa)
{
 800b8e8:	b580      	push	{r7, lr}
 800b8ea:	b086      	sub	sp, #24
 800b8ec:	af02      	add	r7, sp, #8
 800b8ee:	60f8      	str	r0, [r7, #12]
 800b8f0:	60b9      	str	r1, [r7, #8]
 800b8f2:	607a      	str	r2, [r7, #4]
 800b8f4:	603b      	str	r3, [r7, #0]
    /*Wait for the previous operation*/
    HAL_DMA2D_PollForTransfer(&Dma2dHandle, 100);
 800b8f6:	2164      	movs	r1, #100	; 0x64
 800b8f8:	4811      	ldr	r0, [pc, #68]	; (800b940 <gpu_mem_blend+0x58>)
 800b8fa:	f7f5 ff28 	bl	800174e <HAL_DMA2D_PollForTransfer>
    Dma2dHandle.Init.Mode         = DMA2D_M2M_BLEND;
 800b8fe:	4b10      	ldr	r3, [pc, #64]	; (800b940 <gpu_mem_blend+0x58>)
 800b900:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800b904:	605a      	str	r2, [r3, #4]
    /* DMA2D Initialization */
    if(HAL_DMA2D_Init(&Dma2dHandle) != HAL_OK)
 800b906:	480e      	ldr	r0, [pc, #56]	; (800b940 <gpu_mem_blend+0x58>)
 800b908:	f7f5 fea8 	bl	800165c <HAL_DMA2D_Init>
 800b90c:	4603      	mov	r3, r0
 800b90e:	2b00      	cmp	r3, #0
 800b910:	d000      	beq.n	800b914 <gpu_mem_blend+0x2c>
    {
        /* Initialization Error */
        while(1);
 800b912:	e7fe      	b.n	800b912 <gpu_mem_blend+0x2a>
    }

    Dma2dHandle.LayerCfg[1].InputAlpha = opa;
 800b914:	7e3b      	ldrb	r3, [r7, #24]
 800b916:	4a0a      	ldr	r2, [pc, #40]	; (800b940 <gpu_mem_blend+0x58>)
 800b918:	6353      	str	r3, [r2, #52]	; 0x34
    HAL_DMA2D_ConfigLayer(&Dma2dHandle, 1);
 800b91a:	2101      	movs	r1, #1
 800b91c:	4808      	ldr	r0, [pc, #32]	; (800b940 <gpu_mem_blend+0x58>)
 800b91e:	f7f5 ffff 	bl	8001920 <HAL_DMA2D_ConfigLayer>
    HAL_DMA2D_BlendingStart(&Dma2dHandle, (uint32_t) src, (uint32_t) dest, (uint32_t)dest, length, 1);
 800b922:	6879      	ldr	r1, [r7, #4]
 800b924:	68ba      	ldr	r2, [r7, #8]
 800b926:	68b8      	ldr	r0, [r7, #8]
 800b928:	2301      	movs	r3, #1
 800b92a:	9301      	str	r3, [sp, #4]
 800b92c:	683b      	ldr	r3, [r7, #0]
 800b92e:	9300      	str	r3, [sp, #0]
 800b930:	4603      	mov	r3, r0
 800b932:	4803      	ldr	r0, [pc, #12]	; (800b940 <gpu_mem_blend+0x58>)
 800b934:	f7f5 fedc 	bl	80016f0 <HAL_DMA2D_BlendingStart>
}
 800b938:	bf00      	nop
 800b93a:	3710      	adds	r7, #16
 800b93c:	46bd      	mov	sp, r7
 800b93e:	bd80      	pop	{r7, pc}
 800b940:	20000de8 	.word	0x20000de8

0800b944 <gpu_mem_fill>:
 * @param length number of pixels in 'src'
 * @param opa opacity (0, OPA_TRANSP: transparent ... 255, OPA_COVER, fully cover)
 */
static void gpu_mem_fill(lv_disp_drv_t *disp_drv, lv_color_t * dest_buf, lv_coord_t dest_width,
        const lv_area_t * fill_area, lv_color_t color)
{
 800b944:	b590      	push	{r4, r7, lr}
 800b946:	b08b      	sub	sp, #44	; 0x2c
 800b948:	af02      	add	r7, sp, #8
 800b94a:	60f8      	str	r0, [r7, #12]
 800b94c:	60b9      	str	r1, [r7, #8]
 800b94e:	603b      	str	r3, [r7, #0]
 800b950:	4613      	mov	r3, r2
 800b952:	80fb      	strh	r3, [r7, #6]
    /*Wait for the previous operation*/
    HAL_DMA2D_PollForTransfer(&Dma2dHandle, 100);
 800b954:	2164      	movs	r1, #100	; 0x64
 800b956:	482e      	ldr	r0, [pc, #184]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b958:	f7f5 fef9 	bl	800174e <HAL_DMA2D_PollForTransfer>

   Dma2dHandle.Init.Mode         = DMA2D_R2M;
 800b95c:	4b2c      	ldr	r3, [pc, #176]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b95e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
 800b962:	605a      	str	r2, [r3, #4]
    /* DMA2D Initialization */
    if(HAL_DMA2D_Init(&Dma2dHandle) != HAL_OK)
 800b964:	482a      	ldr	r0, [pc, #168]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b966:	f7f5 fe79 	bl	800165c <HAL_DMA2D_Init>
 800b96a:	4603      	mov	r3, r0
 800b96c:	2b00      	cmp	r3, #0
 800b96e:	d000      	beq.n	800b972 <gpu_mem_fill+0x2e>
    {
        /* Initialization Error */
        while(1);
 800b970:	e7fe      	b.n	800b970 <gpu_mem_fill+0x2c>
    }

    Dma2dHandle.LayerCfg[1].InputAlpha = 0xff;
 800b972:	4b27      	ldr	r3, [pc, #156]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b974:	22ff      	movs	r2, #255	; 0xff
 800b976:	635a      	str	r2, [r3, #52]	; 0x34
    HAL_DMA2D_ConfigLayer(&Dma2dHandle, 1);
 800b978:	2101      	movs	r1, #1
 800b97a:	4825      	ldr	r0, [pc, #148]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b97c:	f7f5 ffd0 	bl	8001920 <HAL_DMA2D_ConfigLayer>

   lv_color_t * dest_buf_ofs = dest_buf;
 800b980:	68bb      	ldr	r3, [r7, #8]
 800b982:	61fb      	str	r3, [r7, #28]

   dest_buf_ofs += dest_width * fill_area->y1;
 800b984:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b988:	683a      	ldr	r2, [r7, #0]
 800b98a:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 800b98e:	fb02 f303 	mul.w	r3, r2, r3
 800b992:	005b      	lsls	r3, r3, #1
 800b994:	69fa      	ldr	r2, [r7, #28]
 800b996:	4413      	add	r3, r2
 800b998:	61fb      	str	r3, [r7, #28]
   dest_buf_ofs += fill_area->x1;
 800b99a:	683b      	ldr	r3, [r7, #0]
 800b99c:	f9b3 3000 	ldrsh.w	r3, [r3]
 800b9a0:	005b      	lsls	r3, r3, #1
 800b9a2:	69fa      	ldr	r2, [r7, #28]
 800b9a4:	4413      	add	r3, r2
 800b9a6:	61fb      	str	r3, [r7, #28]
   lv_coord_t area_w = lv_area_get_width(fill_area);
 800b9a8:	6838      	ldr	r0, [r7, #0]
 800b9aa:	f7ff feb3 	bl	800b714 <lv_area_get_width>
 800b9ae:	4603      	mov	r3, r0
 800b9b0:	82fb      	strh	r3, [r7, #22]

   uint32_t i;
   for(i = fill_area->y1; i <= fill_area->y2; i++) {
 800b9b2:	683b      	ldr	r3, [r7, #0]
 800b9b4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800b9b8:	61bb      	str	r3, [r7, #24]
 800b9ba:	e01d      	b.n	800b9f8 <gpu_mem_fill+0xb4>
	   /*Wait for the previous operation*/
	   HAL_DMA2D_PollForTransfer(&Dma2dHandle, 100);
 800b9bc:	2164      	movs	r1, #100	; 0x64
 800b9be:	4814      	ldr	r0, [pc, #80]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b9c0:	f7f5 fec5 	bl	800174e <HAL_DMA2D_PollForTransfer>
	   HAL_DMA2D_BlendingStart(&Dma2dHandle, (uint32_t) lv_color_to32(color), (uint32_t) dest_buf_ofs, (uint32_t)dest_buf_ofs, area_w, 1);
 800b9c4:	8e38      	ldrh	r0, [r7, #48]	; 0x30
 800b9c6:	f7ff fe83 	bl	800b6d0 <lv_color_to32>
 800b9ca:	4604      	mov	r4, r0
 800b9cc:	69f9      	ldr	r1, [r7, #28]
 800b9ce:	69f8      	ldr	r0, [r7, #28]
 800b9d0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 800b9d4:	2201      	movs	r2, #1
 800b9d6:	9201      	str	r2, [sp, #4]
 800b9d8:	9300      	str	r3, [sp, #0]
 800b9da:	4603      	mov	r3, r0
 800b9dc:	460a      	mov	r2, r1
 800b9de:	4621      	mov	r1, r4
 800b9e0:	480b      	ldr	r0, [pc, #44]	; (800ba10 <gpu_mem_fill+0xcc>)
 800b9e2:	f7f5 fe85 	bl	80016f0 <HAL_DMA2D_BlendingStart>
	   dest_buf_ofs += dest_width;
 800b9e6:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800b9ea:	005b      	lsls	r3, r3, #1
 800b9ec:	69fa      	ldr	r2, [r7, #28]
 800b9ee:	4413      	add	r3, r2
 800b9f0:	61fb      	str	r3, [r7, #28]
   for(i = fill_area->y1; i <= fill_area->y2; i++) {
 800b9f2:	69bb      	ldr	r3, [r7, #24]
 800b9f4:	3301      	adds	r3, #1
 800b9f6:	61bb      	str	r3, [r7, #24]
 800b9f8:	683b      	ldr	r3, [r7, #0]
 800b9fa:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800b9fe:	461a      	mov	r2, r3
 800ba00:	69bb      	ldr	r3, [r7, #24]
 800ba02:	4293      	cmp	r3, r2
 800ba04:	d9da      	bls.n	800b9bc <gpu_mem_fill+0x78>
   }
}
 800ba06:	bf00      	nop
 800ba08:	3724      	adds	r7, #36	; 0x24
 800ba0a:	46bd      	mov	sp, r7
 800ba0c:	bd90      	pop	{r4, r7, pc}
 800ba0e:	bf00      	nop
 800ba10:	20000de8 	.word	0x20000de8

0800ba14 <LCD_MspInit>:

/**
 * @brief Configure LCD pins, and peripheral clocks.
 */
static void LCD_MspInit(void)
{
 800ba14:	b580      	push	{r7, lr}
 800ba16:	b08e      	sub	sp, #56	; 0x38
 800ba18:	af00      	add	r7, sp, #0
    GPIO_InitTypeDef gpio_init_structure;

    /* Enable the LTDC and DMA2D clocks */
    __HAL_RCC_LTDC_CLK_ENABLE();
 800ba1a:	4b64      	ldr	r3, [pc, #400]	; (800bbac <LCD_MspInit+0x198>)
 800ba1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ba1e:	4a63      	ldr	r2, [pc, #396]	; (800bbac <LCD_MspInit+0x198>)
 800ba20:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800ba24:	6453      	str	r3, [r2, #68]	; 0x44
 800ba26:	4b61      	ldr	r3, [pc, #388]	; (800bbac <LCD_MspInit+0x198>)
 800ba28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ba2a:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800ba2e:	623b      	str	r3, [r7, #32]
 800ba30:	6a3b      	ldr	r3, [r7, #32]
#if LV_USE_GPU != 0
    __HAL_RCC_DMA2D_CLK_ENABLE();
 800ba32:	4b5e      	ldr	r3, [pc, #376]	; (800bbac <LCD_MspInit+0x198>)
 800ba34:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba36:	4a5d      	ldr	r2, [pc, #372]	; (800bbac <LCD_MspInit+0x198>)
 800ba38:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800ba3c:	6313      	str	r3, [r2, #48]	; 0x30
 800ba3e:	4b5b      	ldr	r3, [pc, #364]	; (800bbac <LCD_MspInit+0x198>)
 800ba40:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba42:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 800ba46:	61fb      	str	r3, [r7, #28]
 800ba48:	69fb      	ldr	r3, [r7, #28]
#endif
    /* Enable GPIOs clock */
    __HAL_RCC_GPIOE_CLK_ENABLE();
 800ba4a:	4b58      	ldr	r3, [pc, #352]	; (800bbac <LCD_MspInit+0x198>)
 800ba4c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba4e:	4a57      	ldr	r2, [pc, #348]	; (800bbac <LCD_MspInit+0x198>)
 800ba50:	f043 0310 	orr.w	r3, r3, #16
 800ba54:	6313      	str	r3, [r2, #48]	; 0x30
 800ba56:	4b55      	ldr	r3, [pc, #340]	; (800bbac <LCD_MspInit+0x198>)
 800ba58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba5a:	f003 0310 	and.w	r3, r3, #16
 800ba5e:	61bb      	str	r3, [r7, #24]
 800ba60:	69bb      	ldr	r3, [r7, #24]
    __HAL_RCC_GPIOG_CLK_ENABLE();
 800ba62:	4b52      	ldr	r3, [pc, #328]	; (800bbac <LCD_MspInit+0x198>)
 800ba64:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba66:	4a51      	ldr	r2, [pc, #324]	; (800bbac <LCD_MspInit+0x198>)
 800ba68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ba6c:	6313      	str	r3, [r2, #48]	; 0x30
 800ba6e:	4b4f      	ldr	r3, [pc, #316]	; (800bbac <LCD_MspInit+0x198>)
 800ba70:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba72:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800ba76:	617b      	str	r3, [r7, #20]
 800ba78:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_GPIOI_CLK_ENABLE();
 800ba7a:	4b4c      	ldr	r3, [pc, #304]	; (800bbac <LCD_MspInit+0x198>)
 800ba7c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba7e:	4a4b      	ldr	r2, [pc, #300]	; (800bbac <LCD_MspInit+0x198>)
 800ba80:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800ba84:	6313      	str	r3, [r2, #48]	; 0x30
 800ba86:	4b49      	ldr	r3, [pc, #292]	; (800bbac <LCD_MspInit+0x198>)
 800ba88:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba8a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800ba8e:	613b      	str	r3, [r7, #16]
 800ba90:	693b      	ldr	r3, [r7, #16]
    __HAL_RCC_GPIOJ_CLK_ENABLE();
 800ba92:	4b46      	ldr	r3, [pc, #280]	; (800bbac <LCD_MspInit+0x198>)
 800ba94:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800ba96:	4a45      	ldr	r2, [pc, #276]	; (800bbac <LCD_MspInit+0x198>)
 800ba98:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800ba9c:	6313      	str	r3, [r2, #48]	; 0x30
 800ba9e:	4b43      	ldr	r3, [pc, #268]	; (800bbac <LCD_MspInit+0x198>)
 800baa0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800baa2:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800baa6:	60fb      	str	r3, [r7, #12]
 800baa8:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOK_CLK_ENABLE();
 800baaa:	4b40      	ldr	r3, [pc, #256]	; (800bbac <LCD_MspInit+0x198>)
 800baac:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800baae:	4a3f      	ldr	r2, [pc, #252]	; (800bbac <LCD_MspInit+0x198>)
 800bab0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800bab4:	6313      	str	r3, [r2, #48]	; 0x30
 800bab6:	4b3d      	ldr	r3, [pc, #244]	; (800bbac <LCD_MspInit+0x198>)
 800bab8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800baba:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800babe:	60bb      	str	r3, [r7, #8]
 800bac0:	68bb      	ldr	r3, [r7, #8]
    LCD_DISP_GPIO_CLK_ENABLE();
 800bac2:	4b3a      	ldr	r3, [pc, #232]	; (800bbac <LCD_MspInit+0x198>)
 800bac4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bac6:	4a39      	ldr	r2, [pc, #228]	; (800bbac <LCD_MspInit+0x198>)
 800bac8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800bacc:	6313      	str	r3, [r2, #48]	; 0x30
 800bace:	4b37      	ldr	r3, [pc, #220]	; (800bbac <LCD_MspInit+0x198>)
 800bad0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bad2:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800bad6:	607b      	str	r3, [r7, #4]
 800bad8:	687b      	ldr	r3, [r7, #4]
    LCD_BL_CTRL_GPIO_CLK_ENABLE();
 800bada:	4b34      	ldr	r3, [pc, #208]	; (800bbac <LCD_MspInit+0x198>)
 800badc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bade:	4a33      	ldr	r2, [pc, #204]	; (800bbac <LCD_MspInit+0x198>)
 800bae0:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800bae4:	6313      	str	r3, [r2, #48]	; 0x30
 800bae6:	4b31      	ldr	r3, [pc, #196]	; (800bbac <LCD_MspInit+0x198>)
 800bae8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800baea:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800baee:	603b      	str	r3, [r7, #0]
 800baf0:	683b      	ldr	r3, [r7, #0]

    /*** LTDC Pins configuration ***/
    /* GPIOE configuration */
    gpio_init_structure.Pin       = GPIO_PIN_4;
 800baf2:	2310      	movs	r3, #16
 800baf4:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800baf6:	2302      	movs	r3, #2
 800baf8:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Pull      = GPIO_NOPULL;
 800bafa:	2300      	movs	r3, #0
 800bafc:	62fb      	str	r3, [r7, #44]	; 0x2c
    gpio_init_structure.Speed     = GPIO_SPEED_FAST;
 800bafe:	2302      	movs	r3, #2
 800bb00:	633b      	str	r3, [r7, #48]	; 0x30
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 800bb02:	230e      	movs	r3, #14
 800bb04:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOE, &gpio_init_structure);
 800bb06:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb0a:	4619      	mov	r1, r3
 800bb0c:	4828      	ldr	r0, [pc, #160]	; (800bbb0 <LCD_MspInit+0x19c>)
 800bb0e:	f7f6 f835 	bl	8001b7c <HAL_GPIO_Init>

    /* GPIOG configuration */
    gpio_init_structure.Pin       = GPIO_PIN_12;
 800bb12:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bb16:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800bb18:	2302      	movs	r3, #2
 800bb1a:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = GPIO_AF9_LTDC;
 800bb1c:	2309      	movs	r3, #9
 800bb1e:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOG, &gpio_init_structure);
 800bb20:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb24:	4619      	mov	r1, r3
 800bb26:	4823      	ldr	r0, [pc, #140]	; (800bbb4 <LCD_MspInit+0x1a0>)
 800bb28:	f7f6 f828 	bl	8001b7c <HAL_GPIO_Init>

    /* GPIOI LTDC alternate configuration */
    gpio_init_structure.Pin       = GPIO_PIN_9 | GPIO_PIN_10 | \
 800bb2c:	f44f 4366 	mov.w	r3, #58880	; 0xe600
 800bb30:	627b      	str	r3, [r7, #36]	; 0x24
            GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800bb32:	2302      	movs	r3, #2
 800bb34:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 800bb36:	230e      	movs	r3, #14
 800bb38:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOI, &gpio_init_structure);
 800bb3a:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb3e:	4619      	mov	r1, r3
 800bb40:	481d      	ldr	r0, [pc, #116]	; (800bbb8 <LCD_MspInit+0x1a4>)
 800bb42:	f7f6 f81b 	bl	8001b7c <HAL_GPIO_Init>

    /* GPIOJ configuration */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | \
 800bb46:	f64e 73ff 	movw	r3, #61439	; 0xefff
 800bb4a:	627b      	str	r3, [r7, #36]	; 0x24
            GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 | \
            GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | \
            GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15;
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800bb4c:	2302      	movs	r3, #2
 800bb4e:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 800bb50:	230e      	movs	r3, #14
 800bb52:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOJ, &gpio_init_structure);
 800bb54:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb58:	4619      	mov	r1, r3
 800bb5a:	4818      	ldr	r0, [pc, #96]	; (800bbbc <LCD_MspInit+0x1a8>)
 800bb5c:	f7f6 f80e 	bl	8001b7c <HAL_GPIO_Init>

    /* GPIOK configuration */
    gpio_init_structure.Pin       = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_4 | \
 800bb60:	23f7      	movs	r3, #247	; 0xf7
 800bb62:	627b      	str	r3, [r7, #36]	; 0x24
            GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
    gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 800bb64:	2302      	movs	r3, #2
 800bb66:	62bb      	str	r3, [r7, #40]	; 0x28
    gpio_init_structure.Alternate = GPIO_AF14_LTDC;
 800bb68:	230e      	movs	r3, #14
 800bb6a:	637b      	str	r3, [r7, #52]	; 0x34
    HAL_GPIO_Init(GPIOK, &gpio_init_structure);
 800bb6c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb70:	4619      	mov	r1, r3
 800bb72:	4813      	ldr	r0, [pc, #76]	; (800bbc0 <LCD_MspInit+0x1ac>)
 800bb74:	f7f6 f802 	bl	8001b7c <HAL_GPIO_Init>

    /* LCD_DISP GPIO configuration */
    gpio_init_structure.Pin       = LCD_DISP_PIN;     /* LCD_DISP pin has to be manually controlled */
 800bb78:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800bb7c:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
 800bb7e:	2301      	movs	r3, #1
 800bb80:	62bb      	str	r3, [r7, #40]	; 0x28
    HAL_GPIO_Init(LCD_DISP_GPIO_PORT, &gpio_init_structure);
 800bb82:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb86:	4619      	mov	r1, r3
 800bb88:	480b      	ldr	r0, [pc, #44]	; (800bbb8 <LCD_MspInit+0x1a4>)
 800bb8a:	f7f5 fff7 	bl	8001b7c <HAL_GPIO_Init>

    /* LCD_BL_CTRL GPIO configuration */
    gpio_init_structure.Pin       = LCD_BL_CTRL_PIN;  /* LCD_BL_CTRL pin has to be manually controlled */
 800bb8e:	2308      	movs	r3, #8
 800bb90:	627b      	str	r3, [r7, #36]	; 0x24
    gpio_init_structure.Mode      = GPIO_MODE_OUTPUT_PP;
 800bb92:	2301      	movs	r3, #1
 800bb94:	62bb      	str	r3, [r7, #40]	; 0x28
    HAL_GPIO_Init(LCD_BL_CTRL_GPIO_PORT, &gpio_init_structure);
 800bb96:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800bb9a:	4619      	mov	r1, r3
 800bb9c:	4808      	ldr	r0, [pc, #32]	; (800bbc0 <LCD_MspInit+0x1ac>)
 800bb9e:	f7f5 ffed 	bl	8001b7c <HAL_GPIO_Init>
}
 800bba2:	bf00      	nop
 800bba4:	3738      	adds	r7, #56	; 0x38
 800bba6:	46bd      	mov	sp, r7
 800bba8:	bd80      	pop	{r7, pc}
 800bbaa:	bf00      	nop
 800bbac:	40023800 	.word	0x40023800
 800bbb0:	40021000 	.word	0x40021000
 800bbb4:	40021800 	.word	0x40021800
 800bbb8:	40022000 	.word	0x40022000
 800bbbc:	40022400 	.word	0x40022400
 800bbc0:	40022800 	.word	0x40022800

0800bbc4 <LCD_ClockConfig>:

/**
 * @brief Configure LTDC PLL.
 */
static void LCD_ClockConfig(void)
{
 800bbc4:	b580      	push	{r7, lr}
 800bbc6:	af00      	add	r7, sp, #0
    /* RK043FN48H LCD clock configuration */
    /* PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 Mhz */
    /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN = 192 Mhz */
    /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/5 = 38.4 Mhz */
    /* LTDC clock frequency = PLLLCDCLK / LTDC_PLLSAI_DIVR_4 = 38.4/4 = 9.6Mhz */
    periph_clk_init_struct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 800bbc8:	4b08      	ldr	r3, [pc, #32]	; (800bbec <LCD_ClockConfig+0x28>)
 800bbca:	2208      	movs	r2, #8
 800bbcc:	601a      	str	r2, [r3, #0]
    periph_clk_init_struct.PLLSAI.PLLSAIN = 192;
 800bbce:	4b07      	ldr	r3, [pc, #28]	; (800bbec <LCD_ClockConfig+0x28>)
 800bbd0:	22c0      	movs	r2, #192	; 0xc0
 800bbd2:	615a      	str	r2, [r3, #20]
    periph_clk_init_struct.PLLSAI.PLLSAIR = RK043FN48H_FREQUENCY_DIVIDER;
 800bbd4:	4b05      	ldr	r3, [pc, #20]	; (800bbec <LCD_ClockConfig+0x28>)
 800bbd6:	2205      	movs	r2, #5
 800bbd8:	61da      	str	r2, [r3, #28]
    periph_clk_init_struct.PLLSAIDivR = RCC_PLLSAIDIVR_4;
 800bbda:	4b04      	ldr	r3, [pc, #16]	; (800bbec <LCD_ClockConfig+0x28>)
 800bbdc:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800bbe0:	62da      	str	r2, [r3, #44]	; 0x2c
    HAL_RCCEx_PeriphCLKConfig(&periph_clk_init_struct);
 800bbe2:	4802      	ldr	r0, [pc, #8]	; (800bbec <LCD_ClockConfig+0x28>)
 800bbe4:	f7f9 f83e 	bl	8004c64 <HAL_RCCEx_PeriphCLKConfig>
}
 800bbe8:	bf00      	nop
 800bbea:	bd80      	pop	{r7, pc}
 800bbec:	200034e8 	.word	0x200034e8

0800bbf0 <LCD_Init>:
/**
  * @brief  Initializes the LCD.
  * @retval LCD state
  */
static uint8_t LCD_Init(void)
{
 800bbf0:	b580      	push	{r7, lr}
 800bbf2:	b082      	sub	sp, #8
 800bbf4:	af00      	add	r7, sp, #0
    /* Select the used LCD */

    /* The RK043FN48H LCD 480x272 is selected */
    /* Timing Configuration */
    hLtdcHandler.Init.HorizontalSync = (RK043FN48H_HSYNC - 1);
 800bbf6:	4b37      	ldr	r3, [pc, #220]	; (800bcd4 <LCD_Init+0xe4>)
 800bbf8:	2228      	movs	r2, #40	; 0x28
 800bbfa:	615a      	str	r2, [r3, #20]
    hLtdcHandler.Init.VerticalSync = (RK043FN48H_VSYNC - 1);
 800bbfc:	4b35      	ldr	r3, [pc, #212]	; (800bcd4 <LCD_Init+0xe4>)
 800bbfe:	2209      	movs	r2, #9
 800bc00:	619a      	str	r2, [r3, #24]
    hLtdcHandler.Init.AccumulatedHBP = (RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
 800bc02:	4b34      	ldr	r3, [pc, #208]	; (800bcd4 <LCD_Init+0xe4>)
 800bc04:	2235      	movs	r2, #53	; 0x35
 800bc06:	61da      	str	r2, [r3, #28]
    hLtdcHandler.Init.AccumulatedVBP = (RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
 800bc08:	4b32      	ldr	r3, [pc, #200]	; (800bcd4 <LCD_Init+0xe4>)
 800bc0a:	220b      	movs	r2, #11
 800bc0c:	621a      	str	r2, [r3, #32]
    hLtdcHandler.Init.AccumulatedActiveH = (RK043FN48H_HEIGHT + RK043FN48H_VSYNC + RK043FN48H_VBP - 1);
 800bc0e:	4b31      	ldr	r3, [pc, #196]	; (800bcd4 <LCD_Init+0xe4>)
 800bc10:	f240 121b 	movw	r2, #283	; 0x11b
 800bc14:	629a      	str	r2, [r3, #40]	; 0x28
    hLtdcHandler.Init.AccumulatedActiveW = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP - 1);
 800bc16:	4b2f      	ldr	r3, [pc, #188]	; (800bcd4 <LCD_Init+0xe4>)
 800bc18:	f240 2215 	movw	r2, #533	; 0x215
 800bc1c:	625a      	str	r2, [r3, #36]	; 0x24
    hLtdcHandler.Init.TotalHeigh = (RK043FN48H_HEIGHT + RK043FN48H_VSYNC + RK043FN48H_VBP + RK043FN48H_VFP - 1);
 800bc1e:	4b2d      	ldr	r3, [pc, #180]	; (800bcd4 <LCD_Init+0xe4>)
 800bc20:	f240 121d 	movw	r2, #285	; 0x11d
 800bc24:	631a      	str	r2, [r3, #48]	; 0x30
    hLtdcHandler.Init.TotalWidth = (RK043FN48H_WIDTH + RK043FN48H_HSYNC + RK043FN48H_HBP + RK043FN48H_HFP - 1);
 800bc26:	4b2b      	ldr	r3, [pc, #172]	; (800bcd4 <LCD_Init+0xe4>)
 800bc28:	f240 2235 	movw	r2, #565	; 0x235
 800bc2c:	62da      	str	r2, [r3, #44]	; 0x2c

    /* LCD clock configuration */
    LCD_ClockConfig();
 800bc2e:	f7ff ffc9 	bl	800bbc4 <LCD_ClockConfig>

    /* Initialize the LCD pixel width and pixel height */
    hLtdcHandler.LayerCfg->ImageWidth  = RK043FN48H_WIDTH;
 800bc32:	4b28      	ldr	r3, [pc, #160]	; (800bcd4 <LCD_Init+0xe4>)
 800bc34:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 800bc38:	661a      	str	r2, [r3, #96]	; 0x60
    hLtdcHandler.LayerCfg->ImageHeight = RK043FN48H_HEIGHT;
 800bc3a:	4b26      	ldr	r3, [pc, #152]	; (800bcd4 <LCD_Init+0xe4>)
 800bc3c:	f44f 7288 	mov.w	r2, #272	; 0x110
 800bc40:	665a      	str	r2, [r3, #100]	; 0x64

    /* Background value */
    hLtdcHandler.Init.Backcolor.Blue = 0;
 800bc42:	4b24      	ldr	r3, [pc, #144]	; (800bcd4 <LCD_Init+0xe4>)
 800bc44:	2200      	movs	r2, #0
 800bc46:	f883 2034 	strb.w	r2, [r3, #52]	; 0x34
    hLtdcHandler.Init.Backcolor.Green = 0;
 800bc4a:	4b22      	ldr	r3, [pc, #136]	; (800bcd4 <LCD_Init+0xe4>)
 800bc4c:	2200      	movs	r2, #0
 800bc4e:	f883 2035 	strb.w	r2, [r3, #53]	; 0x35
    hLtdcHandler.Init.Backcolor.Red = 0;
 800bc52:	4b20      	ldr	r3, [pc, #128]	; (800bcd4 <LCD_Init+0xe4>)
 800bc54:	2200      	movs	r2, #0
 800bc56:	f883 2036 	strb.w	r2, [r3, #54]	; 0x36

    /* Polarity */
    hLtdcHandler.Init.HSPolarity = LTDC_HSPOLARITY_AL;
 800bc5a:	4b1e      	ldr	r3, [pc, #120]	; (800bcd4 <LCD_Init+0xe4>)
 800bc5c:	2200      	movs	r2, #0
 800bc5e:	605a      	str	r2, [r3, #4]
    hLtdcHandler.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 800bc60:	4b1c      	ldr	r3, [pc, #112]	; (800bcd4 <LCD_Init+0xe4>)
 800bc62:	2200      	movs	r2, #0
 800bc64:	609a      	str	r2, [r3, #8]
    hLtdcHandler.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 800bc66:	4b1b      	ldr	r3, [pc, #108]	; (800bcd4 <LCD_Init+0xe4>)
 800bc68:	2200      	movs	r2, #0
 800bc6a:	60da      	str	r2, [r3, #12]
    hLtdcHandler.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 800bc6c:	4b19      	ldr	r3, [pc, #100]	; (800bcd4 <LCD_Init+0xe4>)
 800bc6e:	2200      	movs	r2, #0
 800bc70:	611a      	str	r2, [r3, #16]
    hLtdcHandler.Instance = LTDC;
 800bc72:	4b18      	ldr	r3, [pc, #96]	; (800bcd4 <LCD_Init+0xe4>)
 800bc74:	4a18      	ldr	r2, [pc, #96]	; (800bcd8 <LCD_Init+0xe8>)
 800bc76:	601a      	str	r2, [r3, #0]

    if(HAL_LTDC_GetState(&hLtdcHandler) == HAL_LTDC_STATE_RESET)
 800bc78:	4816      	ldr	r0, [pc, #88]	; (800bcd4 <LCD_Init+0xe4>)
 800bc7a:	f7f8 f97b 	bl	8003f74 <HAL_LTDC_GetState>
 800bc7e:	4603      	mov	r3, r0
 800bc80:	2b00      	cmp	r3, #0
 800bc82:	d101      	bne.n	800bc88 <LCD_Init+0x98>
    {
        /* Initialize the LCD Msp: this __weak function can be rewritten by the application */
        LCD_MspInit();
 800bc84:	f7ff fec6 	bl	800ba14 <LCD_MspInit>
    }
    HAL_LTDC_Init(&hLtdcHandler);
 800bc88:	4812      	ldr	r0, [pc, #72]	; (800bcd4 <LCD_Init+0xe4>)
 800bc8a:	f7f8 f865 	bl	8003d58 <HAL_LTDC_Init>

    /* Assert display enable LCD_DISP pin */
    HAL_GPIO_WritePin(LCD_DISP_GPIO_PORT, LCD_DISP_PIN, GPIO_PIN_SET);
 800bc8e:	2201      	movs	r2, #1
 800bc90:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800bc94:	4811      	ldr	r0, [pc, #68]	; (800bcdc <LCD_Init+0xec>)
 800bc96:	f7f6 f91b 	bl	8001ed0 <HAL_GPIO_WritePin>

    /* Assert backlight LCD_BL_CTRL pin */
    HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_PORT, LCD_BL_CTRL_PIN, GPIO_PIN_SET);
 800bc9a:	2201      	movs	r2, #1
 800bc9c:	2108      	movs	r1, #8
 800bc9e:	4810      	ldr	r0, [pc, #64]	; (800bce0 <LCD_Init+0xf0>)
 800bca0:	f7f6 f916 	bl	8001ed0 <HAL_GPIO_WritePin>

    BSP_SDRAM_Init();
 800bca4:	f7ff f8fe 	bl	800aea4 <BSP_SDRAM_Init>

    uint32_t i;
    for(i = 0; i < (TFT_HOR_RES * TFT_VER_RES) ; i++)
 800bca8:	2300      	movs	r3, #0
 800bcaa:	607b      	str	r3, [r7, #4]
 800bcac:	e009      	b.n	800bcc2 <LCD_Init+0xd2>
    {
        my_fb[i] = 0;
 800bcae:	4b0d      	ldr	r3, [pc, #52]	; (800bce4 <LCD_Init+0xf4>)
 800bcb0:	681a      	ldr	r2, [r3, #0]
 800bcb2:	687b      	ldr	r3, [r7, #4]
 800bcb4:	005b      	lsls	r3, r3, #1
 800bcb6:	4413      	add	r3, r2
 800bcb8:	2200      	movs	r2, #0
 800bcba:	801a      	strh	r2, [r3, #0]
    for(i = 0; i < (TFT_HOR_RES * TFT_VER_RES) ; i++)
 800bcbc:	687b      	ldr	r3, [r7, #4]
 800bcbe:	3301      	adds	r3, #1
 800bcc0:	607b      	str	r3, [r7, #4]
 800bcc2:	687b      	ldr	r3, [r7, #4]
 800bcc4:	f5b3 3fff 	cmp.w	r3, #130560	; 0x1fe00
 800bcc8:	d3f1      	bcc.n	800bcae <LCD_Init+0xbe>
    }

    return LCD_OK;
 800bcca:	2300      	movs	r3, #0
}
 800bccc:	4618      	mov	r0, r3
 800bcce:	3708      	adds	r7, #8
 800bcd0:	46bd      	mov	sp, r7
 800bcd2:	bd80      	pop	{r7, pc}
 800bcd4:	20000e28 	.word	0x20000e28
 800bcd8:	40016800 	.word	0x40016800
 800bcdc:	40022000 	.word	0x40022000
 800bce0:	40022800 	.word	0x40022800
 800bce4:	20000034 	.word	0x20000034

0800bce8 <LCD_LayerRgb565Init>:

static void LCD_LayerRgb565Init(uint32_t FB_Address)
{
 800bce8:	b580      	push	{r7, lr}
 800bcea:	b090      	sub	sp, #64	; 0x40
 800bcec:	af00      	add	r7, sp, #0
 800bcee:	6078      	str	r0, [r7, #4]
    LTDC_LayerCfgTypeDef  layer_cfg;

    /* Layer Init */
    layer_cfg.WindowX0 = 0;
 800bcf0:	2300      	movs	r3, #0
 800bcf2:	60fb      	str	r3, [r7, #12]
    layer_cfg.WindowX1 = TFT_HOR_RES;
 800bcf4:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 800bcf8:	613b      	str	r3, [r7, #16]
    layer_cfg.WindowY0 = 0;
 800bcfa:	2300      	movs	r3, #0
 800bcfc:	617b      	str	r3, [r7, #20]
    layer_cfg.WindowY1 = TFT_VER_RES;
 800bcfe:	f44f 7388 	mov.w	r3, #272	; 0x110
 800bd02:	61bb      	str	r3, [r7, #24]

#if LV_COLOR_DEPTH == 16
    layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
 800bd04:	2302      	movs	r3, #2
 800bd06:	61fb      	str	r3, [r7, #28]
#elif LV_COLOR_DEPTH == 24 || LV_COLOR_DEPTH == 32
    layer_cfg.PixelFormat = LTDC_PIXEL_FORMAT_ARGB8888;
#else
#error Unsupported color depth (see tft.c)
#endif
    layer_cfg.FBStartAdress = FB_Address;
 800bd08:	687b      	ldr	r3, [r7, #4]
 800bd0a:	633b      	str	r3, [r7, #48]	; 0x30
    layer_cfg.Alpha = 255;
 800bd0c:	23ff      	movs	r3, #255	; 0xff
 800bd0e:	623b      	str	r3, [r7, #32]
    layer_cfg.Alpha0 = 0;
 800bd10:	2300      	movs	r3, #0
 800bd12:	627b      	str	r3, [r7, #36]	; 0x24
    layer_cfg.Backcolor.Blue = 0;
 800bd14:	2300      	movs	r3, #0
 800bd16:	f887 303c 	strb.w	r3, [r7, #60]	; 0x3c
    layer_cfg.Backcolor.Green = 0;
 800bd1a:	2300      	movs	r3, #0
 800bd1c:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
    layer_cfg.Backcolor.Red = 0;
 800bd20:	2300      	movs	r3, #0
 800bd22:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
    layer_cfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
 800bd26:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800bd2a:	62bb      	str	r3, [r7, #40]	; 0x28
    layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 800bd2c:	2307      	movs	r3, #7
 800bd2e:	62fb      	str	r3, [r7, #44]	; 0x2c
    layer_cfg.ImageWidth = TFT_HOR_RES;
 800bd30:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 800bd34:	637b      	str	r3, [r7, #52]	; 0x34
    layer_cfg.ImageHeight = TFT_VER_RES;
 800bd36:	f44f 7388 	mov.w	r3, #272	; 0x110
 800bd3a:	63bb      	str	r3, [r7, #56]	; 0x38

    HAL_LTDC_ConfigLayer(&hLtdcHandler, &layer_cfg, 0);
 800bd3c:	f107 030c 	add.w	r3, r7, #12
 800bd40:	2200      	movs	r2, #0
 800bd42:	4619      	mov	r1, r3
 800bd44:	4803      	ldr	r0, [pc, #12]	; (800bd54 <LCD_LayerRgb565Init+0x6c>)
 800bd46:	f7f8 f8d7 	bl	8003ef8 <HAL_LTDC_ConfigLayer>
}
 800bd4a:	bf00      	nop
 800bd4c:	3740      	adds	r7, #64	; 0x40
 800bd4e:	46bd      	mov	sp, r7
 800bd50:	bd80      	pop	{r7, pc}
 800bd52:	bf00      	nop
 800bd54:	20000e28 	.word	0x20000e28

0800bd58 <LCD_DisplayOn>:

static void LCD_DisplayOn(void)
{
 800bd58:	b580      	push	{r7, lr}
 800bd5a:	af00      	add	r7, sp, #0
    /* Display On */
    __HAL_LTDC_ENABLE(&hLtdcHandler);
 800bd5c:	4b0a      	ldr	r3, [pc, #40]	; (800bd88 <LCD_DisplayOn+0x30>)
 800bd5e:	681b      	ldr	r3, [r3, #0]
 800bd60:	699a      	ldr	r2, [r3, #24]
 800bd62:	4b09      	ldr	r3, [pc, #36]	; (800bd88 <LCD_DisplayOn+0x30>)
 800bd64:	681b      	ldr	r3, [r3, #0]
 800bd66:	f042 0201 	orr.w	r2, r2, #1
 800bd6a:	619a      	str	r2, [r3, #24]
    HAL_GPIO_WritePin(LCD_DISP_GPIO_PORT, LCD_DISP_PIN, GPIO_PIN_SET);        /* Assert LCD_DISP pin */
 800bd6c:	2201      	movs	r2, #1
 800bd6e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800bd72:	4806      	ldr	r0, [pc, #24]	; (800bd8c <LCD_DisplayOn+0x34>)
 800bd74:	f7f6 f8ac 	bl	8001ed0 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(LCD_BL_CTRL_GPIO_PORT, LCD_BL_CTRL_PIN, GPIO_PIN_SET);  /* Assert LCD_BL_CTRL pin */
 800bd78:	2201      	movs	r2, #1
 800bd7a:	2108      	movs	r1, #8
 800bd7c:	4804      	ldr	r0, [pc, #16]	; (800bd90 <LCD_DisplayOn+0x38>)
 800bd7e:	f7f6 f8a7 	bl	8001ed0 <HAL_GPIO_WritePin>
}
 800bd82:	bf00      	nop
 800bd84:	bd80      	pop	{r7, pc}
 800bd86:	bf00      	nop
 800bd88:	20000e28 	.word	0x20000e28
 800bd8c:	40022000 	.word	0x40022000
 800bd90:	40022800 	.word	0x40022800

0800bd94 <DMA_Config>:

static void DMA_Config(void)
{
 800bd94:	b580      	push	{r7, lr}
 800bd96:	b082      	sub	sp, #8
 800bd98:	af00      	add	r7, sp, #0
    /*## -1- Enable DMA2 clock #################################################*/
    __HAL_RCC_DMA2_CLK_ENABLE();
 800bd9a:	4b2a      	ldr	r3, [pc, #168]	; (800be44 <DMA_Config+0xb0>)
 800bd9c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bd9e:	4a29      	ldr	r2, [pc, #164]	; (800be44 <DMA_Config+0xb0>)
 800bda0:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800bda4:	6313      	str	r3, [r2, #48]	; 0x30
 800bda6:	4b27      	ldr	r3, [pc, #156]	; (800be44 <DMA_Config+0xb0>)
 800bda8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800bdaa:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 800bdae:	607b      	str	r3, [r7, #4]
 800bdb0:	687b      	ldr	r3, [r7, #4]

    /*##-2- Select the DMA functional Parameters ###############################*/
    DmaHandle.Init.Channel = CPY_BUF_DMA_CHANNEL;                   /* DMA_CHANNEL_0                    */
 800bdb2:	4b25      	ldr	r3, [pc, #148]	; (800be48 <DMA_Config+0xb4>)
 800bdb4:	2200      	movs	r2, #0
 800bdb6:	605a      	str	r2, [r3, #4]
    DmaHandle.Init.Direction = DMA_MEMORY_TO_MEMORY;                /* M2M transfer mode                */
 800bdb8:	4b23      	ldr	r3, [pc, #140]	; (800be48 <DMA_Config+0xb4>)
 800bdba:	2280      	movs	r2, #128	; 0x80
 800bdbc:	609a      	str	r2, [r3, #8]
    DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;                     /* Peripheral increment mode Enable */
 800bdbe:	4b22      	ldr	r3, [pc, #136]	; (800be48 <DMA_Config+0xb4>)
 800bdc0:	f44f 7200 	mov.w	r2, #512	; 0x200
 800bdc4:	60da      	str	r2, [r3, #12]
    DmaHandle.Init.MemInc = DMA_MINC_ENABLE;                        /* Memory increment mode Enable     */
 800bdc6:	4b20      	ldr	r3, [pc, #128]	; (800be48 <DMA_Config+0xb4>)
 800bdc8:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800bdcc:	611a      	str	r2, [r3, #16]
    DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;   /* Peripheral data alignment : 16bit */
 800bdce:	4b1e      	ldr	r3, [pc, #120]	; (800be48 <DMA_Config+0xb4>)
 800bdd0:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800bdd4:	615a      	str	r2, [r3, #20]
    DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;      /* memory data alignment : 16bit     */
 800bdd6:	4b1c      	ldr	r3, [pc, #112]	; (800be48 <DMA_Config+0xb4>)
 800bdd8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800bddc:	619a      	str	r2, [r3, #24]
    DmaHandle.Init.Mode = DMA_NORMAL;                               /* Normal DMA mode                  */
 800bdde:	4b1a      	ldr	r3, [pc, #104]	; (800be48 <DMA_Config+0xb4>)
 800bde0:	2200      	movs	r2, #0
 800bde2:	61da      	str	r2, [r3, #28]
    DmaHandle.Init.Priority = DMA_PRIORITY_HIGH;                    /* priority level : high            */
 800bde4:	4b18      	ldr	r3, [pc, #96]	; (800be48 <DMA_Config+0xb4>)
 800bde6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800bdea:	621a      	str	r2, [r3, #32]
    DmaHandle.Init.FIFOMode = DMA_FIFOMODE_ENABLE;                  /* FIFO mode enabled                */
 800bdec:	4b16      	ldr	r3, [pc, #88]	; (800be48 <DMA_Config+0xb4>)
 800bdee:	2204      	movs	r2, #4
 800bdf0:	625a      	str	r2, [r3, #36]	; 0x24
    DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL; /* FIFO threshold: 1/4 full   */
 800bdf2:	4b15      	ldr	r3, [pc, #84]	; (800be48 <DMA_Config+0xb4>)
 800bdf4:	2200      	movs	r2, #0
 800bdf6:	629a      	str	r2, [r3, #40]	; 0x28
    DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;                    /* Memory burst                     */
 800bdf8:	4b13      	ldr	r3, [pc, #76]	; (800be48 <DMA_Config+0xb4>)
 800bdfa:	2200      	movs	r2, #0
 800bdfc:	62da      	str	r2, [r3, #44]	; 0x2c
    DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;                 /* Peripheral burst                 */
 800bdfe:	4b12      	ldr	r3, [pc, #72]	; (800be48 <DMA_Config+0xb4>)
 800be00:	2200      	movs	r2, #0
 800be02:	631a      	str	r2, [r3, #48]	; 0x30

    /*##-3- Select the DMA instance to be used for the transfer : DMA2_Stream0 #*/
    DmaHandle.Instance = CPY_BUF_DMA_STREAM;
 800be04:	4b10      	ldr	r3, [pc, #64]	; (800be48 <DMA_Config+0xb4>)
 800be06:	4a11      	ldr	r2, [pc, #68]	; (800be4c <DMA_Config+0xb8>)
 800be08:	601a      	str	r2, [r3, #0]

    /*##-4- Initialize the DMA stream ##########################################*/
    if(HAL_DMA_Init(&DmaHandle) != HAL_OK)
 800be0a:	480f      	ldr	r0, [pc, #60]	; (800be48 <DMA_Config+0xb4>)
 800be0c:	f7f4 fffe 	bl	8000e0c <HAL_DMA_Init>
 800be10:	4603      	mov	r3, r0
 800be12:	2b00      	cmp	r3, #0
 800be14:	d000      	beq.n	800be18 <DMA_Config+0x84>
    {
        while(1)
 800be16:	e7fe      	b.n	800be16 <DMA_Config+0x82>
        {
        }
    }

    /*##-5- Select Callbacks functions called after Transfer complete and Transfer error */
    HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_CPLT_CB_ID, DMA_TransferComplete);
 800be18:	4a0d      	ldr	r2, [pc, #52]	; (800be50 <DMA_Config+0xbc>)
 800be1a:	2100      	movs	r1, #0
 800be1c:	480a      	ldr	r0, [pc, #40]	; (800be48 <DMA_Config+0xb4>)
 800be1e:	f7f5 faeb 	bl	80013f8 <HAL_DMA_RegisterCallback>
    HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_ERROR_CB_ID, DMA_TransferError);
 800be22:	4a0c      	ldr	r2, [pc, #48]	; (800be54 <DMA_Config+0xc0>)
 800be24:	2104      	movs	r1, #4
 800be26:	4808      	ldr	r0, [pc, #32]	; (800be48 <DMA_Config+0xb4>)
 800be28:	f7f5 fae6 	bl	80013f8 <HAL_DMA_RegisterCallback>

    /*##-6- Configure NVIC for DMA transfer complete/error interrupts ##########*/
    HAL_NVIC_SetPriority(CPY_BUF_DMA_STREAM_IRQ, 0, 0);
 800be2c:	2200      	movs	r2, #0
 800be2e:	2100      	movs	r1, #0
 800be30:	2038      	movs	r0, #56	; 0x38
 800be32:	f7f4 ff4f 	bl	8000cd4 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(CPY_BUF_DMA_STREAM_IRQ);
 800be36:	2038      	movs	r0, #56	; 0x38
 800be38:	f7f4 ff68 	bl	8000d0c <HAL_NVIC_EnableIRQ>
}
 800be3c:	bf00      	nop
 800be3e:	3708      	adds	r7, #8
 800be40:	46bd      	mov	sp, r7
 800be42:	bd80      	pop	{r7, pc}
 800be44:	40023800 	.word	0x40023800
 800be48:	20000ed0 	.word	0x20000ed0
 800be4c:	40026410 	.word	0x40026410
 800be50:	0800be59 	.word	0x0800be59
 800be54:	0800bf05 	.word	0x0800bf05

0800be58 <DMA_TransferComplete>:
  * @note   This function is executed when the transfer complete interrupt
  *         is generated
  * @retval None
  */
static void DMA_TransferComplete(DMA_HandleTypeDef *han)
{
 800be58:	b580      	push	{r7, lr}
 800be5a:	b084      	sub	sp, #16
 800be5c:	af00      	add	r7, sp, #0
 800be5e:	6078      	str	r0, [r7, #4]
    y_fill_act ++;
 800be60:	4b21      	ldr	r3, [pc, #132]	; (800bee8 <DMA_TransferComplete+0x90>)
 800be62:	681b      	ldr	r3, [r3, #0]
 800be64:	3301      	adds	r3, #1
 800be66:	4a20      	ldr	r2, [pc, #128]	; (800bee8 <DMA_TransferComplete+0x90>)
 800be68:	6013      	str	r3, [r2, #0]

    if(y_fill_act > y2_fill) {
 800be6a:	4b1f      	ldr	r3, [pc, #124]	; (800bee8 <DMA_TransferComplete+0x90>)
 800be6c:	681a      	ldr	r2, [r3, #0]
 800be6e:	4b1f      	ldr	r3, [pc, #124]	; (800beec <DMA_TransferComplete+0x94>)
 800be70:	681b      	ldr	r3, [r3, #0]
 800be72:	429a      	cmp	r2, r3
 800be74:	dd05      	ble.n	800be82 <DMA_TransferComplete+0x2a>
        lv_disp_flush_ready(&our_disp->driver);
 800be76:	4b1e      	ldr	r3, [pc, #120]	; (800bef0 <DMA_TransferComplete+0x98>)
 800be78:	681b      	ldr	r3, [r3, #0]
 800be7a:	4618      	mov	r0, r3
 800be7c:	f00f f992 	bl	801b1a4 <lv_disp_flush_ready>
                            length) != HAL_OK)
        {
            while(1);	/*Halt on error*/
        }
    }
}
 800be80:	e02d      	b.n	800bede <DMA_TransferComplete+0x86>
    	uint32_t length = (x2_flush - x1_flush + 1);
 800be82:	4b1c      	ldr	r3, [pc, #112]	; (800bef4 <DMA_TransferComplete+0x9c>)
 800be84:	681a      	ldr	r2, [r3, #0]
 800be86:	4b1c      	ldr	r3, [pc, #112]	; (800bef8 <DMA_TransferComplete+0xa0>)
 800be88:	681b      	ldr	r3, [r3, #0]
 800be8a:	1ad3      	subs	r3, r2, r3
 800be8c:	3301      	adds	r3, #1
 800be8e:	60fb      	str	r3, [r7, #12]
        buf_to_flush += x2_flush - x1_flush + 1;
 800be90:	4b1a      	ldr	r3, [pc, #104]	; (800befc <DMA_TransferComplete+0xa4>)
 800be92:	681a      	ldr	r2, [r3, #0]
 800be94:	4b17      	ldr	r3, [pc, #92]	; (800bef4 <DMA_TransferComplete+0x9c>)
 800be96:	6819      	ldr	r1, [r3, #0]
 800be98:	4b17      	ldr	r3, [pc, #92]	; (800bef8 <DMA_TransferComplete+0xa0>)
 800be9a:	681b      	ldr	r3, [r3, #0]
 800be9c:	1acb      	subs	r3, r1, r3
 800be9e:	3301      	adds	r3, #1
 800bea0:	005b      	lsls	r3, r3, #1
 800bea2:	4413      	add	r3, r2
 800bea4:	4a15      	ldr	r2, [pc, #84]	; (800befc <DMA_TransferComplete+0xa4>)
 800bea6:	6013      	str	r3, [r2, #0]
        if(HAL_DMA_Start_IT(han,(uint32_t)buf_to_flush, (uint32_t)&my_fb[y_fill_act * TFT_HOR_RES + x1_flush],
 800bea8:	4b14      	ldr	r3, [pc, #80]	; (800befc <DMA_TransferComplete+0xa4>)
 800beaa:	681b      	ldr	r3, [r3, #0]
 800beac:	4618      	mov	r0, r3
 800beae:	4b14      	ldr	r3, [pc, #80]	; (800bf00 <DMA_TransferComplete+0xa8>)
 800beb0:	6819      	ldr	r1, [r3, #0]
 800beb2:	4b0d      	ldr	r3, [pc, #52]	; (800bee8 <DMA_TransferComplete+0x90>)
 800beb4:	681a      	ldr	r2, [r3, #0]
 800beb6:	4613      	mov	r3, r2
 800beb8:	011b      	lsls	r3, r3, #4
 800beba:	1a9b      	subs	r3, r3, r2
 800bebc:	015b      	lsls	r3, r3, #5
 800bebe:	461a      	mov	r2, r3
 800bec0:	4b0d      	ldr	r3, [pc, #52]	; (800bef8 <DMA_TransferComplete+0xa0>)
 800bec2:	681b      	ldr	r3, [r3, #0]
 800bec4:	4413      	add	r3, r2
 800bec6:	005b      	lsls	r3, r3, #1
 800bec8:	440b      	add	r3, r1
 800beca:	461a      	mov	r2, r3
 800becc:	68fb      	ldr	r3, [r7, #12]
 800bece:	4601      	mov	r1, r0
 800bed0:	6878      	ldr	r0, [r7, #4]
 800bed2:	f7f5 f8a7 	bl	8001024 <HAL_DMA_Start_IT>
 800bed6:	4603      	mov	r3, r0
 800bed8:	2b00      	cmp	r3, #0
 800beda:	d000      	beq.n	800bede <DMA_TransferComplete+0x86>
            while(1);	/*Halt on error*/
 800bedc:	e7fe      	b.n	800bedc <DMA_TransferComplete+0x84>
}
 800bede:	bf00      	nop
 800bee0:	3710      	adds	r7, #16
 800bee2:	46bd      	mov	sp, r7
 800bee4:	bd80      	pop	{r7, pc}
 800bee6:	bf00      	nop
 800bee8:	20000f40 	.word	0x20000f40
 800beec:	20000f3c 	.word	0x20000f3c
 800bef0:	20000f48 	.word	0x20000f48
 800bef4:	20000f38 	.word	0x20000f38
 800bef8:	20000f30 	.word	0x20000f30
 800befc:	20000f44 	.word	0x20000f44
 800bf00:	20000034 	.word	0x20000034

0800bf04 <DMA_TransferError>:
  * @note   This function is executed when the transfer error interrupt
  *         is generated during DMA transfer
  * @retval None
  */
static void DMA_TransferError(DMA_HandleTypeDef *han)
{
 800bf04:	b480      	push	{r7}
 800bf06:	b083      	sub	sp, #12
 800bf08:	af00      	add	r7, sp, #0
 800bf0a:	6078      	str	r0, [r7, #4]

}
 800bf0c:	bf00      	nop
 800bf0e:	370c      	adds	r7, #12
 800bf10:	46bd      	mov	sp, r7
 800bf12:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf16:	4770      	bx	lr

0800bf18 <DMA2_Stream0_IRQHandler>:
  * @brief  This function handles DMA Stream interrupt request.
  * @param  None
  * @retval None
  */
void CPY_BUF_DMA_STREAM_IRQHANDLER(void)
{
 800bf18:	b580      	push	{r7, lr}
 800bf1a:	af00      	add	r7, sp, #0
    /* Check the interrupt and clear flag */
    HAL_DMA_IRQHandler(&DmaHandle);
 800bf1c:	4802      	ldr	r0, [pc, #8]	; (800bf28 <DMA2_Stream0_IRQHandler+0x10>)
 800bf1e:	f7f5 f8e1 	bl	80010e4 <HAL_DMA_IRQHandler>
}
 800bf22:	bf00      	nop
 800bf24:	bd80      	pop	{r7, pc}
 800bf26:	bf00      	nop
 800bf28:	20000ed0 	.word	0x20000ed0

0800bf2c <Error_Handler>:


#if LV_USE_GPU != 0

static void Error_Handler(void)
{
 800bf2c:	b480      	push	{r7}
 800bf2e:	af00      	add	r7, sp, #0
    while(1)
 800bf30:	e7fe      	b.n	800bf30 <Error_Handler+0x4>

0800bf32 <DMA2D_TransferComplete>:
  * @note   This example shows a simple way to report end of DMA2D transfer, and
  *         you can add your own implementation.
  * @retval None
  */
static void DMA2D_TransferComplete(DMA2D_HandleTypeDef *hdma2d)
{
 800bf32:	b480      	push	{r7}
 800bf34:	b083      	sub	sp, #12
 800bf36:	af00      	add	r7, sp, #0
 800bf38:	6078      	str	r0, [r7, #4]

}
 800bf3a:	bf00      	nop
 800bf3c:	370c      	adds	r7, #12
 800bf3e:	46bd      	mov	sp, r7
 800bf40:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf44:	4770      	bx	lr

0800bf46 <DMA2D_TransferError>:
  * @note   This example shows a simple way to report DMA2D transfer error, and you can
  *         add your own implementation.
  * @retval None
  */
static void DMA2D_TransferError(DMA2D_HandleTypeDef *hdma2d)
{
 800bf46:	b480      	push	{r7}
 800bf48:	b083      	sub	sp, #12
 800bf4a:	af00      	add	r7, sp, #0
 800bf4c:	6078      	str	r0, [r7, #4]

}
 800bf4e:	bf00      	nop
 800bf50:	370c      	adds	r7, #12
 800bf52:	46bd      	mov	sp, r7
 800bf54:	f85d 7b04 	ldr.w	r7, [sp], #4
 800bf58:	4770      	bx	lr
	...

0800bf5c <DMA2D_Config>:
  *          - second image loaded from FLASH memory
  *          - color mode as RGB565 pixel format
  * @retval None
  */
static void DMA2D_Config(void)
{
 800bf5c:	b580      	push	{r7, lr}
 800bf5e:	af00      	add	r7, sp, #0
    /* Configure the DMA2D Mode, Color Mode and output offset */
    Dma2dHandle.Init.Mode         = DMA2D_M2M_BLEND;
 800bf60:	4b1e      	ldr	r3, [pc, #120]	; (800bfdc <DMA2D_Config+0x80>)
 800bf62:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800bf66:	605a      	str	r2, [r3, #4]
#if LV_COLOR_DEPTH == 16
    Dma2dHandle.Init.ColorMode    = DMA2D_RGB565;
 800bf68:	4b1c      	ldr	r3, [pc, #112]	; (800bfdc <DMA2D_Config+0x80>)
 800bf6a:	2202      	movs	r2, #2
 800bf6c:	609a      	str	r2, [r3, #8]
#elif LV_COLOR_DEPTH == 24 || LV_COLOR_DEPTH == 32
    Dma2dHandle.Init.ColorMode    = DMA2D_ARGB8888;
#endif
    Dma2dHandle.Init.OutputOffset = 0x0;
 800bf6e:	4b1b      	ldr	r3, [pc, #108]	; (800bfdc <DMA2D_Config+0x80>)
 800bf70:	2200      	movs	r2, #0
 800bf72:	60da      	str	r2, [r3, #12]

    /* DMA2D Callbacks Configuration */
    Dma2dHandle.XferCpltCallback  = DMA2D_TransferComplete;
 800bf74:	4b19      	ldr	r3, [pc, #100]	; (800bfdc <DMA2D_Config+0x80>)
 800bf76:	4a1a      	ldr	r2, [pc, #104]	; (800bfe0 <DMA2D_Config+0x84>)
 800bf78:	611a      	str	r2, [r3, #16]
    Dma2dHandle.XferErrorCallback = DMA2D_TransferError;
 800bf7a:	4b18      	ldr	r3, [pc, #96]	; (800bfdc <DMA2D_Config+0x80>)
 800bf7c:	4a19      	ldr	r2, [pc, #100]	; (800bfe4 <DMA2D_Config+0x88>)
 800bf7e:	615a      	str	r2, [r3, #20]

    /* Foreground Configuration */
    Dma2dHandle.LayerCfg[1].AlphaMode = DMA2D_REPLACE_ALPHA;
 800bf80:	4b16      	ldr	r3, [pc, #88]	; (800bfdc <DMA2D_Config+0x80>)
 800bf82:	2201      	movs	r2, #1
 800bf84:	631a      	str	r2, [r3, #48]	; 0x30
    Dma2dHandle.LayerCfg[1].InputAlpha = 0xFF;
 800bf86:	4b15      	ldr	r3, [pc, #84]	; (800bfdc <DMA2D_Config+0x80>)
 800bf88:	22ff      	movs	r2, #255	; 0xff
 800bf8a:	635a      	str	r2, [r3, #52]	; 0x34
#if LV_COLOR_DEPTH == 16
    Dma2dHandle.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
 800bf8c:	4b13      	ldr	r3, [pc, #76]	; (800bfdc <DMA2D_Config+0x80>)
 800bf8e:	2202      	movs	r2, #2
 800bf90:	62da      	str	r2, [r3, #44]	; 0x2c
#elif LV_COLOR_DEPTH == 24 || LV_COLOR_DEPTH == 32
    Dma2dHandle.LayerCfg[1].InputColorMode = DMA2D_INPUT_ARGB8888;
#endif

    Dma2dHandle.LayerCfg[1].InputOffset = 0x0;
 800bf92:	4b12      	ldr	r3, [pc, #72]	; (800bfdc <DMA2D_Config+0x80>)
 800bf94:	2200      	movs	r2, #0
 800bf96:	629a      	str	r2, [r3, #40]	; 0x28

    /* Background Configuration */
    Dma2dHandle.LayerCfg[0].AlphaMode = DMA2D_REPLACE_ALPHA;
 800bf98:	4b10      	ldr	r3, [pc, #64]	; (800bfdc <DMA2D_Config+0x80>)
 800bf9a:	2201      	movs	r2, #1
 800bf9c:	621a      	str	r2, [r3, #32]
    Dma2dHandle.LayerCfg[0].InputAlpha = 0xFF;
 800bf9e:	4b0f      	ldr	r3, [pc, #60]	; (800bfdc <DMA2D_Config+0x80>)
 800bfa0:	22ff      	movs	r2, #255	; 0xff
 800bfa2:	625a      	str	r2, [r3, #36]	; 0x24
#if LV_COLOR_DEPTH == 16
    Dma2dHandle.LayerCfg[0].InputColorMode = DMA2D_INPUT_RGB565;
 800bfa4:	4b0d      	ldr	r3, [pc, #52]	; (800bfdc <DMA2D_Config+0x80>)
 800bfa6:	2202      	movs	r2, #2
 800bfa8:	61da      	str	r2, [r3, #28]
#elif LV_COLOR_DEPTH == 24 || LV_COLOR_DEPTH == 32
    Dma2dHandle.LayerCfg[0].InputColorMode = DMA2D_INPUT_ARGB8888;
#endif
    Dma2dHandle.LayerCfg[0].InputOffset = 0x0;
 800bfaa:	4b0c      	ldr	r3, [pc, #48]	; (800bfdc <DMA2D_Config+0x80>)
 800bfac:	2200      	movs	r2, #0
 800bfae:	619a      	str	r2, [r3, #24]

    Dma2dHandle.Instance   = DMA2D;
 800bfb0:	4b0a      	ldr	r3, [pc, #40]	; (800bfdc <DMA2D_Config+0x80>)
 800bfb2:	4a0d      	ldr	r2, [pc, #52]	; (800bfe8 <DMA2D_Config+0x8c>)
 800bfb4:	601a      	str	r2, [r3, #0]

    /* DMA2D Initialization */
    if(HAL_DMA2D_Init(&Dma2dHandle) != HAL_OK)
 800bfb6:	4809      	ldr	r0, [pc, #36]	; (800bfdc <DMA2D_Config+0x80>)
 800bfb8:	f7f5 fb50 	bl	800165c <HAL_DMA2D_Init>
 800bfbc:	4603      	mov	r3, r0
 800bfbe:	2b00      	cmp	r3, #0
 800bfc0:	d001      	beq.n	800bfc6 <DMA2D_Config+0x6a>
    {
        /* Initialization Error */
        Error_Handler();
 800bfc2:	f7ff ffb3 	bl	800bf2c <Error_Handler>
    }

    HAL_DMA2D_ConfigLayer(&Dma2dHandle, 0);
 800bfc6:	2100      	movs	r1, #0
 800bfc8:	4804      	ldr	r0, [pc, #16]	; (800bfdc <DMA2D_Config+0x80>)
 800bfca:	f7f5 fca9 	bl	8001920 <HAL_DMA2D_ConfigLayer>
    HAL_DMA2D_ConfigLayer(&Dma2dHandle, 1);
 800bfce:	2101      	movs	r1, #1
 800bfd0:	4802      	ldr	r0, [pc, #8]	; (800bfdc <DMA2D_Config+0x80>)
 800bfd2:	f7f5 fca5 	bl	8001920 <HAL_DMA2D_ConfigLayer>
}
 800bfd6:	bf00      	nop
 800bfd8:	bd80      	pop	{r7, pc}
 800bfda:	bf00      	nop
 800bfdc:	20000de8 	.word	0x20000de8
 800bfe0:	0800bf33 	.word	0x0800bf33
 800bfe4:	0800bf47 	.word	0x0800bf47
 800bfe8:	4002b000 	.word	0x4002b000

0800bfec <touchpad_init>:

/**
 * Initialize your input devices here
 */
void touchpad_init(void)
{
 800bfec:	b580      	push	{r7, lr}
 800bfee:	b088      	sub	sp, #32
 800bff0:	af00      	add	r7, sp, #0
    BSP_TS_Init(TFT_HOR_RES, TFT_VER_RES);
 800bff2:	f44f 7188 	mov.w	r1, #272	; 0x110
 800bff6:	f44f 70f0 	mov.w	r0, #480	; 0x1e0
 800bffa:	f7ff f909 	bl	800b210 <BSP_TS_Init>

    lv_indev_drv_t indev_drv;                       /*Descriptor of an input device driver*/
    lv_indev_drv_init(&indev_drv);                  /*Basic initialization*/
 800bffe:	463b      	mov	r3, r7
 800c000:	4618      	mov	r0, r3
 800c002:	f00f f97d 	bl	801b300 <lv_indev_drv_init>
    indev_drv.type = LV_INDEV_TYPE_POINTER;         /*The touchpad is pointer type device*/
 800c006:	2301      	movs	r3, #1
 800c008:	703b      	strb	r3, [r7, #0]
    indev_drv.read_cb = touchpad_read;
 800c00a:	4b05      	ldr	r3, [pc, #20]	; (800c020 <touchpad_init+0x34>)
 800c00c:	607b      	str	r3, [r7, #4]

    lv_indev_drv_register(&indev_drv);
 800c00e:	463b      	mov	r3, r7
 800c010:	4618      	mov	r0, r3
 800c012:	f00f f993 	bl	801b33c <lv_indev_drv_register>
}
 800c016:	bf00      	nop
 800c018:	3720      	adds	r7, #32
 800c01a:	46bd      	mov	sp, r7
 800c01c:	bd80      	pop	{r7, pc}
 800c01e:	bf00      	nop
 800c020:	0800c025 	.word	0x0800c025

0800c024 <touchpad_read>:
 * @param x put the x coordinate here
 * @param y put the y coordinate here
 * @return true: the device is pressed, false: released
 */
static bool touchpad_read(lv_indev_drv_t *indev, lv_indev_data_t *data)
{
 800c024:	b580      	push	{r7, lr}
 800c026:	b082      	sub	sp, #8
 800c028:	af00      	add	r7, sp, #0
 800c02a:	6078      	str	r0, [r7, #4]
 800c02c:	6039      	str	r1, [r7, #0]
    /* Read your touchpad */
    static int16_t last_x = 0;
    static int16_t last_y = 0;
    BSP_LED_Toggle(LED1);
 800c02e:	2000      	movs	r0, #0
 800c030:	f7fe fd7e 	bl	800ab30 <BSP_LED_Toggle>

    BSP_TS_GetState(&TS_State);
 800c034:	4818      	ldr	r0, [pc, #96]	; (800c098 <touchpad_read+0x74>)
 800c036:	f7ff f92b 	bl	800b290 <BSP_TS_GetState>
    if(TS_State.touchDetected) {
 800c03a:	4b17      	ldr	r3, [pc, #92]	; (800c098 <touchpad_read+0x74>)
 800c03c:	781b      	ldrb	r3, [r3, #0]
 800c03e:	2b00      	cmp	r3, #0
 800c040:	d017      	beq.n	800c072 <touchpad_read+0x4e>
            data->point.x = TS_State.touchX[0];
 800c042:	4b15      	ldr	r3, [pc, #84]	; (800c098 <touchpad_read+0x74>)
 800c044:	885b      	ldrh	r3, [r3, #2]
 800c046:	b21a      	sxth	r2, r3
 800c048:	683b      	ldr	r3, [r7, #0]
 800c04a:	801a      	strh	r2, [r3, #0]
            data->point.y = TS_State.touchY[0];
 800c04c:	4b12      	ldr	r3, [pc, #72]	; (800c098 <touchpad_read+0x74>)
 800c04e:	899b      	ldrh	r3, [r3, #12]
 800c050:	b21a      	sxth	r2, r3
 800c052:	683b      	ldr	r3, [r7, #0]
 800c054:	805a      	strh	r2, [r3, #2]
            last_x = data->point.x;
 800c056:	683b      	ldr	r3, [r7, #0]
 800c058:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c05c:	4b0f      	ldr	r3, [pc, #60]	; (800c09c <touchpad_read+0x78>)
 800c05e:	801a      	strh	r2, [r3, #0]
            last_y = data->point.y;
 800c060:	683b      	ldr	r3, [r7, #0]
 800c062:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800c066:	4b0e      	ldr	r3, [pc, #56]	; (800c0a0 <touchpad_read+0x7c>)
 800c068:	801a      	strh	r2, [r3, #0]
            data->state = LV_INDEV_STATE_PR;
 800c06a:	683b      	ldr	r3, [r7, #0]
 800c06c:	2201      	movs	r2, #1
 800c06e:	739a      	strb	r2, [r3, #14]
 800c070:	e00c      	b.n	800c08c <touchpad_read+0x68>
    } else {
            data->point.x = last_x;
 800c072:	4b0a      	ldr	r3, [pc, #40]	; (800c09c <touchpad_read+0x78>)
 800c074:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c078:	683b      	ldr	r3, [r7, #0]
 800c07a:	801a      	strh	r2, [r3, #0]
            data->point.y = last_y;
 800c07c:	4b08      	ldr	r3, [pc, #32]	; (800c0a0 <touchpad_read+0x7c>)
 800c07e:	f9b3 2000 	ldrsh.w	r2, [r3]
 800c082:	683b      	ldr	r3, [r7, #0]
 800c084:	805a      	strh	r2, [r3, #2]
            data->state = LV_INDEV_STATE_REL;
 800c086:	683b      	ldr	r3, [r7, #0]
 800c088:	2200      	movs	r2, #0
 800c08a:	739a      	strb	r2, [r3, #14]
    }

    return false;   /*false: no more data to read because we are no buffering*/
 800c08c:	2300      	movs	r3, #0
}
 800c08e:	4618      	mov	r0, r3
 800c090:	3708      	adds	r7, #8
 800c092:	46bd      	mov	sp, r7
 800c094:	bd80      	pop	{r7, pc}
 800c096:	bf00      	nop
 800c098:	2000356c 	.word	0x2000356c
 800c09c:	20003598 	.word	0x20003598
 800c0a0:	2000359a 	.word	0x2000359a

0800c0a4 <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 800c0a4:	b480      	push	{r7}
 800c0a6:	b085      	sub	sp, #20
 800c0a8:	af00      	add	r7, sp, #0
 800c0aa:	4603      	mov	r3, r0
 800c0ac:	71fb      	strb	r3, [r7, #7]
 800c0ae:	460b      	mov	r3, r1
 800c0b0:	71bb      	strb	r3, [r7, #6]
 800c0b2:	4613      	mov	r3, r2
 800c0b4:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 800c0b6:	797b      	ldrb	r3, [r7, #5]
 800c0b8:	08db      	lsrs	r3, r3, #3
 800c0ba:	b2db      	uxtb	r3, r3
 800c0bc:	f003 031f 	and.w	r3, r3, #31
 800c0c0:	b2da      	uxtb	r2, r3
 800c0c2:	7b3b      	ldrb	r3, [r7, #12]
 800c0c4:	f362 0304 	bfi	r3, r2, #0, #5
 800c0c8:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 800c0ca:	79bb      	ldrb	r3, [r7, #6]
 800c0cc:	089b      	lsrs	r3, r3, #2
 800c0ce:	b2db      	uxtb	r3, r3
 800c0d0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800c0d4:	b2da      	uxtb	r2, r3
 800c0d6:	89bb      	ldrh	r3, [r7, #12]
 800c0d8:	f362 134a 	bfi	r3, r2, #5, #6
 800c0dc:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 800c0de:	79fb      	ldrb	r3, [r7, #7]
 800c0e0:	08db      	lsrs	r3, r3, #3
 800c0e2:	b2db      	uxtb	r3, r3
 800c0e4:	f003 031f 	and.w	r3, r3, #31
 800c0e8:	b2da      	uxtb	r2, r3
 800c0ea:	7b7b      	ldrb	r3, [r7, #13]
 800c0ec:	f362 03c7 	bfi	r3, r2, #3, #5
 800c0f0:	737b      	strb	r3, [r7, #13]
    return color;
 800c0f2:	89bb      	ldrh	r3, [r7, #12]
}
 800c0f4:	4618      	mov	r0, r3
 800c0f6:	3714      	adds	r7, #20
 800c0f8:	46bd      	mov	sp, r7
 800c0fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c0fe:	4770      	bx	lr

0800c100 <lv_color_hex3>:
{
    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));
}

static inline lv_color_t lv_color_hex3(uint32_t c)
{
 800c100:	b580      	push	{r7, lr}
 800c102:	b082      	sub	sp, #8
 800c104:	af00      	add	r7, sp, #0
 800c106:	6078      	str	r0, [r7, #4]
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 800c108:	687b      	ldr	r3, [r7, #4]
 800c10a:	091b      	lsrs	r3, r3, #4
 800c10c:	b2db      	uxtb	r3, r3
 800c10e:	f023 030f 	bic.w	r3, r3, #15
 800c112:	b2da      	uxtb	r2, r3
 800c114:	687b      	ldr	r3, [r7, #4]
 800c116:	0a1b      	lsrs	r3, r3, #8
 800c118:	b2db      	uxtb	r3, r3
 800c11a:	f003 030f 	and.w	r3, r3, #15
 800c11e:	b2db      	uxtb	r3, r3
 800c120:	4313      	orrs	r3, r2
 800c122:	b2d8      	uxtb	r0, r3
 800c124:	687b      	ldr	r3, [r7, #4]
 800c126:	b2db      	uxtb	r3, r3
 800c128:	f023 030f 	bic.w	r3, r3, #15
 800c12c:	b2da      	uxtb	r2, r3
 800c12e:	687b      	ldr	r3, [r7, #4]
 800c130:	091b      	lsrs	r3, r3, #4
 800c132:	b2db      	uxtb	r3, r3
 800c134:	f003 030f 	and.w	r3, r3, #15
 800c138:	b2db      	uxtb	r3, r3
 800c13a:	4313      	orrs	r3, r2
 800c13c:	b2d9      	uxtb	r1, r3
                         (uint8_t)((c & 0xF) | ((c & 0xF) << 4)));
 800c13e:	687b      	ldr	r3, [r7, #4]
 800c140:	b2db      	uxtb	r3, r3
 800c142:	f003 030f 	and.w	r3, r3, #15
 800c146:	b2da      	uxtb	r2, r3
 800c148:	687b      	ldr	r3, [r7, #4]
 800c14a:	b2db      	uxtb	r3, r3
 800c14c:	011b      	lsls	r3, r3, #4
 800c14e:	b2db      	uxtb	r3, r3
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 800c150:	4313      	orrs	r3, r2
 800c152:	b2db      	uxtb	r3, r3
 800c154:	461a      	mov	r2, r3
 800c156:	f7ff ffa5 	bl	800c0a4 <lv_color_make>
 800c15a:	4603      	mov	r3, r0
}
 800c15c:	4618      	mov	r0, r3
 800c15e:	3708      	adds	r7, #8
 800c160:	46bd      	mov	sp, r7
 800c162:	bd80      	pop	{r7, pc}

0800c164 <lv_scr_act>:
/**
 * Get the active screen of the default display
 * @return pointer to the active screen
 */
static inline lv_obj_t * lv_scr_act(void)
{
 800c164:	b580      	push	{r7, lr}
 800c166:	af00      	add	r7, sp, #0
    return lv_disp_get_scr_act(lv_disp_get_default());
 800c168:	f00e ffb0 	bl	801b0cc <lv_disp_get_default>
 800c16c:	4603      	mov	r3, r0
 800c16e:	4618      	mov	r0, r3
 800c170:	f001 fe74 	bl	800de5c <lv_disp_get_scr_act>
 800c174:	4603      	mov	r3, r0
}
 800c176:	4618      	mov	r0, r3
 800c178:	bd80      	pop	{r7, pc}

0800c17a <lv_label_set_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @param style pointer to a style
 */
static inline void lv_label_set_style(lv_obj_t * label, lv_label_style_t type, const lv_style_t * style)
{
 800c17a:	b580      	push	{r7, lr}
 800c17c:	b084      	sub	sp, #16
 800c17e:	af00      	add	r7, sp, #0
 800c180:	60f8      	str	r0, [r7, #12]
 800c182:	460b      	mov	r3, r1
 800c184:	607a      	str	r2, [r7, #4]
 800c186:	72fb      	strb	r3, [r7, #11]
    (void)type; /*Unused*/
    lv_obj_set_style(label, style);
 800c188:	6879      	ldr	r1, [r7, #4]
 800c18a:	68f8      	ldr	r0, [r7, #12]
 800c18c:	f005 fd91 	bl	8011cb2 <lv_obj_set_style>
}
 800c190:	bf00      	nop
 800c192:	3710      	adds	r7, #16
 800c194:	46bd      	mov	sp, r7
 800c196:	bd80      	pop	{r7, pc}

0800c198 <lv_slider_set_value>:
 * @param slider pointer to a slider object
 * @param value new value
 * @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately
 */
static inline void lv_slider_set_value(lv_obj_t * slider, int16_t value, lv_anim_enable_t anim)
{
 800c198:	b580      	push	{r7, lr}
 800c19a:	b082      	sub	sp, #8
 800c19c:	af00      	add	r7, sp, #0
 800c19e:	6078      	str	r0, [r7, #4]
 800c1a0:	460b      	mov	r3, r1
 800c1a2:	807b      	strh	r3, [r7, #2]
 800c1a4:	4613      	mov	r3, r2
 800c1a6:	707b      	strb	r3, [r7, #1]
    lv_bar_set_value(slider, value, anim);
 800c1a8:	787a      	ldrb	r2, [r7, #1]
 800c1aa:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800c1ae:	4619      	mov	r1, r3
 800c1b0:	6878      	ldr	r0, [r7, #4]
 800c1b2:	f011 fd2d 	bl	801dc10 <lv_bar_set_value>
}
 800c1b6:	bf00      	nop
 800c1b8:	3708      	adds	r7, #8
 800c1ba:	46bd      	mov	sp, r7
 800c1bc:	bd80      	pop	{r7, pc}

0800c1be <lv_slider_set_range>:
 * @param slider pointer to the slider object
 * @param min minimum value
 * @param max maximum value
 */
static inline void lv_slider_set_range(lv_obj_t * slider, int16_t min, int16_t max)
{
 800c1be:	b580      	push	{r7, lr}
 800c1c0:	b082      	sub	sp, #8
 800c1c2:	af00      	add	r7, sp, #0
 800c1c4:	6078      	str	r0, [r7, #4]
 800c1c6:	460b      	mov	r3, r1
 800c1c8:	807b      	strh	r3, [r7, #2]
 800c1ca:	4613      	mov	r3, r2
 800c1cc:	803b      	strh	r3, [r7, #0]
    lv_bar_set_range(slider, min, max);
 800c1ce:	f9b7 2000 	ldrsh.w	r2, [r7]
 800c1d2:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 800c1d6:	4619      	mov	r1, r3
 800c1d8:	6878      	ldr	r0, [r7, #4]
 800c1da:	f011 fd9d 	bl	801dd18 <lv_bar_set_range>
}
 800c1de:	bf00      	nop
 800c1e0:	3708      	adds	r7, #8
 800c1e2:	46bd      	mov	sp, r7
 800c1e4:	bd80      	pop	{r7, pc}

0800c1e6 <ledSurucuMain>:
 uint8_t ledRValues = 0;
 uint8_t ledGValues = 0;
 uint8_t ledBValues = 0;

/*Main Function*/
void ledSurucuMain(void) {
 800c1e6:	b580      	push	{r7, lr}
 800c1e8:	b082      	sub	sp, #8
 800c1ea:	af00      	add	r7, sp, #0
	lv_obj_t * LedControllerGui;
	lv_theme_set_current(lv_theme_mono_init(0, 0));
 800c1ec:	2100      	movs	r1, #0
 800c1ee:	2000      	movs	r0, #0
 800c1f0:	f01a ff3a 	bl	8027068 <lv_theme_mono_init>
 800c1f4:	4603      	mov	r3, r0
 800c1f6:	4618      	mov	r0, r3
 800c1f8:	f019 fbac 	bl	8025954 <lv_theme_set_current>
	LedControllerGui = lv_obj_create(0, 0);
 800c1fc:	2100      	movs	r1, #0
 800c1fe:	2000      	movs	r0, #0
 800c200:	f004 fac0 	bl	8010784 <lv_obj_create>
 800c204:	6078      	str	r0, [r7, #4]
	lv_disp_load_scr(LedControllerGui);//Displayi oluturur.
 800c206:	6878      	ldr	r0, [r7, #4]
 800c208:	f001 fe48 	bl	800de9c <lv_disp_load_scr>
	StaticColorScreen();
 800c20c:	f000 f806 	bl	800c21c <StaticColorScreen>
	MenuDropList();
 800c210:	f000 ff94 	bl	800d13c <MenuDropList>
}
 800c214:	bf00      	nop
 800c216:	3708      	adds	r7, #8
 800c218:	46bd      	mov	sp, r7
 800c21a:	bd80      	pop	{r7, pc}

0800c21c <StaticColorScreen>:
/*Design Functions*/
void StaticColorScreen(void) {
 800c21c:	b580      	push	{r7, lr}
 800c21e:	af00      	add	r7, sp, #0

	staticColorButtons();
 800c220:	f000 f81c 	bl	800c25c <staticColorButtons>
	outGoingColorContainer();
 800c224:	f000 ff44 	bl	800d0b0 <outGoingColorContainer>
	setNewColorButton();
 800c228:	f000 fef6 	bl	800d018 <setNewColorButton>
	
}
 800c22c:	bf00      	nop
 800c22e:	bd80      	pop	{r7, pc}

0800c230 <ColorChooserScreen>:
void ColorChooserScreen(void) {
 800c230:	b580      	push	{r7, lr}
 800c232:	af00      	add	r7, sp, #0

	ledRslider();
 800c234:	f000 fd38 	bl	800cca8 <ledRslider>
	ledGslider();
 800c238:	f000 fdce 	bl	800cdd8 <ledGslider>
	ledBslider();
 800c23c:	f000 fe62 	bl	800cf04 <ledBslider>
	outGoingColorContainer();
 800c240:	f000 ff36 	bl	800d0b0 <outGoingColorContainer>
	setNewColorButton();
 800c244:	f000 fee8 	bl	800d018 <setNewColorButton>

	
}
 800c248:	bf00      	nop
 800c24a:	bd80      	pop	{r7, pc}

0800c24c <ColorChooserInformationScreen>:
void ColorChooserInformationScreen(void) {
 800c24c:	b580      	push	{r7, lr}
 800c24e:	af00      	add	r7, sp, #0

	information();	
 800c250:	f000 ffba 	bl	800d1c8 <information>
	outGoingColorContainer();
 800c254:	f000 ff2c 	bl	800d0b0 <outGoingColorContainer>
}
 800c258:	bf00      	nop
 800c25a:	bd80      	pop	{r7, pc}

0800c25c <staticColorButtons>:
void staticColorButtons(void) {
 800c25c:	b590      	push	{r4, r7, lr}
 800c25e:	b093      	sub	sp, #76	; 0x4c
 800c260:	af02      	add	r7, sp, #8
	lv_obj_t * ledStaticColors[15];
	static lv_style_t ledStaticColorsRelSyle[15];
	static lv_style_t ledStaticColorsPrStyle[15];


	for (uint8_t count = 0; count < 15; count++) {
 800c262:	2300      	movs	r3, #0
 800c264:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 800c268:	e3e6      	b.n	800ca38 <staticColorButtons+0x7dc>
		ledButtonStyle();
 800c26a:	f001 fca1 	bl	800dbb0 <ledButtonStyle>
		lv_style_copy(&ledStaticColorsRelSyle[count], &led_Button_style_btn_rel);
 800c26e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c272:	4613      	mov	r3, r2
 800c274:	011b      	lsls	r3, r3, #4
 800c276:	1a9b      	subs	r3, r3, r2
 800c278:	009b      	lsls	r3, r3, #2
 800c27a:	4ad3      	ldr	r2, [pc, #844]	; (800c5c8 <staticColorButtons+0x36c>)
 800c27c:	4413      	add	r3, r2
 800c27e:	49d3      	ldr	r1, [pc, #844]	; (800c5cc <staticColorButtons+0x370>)
 800c280:	4618      	mov	r0, r3
 800c282:	f007 fbef 	bl	8013a64 <lv_style_copy>
		lv_style_copy(&ledStaticColorsPrStyle[count], &led_Button_style_btn_pr);
 800c286:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c28a:	4613      	mov	r3, r2
 800c28c:	011b      	lsls	r3, r3, #4
 800c28e:	1a9b      	subs	r3, r3, r2
 800c290:	009b      	lsls	r3, r3, #2
 800c292:	4acf      	ldr	r2, [pc, #828]	; (800c5d0 <staticColorButtons+0x374>)
 800c294:	4413      	add	r3, r2
 800c296:	49cf      	ldr	r1, [pc, #828]	; (800c5d4 <staticColorButtons+0x378>)
 800c298:	4618      	mov	r0, r3
 800c29a:	f007 fbe3 	bl	8013a64 <lv_style_copy>
		switch (count)
 800c29e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800c2a2:	2b0e      	cmp	r3, #14
 800c2a4:	f200 83c2 	bhi.w	800ca2c <staticColorButtons+0x7d0>
 800c2a8:	a201      	add	r2, pc, #4	; (adr r2, 800c2b0 <staticColorButtons+0x54>)
 800c2aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c2ae:	bf00      	nop
 800c2b0:	0800c2ed 	.word	0x0800c2ed
 800c2b4:	0800c367 	.word	0x0800c367
 800c2b8:	0800c3e1 	.word	0x0800c3e1
 800c2bc:	0800c45b 	.word	0x0800c45b
 800c2c0:	0800c4d5 	.word	0x0800c4d5
 800c2c4:	0800c54f 	.word	0x0800c54f
 800c2c8:	0800c5d9 	.word	0x0800c5d9
 800c2cc:	0800c653 	.word	0x0800c653
 800c2d0:	0800c6cd 	.word	0x0800c6cd
 800c2d4:	0800c747 	.word	0x0800c747
 800c2d8:	0800c7c1 	.word	0x0800c7c1
 800c2dc:	0800c83b 	.word	0x0800c83b
 800c2e0:	0800c8b5 	.word	0x0800c8b5
 800c2e4:	0800c939 	.word	0x0800c939
 800c2e8:	0800c9b3 	.word	0x0800c9b3
		{
		case 0:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(255, 0, 0);
 800c2ec:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c2f0:	49b5      	ldr	r1, [pc, #724]	; (800c5c8 <staticColorButtons+0x36c>)
 800c2f2:	4613      	mov	r3, r2
 800c2f4:	011b      	lsls	r3, r3, #4
 800c2f6:	1a9b      	subs	r3, r3, r2
 800c2f8:	009b      	lsls	r3, r3, #2
 800c2fa:	440b      	add	r3, r1
 800c2fc:	1c9c      	adds	r4, r3, #2
 800c2fe:	2200      	movs	r2, #0
 800c300:	2100      	movs	r1, #0
 800c302:	20ff      	movs	r0, #255	; 0xff
 800c304:	f7ff fece 	bl	800c0a4 <lv_color_make>
 800c308:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(255, 0, 0);
 800c30a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c30e:	49ae      	ldr	r1, [pc, #696]	; (800c5c8 <staticColorButtons+0x36c>)
 800c310:	4613      	mov	r3, r2
 800c312:	011b      	lsls	r3, r3, #4
 800c314:	1a9b      	subs	r3, r3, r2
 800c316:	009b      	lsls	r3, r3, #2
 800c318:	440b      	add	r3, r1
 800c31a:	1d1c      	adds	r4, r3, #4
 800c31c:	2200      	movs	r2, #0
 800c31e:	2100      	movs	r1, #0
 800c320:	20ff      	movs	r0, #255	; 0xff
 800c322:	f7ff febf 	bl	800c0a4 <lv_color_make>
 800c326:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(255, 0, 0);
 800c328:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c32c:	49a8      	ldr	r1, [pc, #672]	; (800c5d0 <staticColorButtons+0x374>)
 800c32e:	4613      	mov	r3, r2
 800c330:	011b      	lsls	r3, r3, #4
 800c332:	1a9b      	subs	r3, r3, r2
 800c334:	009b      	lsls	r3, r3, #2
 800c336:	440b      	add	r3, r1
 800c338:	1c9c      	adds	r4, r3, #2
 800c33a:	2200      	movs	r2, #0
 800c33c:	2100      	movs	r1, #0
 800c33e:	20ff      	movs	r0, #255	; 0xff
 800c340:	f7ff feb0 	bl	800c0a4 <lv_color_make>
 800c344:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(255, 0, 0);
 800c346:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c34a:	49a1      	ldr	r1, [pc, #644]	; (800c5d0 <staticColorButtons+0x374>)
 800c34c:	4613      	mov	r3, r2
 800c34e:	011b      	lsls	r3, r3, #4
 800c350:	1a9b      	subs	r3, r3, r2
 800c352:	009b      	lsls	r3, r3, #2
 800c354:	440b      	add	r3, r1
 800c356:	1d1c      	adds	r4, r3, #4
 800c358:	2200      	movs	r2, #0
 800c35a:	2100      	movs	r1, #0
 800c35c:	20ff      	movs	r0, #255	; 0xff
 800c35e:	f7ff fea1 	bl	800c0a4 <lv_color_make>
 800c362:	8020      	strh	r0, [r4, #0]
			break;
 800c364:	e363      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 1:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(128, 0, 0);
 800c366:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c36a:	4997      	ldr	r1, [pc, #604]	; (800c5c8 <staticColorButtons+0x36c>)
 800c36c:	4613      	mov	r3, r2
 800c36e:	011b      	lsls	r3, r3, #4
 800c370:	1a9b      	subs	r3, r3, r2
 800c372:	009b      	lsls	r3, r3, #2
 800c374:	440b      	add	r3, r1
 800c376:	1c9c      	adds	r4, r3, #2
 800c378:	2200      	movs	r2, #0
 800c37a:	2100      	movs	r1, #0
 800c37c:	2080      	movs	r0, #128	; 0x80
 800c37e:	f7ff fe91 	bl	800c0a4 <lv_color_make>
 800c382:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(128, 0, 0);
 800c384:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c388:	498f      	ldr	r1, [pc, #572]	; (800c5c8 <staticColorButtons+0x36c>)
 800c38a:	4613      	mov	r3, r2
 800c38c:	011b      	lsls	r3, r3, #4
 800c38e:	1a9b      	subs	r3, r3, r2
 800c390:	009b      	lsls	r3, r3, #2
 800c392:	440b      	add	r3, r1
 800c394:	1d1c      	adds	r4, r3, #4
 800c396:	2200      	movs	r2, #0
 800c398:	2100      	movs	r1, #0
 800c39a:	2080      	movs	r0, #128	; 0x80
 800c39c:	f7ff fe82 	bl	800c0a4 <lv_color_make>
 800c3a0:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(128, 0, 0);
 800c3a2:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c3a6:	498a      	ldr	r1, [pc, #552]	; (800c5d0 <staticColorButtons+0x374>)
 800c3a8:	4613      	mov	r3, r2
 800c3aa:	011b      	lsls	r3, r3, #4
 800c3ac:	1a9b      	subs	r3, r3, r2
 800c3ae:	009b      	lsls	r3, r3, #2
 800c3b0:	440b      	add	r3, r1
 800c3b2:	1c9c      	adds	r4, r3, #2
 800c3b4:	2200      	movs	r2, #0
 800c3b6:	2100      	movs	r1, #0
 800c3b8:	2080      	movs	r0, #128	; 0x80
 800c3ba:	f7ff fe73 	bl	800c0a4 <lv_color_make>
 800c3be:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(128, 0, 0);
 800c3c0:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c3c4:	4982      	ldr	r1, [pc, #520]	; (800c5d0 <staticColorButtons+0x374>)
 800c3c6:	4613      	mov	r3, r2
 800c3c8:	011b      	lsls	r3, r3, #4
 800c3ca:	1a9b      	subs	r3, r3, r2
 800c3cc:	009b      	lsls	r3, r3, #2
 800c3ce:	440b      	add	r3, r1
 800c3d0:	1d1c      	adds	r4, r3, #4
 800c3d2:	2200      	movs	r2, #0
 800c3d4:	2100      	movs	r1, #0
 800c3d6:	2080      	movs	r0, #128	; 0x80
 800c3d8:	f7ff fe64 	bl	800c0a4 <lv_color_make>
 800c3dc:	8020      	strh	r0, [r4, #0]
			break;
 800c3de:	e326      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 2:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(128, 0, 128);
 800c3e0:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c3e4:	4978      	ldr	r1, [pc, #480]	; (800c5c8 <staticColorButtons+0x36c>)
 800c3e6:	4613      	mov	r3, r2
 800c3e8:	011b      	lsls	r3, r3, #4
 800c3ea:	1a9b      	subs	r3, r3, r2
 800c3ec:	009b      	lsls	r3, r3, #2
 800c3ee:	440b      	add	r3, r1
 800c3f0:	1c9c      	adds	r4, r3, #2
 800c3f2:	2280      	movs	r2, #128	; 0x80
 800c3f4:	2100      	movs	r1, #0
 800c3f6:	2080      	movs	r0, #128	; 0x80
 800c3f8:	f7ff fe54 	bl	800c0a4 <lv_color_make>
 800c3fc:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(128, 0, 128);
 800c3fe:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c402:	4971      	ldr	r1, [pc, #452]	; (800c5c8 <staticColorButtons+0x36c>)
 800c404:	4613      	mov	r3, r2
 800c406:	011b      	lsls	r3, r3, #4
 800c408:	1a9b      	subs	r3, r3, r2
 800c40a:	009b      	lsls	r3, r3, #2
 800c40c:	440b      	add	r3, r1
 800c40e:	1d1c      	adds	r4, r3, #4
 800c410:	2280      	movs	r2, #128	; 0x80
 800c412:	2100      	movs	r1, #0
 800c414:	2080      	movs	r0, #128	; 0x80
 800c416:	f7ff fe45 	bl	800c0a4 <lv_color_make>
 800c41a:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(128, 0, 128);
 800c41c:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c420:	496b      	ldr	r1, [pc, #428]	; (800c5d0 <staticColorButtons+0x374>)
 800c422:	4613      	mov	r3, r2
 800c424:	011b      	lsls	r3, r3, #4
 800c426:	1a9b      	subs	r3, r3, r2
 800c428:	009b      	lsls	r3, r3, #2
 800c42a:	440b      	add	r3, r1
 800c42c:	1c9c      	adds	r4, r3, #2
 800c42e:	2280      	movs	r2, #128	; 0x80
 800c430:	2100      	movs	r1, #0
 800c432:	2080      	movs	r0, #128	; 0x80
 800c434:	f7ff fe36 	bl	800c0a4 <lv_color_make>
 800c438:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(128, 0, 128);
 800c43a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c43e:	4964      	ldr	r1, [pc, #400]	; (800c5d0 <staticColorButtons+0x374>)
 800c440:	4613      	mov	r3, r2
 800c442:	011b      	lsls	r3, r3, #4
 800c444:	1a9b      	subs	r3, r3, r2
 800c446:	009b      	lsls	r3, r3, #2
 800c448:	440b      	add	r3, r1
 800c44a:	1d1c      	adds	r4, r3, #4
 800c44c:	2280      	movs	r2, #128	; 0x80
 800c44e:	2100      	movs	r1, #0
 800c450:	2080      	movs	r0, #128	; 0x80
 800c452:	f7ff fe27 	bl	800c0a4 <lv_color_make>
 800c456:	8020      	strh	r0, [r4, #0]
			break;
 800c458:	e2e9      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 3:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(255, 0, 255);
 800c45a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c45e:	495a      	ldr	r1, [pc, #360]	; (800c5c8 <staticColorButtons+0x36c>)
 800c460:	4613      	mov	r3, r2
 800c462:	011b      	lsls	r3, r3, #4
 800c464:	1a9b      	subs	r3, r3, r2
 800c466:	009b      	lsls	r3, r3, #2
 800c468:	440b      	add	r3, r1
 800c46a:	1c9c      	adds	r4, r3, #2
 800c46c:	22ff      	movs	r2, #255	; 0xff
 800c46e:	2100      	movs	r1, #0
 800c470:	20ff      	movs	r0, #255	; 0xff
 800c472:	f7ff fe17 	bl	800c0a4 <lv_color_make>
 800c476:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(255, 0, 255);
 800c478:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c47c:	4952      	ldr	r1, [pc, #328]	; (800c5c8 <staticColorButtons+0x36c>)
 800c47e:	4613      	mov	r3, r2
 800c480:	011b      	lsls	r3, r3, #4
 800c482:	1a9b      	subs	r3, r3, r2
 800c484:	009b      	lsls	r3, r3, #2
 800c486:	440b      	add	r3, r1
 800c488:	1d1c      	adds	r4, r3, #4
 800c48a:	22ff      	movs	r2, #255	; 0xff
 800c48c:	2100      	movs	r1, #0
 800c48e:	20ff      	movs	r0, #255	; 0xff
 800c490:	f7ff fe08 	bl	800c0a4 <lv_color_make>
 800c494:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(255, 0, 255);
 800c496:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c49a:	494d      	ldr	r1, [pc, #308]	; (800c5d0 <staticColorButtons+0x374>)
 800c49c:	4613      	mov	r3, r2
 800c49e:	011b      	lsls	r3, r3, #4
 800c4a0:	1a9b      	subs	r3, r3, r2
 800c4a2:	009b      	lsls	r3, r3, #2
 800c4a4:	440b      	add	r3, r1
 800c4a6:	1c9c      	adds	r4, r3, #2
 800c4a8:	22ff      	movs	r2, #255	; 0xff
 800c4aa:	2100      	movs	r1, #0
 800c4ac:	20ff      	movs	r0, #255	; 0xff
 800c4ae:	f7ff fdf9 	bl	800c0a4 <lv_color_make>
 800c4b2:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(255, 0, 255);
 800c4b4:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c4b8:	4945      	ldr	r1, [pc, #276]	; (800c5d0 <staticColorButtons+0x374>)
 800c4ba:	4613      	mov	r3, r2
 800c4bc:	011b      	lsls	r3, r3, #4
 800c4be:	1a9b      	subs	r3, r3, r2
 800c4c0:	009b      	lsls	r3, r3, #2
 800c4c2:	440b      	add	r3, r1
 800c4c4:	1d1c      	adds	r4, r3, #4
 800c4c6:	22ff      	movs	r2, #255	; 0xff
 800c4c8:	2100      	movs	r1, #0
 800c4ca:	20ff      	movs	r0, #255	; 0xff
 800c4cc:	f7ff fdea 	bl	800c0a4 <lv_color_make>
 800c4d0:	8020      	strh	r0, [r4, #0]
			break;
 800c4d2:	e2ac      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 4:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(128, 128, 128);
 800c4d4:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c4d8:	493b      	ldr	r1, [pc, #236]	; (800c5c8 <staticColorButtons+0x36c>)
 800c4da:	4613      	mov	r3, r2
 800c4dc:	011b      	lsls	r3, r3, #4
 800c4de:	1a9b      	subs	r3, r3, r2
 800c4e0:	009b      	lsls	r3, r3, #2
 800c4e2:	440b      	add	r3, r1
 800c4e4:	1c9c      	adds	r4, r3, #2
 800c4e6:	2280      	movs	r2, #128	; 0x80
 800c4e8:	2180      	movs	r1, #128	; 0x80
 800c4ea:	2080      	movs	r0, #128	; 0x80
 800c4ec:	f7ff fdda 	bl	800c0a4 <lv_color_make>
 800c4f0:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(128, 128, 128);
 800c4f2:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c4f6:	4934      	ldr	r1, [pc, #208]	; (800c5c8 <staticColorButtons+0x36c>)
 800c4f8:	4613      	mov	r3, r2
 800c4fa:	011b      	lsls	r3, r3, #4
 800c4fc:	1a9b      	subs	r3, r3, r2
 800c4fe:	009b      	lsls	r3, r3, #2
 800c500:	440b      	add	r3, r1
 800c502:	1d1c      	adds	r4, r3, #4
 800c504:	2280      	movs	r2, #128	; 0x80
 800c506:	2180      	movs	r1, #128	; 0x80
 800c508:	2080      	movs	r0, #128	; 0x80
 800c50a:	f7ff fdcb 	bl	800c0a4 <lv_color_make>
 800c50e:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(128, 128, 128);
 800c510:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c514:	492e      	ldr	r1, [pc, #184]	; (800c5d0 <staticColorButtons+0x374>)
 800c516:	4613      	mov	r3, r2
 800c518:	011b      	lsls	r3, r3, #4
 800c51a:	1a9b      	subs	r3, r3, r2
 800c51c:	009b      	lsls	r3, r3, #2
 800c51e:	440b      	add	r3, r1
 800c520:	1c9c      	adds	r4, r3, #2
 800c522:	2280      	movs	r2, #128	; 0x80
 800c524:	2180      	movs	r1, #128	; 0x80
 800c526:	2080      	movs	r0, #128	; 0x80
 800c528:	f7ff fdbc 	bl	800c0a4 <lv_color_make>
 800c52c:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(128, 128, 128);
 800c52e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c532:	4927      	ldr	r1, [pc, #156]	; (800c5d0 <staticColorButtons+0x374>)
 800c534:	4613      	mov	r3, r2
 800c536:	011b      	lsls	r3, r3, #4
 800c538:	1a9b      	subs	r3, r3, r2
 800c53a:	009b      	lsls	r3, r3, #2
 800c53c:	440b      	add	r3, r1
 800c53e:	1d1c      	adds	r4, r3, #4
 800c540:	2280      	movs	r2, #128	; 0x80
 800c542:	2180      	movs	r1, #128	; 0x80
 800c544:	2080      	movs	r0, #128	; 0x80
 800c546:	f7ff fdad 	bl	800c0a4 <lv_color_make>
 800c54a:	8020      	strh	r0, [r4, #0]
			break;
 800c54c:	e26f      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 5:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(0, 128, 0);
 800c54e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c552:	491d      	ldr	r1, [pc, #116]	; (800c5c8 <staticColorButtons+0x36c>)
 800c554:	4613      	mov	r3, r2
 800c556:	011b      	lsls	r3, r3, #4
 800c558:	1a9b      	subs	r3, r3, r2
 800c55a:	009b      	lsls	r3, r3, #2
 800c55c:	440b      	add	r3, r1
 800c55e:	1c9c      	adds	r4, r3, #2
 800c560:	2200      	movs	r2, #0
 800c562:	2180      	movs	r1, #128	; 0x80
 800c564:	2000      	movs	r0, #0
 800c566:	f7ff fd9d 	bl	800c0a4 <lv_color_make>
 800c56a:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(0, 128, 0);
 800c56c:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c570:	4915      	ldr	r1, [pc, #84]	; (800c5c8 <staticColorButtons+0x36c>)
 800c572:	4613      	mov	r3, r2
 800c574:	011b      	lsls	r3, r3, #4
 800c576:	1a9b      	subs	r3, r3, r2
 800c578:	009b      	lsls	r3, r3, #2
 800c57a:	440b      	add	r3, r1
 800c57c:	1d1c      	adds	r4, r3, #4
 800c57e:	2200      	movs	r2, #0
 800c580:	2180      	movs	r1, #128	; 0x80
 800c582:	2000      	movs	r0, #0
 800c584:	f7ff fd8e 	bl	800c0a4 <lv_color_make>
 800c588:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(0, 128, 0);
 800c58a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c58e:	4910      	ldr	r1, [pc, #64]	; (800c5d0 <staticColorButtons+0x374>)
 800c590:	4613      	mov	r3, r2
 800c592:	011b      	lsls	r3, r3, #4
 800c594:	1a9b      	subs	r3, r3, r2
 800c596:	009b      	lsls	r3, r3, #2
 800c598:	440b      	add	r3, r1
 800c59a:	1c9c      	adds	r4, r3, #2
 800c59c:	2200      	movs	r2, #0
 800c59e:	2180      	movs	r1, #128	; 0x80
 800c5a0:	2000      	movs	r0, #0
 800c5a2:	f7ff fd7f 	bl	800c0a4 <lv_color_make>
 800c5a6:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(0, 128, 0);
 800c5a8:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c5ac:	4908      	ldr	r1, [pc, #32]	; (800c5d0 <staticColorButtons+0x374>)
 800c5ae:	4613      	mov	r3, r2
 800c5b0:	011b      	lsls	r3, r3, #4
 800c5b2:	1a9b      	subs	r3, r3, r2
 800c5b4:	009b      	lsls	r3, r3, #2
 800c5b6:	440b      	add	r3, r1
 800c5b8:	1d1c      	adds	r4, r3, #4
 800c5ba:	2200      	movs	r2, #0
 800c5bc:	2180      	movs	r1, #128	; 0x80
 800c5be:	2000      	movs	r0, #0
 800c5c0:	f7ff fd70 	bl	800c0a4 <lv_color_make>
 800c5c4:	8020      	strh	r0, [r4, #0]
			break;
 800c5c6:	e232      	b.n	800ca2e <staticColorButtons+0x7d2>
 800c5c8:	200037fc 	.word	0x200037fc
 800c5cc:	20003650 	.word	0x20003650
 800c5d0:	20003b80 	.word	0x20003b80
 800c5d4:	2000368c 	.word	0x2000368c
		case 6:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(128, 128, 0);
 800c5d8:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c5dc:	49d4      	ldr	r1, [pc, #848]	; (800c930 <staticColorButtons+0x6d4>)
 800c5de:	4613      	mov	r3, r2
 800c5e0:	011b      	lsls	r3, r3, #4
 800c5e2:	1a9b      	subs	r3, r3, r2
 800c5e4:	009b      	lsls	r3, r3, #2
 800c5e6:	440b      	add	r3, r1
 800c5e8:	1c9c      	adds	r4, r3, #2
 800c5ea:	2200      	movs	r2, #0
 800c5ec:	2180      	movs	r1, #128	; 0x80
 800c5ee:	2080      	movs	r0, #128	; 0x80
 800c5f0:	f7ff fd58 	bl	800c0a4 <lv_color_make>
 800c5f4:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(128, 128, 0);
 800c5f6:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c5fa:	49cd      	ldr	r1, [pc, #820]	; (800c930 <staticColorButtons+0x6d4>)
 800c5fc:	4613      	mov	r3, r2
 800c5fe:	011b      	lsls	r3, r3, #4
 800c600:	1a9b      	subs	r3, r3, r2
 800c602:	009b      	lsls	r3, r3, #2
 800c604:	440b      	add	r3, r1
 800c606:	1d1c      	adds	r4, r3, #4
 800c608:	2200      	movs	r2, #0
 800c60a:	2180      	movs	r1, #128	; 0x80
 800c60c:	2080      	movs	r0, #128	; 0x80
 800c60e:	f7ff fd49 	bl	800c0a4 <lv_color_make>
 800c612:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(128, 128, 0);
 800c614:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c618:	49c6      	ldr	r1, [pc, #792]	; (800c934 <staticColorButtons+0x6d8>)
 800c61a:	4613      	mov	r3, r2
 800c61c:	011b      	lsls	r3, r3, #4
 800c61e:	1a9b      	subs	r3, r3, r2
 800c620:	009b      	lsls	r3, r3, #2
 800c622:	440b      	add	r3, r1
 800c624:	1c9c      	adds	r4, r3, #2
 800c626:	2200      	movs	r2, #0
 800c628:	2180      	movs	r1, #128	; 0x80
 800c62a:	2080      	movs	r0, #128	; 0x80
 800c62c:	f7ff fd3a 	bl	800c0a4 <lv_color_make>
 800c630:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(128, 128, 0);
 800c632:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c636:	49bf      	ldr	r1, [pc, #764]	; (800c934 <staticColorButtons+0x6d8>)
 800c638:	4613      	mov	r3, r2
 800c63a:	011b      	lsls	r3, r3, #4
 800c63c:	1a9b      	subs	r3, r3, r2
 800c63e:	009b      	lsls	r3, r3, #2
 800c640:	440b      	add	r3, r1
 800c642:	1d1c      	adds	r4, r3, #4
 800c644:	2200      	movs	r2, #0
 800c646:	2180      	movs	r1, #128	; 0x80
 800c648:	2080      	movs	r0, #128	; 0x80
 800c64a:	f7ff fd2b 	bl	800c0a4 <lv_color_make>
 800c64e:	8020      	strh	r0, [r4, #0]
			break;
 800c650:	e1ed      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 7:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(0, 128, 128);
 800c652:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c656:	49b6      	ldr	r1, [pc, #728]	; (800c930 <staticColorButtons+0x6d4>)
 800c658:	4613      	mov	r3, r2
 800c65a:	011b      	lsls	r3, r3, #4
 800c65c:	1a9b      	subs	r3, r3, r2
 800c65e:	009b      	lsls	r3, r3, #2
 800c660:	440b      	add	r3, r1
 800c662:	1c9c      	adds	r4, r3, #2
 800c664:	2280      	movs	r2, #128	; 0x80
 800c666:	2180      	movs	r1, #128	; 0x80
 800c668:	2000      	movs	r0, #0
 800c66a:	f7ff fd1b 	bl	800c0a4 <lv_color_make>
 800c66e:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(0, 128, 128);
 800c670:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c674:	49ae      	ldr	r1, [pc, #696]	; (800c930 <staticColorButtons+0x6d4>)
 800c676:	4613      	mov	r3, r2
 800c678:	011b      	lsls	r3, r3, #4
 800c67a:	1a9b      	subs	r3, r3, r2
 800c67c:	009b      	lsls	r3, r3, #2
 800c67e:	440b      	add	r3, r1
 800c680:	1d1c      	adds	r4, r3, #4
 800c682:	2280      	movs	r2, #128	; 0x80
 800c684:	2180      	movs	r1, #128	; 0x80
 800c686:	2000      	movs	r0, #0
 800c688:	f7ff fd0c 	bl	800c0a4 <lv_color_make>
 800c68c:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(0, 128, 128);
 800c68e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c692:	49a8      	ldr	r1, [pc, #672]	; (800c934 <staticColorButtons+0x6d8>)
 800c694:	4613      	mov	r3, r2
 800c696:	011b      	lsls	r3, r3, #4
 800c698:	1a9b      	subs	r3, r3, r2
 800c69a:	009b      	lsls	r3, r3, #2
 800c69c:	440b      	add	r3, r1
 800c69e:	1c9c      	adds	r4, r3, #2
 800c6a0:	2280      	movs	r2, #128	; 0x80
 800c6a2:	2180      	movs	r1, #128	; 0x80
 800c6a4:	2000      	movs	r0, #0
 800c6a6:	f7ff fcfd 	bl	800c0a4 <lv_color_make>
 800c6aa:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(0, 128, 128);
 800c6ac:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c6b0:	49a0      	ldr	r1, [pc, #640]	; (800c934 <staticColorButtons+0x6d8>)
 800c6b2:	4613      	mov	r3, r2
 800c6b4:	011b      	lsls	r3, r3, #4
 800c6b6:	1a9b      	subs	r3, r3, r2
 800c6b8:	009b      	lsls	r3, r3, #2
 800c6ba:	440b      	add	r3, r1
 800c6bc:	1d1c      	adds	r4, r3, #4
 800c6be:	2280      	movs	r2, #128	; 0x80
 800c6c0:	2180      	movs	r1, #128	; 0x80
 800c6c2:	2000      	movs	r0, #0
 800c6c4:	f7ff fcee 	bl	800c0a4 <lv_color_make>
 800c6c8:	8020      	strh	r0, [r4, #0]
			break;
 800c6ca:	e1b0      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 8:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(0, 255, 0);
 800c6cc:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c6d0:	4997      	ldr	r1, [pc, #604]	; (800c930 <staticColorButtons+0x6d4>)
 800c6d2:	4613      	mov	r3, r2
 800c6d4:	011b      	lsls	r3, r3, #4
 800c6d6:	1a9b      	subs	r3, r3, r2
 800c6d8:	009b      	lsls	r3, r3, #2
 800c6da:	440b      	add	r3, r1
 800c6dc:	1c9c      	adds	r4, r3, #2
 800c6de:	2200      	movs	r2, #0
 800c6e0:	21ff      	movs	r1, #255	; 0xff
 800c6e2:	2000      	movs	r0, #0
 800c6e4:	f7ff fcde 	bl	800c0a4 <lv_color_make>
 800c6e8:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(0, 255, 0);
 800c6ea:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c6ee:	4990      	ldr	r1, [pc, #576]	; (800c930 <staticColorButtons+0x6d4>)
 800c6f0:	4613      	mov	r3, r2
 800c6f2:	011b      	lsls	r3, r3, #4
 800c6f4:	1a9b      	subs	r3, r3, r2
 800c6f6:	009b      	lsls	r3, r3, #2
 800c6f8:	440b      	add	r3, r1
 800c6fa:	1d1c      	adds	r4, r3, #4
 800c6fc:	2200      	movs	r2, #0
 800c6fe:	21ff      	movs	r1, #255	; 0xff
 800c700:	2000      	movs	r0, #0
 800c702:	f7ff fccf 	bl	800c0a4 <lv_color_make>
 800c706:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(0, 255, 0);
 800c708:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c70c:	4989      	ldr	r1, [pc, #548]	; (800c934 <staticColorButtons+0x6d8>)
 800c70e:	4613      	mov	r3, r2
 800c710:	011b      	lsls	r3, r3, #4
 800c712:	1a9b      	subs	r3, r3, r2
 800c714:	009b      	lsls	r3, r3, #2
 800c716:	440b      	add	r3, r1
 800c718:	1c9c      	adds	r4, r3, #2
 800c71a:	2200      	movs	r2, #0
 800c71c:	21ff      	movs	r1, #255	; 0xff
 800c71e:	2000      	movs	r0, #0
 800c720:	f7ff fcc0 	bl	800c0a4 <lv_color_make>
 800c724:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(0, 255, 0);
 800c726:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c72a:	4982      	ldr	r1, [pc, #520]	; (800c934 <staticColorButtons+0x6d8>)
 800c72c:	4613      	mov	r3, r2
 800c72e:	011b      	lsls	r3, r3, #4
 800c730:	1a9b      	subs	r3, r3, r2
 800c732:	009b      	lsls	r3, r3, #2
 800c734:	440b      	add	r3, r1
 800c736:	1d1c      	adds	r4, r3, #4
 800c738:	2200      	movs	r2, #0
 800c73a:	21ff      	movs	r1, #255	; 0xff
 800c73c:	2000      	movs	r0, #0
 800c73e:	f7ff fcb1 	bl	800c0a4 <lv_color_make>
 800c742:	8020      	strh	r0, [r4, #0]
			break;
 800c744:	e173      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 9:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(192, 192, 192);
 800c746:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c74a:	4979      	ldr	r1, [pc, #484]	; (800c930 <staticColorButtons+0x6d4>)
 800c74c:	4613      	mov	r3, r2
 800c74e:	011b      	lsls	r3, r3, #4
 800c750:	1a9b      	subs	r3, r3, r2
 800c752:	009b      	lsls	r3, r3, #2
 800c754:	440b      	add	r3, r1
 800c756:	1c9c      	adds	r4, r3, #2
 800c758:	22c0      	movs	r2, #192	; 0xc0
 800c75a:	21c0      	movs	r1, #192	; 0xc0
 800c75c:	20c0      	movs	r0, #192	; 0xc0
 800c75e:	f7ff fca1 	bl	800c0a4 <lv_color_make>
 800c762:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(192, 192, 192);
 800c764:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c768:	4971      	ldr	r1, [pc, #452]	; (800c930 <staticColorButtons+0x6d4>)
 800c76a:	4613      	mov	r3, r2
 800c76c:	011b      	lsls	r3, r3, #4
 800c76e:	1a9b      	subs	r3, r3, r2
 800c770:	009b      	lsls	r3, r3, #2
 800c772:	440b      	add	r3, r1
 800c774:	1d1c      	adds	r4, r3, #4
 800c776:	22c0      	movs	r2, #192	; 0xc0
 800c778:	21c0      	movs	r1, #192	; 0xc0
 800c77a:	20c0      	movs	r0, #192	; 0xc0
 800c77c:	f7ff fc92 	bl	800c0a4 <lv_color_make>
 800c780:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(192, 192, 192);
 800c782:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c786:	496b      	ldr	r1, [pc, #428]	; (800c934 <staticColorButtons+0x6d8>)
 800c788:	4613      	mov	r3, r2
 800c78a:	011b      	lsls	r3, r3, #4
 800c78c:	1a9b      	subs	r3, r3, r2
 800c78e:	009b      	lsls	r3, r3, #2
 800c790:	440b      	add	r3, r1
 800c792:	1c9c      	adds	r4, r3, #2
 800c794:	22c0      	movs	r2, #192	; 0xc0
 800c796:	21c0      	movs	r1, #192	; 0xc0
 800c798:	20c0      	movs	r0, #192	; 0xc0
 800c79a:	f7ff fc83 	bl	800c0a4 <lv_color_make>
 800c79e:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(192, 192, 192);
 800c7a0:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c7a4:	4963      	ldr	r1, [pc, #396]	; (800c934 <staticColorButtons+0x6d8>)
 800c7a6:	4613      	mov	r3, r2
 800c7a8:	011b      	lsls	r3, r3, #4
 800c7aa:	1a9b      	subs	r3, r3, r2
 800c7ac:	009b      	lsls	r3, r3, #2
 800c7ae:	440b      	add	r3, r1
 800c7b0:	1d1c      	adds	r4, r3, #4
 800c7b2:	22c0      	movs	r2, #192	; 0xc0
 800c7b4:	21c0      	movs	r1, #192	; 0xc0
 800c7b6:	20c0      	movs	r0, #192	; 0xc0
 800c7b8:	f7ff fc74 	bl	800c0a4 <lv_color_make>
 800c7bc:	8020      	strh	r0, [r4, #0]
			break;
 800c7be:	e136      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 10:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(0, 0, 255);
 800c7c0:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c7c4:	495a      	ldr	r1, [pc, #360]	; (800c930 <staticColorButtons+0x6d4>)
 800c7c6:	4613      	mov	r3, r2
 800c7c8:	011b      	lsls	r3, r3, #4
 800c7ca:	1a9b      	subs	r3, r3, r2
 800c7cc:	009b      	lsls	r3, r3, #2
 800c7ce:	440b      	add	r3, r1
 800c7d0:	1c9c      	adds	r4, r3, #2
 800c7d2:	22ff      	movs	r2, #255	; 0xff
 800c7d4:	2100      	movs	r1, #0
 800c7d6:	2000      	movs	r0, #0
 800c7d8:	f7ff fc64 	bl	800c0a4 <lv_color_make>
 800c7dc:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(0, 0, 255);
 800c7de:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c7e2:	4953      	ldr	r1, [pc, #332]	; (800c930 <staticColorButtons+0x6d4>)
 800c7e4:	4613      	mov	r3, r2
 800c7e6:	011b      	lsls	r3, r3, #4
 800c7e8:	1a9b      	subs	r3, r3, r2
 800c7ea:	009b      	lsls	r3, r3, #2
 800c7ec:	440b      	add	r3, r1
 800c7ee:	1d1c      	adds	r4, r3, #4
 800c7f0:	22ff      	movs	r2, #255	; 0xff
 800c7f2:	2100      	movs	r1, #0
 800c7f4:	2000      	movs	r0, #0
 800c7f6:	f7ff fc55 	bl	800c0a4 <lv_color_make>
 800c7fa:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(0, 0, 255);
 800c7fc:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c800:	494c      	ldr	r1, [pc, #304]	; (800c934 <staticColorButtons+0x6d8>)
 800c802:	4613      	mov	r3, r2
 800c804:	011b      	lsls	r3, r3, #4
 800c806:	1a9b      	subs	r3, r3, r2
 800c808:	009b      	lsls	r3, r3, #2
 800c80a:	440b      	add	r3, r1
 800c80c:	1c9c      	adds	r4, r3, #2
 800c80e:	22ff      	movs	r2, #255	; 0xff
 800c810:	2100      	movs	r1, #0
 800c812:	2000      	movs	r0, #0
 800c814:	f7ff fc46 	bl	800c0a4 <lv_color_make>
 800c818:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(0, 0, 255);
 800c81a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c81e:	4945      	ldr	r1, [pc, #276]	; (800c934 <staticColorButtons+0x6d8>)
 800c820:	4613      	mov	r3, r2
 800c822:	011b      	lsls	r3, r3, #4
 800c824:	1a9b      	subs	r3, r3, r2
 800c826:	009b      	lsls	r3, r3, #2
 800c828:	440b      	add	r3, r1
 800c82a:	1d1c      	adds	r4, r3, #4
 800c82c:	22ff      	movs	r2, #255	; 0xff
 800c82e:	2100      	movs	r1, #0
 800c830:	2000      	movs	r0, #0
 800c832:	f7ff fc37 	bl	800c0a4 <lv_color_make>
 800c836:	8020      	strh	r0, [r4, #0]
			break;
 800c838:	e0f9      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 11:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(0, 0, 128);
 800c83a:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c83e:	493c      	ldr	r1, [pc, #240]	; (800c930 <staticColorButtons+0x6d4>)
 800c840:	4613      	mov	r3, r2
 800c842:	011b      	lsls	r3, r3, #4
 800c844:	1a9b      	subs	r3, r3, r2
 800c846:	009b      	lsls	r3, r3, #2
 800c848:	440b      	add	r3, r1
 800c84a:	1c9c      	adds	r4, r3, #2
 800c84c:	2280      	movs	r2, #128	; 0x80
 800c84e:	2100      	movs	r1, #0
 800c850:	2000      	movs	r0, #0
 800c852:	f7ff fc27 	bl	800c0a4 <lv_color_make>
 800c856:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(0, 0, 128);
 800c858:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c85c:	4934      	ldr	r1, [pc, #208]	; (800c930 <staticColorButtons+0x6d4>)
 800c85e:	4613      	mov	r3, r2
 800c860:	011b      	lsls	r3, r3, #4
 800c862:	1a9b      	subs	r3, r3, r2
 800c864:	009b      	lsls	r3, r3, #2
 800c866:	440b      	add	r3, r1
 800c868:	1d1c      	adds	r4, r3, #4
 800c86a:	2280      	movs	r2, #128	; 0x80
 800c86c:	2100      	movs	r1, #0
 800c86e:	2000      	movs	r0, #0
 800c870:	f7ff fc18 	bl	800c0a4 <lv_color_make>
 800c874:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(0, 0, 128);
 800c876:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c87a:	492e      	ldr	r1, [pc, #184]	; (800c934 <staticColorButtons+0x6d8>)
 800c87c:	4613      	mov	r3, r2
 800c87e:	011b      	lsls	r3, r3, #4
 800c880:	1a9b      	subs	r3, r3, r2
 800c882:	009b      	lsls	r3, r3, #2
 800c884:	440b      	add	r3, r1
 800c886:	1c9c      	adds	r4, r3, #2
 800c888:	2280      	movs	r2, #128	; 0x80
 800c88a:	2100      	movs	r1, #0
 800c88c:	2000      	movs	r0, #0
 800c88e:	f7ff fc09 	bl	800c0a4 <lv_color_make>
 800c892:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(0, 0, 128);
 800c894:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c898:	4926      	ldr	r1, [pc, #152]	; (800c934 <staticColorButtons+0x6d8>)
 800c89a:	4613      	mov	r3, r2
 800c89c:	011b      	lsls	r3, r3, #4
 800c89e:	1a9b      	subs	r3, r3, r2
 800c8a0:	009b      	lsls	r3, r3, #2
 800c8a2:	440b      	add	r3, r1
 800c8a4:	1d1c      	adds	r4, r3, #4
 800c8a6:	2280      	movs	r2, #128	; 0x80
 800c8a8:	2100      	movs	r1, #0
 800c8aa:	2000      	movs	r0, #0
 800c8ac:	f7ff fbfa 	bl	800c0a4 <lv_color_make>
 800c8b0:	8020      	strh	r0, [r4, #0]
			break;
 800c8b2:	e0bc      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 12:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(0, 255, 255);
 800c8b4:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c8b8:	491d      	ldr	r1, [pc, #116]	; (800c930 <staticColorButtons+0x6d4>)
 800c8ba:	4613      	mov	r3, r2
 800c8bc:	011b      	lsls	r3, r3, #4
 800c8be:	1a9b      	subs	r3, r3, r2
 800c8c0:	009b      	lsls	r3, r3, #2
 800c8c2:	440b      	add	r3, r1
 800c8c4:	1c9c      	adds	r4, r3, #2
 800c8c6:	22ff      	movs	r2, #255	; 0xff
 800c8c8:	21ff      	movs	r1, #255	; 0xff
 800c8ca:	2000      	movs	r0, #0
 800c8cc:	f7ff fbea 	bl	800c0a4 <lv_color_make>
 800c8d0:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(0, 255, 255);
 800c8d2:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c8d6:	4916      	ldr	r1, [pc, #88]	; (800c930 <staticColorButtons+0x6d4>)
 800c8d8:	4613      	mov	r3, r2
 800c8da:	011b      	lsls	r3, r3, #4
 800c8dc:	1a9b      	subs	r3, r3, r2
 800c8de:	009b      	lsls	r3, r3, #2
 800c8e0:	440b      	add	r3, r1
 800c8e2:	1d1c      	adds	r4, r3, #4
 800c8e4:	22ff      	movs	r2, #255	; 0xff
 800c8e6:	21ff      	movs	r1, #255	; 0xff
 800c8e8:	2000      	movs	r0, #0
 800c8ea:	f7ff fbdb 	bl	800c0a4 <lv_color_make>
 800c8ee:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(0, 255, 255);
 800c8f0:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c8f4:	490f      	ldr	r1, [pc, #60]	; (800c934 <staticColorButtons+0x6d8>)
 800c8f6:	4613      	mov	r3, r2
 800c8f8:	011b      	lsls	r3, r3, #4
 800c8fa:	1a9b      	subs	r3, r3, r2
 800c8fc:	009b      	lsls	r3, r3, #2
 800c8fe:	440b      	add	r3, r1
 800c900:	1c9c      	adds	r4, r3, #2
 800c902:	22ff      	movs	r2, #255	; 0xff
 800c904:	21ff      	movs	r1, #255	; 0xff
 800c906:	2000      	movs	r0, #0
 800c908:	f7ff fbcc 	bl	800c0a4 <lv_color_make>
 800c90c:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(0, 255, 255);
 800c90e:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c912:	4908      	ldr	r1, [pc, #32]	; (800c934 <staticColorButtons+0x6d8>)
 800c914:	4613      	mov	r3, r2
 800c916:	011b      	lsls	r3, r3, #4
 800c918:	1a9b      	subs	r3, r3, r2
 800c91a:	009b      	lsls	r3, r3, #2
 800c91c:	440b      	add	r3, r1
 800c91e:	1d1c      	adds	r4, r3, #4
 800c920:	22ff      	movs	r2, #255	; 0xff
 800c922:	21ff      	movs	r1, #255	; 0xff
 800c924:	2000      	movs	r0, #0
 800c926:	f7ff fbbd 	bl	800c0a4 <lv_color_make>
 800c92a:	8020      	strh	r0, [r4, #0]
			break;
 800c92c:	e07f      	b.n	800ca2e <staticColorButtons+0x7d2>
 800c92e:	bf00      	nop
 800c930:	200037fc 	.word	0x200037fc
 800c934:	20003b80 	.word	0x20003b80
		case 13:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(255, 255, 0);
 800c938:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c93c:	49c9      	ldr	r1, [pc, #804]	; (800cc64 <staticColorButtons+0xa08>)
 800c93e:	4613      	mov	r3, r2
 800c940:	011b      	lsls	r3, r3, #4
 800c942:	1a9b      	subs	r3, r3, r2
 800c944:	009b      	lsls	r3, r3, #2
 800c946:	440b      	add	r3, r1
 800c948:	1c9c      	adds	r4, r3, #2
 800c94a:	2200      	movs	r2, #0
 800c94c:	21ff      	movs	r1, #255	; 0xff
 800c94e:	20ff      	movs	r0, #255	; 0xff
 800c950:	f7ff fba8 	bl	800c0a4 <lv_color_make>
 800c954:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(255, 255, 0);
 800c956:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c95a:	49c2      	ldr	r1, [pc, #776]	; (800cc64 <staticColorButtons+0xa08>)
 800c95c:	4613      	mov	r3, r2
 800c95e:	011b      	lsls	r3, r3, #4
 800c960:	1a9b      	subs	r3, r3, r2
 800c962:	009b      	lsls	r3, r3, #2
 800c964:	440b      	add	r3, r1
 800c966:	1d1c      	adds	r4, r3, #4
 800c968:	2200      	movs	r2, #0
 800c96a:	21ff      	movs	r1, #255	; 0xff
 800c96c:	20ff      	movs	r0, #255	; 0xff
 800c96e:	f7ff fb99 	bl	800c0a4 <lv_color_make>
 800c972:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(255, 255, 0);
 800c974:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c978:	49bb      	ldr	r1, [pc, #748]	; (800cc68 <staticColorButtons+0xa0c>)
 800c97a:	4613      	mov	r3, r2
 800c97c:	011b      	lsls	r3, r3, #4
 800c97e:	1a9b      	subs	r3, r3, r2
 800c980:	009b      	lsls	r3, r3, #2
 800c982:	440b      	add	r3, r1
 800c984:	1c9c      	adds	r4, r3, #2
 800c986:	2200      	movs	r2, #0
 800c988:	21ff      	movs	r1, #255	; 0xff
 800c98a:	20ff      	movs	r0, #255	; 0xff
 800c98c:	f7ff fb8a 	bl	800c0a4 <lv_color_make>
 800c990:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(255, 255, 0);
 800c992:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c996:	49b4      	ldr	r1, [pc, #720]	; (800cc68 <staticColorButtons+0xa0c>)
 800c998:	4613      	mov	r3, r2
 800c99a:	011b      	lsls	r3, r3, #4
 800c99c:	1a9b      	subs	r3, r3, r2
 800c99e:	009b      	lsls	r3, r3, #2
 800c9a0:	440b      	add	r3, r1
 800c9a2:	1d1c      	adds	r4, r3, #4
 800c9a4:	2200      	movs	r2, #0
 800c9a6:	21ff      	movs	r1, #255	; 0xff
 800c9a8:	20ff      	movs	r0, #255	; 0xff
 800c9aa:	f7ff fb7b 	bl	800c0a4 <lv_color_make>
 800c9ae:	8020      	strh	r0, [r4, #0]
			break;
 800c9b0:	e03d      	b.n	800ca2e <staticColorButtons+0x7d2>
		case 14:
			ledStaticColorsRelSyle[count].body.main_color = lv_color_make(255, 255, 255);
 800c9b2:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c9b6:	49ab      	ldr	r1, [pc, #684]	; (800cc64 <staticColorButtons+0xa08>)
 800c9b8:	4613      	mov	r3, r2
 800c9ba:	011b      	lsls	r3, r3, #4
 800c9bc:	1a9b      	subs	r3, r3, r2
 800c9be:	009b      	lsls	r3, r3, #2
 800c9c0:	440b      	add	r3, r1
 800c9c2:	1c9c      	adds	r4, r3, #2
 800c9c4:	22ff      	movs	r2, #255	; 0xff
 800c9c6:	21ff      	movs	r1, #255	; 0xff
 800c9c8:	20ff      	movs	r0, #255	; 0xff
 800c9ca:	f7ff fb6b 	bl	800c0a4 <lv_color_make>
 800c9ce:	8020      	strh	r0, [r4, #0]
			ledStaticColorsRelSyle[count].body.grad_color = lv_color_make(255, 255, 255);
 800c9d0:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c9d4:	49a3      	ldr	r1, [pc, #652]	; (800cc64 <staticColorButtons+0xa08>)
 800c9d6:	4613      	mov	r3, r2
 800c9d8:	011b      	lsls	r3, r3, #4
 800c9da:	1a9b      	subs	r3, r3, r2
 800c9dc:	009b      	lsls	r3, r3, #2
 800c9de:	440b      	add	r3, r1
 800c9e0:	1d1c      	adds	r4, r3, #4
 800c9e2:	22ff      	movs	r2, #255	; 0xff
 800c9e4:	21ff      	movs	r1, #255	; 0xff
 800c9e6:	20ff      	movs	r0, #255	; 0xff
 800c9e8:	f7ff fb5c 	bl	800c0a4 <lv_color_make>
 800c9ec:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.main_color = lv_color_make(255, 255, 255);
 800c9ee:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800c9f2:	499d      	ldr	r1, [pc, #628]	; (800cc68 <staticColorButtons+0xa0c>)
 800c9f4:	4613      	mov	r3, r2
 800c9f6:	011b      	lsls	r3, r3, #4
 800c9f8:	1a9b      	subs	r3, r3, r2
 800c9fa:	009b      	lsls	r3, r3, #2
 800c9fc:	440b      	add	r3, r1
 800c9fe:	1c9c      	adds	r4, r3, #2
 800ca00:	22ff      	movs	r2, #255	; 0xff
 800ca02:	21ff      	movs	r1, #255	; 0xff
 800ca04:	20ff      	movs	r0, #255	; 0xff
 800ca06:	f7ff fb4d 	bl	800c0a4 <lv_color_make>
 800ca0a:	8020      	strh	r0, [r4, #0]
			ledStaticColorsPrStyle[count].body.grad_color = lv_color_make(255, 255, 255);
 800ca0c:	f897 203f 	ldrb.w	r2, [r7, #63]	; 0x3f
 800ca10:	4995      	ldr	r1, [pc, #596]	; (800cc68 <staticColorButtons+0xa0c>)
 800ca12:	4613      	mov	r3, r2
 800ca14:	011b      	lsls	r3, r3, #4
 800ca16:	1a9b      	subs	r3, r3, r2
 800ca18:	009b      	lsls	r3, r3, #2
 800ca1a:	440b      	add	r3, r1
 800ca1c:	1d1c      	adds	r4, r3, #4
 800ca1e:	22ff      	movs	r2, #255	; 0xff
 800ca20:	21ff      	movs	r1, #255	; 0xff
 800ca22:	20ff      	movs	r0, #255	; 0xff
 800ca24:	f7ff fb3e 	bl	800c0a4 <lv_color_make>
 800ca28:	8020      	strh	r0, [r4, #0]
			break;
 800ca2a:	e000      	b.n	800ca2e <staticColorButtons+0x7d2>
		default:
			break;
 800ca2c:	bf00      	nop
	for (uint8_t count = 0; count < 15; count++) {
 800ca2e:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800ca32:	3301      	adds	r3, #1
 800ca34:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
 800ca38:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 800ca3c:	2b0e      	cmp	r3, #14
 800ca3e:	f67f ac14 	bls.w	800c26a <staticColorButtons+0xe>
		}
	}
	for (uint8_t count = 0; count < 15; count++) {
 800ca42:	2300      	movs	r3, #0
 800ca44:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
 800ca48:	e0b8      	b.n	800cbbc <staticColorButtons+0x960>

		ledStaticColors[count] = lv_btn_create(lv_scr_act(), NULL);
 800ca4a:	f7ff fb8b 	bl	800c164 <lv_scr_act>
 800ca4e:	4603      	mov	r3, r0
 800ca50:	f897 403e 	ldrb.w	r4, [r7, #62]	; 0x3e
 800ca54:	2100      	movs	r1, #0
 800ca56:	4618      	mov	r0, r3
 800ca58:	f011 fcfa 	bl	801e450 <lv_btn_create>
 800ca5c:	4602      	mov	r2, r0
 800ca5e:	00a3      	lsls	r3, r4, #2
 800ca60:	f107 0140 	add.w	r1, r7, #64	; 0x40
 800ca64:	440b      	add	r3, r1
 800ca66:	f843 2c40 	str.w	r2, [r3, #-64]
		lv_obj_set_size(ledStaticColors[count], 35, 35);
 800ca6a:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800ca6e:	009b      	lsls	r3, r3, #2
 800ca70:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800ca74:	4413      	add	r3, r2
 800ca76:	f853 3c40 	ldr.w	r3, [r3, #-64]
 800ca7a:	2223      	movs	r2, #35	; 0x23
 800ca7c:	2123      	movs	r1, #35	; 0x23
 800ca7e:	4618      	mov	r0, r3
 800ca80:	f004 fb9b 	bl	80111ba <lv_obj_set_size>

		if (count < 5) {
 800ca84:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800ca88:	2b04      	cmp	r3, #4
 800ca8a:	d820      	bhi.n	800cace <staticColorButtons+0x872>
			lv_obj_align(ledStaticColors[count], NULL, LV_ALIGN_CENTER, -104 + (50 * count), -68);
 800ca8c:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800ca90:	009b      	lsls	r3, r3, #2
 800ca92:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800ca96:	4413      	add	r3, r2
 800ca98:	f853 0c40 	ldr.w	r0, [r3, #-64]
 800ca9c:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800caa0:	b29b      	uxth	r3, r3
 800caa2:	461a      	mov	r2, r3
 800caa4:	0092      	lsls	r2, r2, #2
 800caa6:	4413      	add	r3, r2
 800caa8:	461a      	mov	r2, r3
 800caaa:	0091      	lsls	r1, r2, #2
 800caac:	461a      	mov	r2, r3
 800caae:	460b      	mov	r3, r1
 800cab0:	4413      	add	r3, r2
 800cab2:	005b      	lsls	r3, r3, #1
 800cab4:	b29b      	uxth	r3, r3
 800cab6:	3b68      	subs	r3, #104	; 0x68
 800cab8:	b29b      	uxth	r3, r3
 800caba:	b21a      	sxth	r2, r3
 800cabc:	f06f 0343 	mvn.w	r3, #67	; 0x43
 800cac0:	9300      	str	r3, [sp, #0]
 800cac2:	4613      	mov	r3, r2
 800cac4:	2200      	movs	r2, #0
 800cac6:	2100      	movs	r1, #0
 800cac8:	f004 fc1a 	bl	8011300 <lv_obj_align>
 800cacc:	e049      	b.n	800cb62 <staticColorButtons+0x906>

		}
		else if (count >= 5 && count < 10) {
 800cace:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cad2:	2b04      	cmp	r3, #4
 800cad4:	d925      	bls.n	800cb22 <staticColorButtons+0x8c6>
 800cad6:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cada:	2b09      	cmp	r3, #9
 800cadc:	d821      	bhi.n	800cb22 <staticColorButtons+0x8c6>
			lv_obj_align(ledStaticColors[count], NULL, LV_ALIGN_CENTER, -104 + (50 * (count - 5)), -68 + 50);
 800cade:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cae2:	009b      	lsls	r3, r3, #2
 800cae4:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800cae8:	4413      	add	r3, r2
 800caea:	f853 0c40 	ldr.w	r0, [r3, #-64]
 800caee:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800caf2:	3b05      	subs	r3, #5
 800caf4:	b29b      	uxth	r3, r3
 800caf6:	461a      	mov	r2, r3
 800caf8:	0092      	lsls	r2, r2, #2
 800cafa:	4413      	add	r3, r2
 800cafc:	461a      	mov	r2, r3
 800cafe:	0091      	lsls	r1, r2, #2
 800cb00:	461a      	mov	r2, r3
 800cb02:	460b      	mov	r3, r1
 800cb04:	4413      	add	r3, r2
 800cb06:	005b      	lsls	r3, r3, #1
 800cb08:	b29b      	uxth	r3, r3
 800cb0a:	3b68      	subs	r3, #104	; 0x68
 800cb0c:	b29b      	uxth	r3, r3
 800cb0e:	b21a      	sxth	r2, r3
 800cb10:	f06f 0311 	mvn.w	r3, #17
 800cb14:	9300      	str	r3, [sp, #0]
 800cb16:	4613      	mov	r3, r2
 800cb18:	2200      	movs	r2, #0
 800cb1a:	2100      	movs	r1, #0
 800cb1c:	f004 fbf0 	bl	8011300 <lv_obj_align>
 800cb20:	e01f      	b.n	800cb62 <staticColorButtons+0x906>

		}
		else {
			lv_obj_align(ledStaticColors[count], NULL, LV_ALIGN_CENTER, -104 + (50 * (count - 10)), -68 + 100);
 800cb22:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cb26:	009b      	lsls	r3, r3, #2
 800cb28:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800cb2c:	4413      	add	r3, r2
 800cb2e:	f853 0c40 	ldr.w	r0, [r3, #-64]
 800cb32:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cb36:	3b0a      	subs	r3, #10
 800cb38:	b29b      	uxth	r3, r3
 800cb3a:	461a      	mov	r2, r3
 800cb3c:	0092      	lsls	r2, r2, #2
 800cb3e:	4413      	add	r3, r2
 800cb40:	461a      	mov	r2, r3
 800cb42:	0091      	lsls	r1, r2, #2
 800cb44:	461a      	mov	r2, r3
 800cb46:	460b      	mov	r3, r1
 800cb48:	4413      	add	r3, r2
 800cb4a:	005b      	lsls	r3, r3, #1
 800cb4c:	b29b      	uxth	r3, r3
 800cb4e:	3b68      	subs	r3, #104	; 0x68
 800cb50:	b29b      	uxth	r3, r3
 800cb52:	b21a      	sxth	r2, r3
 800cb54:	2320      	movs	r3, #32
 800cb56:	9300      	str	r3, [sp, #0]
 800cb58:	4613      	mov	r3, r2
 800cb5a:	2200      	movs	r2, #0
 800cb5c:	2100      	movs	r1, #0
 800cb5e:	f004 fbcf 	bl	8011300 <lv_obj_align>

		}
		lv_btn_set_style(ledStaticColors[count], LV_BTN_STYLE_REL, &ledStaticColorsRelSyle[count]);
 800cb62:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cb66:	009b      	lsls	r3, r3, #2
 800cb68:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800cb6c:	4413      	add	r3, r2
 800cb6e:	f853 0c40 	ldr.w	r0, [r3, #-64]
 800cb72:	f897 203e 	ldrb.w	r2, [r7, #62]	; 0x3e
 800cb76:	4613      	mov	r3, r2
 800cb78:	011b      	lsls	r3, r3, #4
 800cb7a:	1a9b      	subs	r3, r3, r2
 800cb7c:	009b      	lsls	r3, r3, #2
 800cb7e:	4a39      	ldr	r2, [pc, #228]	; (800cc64 <staticColorButtons+0xa08>)
 800cb80:	4413      	add	r3, r2
 800cb82:	461a      	mov	r2, r3
 800cb84:	2100      	movs	r1, #0
 800cb86:	f011 fd81 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledStaticColors[count], LV_BTN_STYLE_PR, &ledStaticColorsPrStyle[count]);
 800cb8a:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cb8e:	009b      	lsls	r3, r3, #2
 800cb90:	f107 0240 	add.w	r2, r7, #64	; 0x40
 800cb94:	4413      	add	r3, r2
 800cb96:	f853 0c40 	ldr.w	r0, [r3, #-64]
 800cb9a:	f897 203e 	ldrb.w	r2, [r7, #62]	; 0x3e
 800cb9e:	4613      	mov	r3, r2
 800cba0:	011b      	lsls	r3, r3, #4
 800cba2:	1a9b      	subs	r3, r3, r2
 800cba4:	009b      	lsls	r3, r3, #2
 800cba6:	4a30      	ldr	r2, [pc, #192]	; (800cc68 <staticColorButtons+0xa0c>)
 800cba8:	4413      	add	r3, r2
 800cbaa:	461a      	mov	r2, r3
 800cbac:	2101      	movs	r1, #1
 800cbae:	f011 fd6d 	bl	801e68c <lv_btn_set_style>
	for (uint8_t count = 0; count < 15; count++) {
 800cbb2:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cbb6:	3301      	adds	r3, #1
 800cbb8:	f887 303e 	strb.w	r3, [r7, #62]	; 0x3e
 800cbbc:	f897 303e 	ldrb.w	r3, [r7, #62]	; 0x3e
 800cbc0:	2b0e      	cmp	r3, #14
 800cbc2:	f67f af42 	bls.w	800ca4a <staticColorButtons+0x7ee>

	}
	lv_obj_set_event_cb(ledStaticColors[0], staticColorButton0_event_handler);
 800cbc6:	683b      	ldr	r3, [r7, #0]
 800cbc8:	4928      	ldr	r1, [pc, #160]	; (800cc6c <staticColorButtons+0xa10>)
 800cbca:	4618      	mov	r0, r3
 800cbcc:	f005 f939 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[1], staticColorButton1_event_handler);
 800cbd0:	687b      	ldr	r3, [r7, #4]
 800cbd2:	4927      	ldr	r1, [pc, #156]	; (800cc70 <staticColorButtons+0xa14>)
 800cbd4:	4618      	mov	r0, r3
 800cbd6:	f005 f934 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[2], staticColorButton2_event_handler);
 800cbda:	68bb      	ldr	r3, [r7, #8]
 800cbdc:	4925      	ldr	r1, [pc, #148]	; (800cc74 <staticColorButtons+0xa18>)
 800cbde:	4618      	mov	r0, r3
 800cbe0:	f005 f92f 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[3], staticColorButton3_event_handler);
 800cbe4:	68fb      	ldr	r3, [r7, #12]
 800cbe6:	4924      	ldr	r1, [pc, #144]	; (800cc78 <staticColorButtons+0xa1c>)
 800cbe8:	4618      	mov	r0, r3
 800cbea:	f005 f92a 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[4], staticColorButton4_event_handler);
 800cbee:	693b      	ldr	r3, [r7, #16]
 800cbf0:	4922      	ldr	r1, [pc, #136]	; (800cc7c <staticColorButtons+0xa20>)
 800cbf2:	4618      	mov	r0, r3
 800cbf4:	f005 f925 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[5], staticColorButton5_event_handler);
 800cbf8:	697b      	ldr	r3, [r7, #20]
 800cbfa:	4921      	ldr	r1, [pc, #132]	; (800cc80 <staticColorButtons+0xa24>)
 800cbfc:	4618      	mov	r0, r3
 800cbfe:	f005 f920 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[6], staticColorButton6_event_handler);
 800cc02:	69bb      	ldr	r3, [r7, #24]
 800cc04:	491f      	ldr	r1, [pc, #124]	; (800cc84 <staticColorButtons+0xa28>)
 800cc06:	4618      	mov	r0, r3
 800cc08:	f005 f91b 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[7], staticColorButton7_event_handler);
 800cc0c:	69fb      	ldr	r3, [r7, #28]
 800cc0e:	491e      	ldr	r1, [pc, #120]	; (800cc88 <staticColorButtons+0xa2c>)
 800cc10:	4618      	mov	r0, r3
 800cc12:	f005 f916 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[8], staticColorButton8_event_handler);
 800cc16:	6a3b      	ldr	r3, [r7, #32]
 800cc18:	491c      	ldr	r1, [pc, #112]	; (800cc8c <staticColorButtons+0xa30>)
 800cc1a:	4618      	mov	r0, r3
 800cc1c:	f005 f911 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[9], staticColorButton9_event_handler);
 800cc20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cc22:	491b      	ldr	r1, [pc, #108]	; (800cc90 <staticColorButtons+0xa34>)
 800cc24:	4618      	mov	r0, r3
 800cc26:	f005 f90c 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[10], staticColorButton10_event_handler);
 800cc2a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800cc2c:	4919      	ldr	r1, [pc, #100]	; (800cc94 <staticColorButtons+0xa38>)
 800cc2e:	4618      	mov	r0, r3
 800cc30:	f005 f907 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[11], staticColorButton11_event_handler);
 800cc34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800cc36:	4918      	ldr	r1, [pc, #96]	; (800cc98 <staticColorButtons+0xa3c>)
 800cc38:	4618      	mov	r0, r3
 800cc3a:	f005 f902 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[12], staticColorButton12_event_handler);
 800cc3e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800cc40:	4916      	ldr	r1, [pc, #88]	; (800cc9c <staticColorButtons+0xa40>)
 800cc42:	4618      	mov	r0, r3
 800cc44:	f005 f8fd 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[13], staticColorButton13_event_handler);
 800cc48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800cc4a:	4915      	ldr	r1, [pc, #84]	; (800cca0 <staticColorButtons+0xa44>)
 800cc4c:	4618      	mov	r0, r3
 800cc4e:	f005 f8f8 	bl	8011e42 <lv_obj_set_event_cb>
	lv_obj_set_event_cb(ledStaticColors[14], staticColorButton14_event_handler);
 800cc52:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800cc54:	4913      	ldr	r1, [pc, #76]	; (800cca4 <staticColorButtons+0xa48>)
 800cc56:	4618      	mov	r0, r3
 800cc58:	f005 f8f3 	bl	8011e42 <lv_obj_set_event_cb>


}
 800cc5c:	bf00      	nop
 800cc5e:	3744      	adds	r7, #68	; 0x44
 800cc60:	46bd      	mov	sp, r7
 800cc62:	bd90      	pop	{r4, r7, pc}
 800cc64:	200037fc 	.word	0x200037fc
 800cc68:	20003b80 	.word	0x20003b80
 800cc6c:	0800d455 	.word	0x0800d455
 800cc70:	0800d4b9 	.word	0x0800d4b9
 800cc74:	0800d51d 	.word	0x0800d51d
 800cc78:	0800d581 	.word	0x0800d581
 800cc7c:	0800d5e5 	.word	0x0800d5e5
 800cc80:	0800d649 	.word	0x0800d649
 800cc84:	0800d6ad 	.word	0x0800d6ad
 800cc88:	0800d711 	.word	0x0800d711
 800cc8c:	0800d775 	.word	0x0800d775
 800cc90:	0800d7d9 	.word	0x0800d7d9
 800cc94:	0800d83d 	.word	0x0800d83d
 800cc98:	0800d8a1 	.word	0x0800d8a1
 800cc9c:	0800d905 	.word	0x0800d905
 800cca0:	0800d969 	.word	0x0800d969
 800cca4:	0800d9cd 	.word	0x0800d9cd

0800cca8 <ledRslider>:
void ledRslider(void) {
 800cca8:	b590      	push	{r4, r7, lr}
 800ccaa:	b085      	sub	sp, #20
 800ccac:	af02      	add	r7, sp, #8
	ledSliderStyle();
 800ccae:	f000 ff15 	bl	800dadc <ledSliderStyle>
	static lv_style_t ledSlider_Rstyle_indic;
	lv_style_copy(&ledSlider_Rstyle_indic, &ledSlider_style_indic);
 800ccb2:	4940      	ldr	r1, [pc, #256]	; (800cdb4 <ledRslider+0x10c>)
 800ccb4:	4840      	ldr	r0, [pc, #256]	; (800cdb8 <ledRslider+0x110>)
 800ccb6:	f006 fed5 	bl	8013a64 <lv_style_copy>
	ledSlider_Rstyle_indic.body.main_color = lv_color_make(255, 0, 0);
 800ccba:	4c3f      	ldr	r4, [pc, #252]	; (800cdb8 <ledRslider+0x110>)
 800ccbc:	2200      	movs	r2, #0
 800ccbe:	2100      	movs	r1, #0
 800ccc0:	20ff      	movs	r0, #255	; 0xff
 800ccc2:	f7ff f9ef 	bl	800c0a4 <lv_color_make>
 800ccc6:	8060      	strh	r0, [r4, #2]
	ledSlider_Rstyle_indic.body.grad_color = lv_color_make(255, 0, 0);
 800ccc8:	4c3b      	ldr	r4, [pc, #236]	; (800cdb8 <ledRslider+0x110>)
 800ccca:	2200      	movs	r2, #0
 800cccc:	2100      	movs	r1, #0
 800ccce:	20ff      	movs	r0, #255	; 0xff
 800ccd0:	f7ff f9e8 	bl	800c0a4 <lv_color_make>
 800ccd4:	80a0      	strh	r0, [r4, #4]
	ledSlider_Rstyle_indic.body.shadow.color = ledSlider_Rstyle_indic.body.main_color;
 800ccd6:	4a38      	ldr	r2, [pc, #224]	; (800cdb8 <ledRslider+0x110>)
 800ccd8:	4b37      	ldr	r3, [pc, #220]	; (800cdb8 <ledRslider+0x110>)
 800ccda:	885b      	ldrh	r3, [r3, #2]
 800ccdc:	8213      	strh	r3, [r2, #16]
	ledSlider_Rstyle_indic.text.color = lv_color_make(255, 0, 0);
 800ccde:	4c36      	ldr	r4, [pc, #216]	; (800cdb8 <ledRslider+0x110>)
 800cce0:	2200      	movs	r2, #0
 800cce2:	2100      	movs	r1, #0
 800cce4:	20ff      	movs	r0, #255	; 0xff
 800cce6:	f7ff f9dd 	bl	800c0a4 <lv_color_make>
 800ccea:	8420      	strh	r0, [r4, #32]
	lv_obj_t * slider = lv_slider_create(lv_scr_act(), NULL);
 800ccec:	f7ff fa3a 	bl	800c164 <lv_scr_act>
 800ccf0:	4603      	mov	r3, r0
 800ccf2:	2100      	movs	r1, #0
 800ccf4:	4618      	mov	r0, r3
 800ccf6:	f017 fe57 	bl	80249a8 <lv_slider_create>
 800ccfa:	6078      	str	r0, [r7, #4]
	lv_slider_set_range(slider, 0, 255);
 800ccfc:	22ff      	movs	r2, #255	; 0xff
 800ccfe:	2100      	movs	r1, #0
 800cd00:	6878      	ldr	r0, [r7, #4]
 800cd02:	f7ff fa5c 	bl	800c1be <lv_slider_set_range>
	lv_slider_set_value(slider, ledTempRValues, LV_ANIM_OFF);
 800cd06:	4b2d      	ldr	r3, [pc, #180]	; (800cdbc <ledRslider+0x114>)
 800cd08:	781b      	ldrb	r3, [r3, #0]
 800cd0a:	b21b      	sxth	r3, r3
 800cd0c:	2200      	movs	r2, #0
 800cd0e:	4619      	mov	r1, r3
 800cd10:	6878      	ldr	r0, [r7, #4]
 800cd12:	f7ff fa41 	bl	800c198 <lv_slider_set_value>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_BG, &ledSlider_style_bg);
 800cd16:	4a2a      	ldr	r2, [pc, #168]	; (800cdc0 <ledRslider+0x118>)
 800cd18:	2100      	movs	r1, #0
 800cd1a:	6878      	ldr	r0, [r7, #4]
 800cd1c:	f017 fef0 	bl	8024b00 <lv_slider_set_style>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_INDIC, &ledSlider_Rstyle_indic);
 800cd20:	4a25      	ldr	r2, [pc, #148]	; (800cdb8 <ledRslider+0x110>)
 800cd22:	2101      	movs	r1, #1
 800cd24:	6878      	ldr	r0, [r7, #4]
 800cd26:	f017 feeb 	bl	8024b00 <lv_slider_set_style>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_KNOB, &ledSlider_style_knob);
 800cd2a:	4a26      	ldr	r2, [pc, #152]	; (800cdc4 <ledRslider+0x11c>)
 800cd2c:	2102      	movs	r1, #2
 800cd2e:	6878      	ldr	r0, [r7, #4]
 800cd30:	f017 fee6 	bl	8024b00 <lv_slider_set_style>
	lv_obj_align(slider, NULL, LV_ALIGN_CENTER, -15, -50);
 800cd34:	f06f 0331 	mvn.w	r3, #49	; 0x31
 800cd38:	9300      	str	r3, [sp, #0]
 800cd3a:	f06f 030e 	mvn.w	r3, #14
 800cd3e:	2200      	movs	r2, #0
 800cd40:	2100      	movs	r1, #0
 800cd42:	6878      	ldr	r0, [r7, #4]
 800cd44:	f004 fadc 	bl	8011300 <lv_obj_align>
	lv_obj_set_event_cb(slider, ledRslider_event_handler);
 800cd48:	491f      	ldr	r1, [pc, #124]	; (800cdc8 <ledRslider+0x120>)
 800cd4a:	6878      	ldr	r0, [r7, #4]
 800cd4c:	f005 f879 	bl	8011e42 <lv_obj_set_event_cb>

	ledRvalueLabel = lv_label_create(lv_scr_act(), NULL);
 800cd50:	f7ff fa08 	bl	800c164 <lv_scr_act>
 800cd54:	4603      	mov	r3, r0
 800cd56:	2100      	movs	r1, #0
 800cd58:	4618      	mov	r0, r3
 800cd5a:	f014 fb7f 	bl	802145c <lv_label_create>
 800cd5e:	4602      	mov	r2, r0
 800cd60:	4b1a      	ldr	r3, [pc, #104]	; (800cdcc <ledRslider+0x124>)
 800cd62:	601a      	str	r2, [r3, #0]
	lv_label_set_style(ledRvalueLabel,LV_LABEL_STYLE_MAIN,&ledSlider_Rstyle_indic);
 800cd64:	4b19      	ldr	r3, [pc, #100]	; (800cdcc <ledRslider+0x124>)
 800cd66:	681b      	ldr	r3, [r3, #0]
 800cd68:	4a13      	ldr	r2, [pc, #76]	; (800cdb8 <ledRslider+0x110>)
 800cd6a:	2100      	movs	r1, #0
 800cd6c:	4618      	mov	r0, r3
 800cd6e:	f7ff fa04 	bl	800c17a <lv_label_set_style>
	static char subSliderbuf[4];
	snprintf(subSliderbuf, 4, "%d", ledTempRValues);
 800cd72:	4b12      	ldr	r3, [pc, #72]	; (800cdbc <ledRslider+0x114>)
 800cd74:	781b      	ldrb	r3, [r3, #0]
 800cd76:	4a16      	ldr	r2, [pc, #88]	; (800cdd0 <ledRslider+0x128>)
 800cd78:	2104      	movs	r1, #4
 800cd7a:	4816      	ldr	r0, [pc, #88]	; (800cdd4 <ledRslider+0x12c>)
 800cd7c:	f01a fa8e 	bl	802729c <sniprintf>
	lv_label_set_text(ledRvalueLabel, subSliderbuf);
 800cd80:	4b12      	ldr	r3, [pc, #72]	; (800cdcc <ledRslider+0x124>)
 800cd82:	681b      	ldr	r3, [r3, #0]
 800cd84:	4913      	ldr	r1, [pc, #76]	; (800cdd4 <ledRslider+0x12c>)
 800cd86:	4618      	mov	r0, r3
 800cd88:	f014 fcb0 	bl	80216ec <lv_label_set_text>
	lv_obj_set_auto_realign(ledRvalueLabel, true);
 800cd8c:	4b0f      	ldr	r3, [pc, #60]	; (800cdcc <ledRslider+0x124>)
 800cd8e:	681b      	ldr	r3, [r3, #0]
 800cd90:	2101      	movs	r1, #1
 800cd92:	4618      	mov	r0, r3
 800cd94:	f004 ff79 	bl	8011c8a <lv_obj_set_auto_realign>
	lv_obj_align(ledRvalueLabel, NULL, LV_ALIGN_CENTER, 113, -50);
 800cd98:	4b0c      	ldr	r3, [pc, #48]	; (800cdcc <ledRslider+0x124>)
 800cd9a:	6818      	ldr	r0, [r3, #0]
 800cd9c:	f06f 0331 	mvn.w	r3, #49	; 0x31
 800cda0:	9300      	str	r3, [sp, #0]
 800cda2:	2371      	movs	r3, #113	; 0x71
 800cda4:	2200      	movs	r2, #0
 800cda6:	2100      	movs	r1, #0
 800cda8:	f004 faaa 	bl	8011300 <lv_obj_align>

}
 800cdac:	bf00      	nop
 800cdae:	370c      	adds	r7, #12
 800cdb0:	46bd      	mov	sp, r7
 800cdb2:	bd90      	pop	{r4, r7, pc}
 800cdb4:	200035d8 	.word	0x200035d8
 800cdb8:	20003f04 	.word	0x20003f04
 800cdbc:	200037f4 	.word	0x200037f4
 800cdc0:	2000359c 	.word	0x2000359c
 800cdc4:	20003614 	.word	0x20003614
 800cdc8:	0800d215 	.word	0x0800d215
 800cdcc:	2000dc2c 	.word	0x2000dc2c
 800cdd0:	080283f8 	.word	0x080283f8
 800cdd4:	20003f40 	.word	0x20003f40

0800cdd8 <ledGslider>:
void ledGslider(void) {
 800cdd8:	b590      	push	{r4, r7, lr}
 800cdda:	b085      	sub	sp, #20
 800cddc:	af02      	add	r7, sp, #8
	ledSliderStyle();
 800cdde:	f000 fe7d 	bl	800dadc <ledSliderStyle>
	static lv_style_t ledSlider_Gstyle_indic;
	lv_style_copy(&ledSlider_Gstyle_indic, &ledSlider_style_indic);
 800cde2:	493f      	ldr	r1, [pc, #252]	; (800cee0 <ledGslider+0x108>)
 800cde4:	483f      	ldr	r0, [pc, #252]	; (800cee4 <ledGslider+0x10c>)
 800cde6:	f006 fe3d 	bl	8013a64 <lv_style_copy>
	ledSlider_Gstyle_indic.body.main_color = lv_color_make(0,255, 0);
 800cdea:	4c3e      	ldr	r4, [pc, #248]	; (800cee4 <ledGslider+0x10c>)
 800cdec:	2200      	movs	r2, #0
 800cdee:	21ff      	movs	r1, #255	; 0xff
 800cdf0:	2000      	movs	r0, #0
 800cdf2:	f7ff f957 	bl	800c0a4 <lv_color_make>
 800cdf6:	8060      	strh	r0, [r4, #2]
	ledSlider_Gstyle_indic.body.grad_color = lv_color_make(0, 255, 0);
 800cdf8:	4c3a      	ldr	r4, [pc, #232]	; (800cee4 <ledGslider+0x10c>)
 800cdfa:	2200      	movs	r2, #0
 800cdfc:	21ff      	movs	r1, #255	; 0xff
 800cdfe:	2000      	movs	r0, #0
 800ce00:	f7ff f950 	bl	800c0a4 <lv_color_make>
 800ce04:	80a0      	strh	r0, [r4, #4]
	ledSlider_Gstyle_indic.body.shadow.color = ledSlider_Gstyle_indic.body.main_color;
 800ce06:	4a37      	ldr	r2, [pc, #220]	; (800cee4 <ledGslider+0x10c>)
 800ce08:	4b36      	ldr	r3, [pc, #216]	; (800cee4 <ledGslider+0x10c>)
 800ce0a:	885b      	ldrh	r3, [r3, #2]
 800ce0c:	8213      	strh	r3, [r2, #16]
	ledSlider_Gstyle_indic.text.color = lv_color_make(0, 255, 0);
 800ce0e:	4c35      	ldr	r4, [pc, #212]	; (800cee4 <ledGslider+0x10c>)
 800ce10:	2200      	movs	r2, #0
 800ce12:	21ff      	movs	r1, #255	; 0xff
 800ce14:	2000      	movs	r0, #0
 800ce16:	f7ff f945 	bl	800c0a4 <lv_color_make>
 800ce1a:	8420      	strh	r0, [r4, #32]
	lv_obj_t * slider = lv_slider_create(lv_scr_act(), NULL);
 800ce1c:	f7ff f9a2 	bl	800c164 <lv_scr_act>
 800ce20:	4603      	mov	r3, r0
 800ce22:	2100      	movs	r1, #0
 800ce24:	4618      	mov	r0, r3
 800ce26:	f017 fdbf 	bl	80249a8 <lv_slider_create>
 800ce2a:	6078      	str	r0, [r7, #4]
	lv_slider_set_value(slider, ledTempGValues, LV_ANIM_OFF);
 800ce2c:	4b2e      	ldr	r3, [pc, #184]	; (800cee8 <ledGslider+0x110>)
 800ce2e:	781b      	ldrb	r3, [r3, #0]
 800ce30:	b21b      	sxth	r3, r3
 800ce32:	2200      	movs	r2, #0
 800ce34:	4619      	mov	r1, r3
 800ce36:	6878      	ldr	r0, [r7, #4]
 800ce38:	f7ff f9ae 	bl	800c198 <lv_slider_set_value>
	lv_slider_set_range(slider, 0, 255);
 800ce3c:	22ff      	movs	r2, #255	; 0xff
 800ce3e:	2100      	movs	r1, #0
 800ce40:	6878      	ldr	r0, [r7, #4]
 800ce42:	f7ff f9bc 	bl	800c1be <lv_slider_set_range>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_BG, &ledSlider_style_bg);
 800ce46:	4a29      	ldr	r2, [pc, #164]	; (800ceec <ledGslider+0x114>)
 800ce48:	2100      	movs	r1, #0
 800ce4a:	6878      	ldr	r0, [r7, #4]
 800ce4c:	f017 fe58 	bl	8024b00 <lv_slider_set_style>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_INDIC, &ledSlider_Gstyle_indic);
 800ce50:	4a24      	ldr	r2, [pc, #144]	; (800cee4 <ledGslider+0x10c>)
 800ce52:	2101      	movs	r1, #1
 800ce54:	6878      	ldr	r0, [r7, #4]
 800ce56:	f017 fe53 	bl	8024b00 <lv_slider_set_style>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_KNOB, &ledSlider_style_knob);
 800ce5a:	4a25      	ldr	r2, [pc, #148]	; (800cef0 <ledGslider+0x118>)
 800ce5c:	2102      	movs	r1, #2
 800ce5e:	6878      	ldr	r0, [r7, #4]
 800ce60:	f017 fe4e 	bl	8024b00 <lv_slider_set_style>
	lv_obj_align(slider, NULL, LV_ALIGN_CENTER, -15, 0);
 800ce64:	2300      	movs	r3, #0
 800ce66:	9300      	str	r3, [sp, #0]
 800ce68:	f06f 030e 	mvn.w	r3, #14
 800ce6c:	2200      	movs	r2, #0
 800ce6e:	2100      	movs	r1, #0
 800ce70:	6878      	ldr	r0, [r7, #4]
 800ce72:	f004 fa45 	bl	8011300 <lv_obj_align>
	lv_obj_set_event_cb(slider, ledGslider_event_handler);
 800ce76:	491f      	ldr	r1, [pc, #124]	; (800cef4 <ledGslider+0x11c>)
 800ce78:	6878      	ldr	r0, [r7, #4]
 800ce7a:	f004 ffe2 	bl	8011e42 <lv_obj_set_event_cb>


	ledGvalueLabel = lv_label_create(lv_scr_act(), NULL);
 800ce7e:	f7ff f971 	bl	800c164 <lv_scr_act>
 800ce82:	4603      	mov	r3, r0
 800ce84:	2100      	movs	r1, #0
 800ce86:	4618      	mov	r0, r3
 800ce88:	f014 fae8 	bl	802145c <lv_label_create>
 800ce8c:	4602      	mov	r2, r0
 800ce8e:	4b1a      	ldr	r3, [pc, #104]	; (800cef8 <ledGslider+0x120>)
 800ce90:	601a      	str	r2, [r3, #0]
	lv_label_set_style(ledGvalueLabel, LV_LABEL_STYLE_MAIN, &ledSlider_Gstyle_indic);
 800ce92:	4b19      	ldr	r3, [pc, #100]	; (800cef8 <ledGslider+0x120>)
 800ce94:	681b      	ldr	r3, [r3, #0]
 800ce96:	4a13      	ldr	r2, [pc, #76]	; (800cee4 <ledGslider+0x10c>)
 800ce98:	2100      	movs	r1, #0
 800ce9a:	4618      	mov	r0, r3
 800ce9c:	f7ff f96d 	bl	800c17a <lv_label_set_style>
	static char subSliderbuf[4];
	snprintf(subSliderbuf, 4, "%d", ledTempGValues);
 800cea0:	4b11      	ldr	r3, [pc, #68]	; (800cee8 <ledGslider+0x110>)
 800cea2:	781b      	ldrb	r3, [r3, #0]
 800cea4:	4a15      	ldr	r2, [pc, #84]	; (800cefc <ledGslider+0x124>)
 800cea6:	2104      	movs	r1, #4
 800cea8:	4815      	ldr	r0, [pc, #84]	; (800cf00 <ledGslider+0x128>)
 800ceaa:	f01a f9f7 	bl	802729c <sniprintf>
	lv_label_set_text(ledGvalueLabel, subSliderbuf);
 800ceae:	4b12      	ldr	r3, [pc, #72]	; (800cef8 <ledGslider+0x120>)
 800ceb0:	681b      	ldr	r3, [r3, #0]
 800ceb2:	4913      	ldr	r1, [pc, #76]	; (800cf00 <ledGslider+0x128>)
 800ceb4:	4618      	mov	r0, r3
 800ceb6:	f014 fc19 	bl	80216ec <lv_label_set_text>
	lv_obj_set_auto_realign(ledGvalueLabel, true);
 800ceba:	4b0f      	ldr	r3, [pc, #60]	; (800cef8 <ledGslider+0x120>)
 800cebc:	681b      	ldr	r3, [r3, #0]
 800cebe:	2101      	movs	r1, #1
 800cec0:	4618      	mov	r0, r3
 800cec2:	f004 fee2 	bl	8011c8a <lv_obj_set_auto_realign>
	lv_obj_align(ledGvalueLabel, NULL, LV_ALIGN_CENTER, 113, 0);
 800cec6:	4b0c      	ldr	r3, [pc, #48]	; (800cef8 <ledGslider+0x120>)
 800cec8:	6818      	ldr	r0, [r3, #0]
 800ceca:	2300      	movs	r3, #0
 800cecc:	9300      	str	r3, [sp, #0]
 800cece:	2371      	movs	r3, #113	; 0x71
 800ced0:	2200      	movs	r2, #0
 800ced2:	2100      	movs	r1, #0
 800ced4:	f004 fa14 	bl	8011300 <lv_obj_align>
}
 800ced8:	bf00      	nop
 800ceda:	370c      	adds	r7, #12
 800cedc:	46bd      	mov	sp, r7
 800cede:	bd90      	pop	{r4, r7, pc}
 800cee0:	200035d8 	.word	0x200035d8
 800cee4:	20003f44 	.word	0x20003f44
 800cee8:	200037f5 	.word	0x200037f5
 800ceec:	2000359c 	.word	0x2000359c
 800cef0:	20003614 	.word	0x20003614
 800cef4:	0800d2ad 	.word	0x0800d2ad
 800cef8:	2000dc30 	.word	0x2000dc30
 800cefc:	080283f8 	.word	0x080283f8
 800cf00:	20003f80 	.word	0x20003f80

0800cf04 <ledBslider>:
void ledBslider(void) {
 800cf04:	b590      	push	{r4, r7, lr}
 800cf06:	b085      	sub	sp, #20
 800cf08:	af02      	add	r7, sp, #8
	ledSliderStyle();
 800cf0a:	f000 fde7 	bl	800dadc <ledSliderStyle>
	ledSlider_style_indic.body.main_color = lv_color_make(0, 0, 255);
 800cf0e:	4c3a      	ldr	r4, [pc, #232]	; (800cff8 <ledBslider+0xf4>)
 800cf10:	22ff      	movs	r2, #255	; 0xff
 800cf12:	2100      	movs	r1, #0
 800cf14:	2000      	movs	r0, #0
 800cf16:	f7ff f8c5 	bl	800c0a4 <lv_color_make>
 800cf1a:	8060      	strh	r0, [r4, #2]
	ledSlider_style_indic.body.grad_color = lv_color_make(0, 0, 255);
 800cf1c:	4c36      	ldr	r4, [pc, #216]	; (800cff8 <ledBslider+0xf4>)
 800cf1e:	22ff      	movs	r2, #255	; 0xff
 800cf20:	2100      	movs	r1, #0
 800cf22:	2000      	movs	r0, #0
 800cf24:	f7ff f8be 	bl	800c0a4 <lv_color_make>
 800cf28:	80a0      	strh	r0, [r4, #4]
	ledSlider_style_indic.body.shadow.color = ledSlider_style_indic.body.main_color;
 800cf2a:	4a33      	ldr	r2, [pc, #204]	; (800cff8 <ledBslider+0xf4>)
 800cf2c:	4b32      	ldr	r3, [pc, #200]	; (800cff8 <ledBslider+0xf4>)
 800cf2e:	885b      	ldrh	r3, [r3, #2]
 800cf30:	8213      	strh	r3, [r2, #16]

	lv_obj_t * slider = lv_slider_create(lv_scr_act(), NULL);
 800cf32:	f7ff f917 	bl	800c164 <lv_scr_act>
 800cf36:	4603      	mov	r3, r0
 800cf38:	2100      	movs	r1, #0
 800cf3a:	4618      	mov	r0, r3
 800cf3c:	f017 fd34 	bl	80249a8 <lv_slider_create>
 800cf40:	6078      	str	r0, [r7, #4]
	lv_slider_set_value(slider, ledTempBValues, LV_ANIM_OFF);
 800cf42:	4b2e      	ldr	r3, [pc, #184]	; (800cffc <ledBslider+0xf8>)
 800cf44:	781b      	ldrb	r3, [r3, #0]
 800cf46:	b21b      	sxth	r3, r3
 800cf48:	2200      	movs	r2, #0
 800cf4a:	4619      	mov	r1, r3
 800cf4c:	6878      	ldr	r0, [r7, #4]
 800cf4e:	f7ff f923 	bl	800c198 <lv_slider_set_value>
	lv_slider_set_range(slider, 0, 255);
 800cf52:	22ff      	movs	r2, #255	; 0xff
 800cf54:	2100      	movs	r1, #0
 800cf56:	6878      	ldr	r0, [r7, #4]
 800cf58:	f7ff f931 	bl	800c1be <lv_slider_set_range>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_BG, &ledSlider_style_bg);
 800cf5c:	4a28      	ldr	r2, [pc, #160]	; (800d000 <ledBslider+0xfc>)
 800cf5e:	2100      	movs	r1, #0
 800cf60:	6878      	ldr	r0, [r7, #4]
 800cf62:	f017 fdcd 	bl	8024b00 <lv_slider_set_style>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_INDIC, &ledSlider_style_indic);
 800cf66:	4a24      	ldr	r2, [pc, #144]	; (800cff8 <ledBslider+0xf4>)
 800cf68:	2101      	movs	r1, #1
 800cf6a:	6878      	ldr	r0, [r7, #4]
 800cf6c:	f017 fdc8 	bl	8024b00 <lv_slider_set_style>
	lv_slider_set_style(slider, LV_SLIDER_STYLE_KNOB, &ledSlider_style_knob);
 800cf70:	4a24      	ldr	r2, [pc, #144]	; (800d004 <ledBslider+0x100>)
 800cf72:	2102      	movs	r1, #2
 800cf74:	6878      	ldr	r0, [r7, #4]
 800cf76:	f017 fdc3 	bl	8024b00 <lv_slider_set_style>
	lv_obj_align(slider, NULL, LV_ALIGN_CENTER, -15, 50);
 800cf7a:	2332      	movs	r3, #50	; 0x32
 800cf7c:	9300      	str	r3, [sp, #0]
 800cf7e:	f06f 030e 	mvn.w	r3, #14
 800cf82:	2200      	movs	r2, #0
 800cf84:	2100      	movs	r1, #0
 800cf86:	6878      	ldr	r0, [r7, #4]
 800cf88:	f004 f9ba 	bl	8011300 <lv_obj_align>
	lv_obj_set_event_cb(slider, ledBslider_event_handler);
 800cf8c:	491e      	ldr	r1, [pc, #120]	; (800d008 <ledBslider+0x104>)
 800cf8e:	6878      	ldr	r0, [r7, #4]
 800cf90:	f004 ff57 	bl	8011e42 <lv_obj_set_event_cb>


	ledBvalueLabel = lv_label_create(lv_scr_act(), NULL);
 800cf94:	f7ff f8e6 	bl	800c164 <lv_scr_act>
 800cf98:	4603      	mov	r3, r0
 800cf9a:	2100      	movs	r1, #0
 800cf9c:	4618      	mov	r0, r3
 800cf9e:	f014 fa5d 	bl	802145c <lv_label_create>
 800cfa2:	4602      	mov	r2, r0
 800cfa4:	4b19      	ldr	r3, [pc, #100]	; (800d00c <ledBslider+0x108>)
 800cfa6:	601a      	str	r2, [r3, #0]
	lv_label_set_style(ledBvalueLabel, LV_LABEL_STYLE_MAIN, &ledSlider_style_indic);
 800cfa8:	4b18      	ldr	r3, [pc, #96]	; (800d00c <ledBslider+0x108>)
 800cfaa:	681b      	ldr	r3, [r3, #0]
 800cfac:	4a12      	ldr	r2, [pc, #72]	; (800cff8 <ledBslider+0xf4>)
 800cfae:	2100      	movs	r1, #0
 800cfb0:	4618      	mov	r0, r3
 800cfb2:	f7ff f8e2 	bl	800c17a <lv_label_set_style>
	static char subSliderbuf[4];
	snprintf(subSliderbuf, 4, "%d", ledTempBValues);
 800cfb6:	4b11      	ldr	r3, [pc, #68]	; (800cffc <ledBslider+0xf8>)
 800cfb8:	781b      	ldrb	r3, [r3, #0]
 800cfba:	4a15      	ldr	r2, [pc, #84]	; (800d010 <ledBslider+0x10c>)
 800cfbc:	2104      	movs	r1, #4
 800cfbe:	4815      	ldr	r0, [pc, #84]	; (800d014 <ledBslider+0x110>)
 800cfc0:	f01a f96c 	bl	802729c <sniprintf>
	lv_label_set_text(ledBvalueLabel, subSliderbuf);
 800cfc4:	4b11      	ldr	r3, [pc, #68]	; (800d00c <ledBslider+0x108>)
 800cfc6:	681b      	ldr	r3, [r3, #0]
 800cfc8:	4912      	ldr	r1, [pc, #72]	; (800d014 <ledBslider+0x110>)
 800cfca:	4618      	mov	r0, r3
 800cfcc:	f014 fb8e 	bl	80216ec <lv_label_set_text>
	lv_obj_set_auto_realign(ledBvalueLabel, true);
 800cfd0:	4b0e      	ldr	r3, [pc, #56]	; (800d00c <ledBslider+0x108>)
 800cfd2:	681b      	ldr	r3, [r3, #0]
 800cfd4:	2101      	movs	r1, #1
 800cfd6:	4618      	mov	r0, r3
 800cfd8:	f004 fe57 	bl	8011c8a <lv_obj_set_auto_realign>
	lv_obj_align(ledBvalueLabel, NULL, LV_ALIGN_CENTER, 113, 50);
 800cfdc:	4b0b      	ldr	r3, [pc, #44]	; (800d00c <ledBslider+0x108>)
 800cfde:	6818      	ldr	r0, [r3, #0]
 800cfe0:	2332      	movs	r3, #50	; 0x32
 800cfe2:	9300      	str	r3, [sp, #0]
 800cfe4:	2371      	movs	r3, #113	; 0x71
 800cfe6:	2200      	movs	r2, #0
 800cfe8:	2100      	movs	r1, #0
 800cfea:	f004 f989 	bl	8011300 <lv_obj_align>
}
 800cfee:	bf00      	nop
 800cff0:	370c      	adds	r7, #12
 800cff2:	46bd      	mov	sp, r7
 800cff4:	bd90      	pop	{r4, r7, pc}
 800cff6:	bf00      	nop
 800cff8:	200035d8 	.word	0x200035d8
 800cffc:	200037f6 	.word	0x200037f6
 800d000:	2000359c 	.word	0x2000359c
 800d004:	20003614 	.word	0x20003614
 800d008:	0800d345 	.word	0x0800d345
 800d00c:	2000dc24 	.word	0x2000dc24
 800d010:	080283f8 	.word	0x080283f8
 800d014:	20003f84 	.word	0x20003f84

0800d018 <setNewColorButton>:
void setNewColorButton(void) {
 800d018:	b580      	push	{r7, lr}
 800d01a:	b084      	sub	sp, #16
 800d01c:	af02      	add	r7, sp, #8
	
	ledButtonStyle();
 800d01e:	f000 fdc7 	bl	800dbb0 <ledButtonStyle>

	ledSetColorbtn = lv_btn_create(lv_scr_act(), NULL);
 800d022:	f7ff f89f 	bl	800c164 <lv_scr_act>
 800d026:	4603      	mov	r3, r0
 800d028:	2100      	movs	r1, #0
 800d02a:	4618      	mov	r0, r3
 800d02c:	f011 fa10 	bl	801e450 <lv_btn_create>
 800d030:	4602      	mov	r2, r0
 800d032:	4b1a      	ldr	r3, [pc, #104]	; (800d09c <setNewColorButton+0x84>)
 800d034:	601a      	str	r2, [r3, #0]
	lv_obj_align(ledSetColorbtn, NULL, LV_ALIGN_CENTER, 0, 110);
 800d036:	4b19      	ldr	r3, [pc, #100]	; (800d09c <setNewColorButton+0x84>)
 800d038:	6818      	ldr	r0, [r3, #0]
 800d03a:	236e      	movs	r3, #110	; 0x6e
 800d03c:	9300      	str	r3, [sp, #0]
 800d03e:	2300      	movs	r3, #0
 800d040:	2200      	movs	r2, #0
 800d042:	2100      	movs	r1, #0
 800d044:	f004 f95c 	bl	8011300 <lv_obj_align>
	lv_obj_set_size(ledSetColorbtn, 70, 35);
 800d048:	4b14      	ldr	r3, [pc, #80]	; (800d09c <setNewColorButton+0x84>)
 800d04a:	681b      	ldr	r3, [r3, #0]
 800d04c:	2223      	movs	r2, #35	; 0x23
 800d04e:	2146      	movs	r1, #70	; 0x46
 800d050:	4618      	mov	r0, r3
 800d052:	f004 f8b2 	bl	80111ba <lv_obj_set_size>
	lv_obj_set_event_cb(ledSetColorbtn, setNewColorButton_event_handler);
 800d056:	4b11      	ldr	r3, [pc, #68]	; (800d09c <setNewColorButton+0x84>)
 800d058:	681b      	ldr	r3, [r3, #0]
 800d05a:	4911      	ldr	r1, [pc, #68]	; (800d0a0 <setNewColorButton+0x88>)
 800d05c:	4618      	mov	r0, r3
 800d05e:	f004 fef0 	bl	8011e42 <lv_obj_set_event_cb>

	lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d062:	4b0e      	ldr	r3, [pc, #56]	; (800d09c <setNewColorButton+0x84>)
 800d064:	681b      	ldr	r3, [r3, #0]
 800d066:	4a0f      	ldr	r2, [pc, #60]	; (800d0a4 <setNewColorButton+0x8c>)
 800d068:	2100      	movs	r1, #0
 800d06a:	4618      	mov	r0, r3
 800d06c:	f011 fb0e 	bl	801e68c <lv_btn_set_style>
	lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d070:	4b0a      	ldr	r3, [pc, #40]	; (800d09c <setNewColorButton+0x84>)
 800d072:	681b      	ldr	r3, [r3, #0]
 800d074:	4a0c      	ldr	r2, [pc, #48]	; (800d0a8 <setNewColorButton+0x90>)
 800d076:	2101      	movs	r1, #1
 800d078:	4618      	mov	r0, r3
 800d07a:	f011 fb07 	bl	801e68c <lv_btn_set_style>

	lv_obj_t * label = lv_label_create(ledSetColorbtn, NULL);
 800d07e:	4b07      	ldr	r3, [pc, #28]	; (800d09c <setNewColorButton+0x84>)
 800d080:	681b      	ldr	r3, [r3, #0]
 800d082:	2100      	movs	r1, #0
 800d084:	4618      	mov	r0, r3
 800d086:	f014 f9e9 	bl	802145c <lv_label_create>
 800d08a:	6078      	str	r0, [r7, #4]
	lv_label_set_text(label, "Rengi Ata");
 800d08c:	4907      	ldr	r1, [pc, #28]	; (800d0ac <setNewColorButton+0x94>)
 800d08e:	6878      	ldr	r0, [r7, #4]
 800d090:	f014 fb2c 	bl	80216ec <lv_label_set_text>
}
 800d094:	bf00      	nop
 800d096:	3708      	adds	r7, #8
 800d098:	46bd      	mov	sp, r7
 800d09a:	bd80      	pop	{r7, pc}
 800d09c:	2000dc28 	.word	0x2000dc28
 800d0a0:	0800d3dd 	.word	0x0800d3dd
 800d0a4:	20003650 	.word	0x20003650
 800d0a8:	2000368c 	.word	0x2000368c
 800d0ac:	080283fc 	.word	0x080283fc

0800d0b0 <outGoingColorContainer>:
void outGoingColorContainer(void) {
 800d0b0:	b580      	push	{r7, lr}
 800d0b2:	b084      	sub	sp, #16
 800d0b4:	af02      	add	r7, sp, #8
	outGoingColorContainerStyle();
 800d0b6:	f000 fe09 	bl	800dccc <outGoingColorContainerStyle>
	ledOutGoingContainer = lv_btn_create(lv_scr_act(), NULL);
 800d0ba:	f7ff f853 	bl	800c164 <lv_scr_act>
 800d0be:	4603      	mov	r3, r0
 800d0c0:	2100      	movs	r1, #0
 800d0c2:	4618      	mov	r0, r3
 800d0c4:	f011 f9c4 	bl	801e450 <lv_btn_create>
 800d0c8:	4602      	mov	r2, r0
 800d0ca:	4b18      	ldr	r3, [pc, #96]	; (800d12c <outGoingColorContainer+0x7c>)
 800d0cc:	601a      	str	r2, [r3, #0]
	lv_obj_set_size(ledOutGoingContainer, 50, 25);
 800d0ce:	4b17      	ldr	r3, [pc, #92]	; (800d12c <outGoingColorContainer+0x7c>)
 800d0d0:	681b      	ldr	r3, [r3, #0]
 800d0d2:	2219      	movs	r2, #25
 800d0d4:	2132      	movs	r1, #50	; 0x32
 800d0d6:	4618      	mov	r0, r3
 800d0d8:	f004 f86f 	bl	80111ba <lv_obj_set_size>
	lv_obj_align(ledOutGoingContainer, NULL, LV_ALIGN_CENTER, 100, -120);
 800d0dc:	4b13      	ldr	r3, [pc, #76]	; (800d12c <outGoingColorContainer+0x7c>)
 800d0de:	6818      	ldr	r0, [r3, #0]
 800d0e0:	f06f 0377 	mvn.w	r3, #119	; 0x77
 800d0e4:	9300      	str	r3, [sp, #0]
 800d0e6:	2364      	movs	r3, #100	; 0x64
 800d0e8:	2200      	movs	r2, #0
 800d0ea:	2100      	movs	r1, #0
 800d0ec:	f004 f908 	bl	8011300 <lv_obj_align>
	lv_btn_set_style(ledOutGoingContainer, LV_BTN_STYLE_REL, &ledOutGoingContainerRelSyle);
 800d0f0:	4b0e      	ldr	r3, [pc, #56]	; (800d12c <outGoingColorContainer+0x7c>)
 800d0f2:	681b      	ldr	r3, [r3, #0]
 800d0f4:	4a0e      	ldr	r2, [pc, #56]	; (800d130 <outGoingColorContainer+0x80>)
 800d0f6:	2100      	movs	r1, #0
 800d0f8:	4618      	mov	r0, r3
 800d0fa:	f011 fac7 	bl	801e68c <lv_btn_set_style>
	lv_btn_set_style(ledOutGoingContainer, LV_BTN_STYLE_PR, &ledOutGoingContainerPrStyle);
 800d0fe:	4b0b      	ldr	r3, [pc, #44]	; (800d12c <outGoingColorContainer+0x7c>)
 800d100:	681b      	ldr	r3, [r3, #0]
 800d102:	4a0c      	ldr	r2, [pc, #48]	; (800d134 <outGoingColorContainer+0x84>)
 800d104:	2101      	movs	r1, #1
 800d106:	4618      	mov	r0, r3
 800d108:	f011 fac0 	bl	801e68c <lv_btn_set_style>

	lv_obj_t * label = lv_label_create(ledOutGoingContainer, NULL);
 800d10c:	4b07      	ldr	r3, [pc, #28]	; (800d12c <outGoingColorContainer+0x7c>)
 800d10e:	681b      	ldr	r3, [r3, #0]
 800d110:	2100      	movs	r1, #0
 800d112:	4618      	mov	r0, r3
 800d114:	f014 f9a2 	bl	802145c <lv_label_create>
 800d118:	6078      	str	r0, [r7, #4]
	lv_label_set_text(label, "Renk");
 800d11a:	4907      	ldr	r1, [pc, #28]	; (800d138 <outGoingColorContainer+0x88>)
 800d11c:	6878      	ldr	r0, [r7, #4]
 800d11e:	f014 fae5 	bl	80216ec <lv_label_set_text>

}
 800d122:	bf00      	nop
 800d124:	3708      	adds	r7, #8
 800d126:	46bd      	mov	sp, r7
 800d128:	bd80      	pop	{r7, pc}
 800d12a:	bf00      	nop
 800d12c:	2000dc34 	.word	0x2000dc34
 800d130:	200036c8 	.word	0x200036c8
 800d134:	20003704 	.word	0x20003704
 800d138:	08028408 	.word	0x08028408

0800d13c <MenuDropList>:
void MenuDropList(void) {
 800d13c:	b580      	push	{r7, lr}
 800d13e:	b084      	sub	sp, #16
 800d140:	af02      	add	r7, sp, #8
	menuDownListStyle();
 800d142:	f000 fe0b 	bl	800dd5c <menuDownListStyle>
	lv_obj_t * ddlist = lv_ddlist_create(lv_scr_act(), NULL);
 800d146:	f7ff f80d 	bl	800c164 <lv_scr_act>
 800d14a:	4603      	mov	r3, r0
 800d14c:	2100      	movs	r1, #0
 800d14e:	4618      	mov	r0, r3
 800d150:	f013 f86e 	bl	8020230 <lv_ddlist_create>
 800d154:	6078      	str	r0, [r7, #4]
	lv_ddlist_set_options(ddlist, "Statik Renkler\n"
 800d156:	4917      	ldr	r1, [pc, #92]	; (800d1b4 <MenuDropList+0x78>)
 800d158:	6878      	ldr	r0, [r7, #4]
 800d15a:	f013 f9b7 	bl	80204cc <lv_ddlist_set_options>
		"Renk Olusturucu\n"
		"Hakkinda");
	lv_ddlist_set_draw_arrow(ddlist, true);
 800d15e:	2101      	movs	r1, #1
 800d160:	6878      	ldr	r0, [r7, #4]
 800d162:	f013 fa1e 	bl	80205a2 <lv_ddlist_set_draw_arrow>
	lv_ddlist_set_style(ddlist, LV_DDLIST_STYLE_SB, &menuDownList_SbStyle);
 800d166:	4a14      	ldr	r2, [pc, #80]	; (800d1b8 <MenuDropList+0x7c>)
 800d168:	2102      	movs	r1, #2
 800d16a:	6878      	ldr	r0, [r7, #4]
 800d16c:	f013 fa2f 	bl	80205ce <lv_ddlist_set_style>
	lv_ddlist_set_style(ddlist, LV_DDLIST_STYLE_BG, &menuDownList_bgStyle);
 800d170:	4a12      	ldr	r2, [pc, #72]	; (800d1bc <MenuDropList+0x80>)
 800d172:	2100      	movs	r1, #0
 800d174:	6878      	ldr	r0, [r7, #4]
 800d176:	f013 fa2a 	bl	80205ce <lv_ddlist_set_style>
	lv_ddlist_set_style(ddlist, LV_DDLIST_STYLE_SEL, &menuDownList_SelStyle);
 800d17a:	4a11      	ldr	r2, [pc, #68]	; (800d1c0 <MenuDropList+0x84>)
 800d17c:	2101      	movs	r1, #1
 800d17e:	6878      	ldr	r0, [r7, #4]
 800d180:	f013 fa25 	bl	80205ce <lv_ddlist_set_style>
	lv_obj_set_size(ddlist, 75, 25);
 800d184:	2219      	movs	r2, #25
 800d186:	214b      	movs	r1, #75	; 0x4b
 800d188:	6878      	ldr	r0, [r7, #4]
 800d18a:	f004 f816 	bl	80111ba <lv_obj_set_size>
	lv_obj_align(ddlist, NULL, LV_ALIGN_CENTER, -45, -120);
 800d18e:	f06f 0377 	mvn.w	r3, #119	; 0x77
 800d192:	9300      	str	r3, [sp, #0]
 800d194:	f06f 032c 	mvn.w	r3, #44	; 0x2c
 800d198:	2200      	movs	r2, #0
 800d19a:	2100      	movs	r1, #0
 800d19c:	6878      	ldr	r0, [r7, #4]
 800d19e:	f004 f8af 	bl	8011300 <lv_obj_align>
	lv_obj_set_event_cb(ddlist, MenuDropList_event_handler);
 800d1a2:	4908      	ldr	r1, [pc, #32]	; (800d1c4 <MenuDropList+0x88>)
 800d1a4:	6878      	ldr	r0, [r7, #4]
 800d1a6:	f004 fe4c 	bl	8011e42 <lv_obj_set_event_cb>
}
 800d1aa:	bf00      	nop
 800d1ac:	3708      	adds	r7, #8
 800d1ae:	46bd      	mov	sp, r7
 800d1b0:	bd80      	pop	{r7, pc}
 800d1b2:	bf00      	nop
 800d1b4:	08028410 	.word	0x08028410
 800d1b8:	20003740 	.word	0x20003740
 800d1bc:	200037b8 	.word	0x200037b8
 800d1c0:	2000377c 	.word	0x2000377c
 800d1c4:	0800da31 	.word	0x0800da31

0800d1c8 <information>:
void information(void) {
 800d1c8:	b580      	push	{r7, lr}
 800d1ca:	b084      	sub	sp, #16
 800d1cc:	af02      	add	r7, sp, #8
	lv_obj_t * Information = lv_label_create(lv_scr_act(), NULL);
 800d1ce:	f7fe ffc9 	bl	800c164 <lv_scr_act>
 800d1d2:	4603      	mov	r3, r0
 800d1d4:	2100      	movs	r1, #0
 800d1d6:	4618      	mov	r0, r3
 800d1d8:	f014 f940 	bl	802145c <lv_label_create>
 800d1dc:	6078      	str	r0, [r7, #4]
	lv_label_set_recolor(Information, true);
 800d1de:	2101      	movs	r1, #1
 800d1e0:	6878      	ldr	r0, [r7, #4]
 800d1e2:	f014 fbaf 	bl	8021944 <lv_label_set_recolor>
	lv_label_set_text(Information, "Bu grafik arayuz Aydinlatma Teknolojileri ve Proje \nDersi icin; #00bfff Neset AYDIN#"
 800d1e6:	490a      	ldr	r1, [pc, #40]	; (800d210 <information+0x48>)
 800d1e8:	6878      	ldr	r0, [r7, #4]
 800d1ea:	f014 fa7f 	bl	80216ec <lv_label_set_text>
		" tarafindan gelistirildi." "\nStatik Renkler Sayfasindan Mevcut Renklerle ve \nRenk Olusturucu Sayfasinda kendi renklerinizle"
		"\nledleri kontrol edebilirsiniz.");
	lv_obj_set_width(Information, 150);
 800d1ee:	2196      	movs	r1, #150	; 0x96
 800d1f0:	6878      	ldr	r0, [r7, #4]
 800d1f2:	f004 f85b 	bl	80112ac <lv_obj_set_width>
	lv_obj_align(Information, NULL, LV_ALIGN_CENTER, 0, 0);
 800d1f6:	2300      	movs	r3, #0
 800d1f8:	9300      	str	r3, [sp, #0]
 800d1fa:	2300      	movs	r3, #0
 800d1fc:	2200      	movs	r2, #0
 800d1fe:	2100      	movs	r1, #0
 800d200:	6878      	ldr	r0, [r7, #4]
 800d202:	f004 f87d 	bl	8011300 <lv_obj_align>
}
 800d206:	bf00      	nop
 800d208:	3708      	adds	r7, #8
 800d20a:	46bd      	mov	sp, r7
 800d20c:	bd80      	pop	{r7, pc}
 800d20e:	bf00      	nop
 800d210:	08028438 	.word	0x08028438

0800d214 <ledRslider_event_handler>:
/*Events Functions*/
static void ledRslider_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d214:	b580      	push	{r7, lr}
 800d216:	b082      	sub	sp, #8
 800d218:	af00      	add	r7, sp, #0
 800d21a:	6078      	str	r0, [r7, #4]
 800d21c:	460b      	mov	r3, r1
 800d21e:	70fb      	strb	r3, [r7, #3]
	ledButtonStyle();
 800d220:	f000 fcc6 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_VALUE_CHANGED) {
 800d224:	78fb      	ldrb	r3, [r7, #3]
 800d226:	2b0e      	cmp	r3, #14
 800d228:	d12b      	bne.n	800d282 <ledRslider_event_handler+0x6e>
		printf("R Value: %d\n", lv_slider_get_value(obj));
 800d22a:	6878      	ldr	r0, [r7, #4]
 800d22c:	f017 fc92 	bl	8024b54 <lv_slider_get_value>
 800d230:	4603      	mov	r3, r0
 800d232:	4619      	mov	r1, r3
 800d234:	4815      	ldr	r0, [pc, #84]	; (800d28c <ledRslider_event_handler+0x78>)
 800d236:	f019 ffd5 	bl	80271e4 <iprintf>
		ledTempRValues = lv_slider_get_value(obj);
 800d23a:	6878      	ldr	r0, [r7, #4]
 800d23c:	f017 fc8a 	bl	8024b54 <lv_slider_get_value>
 800d240:	4603      	mov	r3, r0
 800d242:	b2da      	uxtb	r2, r3
 800d244:	4b12      	ldr	r3, [pc, #72]	; (800d290 <ledRslider_event_handler+0x7c>)
 800d246:	701a      	strb	r2, [r3, #0]
		static char subSliderbuf[4];
		snprintf(subSliderbuf, 4, "%u", lv_slider_get_value(obj));
 800d248:	6878      	ldr	r0, [r7, #4]
 800d24a:	f017 fc83 	bl	8024b54 <lv_slider_get_value>
 800d24e:	4603      	mov	r3, r0
 800d250:	4a10      	ldr	r2, [pc, #64]	; (800d294 <ledRslider_event_handler+0x80>)
 800d252:	2104      	movs	r1, #4
 800d254:	4810      	ldr	r0, [pc, #64]	; (800d298 <ledRslider_event_handler+0x84>)
 800d256:	f01a f821 	bl	802729c <sniprintf>
		lv_label_set_text(ledRvalueLabel, subSliderbuf);
 800d25a:	4b10      	ldr	r3, [pc, #64]	; (800d29c <ledRslider_event_handler+0x88>)
 800d25c:	681b      	ldr	r3, [r3, #0]
 800d25e:	490e      	ldr	r1, [pc, #56]	; (800d298 <ledRslider_event_handler+0x84>)
 800d260:	4618      	mov	r0, r3
 800d262:	f014 fa43 	bl	80216ec <lv_label_set_text>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d266:	4b0e      	ldr	r3, [pc, #56]	; (800d2a0 <ledRslider_event_handler+0x8c>)
 800d268:	681b      	ldr	r3, [r3, #0]
 800d26a:	4a0e      	ldr	r2, [pc, #56]	; (800d2a4 <ledRslider_event_handler+0x90>)
 800d26c:	2100      	movs	r1, #0
 800d26e:	4618      	mov	r0, r3
 800d270:	f011 fa0c 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d274:	4b0a      	ldr	r3, [pc, #40]	; (800d2a0 <ledRslider_event_handler+0x8c>)
 800d276:	681b      	ldr	r3, [r3, #0]
 800d278:	4a0b      	ldr	r2, [pc, #44]	; (800d2a8 <ledRslider_event_handler+0x94>)
 800d27a:	2101      	movs	r1, #1
 800d27c:	4618      	mov	r0, r3
 800d27e:	f011 fa05 	bl	801e68c <lv_btn_set_style>
	}
}
 800d282:	bf00      	nop
 800d284:	3708      	adds	r7, #8
 800d286:	46bd      	mov	sp, r7
 800d288:	bd80      	pop	{r7, pc}
 800d28a:	bf00      	nop
 800d28c:	08028524 	.word	0x08028524
 800d290:	200037f4 	.word	0x200037f4
 800d294:	08028534 	.word	0x08028534
 800d298:	20003f88 	.word	0x20003f88
 800d29c:	2000dc2c 	.word	0x2000dc2c
 800d2a0:	2000dc28 	.word	0x2000dc28
 800d2a4:	20003650 	.word	0x20003650
 800d2a8:	2000368c 	.word	0x2000368c

0800d2ac <ledGslider_event_handler>:
static void ledGslider_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d2ac:	b580      	push	{r7, lr}
 800d2ae:	b082      	sub	sp, #8
 800d2b0:	af00      	add	r7, sp, #0
 800d2b2:	6078      	str	r0, [r7, #4]
 800d2b4:	460b      	mov	r3, r1
 800d2b6:	70fb      	strb	r3, [r7, #3]
	ledButtonStyle();
 800d2b8:	f000 fc7a 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_VALUE_CHANGED) {
 800d2bc:	78fb      	ldrb	r3, [r7, #3]
 800d2be:	2b0e      	cmp	r3, #14
 800d2c0:	d12b      	bne.n	800d31a <ledGslider_event_handler+0x6e>
		printf("G Value: %d\n", lv_slider_get_value(obj));
 800d2c2:	6878      	ldr	r0, [r7, #4]
 800d2c4:	f017 fc46 	bl	8024b54 <lv_slider_get_value>
 800d2c8:	4603      	mov	r3, r0
 800d2ca:	4619      	mov	r1, r3
 800d2cc:	4815      	ldr	r0, [pc, #84]	; (800d324 <ledGslider_event_handler+0x78>)
 800d2ce:	f019 ff89 	bl	80271e4 <iprintf>
		ledTempGValues = lv_slider_get_value(obj);
 800d2d2:	6878      	ldr	r0, [r7, #4]
 800d2d4:	f017 fc3e 	bl	8024b54 <lv_slider_get_value>
 800d2d8:	4603      	mov	r3, r0
 800d2da:	b2da      	uxtb	r2, r3
 800d2dc:	4b12      	ldr	r3, [pc, #72]	; (800d328 <ledGslider_event_handler+0x7c>)
 800d2de:	701a      	strb	r2, [r3, #0]
		static char subSliderbuf[4];
		snprintf(subSliderbuf, 4, "%u", lv_slider_get_value(obj));
 800d2e0:	6878      	ldr	r0, [r7, #4]
 800d2e2:	f017 fc37 	bl	8024b54 <lv_slider_get_value>
 800d2e6:	4603      	mov	r3, r0
 800d2e8:	4a10      	ldr	r2, [pc, #64]	; (800d32c <ledGslider_event_handler+0x80>)
 800d2ea:	2104      	movs	r1, #4
 800d2ec:	4810      	ldr	r0, [pc, #64]	; (800d330 <ledGslider_event_handler+0x84>)
 800d2ee:	f019 ffd5 	bl	802729c <sniprintf>
		lv_label_set_text(ledGvalueLabel, subSliderbuf);
 800d2f2:	4b10      	ldr	r3, [pc, #64]	; (800d334 <ledGslider_event_handler+0x88>)
 800d2f4:	681b      	ldr	r3, [r3, #0]
 800d2f6:	490e      	ldr	r1, [pc, #56]	; (800d330 <ledGslider_event_handler+0x84>)
 800d2f8:	4618      	mov	r0, r3
 800d2fa:	f014 f9f7 	bl	80216ec <lv_label_set_text>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d2fe:	4b0e      	ldr	r3, [pc, #56]	; (800d338 <ledGslider_event_handler+0x8c>)
 800d300:	681b      	ldr	r3, [r3, #0]
 800d302:	4a0e      	ldr	r2, [pc, #56]	; (800d33c <ledGslider_event_handler+0x90>)
 800d304:	2100      	movs	r1, #0
 800d306:	4618      	mov	r0, r3
 800d308:	f011 f9c0 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d30c:	4b0a      	ldr	r3, [pc, #40]	; (800d338 <ledGslider_event_handler+0x8c>)
 800d30e:	681b      	ldr	r3, [r3, #0]
 800d310:	4a0b      	ldr	r2, [pc, #44]	; (800d340 <ledGslider_event_handler+0x94>)
 800d312:	2101      	movs	r1, #1
 800d314:	4618      	mov	r0, r3
 800d316:	f011 f9b9 	bl	801e68c <lv_btn_set_style>
	}
}
 800d31a:	bf00      	nop
 800d31c:	3708      	adds	r7, #8
 800d31e:	46bd      	mov	sp, r7
 800d320:	bd80      	pop	{r7, pc}
 800d322:	bf00      	nop
 800d324:	08028538 	.word	0x08028538
 800d328:	200037f5 	.word	0x200037f5
 800d32c:	08028534 	.word	0x08028534
 800d330:	20003f8c 	.word	0x20003f8c
 800d334:	2000dc30 	.word	0x2000dc30
 800d338:	2000dc28 	.word	0x2000dc28
 800d33c:	20003650 	.word	0x20003650
 800d340:	2000368c 	.word	0x2000368c

0800d344 <ledBslider_event_handler>:
static void ledBslider_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d344:	b580      	push	{r7, lr}
 800d346:	b082      	sub	sp, #8
 800d348:	af00      	add	r7, sp, #0
 800d34a:	6078      	str	r0, [r7, #4]
 800d34c:	460b      	mov	r3, r1
 800d34e:	70fb      	strb	r3, [r7, #3]
	ledButtonStyle();
 800d350:	f000 fc2e 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_VALUE_CHANGED) {
 800d354:	78fb      	ldrb	r3, [r7, #3]
 800d356:	2b0e      	cmp	r3, #14
 800d358:	d12b      	bne.n	800d3b2 <ledBslider_event_handler+0x6e>
		printf("B Value: %d\n", lv_slider_get_value(obj));
 800d35a:	6878      	ldr	r0, [r7, #4]
 800d35c:	f017 fbfa 	bl	8024b54 <lv_slider_get_value>
 800d360:	4603      	mov	r3, r0
 800d362:	4619      	mov	r1, r3
 800d364:	4815      	ldr	r0, [pc, #84]	; (800d3bc <ledBslider_event_handler+0x78>)
 800d366:	f019 ff3d 	bl	80271e4 <iprintf>
		ledTempBValues = lv_slider_get_value(obj);
 800d36a:	6878      	ldr	r0, [r7, #4]
 800d36c:	f017 fbf2 	bl	8024b54 <lv_slider_get_value>
 800d370:	4603      	mov	r3, r0
 800d372:	b2da      	uxtb	r2, r3
 800d374:	4b12      	ldr	r3, [pc, #72]	; (800d3c0 <ledBslider_event_handler+0x7c>)
 800d376:	701a      	strb	r2, [r3, #0]
		static char subSliderbuf[4];
		snprintf(subSliderbuf, 4, "%u", lv_slider_get_value(obj));
 800d378:	6878      	ldr	r0, [r7, #4]
 800d37a:	f017 fbeb 	bl	8024b54 <lv_slider_get_value>
 800d37e:	4603      	mov	r3, r0
 800d380:	4a10      	ldr	r2, [pc, #64]	; (800d3c4 <ledBslider_event_handler+0x80>)
 800d382:	2104      	movs	r1, #4
 800d384:	4810      	ldr	r0, [pc, #64]	; (800d3c8 <ledBslider_event_handler+0x84>)
 800d386:	f019 ff89 	bl	802729c <sniprintf>
		lv_label_set_text(ledBvalueLabel, subSliderbuf);
 800d38a:	4b10      	ldr	r3, [pc, #64]	; (800d3cc <ledBslider_event_handler+0x88>)
 800d38c:	681b      	ldr	r3, [r3, #0]
 800d38e:	490e      	ldr	r1, [pc, #56]	; (800d3c8 <ledBslider_event_handler+0x84>)
 800d390:	4618      	mov	r0, r3
 800d392:	f014 f9ab 	bl	80216ec <lv_label_set_text>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d396:	4b0e      	ldr	r3, [pc, #56]	; (800d3d0 <ledBslider_event_handler+0x8c>)
 800d398:	681b      	ldr	r3, [r3, #0]
 800d39a:	4a0e      	ldr	r2, [pc, #56]	; (800d3d4 <ledBslider_event_handler+0x90>)
 800d39c:	2100      	movs	r1, #0
 800d39e:	4618      	mov	r0, r3
 800d3a0:	f011 f974 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d3a4:	4b0a      	ldr	r3, [pc, #40]	; (800d3d0 <ledBslider_event_handler+0x8c>)
 800d3a6:	681b      	ldr	r3, [r3, #0]
 800d3a8:	4a0b      	ldr	r2, [pc, #44]	; (800d3d8 <ledBslider_event_handler+0x94>)
 800d3aa:	2101      	movs	r1, #1
 800d3ac:	4618      	mov	r0, r3
 800d3ae:	f011 f96d 	bl	801e68c <lv_btn_set_style>
	}
}
 800d3b2:	bf00      	nop
 800d3b4:	3708      	adds	r7, #8
 800d3b6:	46bd      	mov	sp, r7
 800d3b8:	bd80      	pop	{r7, pc}
 800d3ba:	bf00      	nop
 800d3bc:	08028548 	.word	0x08028548
 800d3c0:	200037f6 	.word	0x200037f6
 800d3c4:	08028534 	.word	0x08028534
 800d3c8:	20003f90 	.word	0x20003f90
 800d3cc:	2000dc24 	.word	0x2000dc24
 800d3d0:	2000dc28 	.word	0x2000dc28
 800d3d4:	20003650 	.word	0x20003650
 800d3d8:	2000368c 	.word	0x2000368c

0800d3dc <setNewColorButton_event_handler>:
static void setNewColorButton_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d3dc:	b580      	push	{r7, lr}
 800d3de:	b082      	sub	sp, #8
 800d3e0:	af00      	add	r7, sp, #0
 800d3e2:	6078      	str	r0, [r7, #4]
 800d3e4:	460b      	mov	r3, r1
 800d3e6:	70fb      	strb	r3, [r7, #3]
	outGoingColorContainerStyle();
 800d3e8:	f000 fc70 	bl	800dccc <outGoingColorContainerStyle>
	if (event == LV_EVENT_CLICKED) {
 800d3ec:	78fb      	ldrb	r3, [r7, #3]
 800d3ee:	2b06      	cmp	r3, #6
 800d3f0:	d119      	bne.n	800d426 <setNewColorButton_event_handler+0x4a>
		ledRValues = ledTempRValues;
 800d3f2:	4b0f      	ldr	r3, [pc, #60]	; (800d430 <setNewColorButton_event_handler+0x54>)
 800d3f4:	781a      	ldrb	r2, [r3, #0]
 800d3f6:	4b0f      	ldr	r3, [pc, #60]	; (800d434 <setNewColorButton_event_handler+0x58>)
 800d3f8:	701a      	strb	r2, [r3, #0]
		ledGValues = ledTempGValues;
 800d3fa:	4b0f      	ldr	r3, [pc, #60]	; (800d438 <setNewColorButton_event_handler+0x5c>)
 800d3fc:	781a      	ldrb	r2, [r3, #0]
 800d3fe:	4b0f      	ldr	r3, [pc, #60]	; (800d43c <setNewColorButton_event_handler+0x60>)
 800d400:	701a      	strb	r2, [r3, #0]
		ledBValues = ledTempBValues;
 800d402:	4b0f      	ldr	r3, [pc, #60]	; (800d440 <setNewColorButton_event_handler+0x64>)
 800d404:	781a      	ldrb	r2, [r3, #0]
 800d406:	4b0f      	ldr	r3, [pc, #60]	; (800d444 <setNewColorButton_event_handler+0x68>)
 800d408:	701a      	strb	r2, [r3, #0]
		lv_btn_set_style(ledOutGoingContainer, LV_BTN_STYLE_REL, &ledOutGoingContainerRelSyle);
 800d40a:	4b0f      	ldr	r3, [pc, #60]	; (800d448 <setNewColorButton_event_handler+0x6c>)
 800d40c:	681b      	ldr	r3, [r3, #0]
 800d40e:	4a0f      	ldr	r2, [pc, #60]	; (800d44c <setNewColorButton_event_handler+0x70>)
 800d410:	2100      	movs	r1, #0
 800d412:	4618      	mov	r0, r3
 800d414:	f011 f93a 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledOutGoingContainer, LV_BTN_STYLE_PR, &ledOutGoingContainerPrStyle);
 800d418:	4b0b      	ldr	r3, [pc, #44]	; (800d448 <setNewColorButton_event_handler+0x6c>)
 800d41a:	681b      	ldr	r3, [r3, #0]
 800d41c:	4a0c      	ldr	r2, [pc, #48]	; (800d450 <setNewColorButton_event_handler+0x74>)
 800d41e:	2101      	movs	r1, #1
 800d420:	4618      	mov	r0, r3
 800d422:	f011 f933 	bl	801e68c <lv_btn_set_style>
	}
}
 800d426:	bf00      	nop
 800d428:	3708      	adds	r7, #8
 800d42a:	46bd      	mov	sp, r7
 800d42c:	bd80      	pop	{r7, pc}
 800d42e:	bf00      	nop
 800d430:	200037f4 	.word	0x200037f4
 800d434:	200037f7 	.word	0x200037f7
 800d438:	200037f5 	.word	0x200037f5
 800d43c:	200037f8 	.word	0x200037f8
 800d440:	200037f6 	.word	0x200037f6
 800d444:	200037f9 	.word	0x200037f9
 800d448:	2000dc34 	.word	0x2000dc34
 800d44c:	200036c8 	.word	0x200036c8
 800d450:	20003704 	.word	0x20003704

0800d454 <staticColorButton0_event_handler>:
static void staticColorButton0_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d454:	b580      	push	{r7, lr}
 800d456:	b082      	sub	sp, #8
 800d458:	af00      	add	r7, sp, #0
 800d45a:	6078      	str	r0, [r7, #4]
 800d45c:	460b      	mov	r3, r1
 800d45e:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d460:	f000 fba6 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d464:	78fb      	ldrb	r3, [r7, #3]
 800d466:	2b06      	cmp	r3, #6
 800d468:	d116      	bne.n	800d498 <staticColorButton0_event_handler+0x44>
		ledTempRValues = 255;
 800d46a:	4b0d      	ldr	r3, [pc, #52]	; (800d4a0 <staticColorButton0_event_handler+0x4c>)
 800d46c:	22ff      	movs	r2, #255	; 0xff
 800d46e:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 0;
 800d470:	4b0c      	ldr	r3, [pc, #48]	; (800d4a4 <staticColorButton0_event_handler+0x50>)
 800d472:	2200      	movs	r2, #0
 800d474:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 0;
 800d476:	4b0c      	ldr	r3, [pc, #48]	; (800d4a8 <staticColorButton0_event_handler+0x54>)
 800d478:	2200      	movs	r2, #0
 800d47a:	701a      	strb	r2, [r3, #0]
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d47c:	4b0b      	ldr	r3, [pc, #44]	; (800d4ac <staticColorButton0_event_handler+0x58>)
 800d47e:	681b      	ldr	r3, [r3, #0]
 800d480:	4a0b      	ldr	r2, [pc, #44]	; (800d4b0 <staticColorButton0_event_handler+0x5c>)
 800d482:	2101      	movs	r1, #1
 800d484:	4618      	mov	r0, r3
 800d486:	f011 f901 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d48a:	4b08      	ldr	r3, [pc, #32]	; (800d4ac <staticColorButton0_event_handler+0x58>)
 800d48c:	681b      	ldr	r3, [r3, #0]
 800d48e:	4a09      	ldr	r2, [pc, #36]	; (800d4b4 <staticColorButton0_event_handler+0x60>)
 800d490:	2100      	movs	r1, #0
 800d492:	4618      	mov	r0, r3
 800d494:	f011 f8fa 	bl	801e68c <lv_btn_set_style>
	}
	
}
 800d498:	bf00      	nop
 800d49a:	3708      	adds	r7, #8
 800d49c:	46bd      	mov	sp, r7
 800d49e:	bd80      	pop	{r7, pc}
 800d4a0:	200037f4 	.word	0x200037f4
 800d4a4:	200037f5 	.word	0x200037f5
 800d4a8:	200037f6 	.word	0x200037f6
 800d4ac:	2000dc28 	.word	0x2000dc28
 800d4b0:	2000368c 	.word	0x2000368c
 800d4b4:	20003650 	.word	0x20003650

0800d4b8 <staticColorButton1_event_handler>:
static void staticColorButton1_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d4b8:	b580      	push	{r7, lr}
 800d4ba:	b082      	sub	sp, #8
 800d4bc:	af00      	add	r7, sp, #0
 800d4be:	6078      	str	r0, [r7, #4]
 800d4c0:	460b      	mov	r3, r1
 800d4c2:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d4c4:	f000 fb74 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d4c8:	78fb      	ldrb	r3, [r7, #3]
 800d4ca:	2b06      	cmp	r3, #6
 800d4cc:	d116      	bne.n	800d4fc <staticColorButton1_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d4ce:	4b0d      	ldr	r3, [pc, #52]	; (800d504 <staticColorButton1_event_handler+0x4c>)
 800d4d0:	681b      	ldr	r3, [r3, #0]
 800d4d2:	4a0d      	ldr	r2, [pc, #52]	; (800d508 <staticColorButton1_event_handler+0x50>)
 800d4d4:	2100      	movs	r1, #0
 800d4d6:	4618      	mov	r0, r3
 800d4d8:	f011 f8d8 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d4dc:	4b09      	ldr	r3, [pc, #36]	; (800d504 <staticColorButton1_event_handler+0x4c>)
 800d4de:	681b      	ldr	r3, [r3, #0]
 800d4e0:	4a0a      	ldr	r2, [pc, #40]	; (800d50c <staticColorButton1_event_handler+0x54>)
 800d4e2:	2101      	movs	r1, #1
 800d4e4:	4618      	mov	r0, r3
 800d4e6:	f011 f8d1 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 128;
 800d4ea:	4b09      	ldr	r3, [pc, #36]	; (800d510 <staticColorButton1_event_handler+0x58>)
 800d4ec:	2280      	movs	r2, #128	; 0x80
 800d4ee:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 0;
 800d4f0:	4b08      	ldr	r3, [pc, #32]	; (800d514 <staticColorButton1_event_handler+0x5c>)
 800d4f2:	2200      	movs	r2, #0
 800d4f4:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 0;
 800d4f6:	4b08      	ldr	r3, [pc, #32]	; (800d518 <staticColorButton1_event_handler+0x60>)
 800d4f8:	2200      	movs	r2, #0
 800d4fa:	701a      	strb	r2, [r3, #0]
	}

}
 800d4fc:	bf00      	nop
 800d4fe:	3708      	adds	r7, #8
 800d500:	46bd      	mov	sp, r7
 800d502:	bd80      	pop	{r7, pc}
 800d504:	2000dc28 	.word	0x2000dc28
 800d508:	20003650 	.word	0x20003650
 800d50c:	2000368c 	.word	0x2000368c
 800d510:	200037f4 	.word	0x200037f4
 800d514:	200037f5 	.word	0x200037f5
 800d518:	200037f6 	.word	0x200037f6

0800d51c <staticColorButton2_event_handler>:
static void staticColorButton2_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d51c:	b580      	push	{r7, lr}
 800d51e:	b082      	sub	sp, #8
 800d520:	af00      	add	r7, sp, #0
 800d522:	6078      	str	r0, [r7, #4]
 800d524:	460b      	mov	r3, r1
 800d526:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d528:	f000 fb42 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d52c:	78fb      	ldrb	r3, [r7, #3]
 800d52e:	2b06      	cmp	r3, #6
 800d530:	d116      	bne.n	800d560 <staticColorButton2_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d532:	4b0d      	ldr	r3, [pc, #52]	; (800d568 <staticColorButton2_event_handler+0x4c>)
 800d534:	681b      	ldr	r3, [r3, #0]
 800d536:	4a0d      	ldr	r2, [pc, #52]	; (800d56c <staticColorButton2_event_handler+0x50>)
 800d538:	2100      	movs	r1, #0
 800d53a:	4618      	mov	r0, r3
 800d53c:	f011 f8a6 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d540:	4b09      	ldr	r3, [pc, #36]	; (800d568 <staticColorButton2_event_handler+0x4c>)
 800d542:	681b      	ldr	r3, [r3, #0]
 800d544:	4a0a      	ldr	r2, [pc, #40]	; (800d570 <staticColorButton2_event_handler+0x54>)
 800d546:	2101      	movs	r1, #1
 800d548:	4618      	mov	r0, r3
 800d54a:	f011 f89f 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 128;
 800d54e:	4b09      	ldr	r3, [pc, #36]	; (800d574 <staticColorButton2_event_handler+0x58>)
 800d550:	2280      	movs	r2, #128	; 0x80
 800d552:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 0;
 800d554:	4b08      	ldr	r3, [pc, #32]	; (800d578 <staticColorButton2_event_handler+0x5c>)
 800d556:	2200      	movs	r2, #0
 800d558:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 128;
 800d55a:	4b08      	ldr	r3, [pc, #32]	; (800d57c <staticColorButton2_event_handler+0x60>)
 800d55c:	2280      	movs	r2, #128	; 0x80
 800d55e:	701a      	strb	r2, [r3, #0]
	}

}
 800d560:	bf00      	nop
 800d562:	3708      	adds	r7, #8
 800d564:	46bd      	mov	sp, r7
 800d566:	bd80      	pop	{r7, pc}
 800d568:	2000dc28 	.word	0x2000dc28
 800d56c:	20003650 	.word	0x20003650
 800d570:	2000368c 	.word	0x2000368c
 800d574:	200037f4 	.word	0x200037f4
 800d578:	200037f5 	.word	0x200037f5
 800d57c:	200037f6 	.word	0x200037f6

0800d580 <staticColorButton3_event_handler>:
static void staticColorButton3_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d580:	b580      	push	{r7, lr}
 800d582:	b082      	sub	sp, #8
 800d584:	af00      	add	r7, sp, #0
 800d586:	6078      	str	r0, [r7, #4]
 800d588:	460b      	mov	r3, r1
 800d58a:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d58c:	f000 fb10 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d590:	78fb      	ldrb	r3, [r7, #3]
 800d592:	2b06      	cmp	r3, #6
 800d594:	d116      	bne.n	800d5c4 <staticColorButton3_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d596:	4b0d      	ldr	r3, [pc, #52]	; (800d5cc <staticColorButton3_event_handler+0x4c>)
 800d598:	681b      	ldr	r3, [r3, #0]
 800d59a:	4a0d      	ldr	r2, [pc, #52]	; (800d5d0 <staticColorButton3_event_handler+0x50>)
 800d59c:	2100      	movs	r1, #0
 800d59e:	4618      	mov	r0, r3
 800d5a0:	f011 f874 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d5a4:	4b09      	ldr	r3, [pc, #36]	; (800d5cc <staticColorButton3_event_handler+0x4c>)
 800d5a6:	681b      	ldr	r3, [r3, #0]
 800d5a8:	4a0a      	ldr	r2, [pc, #40]	; (800d5d4 <staticColorButton3_event_handler+0x54>)
 800d5aa:	2101      	movs	r1, #1
 800d5ac:	4618      	mov	r0, r3
 800d5ae:	f011 f86d 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 255;
 800d5b2:	4b09      	ldr	r3, [pc, #36]	; (800d5d8 <staticColorButton3_event_handler+0x58>)
 800d5b4:	22ff      	movs	r2, #255	; 0xff
 800d5b6:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 0;
 800d5b8:	4b08      	ldr	r3, [pc, #32]	; (800d5dc <staticColorButton3_event_handler+0x5c>)
 800d5ba:	2200      	movs	r2, #0
 800d5bc:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 255;
 800d5be:	4b08      	ldr	r3, [pc, #32]	; (800d5e0 <staticColorButton3_event_handler+0x60>)
 800d5c0:	22ff      	movs	r2, #255	; 0xff
 800d5c2:	701a      	strb	r2, [r3, #0]
	}

}
 800d5c4:	bf00      	nop
 800d5c6:	3708      	adds	r7, #8
 800d5c8:	46bd      	mov	sp, r7
 800d5ca:	bd80      	pop	{r7, pc}
 800d5cc:	2000dc28 	.word	0x2000dc28
 800d5d0:	20003650 	.word	0x20003650
 800d5d4:	2000368c 	.word	0x2000368c
 800d5d8:	200037f4 	.word	0x200037f4
 800d5dc:	200037f5 	.word	0x200037f5
 800d5e0:	200037f6 	.word	0x200037f6

0800d5e4 <staticColorButton4_event_handler>:
static void staticColorButton4_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d5e4:	b580      	push	{r7, lr}
 800d5e6:	b082      	sub	sp, #8
 800d5e8:	af00      	add	r7, sp, #0
 800d5ea:	6078      	str	r0, [r7, #4]
 800d5ec:	460b      	mov	r3, r1
 800d5ee:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d5f0:	f000 fade 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d5f4:	78fb      	ldrb	r3, [r7, #3]
 800d5f6:	2b06      	cmp	r3, #6
 800d5f8:	d116      	bne.n	800d628 <staticColorButton4_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d5fa:	4b0d      	ldr	r3, [pc, #52]	; (800d630 <staticColorButton4_event_handler+0x4c>)
 800d5fc:	681b      	ldr	r3, [r3, #0]
 800d5fe:	4a0d      	ldr	r2, [pc, #52]	; (800d634 <staticColorButton4_event_handler+0x50>)
 800d600:	2100      	movs	r1, #0
 800d602:	4618      	mov	r0, r3
 800d604:	f011 f842 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d608:	4b09      	ldr	r3, [pc, #36]	; (800d630 <staticColorButton4_event_handler+0x4c>)
 800d60a:	681b      	ldr	r3, [r3, #0]
 800d60c:	4a0a      	ldr	r2, [pc, #40]	; (800d638 <staticColorButton4_event_handler+0x54>)
 800d60e:	2101      	movs	r1, #1
 800d610:	4618      	mov	r0, r3
 800d612:	f011 f83b 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 128;
 800d616:	4b09      	ldr	r3, [pc, #36]	; (800d63c <staticColorButton4_event_handler+0x58>)
 800d618:	2280      	movs	r2, #128	; 0x80
 800d61a:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 128;
 800d61c:	4b08      	ldr	r3, [pc, #32]	; (800d640 <staticColorButton4_event_handler+0x5c>)
 800d61e:	2280      	movs	r2, #128	; 0x80
 800d620:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 128;
 800d622:	4b08      	ldr	r3, [pc, #32]	; (800d644 <staticColorButton4_event_handler+0x60>)
 800d624:	2280      	movs	r2, #128	; 0x80
 800d626:	701a      	strb	r2, [r3, #0]
	}

}
 800d628:	bf00      	nop
 800d62a:	3708      	adds	r7, #8
 800d62c:	46bd      	mov	sp, r7
 800d62e:	bd80      	pop	{r7, pc}
 800d630:	2000dc28 	.word	0x2000dc28
 800d634:	20003650 	.word	0x20003650
 800d638:	2000368c 	.word	0x2000368c
 800d63c:	200037f4 	.word	0x200037f4
 800d640:	200037f5 	.word	0x200037f5
 800d644:	200037f6 	.word	0x200037f6

0800d648 <staticColorButton5_event_handler>:
static void staticColorButton5_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d648:	b580      	push	{r7, lr}
 800d64a:	b082      	sub	sp, #8
 800d64c:	af00      	add	r7, sp, #0
 800d64e:	6078      	str	r0, [r7, #4]
 800d650:	460b      	mov	r3, r1
 800d652:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d654:	f000 faac 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d658:	78fb      	ldrb	r3, [r7, #3]
 800d65a:	2b06      	cmp	r3, #6
 800d65c:	d116      	bne.n	800d68c <staticColorButton5_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d65e:	4b0d      	ldr	r3, [pc, #52]	; (800d694 <staticColorButton5_event_handler+0x4c>)
 800d660:	681b      	ldr	r3, [r3, #0]
 800d662:	4a0d      	ldr	r2, [pc, #52]	; (800d698 <staticColorButton5_event_handler+0x50>)
 800d664:	2100      	movs	r1, #0
 800d666:	4618      	mov	r0, r3
 800d668:	f011 f810 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d66c:	4b09      	ldr	r3, [pc, #36]	; (800d694 <staticColorButton5_event_handler+0x4c>)
 800d66e:	681b      	ldr	r3, [r3, #0]
 800d670:	4a0a      	ldr	r2, [pc, #40]	; (800d69c <staticColorButton5_event_handler+0x54>)
 800d672:	2101      	movs	r1, #1
 800d674:	4618      	mov	r0, r3
 800d676:	f011 f809 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 0;
 800d67a:	4b09      	ldr	r3, [pc, #36]	; (800d6a0 <staticColorButton5_event_handler+0x58>)
 800d67c:	2200      	movs	r2, #0
 800d67e:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 128;
 800d680:	4b08      	ldr	r3, [pc, #32]	; (800d6a4 <staticColorButton5_event_handler+0x5c>)
 800d682:	2280      	movs	r2, #128	; 0x80
 800d684:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 0;
 800d686:	4b08      	ldr	r3, [pc, #32]	; (800d6a8 <staticColorButton5_event_handler+0x60>)
 800d688:	2200      	movs	r2, #0
 800d68a:	701a      	strb	r2, [r3, #0]
	}

}
 800d68c:	bf00      	nop
 800d68e:	3708      	adds	r7, #8
 800d690:	46bd      	mov	sp, r7
 800d692:	bd80      	pop	{r7, pc}
 800d694:	2000dc28 	.word	0x2000dc28
 800d698:	20003650 	.word	0x20003650
 800d69c:	2000368c 	.word	0x2000368c
 800d6a0:	200037f4 	.word	0x200037f4
 800d6a4:	200037f5 	.word	0x200037f5
 800d6a8:	200037f6 	.word	0x200037f6

0800d6ac <staticColorButton6_event_handler>:
static void staticColorButton6_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d6ac:	b580      	push	{r7, lr}
 800d6ae:	b082      	sub	sp, #8
 800d6b0:	af00      	add	r7, sp, #0
 800d6b2:	6078      	str	r0, [r7, #4]
 800d6b4:	460b      	mov	r3, r1
 800d6b6:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d6b8:	f000 fa7a 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d6bc:	78fb      	ldrb	r3, [r7, #3]
 800d6be:	2b06      	cmp	r3, #6
 800d6c0:	d116      	bne.n	800d6f0 <staticColorButton6_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d6c2:	4b0d      	ldr	r3, [pc, #52]	; (800d6f8 <staticColorButton6_event_handler+0x4c>)
 800d6c4:	681b      	ldr	r3, [r3, #0]
 800d6c6:	4a0d      	ldr	r2, [pc, #52]	; (800d6fc <staticColorButton6_event_handler+0x50>)
 800d6c8:	2100      	movs	r1, #0
 800d6ca:	4618      	mov	r0, r3
 800d6cc:	f010 ffde 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d6d0:	4b09      	ldr	r3, [pc, #36]	; (800d6f8 <staticColorButton6_event_handler+0x4c>)
 800d6d2:	681b      	ldr	r3, [r3, #0]
 800d6d4:	4a0a      	ldr	r2, [pc, #40]	; (800d700 <staticColorButton6_event_handler+0x54>)
 800d6d6:	2101      	movs	r1, #1
 800d6d8:	4618      	mov	r0, r3
 800d6da:	f010 ffd7 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 128;
 800d6de:	4b09      	ldr	r3, [pc, #36]	; (800d704 <staticColorButton6_event_handler+0x58>)
 800d6e0:	2280      	movs	r2, #128	; 0x80
 800d6e2:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 128;
 800d6e4:	4b08      	ldr	r3, [pc, #32]	; (800d708 <staticColorButton6_event_handler+0x5c>)
 800d6e6:	2280      	movs	r2, #128	; 0x80
 800d6e8:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 0;
 800d6ea:	4b08      	ldr	r3, [pc, #32]	; (800d70c <staticColorButton6_event_handler+0x60>)
 800d6ec:	2200      	movs	r2, #0
 800d6ee:	701a      	strb	r2, [r3, #0]
	}

}
 800d6f0:	bf00      	nop
 800d6f2:	3708      	adds	r7, #8
 800d6f4:	46bd      	mov	sp, r7
 800d6f6:	bd80      	pop	{r7, pc}
 800d6f8:	2000dc28 	.word	0x2000dc28
 800d6fc:	20003650 	.word	0x20003650
 800d700:	2000368c 	.word	0x2000368c
 800d704:	200037f4 	.word	0x200037f4
 800d708:	200037f5 	.word	0x200037f5
 800d70c:	200037f6 	.word	0x200037f6

0800d710 <staticColorButton7_event_handler>:
static void staticColorButton7_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d710:	b580      	push	{r7, lr}
 800d712:	b082      	sub	sp, #8
 800d714:	af00      	add	r7, sp, #0
 800d716:	6078      	str	r0, [r7, #4]
 800d718:	460b      	mov	r3, r1
 800d71a:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d71c:	f000 fa48 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d720:	78fb      	ldrb	r3, [r7, #3]
 800d722:	2b06      	cmp	r3, #6
 800d724:	d116      	bne.n	800d754 <staticColorButton7_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d726:	4b0d      	ldr	r3, [pc, #52]	; (800d75c <staticColorButton7_event_handler+0x4c>)
 800d728:	681b      	ldr	r3, [r3, #0]
 800d72a:	4a0d      	ldr	r2, [pc, #52]	; (800d760 <staticColorButton7_event_handler+0x50>)
 800d72c:	2100      	movs	r1, #0
 800d72e:	4618      	mov	r0, r3
 800d730:	f010 ffac 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d734:	4b09      	ldr	r3, [pc, #36]	; (800d75c <staticColorButton7_event_handler+0x4c>)
 800d736:	681b      	ldr	r3, [r3, #0]
 800d738:	4a0a      	ldr	r2, [pc, #40]	; (800d764 <staticColorButton7_event_handler+0x54>)
 800d73a:	2101      	movs	r1, #1
 800d73c:	4618      	mov	r0, r3
 800d73e:	f010 ffa5 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 0;
 800d742:	4b09      	ldr	r3, [pc, #36]	; (800d768 <staticColorButton7_event_handler+0x58>)
 800d744:	2200      	movs	r2, #0
 800d746:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 128;
 800d748:	4b08      	ldr	r3, [pc, #32]	; (800d76c <staticColorButton7_event_handler+0x5c>)
 800d74a:	2280      	movs	r2, #128	; 0x80
 800d74c:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 128;
 800d74e:	4b08      	ldr	r3, [pc, #32]	; (800d770 <staticColorButton7_event_handler+0x60>)
 800d750:	2280      	movs	r2, #128	; 0x80
 800d752:	701a      	strb	r2, [r3, #0]
	}

}
 800d754:	bf00      	nop
 800d756:	3708      	adds	r7, #8
 800d758:	46bd      	mov	sp, r7
 800d75a:	bd80      	pop	{r7, pc}
 800d75c:	2000dc28 	.word	0x2000dc28
 800d760:	20003650 	.word	0x20003650
 800d764:	2000368c 	.word	0x2000368c
 800d768:	200037f4 	.word	0x200037f4
 800d76c:	200037f5 	.word	0x200037f5
 800d770:	200037f6 	.word	0x200037f6

0800d774 <staticColorButton8_event_handler>:
static void staticColorButton8_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d774:	b580      	push	{r7, lr}
 800d776:	b082      	sub	sp, #8
 800d778:	af00      	add	r7, sp, #0
 800d77a:	6078      	str	r0, [r7, #4]
 800d77c:	460b      	mov	r3, r1
 800d77e:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d780:	f000 fa16 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d784:	78fb      	ldrb	r3, [r7, #3]
 800d786:	2b06      	cmp	r3, #6
 800d788:	d116      	bne.n	800d7b8 <staticColorButton8_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d78a:	4b0d      	ldr	r3, [pc, #52]	; (800d7c0 <staticColorButton8_event_handler+0x4c>)
 800d78c:	681b      	ldr	r3, [r3, #0]
 800d78e:	4a0d      	ldr	r2, [pc, #52]	; (800d7c4 <staticColorButton8_event_handler+0x50>)
 800d790:	2100      	movs	r1, #0
 800d792:	4618      	mov	r0, r3
 800d794:	f010 ff7a 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d798:	4b09      	ldr	r3, [pc, #36]	; (800d7c0 <staticColorButton8_event_handler+0x4c>)
 800d79a:	681b      	ldr	r3, [r3, #0]
 800d79c:	4a0a      	ldr	r2, [pc, #40]	; (800d7c8 <staticColorButton8_event_handler+0x54>)
 800d79e:	2101      	movs	r1, #1
 800d7a0:	4618      	mov	r0, r3
 800d7a2:	f010 ff73 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 0;
 800d7a6:	4b09      	ldr	r3, [pc, #36]	; (800d7cc <staticColorButton8_event_handler+0x58>)
 800d7a8:	2200      	movs	r2, #0
 800d7aa:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 255;
 800d7ac:	4b08      	ldr	r3, [pc, #32]	; (800d7d0 <staticColorButton8_event_handler+0x5c>)
 800d7ae:	22ff      	movs	r2, #255	; 0xff
 800d7b0:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 0;
 800d7b2:	4b08      	ldr	r3, [pc, #32]	; (800d7d4 <staticColorButton8_event_handler+0x60>)
 800d7b4:	2200      	movs	r2, #0
 800d7b6:	701a      	strb	r2, [r3, #0]
	}

}
 800d7b8:	bf00      	nop
 800d7ba:	3708      	adds	r7, #8
 800d7bc:	46bd      	mov	sp, r7
 800d7be:	bd80      	pop	{r7, pc}
 800d7c0:	2000dc28 	.word	0x2000dc28
 800d7c4:	20003650 	.word	0x20003650
 800d7c8:	2000368c 	.word	0x2000368c
 800d7cc:	200037f4 	.word	0x200037f4
 800d7d0:	200037f5 	.word	0x200037f5
 800d7d4:	200037f6 	.word	0x200037f6

0800d7d8 <staticColorButton9_event_handler>:
static void staticColorButton9_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d7d8:	b580      	push	{r7, lr}
 800d7da:	b082      	sub	sp, #8
 800d7dc:	af00      	add	r7, sp, #0
 800d7de:	6078      	str	r0, [r7, #4]
 800d7e0:	460b      	mov	r3, r1
 800d7e2:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d7e4:	f000 f9e4 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d7e8:	78fb      	ldrb	r3, [r7, #3]
 800d7ea:	2b06      	cmp	r3, #6
 800d7ec:	d116      	bne.n	800d81c <staticColorButton9_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d7ee:	4b0d      	ldr	r3, [pc, #52]	; (800d824 <staticColorButton9_event_handler+0x4c>)
 800d7f0:	681b      	ldr	r3, [r3, #0]
 800d7f2:	4a0d      	ldr	r2, [pc, #52]	; (800d828 <staticColorButton9_event_handler+0x50>)
 800d7f4:	2100      	movs	r1, #0
 800d7f6:	4618      	mov	r0, r3
 800d7f8:	f010 ff48 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d7fc:	4b09      	ldr	r3, [pc, #36]	; (800d824 <staticColorButton9_event_handler+0x4c>)
 800d7fe:	681b      	ldr	r3, [r3, #0]
 800d800:	4a0a      	ldr	r2, [pc, #40]	; (800d82c <staticColorButton9_event_handler+0x54>)
 800d802:	2101      	movs	r1, #1
 800d804:	4618      	mov	r0, r3
 800d806:	f010 ff41 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 192;
 800d80a:	4b09      	ldr	r3, [pc, #36]	; (800d830 <staticColorButton9_event_handler+0x58>)
 800d80c:	22c0      	movs	r2, #192	; 0xc0
 800d80e:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 192;
 800d810:	4b08      	ldr	r3, [pc, #32]	; (800d834 <staticColorButton9_event_handler+0x5c>)
 800d812:	22c0      	movs	r2, #192	; 0xc0
 800d814:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 192;
 800d816:	4b08      	ldr	r3, [pc, #32]	; (800d838 <staticColorButton9_event_handler+0x60>)
 800d818:	22c0      	movs	r2, #192	; 0xc0
 800d81a:	701a      	strb	r2, [r3, #0]
	}

}
 800d81c:	bf00      	nop
 800d81e:	3708      	adds	r7, #8
 800d820:	46bd      	mov	sp, r7
 800d822:	bd80      	pop	{r7, pc}
 800d824:	2000dc28 	.word	0x2000dc28
 800d828:	20003650 	.word	0x20003650
 800d82c:	2000368c 	.word	0x2000368c
 800d830:	200037f4 	.word	0x200037f4
 800d834:	200037f5 	.word	0x200037f5
 800d838:	200037f6 	.word	0x200037f6

0800d83c <staticColorButton10_event_handler>:
static void staticColorButton10_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d83c:	b580      	push	{r7, lr}
 800d83e:	b082      	sub	sp, #8
 800d840:	af00      	add	r7, sp, #0
 800d842:	6078      	str	r0, [r7, #4]
 800d844:	460b      	mov	r3, r1
 800d846:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d848:	f000 f9b2 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d84c:	78fb      	ldrb	r3, [r7, #3]
 800d84e:	2b06      	cmp	r3, #6
 800d850:	d116      	bne.n	800d880 <staticColorButton10_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d852:	4b0d      	ldr	r3, [pc, #52]	; (800d888 <staticColorButton10_event_handler+0x4c>)
 800d854:	681b      	ldr	r3, [r3, #0]
 800d856:	4a0d      	ldr	r2, [pc, #52]	; (800d88c <staticColorButton10_event_handler+0x50>)
 800d858:	2100      	movs	r1, #0
 800d85a:	4618      	mov	r0, r3
 800d85c:	f010 ff16 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d860:	4b09      	ldr	r3, [pc, #36]	; (800d888 <staticColorButton10_event_handler+0x4c>)
 800d862:	681b      	ldr	r3, [r3, #0]
 800d864:	4a0a      	ldr	r2, [pc, #40]	; (800d890 <staticColorButton10_event_handler+0x54>)
 800d866:	2101      	movs	r1, #1
 800d868:	4618      	mov	r0, r3
 800d86a:	f010 ff0f 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 0;
 800d86e:	4b09      	ldr	r3, [pc, #36]	; (800d894 <staticColorButton10_event_handler+0x58>)
 800d870:	2200      	movs	r2, #0
 800d872:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 0;
 800d874:	4b08      	ldr	r3, [pc, #32]	; (800d898 <staticColorButton10_event_handler+0x5c>)
 800d876:	2200      	movs	r2, #0
 800d878:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 255;
 800d87a:	4b08      	ldr	r3, [pc, #32]	; (800d89c <staticColorButton10_event_handler+0x60>)
 800d87c:	22ff      	movs	r2, #255	; 0xff
 800d87e:	701a      	strb	r2, [r3, #0]
	}

}
 800d880:	bf00      	nop
 800d882:	3708      	adds	r7, #8
 800d884:	46bd      	mov	sp, r7
 800d886:	bd80      	pop	{r7, pc}
 800d888:	2000dc28 	.word	0x2000dc28
 800d88c:	20003650 	.word	0x20003650
 800d890:	2000368c 	.word	0x2000368c
 800d894:	200037f4 	.word	0x200037f4
 800d898:	200037f5 	.word	0x200037f5
 800d89c:	200037f6 	.word	0x200037f6

0800d8a0 <staticColorButton11_event_handler>:
static void staticColorButton11_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d8a0:	b580      	push	{r7, lr}
 800d8a2:	b082      	sub	sp, #8
 800d8a4:	af00      	add	r7, sp, #0
 800d8a6:	6078      	str	r0, [r7, #4]
 800d8a8:	460b      	mov	r3, r1
 800d8aa:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d8ac:	f000 f980 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d8b0:	78fb      	ldrb	r3, [r7, #3]
 800d8b2:	2b06      	cmp	r3, #6
 800d8b4:	d116      	bne.n	800d8e4 <staticColorButton11_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d8b6:	4b0d      	ldr	r3, [pc, #52]	; (800d8ec <staticColorButton11_event_handler+0x4c>)
 800d8b8:	681b      	ldr	r3, [r3, #0]
 800d8ba:	4a0d      	ldr	r2, [pc, #52]	; (800d8f0 <staticColorButton11_event_handler+0x50>)
 800d8bc:	2100      	movs	r1, #0
 800d8be:	4618      	mov	r0, r3
 800d8c0:	f010 fee4 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d8c4:	4b09      	ldr	r3, [pc, #36]	; (800d8ec <staticColorButton11_event_handler+0x4c>)
 800d8c6:	681b      	ldr	r3, [r3, #0]
 800d8c8:	4a0a      	ldr	r2, [pc, #40]	; (800d8f4 <staticColorButton11_event_handler+0x54>)
 800d8ca:	2101      	movs	r1, #1
 800d8cc:	4618      	mov	r0, r3
 800d8ce:	f010 fedd 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 0;
 800d8d2:	4b09      	ldr	r3, [pc, #36]	; (800d8f8 <staticColorButton11_event_handler+0x58>)
 800d8d4:	2200      	movs	r2, #0
 800d8d6:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 0;
 800d8d8:	4b08      	ldr	r3, [pc, #32]	; (800d8fc <staticColorButton11_event_handler+0x5c>)
 800d8da:	2200      	movs	r2, #0
 800d8dc:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 128;
 800d8de:	4b08      	ldr	r3, [pc, #32]	; (800d900 <staticColorButton11_event_handler+0x60>)
 800d8e0:	2280      	movs	r2, #128	; 0x80
 800d8e2:	701a      	strb	r2, [r3, #0]
	}

}
 800d8e4:	bf00      	nop
 800d8e6:	3708      	adds	r7, #8
 800d8e8:	46bd      	mov	sp, r7
 800d8ea:	bd80      	pop	{r7, pc}
 800d8ec:	2000dc28 	.word	0x2000dc28
 800d8f0:	20003650 	.word	0x20003650
 800d8f4:	2000368c 	.word	0x2000368c
 800d8f8:	200037f4 	.word	0x200037f4
 800d8fc:	200037f5 	.word	0x200037f5
 800d900:	200037f6 	.word	0x200037f6

0800d904 <staticColorButton12_event_handler>:
static void staticColorButton12_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d904:	b580      	push	{r7, lr}
 800d906:	b082      	sub	sp, #8
 800d908:	af00      	add	r7, sp, #0
 800d90a:	6078      	str	r0, [r7, #4]
 800d90c:	460b      	mov	r3, r1
 800d90e:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d910:	f000 f94e 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d914:	78fb      	ldrb	r3, [r7, #3]
 800d916:	2b06      	cmp	r3, #6
 800d918:	d116      	bne.n	800d948 <staticColorButton12_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d91a:	4b0d      	ldr	r3, [pc, #52]	; (800d950 <staticColorButton12_event_handler+0x4c>)
 800d91c:	681b      	ldr	r3, [r3, #0]
 800d91e:	4a0d      	ldr	r2, [pc, #52]	; (800d954 <staticColorButton12_event_handler+0x50>)
 800d920:	2100      	movs	r1, #0
 800d922:	4618      	mov	r0, r3
 800d924:	f010 feb2 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d928:	4b09      	ldr	r3, [pc, #36]	; (800d950 <staticColorButton12_event_handler+0x4c>)
 800d92a:	681b      	ldr	r3, [r3, #0]
 800d92c:	4a0a      	ldr	r2, [pc, #40]	; (800d958 <staticColorButton12_event_handler+0x54>)
 800d92e:	2101      	movs	r1, #1
 800d930:	4618      	mov	r0, r3
 800d932:	f010 feab 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 0;
 800d936:	4b09      	ldr	r3, [pc, #36]	; (800d95c <staticColorButton12_event_handler+0x58>)
 800d938:	2200      	movs	r2, #0
 800d93a:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 255;
 800d93c:	4b08      	ldr	r3, [pc, #32]	; (800d960 <staticColorButton12_event_handler+0x5c>)
 800d93e:	22ff      	movs	r2, #255	; 0xff
 800d940:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 255;
 800d942:	4b08      	ldr	r3, [pc, #32]	; (800d964 <staticColorButton12_event_handler+0x60>)
 800d944:	22ff      	movs	r2, #255	; 0xff
 800d946:	701a      	strb	r2, [r3, #0]
	}

}
 800d948:	bf00      	nop
 800d94a:	3708      	adds	r7, #8
 800d94c:	46bd      	mov	sp, r7
 800d94e:	bd80      	pop	{r7, pc}
 800d950:	2000dc28 	.word	0x2000dc28
 800d954:	20003650 	.word	0x20003650
 800d958:	2000368c 	.word	0x2000368c
 800d95c:	200037f4 	.word	0x200037f4
 800d960:	200037f5 	.word	0x200037f5
 800d964:	200037f6 	.word	0x200037f6

0800d968 <staticColorButton13_event_handler>:
static void staticColorButton13_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d968:	b580      	push	{r7, lr}
 800d96a:	b082      	sub	sp, #8
 800d96c:	af00      	add	r7, sp, #0
 800d96e:	6078      	str	r0, [r7, #4]
 800d970:	460b      	mov	r3, r1
 800d972:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d974:	f000 f91c 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d978:	78fb      	ldrb	r3, [r7, #3]
 800d97a:	2b06      	cmp	r3, #6
 800d97c:	d116      	bne.n	800d9ac <staticColorButton13_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d97e:	4b0d      	ldr	r3, [pc, #52]	; (800d9b4 <staticColorButton13_event_handler+0x4c>)
 800d980:	681b      	ldr	r3, [r3, #0]
 800d982:	4a0d      	ldr	r2, [pc, #52]	; (800d9b8 <staticColorButton13_event_handler+0x50>)
 800d984:	2100      	movs	r1, #0
 800d986:	4618      	mov	r0, r3
 800d988:	f010 fe80 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d98c:	4b09      	ldr	r3, [pc, #36]	; (800d9b4 <staticColorButton13_event_handler+0x4c>)
 800d98e:	681b      	ldr	r3, [r3, #0]
 800d990:	4a0a      	ldr	r2, [pc, #40]	; (800d9bc <staticColorButton13_event_handler+0x54>)
 800d992:	2101      	movs	r1, #1
 800d994:	4618      	mov	r0, r3
 800d996:	f010 fe79 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 255;
 800d99a:	4b09      	ldr	r3, [pc, #36]	; (800d9c0 <staticColorButton13_event_handler+0x58>)
 800d99c:	22ff      	movs	r2, #255	; 0xff
 800d99e:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 255;
 800d9a0:	4b08      	ldr	r3, [pc, #32]	; (800d9c4 <staticColorButton13_event_handler+0x5c>)
 800d9a2:	22ff      	movs	r2, #255	; 0xff
 800d9a4:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 0;
 800d9a6:	4b08      	ldr	r3, [pc, #32]	; (800d9c8 <staticColorButton13_event_handler+0x60>)
 800d9a8:	2200      	movs	r2, #0
 800d9aa:	701a      	strb	r2, [r3, #0]
	}

}
 800d9ac:	bf00      	nop
 800d9ae:	3708      	adds	r7, #8
 800d9b0:	46bd      	mov	sp, r7
 800d9b2:	bd80      	pop	{r7, pc}
 800d9b4:	2000dc28 	.word	0x2000dc28
 800d9b8:	20003650 	.word	0x20003650
 800d9bc:	2000368c 	.word	0x2000368c
 800d9c0:	200037f4 	.word	0x200037f4
 800d9c4:	200037f5 	.word	0x200037f5
 800d9c8:	200037f6 	.word	0x200037f6

0800d9cc <staticColorButton14_event_handler>:
static void staticColorButton14_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800d9cc:	b580      	push	{r7, lr}
 800d9ce:	b082      	sub	sp, #8
 800d9d0:	af00      	add	r7, sp, #0
 800d9d2:	6078      	str	r0, [r7, #4]
 800d9d4:	460b      	mov	r3, r1
 800d9d6:	70fb      	strb	r3, [r7, #3]
		ledButtonStyle();
 800d9d8:	f000 f8ea 	bl	800dbb0 <ledButtonStyle>
	if (event == LV_EVENT_CLICKED) {
 800d9dc:	78fb      	ldrb	r3, [r7, #3]
 800d9de:	2b06      	cmp	r3, #6
 800d9e0:	d116      	bne.n	800da10 <staticColorButton14_event_handler+0x44>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_REL, &led_Button_style_btn_rel);
 800d9e2:	4b0d      	ldr	r3, [pc, #52]	; (800da18 <staticColorButton14_event_handler+0x4c>)
 800d9e4:	681b      	ldr	r3, [r3, #0]
 800d9e6:	4a0d      	ldr	r2, [pc, #52]	; (800da1c <staticColorButton14_event_handler+0x50>)
 800d9e8:	2100      	movs	r1, #0
 800d9ea:	4618      	mov	r0, r3
 800d9ec:	f010 fe4e 	bl	801e68c <lv_btn_set_style>
		lv_btn_set_style(ledSetColorbtn, LV_BTN_STYLE_PR, &led_Button_style_btn_pr);
 800d9f0:	4b09      	ldr	r3, [pc, #36]	; (800da18 <staticColorButton14_event_handler+0x4c>)
 800d9f2:	681b      	ldr	r3, [r3, #0]
 800d9f4:	4a0a      	ldr	r2, [pc, #40]	; (800da20 <staticColorButton14_event_handler+0x54>)
 800d9f6:	2101      	movs	r1, #1
 800d9f8:	4618      	mov	r0, r3
 800d9fa:	f010 fe47 	bl	801e68c <lv_btn_set_style>
		ledTempRValues = 255;
 800d9fe:	4b09      	ldr	r3, [pc, #36]	; (800da24 <staticColorButton14_event_handler+0x58>)
 800da00:	22ff      	movs	r2, #255	; 0xff
 800da02:	701a      	strb	r2, [r3, #0]
		ledTempGValues = 255;
 800da04:	4b08      	ldr	r3, [pc, #32]	; (800da28 <staticColorButton14_event_handler+0x5c>)
 800da06:	22ff      	movs	r2, #255	; 0xff
 800da08:	701a      	strb	r2, [r3, #0]
		ledTempBValues = 255;
 800da0a:	4b08      	ldr	r3, [pc, #32]	; (800da2c <staticColorButton14_event_handler+0x60>)
 800da0c:	22ff      	movs	r2, #255	; 0xff
 800da0e:	701a      	strb	r2, [r3, #0]
	}

}
 800da10:	bf00      	nop
 800da12:	3708      	adds	r7, #8
 800da14:	46bd      	mov	sp, r7
 800da16:	bd80      	pop	{r7, pc}
 800da18:	2000dc28 	.word	0x2000dc28
 800da1c:	20003650 	.word	0x20003650
 800da20:	2000368c 	.word	0x2000368c
 800da24:	200037f4 	.word	0x200037f4
 800da28:	200037f5 	.word	0x200037f5
 800da2c:	200037f6 	.word	0x200037f6

0800da30 <MenuDropList_event_handler>:
static void MenuDropList_event_handler(lv_obj_t * obj, lv_event_t event)
{
 800da30:	b580      	push	{r7, lr}
 800da32:	b086      	sub	sp, #24
 800da34:	af00      	add	r7, sp, #0
 800da36:	6078      	str	r0, [r7, #4]
 800da38:	460b      	mov	r3, r1
 800da3a:	70fb      	strb	r3, [r7, #3]
	if (event == LV_EVENT_VALUE_CHANGED) {
 800da3c:	78fb      	ldrb	r3, [r7, #3]
 800da3e:	2b0e      	cmp	r3, #14
 800da40:	d141      	bne.n	800dac6 <MenuDropList_event_handler+0x96>
		char buf[16];
		lv_ddlist_get_selected_str(obj, buf, sizeof(buf));
 800da42:	f107 0308 	add.w	r3, r7, #8
 800da46:	2210      	movs	r2, #16
 800da48:	4619      	mov	r1, r3
 800da4a:	6878      	ldr	r0, [r7, #4]
 800da4c:	f012 fdf0 	bl	8020630 <lv_ddlist_get_selected_str>
		if (0 == strcmp("Statik Renkler", buf)) {
 800da50:	f107 0308 	add.w	r3, r7, #8
 800da54:	4619      	mov	r1, r3
 800da56:	481e      	ldr	r0, [pc, #120]	; (800dad0 <MenuDropList_event_handler+0xa0>)
 800da58:	f7f2 fbda 	bl	8000210 <strcmp>
 800da5c:	4603      	mov	r3, r0
 800da5e:	2b00      	cmp	r3, #0
 800da60:	d10a      	bne.n	800da78 <MenuDropList_event_handler+0x48>
			lv_obj_clean(lv_scr_act());
 800da62:	f7fe fb7f 	bl	800c164 <lv_scr_act>
 800da66:	4603      	mov	r3, r0
 800da68:	4618      	mov	r0, r3
 800da6a:	f003 f9c5 	bl	8010df8 <lv_obj_clean>
			StaticColorScreen();
 800da6e:	f7fe fbd5 	bl	800c21c <StaticColorScreen>
			MenuDropList();
 800da72:	f7ff fb63 	bl	800d13c <MenuDropList>
			lv_obj_clean(lv_scr_act());
			ColorChooserInformationScreen();
			MenuDropList();
		}
	}
}
 800da76:	e026      	b.n	800dac6 <MenuDropList_event_handler+0x96>
		else if (0 == strcmp("Renk Olusturucu", buf)) {
 800da78:	f107 0308 	add.w	r3, r7, #8
 800da7c:	4619      	mov	r1, r3
 800da7e:	4815      	ldr	r0, [pc, #84]	; (800dad4 <MenuDropList_event_handler+0xa4>)
 800da80:	f7f2 fbc6 	bl	8000210 <strcmp>
 800da84:	4603      	mov	r3, r0
 800da86:	2b00      	cmp	r3, #0
 800da88:	d10a      	bne.n	800daa0 <MenuDropList_event_handler+0x70>
			lv_obj_clean(lv_scr_act());
 800da8a:	f7fe fb6b 	bl	800c164 <lv_scr_act>
 800da8e:	4603      	mov	r3, r0
 800da90:	4618      	mov	r0, r3
 800da92:	f003 f9b1 	bl	8010df8 <lv_obj_clean>
			ColorChooserScreen();
 800da96:	f7fe fbcb 	bl	800c230 <ColorChooserScreen>
			MenuDropList();
 800da9a:	f7ff fb4f 	bl	800d13c <MenuDropList>
}
 800da9e:	e012      	b.n	800dac6 <MenuDropList_event_handler+0x96>
		else if (0 == strcmp("Hakkinda", buf)) {
 800daa0:	f107 0308 	add.w	r3, r7, #8
 800daa4:	4619      	mov	r1, r3
 800daa6:	480c      	ldr	r0, [pc, #48]	; (800dad8 <MenuDropList_event_handler+0xa8>)
 800daa8:	f7f2 fbb2 	bl	8000210 <strcmp>
 800daac:	4603      	mov	r3, r0
 800daae:	2b00      	cmp	r3, #0
 800dab0:	d109      	bne.n	800dac6 <MenuDropList_event_handler+0x96>
			lv_obj_clean(lv_scr_act());
 800dab2:	f7fe fb57 	bl	800c164 <lv_scr_act>
 800dab6:	4603      	mov	r3, r0
 800dab8:	4618      	mov	r0, r3
 800daba:	f003 f99d 	bl	8010df8 <lv_obj_clean>
			ColorChooserInformationScreen();
 800dabe:	f7fe fbc5 	bl	800c24c <ColorChooserInformationScreen>
			MenuDropList();
 800dac2:	f7ff fb3b 	bl	800d13c <MenuDropList>
}
 800dac6:	bf00      	nop
 800dac8:	3718      	adds	r7, #24
 800daca:	46bd      	mov	sp, r7
 800dacc:	bd80      	pop	{r7, pc}
 800dace:	bf00      	nop
 800dad0:	08028558 	.word	0x08028558
 800dad4:	08028568 	.word	0x08028568
 800dad8:	08028578 	.word	0x08028578

0800dadc <ledSliderStyle>:
/*Style Functions*/
void ledSliderStyle(void) {
 800dadc:	b598      	push	{r3, r4, r7, lr}
 800dade:	af00      	add	r7, sp, #0

	lv_style_copy(&ledSlider_style_bg, &lv_style_pretty);
 800dae0:	492d      	ldr	r1, [pc, #180]	; (800db98 <ledSliderStyle+0xbc>)
 800dae2:	482e      	ldr	r0, [pc, #184]	; (800db9c <ledSliderStyle+0xc0>)
 800dae4:	f005 ffbe 	bl	8013a64 <lv_style_copy>
	ledSlider_style_bg.body.main_color = lv_color_hsv_to_rgb(0, 11, 18);
 800dae8:	4c2c      	ldr	r4, [pc, #176]	; (800db9c <ledSliderStyle+0xc0>)
 800daea:	2212      	movs	r2, #18
 800daec:	210b      	movs	r1, #11
 800daee:	2000      	movs	r0, #0
 800daf0:	f00e f9b4 	bl	801be5c <lv_color_hsv_to_rgb>
 800daf4:	8060      	strh	r0, [r4, #2]
	ledSlider_style_bg.body.grad_color = lv_color_hsv_to_rgb(0, 11, 18);
 800daf6:	4c29      	ldr	r4, [pc, #164]	; (800db9c <ledSliderStyle+0xc0>)
 800daf8:	2212      	movs	r2, #18
 800dafa:	210b      	movs	r1, #11
 800dafc:	2000      	movs	r0, #0
 800dafe:	f00e f9ad 	bl	801be5c <lv_color_hsv_to_rgb>
 800db02:	80a0      	strh	r0, [r4, #4]
	ledSlider_style_bg.body.radius = LV_RADIUS_CIRCLE;
 800db04:	4b25      	ldr	r3, [pc, #148]	; (800db9c <ledSliderStyle+0xc0>)
 800db06:	f647 4218 	movw	r2, #31768	; 0x7c18
 800db0a:	80da      	strh	r2, [r3, #6]
	ledSlider_style_bg.body.border.color = LV_COLOR_WHITE;
 800db0c:	4a23      	ldr	r2, [pc, #140]	; (800db9c <ledSliderStyle+0xc0>)
 800db0e:	4b24      	ldr	r3, [pc, #144]	; (800dba0 <ledSliderStyle+0xc4>)
 800db10:	881b      	ldrh	r3, [r3, #0]
 800db12:	8153      	strh	r3, [r2, #10]

	lv_style_copy(&ledSlider_style_indic, &lv_style_pretty_color);
 800db14:	4923      	ldr	r1, [pc, #140]	; (800dba4 <ledSliderStyle+0xc8>)
 800db16:	4824      	ldr	r0, [pc, #144]	; (800dba8 <ledSliderStyle+0xcc>)
 800db18:	f005 ffa4 	bl	8013a64 <lv_style_copy>
	ledSlider_style_indic.body.radius = LV_RADIUS_CIRCLE;
 800db1c:	4b22      	ldr	r3, [pc, #136]	; (800dba8 <ledSliderStyle+0xcc>)
 800db1e:	f647 4218 	movw	r2, #31768	; 0x7c18
 800db22:	80da      	strh	r2, [r3, #6]
	ledSlider_style_indic.body.shadow.width = 8;
 800db24:	4b20      	ldr	r3, [pc, #128]	; (800dba8 <ledSliderStyle+0xcc>)
 800db26:	2208      	movs	r2, #8
 800db28:	825a      	strh	r2, [r3, #18]
	ledSlider_style_indic.body.main_color = lv_color_make(0, 191, 255);
 800db2a:	4c1f      	ldr	r4, [pc, #124]	; (800dba8 <ledSliderStyle+0xcc>)
 800db2c:	22ff      	movs	r2, #255	; 0xff
 800db2e:	21bf      	movs	r1, #191	; 0xbf
 800db30:	2000      	movs	r0, #0
 800db32:	f7fe fab7 	bl	800c0a4 <lv_color_make>
 800db36:	8060      	strh	r0, [r4, #2]
	ledSlider_style_indic.body.grad_color = lv_color_hex3(0x00b2ee);
 800db38:	4c1b      	ldr	r4, [pc, #108]	; (800dba8 <ledSliderStyle+0xcc>)
 800db3a:	f24b 20ee 	movw	r0, #45806	; 0xb2ee
 800db3e:	f7fe fadf 	bl	800c100 <lv_color_hex3>
 800db42:	80a0      	strh	r0, [r4, #4]
	ledSlider_style_indic.body.shadow.color = ledSlider_style_indic.body.main_color;
 800db44:	4a18      	ldr	r2, [pc, #96]	; (800dba8 <ledSliderStyle+0xcc>)
 800db46:	4b18      	ldr	r3, [pc, #96]	; (800dba8 <ledSliderStyle+0xcc>)
 800db48:	885b      	ldrh	r3, [r3, #2]
 800db4a:	8213      	strh	r3, [r2, #16]
	ledSlider_style_indic.body.padding.left = 3;
 800db4c:	4b16      	ldr	r3, [pc, #88]	; (800dba8 <ledSliderStyle+0xcc>)
 800db4e:	2203      	movs	r2, #3
 800db50:	835a      	strh	r2, [r3, #26]
	ledSlider_style_indic.body.padding.right = 3;
 800db52:	4b15      	ldr	r3, [pc, #84]	; (800dba8 <ledSliderStyle+0xcc>)
 800db54:	2203      	movs	r2, #3
 800db56:	839a      	strh	r2, [r3, #28]
	ledSlider_style_indic.body.padding.top = 3;
 800db58:	4b13      	ldr	r3, [pc, #76]	; (800dba8 <ledSliderStyle+0xcc>)
 800db5a:	2203      	movs	r2, #3
 800db5c:	82da      	strh	r2, [r3, #22]
	ledSlider_style_indic.body.padding.bottom = 3;
 800db5e:	4b12      	ldr	r3, [pc, #72]	; (800dba8 <ledSliderStyle+0xcc>)
 800db60:	2203      	movs	r2, #3
 800db62:	831a      	strh	r2, [r3, #24]
	ledSlider_style_indic.text.color = lv_color_make(0, 0, 255);
 800db64:	4c10      	ldr	r4, [pc, #64]	; (800dba8 <ledSliderStyle+0xcc>)
 800db66:	22ff      	movs	r2, #255	; 0xff
 800db68:	2100      	movs	r1, #0
 800db6a:	2000      	movs	r0, #0
 800db6c:	f7fe fa9a 	bl	800c0a4 <lv_color_make>
 800db70:	8420      	strh	r0, [r4, #32]

	lv_style_copy(&ledSlider_style_knob, &lv_style_pretty);
 800db72:	4909      	ldr	r1, [pc, #36]	; (800db98 <ledSliderStyle+0xbc>)
 800db74:	480d      	ldr	r0, [pc, #52]	; (800dbac <ledSliderStyle+0xd0>)
 800db76:	f005 ff75 	bl	8013a64 <lv_style_copy>
	ledSlider_style_knob.body.radius = LV_RADIUS_CIRCLE;
 800db7a:	4b0c      	ldr	r3, [pc, #48]	; (800dbac <ledSliderStyle+0xd0>)
 800db7c:	f647 4218 	movw	r2, #31768	; 0x7c18
 800db80:	80da      	strh	r2, [r3, #6]
	ledSlider_style_knob.body.opa = LV_OPA_70;
 800db82:	4b0a      	ldr	r3, [pc, #40]	; (800dbac <ledSliderStyle+0xd0>)
 800db84:	22b2      	movs	r2, #178	; 0xb2
 800db86:	721a      	strb	r2, [r3, #8]
	ledSlider_style_knob.body.padding.top = 10;
 800db88:	4b08      	ldr	r3, [pc, #32]	; (800dbac <ledSliderStyle+0xd0>)
 800db8a:	220a      	movs	r2, #10
 800db8c:	82da      	strh	r2, [r3, #22]
	ledSlider_style_knob.body.padding.bottom = 10;
 800db8e:	4b07      	ldr	r3, [pc, #28]	; (800dbac <ledSliderStyle+0xd0>)
 800db90:	220a      	movs	r2, #10
 800db92:	831a      	strh	r2, [r3, #24]
}
 800db94:	bf00      	nop
 800db96:	bd98      	pop	{r3, r4, r7, pc}
 800db98:	2000dd28 	.word	0x2000dd28
 800db9c:	2000359c 	.word	0x2000359c
 800dba0:	08028584 	.word	0x08028584
 800dba4:	2000dc38 	.word	0x2000dc38
 800dba8:	200035d8 	.word	0x200035d8
 800dbac:	20003614 	.word	0x20003614

0800dbb0 <ledButtonStyle>:
void ledButtonStyle(void) {
 800dbb0:	b598      	push	{r3, r4, r7, lr}
 800dbb2:	af00      	add	r7, sp, #0

	lv_style_copy(&led_Button_style_btn_rel, &lv_style_plain);         /*Initialize from a built-in style*/
 800dbb4:	493e      	ldr	r1, [pc, #248]	; (800dcb0 <ledButtonStyle+0x100>)
 800dbb6:	483f      	ldr	r0, [pc, #252]	; (800dcb4 <ledButtonStyle+0x104>)
 800dbb8:	f005 ff54 	bl	8013a64 <lv_style_copy>
	led_Button_style_btn_rel.body.border.color = lv_color_hex3(0x00bfff);
 800dbbc:	4c3d      	ldr	r4, [pc, #244]	; (800dcb4 <ledButtonStyle+0x104>)
 800dbbe:	f64b 70ff 	movw	r0, #49151	; 0xbfff
 800dbc2:	f7fe fa9d 	bl	800c100 <lv_color_hex3>
 800dbc6:	8160      	strh	r0, [r4, #10]
	led_Button_style_btn_rel.body.border.width = 1;
 800dbc8:	4b3a      	ldr	r3, [pc, #232]	; (800dcb4 <ledButtonStyle+0x104>)
 800dbca:	2201      	movs	r2, #1
 800dbcc:	819a      	strh	r2, [r3, #12]
	led_Button_style_btn_rel.body.main_color = lv_color_make(ledTempRValues, ledTempGValues, ledTempBValues);
 800dbce:	4b3a      	ldr	r3, [pc, #232]	; (800dcb8 <ledButtonStyle+0x108>)
 800dbd0:	7818      	ldrb	r0, [r3, #0]
 800dbd2:	4b3a      	ldr	r3, [pc, #232]	; (800dcbc <ledButtonStyle+0x10c>)
 800dbd4:	7819      	ldrb	r1, [r3, #0]
 800dbd6:	4b3a      	ldr	r3, [pc, #232]	; (800dcc0 <ledButtonStyle+0x110>)
 800dbd8:	781b      	ldrb	r3, [r3, #0]
 800dbda:	4c36      	ldr	r4, [pc, #216]	; (800dcb4 <ledButtonStyle+0x104>)
 800dbdc:	461a      	mov	r2, r3
 800dbde:	f7fe fa61 	bl	800c0a4 <lv_color_make>
 800dbe2:	8060      	strh	r0, [r4, #2]
	led_Button_style_btn_rel.body.grad_color = lv_color_make(ledTempRValues, ledTempGValues, ledTempBValues);
 800dbe4:	4b34      	ldr	r3, [pc, #208]	; (800dcb8 <ledButtonStyle+0x108>)
 800dbe6:	7818      	ldrb	r0, [r3, #0]
 800dbe8:	4b34      	ldr	r3, [pc, #208]	; (800dcbc <ledButtonStyle+0x10c>)
 800dbea:	7819      	ldrb	r1, [r3, #0]
 800dbec:	4b34      	ldr	r3, [pc, #208]	; (800dcc0 <ledButtonStyle+0x110>)
 800dbee:	781b      	ldrb	r3, [r3, #0]
 800dbf0:	4c30      	ldr	r4, [pc, #192]	; (800dcb4 <ledButtonStyle+0x104>)
 800dbf2:	461a      	mov	r2, r3
 800dbf4:	f7fe fa56 	bl	800c0a4 <lv_color_make>
 800dbf8:	80a0      	strh	r0, [r4, #4]
	led_Button_style_btn_rel.body.shadow.width = 4;
 800dbfa:	4b2e      	ldr	r3, [pc, #184]	; (800dcb4 <ledButtonStyle+0x104>)
 800dbfc:	2204      	movs	r2, #4
 800dbfe:	825a      	strh	r2, [r3, #18]
	led_Button_style_btn_rel.body.shadow.type = LV_SHADOW_BOTTOM;
 800dc00:	4b2c      	ldr	r3, [pc, #176]	; (800dcb4 <ledButtonStyle+0x104>)
 800dc02:	2200      	movs	r2, #0
 800dc04:	751a      	strb	r2, [r3, #20]
	led_Button_style_btn_rel.body.radius = LV_RADIUS_CIRCLE;
 800dc06:	4b2b      	ldr	r3, [pc, #172]	; (800dcb4 <ledButtonStyle+0x104>)
 800dc08:	f647 4218 	movw	r2, #31768	; 0x7c18
 800dc0c:	80da      	strh	r2, [r3, #6]
	led_Button_style_btn_rel.text.font = &lv_font_roboto_16;
 800dc0e:	4b29      	ldr	r3, [pc, #164]	; (800dcb4 <ledButtonStyle+0x104>)
 800dc10:	4a2c      	ldr	r2, [pc, #176]	; (800dcc4 <ledButtonStyle+0x114>)
 800dc12:	625a      	str	r2, [r3, #36]	; 0x24
	led_Button_style_btn_rel.text.color = lv_color_hex3(0x000);
 800dc14:	4c27      	ldr	r4, [pc, #156]	; (800dcb4 <ledButtonStyle+0x104>)
 800dc16:	2000      	movs	r0, #0
 800dc18:	f7fe fa72 	bl	800c100 <lv_color_hex3>
 800dc1c:	8420      	strh	r0, [r4, #32]


	lv_style_copy(&led_Button_style_btn_pr, &led_Button_style_btn_rel);
 800dc1e:	4925      	ldr	r1, [pc, #148]	; (800dcb4 <ledButtonStyle+0x104>)
 800dc20:	4829      	ldr	r0, [pc, #164]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc22:	f005 ff1f 	bl	8013a64 <lv_style_copy>
	led_Button_style_btn_pr.body.border.color = lv_color_hex3(0x00bfff);
 800dc26:	4c28      	ldr	r4, [pc, #160]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc28:	f64b 70ff 	movw	r0, #49151	; 0xbfff
 800dc2c:	f7fe fa68 	bl	800c100 <lv_color_hex3>
 800dc30:	8160      	strh	r0, [r4, #10]
	led_Button_style_btn_pr.body.main_color = lv_color_make(ledTempRValues, ledTempGValues, ledTempBValues);
 800dc32:	4b21      	ldr	r3, [pc, #132]	; (800dcb8 <ledButtonStyle+0x108>)
 800dc34:	7818      	ldrb	r0, [r3, #0]
 800dc36:	4b21      	ldr	r3, [pc, #132]	; (800dcbc <ledButtonStyle+0x10c>)
 800dc38:	7819      	ldrb	r1, [r3, #0]
 800dc3a:	4b21      	ldr	r3, [pc, #132]	; (800dcc0 <ledButtonStyle+0x110>)
 800dc3c:	781b      	ldrb	r3, [r3, #0]
 800dc3e:	4c22      	ldr	r4, [pc, #136]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc40:	461a      	mov	r2, r3
 800dc42:	f7fe fa2f 	bl	800c0a4 <lv_color_make>
 800dc46:	8060      	strh	r0, [r4, #2]
	led_Button_style_btn_pr.body.grad_color = lv_color_make(ledTempRValues, ledTempGValues, ledTempBValues);
 800dc48:	4b1b      	ldr	r3, [pc, #108]	; (800dcb8 <ledButtonStyle+0x108>)
 800dc4a:	7818      	ldrb	r0, [r3, #0]
 800dc4c:	4b1b      	ldr	r3, [pc, #108]	; (800dcbc <ledButtonStyle+0x10c>)
 800dc4e:	7819      	ldrb	r1, [r3, #0]
 800dc50:	4b1b      	ldr	r3, [pc, #108]	; (800dcc0 <ledButtonStyle+0x110>)
 800dc52:	781b      	ldrb	r3, [r3, #0]
 800dc54:	4c1c      	ldr	r4, [pc, #112]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc56:	461a      	mov	r2, r3
 800dc58:	f7fe fa24 	bl	800c0a4 <lv_color_make>
 800dc5c:	80a0      	strh	r0, [r4, #4]
	led_Button_style_btn_pr.body.shadow.width = 2;
 800dc5e:	4b1a      	ldr	r3, [pc, #104]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc60:	2202      	movs	r2, #2
 800dc62:	825a      	strh	r2, [r3, #18]
	led_Button_style_btn_pr.text.font = &lv_font_roboto_16;
 800dc64:	4b18      	ldr	r3, [pc, #96]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc66:	4a17      	ldr	r2, [pc, #92]	; (800dcc4 <ledButtonStyle+0x114>)
 800dc68:	625a      	str	r2, [r3, #36]	; 0x24
	led_Button_style_btn_pr.text.color = lv_color_hex3(0x000);
 800dc6a:	4c17      	ldr	r4, [pc, #92]	; (800dcc8 <ledButtonStyle+0x118>)
 800dc6c:	2000      	movs	r0, #0
 800dc6e:	f7fe fa47 	bl	800c100 <lv_color_hex3>
 800dc72:	8420      	strh	r0, [r4, #32]

	if (ledTempRValues < 128 && ledTempGValues < 128 && ledTempBValues < 128) {
 800dc74:	4b10      	ldr	r3, [pc, #64]	; (800dcb8 <ledButtonStyle+0x108>)
 800dc76:	781b      	ldrb	r3, [r3, #0]
 800dc78:	b25b      	sxtb	r3, r3
 800dc7a:	2b00      	cmp	r3, #0
 800dc7c:	db15      	blt.n	800dcaa <ledButtonStyle+0xfa>
 800dc7e:	4b0f      	ldr	r3, [pc, #60]	; (800dcbc <ledButtonStyle+0x10c>)
 800dc80:	781b      	ldrb	r3, [r3, #0]
 800dc82:	b25b      	sxtb	r3, r3
 800dc84:	2b00      	cmp	r3, #0
 800dc86:	db10      	blt.n	800dcaa <ledButtonStyle+0xfa>
 800dc88:	4b0d      	ldr	r3, [pc, #52]	; (800dcc0 <ledButtonStyle+0x110>)
 800dc8a:	781b      	ldrb	r3, [r3, #0]
 800dc8c:	b25b      	sxtb	r3, r3
 800dc8e:	2b00      	cmp	r3, #0
 800dc90:	db0b      	blt.n	800dcaa <ledButtonStyle+0xfa>
		led_Button_style_btn_rel.text.color = lv_color_hex3(0xfff);
 800dc92:	4c08      	ldr	r4, [pc, #32]	; (800dcb4 <ledButtonStyle+0x104>)
 800dc94:	f640 70ff 	movw	r0, #4095	; 0xfff
 800dc98:	f7fe fa32 	bl	800c100 <lv_color_hex3>
 800dc9c:	8420      	strh	r0, [r4, #32]
		led_Button_style_btn_pr.text.color = lv_color_hex3(0xfff);
 800dc9e:	4c0a      	ldr	r4, [pc, #40]	; (800dcc8 <ledButtonStyle+0x118>)
 800dca0:	f640 70ff 	movw	r0, #4095	; 0xfff
 800dca4:	f7fe fa2c 	bl	800c100 <lv_color_hex3>
 800dca8:	8420      	strh	r0, [r4, #32]
	}
}
 800dcaa:	bf00      	nop
 800dcac:	bd98      	pop	{r3, r4, r7, pc}
 800dcae:	bf00      	nop
 800dcb0:	2000de18 	.word	0x2000de18
 800dcb4:	20003650 	.word	0x20003650
 800dcb8:	200037f4 	.word	0x200037f4
 800dcbc:	200037f5 	.word	0x200037f5
 800dcc0:	200037f6 	.word	0x200037f6
 800dcc4:	20000c1c 	.word	0x20000c1c
 800dcc8:	2000368c 	.word	0x2000368c

0800dccc <outGoingColorContainerStyle>:
void outGoingColorContainerStyle(void) {
 800dccc:	b598      	push	{r3, r4, r7, lr}
 800dcce:	af00      	add	r7, sp, #0
	ledButtonStyle();
 800dcd0:	f7ff ff6e 	bl	800dbb0 <ledButtonStyle>

	lv_style_copy(&ledOutGoingContainerRelSyle, &led_Button_style_btn_rel);
 800dcd4:	491a      	ldr	r1, [pc, #104]	; (800dd40 <outGoingColorContainerStyle+0x74>)
 800dcd6:	481b      	ldr	r0, [pc, #108]	; (800dd44 <outGoingColorContainerStyle+0x78>)
 800dcd8:	f005 fec4 	bl	8013a64 <lv_style_copy>
	lv_style_copy(&ledOutGoingContainerPrStyle, &led_Button_style_btn_pr);
 800dcdc:	491a      	ldr	r1, [pc, #104]	; (800dd48 <outGoingColorContainerStyle+0x7c>)
 800dcde:	481b      	ldr	r0, [pc, #108]	; (800dd4c <outGoingColorContainerStyle+0x80>)
 800dce0:	f005 fec0 	bl	8013a64 <lv_style_copy>
	ledOutGoingContainerRelSyle.body.main_color = lv_color_make(ledRValues, ledGValues, ledBValues);
 800dce4:	4b1a      	ldr	r3, [pc, #104]	; (800dd50 <outGoingColorContainerStyle+0x84>)
 800dce6:	7818      	ldrb	r0, [r3, #0]
 800dce8:	4b1a      	ldr	r3, [pc, #104]	; (800dd54 <outGoingColorContainerStyle+0x88>)
 800dcea:	7819      	ldrb	r1, [r3, #0]
 800dcec:	4b1a      	ldr	r3, [pc, #104]	; (800dd58 <outGoingColorContainerStyle+0x8c>)
 800dcee:	781b      	ldrb	r3, [r3, #0]
 800dcf0:	4c14      	ldr	r4, [pc, #80]	; (800dd44 <outGoingColorContainerStyle+0x78>)
 800dcf2:	461a      	mov	r2, r3
 800dcf4:	f7fe f9d6 	bl	800c0a4 <lv_color_make>
 800dcf8:	8060      	strh	r0, [r4, #2]
	ledOutGoingContainerRelSyle.body.grad_color = lv_color_make(ledRValues, ledGValues, ledBValues);
 800dcfa:	4b15      	ldr	r3, [pc, #84]	; (800dd50 <outGoingColorContainerStyle+0x84>)
 800dcfc:	7818      	ldrb	r0, [r3, #0]
 800dcfe:	4b15      	ldr	r3, [pc, #84]	; (800dd54 <outGoingColorContainerStyle+0x88>)
 800dd00:	7819      	ldrb	r1, [r3, #0]
 800dd02:	4b15      	ldr	r3, [pc, #84]	; (800dd58 <outGoingColorContainerStyle+0x8c>)
 800dd04:	781b      	ldrb	r3, [r3, #0]
 800dd06:	4c0f      	ldr	r4, [pc, #60]	; (800dd44 <outGoingColorContainerStyle+0x78>)
 800dd08:	461a      	mov	r2, r3
 800dd0a:	f7fe f9cb 	bl	800c0a4 <lv_color_make>
 800dd0e:	80a0      	strh	r0, [r4, #4]
	ledOutGoingContainerPrStyle.body.main_color = lv_color_make(ledRValues, ledGValues, ledBValues);
 800dd10:	4b0f      	ldr	r3, [pc, #60]	; (800dd50 <outGoingColorContainerStyle+0x84>)
 800dd12:	7818      	ldrb	r0, [r3, #0]
 800dd14:	4b0f      	ldr	r3, [pc, #60]	; (800dd54 <outGoingColorContainerStyle+0x88>)
 800dd16:	7819      	ldrb	r1, [r3, #0]
 800dd18:	4b0f      	ldr	r3, [pc, #60]	; (800dd58 <outGoingColorContainerStyle+0x8c>)
 800dd1a:	781b      	ldrb	r3, [r3, #0]
 800dd1c:	4c0b      	ldr	r4, [pc, #44]	; (800dd4c <outGoingColorContainerStyle+0x80>)
 800dd1e:	461a      	mov	r2, r3
 800dd20:	f7fe f9c0 	bl	800c0a4 <lv_color_make>
 800dd24:	8060      	strh	r0, [r4, #2]
	ledOutGoingContainerPrStyle.body.grad_color = lv_color_make(ledRValues, ledGValues, ledBValues);
 800dd26:	4b0a      	ldr	r3, [pc, #40]	; (800dd50 <outGoingColorContainerStyle+0x84>)
 800dd28:	7818      	ldrb	r0, [r3, #0]
 800dd2a:	4b0a      	ldr	r3, [pc, #40]	; (800dd54 <outGoingColorContainerStyle+0x88>)
 800dd2c:	7819      	ldrb	r1, [r3, #0]
 800dd2e:	4b0a      	ldr	r3, [pc, #40]	; (800dd58 <outGoingColorContainerStyle+0x8c>)
 800dd30:	781b      	ldrb	r3, [r3, #0]
 800dd32:	4c06      	ldr	r4, [pc, #24]	; (800dd4c <outGoingColorContainerStyle+0x80>)
 800dd34:	461a      	mov	r2, r3
 800dd36:	f7fe f9b5 	bl	800c0a4 <lv_color_make>
 800dd3a:	80a0      	strh	r0, [r4, #4]
}
 800dd3c:	bf00      	nop
 800dd3e:	bd98      	pop	{r3, r4, r7, pc}
 800dd40:	20003650 	.word	0x20003650
 800dd44:	200036c8 	.word	0x200036c8
 800dd48:	2000368c 	.word	0x2000368c
 800dd4c:	20003704 	.word	0x20003704
 800dd50:	200037f7 	.word	0x200037f7
 800dd54:	200037f8 	.word	0x200037f8
 800dd58:	200037f9 	.word	0x200037f9

0800dd5c <menuDownListStyle>:
void menuDownListStyle(void) {
 800dd5c:	b598      	push	{r3, r4, r7, lr}
 800dd5e:	af00      	add	r7, sp, #0



	lv_style_copy(&menuDownList_SbStyle, &lv_style_plain);
 800dd60:	492b      	ldr	r1, [pc, #172]	; (800de10 <menuDownListStyle+0xb4>)
 800dd62:	482c      	ldr	r0, [pc, #176]	; (800de14 <menuDownListStyle+0xb8>)
 800dd64:	f005 fe7e 	bl	8013a64 <lv_style_copy>
	lv_style_copy(&menuDownList_SelStyle, &lv_style_plain);
 800dd68:	4929      	ldr	r1, [pc, #164]	; (800de10 <menuDownListStyle+0xb4>)
 800dd6a:	482b      	ldr	r0, [pc, #172]	; (800de18 <menuDownListStyle+0xbc>)
 800dd6c:	f005 fe7a 	bl	8013a64 <lv_style_copy>
	lv_style_copy(&menuDownList_bgStyle, &lv_style_plain);
 800dd70:	4927      	ldr	r1, [pc, #156]	; (800de10 <menuDownListStyle+0xb4>)
 800dd72:	482a      	ldr	r0, [pc, #168]	; (800de1c <menuDownListStyle+0xc0>)
 800dd74:	f005 fe76 	bl	8013a64 <lv_style_copy>


	menuDownList_SbStyle.body.main_color = lv_color_make(0, 191, 255);
 800dd78:	4c26      	ldr	r4, [pc, #152]	; (800de14 <menuDownListStyle+0xb8>)
 800dd7a:	22ff      	movs	r2, #255	; 0xff
 800dd7c:	21bf      	movs	r1, #191	; 0xbf
 800dd7e:	2000      	movs	r0, #0
 800dd80:	f7fe f990 	bl	800c0a4 <lv_color_make>
 800dd84:	8060      	strh	r0, [r4, #2]
	menuDownList_SbStyle.body.grad_color = lv_color_make(0, 191, 255);
 800dd86:	4c23      	ldr	r4, [pc, #140]	; (800de14 <menuDownListStyle+0xb8>)
 800dd88:	22ff      	movs	r2, #255	; 0xff
 800dd8a:	21bf      	movs	r1, #191	; 0xbf
 800dd8c:	2000      	movs	r0, #0
 800dd8e:	f7fe f989 	bl	800c0a4 <lv_color_make>
 800dd92:	80a0      	strh	r0, [r4, #4]
	menuDownList_SbStyle.body.border.width = 0;
 800dd94:	4b1f      	ldr	r3, [pc, #124]	; (800de14 <menuDownListStyle+0xb8>)
 800dd96:	2200      	movs	r2, #0
 800dd98:	819a      	strh	r2, [r3, #12]
	menuDownList_SbStyle.body.padding.inner = 3;
 800dd9a:	4b1e      	ldr	r3, [pc, #120]	; (800de14 <menuDownListStyle+0xb8>)
 800dd9c:	2203      	movs	r2, #3
 800dd9e:	83da      	strh	r2, [r3, #30]
	menuDownList_SbStyle.body.padding.left = 0;
 800dda0:	4b1c      	ldr	r3, [pc, #112]	; (800de14 <menuDownListStyle+0xb8>)
 800dda2:	2200      	movs	r2, #0
 800dda4:	835a      	strh	r2, [r3, #26]
	menuDownList_SbStyle.body.padding.right = 0;
 800dda6:	4b1b      	ldr	r3, [pc, #108]	; (800de14 <menuDownListStyle+0xb8>)
 800dda8:	2200      	movs	r2, #0
 800ddaa:	839a      	strh	r2, [r3, #28]
	menuDownList_SbStyle.body.padding.top = 0;
 800ddac:	4b19      	ldr	r3, [pc, #100]	; (800de14 <menuDownListStyle+0xb8>)
 800ddae:	2200      	movs	r2, #0
 800ddb0:	82da      	strh	r2, [r3, #22]
	menuDownList_SbStyle.body.padding.bottom = 0;
 800ddb2:	4b18      	ldr	r3, [pc, #96]	; (800de14 <menuDownListStyle+0xb8>)
 800ddb4:	2200      	movs	r2, #0
 800ddb6:	831a      	strh	r2, [r3, #24]
	menuDownList_SbStyle.body.radius = 3;
 800ddb8:	4b16      	ldr	r3, [pc, #88]	; (800de14 <menuDownListStyle+0xb8>)
 800ddba:	2203      	movs	r2, #3
 800ddbc:	80da      	strh	r2, [r3, #6]
	menuDownList_SbStyle.body.opa = LV_OPA_COVER;
 800ddbe:	4b15      	ldr	r3, [pc, #84]	; (800de14 <menuDownListStyle+0xb8>)
 800ddc0:	22ff      	movs	r2, #255	; 0xff
 800ddc2:	721a      	strb	r2, [r3, #8]

	menuDownList_bgStyle.text.line_space = 3;
 800ddc4:	4b15      	ldr	r3, [pc, #84]	; (800de1c <menuDownListStyle+0xc0>)
 800ddc6:	2203      	movs	r2, #3
 800ddc8:	855a      	strh	r2, [r3, #42]	; 0x2a
	menuDownList_bgStyle.body.padding.top = LV_DPI / 8;
 800ddca:	4b14      	ldr	r3, [pc, #80]	; (800de1c <menuDownListStyle+0xc0>)
 800ddcc:	220c      	movs	r2, #12
 800ddce:	82da      	strh	r2, [r3, #22]
	menuDownList_bgStyle.body.padding.bottom = LV_DPI / 8;
 800ddd0:	4b12      	ldr	r3, [pc, #72]	; (800de1c <menuDownListStyle+0xc0>)
 800ddd2:	220c      	movs	r2, #12
 800ddd4:	831a      	strh	r2, [r3, #24]
	menuDownList_bgStyle.body.padding.left = LV_DPI / 8;
 800ddd6:	4b11      	ldr	r3, [pc, #68]	; (800de1c <menuDownListStyle+0xc0>)
 800ddd8:	220c      	movs	r2, #12
 800ddda:	835a      	strh	r2, [r3, #26]
	menuDownList_bgStyle.body.padding.right = LV_DPI / 8;
 800dddc:	4b0f      	ldr	r3, [pc, #60]	; (800de1c <menuDownListStyle+0xc0>)
 800ddde:	220c      	movs	r2, #12
 800dde0:	839a      	strh	r2, [r3, #28]
	menuDownList_bgStyle.body.radius = 3;
 800dde2:	4b0e      	ldr	r3, [pc, #56]	; (800de1c <menuDownListStyle+0xc0>)
 800dde4:	2203      	movs	r2, #3
 800dde6:	80da      	strh	r2, [r3, #6]


	menuDownList_SelStyle.body.main_color = lv_color_make(0, 191, 255);
 800dde8:	4c0b      	ldr	r4, [pc, #44]	; (800de18 <menuDownListStyle+0xbc>)
 800ddea:	22ff      	movs	r2, #255	; 0xff
 800ddec:	21bf      	movs	r1, #191	; 0xbf
 800ddee:	2000      	movs	r0, #0
 800ddf0:	f7fe f958 	bl	800c0a4 <lv_color_make>
 800ddf4:	8060      	strh	r0, [r4, #2]
	menuDownList_SelStyle.body.grad_color = lv_color_make(0, 191, 255);
 800ddf6:	4c08      	ldr	r4, [pc, #32]	; (800de18 <menuDownListStyle+0xbc>)
 800ddf8:	22ff      	movs	r2, #255	; 0xff
 800ddfa:	21bf      	movs	r1, #191	; 0xbf
 800ddfc:	2000      	movs	r0, #0
 800ddfe:	f7fe f951 	bl	800c0a4 <lv_color_make>
 800de02:	80a0      	strh	r0, [r4, #4]
	menuDownList_SelStyle.body.radius = 0;
 800de04:	4b04      	ldr	r3, [pc, #16]	; (800de18 <menuDownListStyle+0xbc>)
 800de06:	2200      	movs	r2, #0
 800de08:	80da      	strh	r2, [r3, #6]


}
 800de0a:	bf00      	nop
 800de0c:	bd98      	pop	{r3, r4, r7, pc}
 800de0e:	bf00      	nop
 800de10:	2000de18 	.word	0x2000de18
 800de14:	20003740 	.word	0x20003740
 800de18:	2000377c 	.word	0x2000377c
 800de1c:	200037b8 	.word	0x200037b8

0800de20 <ledRgbValuesSet>:
/*Set Functions*/
void ledRgbValuesSet(uint8_t *R, uint8_t *G, uint8_t *B) {
 800de20:	b480      	push	{r7}
 800de22:	b085      	sub	sp, #20
 800de24:	af00      	add	r7, sp, #0
 800de26:	60f8      	str	r0, [r7, #12]
 800de28:	60b9      	str	r1, [r7, #8]
 800de2a:	607a      	str	r2, [r7, #4]
	*R=ledRValues;
 800de2c:	4b08      	ldr	r3, [pc, #32]	; (800de50 <ledRgbValuesSet+0x30>)
 800de2e:	781a      	ldrb	r2, [r3, #0]
 800de30:	68fb      	ldr	r3, [r7, #12]
 800de32:	701a      	strb	r2, [r3, #0]
	*G=ledGValues;
 800de34:	4b07      	ldr	r3, [pc, #28]	; (800de54 <ledRgbValuesSet+0x34>)
 800de36:	781a      	ldrb	r2, [r3, #0]
 800de38:	68bb      	ldr	r3, [r7, #8]
 800de3a:	701a      	strb	r2, [r3, #0]
	*B=ledBValues;
 800de3c:	4b06      	ldr	r3, [pc, #24]	; (800de58 <ledRgbValuesSet+0x38>)
 800de3e:	781a      	ldrb	r2, [r3, #0]
 800de40:	687b      	ldr	r3, [r7, #4]
 800de42:	701a      	strb	r2, [r3, #0]
}
 800de44:	bf00      	nop
 800de46:	3714      	adds	r7, #20
 800de48:	46bd      	mov	sp, r7
 800de4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800de4e:	4770      	bx	lr
 800de50:	200037f7 	.word	0x200037f7
 800de54:	200037f8 	.word	0x200037f8
 800de58:	200037f9 	.word	0x200037f9

0800de5c <lv_disp_get_scr_act>:
 * @param disp pointer to display which active screen should be get. (NULL to use the default
 * screen)
 * @return pointer to the active screen object (loaded by 'lv_scr_load()')
 */
lv_obj_t * lv_disp_get_scr_act(lv_disp_t * disp)
{
 800de5c:	b580      	push	{r7, lr}
 800de5e:	b082      	sub	sp, #8
 800de60:	af00      	add	r7, sp, #0
 800de62:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 800de64:	687b      	ldr	r3, [r7, #4]
 800de66:	2b00      	cmp	r3, #0
 800de68:	d102      	bne.n	800de70 <lv_disp_get_scr_act+0x14>
 800de6a:	f00d f92f 	bl	801b0cc <lv_disp_get_default>
 800de6e:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800de70:	687b      	ldr	r3, [r7, #4]
 800de72:	2b00      	cmp	r3, #0
 800de74:	d107      	bne.n	800de86 <lv_disp_get_scr_act+0x2a>
        LV_LOG_WARN("lv_scr_act: no display registered to get its top layer");
 800de76:	4b07      	ldr	r3, [pc, #28]	; (800de94 <lv_disp_get_scr_act+0x38>)
 800de78:	222e      	movs	r2, #46	; 0x2e
 800de7a:	4907      	ldr	r1, [pc, #28]	; (800de98 <lv_disp_get_scr_act+0x3c>)
 800de7c:	2002      	movs	r0, #2
 800de7e:	f00e fcc5 	bl	801c80c <lv_log_add>
        return NULL;
 800de82:	2300      	movs	r3, #0
 800de84:	e001      	b.n	800de8a <lv_disp_get_scr_act+0x2e>
    }

    return disp->act_scr;
 800de86:	687b      	ldr	r3, [r7, #4]
 800de88:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
}
 800de8a:	4618      	mov	r0, r3
 800de8c:	3708      	adds	r7, #8
 800de8e:	46bd      	mov	sp, r7
 800de90:	bd80      	pop	{r7, pc}
 800de92:	bf00      	nop
 800de94:	08028588 	.word	0x08028588
 800de98:	080285c0 	.word	0x080285c0

0800de9c <lv_disp_load_scr>:
/**
 * Make a screen active
 * @param scr pointer to a screen
 */
void lv_disp_load_scr(lv_obj_t * scr)
{
 800de9c:	b580      	push	{r7, lr}
 800de9e:	b084      	sub	sp, #16
 800dea0:	af00      	add	r7, sp, #0
 800dea2:	6078      	str	r0, [r7, #4]
    lv_disp_t * d = lv_obj_get_disp(scr);
 800dea4:	6878      	ldr	r0, [r7, #4]
 800dea6:	f004 f8c5 	bl	8012034 <lv_obj_get_disp>
 800deaa:	60f8      	str	r0, [r7, #12]

    d->act_scr = scr;
 800deac:	68fb      	ldr	r3, [r7, #12]
 800deae:	687a      	ldr	r2, [r7, #4]
 800deb0:	63da      	str	r2, [r3, #60]	; 0x3c

    lv_obj_invalidate(scr);
 800deb2:	6878      	ldr	r0, [r7, #4]
 800deb4:	f002 ffbb 	bl	8010e2e <lv_obj_invalidate>
}
 800deb8:	bf00      	nop
 800deba:	3710      	adds	r7, #16
 800debc:	46bd      	mov	sp, r7
 800debe:	bd80      	pop	{r7, pc}

0800dec0 <lv_disp_get_layer_top>:
 * Return with the top layer. (Same on every screen and it is above the normal screen layer)
 * @param disp pointer to display which top layer should be get. (NULL to use the default screen)
 * @return pointer to the top layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_top(lv_disp_t * disp)
{
 800dec0:	b580      	push	{r7, lr}
 800dec2:	b082      	sub	sp, #8
 800dec4:	af00      	add	r7, sp, #0
 800dec6:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 800dec8:	687b      	ldr	r3, [r7, #4]
 800deca:	2b00      	cmp	r3, #0
 800decc:	d102      	bne.n	800ded4 <lv_disp_get_layer_top+0x14>
 800dece:	f00d f8fd 	bl	801b0cc <lv_disp_get_default>
 800ded2:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800ded4:	687b      	ldr	r3, [r7, #4]
 800ded6:	2b00      	cmp	r3, #0
 800ded8:	d107      	bne.n	800deea <lv_disp_get_layer_top+0x2a>
        LV_LOG_WARN("lv_layer_top: no display registered to get its top layer");
 800deda:	4b07      	ldr	r3, [pc, #28]	; (800def8 <lv_disp_get_layer_top+0x38>)
 800dedc:	224b      	movs	r2, #75	; 0x4b
 800dede:	4907      	ldr	r1, [pc, #28]	; (800defc <lv_disp_get_layer_top+0x3c>)
 800dee0:	2002      	movs	r0, #2
 800dee2:	f00e fc93 	bl	801c80c <lv_log_add>
        return NULL;
 800dee6:	2300      	movs	r3, #0
 800dee8:	e001      	b.n	800deee <lv_disp_get_layer_top+0x2e>
    }

    return disp->top_layer;
 800deea:	687b      	ldr	r3, [r7, #4]
 800deec:	6c1b      	ldr	r3, [r3, #64]	; 0x40
}
 800deee:	4618      	mov	r0, r3
 800def0:	3708      	adds	r7, #8
 800def2:	46bd      	mov	sp, r7
 800def4:	bd80      	pop	{r7, pc}
 800def6:	bf00      	nop
 800def8:	080285e0 	.word	0x080285e0
 800defc:	080285c0 	.word	0x080285c0

0800df00 <lv_disp_get_layer_sys>:
 * layer)
 * @param disp pointer to display which sys. layer  should be get. (NULL to use the default screen)
 * @return pointer to the sys layer object  (transparent screen sized lv_obj)
 */
lv_obj_t * lv_disp_get_layer_sys(lv_disp_t * disp)
{
 800df00:	b580      	push	{r7, lr}
 800df02:	b082      	sub	sp, #8
 800df04:	af00      	add	r7, sp, #0
 800df06:	6078      	str	r0, [r7, #4]
    if(!disp) disp = lv_disp_get_default();
 800df08:	687b      	ldr	r3, [r7, #4]
 800df0a:	2b00      	cmp	r3, #0
 800df0c:	d102      	bne.n	800df14 <lv_disp_get_layer_sys+0x14>
 800df0e:	f00d f8dd 	bl	801b0cc <lv_disp_get_default>
 800df12:	6078      	str	r0, [r7, #4]
    if(!disp) {
 800df14:	687b      	ldr	r3, [r7, #4]
 800df16:	2b00      	cmp	r3, #0
 800df18:	d107      	bne.n	800df2a <lv_disp_get_layer_sys+0x2a>
        LV_LOG_WARN("lv_layer_sys: no display registered to get its top layer");
 800df1a:	4b07      	ldr	r3, [pc, #28]	; (800df38 <lv_disp_get_layer_sys+0x38>)
 800df1c:	225c      	movs	r2, #92	; 0x5c
 800df1e:	4907      	ldr	r1, [pc, #28]	; (800df3c <lv_disp_get_layer_sys+0x3c>)
 800df20:	2002      	movs	r0, #2
 800df22:	f00e fc73 	bl	801c80c <lv_log_add>
        return NULL;
 800df26:	2300      	movs	r3, #0
 800df28:	e001      	b.n	800df2e <lv_disp_get_layer_sys+0x2e>
    }

    return disp->sys_layer;
 800df2a:	687b      	ldr	r3, [r7, #4]
 800df2c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
}
 800df2e:	4618      	mov	r0, r3
 800df30:	3708      	adds	r7, #8
 800df32:	46bd      	mov	sp, r7
 800df34:	bd80      	pop	{r7, pc}
 800df36:	bf00      	nop
 800df38:	0802861c 	.word	0x0802861c
 800df3c:	080285c0 	.word	0x080285c0

0800df40 <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 800df40:	b480      	push	{r7}
 800df42:	b085      	sub	sp, #20
 800df44:	af00      	add	r7, sp, #0
 800df46:	80b8      	strh	r0, [r7, #4]
 800df48:	8039      	strh	r1, [r7, #0]
 800df4a:	4613      	mov	r3, r2
 800df4c:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 800df4e:	797b      	ldrb	r3, [r7, #5]
 800df50:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800df54:	b2db      	uxtb	r3, r3
 800df56:	b29a      	uxth	r2, r3
 800df58:	78fb      	ldrb	r3, [r7, #3]
 800df5a:	b29b      	uxth	r3, r3
 800df5c:	fb12 f303 	smulbb	r3, r2, r3
 800df60:	b29a      	uxth	r2, r3
 800df62:	787b      	ldrb	r3, [r7, #1]
 800df64:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 800df68:	b2db      	uxtb	r3, r3
 800df6a:	b299      	uxth	r1, r3
 800df6c:	78fb      	ldrb	r3, [r7, #3]
 800df6e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800df72:	b29b      	uxth	r3, r3
 800df74:	fb11 f303 	smulbb	r3, r1, r3
 800df78:	b29b      	uxth	r3, r3
 800df7a:	4413      	add	r3, r2
 800df7c:	b29b      	uxth	r3, r3
 800df7e:	0a1b      	lsrs	r3, r3, #8
 800df80:	b29b      	uxth	r3, r3
 800df82:	f003 031f 	and.w	r3, r3, #31
 800df86:	b2da      	uxtb	r2, r3
 800df88:	7b7b      	ldrb	r3, [r7, #13]
 800df8a:	f362 03c7 	bfi	r3, r2, #3, #5
 800df8e:	737b      	strb	r3, [r7, #13]
    uint16_t g_2   = (c2.ch.green_h << 3) + c2.ch.green_l;
    uint16_t g_out = (uint16_t)((uint16_t)g_1 * mix + (g_2 * (255 - mix))) >> 8;
    ret.ch.green_h = g_out >> 3;
    ret.ch.green_l = g_out & 0x7;
#else
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 800df90:	88bb      	ldrh	r3, [r7, #4]
 800df92:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800df96:	b2db      	uxtb	r3, r3
 800df98:	b29a      	uxth	r2, r3
 800df9a:	78fb      	ldrb	r3, [r7, #3]
 800df9c:	b29b      	uxth	r3, r3
 800df9e:	fb12 f303 	smulbb	r3, r2, r3
 800dfa2:	b29a      	uxth	r2, r3
 800dfa4:	883b      	ldrh	r3, [r7, #0]
 800dfa6:	f3c3 1345 	ubfx	r3, r3, #5, #6
 800dfaa:	b2db      	uxtb	r3, r3
 800dfac:	b299      	uxth	r1, r3
 800dfae:	78fb      	ldrb	r3, [r7, #3]
 800dfb0:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800dfb4:	b29b      	uxth	r3, r3
 800dfb6:	fb11 f303 	smulbb	r3, r1, r3
 800dfba:	b29b      	uxth	r3, r3
 800dfbc:	4413      	add	r3, r2
 800dfbe:	b29b      	uxth	r3, r3
 800dfc0:	0a1b      	lsrs	r3, r3, #8
 800dfc2:	b29b      	uxth	r3, r3
 800dfc4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800dfc8:	b2da      	uxtb	r2, r3
 800dfca:	89bb      	ldrh	r3, [r7, #12]
 800dfcc:	f362 134a 	bfi	r3, r2, #5, #6
 800dfd0:	81bb      	strh	r3, [r7, #12]
#endif
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 800dfd2:	793b      	ldrb	r3, [r7, #4]
 800dfd4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800dfd8:	b2db      	uxtb	r3, r3
 800dfda:	b29a      	uxth	r2, r3
 800dfdc:	78fb      	ldrb	r3, [r7, #3]
 800dfde:	b29b      	uxth	r3, r3
 800dfe0:	fb12 f303 	smulbb	r3, r2, r3
 800dfe4:	b29a      	uxth	r2, r3
 800dfe6:	783b      	ldrb	r3, [r7, #0]
 800dfe8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800dfec:	b2db      	uxtb	r3, r3
 800dfee:	b299      	uxth	r1, r3
 800dff0:	78fb      	ldrb	r3, [r7, #3]
 800dff2:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 800dff6:	b29b      	uxth	r3, r3
 800dff8:	fb11 f303 	smulbb	r3, r1, r3
 800dffc:	b29b      	uxth	r3, r3
 800dffe:	4413      	add	r3, r2
 800e000:	b29b      	uxth	r3, r3
 800e002:	0a1b      	lsrs	r3, r3, #8
 800e004:	b29b      	uxth	r3, r3
 800e006:	f003 031f 	and.w	r3, r3, #31
 800e00a:	b2da      	uxtb	r2, r3
 800e00c:	7b3b      	ldrb	r3, [r7, #12]
 800e00e:	f362 0304 	bfi	r3, r2, #0, #5
 800e012:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 800e014:	89bb      	ldrh	r3, [r7, #12]
}
 800e016:	4618      	mov	r0, r3
 800e018:	3714      	adds	r7, #20
 800e01a:	46bd      	mov	sp, r7
 800e01c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e020:	4770      	bx	lr
	...

0800e024 <lv_group_init>:

/**
 * Init. the group module
 */
void lv_group_init(void)
{
 800e024:	b580      	push	{r7, lr}
 800e026:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_group_ll), sizeof(lv_group_t));
 800e028:	2160      	movs	r1, #96	; 0x60
 800e02a:	4802      	ldr	r0, [pc, #8]	; (800e034 <lv_group_init+0x10>)
 800e02c:	f00e f964 	bl	801c2f8 <lv_ll_init>
}
 800e030:	bf00      	nop
 800e032:	bd80      	pop	{r7, pc}
 800e034:	2000df98 	.word	0x2000df98

0800e038 <lv_group_add_obj>:
 * Add an object to a group
 * @param group pointer to a group
 * @param obj pointer to an object to add
 */
void lv_group_add_obj(lv_group_t * group, lv_obj_t * obj)
{
 800e038:	b580      	push	{r7, lr}
 800e03a:	b084      	sub	sp, #16
 800e03c:	af00      	add	r7, sp, #0
 800e03e:	6078      	str	r0, [r7, #4]
 800e040:	6039      	str	r1, [r7, #0]
    if(group == NULL) return;
 800e042:	687b      	ldr	r3, [r7, #4]
 800e044:	2b00      	cmp	r3, #0
 800e046:	d046      	beq.n	800e0d6 <lv_group_add_obj+0x9e>

    /*Do not add the object twice*/
    lv_obj_t ** obj_i;
    LV_LL_READ(group->obj_ll, obj_i)
 800e048:	687b      	ldr	r3, [r7, #4]
 800e04a:	4618      	mov	r0, r3
 800e04c:	f00e fad6 	bl	801c5fc <lv_ll_get_head>
 800e050:	60f8      	str	r0, [r7, #12]
 800e052:	e00a      	b.n	800e06a <lv_group_add_obj+0x32>
    {
        if((*obj_i) == obj) {
 800e054:	68fb      	ldr	r3, [r7, #12]
 800e056:	681b      	ldr	r3, [r3, #0]
 800e058:	683a      	ldr	r2, [r7, #0]
 800e05a:	429a      	cmp	r2, r3
 800e05c:	d03d      	beq.n	800e0da <lv_group_add_obj+0xa2>
    LV_LL_READ(group->obj_ll, obj_i)
 800e05e:	687b      	ldr	r3, [r7, #4]
 800e060:	68f9      	ldr	r1, [r7, #12]
 800e062:	4618      	mov	r0, r3
 800e064:	f00e faf0 	bl	801c648 <lv_ll_get_next>
 800e068:	60f8      	str	r0, [r7, #12]
 800e06a:	68fb      	ldr	r3, [r7, #12]
 800e06c:	2b00      	cmp	r3, #0
 800e06e:	d1f1      	bne.n	800e054 <lv_group_add_obj+0x1c>
            return;
        }
    }

    /*If the object is already in a group and focused then defocus it*/
    if(obj->group_p) {
 800e070:	683b      	ldr	r3, [r7, #0]
 800e072:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e074:	2b00      	cmp	r3, #0
 800e076:	d00a      	beq.n	800e08e <lv_group_add_obj+0x56>
        if(lv_obj_is_focused(obj)) {
 800e078:	6838      	ldr	r0, [r7, #0]
 800e07a:	f004 f9f2 	bl	8012462 <lv_obj_is_focused>
 800e07e:	4603      	mov	r3, r0
 800e080:	2b00      	cmp	r3, #0
 800e082:	d004      	beq.n	800e08e <lv_group_add_obj+0x56>
            lv_group_refocus(obj->group_p);
 800e084:	683b      	ldr	r3, [r7, #0]
 800e086:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e088:	4618      	mov	r0, r3
 800e08a:	f000 fa5b 	bl	800e544 <lv_group_refocus>

            LV_LOG_INFO("lv_group_add_obj: assign object to an other group");
        }
    }

    obj->group_p     = group;
 800e08e:	683b      	ldr	r3, [r7, #0]
 800e090:	687a      	ldr	r2, [r7, #4]
 800e092:	62da      	str	r2, [r3, #44]	; 0x2c
    lv_obj_t ** next = lv_ll_ins_tail(&group->obj_ll);
 800e094:	687b      	ldr	r3, [r7, #4]
 800e096:	4618      	mov	r0, r3
 800e098:	f00e f9c9 	bl	801c42e <lv_ll_ins_tail>
 800e09c:	60b8      	str	r0, [r7, #8]
    lv_mem_assert(next);
 800e09e:	68bb      	ldr	r3, [r7, #8]
 800e0a0:	2b00      	cmp	r3, #0
 800e0a2:	d106      	bne.n	800e0b2 <lv_group_add_obj+0x7a>
 800e0a4:	4b10      	ldr	r3, [pc, #64]	; (800e0e8 <lv_group_add_obj+0xb0>)
 800e0a6:	228d      	movs	r2, #141	; 0x8d
 800e0a8:	4910      	ldr	r1, [pc, #64]	; (800e0ec <lv_group_add_obj+0xb4>)
 800e0aa:	2003      	movs	r0, #3
 800e0ac:	f00e fbae 	bl	801c80c <lv_log_add>
 800e0b0:	e7fe      	b.n	800e0b0 <lv_group_add_obj+0x78>
    if(next == NULL) return;
 800e0b2:	68bb      	ldr	r3, [r7, #8]
 800e0b4:	2b00      	cmp	r3, #0
 800e0b6:	d012      	beq.n	800e0de <lv_group_add_obj+0xa6>
    *next = obj;
 800e0b8:	68bb      	ldr	r3, [r7, #8]
 800e0ba:	683a      	ldr	r2, [r7, #0]
 800e0bc:	601a      	str	r2, [r3, #0]

    /* If the head and the tail is equal then there is only one object in the linked list.
     * In this case automatically activate it*/
    if(lv_ll_get_head(&group->obj_ll) == next) {
 800e0be:	687b      	ldr	r3, [r7, #4]
 800e0c0:	4618      	mov	r0, r3
 800e0c2:	f00e fa9b 	bl	801c5fc <lv_ll_get_head>
 800e0c6:	4602      	mov	r2, r0
 800e0c8:	68bb      	ldr	r3, [r7, #8]
 800e0ca:	4293      	cmp	r3, r2
 800e0cc:	d108      	bne.n	800e0e0 <lv_group_add_obj+0xa8>
        lv_group_refocus(group);
 800e0ce:	6878      	ldr	r0, [r7, #4]
 800e0d0:	f000 fa38 	bl	800e544 <lv_group_refocus>
 800e0d4:	e004      	b.n	800e0e0 <lv_group_add_obj+0xa8>
    if(group == NULL) return;
 800e0d6:	bf00      	nop
 800e0d8:	e002      	b.n	800e0e0 <lv_group_add_obj+0xa8>
            return;
 800e0da:	bf00      	nop
 800e0dc:	e000      	b.n	800e0e0 <lv_group_add_obj+0xa8>
    if(next == NULL) return;
 800e0de:	bf00      	nop
    }
}
 800e0e0:	3710      	adds	r7, #16
 800e0e2:	46bd      	mov	sp, r7
 800e0e4:	bd80      	pop	{r7, pc}
 800e0e6:	bf00      	nop
 800e0e8:	08028728 	.word	0x08028728
 800e0ec:	08028738 	.word	0x08028738

0800e0f0 <lv_group_remove_obj>:
/**
 * Remove an object from its group
 * @param obj pointer to an object to remove
 */
void lv_group_remove_obj(lv_obj_t * obj)
{
 800e0f0:	b580      	push	{r7, lr}
 800e0f2:	b084      	sub	sp, #16
 800e0f4:	af00      	add	r7, sp, #0
 800e0f6:	6078      	str	r0, [r7, #4]
    lv_group_t * g = obj->group_p;
 800e0f8:	687b      	ldr	r3, [r7, #4]
 800e0fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e0fc:	60bb      	str	r3, [r7, #8]
    if(g == NULL) return;
 800e0fe:	68bb      	ldr	r3, [r7, #8]
 800e100:	2b00      	cmp	r3, #0
 800e102:	d053      	beq.n	800e1ac <lv_group_remove_obj+0xbc>
    if(g->obj_focus == NULL) return; /*Just to be sure (Not possible if there is at least one object in the group)*/
 800e104:	68bb      	ldr	r3, [r7, #8]
 800e106:	68db      	ldr	r3, [r3, #12]
 800e108:	2b00      	cmp	r3, #0
 800e10a:	d051      	beq.n	800e1b0 <lv_group_remove_obj+0xc0>

    /*Focus on the next object*/
    if(*g->obj_focus == obj) {
 800e10c:	68bb      	ldr	r3, [r7, #8]
 800e10e:	68db      	ldr	r3, [r3, #12]
 800e110:	681b      	ldr	r3, [r3, #0]
 800e112:	687a      	ldr	r2, [r7, #4]
 800e114:	429a      	cmp	r2, r3
 800e116:	d11f      	bne.n	800e158 <lv_group_remove_obj+0x68>
        /*If this is the only object in the group then focus to nothing.*/
        if(lv_ll_get_head(&g->obj_ll) == g->obj_focus && lv_ll_get_tail(&g->obj_ll) == g->obj_focus) {
 800e118:	68bb      	ldr	r3, [r7, #8]
 800e11a:	4618      	mov	r0, r3
 800e11c:	f00e fa6e 	bl	801c5fc <lv_ll_get_head>
 800e120:	4602      	mov	r2, r0
 800e122:	68bb      	ldr	r3, [r7, #8]
 800e124:	68db      	ldr	r3, [r3, #12]
 800e126:	429a      	cmp	r2, r3
 800e128:	d113      	bne.n	800e152 <lv_group_remove_obj+0x62>
 800e12a:	68bb      	ldr	r3, [r7, #8]
 800e12c:	4618      	mov	r0, r3
 800e12e:	f00e fa78 	bl	801c622 <lv_ll_get_tail>
 800e132:	4602      	mov	r2, r0
 800e134:	68bb      	ldr	r3, [r7, #8]
 800e136:	68db      	ldr	r3, [r3, #12]
 800e138:	429a      	cmp	r2, r3
 800e13a:	d10a      	bne.n	800e152 <lv_group_remove_obj+0x62>
            (*g->obj_focus)->signal_cb(*g->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 800e13c:	68bb      	ldr	r3, [r7, #8]
 800e13e:	68db      	ldr	r3, [r3, #12]
 800e140:	681b      	ldr	r3, [r3, #0]
 800e142:	69db      	ldr	r3, [r3, #28]
 800e144:	68ba      	ldr	r2, [r7, #8]
 800e146:	68d2      	ldr	r2, [r2, #12]
 800e148:	6810      	ldr	r0, [r2, #0]
 800e14a:	2200      	movs	r2, #0
 800e14c:	2110      	movs	r1, #16
 800e14e:	4798      	blx	r3
 800e150:	e002      	b.n	800e158 <lv_group_remove_obj+0x68>
        }
        /*If there more objects in the group then focus to the next/prev object*/
        else {
            lv_group_refocus(g);
 800e152:	68b8      	ldr	r0, [r7, #8]
 800e154:	f000 f9f6 	bl	800e544 <lv_group_refocus>
    }

    /* If the focuses object is still the same then it was the only object in the group but it will
     * be deleted. Set the `obj_focus` to NULL to get back to the initial state of the group with
     * zero objects*/
    if(*g->obj_focus == obj) {
 800e158:	68bb      	ldr	r3, [r7, #8]
 800e15a:	68db      	ldr	r3, [r3, #12]
 800e15c:	681b      	ldr	r3, [r3, #0]
 800e15e:	687a      	ldr	r2, [r7, #4]
 800e160:	429a      	cmp	r2, r3
 800e162:	d102      	bne.n	800e16a <lv_group_remove_obj+0x7a>
        g->obj_focus = NULL;
 800e164:	68bb      	ldr	r3, [r7, #8]
 800e166:	2200      	movs	r2, #0
 800e168:	60da      	str	r2, [r3, #12]
    }

    /*Search the object and remove it from its group */
    lv_obj_t ** i;
    LV_LL_READ(g->obj_ll, i)
 800e16a:	68bb      	ldr	r3, [r7, #8]
 800e16c:	4618      	mov	r0, r3
 800e16e:	f00e fa45 	bl	801c5fc <lv_ll_get_head>
 800e172:	60f8      	str	r0, [r7, #12]
 800e174:	e016      	b.n	800e1a4 <lv_group_remove_obj+0xb4>
    {
        if(*i == obj) {
 800e176:	68fb      	ldr	r3, [r7, #12]
 800e178:	681b      	ldr	r3, [r3, #0]
 800e17a:	687a      	ldr	r2, [r7, #4]
 800e17c:	429a      	cmp	r2, r3
 800e17e:	d10b      	bne.n	800e198 <lv_group_remove_obj+0xa8>
            lv_ll_rem(&g->obj_ll, i);
 800e180:	68bb      	ldr	r3, [r7, #8]
 800e182:	68f9      	ldr	r1, [r7, #12]
 800e184:	4618      	mov	r0, r3
 800e186:	f00e f98b 	bl	801c4a0 <lv_ll_rem>
            lv_mem_free(i);
 800e18a:	68f8      	ldr	r0, [r7, #12]
 800e18c:	f00e fbca 	bl	801c924 <lv_mem_free>
            obj->group_p = NULL;
 800e190:	687b      	ldr	r3, [r7, #4]
 800e192:	2200      	movs	r2, #0
 800e194:	62da      	str	r2, [r3, #44]	; 0x2c
            break;
 800e196:	e00c      	b.n	800e1b2 <lv_group_remove_obj+0xc2>
    LV_LL_READ(g->obj_ll, i)
 800e198:	68bb      	ldr	r3, [r7, #8]
 800e19a:	68f9      	ldr	r1, [r7, #12]
 800e19c:	4618      	mov	r0, r3
 800e19e:	f00e fa53 	bl	801c648 <lv_ll_get_next>
 800e1a2:	60f8      	str	r0, [r7, #12]
 800e1a4:	68fb      	ldr	r3, [r7, #12]
 800e1a6:	2b00      	cmp	r3, #0
 800e1a8:	d1e5      	bne.n	800e176 <lv_group_remove_obj+0x86>
 800e1aa:	e002      	b.n	800e1b2 <lv_group_remove_obj+0xc2>
    if(g == NULL) return;
 800e1ac:	bf00      	nop
 800e1ae:	e000      	b.n	800e1b2 <lv_group_remove_obj+0xc2>
    if(g->obj_focus == NULL) return; /*Just to be sure (Not possible if there is at least one object in the group)*/
 800e1b0:	bf00      	nop
        }
    }
}
 800e1b2:	3710      	adds	r7, #16
 800e1b4:	46bd      	mov	sp, r7
 800e1b6:	bd80      	pop	{r7, pc}

0800e1b8 <lv_group_focus_obj>:
/**
 * Focus on an object (defocus the current)
 * @param obj pointer to an object to focus on
 */
void lv_group_focus_obj(lv_obj_t * obj)
{
 800e1b8:	b580      	push	{r7, lr}
 800e1ba:	b086      	sub	sp, #24
 800e1bc:	af00      	add	r7, sp, #0
 800e1be:	6078      	str	r0, [r7, #4]
    if(obj == NULL) return;
 800e1c0:	687b      	ldr	r3, [r7, #4]
 800e1c2:	2b00      	cmp	r3, #0
 800e1c4:	d07a      	beq.n	800e2bc <lv_group_focus_obj+0x104>
    lv_group_t * g = obj->group_p;
 800e1c6:	687b      	ldr	r3, [r7, #4]
 800e1c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800e1ca:	613b      	str	r3, [r7, #16]
    if(g == NULL) return;
 800e1cc:	693b      	ldr	r3, [r7, #16]
 800e1ce:	2b00      	cmp	r3, #0
 800e1d0:	d076      	beq.n	800e2c0 <lv_group_focus_obj+0x108>

    if(g->frozen != 0) return;
 800e1d2:	693b      	ldr	r3, [r7, #16]
 800e1d4:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e1d8:	f003 0301 	and.w	r3, r3, #1
 800e1dc:	b2db      	uxtb	r3, r3
 800e1de:	2b00      	cmp	r3, #0
 800e1e0:	d170      	bne.n	800e2c4 <lv_group_focus_obj+0x10c>

    /*On defocus edit mode must be leaved*/
    lv_group_set_editing(g, false);
 800e1e2:	2100      	movs	r1, #0
 800e1e4:	6938      	ldr	r0, [r7, #16]
 800e1e6:	f000 f8c8 	bl	800e37a <lv_group_set_editing>

    lv_obj_t ** i;
    LV_LL_READ(g->obj_ll, i)
 800e1ea:	693b      	ldr	r3, [r7, #16]
 800e1ec:	4618      	mov	r0, r3
 800e1ee:	f00e fa05 	bl	801c5fc <lv_ll_get_head>
 800e1f2:	6178      	str	r0, [r7, #20]
 800e1f4:	e05e      	b.n	800e2b4 <lv_group_focus_obj+0xfc>
    {
        if(*i == obj) {
 800e1f6:	697b      	ldr	r3, [r7, #20]
 800e1f8:	681b      	ldr	r3, [r3, #0]
 800e1fa:	687a      	ldr	r2, [r7, #4]
 800e1fc:	429a      	cmp	r2, r3
 800e1fe:	d153      	bne.n	800e2a8 <lv_group_focus_obj+0xf0>
            if(g->obj_focus != NULL) {
 800e200:	693b      	ldr	r3, [r7, #16]
 800e202:	68db      	ldr	r3, [r3, #12]
 800e204:	2b00      	cmp	r3, #0
 800e206:	d01c      	beq.n	800e242 <lv_group_focus_obj+0x8a>
                (*g->obj_focus)->signal_cb(*g->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 800e208:	693b      	ldr	r3, [r7, #16]
 800e20a:	68db      	ldr	r3, [r3, #12]
 800e20c:	681b      	ldr	r3, [r3, #0]
 800e20e:	69db      	ldr	r3, [r3, #28]
 800e210:	693a      	ldr	r2, [r7, #16]
 800e212:	68d2      	ldr	r2, [r2, #12]
 800e214:	6810      	ldr	r0, [r2, #0]
 800e216:	2200      	movs	r2, #0
 800e218:	2110      	movs	r1, #16
 800e21a:	4798      	blx	r3
                lv_res_t res = lv_event_send(*g->obj_focus, LV_EVENT_DEFOCUSED, NULL);
 800e21c:	693b      	ldr	r3, [r7, #16]
 800e21e:	68db      	ldr	r3, [r3, #12]
 800e220:	681b      	ldr	r3, [r3, #0]
 800e222:	2200      	movs	r2, #0
 800e224:	210d      	movs	r1, #13
 800e226:	4618      	mov	r0, r3
 800e228:	f003 fe19 	bl	8011e5e <lv_event_send>
 800e22c:	4603      	mov	r3, r0
 800e22e:	73fb      	strb	r3, [r7, #15]
                if(res != LV_RES_OK) return;
 800e230:	7bfb      	ldrb	r3, [r7, #15]
 800e232:	2b01      	cmp	r3, #1
 800e234:	d148      	bne.n	800e2c8 <lv_group_focus_obj+0x110>
                lv_obj_invalidate(*g->obj_focus);
 800e236:	693b      	ldr	r3, [r7, #16]
 800e238:	68db      	ldr	r3, [r3, #12]
 800e23a:	681b      	ldr	r3, [r3, #0]
 800e23c:	4618      	mov	r0, r3
 800e23e:	f002 fdf6 	bl	8010e2e <lv_obj_invalidate>
            }

            g->obj_focus = i;
 800e242:	693b      	ldr	r3, [r7, #16]
 800e244:	697a      	ldr	r2, [r7, #20]
 800e246:	60da      	str	r2, [r3, #12]

            if(g->obj_focus != NULL) {
 800e248:	693b      	ldr	r3, [r7, #16]
 800e24a:	68db      	ldr	r3, [r3, #12]
 800e24c:	2b00      	cmp	r3, #0
 800e24e:	d03d      	beq.n	800e2cc <lv_group_focus_obj+0x114>
                (*g->obj_focus)->signal_cb(*g->obj_focus, LV_SIGNAL_FOCUS, NULL);
 800e250:	693b      	ldr	r3, [r7, #16]
 800e252:	68db      	ldr	r3, [r3, #12]
 800e254:	681b      	ldr	r3, [r3, #0]
 800e256:	69db      	ldr	r3, [r3, #28]
 800e258:	693a      	ldr	r2, [r7, #16]
 800e25a:	68d2      	ldr	r2, [r2, #12]
 800e25c:	6810      	ldr	r0, [r2, #0]
 800e25e:	2200      	movs	r2, #0
 800e260:	210f      	movs	r1, #15
 800e262:	4798      	blx	r3
                if(g->focus_cb) g->focus_cb(g);
 800e264:	693b      	ldr	r3, [r7, #16]
 800e266:	699b      	ldr	r3, [r3, #24]
 800e268:	2b00      	cmp	r3, #0
 800e26a:	d003      	beq.n	800e274 <lv_group_focus_obj+0xbc>
 800e26c:	693b      	ldr	r3, [r7, #16]
 800e26e:	699b      	ldr	r3, [r3, #24]
 800e270:	6938      	ldr	r0, [r7, #16]
 800e272:	4798      	blx	r3
                lv_res_t res = lv_event_send(*g->obj_focus, LV_EVENT_FOCUSED, NULL);
 800e274:	693b      	ldr	r3, [r7, #16]
 800e276:	68db      	ldr	r3, [r3, #12]
 800e278:	681b      	ldr	r3, [r3, #0]
 800e27a:	2200      	movs	r2, #0
 800e27c:	210c      	movs	r1, #12
 800e27e:	4618      	mov	r0, r3
 800e280:	f003 fded 	bl	8011e5e <lv_event_send>
 800e284:	4603      	mov	r3, r0
 800e286:	73bb      	strb	r3, [r7, #14]
                if(res != LV_RES_OK) return;
 800e288:	7bbb      	ldrb	r3, [r7, #14]
 800e28a:	2b01      	cmp	r3, #1
 800e28c:	d120      	bne.n	800e2d0 <lv_group_focus_obj+0x118>
                lv_obj_invalidate(*g->obj_focus);
 800e28e:	693b      	ldr	r3, [r7, #16]
 800e290:	68db      	ldr	r3, [r3, #12]
 800e292:	681b      	ldr	r3, [r3, #0]
 800e294:	4618      	mov	r0, r3
 800e296:	f002 fdca 	bl	8010e2e <lv_obj_invalidate>

                /*If the object or its parent has `top == true` bring it to the foregorund*/
                obj_to_foreground(*g->obj_focus);
 800e29a:	693b      	ldr	r3, [r7, #16]
 800e29c:	68db      	ldr	r3, [r3, #12]
 800e29e:	681b      	ldr	r3, [r3, #0]
 800e2a0:	4618      	mov	r0, r3
 800e2a2:	f000 fb8a 	bl	800e9ba <obj_to_foreground>
            }
            break;
 800e2a6:	e011      	b.n	800e2cc <lv_group_focus_obj+0x114>
    LV_LL_READ(g->obj_ll, i)
 800e2a8:	693b      	ldr	r3, [r7, #16]
 800e2aa:	6979      	ldr	r1, [r7, #20]
 800e2ac:	4618      	mov	r0, r3
 800e2ae:	f00e f9cb 	bl	801c648 <lv_ll_get_next>
 800e2b2:	6178      	str	r0, [r7, #20]
 800e2b4:	697b      	ldr	r3, [r7, #20]
 800e2b6:	2b00      	cmp	r3, #0
 800e2b8:	d19d      	bne.n	800e1f6 <lv_group_focus_obj+0x3e>
 800e2ba:	e00a      	b.n	800e2d2 <lv_group_focus_obj+0x11a>
    if(obj == NULL) return;
 800e2bc:	bf00      	nop
 800e2be:	e008      	b.n	800e2d2 <lv_group_focus_obj+0x11a>
    if(g == NULL) return;
 800e2c0:	bf00      	nop
 800e2c2:	e006      	b.n	800e2d2 <lv_group_focus_obj+0x11a>
    if(g->frozen != 0) return;
 800e2c4:	bf00      	nop
 800e2c6:	e004      	b.n	800e2d2 <lv_group_focus_obj+0x11a>
                if(res != LV_RES_OK) return;
 800e2c8:	bf00      	nop
 800e2ca:	e002      	b.n	800e2d2 <lv_group_focus_obj+0x11a>
            break;
 800e2cc:	bf00      	nop
 800e2ce:	e000      	b.n	800e2d2 <lv_group_focus_obj+0x11a>
                if(res != LV_RES_OK) return;
 800e2d0:	bf00      	nop
        }
    }
}
 800e2d2:	3718      	adds	r7, #24
 800e2d4:	46bd      	mov	sp, r7
 800e2d6:	bd80      	pop	{r7, pc}

0800e2d8 <lv_group_focus_next>:
/**
 * Focus the next object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_next(lv_group_t * group)
{
 800e2d8:	b580      	push	{r7, lr}
 800e2da:	b082      	sub	sp, #8
 800e2dc:	af00      	add	r7, sp, #0
 800e2de:	6078      	str	r0, [r7, #4]
    focus_next_core(group, lv_ll_get_head, lv_ll_get_next);
 800e2e0:	4a04      	ldr	r2, [pc, #16]	; (800e2f4 <lv_group_focus_next+0x1c>)
 800e2e2:	4905      	ldr	r1, [pc, #20]	; (800e2f8 <lv_group_focus_next+0x20>)
 800e2e4:	6878      	ldr	r0, [r7, #4]
 800e2e6:	f000 faa1 	bl	800e82c <focus_next_core>
}
 800e2ea:	bf00      	nop
 800e2ec:	3708      	adds	r7, #8
 800e2ee:	46bd      	mov	sp, r7
 800e2f0:	bd80      	pop	{r7, pc}
 800e2f2:	bf00      	nop
 800e2f4:	0801c649 	.word	0x0801c649
 800e2f8:	0801c5fd 	.word	0x0801c5fd

0800e2fc <lv_group_focus_prev>:
/**
 * Focus the previous object in a group (defocus the current)
 * @param group pointer to a group
 */
void lv_group_focus_prev(lv_group_t * group)
{
 800e2fc:	b580      	push	{r7, lr}
 800e2fe:	b082      	sub	sp, #8
 800e300:	af00      	add	r7, sp, #0
 800e302:	6078      	str	r0, [r7, #4]
    focus_next_core(group, lv_ll_get_tail, lv_ll_get_prev);
 800e304:	4a04      	ldr	r2, [pc, #16]	; (800e318 <lv_group_focus_prev+0x1c>)
 800e306:	4905      	ldr	r1, [pc, #20]	; (800e31c <lv_group_focus_prev+0x20>)
 800e308:	6878      	ldr	r0, [r7, #4]
 800e30a:	f000 fa8f 	bl	800e82c <focus_next_core>
}
 800e30e:	bf00      	nop
 800e310:	3708      	adds	r7, #8
 800e312:	46bd      	mov	sp, r7
 800e314:	bd80      	pop	{r7, pc}
 800e316:	bf00      	nop
 800e318:	0801c67d 	.word	0x0801c67d
 800e31c:	0801c623 	.word	0x0801c623

0800e320 <lv_group_send_data>:
 * @param group pointer to a group
 * @param c a character (use LV_KEY_.. to navigate)
 * @return result of focused object in group.
 */
lv_res_t lv_group_send_data(lv_group_t * group, uint32_t c)
{
 800e320:	b580      	push	{r7, lr}
 800e322:	b084      	sub	sp, #16
 800e324:	af00      	add	r7, sp, #0
 800e326:	6078      	str	r0, [r7, #4]
 800e328:	6039      	str	r1, [r7, #0]
    lv_obj_t * act = lv_group_get_focused(group);
 800e32a:	6878      	ldr	r0, [r7, #4]
 800e32c:	f000 f896 	bl	800e45c <lv_group_get_focused>
 800e330:	60f8      	str	r0, [r7, #12]
    if(act == NULL) return LV_RES_OK;
 800e332:	68fb      	ldr	r3, [r7, #12]
 800e334:	2b00      	cmp	r3, #0
 800e336:	d101      	bne.n	800e33c <lv_group_send_data+0x1c>
 800e338:	2301      	movs	r3, #1
 800e33a:	e01a      	b.n	800e372 <lv_group_send_data+0x52>

    lv_res_t res;

    res = act->signal_cb(act, LV_SIGNAL_CONTROL, &c);
 800e33c:	68fb      	ldr	r3, [r7, #12]
 800e33e:	69db      	ldr	r3, [r3, #28]
 800e340:	463a      	mov	r2, r7
 800e342:	2111      	movs	r1, #17
 800e344:	68f8      	ldr	r0, [r7, #12]
 800e346:	4798      	blx	r3
 800e348:	4603      	mov	r3, r0
 800e34a:	72fb      	strb	r3, [r7, #11]
    if(res != LV_RES_OK) return res;
 800e34c:	7afb      	ldrb	r3, [r7, #11]
 800e34e:	2b01      	cmp	r3, #1
 800e350:	d001      	beq.n	800e356 <lv_group_send_data+0x36>
 800e352:	7afb      	ldrb	r3, [r7, #11]
 800e354:	e00d      	b.n	800e372 <lv_group_send_data+0x52>

    res = lv_event_send(act, LV_EVENT_KEY, &c);
 800e356:	463b      	mov	r3, r7
 800e358:	461a      	mov	r2, r3
 800e35a:	210b      	movs	r1, #11
 800e35c:	68f8      	ldr	r0, [r7, #12]
 800e35e:	f003 fd7e 	bl	8011e5e <lv_event_send>
 800e362:	4603      	mov	r3, r0
 800e364:	72fb      	strb	r3, [r7, #11]
    if(res != LV_RES_OK) return res;
 800e366:	7afb      	ldrb	r3, [r7, #11]
 800e368:	2b01      	cmp	r3, #1
 800e36a:	d001      	beq.n	800e370 <lv_group_send_data+0x50>
 800e36c:	7afb      	ldrb	r3, [r7, #11]
 800e36e:	e000      	b.n	800e372 <lv_group_send_data+0x52>

    return res;
 800e370:	7afb      	ldrb	r3, [r7, #11]
}
 800e372:	4618      	mov	r0, r3
 800e374:	3710      	adds	r7, #16
 800e376:	46bd      	mov	sp, r7
 800e378:	bd80      	pop	{r7, pc}

0800e37a <lv_group_set_editing>:
 * Manually set the current mode (edit or navigate).
 * @param group pointer to group
 * @param edit: true: edit mode; false: navigate mode
 */
void lv_group_set_editing(lv_group_t * group, bool edit)
{
 800e37a:	b580      	push	{r7, lr}
 800e37c:	b086      	sub	sp, #24
 800e37e:	af00      	add	r7, sp, #0
 800e380:	6078      	str	r0, [r7, #4]
 800e382:	460b      	mov	r3, r1
 800e384:	70fb      	strb	r3, [r7, #3]
    uint8_t en_val = edit ? 1 : 0;
 800e386:	78fb      	ldrb	r3, [r7, #3]
 800e388:	75fb      	strb	r3, [r7, #23]

    if(en_val == group->editing) return; /*Do not set the same mode again*/
 800e38a:	687b      	ldr	r3, [r7, #4]
 800e38c:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e390:	f3c3 0340 	ubfx	r3, r3, #1, #1
 800e394:	b2db      	uxtb	r3, r3
 800e396:	461a      	mov	r2, r3
 800e398:	7dfb      	ldrb	r3, [r7, #23]
 800e39a:	4293      	cmp	r3, r2
 800e39c:	d028      	beq.n	800e3f0 <lv_group_set_editing+0x76>

    group->editing     = en_val;
 800e39e:	7dfb      	ldrb	r3, [r7, #23]
 800e3a0:	f003 0301 	and.w	r3, r3, #1
 800e3a4:	b2d9      	uxtb	r1, r3
 800e3a6:	687a      	ldr	r2, [r7, #4]
 800e3a8:	f892 305c 	ldrb.w	r3, [r2, #92]	; 0x5c
 800e3ac:	f361 0341 	bfi	r3, r1, #1, #1
 800e3b0:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
    lv_obj_t * focused = lv_group_get_focused(group);
 800e3b4:	6878      	ldr	r0, [r7, #4]
 800e3b6:	f000 f851 	bl	800e45c <lv_group_get_focused>
 800e3ba:	6138      	str	r0, [r7, #16]

    if(focused) {
 800e3bc:	693b      	ldr	r3, [r7, #16]
 800e3be:	2b00      	cmp	r3, #0
 800e3c0:	d012      	beq.n	800e3e8 <lv_group_set_editing+0x6e>
        focused->signal_cb(focused, LV_SIGNAL_FOCUS, NULL); /*Focus again to properly leave/open edit/navigate mode*/
 800e3c2:	693b      	ldr	r3, [r7, #16]
 800e3c4:	69db      	ldr	r3, [r3, #28]
 800e3c6:	2200      	movs	r2, #0
 800e3c8:	210f      	movs	r1, #15
 800e3ca:	6938      	ldr	r0, [r7, #16]
 800e3cc:	4798      	blx	r3
        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, NULL);
 800e3ce:	687b      	ldr	r3, [r7, #4]
 800e3d0:	68db      	ldr	r3, [r3, #12]
 800e3d2:	681b      	ldr	r3, [r3, #0]
 800e3d4:	2200      	movs	r2, #0
 800e3d6:	210c      	movs	r1, #12
 800e3d8:	4618      	mov	r0, r3
 800e3da:	f003 fd40 	bl	8011e5e <lv_event_send>
 800e3de:	4603      	mov	r3, r0
 800e3e0:	73fb      	strb	r3, [r7, #15]
        if(res != LV_RES_OK) return;
 800e3e2:	7bfb      	ldrb	r3, [r7, #15]
 800e3e4:	2b01      	cmp	r3, #1
 800e3e6:	d105      	bne.n	800e3f4 <lv_group_set_editing+0x7a>
    }

    lv_obj_invalidate(focused);
 800e3e8:	6938      	ldr	r0, [r7, #16]
 800e3ea:	f002 fd20 	bl	8010e2e <lv_obj_invalidate>
 800e3ee:	e002      	b.n	800e3f6 <lv_group_set_editing+0x7c>
    if(en_val == group->editing) return; /*Do not set the same mode again*/
 800e3f0:	bf00      	nop
 800e3f2:	e000      	b.n	800e3f6 <lv_group_set_editing+0x7c>
        if(res != LV_RES_OK) return;
 800e3f4:	bf00      	nop
}
 800e3f6:	3718      	adds	r7, #24
 800e3f8:	46bd      	mov	sp, r7
 800e3fa:	bd80      	pop	{r7, pc}

0800e3fc <lv_group_mod_style>:
 * @param group pointer to group
 * @param style pointer to a style to modify
 * @return a copy of the input style but modified with the 'style_mod' function
 */
lv_style_t * lv_group_mod_style(lv_group_t * group, const lv_style_t * style)
{
 800e3fc:	b580      	push	{r7, lr}
 800e3fe:	b082      	sub	sp, #8
 800e400:	af00      	add	r7, sp, #0
 800e402:	6078      	str	r0, [r7, #4]
 800e404:	6039      	str	r1, [r7, #0]
    /*Load the current style. It will be modified by the callback*/
    lv_style_copy(&group->style_tmp, style);
 800e406:	687b      	ldr	r3, [r7, #4]
 800e408:	331c      	adds	r3, #28
 800e40a:	6839      	ldr	r1, [r7, #0]
 800e40c:	4618      	mov	r0, r3
 800e40e:	f005 fb29 	bl	8013a64 <lv_style_copy>

    if(group->editing) {
 800e412:	687b      	ldr	r3, [r7, #4]
 800e414:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e418:	f003 0302 	and.w	r3, r3, #2
 800e41c:	b2db      	uxtb	r3, r3
 800e41e:	2b00      	cmp	r3, #0
 800e420:	d00b      	beq.n	800e43a <lv_group_mod_style+0x3e>
        if(group->style_mod_edit_cb) group->style_mod_edit_cb(group, &group->style_tmp);
 800e422:	687b      	ldr	r3, [r7, #4]
 800e424:	695b      	ldr	r3, [r3, #20]
 800e426:	2b00      	cmp	r3, #0
 800e428:	d012      	beq.n	800e450 <lv_group_mod_style+0x54>
 800e42a:	687b      	ldr	r3, [r7, #4]
 800e42c:	695b      	ldr	r3, [r3, #20]
 800e42e:	687a      	ldr	r2, [r7, #4]
 800e430:	321c      	adds	r2, #28
 800e432:	4611      	mov	r1, r2
 800e434:	6878      	ldr	r0, [r7, #4]
 800e436:	4798      	blx	r3
 800e438:	e00a      	b.n	800e450 <lv_group_mod_style+0x54>
    } else {
        if(group->style_mod_cb) group->style_mod_cb(group, &group->style_tmp);
 800e43a:	687b      	ldr	r3, [r7, #4]
 800e43c:	691b      	ldr	r3, [r3, #16]
 800e43e:	2b00      	cmp	r3, #0
 800e440:	d006      	beq.n	800e450 <lv_group_mod_style+0x54>
 800e442:	687b      	ldr	r3, [r7, #4]
 800e444:	691b      	ldr	r3, [r3, #16]
 800e446:	687a      	ldr	r2, [r7, #4]
 800e448:	321c      	adds	r2, #28
 800e44a:	4611      	mov	r1, r2
 800e44c:	6878      	ldr	r0, [r7, #4]
 800e44e:	4798      	blx	r3
    }
    return &group->style_tmp;
 800e450:	687b      	ldr	r3, [r7, #4]
 800e452:	331c      	adds	r3, #28
}
 800e454:	4618      	mov	r0, r3
 800e456:	3708      	adds	r7, #8
 800e458:	46bd      	mov	sp, r7
 800e45a:	bd80      	pop	{r7, pc}

0800e45c <lv_group_get_focused>:
 * Get the focused object or NULL if there isn't one
 * @param group pointer to a group
 * @return pointer to the focused object
 */
lv_obj_t * lv_group_get_focused(const lv_group_t * group)
{
 800e45c:	b480      	push	{r7}
 800e45e:	b083      	sub	sp, #12
 800e460:	af00      	add	r7, sp, #0
 800e462:	6078      	str	r0, [r7, #4]
    if(!group) return NULL;
 800e464:	687b      	ldr	r3, [r7, #4]
 800e466:	2b00      	cmp	r3, #0
 800e468:	d101      	bne.n	800e46e <lv_group_get_focused+0x12>
 800e46a:	2300      	movs	r3, #0
 800e46c:	e008      	b.n	800e480 <lv_group_get_focused+0x24>
    if(group->obj_focus == NULL) return NULL;
 800e46e:	687b      	ldr	r3, [r7, #4]
 800e470:	68db      	ldr	r3, [r3, #12]
 800e472:	2b00      	cmp	r3, #0
 800e474:	d101      	bne.n	800e47a <lv_group_get_focused+0x1e>
 800e476:	2300      	movs	r3, #0
 800e478:	e002      	b.n	800e480 <lv_group_get_focused+0x24>

    return *group->obj_focus;
 800e47a:	687b      	ldr	r3, [r7, #4]
 800e47c:	68db      	ldr	r3, [r3, #12]
 800e47e:	681b      	ldr	r3, [r3, #0]
}
 800e480:	4618      	mov	r0, r3
 800e482:	370c      	adds	r7, #12
 800e484:	46bd      	mov	sp, r7
 800e486:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e48a:	4770      	bx	lr

0800e48c <lv_group_get_editing>:
 * Get the current mode (edit or navigate).
 * @param group pointer to group
 * @return true: edit mode; false: navigate mode
 */
bool lv_group_get_editing(const lv_group_t * group)
{
 800e48c:	b480      	push	{r7}
 800e48e:	b083      	sub	sp, #12
 800e490:	af00      	add	r7, sp, #0
 800e492:	6078      	str	r0, [r7, #4]
    if(!group) return false;
 800e494:	687b      	ldr	r3, [r7, #4]
 800e496:	2b00      	cmp	r3, #0
 800e498:	d101      	bne.n	800e49e <lv_group_get_editing+0x12>
 800e49a:	2300      	movs	r3, #0
 800e49c:	e00b      	b.n	800e4b6 <lv_group_get_editing+0x2a>
    return group->editing ? true : false;
 800e49e:	687b      	ldr	r3, [r7, #4]
 800e4a0:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e4a4:	085b      	lsrs	r3, r3, #1
 800e4a6:	b2db      	uxtb	r3, r3
 800e4a8:	f003 0301 	and.w	r3, r3, #1
 800e4ac:	2b00      	cmp	r3, #0
 800e4ae:	bf14      	ite	ne
 800e4b0:	2301      	movne	r3, #1
 800e4b2:	2300      	moveq	r3, #0
 800e4b4:	b2db      	uxtb	r3, r3
}
 800e4b6:	4618      	mov	r0, r3
 800e4b8:	370c      	adds	r7, #12
 800e4ba:	46bd      	mov	sp, r7
 800e4bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4c0:	4770      	bx	lr

0800e4c2 <lv_group_get_click_focus>:
 * Get the `click_focus` attribute.
 * @param group pointer to group
 * @return true: `click_focus` is enabled; false: disabled
 */
bool lv_group_get_click_focus(const lv_group_t * group)
{
 800e4c2:	b480      	push	{r7}
 800e4c4:	b083      	sub	sp, #12
 800e4c6:	af00      	add	r7, sp, #0
 800e4c8:	6078      	str	r0, [r7, #4]
    if(!group) return false;
 800e4ca:	687b      	ldr	r3, [r7, #4]
 800e4cc:	2b00      	cmp	r3, #0
 800e4ce:	d101      	bne.n	800e4d4 <lv_group_get_click_focus+0x12>
 800e4d0:	2300      	movs	r3, #0
 800e4d2:	e00b      	b.n	800e4ec <lv_group_get_click_focus+0x2a>
    return group->click_focus ? true : false;
 800e4d4:	687b      	ldr	r3, [r7, #4]
 800e4d6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e4da:	089b      	lsrs	r3, r3, #2
 800e4dc:	b2db      	uxtb	r3, r3
 800e4de:	f003 0301 	and.w	r3, r3, #1
 800e4e2:	2b00      	cmp	r3, #0
 800e4e4:	bf14      	ite	ne
 800e4e6:	2301      	movne	r3, #1
 800e4e8:	2300      	moveq	r3, #0
 800e4ea:	b2db      	uxtb	r3, r3
}
 800e4ec:	4618      	mov	r0, r3
 800e4ee:	370c      	adds	r7, #12
 800e4f0:	46bd      	mov	sp, r7
 800e4f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e4f6:	4770      	bx	lr

0800e4f8 <lv_group_report_style_mod>:
 * Notify the group that current theme changed and style modification callbacks need to be
 * refreshed.
 * @param group pointer to group. If NULL then all groups are notified.
 */
void lv_group_report_style_mod(lv_group_t * group)
{
 800e4f8:	b580      	push	{r7, lr}
 800e4fa:	b084      	sub	sp, #16
 800e4fc:	af00      	add	r7, sp, #0
 800e4fe:	6078      	str	r0, [r7, #4]
    lv_theme_t * th = lv_theme_get_current();
 800e500:	f017 fa46 	bl	8025990 <lv_theme_get_current>
 800e504:	60b8      	str	r0, [r7, #8]

    if(group != NULL) {
 800e506:	687b      	ldr	r3, [r7, #4]
 800e508:	2b00      	cmp	r3, #0
 800e50a:	d004      	beq.n	800e516 <lv_group_report_style_mod+0x1e>
        refresh_theme(group, th);
 800e50c:	68b9      	ldr	r1, [r7, #8]
 800e50e:	6878      	ldr	r0, [r7, #4]
 800e510:	f000 f960 	bl	800e7d4 <refresh_theme>
        return;
 800e514:	e010      	b.n	800e538 <lv_group_report_style_mod+0x40>
    }

    lv_group_t * i;
    LV_LL_READ(LV_GC_ROOT(_lv_group_ll), i)
 800e516:	480a      	ldr	r0, [pc, #40]	; (800e540 <lv_group_report_style_mod+0x48>)
 800e518:	f00e f870 	bl	801c5fc <lv_ll_get_head>
 800e51c:	60f8      	str	r0, [r7, #12]
 800e51e:	e008      	b.n	800e532 <lv_group_report_style_mod+0x3a>
    {
        refresh_theme(i, th);
 800e520:	68b9      	ldr	r1, [r7, #8]
 800e522:	68f8      	ldr	r0, [r7, #12]
 800e524:	f000 f956 	bl	800e7d4 <refresh_theme>
    LV_LL_READ(LV_GC_ROOT(_lv_group_ll), i)
 800e528:	68f9      	ldr	r1, [r7, #12]
 800e52a:	4805      	ldr	r0, [pc, #20]	; (800e540 <lv_group_report_style_mod+0x48>)
 800e52c:	f00e f88c 	bl	801c648 <lv_ll_get_next>
 800e530:	60f8      	str	r0, [r7, #12]
 800e532:	68fb      	ldr	r3, [r7, #12]
 800e534:	2b00      	cmp	r3, #0
 800e536:	d1f3      	bne.n	800e520 <lv_group_report_style_mod+0x28>
    }
}
 800e538:	3710      	adds	r7, #16
 800e53a:	46bd      	mov	sp, r7
 800e53c:	bd80      	pop	{r7, pc}
 800e53e:	bf00      	nop
 800e540:	2000df98 	.word	0x2000df98

0800e544 <lv_group_refocus>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void lv_group_refocus(lv_group_t * g)
{
 800e544:	b580      	push	{r7, lr}
 800e546:	b084      	sub	sp, #16
 800e548:	af00      	add	r7, sp, #0
 800e54a:	6078      	str	r0, [r7, #4]
    /*Refocus must temporarily allow wrapping to work correctly*/
    uint8_t temp_wrap = g->wrap;
 800e54c:	687b      	ldr	r3, [r7, #4]
 800e54e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e552:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800e556:	b2db      	uxtb	r3, r3
 800e558:	73fb      	strb	r3, [r7, #15]
    g->wrap           = 1;
 800e55a:	687a      	ldr	r2, [r7, #4]
 800e55c:	f892 305c 	ldrb.w	r3, [r2, #92]	; 0x5c
 800e560:	f043 0310 	orr.w	r3, r3, #16
 800e564:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c

    if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_NEXT)
 800e568:	687b      	ldr	r3, [r7, #4]
 800e56a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e56e:	f003 0308 	and.w	r3, r3, #8
 800e572:	b2db      	uxtb	r3, r3
 800e574:	2b00      	cmp	r3, #0
 800e576:	d103      	bne.n	800e580 <lv_group_refocus+0x3c>
        lv_group_focus_next(g);
 800e578:	6878      	ldr	r0, [r7, #4]
 800e57a:	f7ff fead 	bl	800e2d8 <lv_group_focus_next>
 800e57e:	e00a      	b.n	800e596 <lv_group_refocus+0x52>
    else if(g->refocus_policy == LV_GROUP_REFOCUS_POLICY_PREV)
 800e580:	687b      	ldr	r3, [r7, #4]
 800e582:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e586:	f003 0308 	and.w	r3, r3, #8
 800e58a:	b2db      	uxtb	r3, r3
 800e58c:	2b00      	cmp	r3, #0
 800e58e:	d002      	beq.n	800e596 <lv_group_refocus+0x52>
        lv_group_focus_prev(g);
 800e590:	6878      	ldr	r0, [r7, #4]
 800e592:	f7ff feb3 	bl	800e2fc <lv_group_focus_prev>
    /*Restore wrap property*/
    g->wrap = temp_wrap;
 800e596:	7bfb      	ldrb	r3, [r7, #15]
 800e598:	f003 0301 	and.w	r3, r3, #1
 800e59c:	b2d9      	uxtb	r1, r3
 800e59e:	687a      	ldr	r2, [r7, #4]
 800e5a0:	f892 305c 	ldrb.w	r3, [r2, #92]	; 0x5c
 800e5a4:	f361 1304 	bfi	r3, r1, #4, #1
 800e5a8:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
}
 800e5ac:	bf00      	nop
 800e5ae:	3710      	adds	r7, #16
 800e5b0:	46bd      	mov	sp, r7
 800e5b2:	bd80      	pop	{r7, pc}

0800e5b4 <style_mod_def>:
 * Default style modifier function
 * @param group pointer to the caller group
 * @param style pointer to a style to modify. (Typically group.style_tmp) It will be OVERWRITTEN.
 */
static void style_mod_def(lv_group_t * group, lv_style_t * style)
{
 800e5b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e5b6:	b085      	sub	sp, #20
 800e5b8:	af00      	add	r7, sp, #0
 800e5ba:	60f8      	str	r0, [r7, #12]
 800e5bc:	60b9      	str	r1, [r7, #8]
    (void)group; /*Unused*/
#if LV_COLOR_DEPTH != 1

    /*Make the style to be a little bit orange*/
    style->body.border.opa   = LV_OPA_COVER;
 800e5be:	68ba      	ldr	r2, [r7, #8]
 800e5c0:	21ff      	movs	r1, #255	; 0xff
 800e5c2:	73d1      	strb	r1, [r2, #15]
    style->body.border.color = LV_COLOR_ORANGE;
 800e5c4:	68b9      	ldr	r1, [r7, #8]
 800e5c6:	7a8a      	ldrb	r2, [r1, #10]
 800e5c8:	f36f 0204 	bfc	r2, #0, #5
 800e5cc:	728a      	strb	r2, [r1, #10]
 800e5ce:	68b9      	ldr	r1, [r7, #8]
 800e5d0:	894a      	ldrh	r2, [r1, #10]
 800e5d2:	2029      	movs	r0, #41	; 0x29
 800e5d4:	f360 124a 	bfi	r2, r0, #5, #6
 800e5d8:	814a      	strh	r2, [r1, #10]
 800e5da:	68b9      	ldr	r1, [r7, #8]
 800e5dc:	7aca      	ldrb	r2, [r1, #11]
 800e5de:	f042 02f8 	orr.w	r2, r2, #248	; 0xf8
 800e5e2:	72ca      	strb	r2, [r1, #11]

    /*If not transparent or has border then emphasis the border*/
    if(style->body.opa != LV_OPA_TRANSP || style->body.border.width != 0) style->body.border.width = LV_DPI / 20;
 800e5e4:	68ba      	ldr	r2, [r7, #8]
 800e5e6:	7a12      	ldrb	r2, [r2, #8]
 800e5e8:	2a00      	cmp	r2, #0
 800e5ea:	d104      	bne.n	800e5f6 <style_mod_def+0x42>
 800e5ec:	68ba      	ldr	r2, [r7, #8]
 800e5ee:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
 800e5f2:	2a00      	cmp	r2, #0
 800e5f4:	d002      	beq.n	800e5fc <style_mod_def+0x48>
 800e5f6:	68ba      	ldr	r2, [r7, #8]
 800e5f8:	2105      	movs	r1, #5
 800e5fa:	8191      	strh	r1, [r2, #12]

    style->body.main_color   = lv_color_mix(style->body.main_color, LV_COLOR_ORANGE, LV_OPA_70);
 800e5fc:	f36f 0304 	bfc	r3, #0, #5
 800e600:	2229      	movs	r2, #41	; 0x29
 800e602:	f362 134a 	bfi	r3, r2, #5, #6
 800e606:	f443 4378 	orr.w	r3, r3, #63488	; 0xf800
 800e60a:	68ba      	ldr	r2, [r7, #8]
 800e60c:	607a      	str	r2, [r7, #4]
 800e60e:	68b8      	ldr	r0, [r7, #8]
 800e610:	22b2      	movs	r2, #178	; 0xb2
 800e612:	4619      	mov	r1, r3
 800e614:	8840      	ldrh	r0, [r0, #2]
 800e616:	f7ff fc93 	bl	800df40 <lv_color_mix>
 800e61a:	687a      	ldr	r2, [r7, #4]
 800e61c:	8050      	strh	r0, [r2, #2]
    style->body.grad_color   = lv_color_mix(style->body.grad_color, LV_COLOR_ORANGE, LV_OPA_70);
 800e61e:	f36f 0604 	bfc	r6, #0, #5
 800e622:	2329      	movs	r3, #41	; 0x29
 800e624:	f363 164a 	bfi	r6, r3, #5, #6
 800e628:	4633      	mov	r3, r6
 800e62a:	f443 4378 	orr.w	r3, r3, #63488	; 0xf800
 800e62e:	461e      	mov	r6, r3
 800e630:	68bb      	ldr	r3, [r7, #8]
 800e632:	607b      	str	r3, [r7, #4]
 800e634:	68bb      	ldr	r3, [r7, #8]
 800e636:	22b2      	movs	r2, #178	; 0xb2
 800e638:	4631      	mov	r1, r6
 800e63a:	8898      	ldrh	r0, [r3, #4]
 800e63c:	f7ff fc80 	bl	800df40 <lv_color_mix>
 800e640:	687b      	ldr	r3, [r7, #4]
 800e642:	8098      	strh	r0, [r3, #4]
    style->body.shadow.color = lv_color_mix(style->body.shadow.color, LV_COLOR_ORANGE, LV_OPA_60);
 800e644:	f36f 0504 	bfc	r5, #0, #5
 800e648:	2329      	movs	r3, #41	; 0x29
 800e64a:	f363 154a 	bfi	r5, r3, #5, #6
 800e64e:	462b      	mov	r3, r5
 800e650:	f443 4378 	orr.w	r3, r3, #63488	; 0xf800
 800e654:	461d      	mov	r5, r3
 800e656:	68be      	ldr	r6, [r7, #8]
 800e658:	68bb      	ldr	r3, [r7, #8]
 800e65a:	2299      	movs	r2, #153	; 0x99
 800e65c:	4629      	mov	r1, r5
 800e65e:	8a18      	ldrh	r0, [r3, #16]
 800e660:	f7ff fc6e 	bl	800df40 <lv_color_mix>
 800e664:	8230      	strh	r0, [r6, #16]

    style->text.color = lv_color_mix(style->text.color, LV_COLOR_ORANGE, LV_OPA_70);
 800e666:	f36f 0404 	bfc	r4, #0, #5
 800e66a:	2329      	movs	r3, #41	; 0x29
 800e66c:	f363 144a 	bfi	r4, r3, #5, #6
 800e670:	4623      	mov	r3, r4
 800e672:	f443 4378 	orr.w	r3, r3, #63488	; 0xf800
 800e676:	461c      	mov	r4, r3
 800e678:	68bd      	ldr	r5, [r7, #8]
 800e67a:	68bb      	ldr	r3, [r7, #8]
 800e67c:	22b2      	movs	r2, #178	; 0xb2
 800e67e:	4621      	mov	r1, r4
 800e680:	8c18      	ldrh	r0, [r3, #32]
 800e682:	f7ff fc5d 	bl	800df40 <lv_color_mix>
 800e686:	8428      	strh	r0, [r5, #32]

    /*Add some recolor to the images*/
    if(style->image.intense < LV_OPA_MIN) {
 800e688:	68bb      	ldr	r3, [r7, #8]
 800e68a:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 800e68e:	2b0f      	cmp	r3, #15
 800e690:	d817      	bhi.n	800e6c2 <style_mod_def+0x10e>
        style->image.color   = LV_COLOR_ORANGE;
 800e692:	68ba      	ldr	r2, [r7, #8]
 800e694:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 800e698:	f36f 0304 	bfc	r3, #0, #5
 800e69c:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
 800e6a0:	68ba      	ldr	r2, [r7, #8]
 800e6a2:	8e13      	ldrh	r3, [r2, #48]	; 0x30
 800e6a4:	2129      	movs	r1, #41	; 0x29
 800e6a6:	f361 134a 	bfi	r3, r1, #5, #6
 800e6aa:	8613      	strh	r3, [r2, #48]	; 0x30
 800e6ac:	68ba      	ldr	r2, [r7, #8]
 800e6ae:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 800e6b2:	f043 03f8 	orr.w	r3, r3, #248	; 0xf8
 800e6b6:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        style->image.intense = LV_OPA_40;
 800e6ba:	68bb      	ldr	r3, [r7, #8]
 800e6bc:	2266      	movs	r2, #102	; 0x66
 800e6be:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    style->body.border.opa   = LV_OPA_COVER;
    style->body.border.color = LV_COLOR_BLACK;
    style->body.border.width = 2;

#endif
}
 800e6c2:	bf00      	nop
 800e6c4:	3714      	adds	r7, #20
 800e6c6:	46bd      	mov	sp, r7
 800e6c8:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800e6ca <style_mod_edit_def>:
 * Default style modifier function
 * @param group pointer to the caller group
 * @param style pointer to a style to modify. (Typically group.style_tmp) It will be OVERWRITTEN.
 */
static void style_mod_edit_def(lv_group_t * group, lv_style_t * style)
{
 800e6ca:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e6cc:	b085      	sub	sp, #20
 800e6ce:	af00      	add	r7, sp, #0
 800e6d0:	60f8      	str	r0, [r7, #12]
 800e6d2:	60b9      	str	r1, [r7, #8]
    (void)group; /*Unused*/
#if LV_COLOR_DEPTH != 1

    /*Make the style to be a little bit orange*/
    style->body.border.opa   = LV_OPA_COVER;
 800e6d4:	68ba      	ldr	r2, [r7, #8]
 800e6d6:	21ff      	movs	r1, #255	; 0xff
 800e6d8:	73d1      	strb	r1, [r2, #15]
    style->body.border.color = LV_COLOR_GREEN;
 800e6da:	68b9      	ldr	r1, [r7, #8]
 800e6dc:	7a8a      	ldrb	r2, [r1, #10]
 800e6de:	f36f 0204 	bfc	r2, #0, #5
 800e6e2:	728a      	strb	r2, [r1, #10]
 800e6e4:	68b9      	ldr	r1, [r7, #8]
 800e6e6:	894a      	ldrh	r2, [r1, #10]
 800e6e8:	2020      	movs	r0, #32
 800e6ea:	f360 124a 	bfi	r2, r0, #5, #6
 800e6ee:	814a      	strh	r2, [r1, #10]
 800e6f0:	68b9      	ldr	r1, [r7, #8]
 800e6f2:	7aca      	ldrb	r2, [r1, #11]
 800e6f4:	f36f 02c7 	bfc	r2, #3, #5
 800e6f8:	72ca      	strb	r2, [r1, #11]

    /*If not empty or has border then emphasis the border*/
    if(style->body.opa != LV_OPA_TRANSP || style->body.border.width != 0) style->body.border.width = LV_DPI / 20;
 800e6fa:	68ba      	ldr	r2, [r7, #8]
 800e6fc:	7a12      	ldrb	r2, [r2, #8]
 800e6fe:	2a00      	cmp	r2, #0
 800e700:	d104      	bne.n	800e70c <style_mod_edit_def+0x42>
 800e702:	68ba      	ldr	r2, [r7, #8]
 800e704:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
 800e708:	2a00      	cmp	r2, #0
 800e70a:	d002      	beq.n	800e712 <style_mod_edit_def+0x48>
 800e70c:	68ba      	ldr	r2, [r7, #8]
 800e70e:	2105      	movs	r1, #5
 800e710:	8191      	strh	r1, [r2, #12]

    style->body.main_color   = lv_color_mix(style->body.main_color, LV_COLOR_GREEN, LV_OPA_70);
 800e712:	f36f 0304 	bfc	r3, #0, #5
 800e716:	2220      	movs	r2, #32
 800e718:	f362 134a 	bfi	r3, r2, #5, #6
 800e71c:	f36f 23cf 	bfc	r3, #11, #5
 800e720:	68ba      	ldr	r2, [r7, #8]
 800e722:	607a      	str	r2, [r7, #4]
 800e724:	68b8      	ldr	r0, [r7, #8]
 800e726:	22b2      	movs	r2, #178	; 0xb2
 800e728:	4619      	mov	r1, r3
 800e72a:	8840      	ldrh	r0, [r0, #2]
 800e72c:	f7ff fc08 	bl	800df40 <lv_color_mix>
 800e730:	687a      	ldr	r2, [r7, #4]
 800e732:	8050      	strh	r0, [r2, #2]
    style->body.grad_color   = lv_color_mix(style->body.grad_color, LV_COLOR_GREEN, LV_OPA_70);
 800e734:	f36f 0604 	bfc	r6, #0, #5
 800e738:	2320      	movs	r3, #32
 800e73a:	f363 164a 	bfi	r6, r3, #5, #6
 800e73e:	f36f 26cf 	bfc	r6, #11, #5
 800e742:	68bb      	ldr	r3, [r7, #8]
 800e744:	607b      	str	r3, [r7, #4]
 800e746:	68bb      	ldr	r3, [r7, #8]
 800e748:	22b2      	movs	r2, #178	; 0xb2
 800e74a:	4631      	mov	r1, r6
 800e74c:	8898      	ldrh	r0, [r3, #4]
 800e74e:	f7ff fbf7 	bl	800df40 <lv_color_mix>
 800e752:	687b      	ldr	r3, [r7, #4]
 800e754:	8098      	strh	r0, [r3, #4]
    style->body.shadow.color = lv_color_mix(style->body.shadow.color, LV_COLOR_GREEN, LV_OPA_60);
 800e756:	f36f 0504 	bfc	r5, #0, #5
 800e75a:	2320      	movs	r3, #32
 800e75c:	f363 154a 	bfi	r5, r3, #5, #6
 800e760:	f36f 25cf 	bfc	r5, #11, #5
 800e764:	68be      	ldr	r6, [r7, #8]
 800e766:	68bb      	ldr	r3, [r7, #8]
 800e768:	2299      	movs	r2, #153	; 0x99
 800e76a:	4629      	mov	r1, r5
 800e76c:	8a18      	ldrh	r0, [r3, #16]
 800e76e:	f7ff fbe7 	bl	800df40 <lv_color_mix>
 800e772:	8230      	strh	r0, [r6, #16]

    style->text.color = lv_color_mix(style->text.color, LV_COLOR_GREEN, LV_OPA_70);
 800e774:	f36f 0404 	bfc	r4, #0, #5
 800e778:	2320      	movs	r3, #32
 800e77a:	f363 144a 	bfi	r4, r3, #5, #6
 800e77e:	f36f 24cf 	bfc	r4, #11, #5
 800e782:	68bd      	ldr	r5, [r7, #8]
 800e784:	68bb      	ldr	r3, [r7, #8]
 800e786:	22b2      	movs	r2, #178	; 0xb2
 800e788:	4621      	mov	r1, r4
 800e78a:	8c18      	ldrh	r0, [r3, #32]
 800e78c:	f7ff fbd8 	bl	800df40 <lv_color_mix>
 800e790:	8428      	strh	r0, [r5, #32]

    /*Add some recolor to the images*/
    if(style->image.intense < LV_OPA_MIN) {
 800e792:	68bb      	ldr	r3, [r7, #8]
 800e794:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 800e798:	2b0f      	cmp	r3, #15
 800e79a:	d817      	bhi.n	800e7cc <style_mod_edit_def+0x102>
        style->image.color   = LV_COLOR_GREEN;
 800e79c:	68ba      	ldr	r2, [r7, #8]
 800e79e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 800e7a2:	f36f 0304 	bfc	r3, #0, #5
 800e7a6:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
 800e7aa:	68ba      	ldr	r2, [r7, #8]
 800e7ac:	8e13      	ldrh	r3, [r2, #48]	; 0x30
 800e7ae:	2120      	movs	r1, #32
 800e7b0:	f361 134a 	bfi	r3, r1, #5, #6
 800e7b4:	8613      	strh	r3, [r2, #48]	; 0x30
 800e7b6:	68ba      	ldr	r2, [r7, #8]
 800e7b8:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 800e7bc:	f36f 03c7 	bfc	r3, #3, #5
 800e7c0:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        style->image.intense = LV_OPA_40;
 800e7c4:	68bb      	ldr	r3, [r7, #8]
 800e7c6:	2266      	movs	r2, #102	; 0x66
 800e7c8:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    style->body.border.opa   = LV_OPA_COVER;
    style->body.border.color = LV_COLOR_BLACK;
    style->body.border.width = 3;

#endif
}
 800e7cc:	bf00      	nop
 800e7ce:	3714      	adds	r7, #20
 800e7d0:	46bd      	mov	sp, r7
 800e7d2:	bdf0      	pop	{r4, r5, r6, r7, pc}

0800e7d4 <refresh_theme>:

static void refresh_theme(lv_group_t * g, lv_theme_t * th)
{
 800e7d4:	b480      	push	{r7}
 800e7d6:	b083      	sub	sp, #12
 800e7d8:	af00      	add	r7, sp, #0
 800e7da:	6078      	str	r0, [r7, #4]
 800e7dc:	6039      	str	r1, [r7, #0]
    g->style_mod_cb      = style_mod_def;
 800e7de:	687b      	ldr	r3, [r7, #4]
 800e7e0:	4a10      	ldr	r2, [pc, #64]	; (800e824 <refresh_theme+0x50>)
 800e7e2:	611a      	str	r2, [r3, #16]
    g->style_mod_edit_cb = style_mod_edit_def;
 800e7e4:	687b      	ldr	r3, [r7, #4]
 800e7e6:	4a10      	ldr	r2, [pc, #64]	; (800e828 <refresh_theme+0x54>)
 800e7e8:	615a      	str	r2, [r3, #20]
    if(th) {
 800e7ea:	683b      	ldr	r3, [r7, #0]
 800e7ec:	2b00      	cmp	r3, #0
 800e7ee:	d013      	beq.n	800e818 <refresh_theme+0x44>
        if(th->group.style_mod_xcb) g->style_mod_cb = th->group.style_mod_xcb;
 800e7f0:	683b      	ldr	r3, [r7, #0]
 800e7f2:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
 800e7f6:	2b00      	cmp	r3, #0
 800e7f8:	d004      	beq.n	800e804 <refresh_theme+0x30>
 800e7fa:	683b      	ldr	r3, [r7, #0]
 800e7fc:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
 800e800:	687b      	ldr	r3, [r7, #4]
 800e802:	611a      	str	r2, [r3, #16]
        if(th->group.style_mod_edit_xcb) g->style_mod_edit_cb = th->group.style_mod_edit_xcb;
 800e804:	683b      	ldr	r3, [r7, #0]
 800e806:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
 800e80a:	2b00      	cmp	r3, #0
 800e80c:	d004      	beq.n	800e818 <refresh_theme+0x44>
 800e80e:	683b      	ldr	r3, [r7, #0]
 800e810:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
 800e814:	687b      	ldr	r3, [r7, #4]
 800e816:	615a      	str	r2, [r3, #20]
    }
}
 800e818:	bf00      	nop
 800e81a:	370c      	adds	r7, #12
 800e81c:	46bd      	mov	sp, r7
 800e81e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800e822:	4770      	bx	lr
 800e824:	0800e5b5 	.word	0x0800e5b5
 800e828:	0800e6cb 	.word	0x0800e6cb

0800e82c <focus_next_core>:

static void focus_next_core(lv_group_t * group, void * (*begin)(const lv_ll_t *),
                            void * (*move)(const lv_ll_t *, const void *))
{
 800e82c:	b580      	push	{r7, lr}
 800e82e:	b088      	sub	sp, #32
 800e830:	af00      	add	r7, sp, #0
 800e832:	60f8      	str	r0, [r7, #12]
 800e834:	60b9      	str	r1, [r7, #8]
 800e836:	607a      	str	r2, [r7, #4]
    if(group->frozen) return;
 800e838:	68fb      	ldr	r3, [r7, #12]
 800e83a:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e83e:	f003 0301 	and.w	r3, r3, #1
 800e842:	b2db      	uxtb	r3, r3
 800e844:	2b00      	cmp	r3, #0
 800e846:	f040 80a6 	bne.w	800e996 <focus_next_core+0x16a>

    lv_obj_t ** obj_next     = group->obj_focus;
 800e84a:	68fb      	ldr	r3, [r7, #12]
 800e84c:	68db      	ldr	r3, [r3, #12]
 800e84e:	61fb      	str	r3, [r7, #28]
    lv_obj_t ** obj_sentinel = NULL;
 800e850:	2300      	movs	r3, #0
 800e852:	61bb      	str	r3, [r7, #24]
    bool can_move            = true;
 800e854:	2301      	movs	r3, #1
 800e856:	75fb      	strb	r3, [r7, #23]
    bool can_begin           = true;
 800e858:	2301      	movs	r3, #1
 800e85a:	75bb      	strb	r3, [r7, #22]

    for(;;) {
        if(obj_next == NULL) {
 800e85c:	69fb      	ldr	r3, [r7, #28]
 800e85e:	2b00      	cmp	r3, #0
 800e860:	d11b      	bne.n	800e89a <focus_next_core+0x6e>
            if(group->wrap || obj_sentinel == NULL) {
 800e862:	68fb      	ldr	r3, [r7, #12]
 800e864:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800e868:	f003 0310 	and.w	r3, r3, #16
 800e86c:	b2db      	uxtb	r3, r3
 800e86e:	2b00      	cmp	r3, #0
 800e870:	d103      	bne.n	800e87a <focus_next_core+0x4e>
 800e872:	69bb      	ldr	r3, [r7, #24]
 800e874:	2b00      	cmp	r3, #0
 800e876:	f040 8090 	bne.w	800e99a <focus_next_core+0x16e>
                if(!can_begin) return;
 800e87a:	7dbb      	ldrb	r3, [r7, #22]
 800e87c:	f083 0301 	eor.w	r3, r3, #1
 800e880:	b2db      	uxtb	r3, r3
 800e882:	2b00      	cmp	r3, #0
 800e884:	f040 808b 	bne.w	800e99e <focus_next_core+0x172>
                obj_next  = begin(&group->obj_ll);
 800e888:	68fa      	ldr	r2, [r7, #12]
 800e88a:	68bb      	ldr	r3, [r7, #8]
 800e88c:	4610      	mov	r0, r2
 800e88e:	4798      	blx	r3
 800e890:	61f8      	str	r0, [r7, #28]
                can_move  = false;
 800e892:	2300      	movs	r3, #0
 800e894:	75fb      	strb	r3, [r7, #23]
                can_begin = false;
 800e896:	2300      	movs	r3, #0
 800e898:	75bb      	strb	r3, [r7, #22]
                /*Currently focused object is the last/first in the group, keep it that way*/
                return;
            }
        }

        if(obj_sentinel == NULL) {
 800e89a:	69bb      	ldr	r3, [r7, #24]
 800e89c:	2b00      	cmp	r3, #0
 800e89e:	d104      	bne.n	800e8aa <focus_next_core+0x7e>
            obj_sentinel = obj_next;
 800e8a0:	69fb      	ldr	r3, [r7, #28]
 800e8a2:	61bb      	str	r3, [r7, #24]
            if(obj_sentinel == NULL) return; /*Group is empty*/
 800e8a4:	69bb      	ldr	r3, [r7, #24]
 800e8a6:	2b00      	cmp	r3, #0
 800e8a8:	d07b      	beq.n	800e9a2 <focus_next_core+0x176>
        }

        if(can_move) {
 800e8aa:	7dfb      	ldrb	r3, [r7, #23]
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	d009      	beq.n	800e8c4 <focus_next_core+0x98>
            obj_next = move(&group->obj_ll, obj_next);
 800e8b0:	68fa      	ldr	r2, [r7, #12]
 800e8b2:	687b      	ldr	r3, [r7, #4]
 800e8b4:	69f9      	ldr	r1, [r7, #28]
 800e8b6:	4610      	mov	r0, r2
 800e8b8:	4798      	blx	r3
 800e8ba:	61f8      	str	r0, [r7, #28]

            /*Give up if we walked the entire list and haven't found another visible object*/
            if(obj_next == obj_sentinel) return;
 800e8bc:	69fa      	ldr	r2, [r7, #28]
 800e8be:	69bb      	ldr	r3, [r7, #24]
 800e8c0:	429a      	cmp	r2, r3
 800e8c2:	d070      	beq.n	800e9a6 <focus_next_core+0x17a>
        }

        can_move = true;
 800e8c4:	2301      	movs	r3, #1
 800e8c6:	75fb      	strb	r3, [r7, #23]

        if(obj_next == NULL) continue;
 800e8c8:	69fb      	ldr	r3, [r7, #28]
 800e8ca:	2b00      	cmp	r3, #0
 800e8cc:	d00b      	beq.n	800e8e6 <focus_next_core+0xba>

        /*Hidden objects don't receive focus*/
        if(!lv_obj_get_hidden(*obj_next)) break;
 800e8ce:	69fb      	ldr	r3, [r7, #28]
 800e8d0:	681b      	ldr	r3, [r3, #0]
 800e8d2:	4618      	mov	r0, r3
 800e8d4:	f003 fce6 	bl	80122a4 <lv_obj_get_hidden>
 800e8d8:	4603      	mov	r3, r0
 800e8da:	f083 0301 	eor.w	r3, r3, #1
 800e8de:	b2db      	uxtb	r3, r3
 800e8e0:	2b00      	cmp	r3, #0
 800e8e2:	d102      	bne.n	800e8ea <focus_next_core+0xbe>
 800e8e4:	e7ba      	b.n	800e85c <focus_next_core+0x30>
        if(obj_next == NULL) continue;
 800e8e6:	bf00      	nop
        if(obj_next == NULL) {
 800e8e8:	e7b8      	b.n	800e85c <focus_next_core+0x30>
        if(!lv_obj_get_hidden(*obj_next)) break;
 800e8ea:	bf00      	nop
    }

    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 800e8ec:	68fb      	ldr	r3, [r7, #12]
 800e8ee:	68db      	ldr	r3, [r3, #12]
 800e8f0:	69fa      	ldr	r2, [r7, #28]
 800e8f2:	429a      	cmp	r2, r3
 800e8f4:	d059      	beq.n	800e9aa <focus_next_core+0x17e>

    if(group->obj_focus) {
 800e8f6:	68fb      	ldr	r3, [r7, #12]
 800e8f8:	68db      	ldr	r3, [r3, #12]
 800e8fa:	2b00      	cmp	r3, #0
 800e8fc:	d01c      	beq.n	800e938 <focus_next_core+0x10c>
        (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_DEFOCUS, NULL);
 800e8fe:	68fb      	ldr	r3, [r7, #12]
 800e900:	68db      	ldr	r3, [r3, #12]
 800e902:	681b      	ldr	r3, [r3, #0]
 800e904:	69db      	ldr	r3, [r3, #28]
 800e906:	68fa      	ldr	r2, [r7, #12]
 800e908:	68d2      	ldr	r2, [r2, #12]
 800e90a:	6810      	ldr	r0, [r2, #0]
 800e90c:	2200      	movs	r2, #0
 800e90e:	2110      	movs	r1, #16
 800e910:	4798      	blx	r3
        lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_DEFOCUSED, NULL);
 800e912:	68fb      	ldr	r3, [r7, #12]
 800e914:	68db      	ldr	r3, [r3, #12]
 800e916:	681b      	ldr	r3, [r3, #0]
 800e918:	2200      	movs	r2, #0
 800e91a:	210d      	movs	r1, #13
 800e91c:	4618      	mov	r0, r3
 800e91e:	f003 fa9e 	bl	8011e5e <lv_event_send>
 800e922:	4603      	mov	r3, r0
 800e924:	757b      	strb	r3, [r7, #21]
        if(res != LV_RES_OK) return;
 800e926:	7d7b      	ldrb	r3, [r7, #21]
 800e928:	2b01      	cmp	r3, #1
 800e92a:	d140      	bne.n	800e9ae <focus_next_core+0x182>
        lv_obj_invalidate(*group->obj_focus);
 800e92c:	68fb      	ldr	r3, [r7, #12]
 800e92e:	68db      	ldr	r3, [r3, #12]
 800e930:	681b      	ldr	r3, [r3, #0]
 800e932:	4618      	mov	r0, r3
 800e934:	f002 fa7b 	bl	8010e2e <lv_obj_invalidate>
    }

    group->obj_focus = obj_next;
 800e938:	68fb      	ldr	r3, [r7, #12]
 800e93a:	69fa      	ldr	r2, [r7, #28]
 800e93c:	60da      	str	r2, [r3, #12]

    (*group->obj_focus)->signal_cb(*group->obj_focus, LV_SIGNAL_FOCUS, NULL);
 800e93e:	68fb      	ldr	r3, [r7, #12]
 800e940:	68db      	ldr	r3, [r3, #12]
 800e942:	681b      	ldr	r3, [r3, #0]
 800e944:	69db      	ldr	r3, [r3, #28]
 800e946:	68fa      	ldr	r2, [r7, #12]
 800e948:	68d2      	ldr	r2, [r2, #12]
 800e94a:	6810      	ldr	r0, [r2, #0]
 800e94c:	2200      	movs	r2, #0
 800e94e:	210f      	movs	r1, #15
 800e950:	4798      	blx	r3
    lv_res_t res = lv_event_send(*group->obj_focus, LV_EVENT_FOCUSED, NULL);
 800e952:	68fb      	ldr	r3, [r7, #12]
 800e954:	68db      	ldr	r3, [r3, #12]
 800e956:	681b      	ldr	r3, [r3, #0]
 800e958:	2200      	movs	r2, #0
 800e95a:	210c      	movs	r1, #12
 800e95c:	4618      	mov	r0, r3
 800e95e:	f003 fa7e 	bl	8011e5e <lv_event_send>
 800e962:	4603      	mov	r3, r0
 800e964:	753b      	strb	r3, [r7, #20]
    if(res != LV_RES_OK) return;
 800e966:	7d3b      	ldrb	r3, [r7, #20]
 800e968:	2b01      	cmp	r3, #1
 800e96a:	d122      	bne.n	800e9b2 <focus_next_core+0x186>

    /*If the object or its parent has `top == true` bring it to the foregorund*/
    obj_to_foreground(*group->obj_focus);
 800e96c:	68fb      	ldr	r3, [r7, #12]
 800e96e:	68db      	ldr	r3, [r3, #12]
 800e970:	681b      	ldr	r3, [r3, #0]
 800e972:	4618      	mov	r0, r3
 800e974:	f000 f821 	bl	800e9ba <obj_to_foreground>

    lv_obj_invalidate(*group->obj_focus);
 800e978:	68fb      	ldr	r3, [r7, #12]
 800e97a:	68db      	ldr	r3, [r3, #12]
 800e97c:	681b      	ldr	r3, [r3, #0]
 800e97e:	4618      	mov	r0, r3
 800e980:	f002 fa55 	bl	8010e2e <lv_obj_invalidate>

    if(group->focus_cb) group->focus_cb(group);
 800e984:	68fb      	ldr	r3, [r7, #12]
 800e986:	699b      	ldr	r3, [r3, #24]
 800e988:	2b00      	cmp	r3, #0
 800e98a:	d013      	beq.n	800e9b4 <focus_next_core+0x188>
 800e98c:	68fb      	ldr	r3, [r7, #12]
 800e98e:	699b      	ldr	r3, [r3, #24]
 800e990:	68f8      	ldr	r0, [r7, #12]
 800e992:	4798      	blx	r3
 800e994:	e00e      	b.n	800e9b4 <focus_next_core+0x188>
    if(group->frozen) return;
 800e996:	bf00      	nop
 800e998:	e00c      	b.n	800e9b4 <focus_next_core+0x188>
                return;
 800e99a:	bf00      	nop
 800e99c:	e00a      	b.n	800e9b4 <focus_next_core+0x188>
                if(!can_begin) return;
 800e99e:	bf00      	nop
 800e9a0:	e008      	b.n	800e9b4 <focus_next_core+0x188>
            if(obj_sentinel == NULL) return; /*Group is empty*/
 800e9a2:	bf00      	nop
 800e9a4:	e006      	b.n	800e9b4 <focus_next_core+0x188>
            if(obj_next == obj_sentinel) return;
 800e9a6:	bf00      	nop
 800e9a8:	e004      	b.n	800e9b4 <focus_next_core+0x188>
    if(obj_next == group->obj_focus) return; /*There's only one visible object and it's already focused*/
 800e9aa:	bf00      	nop
 800e9ac:	e002      	b.n	800e9b4 <focus_next_core+0x188>
        if(res != LV_RES_OK) return;
 800e9ae:	bf00      	nop
 800e9b0:	e000      	b.n	800e9b4 <focus_next_core+0x188>
    if(res != LV_RES_OK) return;
 800e9b2:	bf00      	nop
}
 800e9b4:	3720      	adds	r7, #32
 800e9b6:	46bd      	mov	sp, r7
 800e9b8:	bd80      	pop	{r7, pc}

0800e9ba <obj_to_foreground>:

static void obj_to_foreground(lv_obj_t * obj)
{
 800e9ba:	b580      	push	{r7, lr}
 800e9bc:	b084      	sub	sp, #16
 800e9be:	af00      	add	r7, sp, #0
 800e9c0:	6078      	str	r0, [r7, #4]
    /*Search for 'top' attribute*/
    lv_obj_t * i        = obj;
 800e9c2:	687b      	ldr	r3, [r7, #4]
 800e9c4:	60fb      	str	r3, [r7, #12]
    lv_obj_t * last_top = NULL;
 800e9c6:	2300      	movs	r3, #0
 800e9c8:	60bb      	str	r3, [r7, #8]
    while(i != NULL) {
 800e9ca:	e00d      	b.n	800e9e8 <obj_to_foreground+0x2e>
        if(i->top != 0) last_top = i;
 800e9cc:	68fb      	ldr	r3, [r7, #12]
 800e9ce:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800e9d2:	f003 0320 	and.w	r3, r3, #32
 800e9d6:	b2db      	uxtb	r3, r3
 800e9d8:	2b00      	cmp	r3, #0
 800e9da:	d001      	beq.n	800e9e0 <obj_to_foreground+0x26>
 800e9dc:	68fb      	ldr	r3, [r7, #12]
 800e9de:	60bb      	str	r3, [r7, #8]
        i = lv_obj_get_parent(i);
 800e9e0:	68f8      	ldr	r0, [r7, #12]
 800e9e2:	f003 fb6d 	bl	80120c0 <lv_obj_get_parent>
 800e9e6:	60f8      	str	r0, [r7, #12]
    while(i != NULL) {
 800e9e8:	68fb      	ldr	r3, [r7, #12]
 800e9ea:	2b00      	cmp	r3, #0
 800e9ec:	d1ee      	bne.n	800e9cc <obj_to_foreground+0x12>
    }

    if(last_top != NULL) {
 800e9ee:	68bb      	ldr	r3, [r7, #8]
 800e9f0:	2b00      	cmp	r3, #0
 800e9f2:	d002      	beq.n	800e9fa <obj_to_foreground+0x40>
        /*Move the last_top object to the foreground*/
        lv_obj_move_foreground(last_top);
 800e9f4:	68b8      	ldr	r0, [r7, #8]
 800e9f6:	f002 fb01 	bl	8010ffc <lv_obj_move_foreground>
    }
}
 800e9fa:	bf00      	nop
 800e9fc:	3710      	adds	r7, #16
 800e9fe:	46bd      	mov	sp, r7
 800ea00:	bd80      	pop	{r7, pc}

0800ea02 <lv_indev_init>:

/**
 * Initialize the display input device subsystem
 */
void lv_indev_init(void)
{
 800ea02:	b580      	push	{r7, lr}
 800ea04:	af00      	add	r7, sp, #0
    lv_indev_reset(NULL); /*Reset all input devices*/
 800ea06:	2000      	movs	r0, #0
 800ea08:	f000 f8c3 	bl	800eb92 <lv_indev_reset>
}
 800ea0c:	bf00      	nop
 800ea0e:	bd80      	pop	{r7, pc}

0800ea10 <lv_indev_read_task>:
/**
 * Called periodically to read the input devices
 * @param param pointer to and input device to read
 */
void lv_indev_read_task(lv_task_t * task)
{
 800ea10:	b590      	push	{r4, r7, lr}
 800ea12:	b089      	sub	sp, #36	; 0x24
 800ea14:	af00      	add	r7, sp, #0
 800ea16:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("indev read task started");

    lv_indev_data_t data;

    indev_act = task->user_data;
 800ea18:	687b      	ldr	r3, [r7, #4]
 800ea1a:	68db      	ldr	r3, [r3, #12]
 800ea1c:	4a4c      	ldr	r2, [pc, #304]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea1e:	6013      	str	r3, [r2, #0]

    /*Read and process all indevs*/
    if(indev_act->driver.disp == NULL) return; /*Not assigned to any displays*/
 800ea20:	4b4b      	ldr	r3, [pc, #300]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea22:	681b      	ldr	r3, [r3, #0]
 800ea24:	691b      	ldr	r3, [r3, #16]
 800ea26:	2b00      	cmp	r3, #0
 800ea28:	f000 808b 	beq.w	800eb42 <lv_indev_read_task+0x132>

    /*Handle reset query before processing the point*/
    indev_proc_reset_query_handler(indev_act);
 800ea2c:	4b48      	ldr	r3, [pc, #288]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea2e:	681b      	ldr	r3, [r3, #0]
 800ea30:	4618      	mov	r0, r3
 800ea32:	f001 fa93 	bl	800ff5c <indev_proc_reset_query_handler>

    if(indev_act->proc.disabled) return;
 800ea36:	4b46      	ldr	r3, [pc, #280]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea38:	681b      	ldr	r3, [r3, #0]
 800ea3a:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800ea3e:	f003 0304 	and.w	r3, r3, #4
 800ea42:	b2db      	uxtb	r3, r3
 800ea44:	2b00      	cmp	r3, #0
 800ea46:	d17e      	bne.n	800eb46 <lv_indev_read_task+0x136>
    bool more_to_read;
    do {
        /*Read the data*/
        more_to_read = lv_indev_read(indev_act, &data);
 800ea48:	4b41      	ldr	r3, [pc, #260]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea4a:	681b      	ldr	r3, [r3, #0]
 800ea4c:	f107 020c 	add.w	r2, r7, #12
 800ea50:	4611      	mov	r1, r2
 800ea52:	4618      	mov	r0, r3
 800ea54:	f00c fcea 	bl	801b42c <lv_indev_read>
 800ea58:	4603      	mov	r3, r0
 800ea5a:	77fb      	strb	r3, [r7, #31]

        /*The active object might deleted even in the read function*/
        indev_proc_reset_query_handler(indev_act);
 800ea5c:	4b3c      	ldr	r3, [pc, #240]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea5e:	681b      	ldr	r3, [r3, #0]
 800ea60:	4618      	mov	r0, r3
 800ea62:	f001 fa7b 	bl	800ff5c <indev_proc_reset_query_handler>
        indev_obj_act = NULL;
 800ea66:	4b3b      	ldr	r3, [pc, #236]	; (800eb54 <lv_indev_read_task+0x144>)
 800ea68:	2200      	movs	r2, #0
 800ea6a:	601a      	str	r2, [r3, #0]

        indev_act->proc.state = data.state;
 800ea6c:	4b38      	ldr	r3, [pc, #224]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea6e:	681b      	ldr	r3, [r3, #0]
 800ea70:	7eba      	ldrb	r2, [r7, #26]
 800ea72:	f883 2020 	strb.w	r2, [r3, #32]

        /*Save the last activity time*/
        if(indev_act->proc.state == LV_INDEV_STATE_PR) {
 800ea76:	4b36      	ldr	r3, [pc, #216]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea78:	681b      	ldr	r3, [r3, #0]
 800ea7a:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ea7e:	2b01      	cmp	r3, #1
 800ea80:	d108      	bne.n	800ea94 <lv_indev_read_task+0x84>
            indev_act->driver.disp->last_activity_time = lv_tick_get();
 800ea82:	4b33      	ldr	r3, [pc, #204]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea84:	681b      	ldr	r3, [r3, #0]
 800ea86:	691c      	ldr	r4, [r3, #16]
 800ea88:	f00c fd10 	bl	801b4ac <lv_tick_get>
 800ea8c:	4603      	mov	r3, r0
 800ea8e:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
 800ea92:	e010      	b.n	800eab6 <lv_indev_read_task+0xa6>
        } else if(indev_act->driver.type == LV_INDEV_TYPE_ENCODER && data.enc_diff) {
 800ea94:	4b2e      	ldr	r3, [pc, #184]	; (800eb50 <lv_indev_read_task+0x140>)
 800ea96:	681b      	ldr	r3, [r3, #0]
 800ea98:	781b      	ldrb	r3, [r3, #0]
 800ea9a:	2b04      	cmp	r3, #4
 800ea9c:	d10b      	bne.n	800eab6 <lv_indev_read_task+0xa6>
 800ea9e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 800eaa2:	2b00      	cmp	r3, #0
 800eaa4:	d007      	beq.n	800eab6 <lv_indev_read_task+0xa6>
            indev_act->driver.disp->last_activity_time = lv_tick_get();
 800eaa6:	4b2a      	ldr	r3, [pc, #168]	; (800eb50 <lv_indev_read_task+0x140>)
 800eaa8:	681b      	ldr	r3, [r3, #0]
 800eaaa:	691c      	ldr	r4, [r3, #16]
 800eaac:	f00c fcfe 	bl	801b4ac <lv_tick_get>
 800eab0:	4603      	mov	r3, r0
 800eab2:	f8c4 316c 	str.w	r3, [r4, #364]	; 0x16c
        }

        if(indev_act->driver.type == LV_INDEV_TYPE_POINTER) {
 800eab6:	4b26      	ldr	r3, [pc, #152]	; (800eb50 <lv_indev_read_task+0x140>)
 800eab8:	681b      	ldr	r3, [r3, #0]
 800eaba:	781b      	ldrb	r3, [r3, #0]
 800eabc:	2b01      	cmp	r3, #1
 800eabe:	d108      	bne.n	800ead2 <lv_indev_read_task+0xc2>
            indev_pointer_proc(indev_act, &data);
 800eac0:	4b23      	ldr	r3, [pc, #140]	; (800eb50 <lv_indev_read_task+0x140>)
 800eac2:	681b      	ldr	r3, [r3, #0]
 800eac4:	f107 020c 	add.w	r2, r7, #12
 800eac8:	4611      	mov	r1, r2
 800eaca:	4618      	mov	r0, r3
 800eacc:	f000 f90a 	bl	800ece4 <indev_pointer_proc>
 800ead0:	e028      	b.n	800eb24 <lv_indev_read_task+0x114>
        } else if(indev_act->driver.type == LV_INDEV_TYPE_KEYPAD) {
 800ead2:	4b1f      	ldr	r3, [pc, #124]	; (800eb50 <lv_indev_read_task+0x140>)
 800ead4:	681b      	ldr	r3, [r3, #0]
 800ead6:	781b      	ldrb	r3, [r3, #0]
 800ead8:	2b02      	cmp	r3, #2
 800eada:	d108      	bne.n	800eaee <lv_indev_read_task+0xde>
            indev_keypad_proc(indev_act, &data);
 800eadc:	4b1c      	ldr	r3, [pc, #112]	; (800eb50 <lv_indev_read_task+0x140>)
 800eade:	681b      	ldr	r3, [r3, #0]
 800eae0:	f107 020c 	add.w	r2, r7, #12
 800eae4:	4611      	mov	r1, r2
 800eae6:	4618      	mov	r0, r3
 800eae8:	f000 f948 	bl	800ed7c <indev_keypad_proc>
 800eaec:	e01a      	b.n	800eb24 <lv_indev_read_task+0x114>
        } else if(indev_act->driver.type == LV_INDEV_TYPE_ENCODER) {
 800eaee:	4b18      	ldr	r3, [pc, #96]	; (800eb50 <lv_indev_read_task+0x140>)
 800eaf0:	681b      	ldr	r3, [r3, #0]
 800eaf2:	781b      	ldrb	r3, [r3, #0]
 800eaf4:	2b04      	cmp	r3, #4
 800eaf6:	d108      	bne.n	800eb0a <lv_indev_read_task+0xfa>
            indev_encoder_proc(indev_act, &data);
 800eaf8:	4b15      	ldr	r3, [pc, #84]	; (800eb50 <lv_indev_read_task+0x140>)
 800eafa:	681b      	ldr	r3, [r3, #0]
 800eafc:	f107 020c 	add.w	r2, r7, #12
 800eb00:	4611      	mov	r1, r2
 800eb02:	4618      	mov	r0, r3
 800eb04:	f000 fb52 	bl	800f1ac <indev_encoder_proc>
 800eb08:	e00c      	b.n	800eb24 <lv_indev_read_task+0x114>
        } else if(indev_act->driver.type == LV_INDEV_TYPE_BUTTON) {
 800eb0a:	4b11      	ldr	r3, [pc, #68]	; (800eb50 <lv_indev_read_task+0x140>)
 800eb0c:	681b      	ldr	r3, [r3, #0]
 800eb0e:	781b      	ldrb	r3, [r3, #0]
 800eb10:	2b03      	cmp	r3, #3
 800eb12:	d107      	bne.n	800eb24 <lv_indev_read_task+0x114>
            indev_button_proc(indev_act, &data);
 800eb14:	4b0e      	ldr	r3, [pc, #56]	; (800eb50 <lv_indev_read_task+0x140>)
 800eb16:	681b      	ldr	r3, [r3, #0]
 800eb18:	f107 020c 	add.w	r2, r7, #12
 800eb1c:	4611      	mov	r1, r2
 800eb1e:	4618      	mov	r0, r3
 800eb20:	f000 fdb8 	bl	800f694 <indev_button_proc>
        }
        /*Handle reset query if it happened in during processing*/
        indev_proc_reset_query_handler(indev_act);
 800eb24:	4b0a      	ldr	r3, [pc, #40]	; (800eb50 <lv_indev_read_task+0x140>)
 800eb26:	681b      	ldr	r3, [r3, #0]
 800eb28:	4618      	mov	r0, r3
 800eb2a:	f001 fa17 	bl	800ff5c <indev_proc_reset_query_handler>
    } while(more_to_read);
 800eb2e:	7ffb      	ldrb	r3, [r7, #31]
 800eb30:	2b00      	cmp	r3, #0
 800eb32:	d189      	bne.n	800ea48 <lv_indev_read_task+0x38>

    /*End of indev processing, so no act indev*/
    indev_act     = NULL;
 800eb34:	4b06      	ldr	r3, [pc, #24]	; (800eb50 <lv_indev_read_task+0x140>)
 800eb36:	2200      	movs	r2, #0
 800eb38:	601a      	str	r2, [r3, #0]
    indev_obj_act = NULL;
 800eb3a:	4b06      	ldr	r3, [pc, #24]	; (800eb54 <lv_indev_read_task+0x144>)
 800eb3c:	2200      	movs	r2, #0
 800eb3e:	601a      	str	r2, [r3, #0]
 800eb40:	e002      	b.n	800eb48 <lv_indev_read_task+0x138>
    if(indev_act->driver.disp == NULL) return; /*Not assigned to any displays*/
 800eb42:	bf00      	nop
 800eb44:	e000      	b.n	800eb48 <lv_indev_read_task+0x138>
    if(indev_act->proc.disabled) return;
 800eb46:	bf00      	nop

    LV_LOG_TRACE("indev read task finished");
}
 800eb48:	3724      	adds	r7, #36	; 0x24
 800eb4a:	46bd      	mov	sp, r7
 800eb4c:	bd90      	pop	{r4, r7, pc}
 800eb4e:	bf00      	nop
 800eb50:	20003f94 	.word	0x20003f94
 800eb54:	20003f98 	.word	0x20003f98

0800eb58 <lv_indev_get_act>:
 * Get the currently processed input device. Can be used in action functions too.
 * @return pointer to the currently processed input device or NULL if no input device processing
 * right now
 */
lv_indev_t * lv_indev_get_act(void)
{
 800eb58:	b480      	push	{r7}
 800eb5a:	af00      	add	r7, sp, #0
    return indev_act;
 800eb5c:	4b03      	ldr	r3, [pc, #12]	; (800eb6c <lv_indev_get_act+0x14>)
 800eb5e:	681b      	ldr	r3, [r3, #0]
}
 800eb60:	4618      	mov	r0, r3
 800eb62:	46bd      	mov	sp, r7
 800eb64:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb68:	4770      	bx	lr
 800eb6a:	bf00      	nop
 800eb6c:	20003f94 	.word	0x20003f94

0800eb70 <lv_indev_get_type>:
 * Get the type of an input device
 * @param indev pointer to an input device
 * @return the type of the input device from `lv_hal_indev_type_t` (`LV_INDEV_TYPE_...`)
 */
lv_indev_type_t lv_indev_get_type(const lv_indev_t * indev)
{
 800eb70:	b480      	push	{r7}
 800eb72:	b083      	sub	sp, #12
 800eb74:	af00      	add	r7, sp, #0
 800eb76:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return LV_INDEV_TYPE_NONE;
 800eb78:	687b      	ldr	r3, [r7, #4]
 800eb7a:	2b00      	cmp	r3, #0
 800eb7c:	d101      	bne.n	800eb82 <lv_indev_get_type+0x12>
 800eb7e:	2300      	movs	r3, #0
 800eb80:	e001      	b.n	800eb86 <lv_indev_get_type+0x16>

    return indev->driver.type;
 800eb82:	687b      	ldr	r3, [r7, #4]
 800eb84:	781b      	ldrb	r3, [r3, #0]
}
 800eb86:	4618      	mov	r0, r3
 800eb88:	370c      	adds	r7, #12
 800eb8a:	46bd      	mov	sp, r7
 800eb8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800eb90:	4770      	bx	lr

0800eb92 <lv_indev_reset>:
/**
 * Reset one or all input devices
 * @param indev pointer to an input device to reset or NULL to reset all of them
 */
void lv_indev_reset(lv_indev_t * indev)
{
 800eb92:	b580      	push	{r7, lr}
 800eb94:	b084      	sub	sp, #16
 800eb96:	af00      	add	r7, sp, #0
 800eb98:	6078      	str	r0, [r7, #4]
    if(indev)
 800eb9a:	687b      	ldr	r3, [r7, #4]
 800eb9c:	2b00      	cmp	r3, #0
 800eb9e:	d007      	beq.n	800ebb0 <lv_indev_reset+0x1e>
        indev->proc.reset_query = 1;
 800eba0:	687a      	ldr	r2, [r7, #4]
 800eba2:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800eba6:	f043 0302 	orr.w	r3, r3, #2
 800ebaa:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
            i->proc.reset_query = 1;

            i = lv_indev_get_next(i);
        }
    }
}
 800ebae:	e012      	b.n	800ebd6 <lv_indev_reset+0x44>
        lv_indev_t * i = lv_indev_get_next(NULL);
 800ebb0:	2000      	movs	r0, #0
 800ebb2:	f00c fc23 	bl	801b3fc <lv_indev_get_next>
 800ebb6:	60f8      	str	r0, [r7, #12]
        while(i) {
 800ebb8:	e00a      	b.n	800ebd0 <lv_indev_reset+0x3e>
            i->proc.reset_query = 1;
 800ebba:	68fa      	ldr	r2, [r7, #12]
 800ebbc:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800ebc0:	f043 0302 	orr.w	r3, r3, #2
 800ebc4:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
            i = lv_indev_get_next(i);
 800ebc8:	68f8      	ldr	r0, [r7, #12]
 800ebca:	f00c fc17 	bl	801b3fc <lv_indev_get_next>
 800ebce:	60f8      	str	r0, [r7, #12]
        while(i) {
 800ebd0:	68fb      	ldr	r3, [r7, #12]
 800ebd2:	2b00      	cmp	r3, #0
 800ebd4:	d1f1      	bne.n	800ebba <lv_indev_reset+0x28>
}
 800ebd6:	bf00      	nop
 800ebd8:	3710      	adds	r7, #16
 800ebda:	46bd      	mov	sp, r7
 800ebdc:	bd80      	pop	{r7, pc}

0800ebde <lv_indev_get_point>:
 * Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)
 * @param indev pointer to an input device
 * @param point pointer to a point to store the result
 */
void lv_indev_get_point(const lv_indev_t * indev, lv_point_t * point)
{
 800ebde:	b480      	push	{r7}
 800ebe0:	b083      	sub	sp, #12
 800ebe2:	af00      	add	r7, sp, #0
 800ebe4:	6078      	str	r0, [r7, #4]
 800ebe6:	6039      	str	r1, [r7, #0]
    if(indev->driver.type != LV_INDEV_TYPE_POINTER && indev->driver.type != LV_INDEV_TYPE_BUTTON) {
 800ebe8:	687b      	ldr	r3, [r7, #4]
 800ebea:	781b      	ldrb	r3, [r3, #0]
 800ebec:	2b01      	cmp	r3, #1
 800ebee:	d00c      	beq.n	800ec0a <lv_indev_get_point+0x2c>
 800ebf0:	687b      	ldr	r3, [r7, #4]
 800ebf2:	781b      	ldrb	r3, [r3, #0]
 800ebf4:	2b03      	cmp	r3, #3
 800ebf6:	d008      	beq.n	800ec0a <lv_indev_get_point+0x2c>
        point->x = -1;
 800ebf8:	683b      	ldr	r3, [r7, #0]
 800ebfa:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ebfe:	801a      	strh	r2, [r3, #0]
        point->y = -1;
 800ec00:	683b      	ldr	r3, [r7, #0]
 800ec02:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800ec06:	805a      	strh	r2, [r3, #2]
 800ec08:	e009      	b.n	800ec1e <lv_indev_get_point+0x40>
    } else {
        point->x = indev->proc.types.pointer.act_point.x;
 800ec0a:	687b      	ldr	r3, [r7, #4]
 800ec0c:	f9b3 2024 	ldrsh.w	r2, [r3, #36]	; 0x24
 800ec10:	683b      	ldr	r3, [r7, #0]
 800ec12:	801a      	strh	r2, [r3, #0]
        point->y = indev->proc.types.pointer.act_point.y;
 800ec14:	687b      	ldr	r3, [r7, #4]
 800ec16:	f9b3 2026 	ldrsh.w	r2, [r3, #38]	; 0x26
 800ec1a:	683b      	ldr	r3, [r7, #0]
 800ec1c:	805a      	strh	r2, [r3, #2]
    }
}
 800ec1e:	bf00      	nop
 800ec20:	370c      	adds	r7, #12
 800ec22:	46bd      	mov	sp, r7
 800ec24:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec28:	4770      	bx	lr

0800ec2a <lv_indev_is_dragging>:
 * LV_INDEV_TYPE_BUTTON)
 * @param indev pointer to an input device
 * @return true: drag is in progress
 */
bool lv_indev_is_dragging(const lv_indev_t * indev)
{
 800ec2a:	b480      	push	{r7}
 800ec2c:	b083      	sub	sp, #12
 800ec2e:	af00      	add	r7, sp, #0
 800ec30:	6078      	str	r0, [r7, #4]
    if(indev == NULL) return false;
 800ec32:	687b      	ldr	r3, [r7, #4]
 800ec34:	2b00      	cmp	r3, #0
 800ec36:	d101      	bne.n	800ec3c <lv_indev_is_dragging+0x12>
 800ec38:	2300      	movs	r3, #0
 800ec3a:	e014      	b.n	800ec66 <lv_indev_is_dragging+0x3c>
    if(indev->driver.type != LV_INDEV_TYPE_POINTER && indev->driver.type != LV_INDEV_TYPE_BUTTON) return false;
 800ec3c:	687b      	ldr	r3, [r7, #4]
 800ec3e:	781b      	ldrb	r3, [r3, #0]
 800ec40:	2b01      	cmp	r3, #1
 800ec42:	d005      	beq.n	800ec50 <lv_indev_is_dragging+0x26>
 800ec44:	687b      	ldr	r3, [r7, #4]
 800ec46:	781b      	ldrb	r3, [r3, #0]
 800ec48:	2b03      	cmp	r3, #3
 800ec4a:	d001      	beq.n	800ec50 <lv_indev_is_dragging+0x26>
 800ec4c:	2300      	movs	r3, #0
 800ec4e:	e00a      	b.n	800ec66 <lv_indev_is_dragging+0x3c>
    return indev->proc.types.pointer.drag_in_prog == 0 ? false : true;
 800ec50:	687b      	ldr	r3, [r7, #4]
 800ec52:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800ec56:	f003 0302 	and.w	r3, r3, #2
 800ec5a:	b2db      	uxtb	r3, r3
 800ec5c:	2b00      	cmp	r3, #0
 800ec5e:	bf14      	ite	ne
 800ec60:	2301      	movne	r3, #1
 800ec62:	2300      	moveq	r3, #0
 800ec64:	b2db      	uxtb	r3, r3
}
 800ec66:	4618      	mov	r0, r3
 800ec68:	370c      	adds	r7, #12
 800ec6a:	46bd      	mov	sp, r7
 800ec6c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec70:	4770      	bx	lr

0800ec72 <lv_indev_get_vect>:
 * LV_INDEV_TYPE_BUTTON)
 * @param indev pointer to an input device
 * @param point pointer to a point to store the types.pointer.vector
 */
void lv_indev_get_vect(const lv_indev_t * indev, lv_point_t * point)
{
 800ec72:	b480      	push	{r7}
 800ec74:	b083      	sub	sp, #12
 800ec76:	af00      	add	r7, sp, #0
 800ec78:	6078      	str	r0, [r7, #4]
 800ec7a:	6039      	str	r1, [r7, #0]
    if(indev == NULL) {
 800ec7c:	687b      	ldr	r3, [r7, #4]
 800ec7e:	2b00      	cmp	r3, #0
 800ec80:	d106      	bne.n	800ec90 <lv_indev_get_vect+0x1e>
        point->x = 0;
 800ec82:	683b      	ldr	r3, [r7, #0]
 800ec84:	2200      	movs	r2, #0
 800ec86:	801a      	strh	r2, [r3, #0]
        point->y = 0;
 800ec88:	683b      	ldr	r3, [r7, #0]
 800ec8a:	2200      	movs	r2, #0
 800ec8c:	805a      	strh	r2, [r3, #2]
        return;
 800ec8e:	e018      	b.n	800ecc2 <lv_indev_get_vect+0x50>
    }

    if(indev->driver.type != LV_INDEV_TYPE_POINTER && indev->driver.type != LV_INDEV_TYPE_BUTTON) {
 800ec90:	687b      	ldr	r3, [r7, #4]
 800ec92:	781b      	ldrb	r3, [r3, #0]
 800ec94:	2b01      	cmp	r3, #1
 800ec96:	d00a      	beq.n	800ecae <lv_indev_get_vect+0x3c>
 800ec98:	687b      	ldr	r3, [r7, #4]
 800ec9a:	781b      	ldrb	r3, [r3, #0]
 800ec9c:	2b03      	cmp	r3, #3
 800ec9e:	d006      	beq.n	800ecae <lv_indev_get_vect+0x3c>
        point->x = 0;
 800eca0:	683b      	ldr	r3, [r7, #0]
 800eca2:	2200      	movs	r2, #0
 800eca4:	801a      	strh	r2, [r3, #0]
        point->y = 0;
 800eca6:	683b      	ldr	r3, [r7, #0]
 800eca8:	2200      	movs	r2, #0
 800ecaa:	805a      	strh	r2, [r3, #2]
 800ecac:	e009      	b.n	800ecc2 <lv_indev_get_vect+0x50>
    } else {
        point->x = indev->proc.types.pointer.vect.x;
 800ecae:	687b      	ldr	r3, [r7, #4]
 800ecb0:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
 800ecb4:	683b      	ldr	r3, [r7, #0]
 800ecb6:	801a      	strh	r2, [r3, #0]
        point->y = indev->proc.types.pointer.vect.y;
 800ecb8:	687b      	ldr	r3, [r7, #4]
 800ecba:	f9b3 202e 	ldrsh.w	r2, [r3, #46]	; 0x2e
 800ecbe:	683b      	ldr	r3, [r7, #0]
 800ecc0:	805a      	strh	r2, [r3, #2]
    }
}
 800ecc2:	370c      	adds	r7, #12
 800ecc4:	46bd      	mov	sp, r7
 800ecc6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecca:	4770      	bx	lr

0800eccc <lv_indev_get_obj_act>:
/**
 * Gets a pointer to the currently active object in the currently processed input device.
 * @return pointer to currently active object or NULL if no active object
 */
lv_obj_t * lv_indev_get_obj_act(void)
{
 800eccc:	b480      	push	{r7}
 800ecce:	af00      	add	r7, sp, #0
    return indev_obj_act;
 800ecd0:	4b03      	ldr	r3, [pc, #12]	; (800ece0 <lv_indev_get_obj_act+0x14>)
 800ecd2:	681b      	ldr	r3, [r3, #0]
}
 800ecd4:	4618      	mov	r0, r3
 800ecd6:	46bd      	mov	sp, r7
 800ecd8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ecdc:	4770      	bx	lr
 800ecde:	bf00      	nop
 800ece0:	20003f98 	.word	0x20003f98

0800ece4 <indev_pointer_proc>:
 * Process a new point from LV_INDEV_TYPE_POINTER input device
 * @param i pointer to an input device
 * @param data pointer to the data read from the input device
 */
static void indev_pointer_proc(lv_indev_t * i, lv_indev_data_t * data)
{
 800ece4:	b580      	push	{r7, lr}
 800ece6:	b082      	sub	sp, #8
 800ece8:	af00      	add	r7, sp, #0
 800ecea:	6078      	str	r0, [r7, #4]
 800ecec:	6039      	str	r1, [r7, #0]
    /*Move the cursor if set and moved*/
    if(i->cursor != NULL &&
 800ecee:	687b      	ldr	r3, [r7, #4]
 800ecf0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800ecf2:	2b00      	cmp	r3, #0
 800ecf4:	d01a      	beq.n	800ed2c <indev_pointer_proc+0x48>
       (i->proc.types.pointer.last_point.x != data->point.x || i->proc.types.pointer.last_point.y != data->point.y)) {
 800ecf6:	687b      	ldr	r3, [r7, #4]
 800ecf8:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 800ecfc:	683b      	ldr	r3, [r7, #0]
 800ecfe:	f9b3 3000 	ldrsh.w	r3, [r3]
    if(i->cursor != NULL &&
 800ed02:	429a      	cmp	r2, r3
 800ed04:	d107      	bne.n	800ed16 <indev_pointer_proc+0x32>
       (i->proc.types.pointer.last_point.x != data->point.x || i->proc.types.pointer.last_point.y != data->point.y)) {
 800ed06:	687b      	ldr	r3, [r7, #4]
 800ed08:	f9b3 202a 	ldrsh.w	r2, [r3, #42]	; 0x2a
 800ed0c:	683b      	ldr	r3, [r7, #0]
 800ed0e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800ed12:	429a      	cmp	r2, r3
 800ed14:	d00a      	beq.n	800ed2c <indev_pointer_proc+0x48>
        lv_obj_set_pos(i->cursor, data->point.x, data->point.y);
 800ed16:	687b      	ldr	r3, [r7, #4]
 800ed18:	6d58      	ldr	r0, [r3, #84]	; 0x54
 800ed1a:	683b      	ldr	r3, [r7, #0]
 800ed1c:	f9b3 1000 	ldrsh.w	r1, [r3]
 800ed20:	683b      	ldr	r3, [r7, #0]
 800ed22:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800ed26:	461a      	mov	r2, r3
 800ed28:	f002 f992 	bl	8011050 <lv_obj_set_pos>
    }

    i->proc.types.pointer.act_point.x = data->point.x;
 800ed2c:	683b      	ldr	r3, [r7, #0]
 800ed2e:	f9b3 2000 	ldrsh.w	r2, [r3]
 800ed32:	687b      	ldr	r3, [r7, #4]
 800ed34:	849a      	strh	r2, [r3, #36]	; 0x24
    i->proc.types.pointer.act_point.y = data->point.y;
 800ed36:	683b      	ldr	r3, [r7, #0]
 800ed38:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800ed3c:	687b      	ldr	r3, [r7, #4]
 800ed3e:	84da      	strh	r2, [r3, #38]	; 0x26

    if(i->proc.state == LV_INDEV_STATE_PR) {
 800ed40:	687b      	ldr	r3, [r7, #4]
 800ed42:	f893 3020 	ldrb.w	r3, [r3, #32]
 800ed46:	2b01      	cmp	r3, #1
 800ed48:	d105      	bne.n	800ed56 <indev_pointer_proc+0x72>
        indev_proc_press(&i->proc);
 800ed4a:	687b      	ldr	r3, [r7, #4]
 800ed4c:	3320      	adds	r3, #32
 800ed4e:	4618      	mov	r0, r3
 800ed50:	f000 fce6 	bl	800f720 <indev_proc_press>
 800ed54:	e004      	b.n	800ed60 <indev_pointer_proc+0x7c>
    } else {
        indev_proc_release(&i->proc);
 800ed56:	687b      	ldr	r3, [r7, #4]
 800ed58:	3320      	adds	r3, #32
 800ed5a:	4618      	mov	r0, r3
 800ed5c:	f000 ff56 	bl	800fc0c <indev_proc_release>
    }

    i->proc.types.pointer.last_point.x = i->proc.types.pointer.act_point.x;
 800ed60:	687b      	ldr	r3, [r7, #4]
 800ed62:	f9b3 2024 	ldrsh.w	r2, [r3, #36]	; 0x24
 800ed66:	687b      	ldr	r3, [r7, #4]
 800ed68:	851a      	strh	r2, [r3, #40]	; 0x28
    i->proc.types.pointer.last_point.y = i->proc.types.pointer.act_point.y;
 800ed6a:	687b      	ldr	r3, [r7, #4]
 800ed6c:	f9b3 2026 	ldrsh.w	r2, [r3, #38]	; 0x26
 800ed70:	687b      	ldr	r3, [r7, #4]
 800ed72:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 800ed74:	bf00      	nop
 800ed76:	3708      	adds	r7, #8
 800ed78:	46bd      	mov	sp, r7
 800ed7a:	bd80      	pop	{r7, pc}

0800ed7c <indev_keypad_proc>:
 * Process a new point from LV_INDEV_TYPE_KEYPAD input device
 * @param i pointer to an input device
 * @param data pointer to the data read from the input device
 */
static void indev_keypad_proc(lv_indev_t * i, lv_indev_data_t * data)
{
 800ed7c:	b580      	push	{r7, lr}
 800ed7e:	b086      	sub	sp, #24
 800ed80:	af00      	add	r7, sp, #0
 800ed82:	6078      	str	r0, [r7, #4]
 800ed84:	6039      	str	r1, [r7, #0]
#if LV_USE_GROUP
    if(data->state == LV_INDEV_STATE_PR && i->proc.wait_until_release) return;
 800ed86:	683b      	ldr	r3, [r7, #0]
 800ed88:	7b9b      	ldrb	r3, [r3, #14]
 800ed8a:	2b01      	cmp	r3, #1
 800ed8c:	d108      	bne.n	800eda0 <indev_keypad_proc+0x24>
 800ed8e:	687b      	ldr	r3, [r7, #4]
 800ed90:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800ed94:	f003 0308 	and.w	r3, r3, #8
 800ed98:	b2db      	uxtb	r3, r3
 800ed9a:	2b00      	cmp	r3, #0
 800ed9c:	f040 81ed 	bne.w	800f17a <indev_keypad_proc+0x3fe>

    if(i->proc.wait_until_release) {
 800eda0:	687b      	ldr	r3, [r7, #4]
 800eda2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800eda6:	f003 0308 	and.w	r3, r3, #8
 800edaa:	b2db      	uxtb	r3, r3
 800edac:	2b00      	cmp	r3, #0
 800edae:	d014      	beq.n	800edda <indev_keypad_proc+0x5e>
        i->proc.wait_until_release      = 0;
 800edb0:	687a      	ldr	r2, [r7, #4]
 800edb2:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800edb6:	f36f 03c3 	bfc	r3, #3, #1
 800edba:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        i->proc.pr_timestamp            = 0;
 800edbe:	687b      	ldr	r3, [r7, #4]
 800edc0:	2200      	movs	r2, #0
 800edc2:	649a      	str	r2, [r3, #72]	; 0x48
        i->proc.long_pr_sent            = 0;
 800edc4:	687a      	ldr	r2, [r7, #4]
 800edc6:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800edca:	f36f 0300 	bfc	r3, #0, #1
 800edce:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        i->proc.types.keypad.last_state = LV_INDEV_STATE_REL; /*To skip the processing of release*/
 800edd2:	687b      	ldr	r3, [r7, #4]
 800edd4:	2200      	movs	r2, #0
 800edd6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    }

    lv_group_t * g = i->group;
 800edda:	687b      	ldr	r3, [r7, #4]
 800eddc:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800edde:	617b      	str	r3, [r7, #20]
    if(g == NULL) return;
 800ede0:	697b      	ldr	r3, [r7, #20]
 800ede2:	2b00      	cmp	r3, #0
 800ede4:	f000 81cb 	beq.w	800f17e <indev_keypad_proc+0x402>

    indev_obj_act = lv_group_get_focused(g);
 800ede8:	6978      	ldr	r0, [r7, #20]
 800edea:	f7ff fb37 	bl	800e45c <lv_group_get_focused>
 800edee:	4602      	mov	r2, r0
 800edf0:	4bae      	ldr	r3, [pc, #696]	; (800f0ac <indev_keypad_proc+0x330>)
 800edf2:	601a      	str	r2, [r3, #0]
    if(indev_obj_act == NULL) return;
 800edf4:	4bad      	ldr	r3, [pc, #692]	; (800f0ac <indev_keypad_proc+0x330>)
 800edf6:	681b      	ldr	r3, [r3, #0]
 800edf8:	2b00      	cmp	r3, #0
 800edfa:	f000 81c2 	beq.w	800f182 <indev_keypad_proc+0x406>

    /*Save the last key to compare it with the current latter on RELEASE*/
    uint32_t prev_key = i->proc.types.keypad.last_key;
 800edfe:	687b      	ldr	r3, [r7, #4]
 800ee00:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800ee02:	613b      	str	r3, [r7, #16]

    /* Save the last key.
     * It must be done here else `lv_indev_get_key` will return the last key in events and signals*/
    i->proc.types.keypad.last_key = data->key;
 800ee04:	683b      	ldr	r3, [r7, #0]
 800ee06:	685a      	ldr	r2, [r3, #4]
 800ee08:	687b      	ldr	r3, [r7, #4]
 800ee0a:	629a      	str	r2, [r3, #40]	; 0x28

    /* Save the previous state so we can detect state changes below and also set the last state now
     * so if any signal/event handler on the way returns `LV_RES_INV` the last state is remembered
     * for the next time*/
    uint32_t prev_state             = i->proc.types.keypad.last_state;
 800ee0c:	687b      	ldr	r3, [r7, #4]
 800ee0e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800ee12:	60fb      	str	r3, [r7, #12]
    i->proc.types.keypad.last_state = data->state;
 800ee14:	683b      	ldr	r3, [r7, #0]
 800ee16:	7b9a      	ldrb	r2, [r3, #14]
 800ee18:	687b      	ldr	r3, [r7, #4]
 800ee1a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

    /*Key press happened*/
    if(data->state == LV_INDEV_STATE_PR && prev_state == LV_INDEV_STATE_REL) {
 800ee1e:	683b      	ldr	r3, [r7, #0]
 800ee20:	7b9b      	ldrb	r3, [r3, #14]
 800ee22:	2b01      	cmp	r3, #1
 800ee24:	d17b      	bne.n	800ef1e <indev_keypad_proc+0x1a2>
 800ee26:	68fb      	ldr	r3, [r7, #12]
 800ee28:	2b00      	cmp	r3, #0
 800ee2a:	d178      	bne.n	800ef1e <indev_keypad_proc+0x1a2>
        i->proc.pr_timestamp = lv_tick_get();
 800ee2c:	f00c fb3e 	bl	801b4ac <lv_tick_get>
 800ee30:	4602      	mov	r2, r0
 800ee32:	687b      	ldr	r3, [r7, #4]
 800ee34:	649a      	str	r2, [r3, #72]	; 0x48

        /*Simulate a press on the object if ENTER was pressed*/
        if(data->key == LV_KEY_ENTER) {
 800ee36:	683b      	ldr	r3, [r7, #0]
 800ee38:	685b      	ldr	r3, [r3, #4]
 800ee3a:	2b0a      	cmp	r3, #10
 800ee3c:	d125      	bne.n	800ee8a <indev_keypad_proc+0x10e>
            /*Send the ENTER as a normal KEY*/
            lv_group_send_data(g, LV_KEY_ENTER);
 800ee3e:	210a      	movs	r1, #10
 800ee40:	6978      	ldr	r0, [r7, #20]
 800ee42:	f7ff fa6d 	bl	800e320 <lv_group_send_data>

            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSED, NULL);
 800ee46:	4b99      	ldr	r3, [pc, #612]	; (800f0ac <indev_keypad_proc+0x330>)
 800ee48:	681b      	ldr	r3, [r3, #0]
 800ee4a:	69db      	ldr	r3, [r3, #28]
 800ee4c:	4a97      	ldr	r2, [pc, #604]	; (800f0ac <indev_keypad_proc+0x330>)
 800ee4e:	6810      	ldr	r0, [r2, #0]
 800ee50:	2200      	movs	r2, #0
 800ee52:	2107      	movs	r1, #7
 800ee54:	4798      	blx	r3
            if(indev_reset_check(&i->proc)) return;
 800ee56:	687b      	ldr	r3, [r7, #4]
 800ee58:	3320      	adds	r3, #32
 800ee5a:	4618      	mov	r0, r3
 800ee5c:	f001 fbf8 	bl	8010650 <indev_reset_check>
 800ee60:	4603      	mov	r3, r0
 800ee62:	2b00      	cmp	r3, #0
 800ee64:	f040 818f 	bne.w	800f186 <indev_keypad_proc+0x40a>
            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, NULL);
 800ee68:	4b90      	ldr	r3, [pc, #576]	; (800f0ac <indev_keypad_proc+0x330>)
 800ee6a:	681b      	ldr	r3, [r3, #0]
 800ee6c:	2200      	movs	r2, #0
 800ee6e:	2100      	movs	r1, #0
 800ee70:	4618      	mov	r0, r3
 800ee72:	f002 fff4 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800ee76:	687b      	ldr	r3, [r7, #4]
 800ee78:	3320      	adds	r3, #32
 800ee7a:	4618      	mov	r0, r3
 800ee7c:	f001 fbe8 	bl	8010650 <indev_reset_check>
 800ee80:	4603      	mov	r3, r0
 800ee82:	2b00      	cmp	r3, #0
 800ee84:	f000 8172 	beq.w	800f16c <indev_keypad_proc+0x3f0>
 800ee88:	e18a      	b.n	800f1a0 <indev_keypad_proc+0x424>
        } else if(data->key == LV_KEY_ESC) {
 800ee8a:	683b      	ldr	r3, [r7, #0]
 800ee8c:	685b      	ldr	r3, [r3, #4]
 800ee8e:	2b1b      	cmp	r3, #27
 800ee90:	d114      	bne.n	800eebc <indev_keypad_proc+0x140>
            /*Send the ESC as a normal KEY*/
            lv_group_send_data(g, LV_KEY_ESC);
 800ee92:	211b      	movs	r1, #27
 800ee94:	6978      	ldr	r0, [r7, #20]
 800ee96:	f7ff fa43 	bl	800e320 <lv_group_send_data>

            lv_event_send(indev_obj_act, LV_EVENT_CANCEL, NULL);
 800ee9a:	4b84      	ldr	r3, [pc, #528]	; (800f0ac <indev_keypad_proc+0x330>)
 800ee9c:	681b      	ldr	r3, [r3, #0]
 800ee9e:	2200      	movs	r2, #0
 800eea0:	2112      	movs	r1, #18
 800eea2:	4618      	mov	r0, r3
 800eea4:	f002 ffdb 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800eea8:	687b      	ldr	r3, [r7, #4]
 800eeaa:	3320      	adds	r3, #32
 800eeac:	4618      	mov	r0, r3
 800eeae:	f001 fbcf 	bl	8010650 <indev_reset_check>
 800eeb2:	4603      	mov	r3, r0
 800eeb4:	2b00      	cmp	r3, #0
 800eeb6:	f000 8159 	beq.w	800f16c <indev_keypad_proc+0x3f0>
 800eeba:	e171      	b.n	800f1a0 <indev_keypad_proc+0x424>
        }
        /*Move the focus on NEXT*/
        else if(data->key == LV_KEY_NEXT) {
 800eebc:	683b      	ldr	r3, [r7, #0]
 800eebe:	685b      	ldr	r3, [r3, #4]
 800eec0:	2b09      	cmp	r3, #9
 800eec2:	d110      	bne.n	800eee6 <indev_keypad_proc+0x16a>
            lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/
 800eec4:	2100      	movs	r1, #0
 800eec6:	6978      	ldr	r0, [r7, #20]
 800eec8:	f7ff fa57 	bl	800e37a <lv_group_set_editing>
            lv_group_focus_next(g);
 800eecc:	6978      	ldr	r0, [r7, #20]
 800eece:	f7ff fa03 	bl	800e2d8 <lv_group_focus_next>
            if(indev_reset_check(&i->proc)) return;
 800eed2:	687b      	ldr	r3, [r7, #4]
 800eed4:	3320      	adds	r3, #32
 800eed6:	4618      	mov	r0, r3
 800eed8:	f001 fbba 	bl	8010650 <indev_reset_check>
 800eedc:	4603      	mov	r3, r0
 800eede:	2b00      	cmp	r3, #0
 800eee0:	f000 8144 	beq.w	800f16c <indev_keypad_proc+0x3f0>
 800eee4:	e15c      	b.n	800f1a0 <indev_keypad_proc+0x424>
        }
        /*Move the focus on PREV*/
        else if(data->key == LV_KEY_PREV) {
 800eee6:	683b      	ldr	r3, [r7, #0]
 800eee8:	685b      	ldr	r3, [r3, #4]
 800eeea:	2b0b      	cmp	r3, #11
 800eeec:	d110      	bne.n	800ef10 <indev_keypad_proc+0x194>
            lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/
 800eeee:	2100      	movs	r1, #0
 800eef0:	6978      	ldr	r0, [r7, #20]
 800eef2:	f7ff fa42 	bl	800e37a <lv_group_set_editing>
            lv_group_focus_prev(g);
 800eef6:	6978      	ldr	r0, [r7, #20]
 800eef8:	f7ff fa00 	bl	800e2fc <lv_group_focus_prev>
            if(indev_reset_check(&i->proc)) return;
 800eefc:	687b      	ldr	r3, [r7, #4]
 800eefe:	3320      	adds	r3, #32
 800ef00:	4618      	mov	r0, r3
 800ef02:	f001 fba5 	bl	8010650 <indev_reset_check>
 800ef06:	4603      	mov	r3, r0
 800ef08:	2b00      	cmp	r3, #0
 800ef0a:	f000 812f 	beq.w	800f16c <indev_keypad_proc+0x3f0>
 800ef0e:	e147      	b.n	800f1a0 <indev_keypad_proc+0x424>
        }
        /*Just send other keys to the object (e.g. 'A' or `LV_GROUP_KEY_RIGHT`)*/
        else {
            lv_group_send_data(g, data->key);
 800ef10:	683b      	ldr	r3, [r7, #0]
 800ef12:	685b      	ldr	r3, [r3, #4]
 800ef14:	4619      	mov	r1, r3
 800ef16:	6978      	ldr	r0, [r7, #20]
 800ef18:	f7ff fa02 	bl	800e320 <lv_group_send_data>
        if(data->key == LV_KEY_ENTER) {
 800ef1c:	e126      	b.n	800f16c <indev_keypad_proc+0x3f0>
        }
    }
    /*Pressing*/
    else if(data->state == LV_INDEV_STATE_PR && prev_state == LV_INDEV_STATE_PR) {
 800ef1e:	683b      	ldr	r3, [r7, #0]
 800ef20:	7b9b      	ldrb	r3, [r3, #14]
 800ef22:	2b01      	cmp	r3, #1
 800ef24:	f040 80c4 	bne.w	800f0b0 <indev_keypad_proc+0x334>
 800ef28:	68fb      	ldr	r3, [r7, #12]
 800ef2a:	2b01      	cmp	r3, #1
 800ef2c:	f040 80c0 	bne.w	800f0b0 <indev_keypad_proc+0x334>
        /*Long press time has elapsed?*/
        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver.long_press_time) {
 800ef30:	687b      	ldr	r3, [r7, #4]
 800ef32:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800ef36:	f003 0301 	and.w	r3, r3, #1
 800ef3a:	b2db      	uxtb	r3, r3
 800ef3c:	2b00      	cmp	r3, #0
 800ef3e:	d13b      	bne.n	800efb8 <indev_keypad_proc+0x23c>
 800ef40:	687b      	ldr	r3, [r7, #4]
 800ef42:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ef44:	4618      	mov	r0, r3
 800ef46:	f00c facb 	bl	801b4e0 <lv_tick_elaps>
 800ef4a:	4602      	mov	r2, r0
 800ef4c:	687b      	ldr	r3, [r7, #4]
 800ef4e:	8b5b      	ldrh	r3, [r3, #26]
 800ef50:	429a      	cmp	r2, r3
 800ef52:	d931      	bls.n	800efb8 <indev_keypad_proc+0x23c>
            i->proc.long_pr_sent = 1;
 800ef54:	687a      	ldr	r2, [r7, #4]
 800ef56:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800ef5a:	f043 0301 	orr.w	r3, r3, #1
 800ef5e:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
            if(data->key == LV_KEY_ENTER) {
 800ef62:	683b      	ldr	r3, [r7, #0]
 800ef64:	685b      	ldr	r3, [r3, #4]
 800ef66:	2b0a      	cmp	r3, #10
 800ef68:	f040 809d 	bne.w	800f0a6 <indev_keypad_proc+0x32a>
                i->proc.longpr_rep_timestamp = lv_tick_get();
 800ef6c:	f00c fa9e 	bl	801b4ac <lv_tick_get>
 800ef70:	4602      	mov	r2, r0
 800ef72:	687b      	ldr	r3, [r7, #4]
 800ef74:	64da      	str	r2, [r3, #76]	; 0x4c
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS, NULL);
 800ef76:	4b4d      	ldr	r3, [pc, #308]	; (800f0ac <indev_keypad_proc+0x330>)
 800ef78:	681b      	ldr	r3, [r3, #0]
 800ef7a:	69db      	ldr	r3, [r3, #28]
 800ef7c:	4a4b      	ldr	r2, [pc, #300]	; (800f0ac <indev_keypad_proc+0x330>)
 800ef7e:	6810      	ldr	r0, [r2, #0]
 800ef80:	2200      	movs	r2, #0
 800ef82:	210b      	movs	r1, #11
 800ef84:	4798      	blx	r3
                if(indev_reset_check(&i->proc)) return;
 800ef86:	687b      	ldr	r3, [r7, #4]
 800ef88:	3320      	adds	r3, #32
 800ef8a:	4618      	mov	r0, r3
 800ef8c:	f001 fb60 	bl	8010650 <indev_reset_check>
 800ef90:	4603      	mov	r3, r0
 800ef92:	2b00      	cmp	r3, #0
 800ef94:	f040 80f9 	bne.w	800f18a <indev_keypad_proc+0x40e>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, NULL);
 800ef98:	4b44      	ldr	r3, [pc, #272]	; (800f0ac <indev_keypad_proc+0x330>)
 800ef9a:	681b      	ldr	r3, [r3, #0]
 800ef9c:	2200      	movs	r2, #0
 800ef9e:	2104      	movs	r1, #4
 800efa0:	4618      	mov	r0, r3
 800efa2:	f002 ff5c 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800efa6:	687b      	ldr	r3, [r7, #4]
 800efa8:	3320      	adds	r3, #32
 800efaa:	4618      	mov	r0, r3
 800efac:	f001 fb50 	bl	8010650 <indev_reset_check>
 800efb0:	4603      	mov	r3, r0
 800efb2:	2b00      	cmp	r3, #0
 800efb4:	d077      	beq.n	800f0a6 <indev_keypad_proc+0x32a>
 800efb6:	e0f3      	b.n	800f1a0 <indev_keypad_proc+0x424>
            }
        }
        /*Long press repeated time has elapsed?*/
        else if(i->proc.long_pr_sent != 0 &&
 800efb8:	687b      	ldr	r3, [r7, #4]
 800efba:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800efbe:	f003 0301 	and.w	r3, r3, #1
 800efc2:	b2db      	uxtb	r3, r3
 800efc4:	2b00      	cmp	r3, #0
 800efc6:	f000 80d3 	beq.w	800f170 <indev_keypad_proc+0x3f4>
                lv_tick_elaps(i->proc.longpr_rep_timestamp) > i->driver.long_press_rep_time) {
 800efca:	687b      	ldr	r3, [r7, #4]
 800efcc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 800efce:	4618      	mov	r0, r3
 800efd0:	f00c fa86 	bl	801b4e0 <lv_tick_elaps>
 800efd4:	4602      	mov	r2, r0
 800efd6:	687b      	ldr	r3, [r7, #4]
 800efd8:	8b9b      	ldrh	r3, [r3, #28]
        else if(i->proc.long_pr_sent != 0 &&
 800efda:	429a      	cmp	r2, r3
 800efdc:	f240 80c8 	bls.w	800f170 <indev_keypad_proc+0x3f4>

            i->proc.longpr_rep_timestamp = lv_tick_get();
 800efe0:	f00c fa64 	bl	801b4ac <lv_tick_get>
 800efe4:	4602      	mov	r2, r0
 800efe6:	687b      	ldr	r3, [r7, #4]
 800efe8:	64da      	str	r2, [r3, #76]	; 0x4c

            /*Send LONG_PRESS_REP on ENTER*/
            if(data->key == LV_KEY_ENTER) {
 800efea:	683b      	ldr	r3, [r7, #0]
 800efec:	685b      	ldr	r3, [r3, #4]
 800efee:	2b0a      	cmp	r3, #10
 800eff0:	d121      	bne.n	800f036 <indev_keypad_proc+0x2ba>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS_REP, NULL);
 800eff2:	4b2e      	ldr	r3, [pc, #184]	; (800f0ac <indev_keypad_proc+0x330>)
 800eff4:	681b      	ldr	r3, [r3, #0]
 800eff6:	69db      	ldr	r3, [r3, #28]
 800eff8:	4a2c      	ldr	r2, [pc, #176]	; (800f0ac <indev_keypad_proc+0x330>)
 800effa:	6810      	ldr	r0, [r2, #0]
 800effc:	2200      	movs	r2, #0
 800effe:	210c      	movs	r1, #12
 800f000:	4798      	blx	r3
                if(indev_reset_check(&i->proc)) return;
 800f002:	687b      	ldr	r3, [r7, #4]
 800f004:	3320      	adds	r3, #32
 800f006:	4618      	mov	r0, r3
 800f008:	f001 fb22 	bl	8010650 <indev_reset_check>
 800f00c:	4603      	mov	r3, r0
 800f00e:	2b00      	cmp	r3, #0
 800f010:	f040 80bd 	bne.w	800f18e <indev_keypad_proc+0x412>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, NULL);
 800f014:	4b25      	ldr	r3, [pc, #148]	; (800f0ac <indev_keypad_proc+0x330>)
 800f016:	681b      	ldr	r3, [r3, #0]
 800f018:	2200      	movs	r2, #0
 800f01a:	2105      	movs	r1, #5
 800f01c:	4618      	mov	r0, r3
 800f01e:	f002 ff1e 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800f022:	687b      	ldr	r3, [r7, #4]
 800f024:	3320      	adds	r3, #32
 800f026:	4618      	mov	r0, r3
 800f028:	f001 fb12 	bl	8010650 <indev_reset_check>
 800f02c:	4603      	mov	r3, r0
 800f02e:	2b00      	cmp	r3, #0
 800f030:	f000 809e 	beq.w	800f170 <indev_keypad_proc+0x3f4>
 800f034:	e0b4      	b.n	800f1a0 <indev_keypad_proc+0x424>
            }
            /*Move the focus on NEXT again*/
            else if(data->key == LV_KEY_NEXT) {
 800f036:	683b      	ldr	r3, [r7, #0]
 800f038:	685b      	ldr	r3, [r3, #4]
 800f03a:	2b09      	cmp	r3, #9
 800f03c:	d110      	bne.n	800f060 <indev_keypad_proc+0x2e4>
                lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/
 800f03e:	2100      	movs	r1, #0
 800f040:	6978      	ldr	r0, [r7, #20]
 800f042:	f7ff f99a 	bl	800e37a <lv_group_set_editing>
                lv_group_focus_next(g);
 800f046:	6978      	ldr	r0, [r7, #20]
 800f048:	f7ff f946 	bl	800e2d8 <lv_group_focus_next>
                if(indev_reset_check(&i->proc)) return;
 800f04c:	687b      	ldr	r3, [r7, #4]
 800f04e:	3320      	adds	r3, #32
 800f050:	4618      	mov	r0, r3
 800f052:	f001 fafd 	bl	8010650 <indev_reset_check>
 800f056:	4603      	mov	r3, r0
 800f058:	2b00      	cmp	r3, #0
 800f05a:	f000 8089 	beq.w	800f170 <indev_keypad_proc+0x3f4>
 800f05e:	e09f      	b.n	800f1a0 <indev_keypad_proc+0x424>
            }
            /*Move the focus on PREV again*/
            else if(data->key == LV_KEY_PREV) {
 800f060:	683b      	ldr	r3, [r7, #0]
 800f062:	685b      	ldr	r3, [r3, #4]
 800f064:	2b0b      	cmp	r3, #11
 800f066:	d10f      	bne.n	800f088 <indev_keypad_proc+0x30c>
                lv_group_set_editing(g, false); /*Editing is not used by KEYPAD is be sure it is disabled*/
 800f068:	2100      	movs	r1, #0
 800f06a:	6978      	ldr	r0, [r7, #20]
 800f06c:	f7ff f985 	bl	800e37a <lv_group_set_editing>
                lv_group_focus_prev(g);
 800f070:	6978      	ldr	r0, [r7, #20]
 800f072:	f7ff f943 	bl	800e2fc <lv_group_focus_prev>
                if(indev_reset_check(&i->proc)) return;
 800f076:	687b      	ldr	r3, [r7, #4]
 800f078:	3320      	adds	r3, #32
 800f07a:	4618      	mov	r0, r3
 800f07c:	f001 fae8 	bl	8010650 <indev_reset_check>
 800f080:	4603      	mov	r3, r0
 800f082:	2b00      	cmp	r3, #0
 800f084:	d074      	beq.n	800f170 <indev_keypad_proc+0x3f4>
 800f086:	e08b      	b.n	800f1a0 <indev_keypad_proc+0x424>
            }
            /*Just send other keys again to the object (e.g. 'A' or `LV_GORUP_KEY_RIGHT)*/
            else {
                lv_group_send_data(g, data->key);
 800f088:	683b      	ldr	r3, [r7, #0]
 800f08a:	685b      	ldr	r3, [r3, #4]
 800f08c:	4619      	mov	r1, r3
 800f08e:	6978      	ldr	r0, [r7, #20]
 800f090:	f7ff f946 	bl	800e320 <lv_group_send_data>
                if(indev_reset_check(&i->proc)) return;
 800f094:	687b      	ldr	r3, [r7, #4]
 800f096:	3320      	adds	r3, #32
 800f098:	4618      	mov	r0, r3
 800f09a:	f001 fad9 	bl	8010650 <indev_reset_check>
 800f09e:	4603      	mov	r3, r0
 800f0a0:	2b00      	cmp	r3, #0
 800f0a2:	d065      	beq.n	800f170 <indev_keypad_proc+0x3f4>
 800f0a4:	e07c      	b.n	800f1a0 <indev_keypad_proc+0x424>
            if(data->key == LV_KEY_ENTER) {
 800f0a6:	bf00      	nop
        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver.long_press_time) {
 800f0a8:	e062      	b.n	800f170 <indev_keypad_proc+0x3f4>
 800f0aa:	bf00      	nop
 800f0ac:	20003f98 	.word	0x20003f98
            }
        }
    }
    /*Release happened*/
    else if(data->state == LV_INDEV_STATE_REL && prev_state == LV_INDEV_STATE_PR) {
 800f0b0:	683b      	ldr	r3, [r7, #0]
 800f0b2:	7b9b      	ldrb	r3, [r3, #14]
 800f0b4:	2b00      	cmp	r3, #0
 800f0b6:	d15c      	bne.n	800f172 <indev_keypad_proc+0x3f6>
 800f0b8:	68fb      	ldr	r3, [r7, #12]
 800f0ba:	2b01      	cmp	r3, #1
 800f0bc:	d159      	bne.n	800f172 <indev_keypad_proc+0x3f6>
        /*The user might clear the key when it was released. Always release the pressed key*/
        data->key = prev_key;
 800f0be:	683b      	ldr	r3, [r7, #0]
 800f0c0:	693a      	ldr	r2, [r7, #16]
 800f0c2:	605a      	str	r2, [r3, #4]
        if(data->key == LV_KEY_ENTER) {
 800f0c4:	683b      	ldr	r3, [r7, #0]
 800f0c6:	685b      	ldr	r3, [r3, #4]
 800f0c8:	2b0a      	cmp	r3, #10
 800f0ca:	d144      	bne.n	800f156 <indev_keypad_proc+0x3da>

            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, NULL);
 800f0cc:	4b36      	ldr	r3, [pc, #216]	; (800f1a8 <indev_keypad_proc+0x42c>)
 800f0ce:	681b      	ldr	r3, [r3, #0]
 800f0d0:	69db      	ldr	r3, [r3, #28]
 800f0d2:	4a35      	ldr	r2, [pc, #212]	; (800f1a8 <indev_keypad_proc+0x42c>)
 800f0d4:	6810      	ldr	r0, [r2, #0]
 800f0d6:	2200      	movs	r2, #0
 800f0d8:	210a      	movs	r1, #10
 800f0da:	4798      	blx	r3
            if(indev_reset_check(&i->proc)) return;
 800f0dc:	687b      	ldr	r3, [r7, #4]
 800f0de:	3320      	adds	r3, #32
 800f0e0:	4618      	mov	r0, r3
 800f0e2:	f001 fab5 	bl	8010650 <indev_reset_check>
 800f0e6:	4603      	mov	r3, r0
 800f0e8:	2b00      	cmp	r3, #0
 800f0ea:	d152      	bne.n	800f192 <indev_keypad_proc+0x416>

            if(i->proc.long_pr_sent == 0) {
 800f0ec:	687b      	ldr	r3, [r7, #4]
 800f0ee:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f0f2:	f003 0301 	and.w	r3, r3, #1
 800f0f6:	b2db      	uxtb	r3, r3
 800f0f8:	2b00      	cmp	r3, #0
 800f0fa:	d10e      	bne.n	800f11a <indev_keypad_proc+0x39e>
                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
 800f0fc:	4b2a      	ldr	r3, [pc, #168]	; (800f1a8 <indev_keypad_proc+0x42c>)
 800f0fe:	681b      	ldr	r3, [r3, #0]
 800f100:	2200      	movs	r2, #0
 800f102:	2103      	movs	r1, #3
 800f104:	4618      	mov	r0, r3
 800f106:	f002 feaa 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800f10a:	687b      	ldr	r3, [r7, #4]
 800f10c:	3320      	adds	r3, #32
 800f10e:	4618      	mov	r0, r3
 800f110:	f001 fa9e 	bl	8010650 <indev_reset_check>
 800f114:	4603      	mov	r3, r0
 800f116:	2b00      	cmp	r3, #0
 800f118:	d13d      	bne.n	800f196 <indev_keypad_proc+0x41a>
            }

            lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
 800f11a:	4b23      	ldr	r3, [pc, #140]	; (800f1a8 <indev_keypad_proc+0x42c>)
 800f11c:	681b      	ldr	r3, [r3, #0]
 800f11e:	2200      	movs	r2, #0
 800f120:	2106      	movs	r1, #6
 800f122:	4618      	mov	r0, r3
 800f124:	f002 fe9b 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800f128:	687b      	ldr	r3, [r7, #4]
 800f12a:	3320      	adds	r3, #32
 800f12c:	4618      	mov	r0, r3
 800f12e:	f001 fa8f 	bl	8010650 <indev_reset_check>
 800f132:	4603      	mov	r3, r0
 800f134:	2b00      	cmp	r3, #0
 800f136:	d130      	bne.n	800f19a <indev_keypad_proc+0x41e>

            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
 800f138:	4b1b      	ldr	r3, [pc, #108]	; (800f1a8 <indev_keypad_proc+0x42c>)
 800f13a:	681b      	ldr	r3, [r3, #0]
 800f13c:	2200      	movs	r2, #0
 800f13e:	2107      	movs	r1, #7
 800f140:	4618      	mov	r0, r3
 800f142:	f002 fe8c 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800f146:	687b      	ldr	r3, [r7, #4]
 800f148:	3320      	adds	r3, #32
 800f14a:	4618      	mov	r0, r3
 800f14c:	f001 fa80 	bl	8010650 <indev_reset_check>
 800f150:	4603      	mov	r3, r0
 800f152:	2b00      	cmp	r3, #0
 800f154:	d123      	bne.n	800f19e <indev_keypad_proc+0x422>
        }
        i->proc.pr_timestamp = 0;
 800f156:	687b      	ldr	r3, [r7, #4]
 800f158:	2200      	movs	r2, #0
 800f15a:	649a      	str	r2, [r3, #72]	; 0x48
        i->proc.long_pr_sent = 0;
 800f15c:	687a      	ldr	r2, [r7, #4]
 800f15e:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800f162:	f36f 0300 	bfc	r3, #0, #1
 800f166:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
 800f16a:	e002      	b.n	800f172 <indev_keypad_proc+0x3f6>
        if(data->key == LV_KEY_ENTER) {
 800f16c:	bf00      	nop
 800f16e:	e000      	b.n	800f172 <indev_keypad_proc+0x3f6>
        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver.long_press_time) {
 800f170:	bf00      	nop
    }
    indev_obj_act = NULL;
 800f172:	4b0d      	ldr	r3, [pc, #52]	; (800f1a8 <indev_keypad_proc+0x42c>)
 800f174:	2200      	movs	r2, #0
 800f176:	601a      	str	r2, [r3, #0]
 800f178:	e012      	b.n	800f1a0 <indev_keypad_proc+0x424>
    if(data->state == LV_INDEV_STATE_PR && i->proc.wait_until_release) return;
 800f17a:	bf00      	nop
 800f17c:	e010      	b.n	800f1a0 <indev_keypad_proc+0x424>
    if(g == NULL) return;
 800f17e:	bf00      	nop
 800f180:	e00e      	b.n	800f1a0 <indev_keypad_proc+0x424>
    if(indev_obj_act == NULL) return;
 800f182:	bf00      	nop
 800f184:	e00c      	b.n	800f1a0 <indev_keypad_proc+0x424>
            if(indev_reset_check(&i->proc)) return;
 800f186:	bf00      	nop
 800f188:	e00a      	b.n	800f1a0 <indev_keypad_proc+0x424>
                if(indev_reset_check(&i->proc)) return;
 800f18a:	bf00      	nop
 800f18c:	e008      	b.n	800f1a0 <indev_keypad_proc+0x424>
                if(indev_reset_check(&i->proc)) return;
 800f18e:	bf00      	nop
 800f190:	e006      	b.n	800f1a0 <indev_keypad_proc+0x424>
            if(indev_reset_check(&i->proc)) return;
 800f192:	bf00      	nop
 800f194:	e004      	b.n	800f1a0 <indev_keypad_proc+0x424>
                if(indev_reset_check(&i->proc)) return;
 800f196:	bf00      	nop
 800f198:	e002      	b.n	800f1a0 <indev_keypad_proc+0x424>
            if(indev_reset_check(&i->proc)) return;
 800f19a:	bf00      	nop
 800f19c:	e000      	b.n	800f1a0 <indev_keypad_proc+0x424>
            if(indev_reset_check(&i->proc)) return;
 800f19e:	bf00      	nop
#else
    (void)data; /*Unused*/
    (void)i;    /*Unused*/
#endif
}
 800f1a0:	3718      	adds	r7, #24
 800f1a2:	46bd      	mov	sp, r7
 800f1a4:	bd80      	pop	{r7, pc}
 800f1a6:	bf00      	nop
 800f1a8:	20003f98 	.word	0x20003f98

0800f1ac <indev_encoder_proc>:
 * Process a new point from LV_INDEV_TYPE_ENCODER input device
 * @param i pointer to an input device
 * @param data pointer to the data read from the input device
 */
static void indev_encoder_proc(lv_indev_t * i, lv_indev_data_t * data)
{
 800f1ac:	b580      	push	{r7, lr}
 800f1ae:	b088      	sub	sp, #32
 800f1b0:	af00      	add	r7, sp, #0
 800f1b2:	6078      	str	r0, [r7, #4]
 800f1b4:	6039      	str	r1, [r7, #0]
#if LV_USE_GROUP

    if(data->state == LV_INDEV_STATE_PR && i->proc.wait_until_release) return;
 800f1b6:	683b      	ldr	r3, [r7, #0]
 800f1b8:	7b9b      	ldrb	r3, [r3, #14]
 800f1ba:	2b01      	cmp	r3, #1
 800f1bc:	d108      	bne.n	800f1d0 <indev_encoder_proc+0x24>
 800f1be:	687b      	ldr	r3, [r7, #4]
 800f1c0:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f1c4:	f003 0308 	and.w	r3, r3, #8
 800f1c8:	b2db      	uxtb	r3, r3
 800f1ca:	2b00      	cmp	r3, #0
 800f1cc:	f040 8241 	bne.w	800f652 <indev_encoder_proc+0x4a6>

    if(i->proc.wait_until_release) {
 800f1d0:	687b      	ldr	r3, [r7, #4]
 800f1d2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f1d6:	f003 0308 	and.w	r3, r3, #8
 800f1da:	b2db      	uxtb	r3, r3
 800f1dc:	2b00      	cmp	r3, #0
 800f1de:	d014      	beq.n	800f20a <indev_encoder_proc+0x5e>
        i->proc.wait_until_release      = 0;
 800f1e0:	687a      	ldr	r2, [r7, #4]
 800f1e2:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800f1e6:	f36f 03c3 	bfc	r3, #3, #1
 800f1ea:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        i->proc.pr_timestamp            = 0;
 800f1ee:	687b      	ldr	r3, [r7, #4]
 800f1f0:	2200      	movs	r2, #0
 800f1f2:	649a      	str	r2, [r3, #72]	; 0x48
        i->proc.long_pr_sent            = 0;
 800f1f4:	687a      	ldr	r2, [r7, #4]
 800f1f6:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800f1fa:	f36f 0300 	bfc	r3, #0, #1
 800f1fe:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        i->proc.types.keypad.last_state = LV_INDEV_STATE_REL; /*To skip the processing of release*/
 800f202:	687b      	ldr	r3, [r7, #4]
 800f204:	2200      	movs	r2, #0
 800f206:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    }

    /* Save the last keys before anything else.
     * They need to be already saved if the the function returns for any reason*/
    lv_indev_state_t last_state     = i->proc.types.keypad.last_state;
 800f20a:	687b      	ldr	r3, [r7, #4]
 800f20c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800f210:	75fb      	strb	r3, [r7, #23]
    i->proc.types.keypad.last_state = data->state;
 800f212:	683b      	ldr	r3, [r7, #0]
 800f214:	7b9a      	ldrb	r2, [r3, #14]
 800f216:	687b      	ldr	r3, [r7, #4]
 800f218:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    i->proc.types.keypad.last_key   = data->key;
 800f21c:	683b      	ldr	r3, [r7, #0]
 800f21e:	685a      	ldr	r2, [r3, #4]
 800f220:	687b      	ldr	r3, [r7, #4]
 800f222:	629a      	str	r2, [r3, #40]	; 0x28

    lv_group_t * g = i->group;
 800f224:	687b      	ldr	r3, [r7, #4]
 800f226:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800f228:	613b      	str	r3, [r7, #16]
    if(g == NULL) return;
 800f22a:	693b      	ldr	r3, [r7, #16]
 800f22c:	2b00      	cmp	r3, #0
 800f22e:	f000 8212 	beq.w	800f656 <indev_encoder_proc+0x4aa>

    indev_obj_act = lv_group_get_focused(g);
 800f232:	6938      	ldr	r0, [r7, #16]
 800f234:	f7ff f912 	bl	800e45c <lv_group_get_focused>
 800f238:	4602      	mov	r2, r0
 800f23a:	4b92      	ldr	r3, [pc, #584]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f23c:	601a      	str	r2, [r3, #0]
    if(indev_obj_act == NULL) return;
 800f23e:	4b91      	ldr	r3, [pc, #580]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f240:	681b      	ldr	r3, [r3, #0]
 800f242:	2b00      	cmp	r3, #0
 800f244:	f000 8209 	beq.w	800f65a <indev_encoder_proc+0x4ae>

    /*Process the steps first. They are valid only with released button*/
    if(data->state == LV_INDEV_STATE_REL) {
 800f248:	683b      	ldr	r3, [r7, #0]
 800f24a:	7b9b      	ldrb	r3, [r3, #14]
 800f24c:	2b00      	cmp	r3, #0
 800f24e:	d15e      	bne.n	800f30e <indev_encoder_proc+0x162>
        /*In edit mode send LEFT/RIGHT keys*/
        if(lv_group_get_editing(g)) {
 800f250:	6938      	ldr	r0, [r7, #16]
 800f252:	f7ff f91b 	bl	800e48c <lv_group_get_editing>
 800f256:	4603      	mov	r3, r0
 800f258:	2b00      	cmp	r3, #0
 800f25a:	d02d      	beq.n	800f2b8 <indev_encoder_proc+0x10c>
            int32_t s;
            if(data->enc_diff < 0) {
 800f25c:	683b      	ldr	r3, [r7, #0]
 800f25e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f262:	2b00      	cmp	r3, #0
 800f264:	da11      	bge.n	800f28a <indev_encoder_proc+0xde>
                for(s = 0; s < -data->enc_diff; s++) lv_group_send_data(g, LV_KEY_LEFT);
 800f266:	2300      	movs	r3, #0
 800f268:	61fb      	str	r3, [r7, #28]
 800f26a:	e006      	b.n	800f27a <indev_encoder_proc+0xce>
 800f26c:	2114      	movs	r1, #20
 800f26e:	6938      	ldr	r0, [r7, #16]
 800f270:	f7ff f856 	bl	800e320 <lv_group_send_data>
 800f274:	69fb      	ldr	r3, [r7, #28]
 800f276:	3301      	adds	r3, #1
 800f278:	61fb      	str	r3, [r7, #28]
 800f27a:	683b      	ldr	r3, [r7, #0]
 800f27c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f280:	425b      	negs	r3, r3
 800f282:	69fa      	ldr	r2, [r7, #28]
 800f284:	429a      	cmp	r2, r3
 800f286:	dbf1      	blt.n	800f26c <indev_encoder_proc+0xc0>
 800f288:	e041      	b.n	800f30e <indev_encoder_proc+0x162>
            } else if(data->enc_diff > 0) {
 800f28a:	683b      	ldr	r3, [r7, #0]
 800f28c:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f290:	2b00      	cmp	r3, #0
 800f292:	dd3c      	ble.n	800f30e <indev_encoder_proc+0x162>
                for(s = 0; s < data->enc_diff; s++) lv_group_send_data(g, LV_KEY_RIGHT);
 800f294:	2300      	movs	r3, #0
 800f296:	61fb      	str	r3, [r7, #28]
 800f298:	e006      	b.n	800f2a8 <indev_encoder_proc+0xfc>
 800f29a:	2113      	movs	r1, #19
 800f29c:	6938      	ldr	r0, [r7, #16]
 800f29e:	f7ff f83f 	bl	800e320 <lv_group_send_data>
 800f2a2:	69fb      	ldr	r3, [r7, #28]
 800f2a4:	3301      	adds	r3, #1
 800f2a6:	61fb      	str	r3, [r7, #28]
 800f2a8:	683b      	ldr	r3, [r7, #0]
 800f2aa:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f2ae:	461a      	mov	r2, r3
 800f2b0:	69fb      	ldr	r3, [r7, #28]
 800f2b2:	4293      	cmp	r3, r2
 800f2b4:	dbf1      	blt.n	800f29a <indev_encoder_proc+0xee>
 800f2b6:	e02a      	b.n	800f30e <indev_encoder_proc+0x162>
            }
        }
        /*In navigate mode focus on the next/prev objects*/
        else {
            int32_t s;
            if(data->enc_diff < 0) {
 800f2b8:	683b      	ldr	r3, [r7, #0]
 800f2ba:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f2be:	2b00      	cmp	r3, #0
 800f2c0:	da10      	bge.n	800f2e4 <indev_encoder_proc+0x138>
                for(s = 0; s < -data->enc_diff; s++) lv_group_focus_prev(g);
 800f2c2:	2300      	movs	r3, #0
 800f2c4:	61bb      	str	r3, [r7, #24]
 800f2c6:	e005      	b.n	800f2d4 <indev_encoder_proc+0x128>
 800f2c8:	6938      	ldr	r0, [r7, #16]
 800f2ca:	f7ff f817 	bl	800e2fc <lv_group_focus_prev>
 800f2ce:	69bb      	ldr	r3, [r7, #24]
 800f2d0:	3301      	adds	r3, #1
 800f2d2:	61bb      	str	r3, [r7, #24]
 800f2d4:	683b      	ldr	r3, [r7, #0]
 800f2d6:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f2da:	425b      	negs	r3, r3
 800f2dc:	69ba      	ldr	r2, [r7, #24]
 800f2de:	429a      	cmp	r2, r3
 800f2e0:	dbf2      	blt.n	800f2c8 <indev_encoder_proc+0x11c>
 800f2e2:	e014      	b.n	800f30e <indev_encoder_proc+0x162>
            } else if(data->enc_diff > 0) {
 800f2e4:	683b      	ldr	r3, [r7, #0]
 800f2e6:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f2ea:	2b00      	cmp	r3, #0
 800f2ec:	dd0f      	ble.n	800f30e <indev_encoder_proc+0x162>
                for(s = 0; s < data->enc_diff; s++) lv_group_focus_next(g);
 800f2ee:	2300      	movs	r3, #0
 800f2f0:	61bb      	str	r3, [r7, #24]
 800f2f2:	e005      	b.n	800f300 <indev_encoder_proc+0x154>
 800f2f4:	6938      	ldr	r0, [r7, #16]
 800f2f6:	f7fe ffef 	bl	800e2d8 <lv_group_focus_next>
 800f2fa:	69bb      	ldr	r3, [r7, #24]
 800f2fc:	3301      	adds	r3, #1
 800f2fe:	61bb      	str	r3, [r7, #24]
 800f300:	683b      	ldr	r3, [r7, #0]
 800f302:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800f306:	461a      	mov	r2, r3
 800f308:	69bb      	ldr	r3, [r7, #24]
 800f30a:	4293      	cmp	r3, r2
 800f30c:	dbf2      	blt.n	800f2f4 <indev_encoder_proc+0x148>
            }
        }
    }

    /*Refresh the focused object. It might change due to lv_group_focus_prev/next*/
    indev_obj_act = lv_group_get_focused(g);
 800f30e:	6938      	ldr	r0, [r7, #16]
 800f310:	f7ff f8a4 	bl	800e45c <lv_group_get_focused>
 800f314:	4602      	mov	r2, r0
 800f316:	4b5b      	ldr	r3, [pc, #364]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f318:	601a      	str	r2, [r3, #0]
    if(indev_obj_act == NULL) return;
 800f31a:	4b5a      	ldr	r3, [pc, #360]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f31c:	681b      	ldr	r3, [r3, #0]
 800f31e:	2b00      	cmp	r3, #0
 800f320:	f000 819d 	beq.w	800f65e <indev_encoder_proc+0x4b2>

    /*Button press happened*/
    if(data->state == LV_INDEV_STATE_PR && last_state == LV_INDEV_STATE_REL) {
 800f324:	683b      	ldr	r3, [r7, #0]
 800f326:	7b9b      	ldrb	r3, [r3, #14]
 800f328:	2b01      	cmp	r3, #1
 800f32a:	d142      	bne.n	800f3b2 <indev_encoder_proc+0x206>
 800f32c:	7dfb      	ldrb	r3, [r7, #23]
 800f32e:	2b00      	cmp	r3, #0
 800f330:	d13f      	bne.n	800f3b2 <indev_encoder_proc+0x206>
        bool editable = false;
 800f332:	2300      	movs	r3, #0
 800f334:	73fb      	strb	r3, [r7, #15]
        indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_GET_EDITABLE, &editable);
 800f336:	4b53      	ldr	r3, [pc, #332]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f338:	681b      	ldr	r3, [r3, #0]
 800f33a:	69db      	ldr	r3, [r3, #28]
 800f33c:	4a51      	ldr	r2, [pc, #324]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f33e:	6810      	ldr	r0, [r2, #0]
 800f340:	f107 020f 	add.w	r2, r7, #15
 800f344:	2112      	movs	r1, #18
 800f346:	4798      	blx	r3

        i->proc.pr_timestamp = lv_tick_get();
 800f348:	f00c f8b0 	bl	801b4ac <lv_tick_get>
 800f34c:	4602      	mov	r2, r0
 800f34e:	687b      	ldr	r3, [r7, #4]
 800f350:	649a      	str	r2, [r3, #72]	; 0x48
        if(lv_group_get_editing(g) == true || editable == false) {
 800f352:	6938      	ldr	r0, [r7, #16]
 800f354:	f7ff f89a 	bl	800e48c <lv_group_get_editing>
 800f358:	4603      	mov	r3, r0
 800f35a:	2b00      	cmp	r3, #0
 800f35c:	d106      	bne.n	800f36c <indev_encoder_proc+0x1c0>
 800f35e:	7bfb      	ldrb	r3, [r7, #15]
 800f360:	f083 0301 	eor.w	r3, r3, #1
 800f364:	b2db      	uxtb	r3, r3
 800f366:	2b00      	cmp	r3, #0
 800f368:	f000 816c 	beq.w	800f644 <indev_encoder_proc+0x498>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSED, NULL);
 800f36c:	4b45      	ldr	r3, [pc, #276]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f36e:	681b      	ldr	r3, [r3, #0]
 800f370:	69db      	ldr	r3, [r3, #28]
 800f372:	4a44      	ldr	r2, [pc, #272]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f374:	6810      	ldr	r0, [r2, #0]
 800f376:	2200      	movs	r2, #0
 800f378:	2107      	movs	r1, #7
 800f37a:	4798      	blx	r3
            if(indev_reset_check(&i->proc)) return;
 800f37c:	687b      	ldr	r3, [r7, #4]
 800f37e:	3320      	adds	r3, #32
 800f380:	4618      	mov	r0, r3
 800f382:	f001 f965 	bl	8010650 <indev_reset_check>
 800f386:	4603      	mov	r3, r0
 800f388:	2b00      	cmp	r3, #0
 800f38a:	f040 816a 	bne.w	800f662 <indev_encoder_proc+0x4b6>

            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, NULL);
 800f38e:	4b3d      	ldr	r3, [pc, #244]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f390:	681b      	ldr	r3, [r3, #0]
 800f392:	2200      	movs	r2, #0
 800f394:	2100      	movs	r1, #0
 800f396:	4618      	mov	r0, r3
 800f398:	f002 fd61 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800f39c:	687b      	ldr	r3, [r7, #4]
 800f39e:	3320      	adds	r3, #32
 800f3a0:	4618      	mov	r0, r3
 800f3a2:	f001 f955 	bl	8010650 <indev_reset_check>
 800f3a6:	4603      	mov	r3, r0
 800f3a8:	2b00      	cmp	r3, #0
 800f3aa:	f000 814b 	beq.w	800f644 <indev_encoder_proc+0x498>
 800f3ae:	bf00      	nop
 800f3b0:	e16a      	b.n	800f688 <indev_encoder_proc+0x4dc>
        }
    }
    /*Pressing*/
    else if(data->state == LV_INDEV_STATE_PR && last_state == LV_INDEV_STATE_PR) {
 800f3b2:	683b      	ldr	r3, [r7, #0]
 800f3b4:	7b9b      	ldrb	r3, [r3, #14]
 800f3b6:	2b01      	cmp	r3, #1
 800f3b8:	d166      	bne.n	800f488 <indev_encoder_proc+0x2dc>
 800f3ba:	7dfb      	ldrb	r3, [r7, #23]
 800f3bc:	2b01      	cmp	r3, #1
 800f3be:	d163      	bne.n	800f488 <indev_encoder_proc+0x2dc>
        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver.long_press_time) {
 800f3c0:	687b      	ldr	r3, [r7, #4]
 800f3c2:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f3c6:	f003 0301 	and.w	r3, r3, #1
 800f3ca:	b2db      	uxtb	r3, r3
 800f3cc:	2b00      	cmp	r3, #0
 800f3ce:	f040 813b 	bne.w	800f648 <indev_encoder_proc+0x49c>
 800f3d2:	687b      	ldr	r3, [r7, #4]
 800f3d4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800f3d6:	4618      	mov	r0, r3
 800f3d8:	f00c f882 	bl	801b4e0 <lv_tick_elaps>
 800f3dc:	4602      	mov	r2, r0
 800f3de:	687b      	ldr	r3, [r7, #4]
 800f3e0:	8b5b      	ldrh	r3, [r3, #26]
 800f3e2:	429a      	cmp	r2, r3
 800f3e4:	f240 8130 	bls.w	800f648 <indev_encoder_proc+0x49c>
            bool editable = false;
 800f3e8:	2300      	movs	r3, #0
 800f3ea:	73bb      	strb	r3, [r7, #14]
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_GET_EDITABLE, &editable);
 800f3ec:	4b25      	ldr	r3, [pc, #148]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f3ee:	681b      	ldr	r3, [r3, #0]
 800f3f0:	69db      	ldr	r3, [r3, #28]
 800f3f2:	4a24      	ldr	r2, [pc, #144]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f3f4:	6810      	ldr	r0, [r2, #0]
 800f3f6:	f107 020e 	add.w	r2, r7, #14
 800f3fa:	2112      	movs	r1, #18
 800f3fc:	4798      	blx	r3

            /*On enter long press toggle edit mode.*/
            if(editable) {
 800f3fe:	7bbb      	ldrb	r3, [r7, #14]
 800f400:	2b00      	cmp	r3, #0
 800f402:	d015      	beq.n	800f430 <indev_encoder_proc+0x284>
                /*Don't leave edit mode if there is only one object (nowhere to navigate)*/
                if(lv_ll_is_empty(&g->obj_ll) == false) {
 800f404:	693b      	ldr	r3, [r7, #16]
 800f406:	4618      	mov	r0, r3
 800f408:	f00d f997 	bl	801c73a <lv_ll_is_empty>
 800f40c:	4603      	mov	r3, r0
 800f40e:	f083 0301 	eor.w	r3, r3, #1
 800f412:	b2db      	uxtb	r3, r3
 800f414:	2b00      	cmp	r3, #0
 800f416:	d02c      	beq.n	800f472 <indev_encoder_proc+0x2c6>
                    lv_group_set_editing(g, lv_group_get_editing(g) ? false : true); /*Toggle edit mode on long press*/
 800f418:	6938      	ldr	r0, [r7, #16]
 800f41a:	f7ff f837 	bl	800e48c <lv_group_get_editing>
 800f41e:	4603      	mov	r3, r0
 800f420:	f083 0301 	eor.w	r3, r3, #1
 800f424:	b2db      	uxtb	r3, r3
 800f426:	4619      	mov	r1, r3
 800f428:	6938      	ldr	r0, [r7, #16]
 800f42a:	f7fe ffa6 	bl	800e37a <lv_group_set_editing>
 800f42e:	e020      	b.n	800f472 <indev_encoder_proc+0x2c6>
                }
            }
            /*If not editable then just send a long press signal*/
            else {
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS, NULL);
 800f430:	4b14      	ldr	r3, [pc, #80]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f432:	681b      	ldr	r3, [r3, #0]
 800f434:	69db      	ldr	r3, [r3, #28]
 800f436:	4a13      	ldr	r2, [pc, #76]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f438:	6810      	ldr	r0, [r2, #0]
 800f43a:	2200      	movs	r2, #0
 800f43c:	210b      	movs	r1, #11
 800f43e:	4798      	blx	r3
                if(indev_reset_check(&i->proc)) return;
 800f440:	687b      	ldr	r3, [r7, #4]
 800f442:	3320      	adds	r3, #32
 800f444:	4618      	mov	r0, r3
 800f446:	f001 f903 	bl	8010650 <indev_reset_check>
 800f44a:	4603      	mov	r3, r0
 800f44c:	2b00      	cmp	r3, #0
 800f44e:	f040 810a 	bne.w	800f666 <indev_encoder_proc+0x4ba>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, NULL);
 800f452:	4b0c      	ldr	r3, [pc, #48]	; (800f484 <indev_encoder_proc+0x2d8>)
 800f454:	681b      	ldr	r3, [r3, #0]
 800f456:	2200      	movs	r2, #0
 800f458:	2104      	movs	r1, #4
 800f45a:	4618      	mov	r0, r3
 800f45c:	f002 fcff 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800f460:	687b      	ldr	r3, [r7, #4]
 800f462:	3320      	adds	r3, #32
 800f464:	4618      	mov	r0, r3
 800f466:	f001 f8f3 	bl	8010650 <indev_reset_check>
 800f46a:	4603      	mov	r3, r0
 800f46c:	2b00      	cmp	r3, #0
 800f46e:	f040 80fc 	bne.w	800f66a <indev_encoder_proc+0x4be>
            }
            i->proc.long_pr_sent = 1;
 800f472:	687a      	ldr	r2, [r7, #4]
 800f474:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800f478:	f043 0301 	orr.w	r3, r3, #1
 800f47c:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver.long_press_time) {
 800f480:	e0e2      	b.n	800f648 <indev_encoder_proc+0x49c>
 800f482:	bf00      	nop
 800f484:	20003f98 	.word	0x20003f98
        }
    }
    /*Release happened*/
    else if(data->state == LV_INDEV_STATE_REL && last_state == LV_INDEV_STATE_PR) {
 800f488:	683b      	ldr	r3, [r7, #0]
 800f48a:	7b9b      	ldrb	r3, [r3, #14]
 800f48c:	2b00      	cmp	r3, #0
 800f48e:	f040 80dc 	bne.w	800f64a <indev_encoder_proc+0x49e>
 800f492:	7dfb      	ldrb	r3, [r7, #23]
 800f494:	2b01      	cmp	r3, #1
 800f496:	f040 80d8 	bne.w	800f64a <indev_encoder_proc+0x49e>

        bool editable = false;
 800f49a:	2300      	movs	r3, #0
 800f49c:	737b      	strb	r3, [r7, #13]
        indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_GET_EDITABLE, &editable);
 800f49e:	4b7c      	ldr	r3, [pc, #496]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f4a0:	681b      	ldr	r3, [r3, #0]
 800f4a2:	69db      	ldr	r3, [r3, #28]
 800f4a4:	4a7a      	ldr	r2, [pc, #488]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f4a6:	6810      	ldr	r0, [r2, #0]
 800f4a8:	f107 020d 	add.w	r2, r7, #13
 800f4ac:	2112      	movs	r1, #18
 800f4ae:	4798      	blx	r3

        /*The button was released on a non-editable object. Just send enter*/
        if(editable == false) {
 800f4b0:	7b7b      	ldrb	r3, [r7, #13]
 800f4b2:	f083 0301 	eor.w	r3, r3, #1
 800f4b6:	b2db      	uxtb	r3, r3
 800f4b8:	2b00      	cmp	r3, #0
 800f4ba:	d048      	beq.n	800f54e <indev_encoder_proc+0x3a2>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, NULL);
 800f4bc:	4b74      	ldr	r3, [pc, #464]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f4be:	681b      	ldr	r3, [r3, #0]
 800f4c0:	69db      	ldr	r3, [r3, #28]
 800f4c2:	4a73      	ldr	r2, [pc, #460]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f4c4:	6810      	ldr	r0, [r2, #0]
 800f4c6:	2200      	movs	r2, #0
 800f4c8:	210a      	movs	r1, #10
 800f4ca:	4798      	blx	r3
            if(indev_reset_check(&i->proc)) return;
 800f4cc:	687b      	ldr	r3, [r7, #4]
 800f4ce:	3320      	adds	r3, #32
 800f4d0:	4618      	mov	r0, r3
 800f4d2:	f001 f8bd 	bl	8010650 <indev_reset_check>
 800f4d6:	4603      	mov	r3, r0
 800f4d8:	2b00      	cmp	r3, #0
 800f4da:	f040 80c8 	bne.w	800f66e <indev_encoder_proc+0x4c2>

            if(i->proc.long_pr_sent == 0) lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
 800f4de:	687b      	ldr	r3, [r7, #4]
 800f4e0:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f4e4:	f003 0301 	and.w	r3, r3, #1
 800f4e8:	b2db      	uxtb	r3, r3
 800f4ea:	2b00      	cmp	r3, #0
 800f4ec:	d106      	bne.n	800f4fc <indev_encoder_proc+0x350>
 800f4ee:	4b68      	ldr	r3, [pc, #416]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f4f0:	681b      	ldr	r3, [r3, #0]
 800f4f2:	2200      	movs	r2, #0
 800f4f4:	2103      	movs	r1, #3
 800f4f6:	4618      	mov	r0, r3
 800f4f8:	f002 fcb1 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800f4fc:	687b      	ldr	r3, [r7, #4]
 800f4fe:	3320      	adds	r3, #32
 800f500:	4618      	mov	r0, r3
 800f502:	f001 f8a5 	bl	8010650 <indev_reset_check>
 800f506:	4603      	mov	r3, r0
 800f508:	2b00      	cmp	r3, #0
 800f50a:	f040 80b2 	bne.w	800f672 <indev_encoder_proc+0x4c6>

            lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
 800f50e:	4b60      	ldr	r3, [pc, #384]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f510:	681b      	ldr	r3, [r3, #0]
 800f512:	2200      	movs	r2, #0
 800f514:	2106      	movs	r1, #6
 800f516:	4618      	mov	r0, r3
 800f518:	f002 fca1 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800f51c:	687b      	ldr	r3, [r7, #4]
 800f51e:	3320      	adds	r3, #32
 800f520:	4618      	mov	r0, r3
 800f522:	f001 f895 	bl	8010650 <indev_reset_check>
 800f526:	4603      	mov	r3, r0
 800f528:	2b00      	cmp	r3, #0
 800f52a:	f040 80a4 	bne.w	800f676 <indev_encoder_proc+0x4ca>

            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
 800f52e:	4b58      	ldr	r3, [pc, #352]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f530:	681b      	ldr	r3, [r3, #0]
 800f532:	2200      	movs	r2, #0
 800f534:	2107      	movs	r1, #7
 800f536:	4618      	mov	r0, r3
 800f538:	f002 fc91 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(&i->proc)) return;
 800f53c:	687b      	ldr	r3, [r7, #4]
 800f53e:	3320      	adds	r3, #32
 800f540:	4618      	mov	r0, r3
 800f542:	f001 f885 	bl	8010650 <indev_reset_check>
 800f546:	4603      	mov	r3, r0
 800f548:	2b00      	cmp	r3, #0
 800f54a:	d070      	beq.n	800f62e <indev_encoder_proc+0x482>
 800f54c:	e09c      	b.n	800f688 <indev_encoder_proc+0x4dc>
        }
        /*An object is being edited and the button is released. */
        else if(g->editing) {
 800f54e:	693b      	ldr	r3, [r7, #16]
 800f550:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800f554:	f003 0302 	and.w	r3, r3, #2
 800f558:	b2db      	uxtb	r3, r3
 800f55a:	2b00      	cmp	r3, #0
 800f55c:	d050      	beq.n	800f600 <indev_encoder_proc+0x454>
            /*Ignore long pressed enter release because it comes from mode switch*/
            if(!i->proc.long_pr_sent || lv_ll_is_empty(&g->obj_ll)) {
 800f55e:	687b      	ldr	r3, [r7, #4]
 800f560:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f564:	f003 0301 	and.w	r3, r3, #1
 800f568:	b2db      	uxtb	r3, r3
 800f56a:	2b00      	cmp	r3, #0
 800f56c:	d006      	beq.n	800f57c <indev_encoder_proc+0x3d0>
 800f56e:	693b      	ldr	r3, [r7, #16]
 800f570:	4618      	mov	r0, r3
 800f572:	f00d f8e2 	bl	801c73a <lv_ll_is_empty>
 800f576:	4603      	mov	r3, r0
 800f578:	2b00      	cmp	r3, #0
 800f57a:	d058      	beq.n	800f62e <indev_encoder_proc+0x482>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, NULL);
 800f57c:	4b44      	ldr	r3, [pc, #272]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f57e:	681b      	ldr	r3, [r3, #0]
 800f580:	69db      	ldr	r3, [r3, #28]
 800f582:	4a43      	ldr	r2, [pc, #268]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f584:	6810      	ldr	r0, [r2, #0]
 800f586:	2200      	movs	r2, #0
 800f588:	210a      	movs	r1, #10
 800f58a:	4798      	blx	r3
                if(indev_reset_check(&i->proc)) return;
 800f58c:	687b      	ldr	r3, [r7, #4]
 800f58e:	3320      	adds	r3, #32
 800f590:	4618      	mov	r0, r3
 800f592:	f001 f85d 	bl	8010650 <indev_reset_check>
 800f596:	4603      	mov	r3, r0
 800f598:	2b00      	cmp	r3, #0
 800f59a:	d16e      	bne.n	800f67a <indev_encoder_proc+0x4ce>

                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
 800f59c:	4b3c      	ldr	r3, [pc, #240]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f59e:	681b      	ldr	r3, [r3, #0]
 800f5a0:	2200      	movs	r2, #0
 800f5a2:	2103      	movs	r1, #3
 800f5a4:	4618      	mov	r0, r3
 800f5a6:	f002 fc5a 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800f5aa:	687b      	ldr	r3, [r7, #4]
 800f5ac:	3320      	adds	r3, #32
 800f5ae:	4618      	mov	r0, r3
 800f5b0:	f001 f84e 	bl	8010650 <indev_reset_check>
 800f5b4:	4603      	mov	r3, r0
 800f5b6:	2b00      	cmp	r3, #0
 800f5b8:	d161      	bne.n	800f67e <indev_encoder_proc+0x4d2>

                lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
 800f5ba:	4b35      	ldr	r3, [pc, #212]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f5bc:	681b      	ldr	r3, [r3, #0]
 800f5be:	2200      	movs	r2, #0
 800f5c0:	2106      	movs	r1, #6
 800f5c2:	4618      	mov	r0, r3
 800f5c4:	f002 fc4b 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800f5c8:	687b      	ldr	r3, [r7, #4]
 800f5ca:	3320      	adds	r3, #32
 800f5cc:	4618      	mov	r0, r3
 800f5ce:	f001 f83f 	bl	8010650 <indev_reset_check>
 800f5d2:	4603      	mov	r3, r0
 800f5d4:	2b00      	cmp	r3, #0
 800f5d6:	d154      	bne.n	800f682 <indev_encoder_proc+0x4d6>

                lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
 800f5d8:	4b2d      	ldr	r3, [pc, #180]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f5da:	681b      	ldr	r3, [r3, #0]
 800f5dc:	2200      	movs	r2, #0
 800f5de:	2107      	movs	r1, #7
 800f5e0:	4618      	mov	r0, r3
 800f5e2:	f002 fc3c 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(&i->proc)) return;
 800f5e6:	687b      	ldr	r3, [r7, #4]
 800f5e8:	3320      	adds	r3, #32
 800f5ea:	4618      	mov	r0, r3
 800f5ec:	f001 f830 	bl	8010650 <indev_reset_check>
 800f5f0:	4603      	mov	r3, r0
 800f5f2:	2b00      	cmp	r3, #0
 800f5f4:	d147      	bne.n	800f686 <indev_encoder_proc+0x4da>

                lv_group_send_data(g, LV_KEY_ENTER);
 800f5f6:	210a      	movs	r1, #10
 800f5f8:	6938      	ldr	r0, [r7, #16]
 800f5fa:	f7fe fe91 	bl	800e320 <lv_group_send_data>
 800f5fe:	e016      	b.n	800f62e <indev_encoder_proc+0x482>
            }
        }
        /*If the focused object is editable and now in navigate mode then on enter switch edit
           mode*/
        else if(editable && !g->editing && !i->proc.long_pr_sent) {
 800f600:	7b7b      	ldrb	r3, [r7, #13]
 800f602:	2b00      	cmp	r3, #0
 800f604:	d013      	beq.n	800f62e <indev_encoder_proc+0x482>
 800f606:	693b      	ldr	r3, [r7, #16]
 800f608:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800f60c:	f003 0302 	and.w	r3, r3, #2
 800f610:	b2db      	uxtb	r3, r3
 800f612:	2b00      	cmp	r3, #0
 800f614:	d10b      	bne.n	800f62e <indev_encoder_proc+0x482>
 800f616:	687b      	ldr	r3, [r7, #4]
 800f618:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800f61c:	f003 0301 	and.w	r3, r3, #1
 800f620:	b2db      	uxtb	r3, r3
 800f622:	2b00      	cmp	r3, #0
 800f624:	d103      	bne.n	800f62e <indev_encoder_proc+0x482>
            lv_group_set_editing(g, true); /*Set edit mode*/
 800f626:	2101      	movs	r1, #1
 800f628:	6938      	ldr	r0, [r7, #16]
 800f62a:	f7fe fea6 	bl	800e37a <lv_group_set_editing>
        }

        i->proc.pr_timestamp = 0;
 800f62e:	687b      	ldr	r3, [r7, #4]
 800f630:	2200      	movs	r2, #0
 800f632:	649a      	str	r2, [r3, #72]	; 0x48
        i->proc.long_pr_sent = 0;
 800f634:	687a      	ldr	r2, [r7, #4]
 800f636:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800f63a:	f36f 0300 	bfc	r3, #0, #1
 800f63e:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
 800f642:	e002      	b.n	800f64a <indev_encoder_proc+0x49e>
    if(data->state == LV_INDEV_STATE_PR && last_state == LV_INDEV_STATE_REL) {
 800f644:	bf00      	nop
 800f646:	e000      	b.n	800f64a <indev_encoder_proc+0x49e>
        if(i->proc.long_pr_sent == 0 && lv_tick_elaps(i->proc.pr_timestamp) > i->driver.long_press_time) {
 800f648:	bf00      	nop
    }
    indev_obj_act = NULL;
 800f64a:	4b11      	ldr	r3, [pc, #68]	; (800f690 <indev_encoder_proc+0x4e4>)
 800f64c:	2200      	movs	r2, #0
 800f64e:	601a      	str	r2, [r3, #0]
 800f650:	e01a      	b.n	800f688 <indev_encoder_proc+0x4dc>
    if(data->state == LV_INDEV_STATE_PR && i->proc.wait_until_release) return;
 800f652:	bf00      	nop
 800f654:	e018      	b.n	800f688 <indev_encoder_proc+0x4dc>
    if(g == NULL) return;
 800f656:	bf00      	nop
 800f658:	e016      	b.n	800f688 <indev_encoder_proc+0x4dc>
    if(indev_obj_act == NULL) return;
 800f65a:	bf00      	nop
 800f65c:	e014      	b.n	800f688 <indev_encoder_proc+0x4dc>
    if(indev_obj_act == NULL) return;
 800f65e:	bf00      	nop
 800f660:	e012      	b.n	800f688 <indev_encoder_proc+0x4dc>
            if(indev_reset_check(&i->proc)) return;
 800f662:	bf00      	nop
 800f664:	e010      	b.n	800f688 <indev_encoder_proc+0x4dc>
                if(indev_reset_check(&i->proc)) return;
 800f666:	bf00      	nop
 800f668:	e00e      	b.n	800f688 <indev_encoder_proc+0x4dc>
                if(indev_reset_check(&i->proc)) return;
 800f66a:	bf00      	nop
 800f66c:	e00c      	b.n	800f688 <indev_encoder_proc+0x4dc>
            if(indev_reset_check(&i->proc)) return;
 800f66e:	bf00      	nop
 800f670:	e00a      	b.n	800f688 <indev_encoder_proc+0x4dc>
            if(indev_reset_check(&i->proc)) return;
 800f672:	bf00      	nop
 800f674:	e008      	b.n	800f688 <indev_encoder_proc+0x4dc>
            if(indev_reset_check(&i->proc)) return;
 800f676:	bf00      	nop
 800f678:	e006      	b.n	800f688 <indev_encoder_proc+0x4dc>
                if(indev_reset_check(&i->proc)) return;
 800f67a:	bf00      	nop
 800f67c:	e004      	b.n	800f688 <indev_encoder_proc+0x4dc>
                if(indev_reset_check(&i->proc)) return;
 800f67e:	bf00      	nop
 800f680:	e002      	b.n	800f688 <indev_encoder_proc+0x4dc>
                if(indev_reset_check(&i->proc)) return;
 800f682:	bf00      	nop
 800f684:	e000      	b.n	800f688 <indev_encoder_proc+0x4dc>
                if(indev_reset_check(&i->proc)) return;
 800f686:	bf00      	nop
#else
    (void)data; /*Unused*/
    (void)i;    /*Unused*/
#endif
}
 800f688:	3720      	adds	r7, #32
 800f68a:	46bd      	mov	sp, r7
 800f68c:	bd80      	pop	{r7, pc}
 800f68e:	bf00      	nop
 800f690:	20003f98 	.word	0x20003f98

0800f694 <indev_button_proc>:
 * @param indev pointer to an input device state
 * @param x x coordinate of the next point
 * @param y y coordinate of the next point
 */
static void indev_button_proc(lv_indev_t * i, lv_indev_data_t * data)
{
 800f694:	b580      	push	{r7, lr}
 800f696:	b082      	sub	sp, #8
 800f698:	af00      	add	r7, sp, #0
 800f69a:	6078      	str	r0, [r7, #4]
 800f69c:	6039      	str	r1, [r7, #0]
    i->proc.types.pointer.act_point.x = i->btn_points[data->btn_id].x;
 800f69e:	687b      	ldr	r3, [r7, #4]
 800f6a0:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800f6a2:	683b      	ldr	r3, [r7, #0]
 800f6a4:	689b      	ldr	r3, [r3, #8]
 800f6a6:	009b      	lsls	r3, r3, #2
 800f6a8:	4413      	add	r3, r2
 800f6aa:	f9b3 2000 	ldrsh.w	r2, [r3]
 800f6ae:	687b      	ldr	r3, [r7, #4]
 800f6b0:	849a      	strh	r2, [r3, #36]	; 0x24
    i->proc.types.pointer.act_point.y = i->btn_points[data->btn_id].y;
 800f6b2:	687b      	ldr	r3, [r7, #4]
 800f6b4:	6dda      	ldr	r2, [r3, #92]	; 0x5c
 800f6b6:	683b      	ldr	r3, [r7, #0]
 800f6b8:	689b      	ldr	r3, [r3, #8]
 800f6ba:	009b      	lsls	r3, r3, #2
 800f6bc:	4413      	add	r3, r2
 800f6be:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800f6c2:	687b      	ldr	r3, [r7, #4]
 800f6c4:	84da      	strh	r2, [r3, #38]	; 0x26

    /*Still the same point is pressed*/
    if(i->proc.types.pointer.last_point.x == i->proc.types.pointer.act_point.x &&
 800f6c6:	687b      	ldr	r3, [r7, #4]
 800f6c8:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 800f6cc:	687b      	ldr	r3, [r7, #4]
 800f6ce:	f9b3 3024 	ldrsh.w	r3, [r3, #36]	; 0x24
 800f6d2:	429a      	cmp	r2, r3
 800f6d4:	d111      	bne.n	800f6fa <indev_button_proc+0x66>
       i->proc.types.pointer.last_point.y == i->proc.types.pointer.act_point.y && data->state == LV_INDEV_STATE_PR) {
 800f6d6:	687b      	ldr	r3, [r7, #4]
 800f6d8:	f9b3 202a 	ldrsh.w	r2, [r3, #42]	; 0x2a
 800f6dc:	687b      	ldr	r3, [r7, #4]
 800f6de:	f9b3 3026 	ldrsh.w	r3, [r3, #38]	; 0x26
    if(i->proc.types.pointer.last_point.x == i->proc.types.pointer.act_point.x &&
 800f6e2:	429a      	cmp	r2, r3
 800f6e4:	d109      	bne.n	800f6fa <indev_button_proc+0x66>
       i->proc.types.pointer.last_point.y == i->proc.types.pointer.act_point.y && data->state == LV_INDEV_STATE_PR) {
 800f6e6:	683b      	ldr	r3, [r7, #0]
 800f6e8:	7b9b      	ldrb	r3, [r3, #14]
 800f6ea:	2b01      	cmp	r3, #1
 800f6ec:	d105      	bne.n	800f6fa <indev_button_proc+0x66>
        indev_proc_press(&i->proc);
 800f6ee:	687b      	ldr	r3, [r7, #4]
 800f6f0:	3320      	adds	r3, #32
 800f6f2:	4618      	mov	r0, r3
 800f6f4:	f000 f814 	bl	800f720 <indev_proc_press>
 800f6f8:	e004      	b.n	800f704 <indev_button_proc+0x70>
    } else {
        /*If a new point comes always make a release*/
        indev_proc_release(&i->proc);
 800f6fa:	687b      	ldr	r3, [r7, #4]
 800f6fc:	3320      	adds	r3, #32
 800f6fe:	4618      	mov	r0, r3
 800f700:	f000 fa84 	bl	800fc0c <indev_proc_release>
    }

    i->proc.types.pointer.last_point.x = i->proc.types.pointer.act_point.x;
 800f704:	687b      	ldr	r3, [r7, #4]
 800f706:	f9b3 2024 	ldrsh.w	r2, [r3, #36]	; 0x24
 800f70a:	687b      	ldr	r3, [r7, #4]
 800f70c:	851a      	strh	r2, [r3, #40]	; 0x28
    i->proc.types.pointer.last_point.y = i->proc.types.pointer.act_point.y;
 800f70e:	687b      	ldr	r3, [r7, #4]
 800f710:	f9b3 2026 	ldrsh.w	r2, [r3, #38]	; 0x26
 800f714:	687b      	ldr	r3, [r7, #4]
 800f716:	855a      	strh	r2, [r3, #42]	; 0x2a
}
 800f718:	bf00      	nop
 800f71a:	3708      	adds	r7, #8
 800f71c:	46bd      	mov	sp, r7
 800f71e:	bd80      	pop	{r7, pc}

0800f720 <indev_proc_press>:
 * Process the pressed state of LV_INDEV_TYPE_POINER input devices
 * @param indev pointer to an input device 'proc'
 * @return LV_RES_OK: no indev reset required; LV_RES_INV: indev reset is required
 */
static void indev_proc_press(lv_indev_proc_t * proc)
{
 800f720:	b580      	push	{r7, lr}
 800f722:	b086      	sub	sp, #24
 800f724:	af00      	add	r7, sp, #0
 800f726:	6078      	str	r0, [r7, #4]
    indev_obj_act = proc->types.pointer.act_obj;
 800f728:	687b      	ldr	r3, [r7, #4]
 800f72a:	699b      	ldr	r3, [r3, #24]
 800f72c:	4a71      	ldr	r2, [pc, #452]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f72e:	6013      	str	r3, [r2, #0]

    if(proc->wait_until_release != 0) return;
 800f730:	687b      	ldr	r3, [r7, #4]
 800f732:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800f736:	f003 0308 	and.w	r3, r3, #8
 800f73a:	b2db      	uxtb	r3, r3
 800f73c:	2b00      	cmp	r3, #0
 800f73e:	f040 8247 	bne.w	800fbd0 <indev_proc_press+0x4b0>

    lv_disp_t * disp = indev_act->driver.disp;
 800f742:	4b6d      	ldr	r3, [pc, #436]	; (800f8f8 <indev_proc_press+0x1d8>)
 800f744:	681b      	ldr	r3, [r3, #0]
 800f746:	691b      	ldr	r3, [r3, #16]
 800f748:	60fb      	str	r3, [r7, #12]

    /*If there is no last object then search*/
    if(indev_obj_act == NULL) {
 800f74a:	4b6a      	ldr	r3, [pc, #424]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f74c:	681b      	ldr	r3, [r3, #0]
 800f74e:	2b00      	cmp	r3, #0
 800f750:	d129      	bne.n	800f7a6 <indev_proc_press+0x86>
        indev_obj_act = indev_search_obj(proc, lv_disp_get_layer_sys(disp));
 800f752:	68f8      	ldr	r0, [r7, #12]
 800f754:	f7fe fbd4 	bl	800df00 <lv_disp_get_layer_sys>
 800f758:	4603      	mov	r3, r0
 800f75a:	4619      	mov	r1, r3
 800f75c:	6878      	ldr	r0, [r7, #4]
 800f75e:	f000 fc4b 	bl	800fff8 <indev_search_obj>
 800f762:	4602      	mov	r2, r0
 800f764:	4b63      	ldr	r3, [pc, #396]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f766:	601a      	str	r2, [r3, #0]
        if(indev_obj_act == NULL) indev_obj_act = indev_search_obj(proc, lv_disp_get_layer_top(disp));
 800f768:	4b62      	ldr	r3, [pc, #392]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f76a:	681b      	ldr	r3, [r3, #0]
 800f76c:	2b00      	cmp	r3, #0
 800f76e:	d10a      	bne.n	800f786 <indev_proc_press+0x66>
 800f770:	68f8      	ldr	r0, [r7, #12]
 800f772:	f7fe fba5 	bl	800dec0 <lv_disp_get_layer_top>
 800f776:	4603      	mov	r3, r0
 800f778:	4619      	mov	r1, r3
 800f77a:	6878      	ldr	r0, [r7, #4]
 800f77c:	f000 fc3c 	bl	800fff8 <indev_search_obj>
 800f780:	4602      	mov	r2, r0
 800f782:	4b5c      	ldr	r3, [pc, #368]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f784:	601a      	str	r2, [r3, #0]
        if(indev_obj_act == NULL) indev_obj_act = indev_search_obj(proc, lv_disp_get_scr_act(disp));
 800f786:	4b5b      	ldr	r3, [pc, #364]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f788:	681b      	ldr	r3, [r3, #0]
 800f78a:	2b00      	cmp	r3, #0
 800f78c:	d148      	bne.n	800f820 <indev_proc_press+0x100>
 800f78e:	68f8      	ldr	r0, [r7, #12]
 800f790:	f7fe fb64 	bl	800de5c <lv_disp_get_scr_act>
 800f794:	4603      	mov	r3, r0
 800f796:	4619      	mov	r1, r3
 800f798:	6878      	ldr	r0, [r7, #4]
 800f79a:	f000 fc2d 	bl	800fff8 <indev_search_obj>
 800f79e:	4602      	mov	r2, r0
 800f7a0:	4b54      	ldr	r3, [pc, #336]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f7a2:	601a      	str	r2, [r3, #0]
 800f7a4:	e03c      	b.n	800f820 <indev_proc_press+0x100>
    }
    /*If there is last object but it is not dragged and not protected also search*/
    else if(proc->types.pointer.drag_in_prog == 0 &&
 800f7a6:	687b      	ldr	r3, [r7, #4]
 800f7a8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800f7ac:	f003 0302 	and.w	r3, r3, #2
 800f7b0:	b2db      	uxtb	r3, r3
 800f7b2:	2b00      	cmp	r3, #0
 800f7b4:	d134      	bne.n	800f820 <indev_proc_press+0x100>
            lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST) == false) {
 800f7b6:	4b4f      	ldr	r3, [pc, #316]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f7b8:	681b      	ldr	r3, [r3, #0]
 800f7ba:	2110      	movs	r1, #16
 800f7bc:	4618      	mov	r0, r3
 800f7be:	f002 fe09 	bl	80123d4 <lv_obj_is_protected>
 800f7c2:	4603      	mov	r3, r0
 800f7c4:	f083 0301 	eor.w	r3, r3, #1
 800f7c8:	b2db      	uxtb	r3, r3
    else if(proc->types.pointer.drag_in_prog == 0 &&
 800f7ca:	2b00      	cmp	r3, #0
 800f7cc:	d028      	beq.n	800f820 <indev_proc_press+0x100>
        indev_obj_act = indev_search_obj(proc, lv_disp_get_layer_sys(disp));
 800f7ce:	68f8      	ldr	r0, [r7, #12]
 800f7d0:	f7fe fb96 	bl	800df00 <lv_disp_get_layer_sys>
 800f7d4:	4603      	mov	r3, r0
 800f7d6:	4619      	mov	r1, r3
 800f7d8:	6878      	ldr	r0, [r7, #4]
 800f7da:	f000 fc0d 	bl	800fff8 <indev_search_obj>
 800f7de:	4602      	mov	r2, r0
 800f7e0:	4b44      	ldr	r3, [pc, #272]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f7e2:	601a      	str	r2, [r3, #0]
        if(indev_obj_act == NULL) indev_obj_act = indev_search_obj(proc, lv_disp_get_layer_top(disp));
 800f7e4:	4b43      	ldr	r3, [pc, #268]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f7e6:	681b      	ldr	r3, [r3, #0]
 800f7e8:	2b00      	cmp	r3, #0
 800f7ea:	d10a      	bne.n	800f802 <indev_proc_press+0xe2>
 800f7ec:	68f8      	ldr	r0, [r7, #12]
 800f7ee:	f7fe fb67 	bl	800dec0 <lv_disp_get_layer_top>
 800f7f2:	4603      	mov	r3, r0
 800f7f4:	4619      	mov	r1, r3
 800f7f6:	6878      	ldr	r0, [r7, #4]
 800f7f8:	f000 fbfe 	bl	800fff8 <indev_search_obj>
 800f7fc:	4602      	mov	r2, r0
 800f7fe:	4b3d      	ldr	r3, [pc, #244]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f800:	601a      	str	r2, [r3, #0]
        if(indev_obj_act == NULL) indev_obj_act = indev_search_obj(proc, lv_disp_get_scr_act(disp));
 800f802:	4b3c      	ldr	r3, [pc, #240]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f804:	681b      	ldr	r3, [r3, #0]
 800f806:	2b00      	cmp	r3, #0
 800f808:	d10a      	bne.n	800f820 <indev_proc_press+0x100>
 800f80a:	68f8      	ldr	r0, [r7, #12]
 800f80c:	f7fe fb26 	bl	800de5c <lv_disp_get_scr_act>
 800f810:	4603      	mov	r3, r0
 800f812:	4619      	mov	r1, r3
 800f814:	6878      	ldr	r0, [r7, #4]
 800f816:	f000 fbef 	bl	800fff8 <indev_search_obj>
 800f81a:	4602      	mov	r2, r0
 800f81c:	4b35      	ldr	r3, [pc, #212]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f81e:	601a      	str	r2, [r3, #0]
    /*If a dragable or a protected object was the last then keep it*/
    else {
    }

    /*If a new object was found reset some variables and send a pressed signal*/
    if(indev_obj_act != proc->types.pointer.act_obj) {
 800f820:	687b      	ldr	r3, [r7, #4]
 800f822:	699a      	ldr	r2, [r3, #24]
 800f824:	4b33      	ldr	r3, [pc, #204]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f826:	681b      	ldr	r3, [r3, #0]
 800f828:	429a      	cmp	r2, r3
 800f82a:	f000 809c 	beq.w	800f966 <indev_proc_press+0x246>

        proc->types.pointer.last_point.x = proc->types.pointer.act_point.x;
 800f82e:	687b      	ldr	r3, [r7, #4]
 800f830:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800f834:	687b      	ldr	r3, [r7, #4]
 800f836:	811a      	strh	r2, [r3, #8]
        proc->types.pointer.last_point.y = proc->types.pointer.act_point.y;
 800f838:	687b      	ldr	r3, [r7, #4]
 800f83a:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 800f83e:	687b      	ldr	r3, [r7, #4]
 800f840:	815a      	strh	r2, [r3, #10]

        /*If a new object found the previous was lost, so send a signal*/
        if(proc->types.pointer.act_obj != NULL) {
 800f842:	687b      	ldr	r3, [r7, #4]
 800f844:	699b      	ldr	r3, [r3, #24]
 800f846:	2b00      	cmp	r3, #0
 800f848:	d01c      	beq.n	800f884 <indev_proc_press+0x164>
            /*Save the obj because in special cases `act_obj` can change in the signal function*/
            lv_obj_t * last_obj = proc->types.pointer.act_obj;
 800f84a:	687b      	ldr	r3, [r7, #4]
 800f84c:	699b      	ldr	r3, [r3, #24]
 800f84e:	60bb      	str	r3, [r7, #8]

            last_obj->signal_cb(last_obj, LV_SIGNAL_PRESS_LOST, indev_act);
 800f850:	68bb      	ldr	r3, [r7, #8]
 800f852:	69db      	ldr	r3, [r3, #28]
 800f854:	4a28      	ldr	r2, [pc, #160]	; (800f8f8 <indev_proc_press+0x1d8>)
 800f856:	6812      	ldr	r2, [r2, #0]
 800f858:	2109      	movs	r1, #9
 800f85a:	68b8      	ldr	r0, [r7, #8]
 800f85c:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
 800f85e:	6878      	ldr	r0, [r7, #4]
 800f860:	f000 fef6 	bl	8010650 <indev_reset_check>
 800f864:	4603      	mov	r3, r0
 800f866:	2b00      	cmp	r3, #0
 800f868:	f040 81b4 	bne.w	800fbd4 <indev_proc_press+0x4b4>
            lv_event_send(last_obj, LV_EVENT_PRESS_LOST, NULL);
 800f86c:	2200      	movs	r2, #0
 800f86e:	2102      	movs	r1, #2
 800f870:	68b8      	ldr	r0, [r7, #8]
 800f872:	f002 faf4 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800f876:	6878      	ldr	r0, [r7, #4]
 800f878:	f000 feea 	bl	8010650 <indev_reset_check>
 800f87c:	4603      	mov	r3, r0
 800f87e:	2b00      	cmp	r3, #0
 800f880:	f040 81aa 	bne.w	800fbd8 <indev_proc_press+0x4b8>
        }

        proc->types.pointer.act_obj  = indev_obj_act; /*Save the pressed object*/
 800f884:	4b1b      	ldr	r3, [pc, #108]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f886:	681a      	ldr	r2, [r3, #0]
 800f888:	687b      	ldr	r3, [r7, #4]
 800f88a:	619a      	str	r2, [r3, #24]
        proc->types.pointer.last_obj = indev_obj_act;
 800f88c:	4b19      	ldr	r3, [pc, #100]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f88e:	681a      	ldr	r2, [r3, #0]
 800f890:	687b      	ldr	r3, [r7, #4]
 800f892:	61da      	str	r2, [r3, #28]

        if(indev_obj_act != NULL) {
 800f894:	4b17      	ldr	r3, [pc, #92]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f896:	681b      	ldr	r3, [r3, #0]
 800f898:	2b00      	cmp	r3, #0
 800f89a:	d064      	beq.n	800f966 <indev_proc_press+0x246>
            /* Save the time when the obj pressed.
             * It is necessary to count the long press time.*/
            proc->pr_timestamp                 = lv_tick_get();
 800f89c:	f00b fe06 	bl	801b4ac <lv_tick_get>
 800f8a0:	4602      	mov	r2, r0
 800f8a2:	687b      	ldr	r3, [r7, #4]
 800f8a4:	629a      	str	r2, [r3, #40]	; 0x28
            proc->long_pr_sent                 = 0;
 800f8a6:	687a      	ldr	r2, [r7, #4]
 800f8a8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 800f8ac:	f36f 0300 	bfc	r3, #0, #1
 800f8b0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
            proc->types.pointer.drag_limit_out = 0;
 800f8b4:	687a      	ldr	r2, [r7, #4]
 800f8b6:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 800f8ba:	f36f 0300 	bfc	r3, #0, #1
 800f8be:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            proc->types.pointer.drag_in_prog   = 0;
 800f8c2:	687a      	ldr	r2, [r7, #4]
 800f8c4:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 800f8c8:	f36f 0341 	bfc	r3, #1, #1
 800f8cc:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            proc->types.pointer.drag_sum.x     = 0;
 800f8d0:	687b      	ldr	r3, [r7, #4]
 800f8d2:	2200      	movs	r2, #0
 800f8d4:	821a      	strh	r2, [r3, #16]
            proc->types.pointer.drag_sum.y     = 0;
 800f8d6:	687b      	ldr	r3, [r7, #4]
 800f8d8:	2200      	movs	r2, #0
 800f8da:	825a      	strh	r2, [r3, #18]
            proc->types.pointer.vect.x         = 0;
 800f8dc:	687b      	ldr	r3, [r7, #4]
 800f8de:	2200      	movs	r2, #0
 800f8e0:	819a      	strh	r2, [r3, #12]
            proc->types.pointer.vect.y         = 0;
 800f8e2:	687b      	ldr	r3, [r7, #4]
 800f8e4:	2200      	movs	r2, #0
 800f8e6:	81da      	strh	r2, [r3, #14]

            /*Search for 'top' attribute*/
            lv_obj_t * i        = indev_obj_act;
 800f8e8:	4b02      	ldr	r3, [pc, #8]	; (800f8f4 <indev_proc_press+0x1d4>)
 800f8ea:	681b      	ldr	r3, [r3, #0]
 800f8ec:	617b      	str	r3, [r7, #20]
            lv_obj_t * last_top = NULL;
 800f8ee:	2300      	movs	r3, #0
 800f8f0:	613b      	str	r3, [r7, #16]
            while(i != NULL) {
 800f8f2:	e011      	b.n	800f918 <indev_proc_press+0x1f8>
 800f8f4:	20003f98 	.word	0x20003f98
 800f8f8:	20003f94 	.word	0x20003f94
                if(i->top) last_top = i;
 800f8fc:	697b      	ldr	r3, [r7, #20]
 800f8fe:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800f902:	f003 0320 	and.w	r3, r3, #32
 800f906:	b2db      	uxtb	r3, r3
 800f908:	2b00      	cmp	r3, #0
 800f90a:	d001      	beq.n	800f910 <indev_proc_press+0x1f0>
 800f90c:	697b      	ldr	r3, [r7, #20]
 800f90e:	613b      	str	r3, [r7, #16]
                i = lv_obj_get_parent(i);
 800f910:	6978      	ldr	r0, [r7, #20]
 800f912:	f002 fbd5 	bl	80120c0 <lv_obj_get_parent>
 800f916:	6178      	str	r0, [r7, #20]
            while(i != NULL) {
 800f918:	697b      	ldr	r3, [r7, #20]
 800f91a:	2b00      	cmp	r3, #0
 800f91c:	d1ee      	bne.n	800f8fc <indev_proc_press+0x1dc>
            }

            if(last_top != NULL) {
 800f91e:	693b      	ldr	r3, [r7, #16]
 800f920:	2b00      	cmp	r3, #0
 800f922:	d002      	beq.n	800f92a <indev_proc_press+0x20a>
                /*Move the last_top object to the foreground*/
                lv_obj_move_foreground(last_top);
 800f924:	6938      	ldr	r0, [r7, #16]
 800f926:	f001 fb69 	bl	8010ffc <lv_obj_move_foreground>
            }

            /*Send a signal about the press*/
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSED, indev_act);
 800f92a:	4bac      	ldr	r3, [pc, #688]	; (800fbdc <indev_proc_press+0x4bc>)
 800f92c:	681b      	ldr	r3, [r3, #0]
 800f92e:	69db      	ldr	r3, [r3, #28]
 800f930:	4aaa      	ldr	r2, [pc, #680]	; (800fbdc <indev_proc_press+0x4bc>)
 800f932:	6810      	ldr	r0, [r2, #0]
 800f934:	4aaa      	ldr	r2, [pc, #680]	; (800fbe0 <indev_proc_press+0x4c0>)
 800f936:	6812      	ldr	r2, [r2, #0]
 800f938:	2107      	movs	r1, #7
 800f93a:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
 800f93c:	6878      	ldr	r0, [r7, #4]
 800f93e:	f000 fe87 	bl	8010650 <indev_reset_check>
 800f942:	4603      	mov	r3, r0
 800f944:	2b00      	cmp	r3, #0
 800f946:	f040 814d 	bne.w	800fbe4 <indev_proc_press+0x4c4>

            lv_event_send(indev_obj_act, LV_EVENT_PRESSED, NULL);
 800f94a:	4ba4      	ldr	r3, [pc, #656]	; (800fbdc <indev_proc_press+0x4bc>)
 800f94c:	681b      	ldr	r3, [r3, #0]
 800f94e:	2200      	movs	r2, #0
 800f950:	2100      	movs	r1, #0
 800f952:	4618      	mov	r0, r3
 800f954:	f002 fa83 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800f958:	6878      	ldr	r0, [r7, #4]
 800f95a:	f000 fe79 	bl	8010650 <indev_reset_check>
 800f95e:	4603      	mov	r3, r0
 800f960:	2b00      	cmp	r3, #0
 800f962:	f040 8141 	bne.w	800fbe8 <indev_proc_press+0x4c8>
        }
    }

    /*Calculate the types.pointer.vector*/
    proc->types.pointer.vect.x = proc->types.pointer.act_point.x - proc->types.pointer.last_point.x;
 800f966:	687b      	ldr	r3, [r7, #4]
 800f968:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800f96c:	b29a      	uxth	r2, r3
 800f96e:	687b      	ldr	r3, [r7, #4]
 800f970:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 800f974:	b29b      	uxth	r3, r3
 800f976:	1ad3      	subs	r3, r2, r3
 800f978:	b29b      	uxth	r3, r3
 800f97a:	b21a      	sxth	r2, r3
 800f97c:	687b      	ldr	r3, [r7, #4]
 800f97e:	819a      	strh	r2, [r3, #12]
    proc->types.pointer.vect.y = proc->types.pointer.act_point.y - proc->types.pointer.last_point.y;
 800f980:	687b      	ldr	r3, [r7, #4]
 800f982:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800f986:	b29a      	uxth	r2, r3
 800f988:	687b      	ldr	r3, [r7, #4]
 800f98a:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 800f98e:	b29b      	uxth	r3, r3
 800f990:	1ad3      	subs	r3, r2, r3
 800f992:	b29b      	uxth	r3, r3
 800f994:	b21a      	sxth	r2, r3
 800f996:	687b      	ldr	r3, [r7, #4]
 800f998:	81da      	strh	r2, [r3, #14]

    proc->types.pointer.drag_throw_vect.x = (proc->types.pointer.drag_throw_vect.x * 5) >> 3;
 800f99a:	687b      	ldr	r3, [r7, #4]
 800f99c:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800f9a0:	461a      	mov	r2, r3
 800f9a2:	4613      	mov	r3, r2
 800f9a4:	009b      	lsls	r3, r3, #2
 800f9a6:	4413      	add	r3, r2
 800f9a8:	10db      	asrs	r3, r3, #3
 800f9aa:	b21a      	sxth	r2, r3
 800f9ac:	687b      	ldr	r3, [r7, #4]
 800f9ae:	829a      	strh	r2, [r3, #20]
    proc->types.pointer.drag_throw_vect.y = (proc->types.pointer.drag_throw_vect.y * 5) >> 3;
 800f9b0:	687b      	ldr	r3, [r7, #4]
 800f9b2:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800f9b6:	461a      	mov	r2, r3
 800f9b8:	4613      	mov	r3, r2
 800f9ba:	009b      	lsls	r3, r3, #2
 800f9bc:	4413      	add	r3, r2
 800f9be:	10db      	asrs	r3, r3, #3
 800f9c0:	b21a      	sxth	r2, r3
 800f9c2:	687b      	ldr	r3, [r7, #4]
 800f9c4:	82da      	strh	r2, [r3, #22]

    if(proc->types.pointer.drag_throw_vect.x < 0)
 800f9c6:	687b      	ldr	r3, [r7, #4]
 800f9c8:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800f9cc:	2b00      	cmp	r3, #0
 800f9ce:	da09      	bge.n	800f9e4 <indev_proc_press+0x2c4>
        proc->types.pointer.drag_throw_vect.x++;
 800f9d0:	687b      	ldr	r3, [r7, #4]
 800f9d2:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800f9d6:	b29b      	uxth	r3, r3
 800f9d8:	3301      	adds	r3, #1
 800f9da:	b29b      	uxth	r3, r3
 800f9dc:	b21a      	sxth	r2, r3
 800f9de:	687b      	ldr	r3, [r7, #4]
 800f9e0:	829a      	strh	r2, [r3, #20]
 800f9e2:	e00d      	b.n	800fa00 <indev_proc_press+0x2e0>
    else if(proc->types.pointer.drag_throw_vect.x > 0)
 800f9e4:	687b      	ldr	r3, [r7, #4]
 800f9e6:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800f9ea:	2b00      	cmp	r3, #0
 800f9ec:	dd08      	ble.n	800fa00 <indev_proc_press+0x2e0>
        proc->types.pointer.drag_throw_vect.x--;
 800f9ee:	687b      	ldr	r3, [r7, #4]
 800f9f0:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800f9f4:	b29b      	uxth	r3, r3
 800f9f6:	3b01      	subs	r3, #1
 800f9f8:	b29b      	uxth	r3, r3
 800f9fa:	b21a      	sxth	r2, r3
 800f9fc:	687b      	ldr	r3, [r7, #4]
 800f9fe:	829a      	strh	r2, [r3, #20]

    if(proc->types.pointer.drag_throw_vect.y < 0)
 800fa00:	687b      	ldr	r3, [r7, #4]
 800fa02:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800fa06:	2b00      	cmp	r3, #0
 800fa08:	da09      	bge.n	800fa1e <indev_proc_press+0x2fe>
        proc->types.pointer.drag_throw_vect.y++;
 800fa0a:	687b      	ldr	r3, [r7, #4]
 800fa0c:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800fa10:	b29b      	uxth	r3, r3
 800fa12:	3301      	adds	r3, #1
 800fa14:	b29b      	uxth	r3, r3
 800fa16:	b21a      	sxth	r2, r3
 800fa18:	687b      	ldr	r3, [r7, #4]
 800fa1a:	82da      	strh	r2, [r3, #22]
 800fa1c:	e00d      	b.n	800fa3a <indev_proc_press+0x31a>
    else if(proc->types.pointer.drag_throw_vect.y > 0)
 800fa1e:	687b      	ldr	r3, [r7, #4]
 800fa20:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800fa24:	2b00      	cmp	r3, #0
 800fa26:	dd08      	ble.n	800fa3a <indev_proc_press+0x31a>
        proc->types.pointer.drag_throw_vect.y--;
 800fa28:	687b      	ldr	r3, [r7, #4]
 800fa2a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800fa2e:	b29b      	uxth	r3, r3
 800fa30:	3b01      	subs	r3, #1
 800fa32:	b29b      	uxth	r3, r3
 800fa34:	b21a      	sxth	r2, r3
 800fa36:	687b      	ldr	r3, [r7, #4]
 800fa38:	82da      	strh	r2, [r3, #22]

    proc->types.pointer.drag_throw_vect.x += (proc->types.pointer.vect.x * 4) >> 3;
 800fa3a:	687b      	ldr	r3, [r7, #4]
 800fa3c:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 800fa40:	b29a      	uxth	r2, r3
 800fa42:	687b      	ldr	r3, [r7, #4]
 800fa44:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 800fa48:	009b      	lsls	r3, r3, #2
 800fa4a:	10db      	asrs	r3, r3, #3
 800fa4c:	b29b      	uxth	r3, r3
 800fa4e:	4413      	add	r3, r2
 800fa50:	b29b      	uxth	r3, r3
 800fa52:	b21a      	sxth	r2, r3
 800fa54:	687b      	ldr	r3, [r7, #4]
 800fa56:	829a      	strh	r2, [r3, #20]
    proc->types.pointer.drag_throw_vect.y += (proc->types.pointer.vect.y * 4) >> 3;
 800fa58:	687b      	ldr	r3, [r7, #4]
 800fa5a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 800fa5e:	b29a      	uxth	r2, r3
 800fa60:	687b      	ldr	r3, [r7, #4]
 800fa62:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 800fa66:	009b      	lsls	r3, r3, #2
 800fa68:	10db      	asrs	r3, r3, #3
 800fa6a:	b29b      	uxth	r3, r3
 800fa6c:	4413      	add	r3, r2
 800fa6e:	b29b      	uxth	r3, r3
 800fa70:	b21a      	sxth	r2, r3
 800fa72:	687b      	ldr	r3, [r7, #4]
 800fa74:	82da      	strh	r2, [r3, #22]

    /*If there is active object and it can be dragged run the drag*/
    if(indev_obj_act != NULL) {
 800fa76:	4b59      	ldr	r3, [pc, #356]	; (800fbdc <indev_proc_press+0x4bc>)
 800fa78:	681b      	ldr	r3, [r3, #0]
 800fa7a:	2b00      	cmp	r3, #0
 800fa7c:	f000 80c3 	beq.w	800fc06 <indev_proc_press+0x4e6>
        indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_PRESSING, indev_act);
 800fa80:	4b56      	ldr	r3, [pc, #344]	; (800fbdc <indev_proc_press+0x4bc>)
 800fa82:	681b      	ldr	r3, [r3, #0]
 800fa84:	69db      	ldr	r3, [r3, #28]
 800fa86:	4a55      	ldr	r2, [pc, #340]	; (800fbdc <indev_proc_press+0x4bc>)
 800fa88:	6810      	ldr	r0, [r2, #0]
 800fa8a:	4a55      	ldr	r2, [pc, #340]	; (800fbe0 <indev_proc_press+0x4c0>)
 800fa8c:	6812      	ldr	r2, [r2, #0]
 800fa8e:	2108      	movs	r1, #8
 800fa90:	4798      	blx	r3
        if(indev_reset_check(proc)) return;
 800fa92:	6878      	ldr	r0, [r7, #4]
 800fa94:	f000 fddc 	bl	8010650 <indev_reset_check>
 800fa98:	4603      	mov	r3, r0
 800fa9a:	2b00      	cmp	r3, #0
 800fa9c:	f040 80a6 	bne.w	800fbec <indev_proc_press+0x4cc>
        lv_event_send(indev_obj_act, LV_EVENT_PRESSING, NULL);
 800faa0:	4b4e      	ldr	r3, [pc, #312]	; (800fbdc <indev_proc_press+0x4bc>)
 800faa2:	681b      	ldr	r3, [r3, #0]
 800faa4:	2200      	movs	r2, #0
 800faa6:	2101      	movs	r1, #1
 800faa8:	4618      	mov	r0, r3
 800faaa:	f002 f9d8 	bl	8011e5e <lv_event_send>
        if(indev_reset_check(proc)) return;
 800faae:	6878      	ldr	r0, [r7, #4]
 800fab0:	f000 fdce 	bl	8010650 <indev_reset_check>
 800fab4:	4603      	mov	r3, r0
 800fab6:	2b00      	cmp	r3, #0
 800fab8:	f040 809a 	bne.w	800fbf0 <indev_proc_press+0x4d0>

        indev_drag(proc);
 800fabc:	6878      	ldr	r0, [r7, #4]
 800fabe:	f000 faef 	bl	80100a0 <indev_drag>
        if(indev_reset_check(proc)) return;
 800fac2:	6878      	ldr	r0, [r7, #4]
 800fac4:	f000 fdc4 	bl	8010650 <indev_reset_check>
 800fac8:	4603      	mov	r3, r0
 800faca:	2b00      	cmp	r3, #0
 800facc:	f040 8092 	bne.w	800fbf4 <indev_proc_press+0x4d4>

        /*If there is no drag then check for long press time*/
        if(proc->types.pointer.drag_in_prog == 0 && proc->long_pr_sent == 0) {
 800fad0:	687b      	ldr	r3, [r7, #4]
 800fad2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fad6:	f003 0302 	and.w	r3, r3, #2
 800fada:	b2db      	uxtb	r3, r3
 800fadc:	2b00      	cmp	r3, #0
 800fade:	d13a      	bne.n	800fb56 <indev_proc_press+0x436>
 800fae0:	687b      	ldr	r3, [r7, #4]
 800fae2:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800fae6:	f003 0301 	and.w	r3, r3, #1
 800faea:	b2db      	uxtb	r3, r3
 800faec:	2b00      	cmp	r3, #0
 800faee:	d132      	bne.n	800fb56 <indev_proc_press+0x436>
            /*Send a signal about the long press if enough time elapsed*/
            if(lv_tick_elaps(proc->pr_timestamp) > indev_act->driver.long_press_time) {
 800faf0:	687b      	ldr	r3, [r7, #4]
 800faf2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800faf4:	4618      	mov	r0, r3
 800faf6:	f00b fcf3 	bl	801b4e0 <lv_tick_elaps>
 800fafa:	4602      	mov	r2, r0
 800fafc:	4b38      	ldr	r3, [pc, #224]	; (800fbe0 <indev_proc_press+0x4c0>)
 800fafe:	681b      	ldr	r3, [r3, #0]
 800fb00:	8b5b      	ldrh	r3, [r3, #26]
 800fb02:	429a      	cmp	r2, r3
 800fb04:	d927      	bls.n	800fb56 <indev_proc_press+0x436>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS, indev_act);
 800fb06:	4b35      	ldr	r3, [pc, #212]	; (800fbdc <indev_proc_press+0x4bc>)
 800fb08:	681b      	ldr	r3, [r3, #0]
 800fb0a:	69db      	ldr	r3, [r3, #28]
 800fb0c:	4a33      	ldr	r2, [pc, #204]	; (800fbdc <indev_proc_press+0x4bc>)
 800fb0e:	6810      	ldr	r0, [r2, #0]
 800fb10:	4a33      	ldr	r2, [pc, #204]	; (800fbe0 <indev_proc_press+0x4c0>)
 800fb12:	6812      	ldr	r2, [r2, #0]
 800fb14:	210b      	movs	r1, #11
 800fb16:	4798      	blx	r3
                if(indev_reset_check(proc)) return;
 800fb18:	6878      	ldr	r0, [r7, #4]
 800fb1a:	f000 fd99 	bl	8010650 <indev_reset_check>
 800fb1e:	4603      	mov	r3, r0
 800fb20:	2b00      	cmp	r3, #0
 800fb22:	d169      	bne.n	800fbf8 <indev_proc_press+0x4d8>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED, NULL);
 800fb24:	4b2d      	ldr	r3, [pc, #180]	; (800fbdc <indev_proc_press+0x4bc>)
 800fb26:	681b      	ldr	r3, [r3, #0]
 800fb28:	2200      	movs	r2, #0
 800fb2a:	2104      	movs	r1, #4
 800fb2c:	4618      	mov	r0, r3
 800fb2e:	f002 f996 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(proc)) return;
 800fb32:	6878      	ldr	r0, [r7, #4]
 800fb34:	f000 fd8c 	bl	8010650 <indev_reset_check>
 800fb38:	4603      	mov	r3, r0
 800fb3a:	2b00      	cmp	r3, #0
 800fb3c:	d15e      	bne.n	800fbfc <indev_proc_press+0x4dc>

                /*Mark the signal sending to do not send it again*/
                proc->long_pr_sent = 1;
 800fb3e:	687a      	ldr	r2, [r7, #4]
 800fb40:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 800fb44:	f043 0301 	orr.w	r3, r3, #1
 800fb48:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

                /*Save the long press time stamp for the long press repeat handler*/
                proc->longpr_rep_timestamp = lv_tick_get();
 800fb4c:	f00b fcae 	bl	801b4ac <lv_tick_get>
 800fb50:	4602      	mov	r2, r0
 800fb52:	687b      	ldr	r3, [r7, #4]
 800fb54:	62da      	str	r2, [r3, #44]	; 0x2c
            }
        }
        /*Send long press repeated signal*/
        if(proc->types.pointer.drag_in_prog == 0 && proc->long_pr_sent == 1) {
 800fb56:	687b      	ldr	r3, [r7, #4]
 800fb58:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fb5c:	f003 0302 	and.w	r3, r3, #2
 800fb60:	b2db      	uxtb	r3, r3
 800fb62:	2b00      	cmp	r3, #0
 800fb64:	d14f      	bne.n	800fc06 <indev_proc_press+0x4e6>
 800fb66:	687b      	ldr	r3, [r7, #4]
 800fb68:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800fb6c:	f003 0301 	and.w	r3, r3, #1
 800fb70:	b2db      	uxtb	r3, r3
 800fb72:	2b00      	cmp	r3, #0
 800fb74:	d047      	beq.n	800fc06 <indev_proc_press+0x4e6>
            /*Send a signal about the long press repeat if enough time elapsed*/
            if(lv_tick_elaps(proc->longpr_rep_timestamp) > indev_act->driver.long_press_rep_time) {
 800fb76:	687b      	ldr	r3, [r7, #4]
 800fb78:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800fb7a:	4618      	mov	r0, r3
 800fb7c:	f00b fcb0 	bl	801b4e0 <lv_tick_elaps>
 800fb80:	4602      	mov	r2, r0
 800fb82:	4b17      	ldr	r3, [pc, #92]	; (800fbe0 <indev_proc_press+0x4c0>)
 800fb84:	681b      	ldr	r3, [r3, #0]
 800fb86:	8b9b      	ldrh	r3, [r3, #28]
 800fb88:	429a      	cmp	r2, r3
 800fb8a:	d93c      	bls.n	800fc06 <indev_proc_press+0x4e6>
                indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_LONG_PRESS_REP, indev_act);
 800fb8c:	4b13      	ldr	r3, [pc, #76]	; (800fbdc <indev_proc_press+0x4bc>)
 800fb8e:	681b      	ldr	r3, [r3, #0]
 800fb90:	69db      	ldr	r3, [r3, #28]
 800fb92:	4a12      	ldr	r2, [pc, #72]	; (800fbdc <indev_proc_press+0x4bc>)
 800fb94:	6810      	ldr	r0, [r2, #0]
 800fb96:	4a12      	ldr	r2, [pc, #72]	; (800fbe0 <indev_proc_press+0x4c0>)
 800fb98:	6812      	ldr	r2, [r2, #0]
 800fb9a:	210c      	movs	r1, #12
 800fb9c:	4798      	blx	r3
                if(indev_reset_check(proc)) return;
 800fb9e:	6878      	ldr	r0, [r7, #4]
 800fba0:	f000 fd56 	bl	8010650 <indev_reset_check>
 800fba4:	4603      	mov	r3, r0
 800fba6:	2b00      	cmp	r3, #0
 800fba8:	d12a      	bne.n	800fc00 <indev_proc_press+0x4e0>
                lv_event_send(indev_obj_act, LV_EVENT_LONG_PRESSED_REPEAT, NULL);
 800fbaa:	4b0c      	ldr	r3, [pc, #48]	; (800fbdc <indev_proc_press+0x4bc>)
 800fbac:	681b      	ldr	r3, [r3, #0]
 800fbae:	2200      	movs	r2, #0
 800fbb0:	2105      	movs	r1, #5
 800fbb2:	4618      	mov	r0, r3
 800fbb4:	f002 f953 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(proc)) return;
 800fbb8:	6878      	ldr	r0, [r7, #4]
 800fbba:	f000 fd49 	bl	8010650 <indev_reset_check>
 800fbbe:	4603      	mov	r3, r0
 800fbc0:	2b00      	cmp	r3, #0
 800fbc2:	d11f      	bne.n	800fc04 <indev_proc_press+0x4e4>
                proc->longpr_rep_timestamp = lv_tick_get();
 800fbc4:	f00b fc72 	bl	801b4ac <lv_tick_get>
 800fbc8:	4602      	mov	r2, r0
 800fbca:	687b      	ldr	r3, [r7, #4]
 800fbcc:	62da      	str	r2, [r3, #44]	; 0x2c
 800fbce:	e01a      	b.n	800fc06 <indev_proc_press+0x4e6>
    if(proc->wait_until_release != 0) return;
 800fbd0:	bf00      	nop
 800fbd2:	e018      	b.n	800fc06 <indev_proc_press+0x4e6>
            if(indev_reset_check(proc)) return;
 800fbd4:	bf00      	nop
 800fbd6:	e016      	b.n	800fc06 <indev_proc_press+0x4e6>
            if(indev_reset_check(proc)) return;
 800fbd8:	bf00      	nop
 800fbda:	e014      	b.n	800fc06 <indev_proc_press+0x4e6>
 800fbdc:	20003f98 	.word	0x20003f98
 800fbe0:	20003f94 	.word	0x20003f94
            if(indev_reset_check(proc)) return;
 800fbe4:	bf00      	nop
 800fbe6:	e00e      	b.n	800fc06 <indev_proc_press+0x4e6>
            if(indev_reset_check(proc)) return;
 800fbe8:	bf00      	nop
 800fbea:	e00c      	b.n	800fc06 <indev_proc_press+0x4e6>
        if(indev_reset_check(proc)) return;
 800fbec:	bf00      	nop
 800fbee:	e00a      	b.n	800fc06 <indev_proc_press+0x4e6>
        if(indev_reset_check(proc)) return;
 800fbf0:	bf00      	nop
 800fbf2:	e008      	b.n	800fc06 <indev_proc_press+0x4e6>
        if(indev_reset_check(proc)) return;
 800fbf4:	bf00      	nop
 800fbf6:	e006      	b.n	800fc06 <indev_proc_press+0x4e6>
                if(indev_reset_check(proc)) return;
 800fbf8:	bf00      	nop
 800fbfa:	e004      	b.n	800fc06 <indev_proc_press+0x4e6>
                if(indev_reset_check(proc)) return;
 800fbfc:	bf00      	nop
 800fbfe:	e002      	b.n	800fc06 <indev_proc_press+0x4e6>
                if(indev_reset_check(proc)) return;
 800fc00:	bf00      	nop
 800fc02:	e000      	b.n	800fc06 <indev_proc_press+0x4e6>
                if(indev_reset_check(proc)) return;
 800fc04:	bf00      	nop
            }
        }
    }
}
 800fc06:	3718      	adds	r7, #24
 800fc08:	46bd      	mov	sp, r7
 800fc0a:	bd80      	pop	{r7, pc}

0800fc0c <indev_proc_release>:
/**
 * Process the released state of LV_INDEV_TYPE_POINER input devices
 * @param proc pointer to an input device 'proc'
 */
static void indev_proc_release(lv_indev_proc_t * proc)
{
 800fc0c:	b580      	push	{r7, lr}
 800fc0e:	b086      	sub	sp, #24
 800fc10:	af00      	add	r7, sp, #0
 800fc12:	6078      	str	r0, [r7, #4]
    if(proc->wait_until_release != 0) {
 800fc14:	687b      	ldr	r3, [r7, #4]
 800fc16:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800fc1a:	f003 0308 	and.w	r3, r3, #8
 800fc1e:	b2db      	uxtb	r3, r3
 800fc20:	2b00      	cmp	r3, #0
 800fc22:	d012      	beq.n	800fc4a <indev_proc_release+0x3e>
        proc->types.pointer.act_obj  = NULL;
 800fc24:	687b      	ldr	r3, [r7, #4]
 800fc26:	2200      	movs	r2, #0
 800fc28:	619a      	str	r2, [r3, #24]
        proc->types.pointer.last_obj = NULL;
 800fc2a:	687b      	ldr	r3, [r7, #4]
 800fc2c:	2200      	movs	r2, #0
 800fc2e:	61da      	str	r2, [r3, #28]
        proc->pr_timestamp           = 0;
 800fc30:	687b      	ldr	r3, [r7, #4]
 800fc32:	2200      	movs	r2, #0
 800fc34:	629a      	str	r2, [r3, #40]	; 0x28
        proc->longpr_rep_timestamp   = 0;
 800fc36:	687b      	ldr	r3, [r7, #4]
 800fc38:	2200      	movs	r2, #0
 800fc3a:	62da      	str	r2, [r3, #44]	; 0x2c
        proc->wait_until_release     = 0;
 800fc3c:	687a      	ldr	r2, [r7, #4]
 800fc3e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 800fc42:	f36f 03c3 	bfc	r3, #3, #1
 800fc46:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
    }
    indev_obj_act = proc->types.pointer.act_obj;
 800fc4a:	687b      	ldr	r3, [r7, #4]
 800fc4c:	699b      	ldr	r3, [r3, #24]
 800fc4e:	4ab4      	ldr	r2, [pc, #720]	; (800ff20 <indev_proc_release+0x314>)
 800fc50:	6013      	str	r3, [r2, #0]

    /*Forget the act obj and send a released signal */
    if(indev_obj_act) {
 800fc52:	4bb3      	ldr	r3, [pc, #716]	; (800ff20 <indev_proc_release+0x314>)
 800fc54:	681b      	ldr	r3, [r3, #0]
 800fc56:	2b00      	cmp	r3, #0
 800fc58:	f000 814d 	beq.w	800fef6 <indev_proc_release+0x2ea>
        /* If the object was protected against press lost then it possible that
         * the object is already not pressed but still it is the `act_obj`.
         * In this case send the `LV_SIGNAL_RELEASED/CLICKED` instead of `LV_SIGNAL_PRESS_LOST` if
         * the indev is ON the `types.pointer.act_obj` */
        if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_PRESS_LOST)) {
 800fc5c:	4bb0      	ldr	r3, [pc, #704]	; (800ff20 <indev_proc_release+0x314>)
 800fc5e:	681b      	ldr	r3, [r3, #0]
 800fc60:	2110      	movs	r1, #16
 800fc62:	4618      	mov	r0, r3
 800fc64:	f002 fbb6 	bl	80123d4 <lv_obj_is_protected>
 800fc68:	4603      	mov	r3, r0
 800fc6a:	2b00      	cmp	r3, #0
 800fc6c:	d049      	beq.n	800fd02 <indev_proc_release+0xf6>
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
 800fc6e:	4bac      	ldr	r3, [pc, #688]	; (800ff20 <indev_proc_release+0x314>)
 800fc70:	681b      	ldr	r3, [r3, #0]
 800fc72:	69db      	ldr	r3, [r3, #28]
 800fc74:	4aaa      	ldr	r2, [pc, #680]	; (800ff20 <indev_proc_release+0x314>)
 800fc76:	6810      	ldr	r0, [r2, #0]
 800fc78:	4aaa      	ldr	r2, [pc, #680]	; (800ff24 <indev_proc_release+0x318>)
 800fc7a:	6812      	ldr	r2, [r2, #0]
 800fc7c:	210a      	movs	r1, #10
 800fc7e:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
 800fc80:	6878      	ldr	r0, [r7, #4]
 800fc82:	f000 fce5 	bl	8010650 <indev_reset_check>
 800fc86:	4603      	mov	r3, r0
 800fc88:	2b00      	cmp	r3, #0
 800fc8a:	f040 814d 	bne.w	800ff28 <indev_proc_release+0x31c>

            if(proc->types.pointer.drag_in_prog == 0) {
 800fc8e:	687b      	ldr	r3, [r7, #4]
 800fc90:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fc94:	f003 0302 	and.w	r3, r3, #2
 800fc98:	b2db      	uxtb	r3, r3
 800fc9a:	2b00      	cmp	r3, #0
 800fc9c:	d123      	bne.n	800fce6 <indev_proc_release+0xda>
                if(proc->long_pr_sent == 0) {
 800fc9e:	687b      	ldr	r3, [r7, #4]
 800fca0:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800fca4:	f003 0301 	and.w	r3, r3, #1
 800fca8:	b2db      	uxtb	r3, r3
 800fcaa:	2b00      	cmp	r3, #0
 800fcac:	d10d      	bne.n	800fcca <indev_proc_release+0xbe>
                    lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
 800fcae:	4b9c      	ldr	r3, [pc, #624]	; (800ff20 <indev_proc_release+0x314>)
 800fcb0:	681b      	ldr	r3, [r3, #0]
 800fcb2:	2200      	movs	r2, #0
 800fcb4:	2103      	movs	r1, #3
 800fcb6:	4618      	mov	r0, r3
 800fcb8:	f002 f8d1 	bl	8011e5e <lv_event_send>
                    if(indev_reset_check(proc)) return;
 800fcbc:	6878      	ldr	r0, [r7, #4]
 800fcbe:	f000 fcc7 	bl	8010650 <indev_reset_check>
 800fcc2:	4603      	mov	r3, r0
 800fcc4:	2b00      	cmp	r3, #0
 800fcc6:	f040 8131 	bne.w	800ff2c <indev_proc_release+0x320>
                }

                lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
 800fcca:	4b95      	ldr	r3, [pc, #596]	; (800ff20 <indev_proc_release+0x314>)
 800fccc:	681b      	ldr	r3, [r3, #0]
 800fcce:	2200      	movs	r2, #0
 800fcd0:	2106      	movs	r1, #6
 800fcd2:	4618      	mov	r0, r3
 800fcd4:	f002 f8c3 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(proc)) return;
 800fcd8:	6878      	ldr	r0, [r7, #4]
 800fcda:	f000 fcb9 	bl	8010650 <indev_reset_check>
 800fcde:	4603      	mov	r3, r0
 800fce0:	2b00      	cmp	r3, #0
 800fce2:	f040 8125 	bne.w	800ff30 <indev_proc_release+0x324>
            }

            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
 800fce6:	4b8e      	ldr	r3, [pc, #568]	; (800ff20 <indev_proc_release+0x314>)
 800fce8:	681b      	ldr	r3, [r3, #0]
 800fcea:	2200      	movs	r2, #0
 800fcec:	2107      	movs	r1, #7
 800fcee:	4618      	mov	r0, r3
 800fcf0:	f002 f8b5 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800fcf4:	6878      	ldr	r0, [r7, #4]
 800fcf6:	f000 fcab 	bl	8010650 <indev_reset_check>
 800fcfa:	4603      	mov	r3, r0
 800fcfc:	2b00      	cmp	r3, #0
 800fcfe:	d04a      	beq.n	800fd96 <indev_proc_release+0x18a>
 800fd00:	e129      	b.n	800ff56 <indev_proc_release+0x34a>
        }
        /* The simple case: `act_obj` was not protected against press lost.
         * If it is already not pressed then `indev_proc_press` would set `indev_obj_act = NULL`*/
        else {
            indev_obj_act->signal_cb(indev_obj_act, LV_SIGNAL_RELEASED, indev_act);
 800fd02:	4b87      	ldr	r3, [pc, #540]	; (800ff20 <indev_proc_release+0x314>)
 800fd04:	681b      	ldr	r3, [r3, #0]
 800fd06:	69db      	ldr	r3, [r3, #28]
 800fd08:	4a85      	ldr	r2, [pc, #532]	; (800ff20 <indev_proc_release+0x314>)
 800fd0a:	6810      	ldr	r0, [r2, #0]
 800fd0c:	4a85      	ldr	r2, [pc, #532]	; (800ff24 <indev_proc_release+0x318>)
 800fd0e:	6812      	ldr	r2, [r2, #0]
 800fd10:	210a      	movs	r1, #10
 800fd12:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
 800fd14:	6878      	ldr	r0, [r7, #4]
 800fd16:	f000 fc9b 	bl	8010650 <indev_reset_check>
 800fd1a:	4603      	mov	r3, r0
 800fd1c:	2b00      	cmp	r3, #0
 800fd1e:	f040 8109 	bne.w	800ff34 <indev_proc_release+0x328>

            if(proc->long_pr_sent == 0 && proc->types.pointer.drag_in_prog == 0) {
 800fd22:	687b      	ldr	r3, [r7, #4]
 800fd24:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800fd28:	f003 0301 	and.w	r3, r3, #1
 800fd2c:	b2db      	uxtb	r3, r3
 800fd2e:	2b00      	cmp	r3, #0
 800fd30:	d115      	bne.n	800fd5e <indev_proc_release+0x152>
 800fd32:	687b      	ldr	r3, [r7, #4]
 800fd34:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fd38:	f003 0302 	and.w	r3, r3, #2
 800fd3c:	b2db      	uxtb	r3, r3
 800fd3e:	2b00      	cmp	r3, #0
 800fd40:	d10d      	bne.n	800fd5e <indev_proc_release+0x152>
                lv_event_send(indev_obj_act, LV_EVENT_SHORT_CLICKED, NULL);
 800fd42:	4b77      	ldr	r3, [pc, #476]	; (800ff20 <indev_proc_release+0x314>)
 800fd44:	681b      	ldr	r3, [r3, #0]
 800fd46:	2200      	movs	r2, #0
 800fd48:	2103      	movs	r1, #3
 800fd4a:	4618      	mov	r0, r3
 800fd4c:	f002 f887 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(proc)) return;
 800fd50:	6878      	ldr	r0, [r7, #4]
 800fd52:	f000 fc7d 	bl	8010650 <indev_reset_check>
 800fd56:	4603      	mov	r3, r0
 800fd58:	2b00      	cmp	r3, #0
 800fd5a:	f040 80ed 	bne.w	800ff38 <indev_proc_release+0x32c>
            }

            lv_event_send(indev_obj_act, LV_EVENT_CLICKED, NULL);
 800fd5e:	4b70      	ldr	r3, [pc, #448]	; (800ff20 <indev_proc_release+0x314>)
 800fd60:	681b      	ldr	r3, [r3, #0]
 800fd62:	2200      	movs	r2, #0
 800fd64:	2106      	movs	r1, #6
 800fd66:	4618      	mov	r0, r3
 800fd68:	f002 f879 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800fd6c:	6878      	ldr	r0, [r7, #4]
 800fd6e:	f000 fc6f 	bl	8010650 <indev_reset_check>
 800fd72:	4603      	mov	r3, r0
 800fd74:	2b00      	cmp	r3, #0
 800fd76:	f040 80e1 	bne.w	800ff3c <indev_proc_release+0x330>

            lv_event_send(indev_obj_act, LV_EVENT_RELEASED, NULL);
 800fd7a:	4b69      	ldr	r3, [pc, #420]	; (800ff20 <indev_proc_release+0x314>)
 800fd7c:	681b      	ldr	r3, [r3, #0]
 800fd7e:	2200      	movs	r2, #0
 800fd80:	2107      	movs	r1, #7
 800fd82:	4618      	mov	r0, r3
 800fd84:	f002 f86b 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800fd88:	6878      	ldr	r0, [r7, #4]
 800fd8a:	f000 fc61 	bl	8010650 <indev_reset_check>
 800fd8e:	4603      	mov	r3, r0
 800fd90:	2b00      	cmp	r3, #0
 800fd92:	f040 80d5 	bne.w	800ff40 <indev_proc_release+0x334>
        }

        if(indev_reset_check(proc)) return;
 800fd96:	6878      	ldr	r0, [r7, #4]
 800fd98:	f000 fc5a 	bl	8010650 <indev_reset_check>
 800fd9c:	4603      	mov	r3, r0
 800fd9e:	2b00      	cmp	r3, #0
 800fda0:	f040 80d0 	bne.w	800ff44 <indev_proc_release+0x338>

        /*Handle click focus*/
        bool click_focus_sent = false;
 800fda4:	2300      	movs	r3, #0
 800fda6:	75fb      	strb	r3, [r7, #23]
#if LV_USE_GROUP
        lv_group_t * g = lv_obj_get_group(indev_obj_act);
 800fda8:	4b5d      	ldr	r3, [pc, #372]	; (800ff20 <indev_proc_release+0x314>)
 800fdaa:	681b      	ldr	r3, [r3, #0]
 800fdac:	4618      	mov	r0, r3
 800fdae:	f002 fb4c 	bl	801244a <lv_obj_get_group>
 800fdb2:	6138      	str	r0, [r7, #16]

        /*Check, if the parent is in a group and focus on it.*/
        /*Respect the click focus protection*/
        if(lv_obj_is_protected(indev_obj_act, LV_PROTECT_CLICK_FOCUS) == false) {
 800fdb4:	4b5a      	ldr	r3, [pc, #360]	; (800ff20 <indev_proc_release+0x314>)
 800fdb6:	681b      	ldr	r3, [r3, #0]
 800fdb8:	2120      	movs	r1, #32
 800fdba:	4618      	mov	r0, r3
 800fdbc:	f002 fb0a 	bl	80123d4 <lv_obj_is_protected>
 800fdc0:	4603      	mov	r3, r0
 800fdc2:	f083 0301 	eor.w	r3, r3, #1
 800fdc6:	b2db      	uxtb	r3, r3
 800fdc8:	2b00      	cmp	r3, #0
 800fdca:	d02e      	beq.n	800fe2a <indev_proc_release+0x21e>
            lv_obj_t * parent = indev_obj_act;
 800fdcc:	4b54      	ldr	r3, [pc, #336]	; (800ff20 <indev_proc_release+0x314>)
 800fdce:	681b      	ldr	r3, [r3, #0]
 800fdd0:	60fb      	str	r3, [r7, #12]

            while(g == NULL) {
 800fdd2:	e014      	b.n	800fdfe <indev_proc_release+0x1f2>
                parent = lv_obj_get_parent(parent);
 800fdd4:	68f8      	ldr	r0, [r7, #12]
 800fdd6:	f002 f973 	bl	80120c0 <lv_obj_get_parent>
 800fdda:	60f8      	str	r0, [r7, #12]
                if(parent == NULL) break;
 800fddc:	68fb      	ldr	r3, [r7, #12]
 800fdde:	2b00      	cmp	r3, #0
 800fde0:	d011      	beq.n	800fe06 <indev_proc_release+0x1fa>

                /*Ignore is the protected against click focus*/
                if(lv_obj_is_protected(parent, LV_PROTECT_CLICK_FOCUS)) {
 800fde2:	2120      	movs	r1, #32
 800fde4:	68f8      	ldr	r0, [r7, #12]
 800fde6:	f002 faf5 	bl	80123d4 <lv_obj_is_protected>
 800fdea:	4603      	mov	r3, r0
 800fdec:	2b00      	cmp	r3, #0
 800fdee:	d002      	beq.n	800fdf6 <indev_proc_release+0x1ea>
                    parent = NULL;
 800fdf0:	2300      	movs	r3, #0
 800fdf2:	60fb      	str	r3, [r7, #12]
                    break;
 800fdf4:	e008      	b.n	800fe08 <indev_proc_release+0x1fc>
                }
                g = lv_obj_get_group(parent);
 800fdf6:	68f8      	ldr	r0, [r7, #12]
 800fdf8:	f002 fb27 	bl	801244a <lv_obj_get_group>
 800fdfc:	6138      	str	r0, [r7, #16]
            while(g == NULL) {
 800fdfe:	693b      	ldr	r3, [r7, #16]
 800fe00:	2b00      	cmp	r3, #0
 800fe02:	d0e7      	beq.n	800fdd4 <indev_proc_release+0x1c8>
 800fe04:	e000      	b.n	800fe08 <indev_proc_release+0x1fc>
                if(parent == NULL) break;
 800fe06:	bf00      	nop
            }

            /* If a parent is in a group make it focused.
             * `LV_EVENT_FOCUSED/DEFOCUSED` will be sent by `lv_group_focus_obj`*/
            if(g && parent) {
 800fe08:	693b      	ldr	r3, [r7, #16]
 800fe0a:	2b00      	cmp	r3, #0
 800fe0c:	d00d      	beq.n	800fe2a <indev_proc_release+0x21e>
 800fe0e:	68fb      	ldr	r3, [r7, #12]
 800fe10:	2b00      	cmp	r3, #0
 800fe12:	d00a      	beq.n	800fe2a <indev_proc_release+0x21e>
                if(lv_group_get_click_focus(g)) {
 800fe14:	6938      	ldr	r0, [r7, #16]
 800fe16:	f7fe fb54 	bl	800e4c2 <lv_group_get_click_focus>
 800fe1a:	4603      	mov	r3, r0
 800fe1c:	2b00      	cmp	r3, #0
 800fe1e:	d004      	beq.n	800fe2a <indev_proc_release+0x21e>
                    click_focus_sent = true;
 800fe20:	2301      	movs	r3, #1
 800fe22:	75fb      	strb	r3, [r7, #23]
                    lv_group_focus_obj(parent);
 800fe24:	68f8      	ldr	r0, [r7, #12]
 800fe26:	f7fe f9c7 	bl	800e1b8 <lv_group_focus_obj>
        }
#endif

        /* Send defocus to the lastly "active" object and foucus to the new one.
         * DO not sent the events if they was sent by the click focus*/
        if(proc->types.pointer.last_pressed != indev_obj_act && click_focus_sent == false) {
 800fe2a:	687b      	ldr	r3, [r7, #4]
 800fe2c:	6a1a      	ldr	r2, [r3, #32]
 800fe2e:	4b3c      	ldr	r3, [pc, #240]	; (800ff20 <indev_proc_release+0x314>)
 800fe30:	681b      	ldr	r3, [r3, #0]
 800fe32:	429a      	cmp	r2, r3
 800fe34:	d023      	beq.n	800fe7e <indev_proc_release+0x272>
 800fe36:	7dfb      	ldrb	r3, [r7, #23]
 800fe38:	f083 0301 	eor.w	r3, r3, #1
 800fe3c:	b2db      	uxtb	r3, r3
 800fe3e:	2b00      	cmp	r3, #0
 800fe40:	d01d      	beq.n	800fe7e <indev_proc_release+0x272>
            lv_event_send(proc->types.pointer.last_pressed, LV_EVENT_DEFOCUSED, NULL);
 800fe42:	687b      	ldr	r3, [r7, #4]
 800fe44:	6a1b      	ldr	r3, [r3, #32]
 800fe46:	2200      	movs	r2, #0
 800fe48:	210d      	movs	r1, #13
 800fe4a:	4618      	mov	r0, r3
 800fe4c:	f002 f807 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800fe50:	6878      	ldr	r0, [r7, #4]
 800fe52:	f000 fbfd 	bl	8010650 <indev_reset_check>
 800fe56:	4603      	mov	r3, r0
 800fe58:	2b00      	cmp	r3, #0
 800fe5a:	d175      	bne.n	800ff48 <indev_proc_release+0x33c>

            lv_event_send(proc->types.pointer.act_obj, LV_EVENT_FOCUSED, NULL);
 800fe5c:	687b      	ldr	r3, [r7, #4]
 800fe5e:	699b      	ldr	r3, [r3, #24]
 800fe60:	2200      	movs	r2, #0
 800fe62:	210c      	movs	r1, #12
 800fe64:	4618      	mov	r0, r3
 800fe66:	f001 fffa 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 800fe6a:	6878      	ldr	r0, [r7, #4]
 800fe6c:	f000 fbf0 	bl	8010650 <indev_reset_check>
 800fe70:	4603      	mov	r3, r0
 800fe72:	2b00      	cmp	r3, #0
 800fe74:	d16a      	bne.n	800ff4c <indev_proc_release+0x340>

            proc->types.pointer.last_pressed = indev_obj_act;
 800fe76:	4b2a      	ldr	r3, [pc, #168]	; (800ff20 <indev_proc_release+0x314>)
 800fe78:	681a      	ldr	r2, [r3, #0]
 800fe7a:	687b      	ldr	r3, [r7, #4]
 800fe7c:	621a      	str	r2, [r3, #32]
        }

        if(indev_reset_check(proc)) return;
 800fe7e:	6878      	ldr	r0, [r7, #4]
 800fe80:	f000 fbe6 	bl	8010650 <indev_reset_check>
 800fe84:	4603      	mov	r3, r0
 800fe86:	2b00      	cmp	r3, #0
 800fe88:	d162      	bne.n	800ff50 <indev_proc_release+0x344>

        /*Send LV_EVENT_DRAG_THROW_BEGIN if required */
        /*If drag parent is active check recursively the drag_parent attribute*/
        lv_obj_t * drag_obj = indev_obj_act;
 800fe8a:	4b25      	ldr	r3, [pc, #148]	; (800ff20 <indev_proc_release+0x314>)
 800fe8c:	681b      	ldr	r3, [r3, #0]
 800fe8e:	60bb      	str	r3, [r7, #8]
        while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
 800fe90:	e003      	b.n	800fe9a <indev_proc_release+0x28e>
            drag_obj = lv_obj_get_parent(drag_obj);
 800fe92:	68b8      	ldr	r0, [r7, #8]
 800fe94:	f002 f914 	bl	80120c0 <lv_obj_get_parent>
 800fe98:	60b8      	str	r0, [r7, #8]
        while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
 800fe9a:	68b8      	ldr	r0, [r7, #8]
 800fe9c:	f002 fa66 	bl	801236c <lv_obj_get_drag_parent>
 800fea0:	4603      	mov	r3, r0
 800fea2:	2b00      	cmp	r3, #0
 800fea4:	d002      	beq.n	800feac <indev_proc_release+0x2a0>
 800fea6:	68bb      	ldr	r3, [r7, #8]
 800fea8:	2b00      	cmp	r3, #0
 800feaa:	d1f2      	bne.n	800fe92 <indev_proc_release+0x286>
        }

        if(drag_obj) {
 800feac:	68bb      	ldr	r3, [r7, #8]
 800feae:	2b00      	cmp	r3, #0
 800feb0:	d018      	beq.n	800fee4 <indev_proc_release+0x2d8>
            if(lv_obj_get_drag_throw(drag_obj) && proc->types.pointer.drag_in_prog) {
 800feb2:	68b8      	ldr	r0, [r7, #8]
 800feb4:	f002 fa45 	bl	8012342 <lv_obj_get_drag_throw>
 800feb8:	4603      	mov	r3, r0
 800feba:	2b00      	cmp	r3, #0
 800febc:	d012      	beq.n	800fee4 <indev_proc_release+0x2d8>
 800febe:	687b      	ldr	r3, [r7, #4]
 800fec0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800fec4:	f003 0302 	and.w	r3, r3, #2
 800fec8:	b2db      	uxtb	r3, r3
 800feca:	2b00      	cmp	r3, #0
 800fecc:	d00a      	beq.n	800fee4 <indev_proc_release+0x2d8>
                lv_event_send(drag_obj, LV_EVENT_DRAG_THROW_BEGIN, NULL);
 800fece:	2200      	movs	r2, #0
 800fed0:	210a      	movs	r1, #10
 800fed2:	68b8      	ldr	r0, [r7, #8]
 800fed4:	f001 ffc3 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(proc)) return;
 800fed8:	6878      	ldr	r0, [r7, #4]
 800feda:	f000 fbb9 	bl	8010650 <indev_reset_check>
 800fede:	4603      	mov	r3, r0
 800fee0:	2b00      	cmp	r3, #0
 800fee2:	d137      	bne.n	800ff54 <indev_proc_release+0x348>
            }
        }

        proc->types.pointer.act_obj = NULL;
 800fee4:	687b      	ldr	r3, [r7, #4]
 800fee6:	2200      	movs	r2, #0
 800fee8:	619a      	str	r2, [r3, #24]
        proc->pr_timestamp          = 0;
 800feea:	687b      	ldr	r3, [r7, #4]
 800feec:	2200      	movs	r2, #0
 800feee:	629a      	str	r2, [r3, #40]	; 0x28
        proc->longpr_rep_timestamp  = 0;
 800fef0:	687b      	ldr	r3, [r7, #4]
 800fef2:	2200      	movs	r2, #0
 800fef4:	62da      	str	r2, [r3, #44]	; 0x2c
    }

    /*The reset can be set in the signal function.
     * In case of reset query ignore the remaining parts.*/
    if(proc->types.pointer.last_obj != NULL && proc->reset_query == 0) {
 800fef6:	687b      	ldr	r3, [r7, #4]
 800fef8:	69db      	ldr	r3, [r3, #28]
 800fefa:	2b00      	cmp	r3, #0
 800fefc:	d02b      	beq.n	800ff56 <indev_proc_release+0x34a>
 800fefe:	687b      	ldr	r3, [r7, #4]
 800ff00:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 800ff04:	f003 0302 	and.w	r3, r3, #2
 800ff08:	b2db      	uxtb	r3, r3
 800ff0a:	2b00      	cmp	r3, #0
 800ff0c:	d123      	bne.n	800ff56 <indev_proc_release+0x34a>
        indev_drag_throw(proc);
 800ff0e:	6878      	ldr	r0, [r7, #4]
 800ff10:	f000 fa5c 	bl	80103cc <indev_drag_throw>
        if(indev_reset_check(proc)) return;
 800ff14:	6878      	ldr	r0, [r7, #4]
 800ff16:	f000 fb9b 	bl	8010650 <indev_reset_check>
 800ff1a:	4603      	mov	r3, r0
 800ff1c:	2b00      	cmp	r3, #0
 800ff1e:	e01a      	b.n	800ff56 <indev_proc_release+0x34a>
 800ff20:	20003f98 	.word	0x20003f98
 800ff24:	20003f94 	.word	0x20003f94
            if(indev_reset_check(proc)) return;
 800ff28:	bf00      	nop
 800ff2a:	e014      	b.n	800ff56 <indev_proc_release+0x34a>
                    if(indev_reset_check(proc)) return;
 800ff2c:	bf00      	nop
 800ff2e:	e012      	b.n	800ff56 <indev_proc_release+0x34a>
                if(indev_reset_check(proc)) return;
 800ff30:	bf00      	nop
 800ff32:	e010      	b.n	800ff56 <indev_proc_release+0x34a>
            if(indev_reset_check(proc)) return;
 800ff34:	bf00      	nop
 800ff36:	e00e      	b.n	800ff56 <indev_proc_release+0x34a>
                if(indev_reset_check(proc)) return;
 800ff38:	bf00      	nop
 800ff3a:	e00c      	b.n	800ff56 <indev_proc_release+0x34a>
            if(indev_reset_check(proc)) return;
 800ff3c:	bf00      	nop
 800ff3e:	e00a      	b.n	800ff56 <indev_proc_release+0x34a>
            if(indev_reset_check(proc)) return;
 800ff40:	bf00      	nop
 800ff42:	e008      	b.n	800ff56 <indev_proc_release+0x34a>
        if(indev_reset_check(proc)) return;
 800ff44:	bf00      	nop
 800ff46:	e006      	b.n	800ff56 <indev_proc_release+0x34a>
            if(indev_reset_check(proc)) return;
 800ff48:	bf00      	nop
 800ff4a:	e004      	b.n	800ff56 <indev_proc_release+0x34a>
            if(indev_reset_check(proc)) return;
 800ff4c:	bf00      	nop
 800ff4e:	e002      	b.n	800ff56 <indev_proc_release+0x34a>
        if(indev_reset_check(proc)) return;
 800ff50:	bf00      	nop
 800ff52:	e000      	b.n	800ff56 <indev_proc_release+0x34a>
                if(indev_reset_check(proc)) return;
 800ff54:	bf00      	nop
    }
}
 800ff56:	3718      	adds	r7, #24
 800ff58:	46bd      	mov	sp, r7
 800ff5a:	bd80      	pop	{r7, pc}

0800ff5c <indev_proc_reset_query_handler>:
 * @param data pointer to the data read from the input device
 * Reset input device if a reset query has been sent to it
 * @param indev pointer to an input device
 */
static void indev_proc_reset_query_handler(lv_indev_t * indev)
{
 800ff5c:	b480      	push	{r7}
 800ff5e:	b083      	sub	sp, #12
 800ff60:	af00      	add	r7, sp, #0
 800ff62:	6078      	str	r0, [r7, #4]
    if(indev->proc.reset_query) {
 800ff64:	687b      	ldr	r3, [r7, #4]
 800ff66:	f893 3050 	ldrb.w	r3, [r3, #80]	; 0x50
 800ff6a:	f003 0302 	and.w	r3, r3, #2
 800ff6e:	b2db      	uxtb	r3, r3
 800ff70:	2b00      	cmp	r3, #0
 800ff72:	d039      	beq.n	800ffe8 <indev_proc_reset_query_handler+0x8c>
        indev->proc.types.pointer.act_obj           = NULL;
 800ff74:	687b      	ldr	r3, [r7, #4]
 800ff76:	2200      	movs	r2, #0
 800ff78:	639a      	str	r2, [r3, #56]	; 0x38
        indev->proc.types.pointer.last_obj          = NULL;
 800ff7a:	687b      	ldr	r3, [r7, #4]
 800ff7c:	2200      	movs	r2, #0
 800ff7e:	63da      	str	r2, [r3, #60]	; 0x3c
        indev->proc.types.pointer.last_pressed      = NULL;
 800ff80:	687b      	ldr	r3, [r7, #4]
 800ff82:	2200      	movs	r2, #0
 800ff84:	641a      	str	r2, [r3, #64]	; 0x40
        indev->proc.types.pointer.drag_limit_out    = 0;
 800ff86:	687a      	ldr	r2, [r7, #4]
 800ff88:	f892 3044 	ldrb.w	r3, [r2, #68]	; 0x44
 800ff8c:	f36f 0300 	bfc	r3, #0, #1
 800ff90:	f882 3044 	strb.w	r3, [r2, #68]	; 0x44
        indev->proc.types.pointer.drag_in_prog      = 0;
 800ff94:	687a      	ldr	r2, [r7, #4]
 800ff96:	f892 3044 	ldrb.w	r3, [r2, #68]	; 0x44
 800ff9a:	f36f 0341 	bfc	r3, #1, #1
 800ff9e:	f882 3044 	strb.w	r3, [r2, #68]	; 0x44
        indev->proc.long_pr_sent                    = 0;
 800ffa2:	687a      	ldr	r2, [r7, #4]
 800ffa4:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800ffa8:	f36f 0300 	bfc	r3, #0, #1
 800ffac:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        indev->proc.pr_timestamp                    = 0;
 800ffb0:	687b      	ldr	r3, [r7, #4]
 800ffb2:	2200      	movs	r2, #0
 800ffb4:	649a      	str	r2, [r3, #72]	; 0x48
        indev->proc.longpr_rep_timestamp            = 0;
 800ffb6:	687b      	ldr	r3, [r7, #4]
 800ffb8:	2200      	movs	r2, #0
 800ffba:	64da      	str	r2, [r3, #76]	; 0x4c
        indev->proc.types.pointer.drag_sum.x        = 0;
 800ffbc:	687b      	ldr	r3, [r7, #4]
 800ffbe:	2200      	movs	r2, #0
 800ffc0:	861a      	strh	r2, [r3, #48]	; 0x30
        indev->proc.types.pointer.drag_sum.y        = 0;
 800ffc2:	687b      	ldr	r3, [r7, #4]
 800ffc4:	2200      	movs	r2, #0
 800ffc6:	865a      	strh	r2, [r3, #50]	; 0x32
        indev->proc.types.pointer.drag_throw_vect.x = 0;
 800ffc8:	687b      	ldr	r3, [r7, #4]
 800ffca:	2200      	movs	r2, #0
 800ffcc:	869a      	strh	r2, [r3, #52]	; 0x34
        indev->proc.types.pointer.drag_throw_vect.y = 0;
 800ffce:	687b      	ldr	r3, [r7, #4]
 800ffd0:	2200      	movs	r2, #0
 800ffd2:	86da      	strh	r2, [r3, #54]	; 0x36
        indev->proc.reset_query                     = 0;
 800ffd4:	687a      	ldr	r2, [r7, #4]
 800ffd6:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 800ffda:	f36f 0341 	bfc	r3, #1, #1
 800ffde:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
        indev_obj_act                               = NULL;
 800ffe2:	4b04      	ldr	r3, [pc, #16]	; (800fff4 <indev_proc_reset_query_handler+0x98>)
 800ffe4:	2200      	movs	r2, #0
 800ffe6:	601a      	str	r2, [r3, #0]
    }
}
 800ffe8:	bf00      	nop
 800ffea:	370c      	adds	r7, #12
 800ffec:	46bd      	mov	sp, r7
 800ffee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800fff2:	4770      	bx	lr
 800fff4:	20003f98 	.word	0x20003f98

0800fff8 <indev_search_obj>:
 * @param proc pointer to  the `lv_indev_proc_t` part of the input device
 * @param obj pointer to a start object, typically the screen
 * @return pointer to the found object or NULL if there was no suitable object
 */
static lv_obj_t * indev_search_obj(const lv_indev_proc_t * proc, lv_obj_t * obj)
{
 800fff8:	b580      	push	{r7, lr}
 800fffa:	b086      	sub	sp, #24
 800fffc:	af00      	add	r7, sp, #0
 800fffe:	6078      	str	r0, [r7, #4]
 8010000:	6039      	str	r1, [r7, #0]
    lv_obj_t * found_p = NULL;
 8010002:	2300      	movs	r3, #0
 8010004:	617b      	str	r3, [r7, #20]
    ext_area.y1 = obj->coords.y1 - obj->ext_click_pad.y1;
    ext_area.y2 = obj->coords.y2 + obj->ext_click_pad.y2;

    if(lv_area_is_point_on(&ext_area, &proc->types.pointer.act_point)) {
#else
    if(lv_area_is_point_on(&obj->coords, &proc->types.pointer.act_point)) {
 8010006:	683b      	ldr	r3, [r7, #0]
 8010008:	f103 0210 	add.w	r2, r3, #16
 801000c:	687b      	ldr	r3, [r7, #4]
 801000e:	3304      	adds	r3, #4
 8010010:	4619      	mov	r1, r3
 8010012:	4610      	mov	r0, r2
 8010014:	f00b fded 	bl	801bbf2 <lv_area_is_point_on>
 8010018:	4603      	mov	r3, r0
 801001a:	2b00      	cmp	r3, #0
 801001c:	d03a      	beq.n	8010094 <indev_search_obj+0x9c>
#endif
        lv_obj_t * i;

        LV_LL_READ(obj->child_ll, i)
 801001e:	683b      	ldr	r3, [r7, #0]
 8010020:	3304      	adds	r3, #4
 8010022:	4618      	mov	r0, r3
 8010024:	f00c faea 	bl	801c5fc <lv_ll_get_head>
 8010028:	6138      	str	r0, [r7, #16]
 801002a:	e00e      	b.n	801004a <indev_search_obj+0x52>
        {
            found_p = indev_search_obj(proc, i);
 801002c:	6939      	ldr	r1, [r7, #16]
 801002e:	6878      	ldr	r0, [r7, #4]
 8010030:	f7ff ffe2 	bl	800fff8 <indev_search_obj>
 8010034:	6178      	str	r0, [r7, #20]

            /*If a child was found then break*/
            if(found_p != NULL) {
 8010036:	697b      	ldr	r3, [r7, #20]
 8010038:	2b00      	cmp	r3, #0
 801003a:	d10a      	bne.n	8010052 <indev_search_obj+0x5a>
        LV_LL_READ(obj->child_ll, i)
 801003c:	683b      	ldr	r3, [r7, #0]
 801003e:	3304      	adds	r3, #4
 8010040:	6939      	ldr	r1, [r7, #16]
 8010042:	4618      	mov	r0, r3
 8010044:	f00c fb00 	bl	801c648 <lv_ll_get_next>
 8010048:	6138      	str	r0, [r7, #16]
 801004a:	693b      	ldr	r3, [r7, #16]
 801004c:	2b00      	cmp	r3, #0
 801004e:	d1ed      	bne.n	801002c <indev_search_obj+0x34>
 8010050:	e000      	b.n	8010054 <indev_search_obj+0x5c>
                break;
 8010052:	bf00      	nop
            }
        }

        /*If then the children was not ok, and this obj is clickable
         * and it or its parent is not hidden then save this object*/
        if(found_p == NULL && lv_obj_get_click(obj) != false) {
 8010054:	697b      	ldr	r3, [r7, #20]
 8010056:	2b00      	cmp	r3, #0
 8010058:	d11c      	bne.n	8010094 <indev_search_obj+0x9c>
 801005a:	6838      	ldr	r0, [r7, #0]
 801005c:	f002 f937 	bl	80122ce <lv_obj_get_click>
 8010060:	4603      	mov	r3, r0
 8010062:	2b00      	cmp	r3, #0
 8010064:	d016      	beq.n	8010094 <indev_search_obj+0x9c>
            lv_obj_t * hidden_i = obj;
 8010066:	683b      	ldr	r3, [r7, #0]
 8010068:	60fb      	str	r3, [r7, #12]
            while(hidden_i != NULL) {
 801006a:	e009      	b.n	8010080 <indev_search_obj+0x88>
                if(lv_obj_get_hidden(hidden_i) == true) break;
 801006c:	68f8      	ldr	r0, [r7, #12]
 801006e:	f002 f919 	bl	80122a4 <lv_obj_get_hidden>
 8010072:	4603      	mov	r3, r0
 8010074:	2b00      	cmp	r3, #0
 8010076:	d107      	bne.n	8010088 <indev_search_obj+0x90>
                hidden_i = lv_obj_get_parent(hidden_i);
 8010078:	68f8      	ldr	r0, [r7, #12]
 801007a:	f002 f821 	bl	80120c0 <lv_obj_get_parent>
 801007e:	60f8      	str	r0, [r7, #12]
            while(hidden_i != NULL) {
 8010080:	68fb      	ldr	r3, [r7, #12]
 8010082:	2b00      	cmp	r3, #0
 8010084:	d1f2      	bne.n	801006c <indev_search_obj+0x74>
 8010086:	e000      	b.n	801008a <indev_search_obj+0x92>
                if(lv_obj_get_hidden(hidden_i) == true) break;
 8010088:	bf00      	nop
            }
            /*No parent found with hidden == true*/
            if(hidden_i == NULL) found_p = obj;
 801008a:	68fb      	ldr	r3, [r7, #12]
 801008c:	2b00      	cmp	r3, #0
 801008e:	d101      	bne.n	8010094 <indev_search_obj+0x9c>
 8010090:	683b      	ldr	r3, [r7, #0]
 8010092:	617b      	str	r3, [r7, #20]
        }
    }

    return found_p;
 8010094:	697b      	ldr	r3, [r7, #20]
}
 8010096:	4618      	mov	r0, r3
 8010098:	3718      	adds	r7, #24
 801009a:	46bd      	mov	sp, r7
 801009c:	bd80      	pop	{r7, pc}
	...

080100a0 <indev_drag>:
/**
 * Handle the dragging of indev_proc_p->types.pointer.act_obj
 * @param indev pointer to a input device state
 */
static void indev_drag(lv_indev_proc_t * state)
{
 80100a0:	b580      	push	{r7, lr}
 80100a2:	b08a      	sub	sp, #40	; 0x28
 80100a4:	af00      	add	r7, sp, #0
 80100a6:	6078      	str	r0, [r7, #4]
    lv_obj_t * drag_obj    = state->types.pointer.act_obj;
 80100a8:	687b      	ldr	r3, [r7, #4]
 80100aa:	699b      	ldr	r3, [r3, #24]
 80100ac:	627b      	str	r3, [r7, #36]	; 0x24
    bool drag_just_started = false;
 80100ae:	2300      	movs	r3, #0
 80100b0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    /*If drag parent is active check recursively the drag_parent attribute*/
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
 80100b4:	e003      	b.n	80100be <indev_drag+0x1e>
        drag_obj = lv_obj_get_parent(drag_obj);
 80100b6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80100b8:	f002 f802 	bl	80120c0 <lv_obj_get_parent>
 80100bc:	6278      	str	r0, [r7, #36]	; 0x24
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
 80100be:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80100c0:	f002 f954 	bl	801236c <lv_obj_get_drag_parent>
 80100c4:	4603      	mov	r3, r0
 80100c6:	2b00      	cmp	r3, #0
 80100c8:	d002      	beq.n	80100d0 <indev_drag+0x30>
 80100ca:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100cc:	2b00      	cmp	r3, #0
 80100ce:	d1f2      	bne.n	80100b6 <indev_drag+0x16>
    }

    if(drag_obj == NULL) return;
 80100d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100d2:	2b00      	cmp	r3, #0
 80100d4:	f000 816d 	beq.w	80103b2 <indev_drag+0x312>

    if(lv_obj_get_drag(drag_obj) == false) return;
 80100d8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80100da:	f002 f90d 	bl	80122f8 <lv_obj_get_drag>
 80100de:	4603      	mov	r3, r0
 80100e0:	f083 0301 	eor.w	r3, r3, #1
 80100e4:	b2db      	uxtb	r3, r3
 80100e6:	2b00      	cmp	r3, #0
 80100e8:	f040 8165 	bne.w	80103b6 <indev_drag+0x316>

    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
 80100ec:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80100ee:	f002 f918 	bl	8012322 <lv_obj_get_drag_dir>
 80100f2:	4603      	mov	r3, r0
 80100f4:	777b      	strb	r3, [r7, #29]

    /*Count the movement by drag*/
    state->types.pointer.drag_sum.x += state->types.pointer.vect.x;
 80100f6:	687b      	ldr	r3, [r7, #4]
 80100f8:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80100fc:	b29a      	uxth	r2, r3
 80100fe:	687b      	ldr	r3, [r7, #4]
 8010100:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8010104:	b29b      	uxth	r3, r3
 8010106:	4413      	add	r3, r2
 8010108:	b29b      	uxth	r3, r3
 801010a:	b21a      	sxth	r2, r3
 801010c:	687b      	ldr	r3, [r7, #4]
 801010e:	821a      	strh	r2, [r3, #16]
    state->types.pointer.drag_sum.y += state->types.pointer.vect.y;
 8010110:	687b      	ldr	r3, [r7, #4]
 8010112:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8010116:	b29a      	uxth	r2, r3
 8010118:	687b      	ldr	r3, [r7, #4]
 801011a:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 801011e:	b29b      	uxth	r3, r3
 8010120:	4413      	add	r3, r2
 8010122:	b29b      	uxth	r3, r3
 8010124:	b21a      	sxth	r2, r3
 8010126:	687b      	ldr	r3, [r7, #4]
 8010128:	825a      	strh	r2, [r3, #18]

    /*Enough move?*/
    if(state->types.pointer.drag_limit_out == 0) {
 801012a:	687b      	ldr	r3, [r7, #4]
 801012c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8010130:	f003 0301 	and.w	r3, r3, #1
 8010134:	b2db      	uxtb	r3, r3
 8010136:	2b00      	cmp	r3, #0
 8010138:	d129      	bne.n	801018e <indev_drag+0xee>
        /*If a move is greater then LV_DRAG_LIMIT then begin the drag*/
        if(((allowed_dirs & LV_DRAG_DIR_HOR) &&
 801013a:	7f7b      	ldrb	r3, [r7, #29]
 801013c:	f003 0301 	and.w	r3, r3, #1
 8010140:	2b00      	cmp	r3, #0
 8010142:	d00a      	beq.n	801015a <indev_drag+0xba>
            LV_MATH_ABS(state->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||
 8010144:	687b      	ldr	r3, [r7, #4]
 8010146:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801014a:	2b00      	cmp	r3, #0
 801014c:	bfb8      	it	lt
 801014e:	425b      	neglt	r3, r3
 8010150:	4a9d      	ldr	r2, [pc, #628]	; (80103c8 <indev_drag+0x328>)
 8010152:	6812      	ldr	r2, [r2, #0]
 8010154:	7e12      	ldrb	r2, [r2, #24]
        if(((allowed_dirs & LV_DRAG_DIR_HOR) &&
 8010156:	4293      	cmp	r3, r2
 8010158:	da0f      	bge.n	801017a <indev_drag+0xda>
           ((allowed_dirs & LV_DRAG_DIR_VER) &&
 801015a:	7f7b      	ldrb	r3, [r7, #29]
 801015c:	f003 0302 	and.w	r3, r3, #2
            LV_MATH_ABS(state->types.pointer.drag_sum.x) >= indev_act->driver.drag_limit) ||
 8010160:	2b00      	cmp	r3, #0
 8010162:	d014      	beq.n	801018e <indev_drag+0xee>
            LV_MATH_ABS(state->types.pointer.drag_sum.y) >= indev_act->driver.drag_limit)) {
 8010164:	687b      	ldr	r3, [r7, #4]
 8010166:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801016a:	2b00      	cmp	r3, #0
 801016c:	bfb8      	it	lt
 801016e:	425b      	neglt	r3, r3
 8010170:	4a95      	ldr	r2, [pc, #596]	; (80103c8 <indev_drag+0x328>)
 8010172:	6812      	ldr	r2, [r2, #0]
 8010174:	7e12      	ldrb	r2, [r2, #24]
           ((allowed_dirs & LV_DRAG_DIR_VER) &&
 8010176:	4293      	cmp	r3, r2
 8010178:	db09      	blt.n	801018e <indev_drag+0xee>
            state->types.pointer.drag_limit_out = 1;
 801017a:	687a      	ldr	r2, [r7, #4]
 801017c:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8010180:	f043 0301 	orr.w	r3, r3, #1
 8010184:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            drag_just_started                   = true;
 8010188:	2301      	movs	r3, #1
 801018a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        }
    }

    /*If the drag limit is exceeded handle the dragging*/
    if(state->types.pointer.drag_limit_out != 0) {
 801018e:	687b      	ldr	r3, [r7, #4]
 8010190:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8010194:	f003 0301 	and.w	r3, r3, #1
 8010198:	b2db      	uxtb	r3, r3
 801019a:	2b00      	cmp	r3, #0
 801019c:	f000 8110 	beq.w	80103c0 <indev_drag+0x320>
        /*Set new position if the vector is not zero*/
        if(state->types.pointer.vect.x != 0 || state->types.pointer.vect.y != 0) {
 80101a0:	687b      	ldr	r3, [r7, #4]
 80101a2:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80101a6:	2b00      	cmp	r3, #0
 80101a8:	d105      	bne.n	80101b6 <indev_drag+0x116>
 80101aa:	687b      	ldr	r3, [r7, #4]
 80101ac:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 80101b0:	2b00      	cmp	r3, #0
 80101b2:	f000 8105 	beq.w	80103c0 <indev_drag+0x320>

            uint16_t inv_buf_size =
                lv_disp_get_inv_buf_size(indev_act->driver.disp); /*Get the number of currently invalidated areas*/
 80101b6:	4b84      	ldr	r3, [pc, #528]	; (80103c8 <indev_drag+0x328>)
 80101b8:	681b      	ldr	r3, [r3, #0]
 80101ba:	691b      	ldr	r3, [r3, #16]
            uint16_t inv_buf_size =
 80101bc:	4618      	mov	r0, r3
 80101be:	f00b f825 	bl	801b20c <lv_disp_get_inv_buf_size>
 80101c2:	4603      	mov	r3, r0
 80101c4:	837b      	strh	r3, [r7, #26]

            lv_coord_t prev_x     = drag_obj->coords.x1;
 80101c6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80101c8:	8a1b      	ldrh	r3, [r3, #16]
 80101ca:	833b      	strh	r3, [r7, #24]
            lv_coord_t prev_y     = drag_obj->coords.y1;
 80101cc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80101ce:	8a5b      	ldrh	r3, [r3, #18]
 80101d0:	82fb      	strh	r3, [r7, #22]
            lv_coord_t prev_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
 80101d2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80101d4:	f001 ff74 	bl	80120c0 <lv_obj_get_parent>
 80101d8:	4603      	mov	r3, r0
 80101da:	4618      	mov	r0, r3
 80101dc:	f001 ffda 	bl	8012194 <lv_obj_get_width>
 80101e0:	4603      	mov	r3, r0
 80101e2:	82bb      	strh	r3, [r7, #20]
            lv_coord_t prev_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
 80101e4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80101e6:	f001 ff6b 	bl	80120c0 <lv_obj_get_parent>
 80101ea:	4603      	mov	r3, r0
 80101ec:	4618      	mov	r0, r3
 80101ee:	f001 ffdf 	bl	80121b0 <lv_obj_get_height>
 80101f2:	4603      	mov	r3, r0
 80101f4:	827b      	strh	r3, [r7, #18]

            /*Get the coordinates of the object and modify them*/
            lv_coord_t act_x = lv_obj_get_x(drag_obj);
 80101f6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80101f8:	f001 ff9a 	bl	8012130 <lv_obj_get_x>
 80101fc:	4603      	mov	r3, r0
 80101fe:	843b      	strh	r3, [r7, #32]
            lv_coord_t act_y = lv_obj_get_y(drag_obj);
 8010200:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010202:	f001 ffae 	bl	8012162 <lv_obj_get_y>
 8010206:	4603      	mov	r3, r0
 8010208:	83fb      	strh	r3, [r7, #30]

            if(allowed_dirs == LV_DRAG_DIR_ALL) {
 801020a:	7f7b      	ldrb	r3, [r7, #29]
 801020c:	2b03      	cmp	r3, #3
 801020e:	d128      	bne.n	8010262 <indev_drag+0x1c2>
                if(drag_just_started) {
 8010210:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010214:	2b00      	cmp	r3, #0
 8010216:	d00f      	beq.n	8010238 <indev_drag+0x198>
                    act_x += state->types.pointer.drag_sum.x;
 8010218:	687b      	ldr	r3, [r7, #4]
 801021a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801021e:	b29a      	uxth	r2, r3
 8010220:	8c3b      	ldrh	r3, [r7, #32]
 8010222:	4413      	add	r3, r2
 8010224:	b29b      	uxth	r3, r3
 8010226:	843b      	strh	r3, [r7, #32]
                    act_y += state->types.pointer.drag_sum.y;
 8010228:	687b      	ldr	r3, [r7, #4]
 801022a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801022e:	b29a      	uxth	r2, r3
 8010230:	8bfb      	ldrh	r3, [r7, #30]
 8010232:	4413      	add	r3, r2
 8010234:	b29b      	uxth	r3, r3
 8010236:	83fb      	strh	r3, [r7, #30]
                }
                lv_obj_set_pos(drag_obj, act_x + state->types.pointer.vect.x, act_y + state->types.pointer.vect.y);
 8010238:	687b      	ldr	r3, [r7, #4]
 801023a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 801023e:	b29a      	uxth	r2, r3
 8010240:	8c3b      	ldrh	r3, [r7, #32]
 8010242:	4413      	add	r3, r2
 8010244:	b29b      	uxth	r3, r3
 8010246:	b219      	sxth	r1, r3
 8010248:	687b      	ldr	r3, [r7, #4]
 801024a:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 801024e:	b29a      	uxth	r2, r3
 8010250:	8bfb      	ldrh	r3, [r7, #30]
 8010252:	4413      	add	r3, r2
 8010254:	b29b      	uxth	r3, r3
 8010256:	b21b      	sxth	r3, r3
 8010258:	461a      	mov	r2, r3
 801025a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801025c:	f000 fef8 	bl	8011050 <lv_obj_set_pos>
 8010260:	e03a      	b.n	80102d8 <indev_drag+0x238>
            } else if(allowed_dirs & LV_DRAG_DIR_HOR) {
 8010262:	7f7b      	ldrb	r3, [r7, #29]
 8010264:	f003 0301 	and.w	r3, r3, #1
 8010268:	2b00      	cmp	r3, #0
 801026a:	d018      	beq.n	801029e <indev_drag+0x1fe>
                if(drag_just_started) {
 801026c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010270:	2b00      	cmp	r3, #0
 8010272:	d007      	beq.n	8010284 <indev_drag+0x1e4>
                    act_x += state->types.pointer.drag_sum.x;
 8010274:	687b      	ldr	r3, [r7, #4]
 8010276:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801027a:	b29a      	uxth	r2, r3
 801027c:	8c3b      	ldrh	r3, [r7, #32]
 801027e:	4413      	add	r3, r2
 8010280:	b29b      	uxth	r3, r3
 8010282:	843b      	strh	r3, [r7, #32]
                }
                lv_obj_set_x(drag_obj, act_x + state->types.pointer.vect.x);
 8010284:	687b      	ldr	r3, [r7, #4]
 8010286:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 801028a:	b29a      	uxth	r2, r3
 801028c:	8c3b      	ldrh	r3, [r7, #32]
 801028e:	4413      	add	r3, r2
 8010290:	b29b      	uxth	r3, r3
 8010292:	b21b      	sxth	r3, r3
 8010294:	4619      	mov	r1, r3
 8010296:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010298:	f000 ff65 	bl	8011166 <lv_obj_set_x>
 801029c:	e01c      	b.n	80102d8 <indev_drag+0x238>
            } else if(allowed_dirs & LV_DRAG_DIR_VER) {
 801029e:	7f7b      	ldrb	r3, [r7, #29]
 80102a0:	f003 0302 	and.w	r3, r3, #2
 80102a4:	2b00      	cmp	r3, #0
 80102a6:	d017      	beq.n	80102d8 <indev_drag+0x238>
                if(drag_just_started) {
 80102a8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 80102ac:	2b00      	cmp	r3, #0
 80102ae:	d007      	beq.n	80102c0 <indev_drag+0x220>
                    act_y += state->types.pointer.drag_sum.y;
 80102b0:	687b      	ldr	r3, [r7, #4]
 80102b2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80102b6:	b29a      	uxth	r2, r3
 80102b8:	8bfb      	ldrh	r3, [r7, #30]
 80102ba:	4413      	add	r3, r2
 80102bc:	b29b      	uxth	r3, r3
 80102be:	83fb      	strh	r3, [r7, #30]
                }
                lv_obj_set_y(drag_obj, act_y + state->types.pointer.vect.y);
 80102c0:	687b      	ldr	r3, [r7, #4]
 80102c2:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 80102c6:	b29a      	uxth	r2, r3
 80102c8:	8bfb      	ldrh	r3, [r7, #30]
 80102ca:	4413      	add	r3, r2
 80102cc:	b29b      	uxth	r3, r3
 80102ce:	b21b      	sxth	r3, r3
 80102d0:	4619      	mov	r1, r3
 80102d2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80102d4:	f000 ff5c 	bl	8011190 <lv_obj_set_y>
            }

            /*Set the drag in progress flag*/
            /*Send the drag begin signal on first move*/
            if(state->types.pointer.drag_in_prog == 0) {
 80102d8:	687b      	ldr	r3, [r7, #4]
 80102da:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80102de:	f003 0302 	and.w	r3, r3, #2
 80102e2:	b2db      	uxtb	r3, r3
 80102e4:	2b00      	cmp	r3, #0
 80102e6:	d117      	bne.n	8010318 <indev_drag+0x278>
                drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_BEGIN, indev_act);
 80102e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80102ea:	69db      	ldr	r3, [r3, #28]
 80102ec:	4a36      	ldr	r2, [pc, #216]	; (80103c8 <indev_drag+0x328>)
 80102ee:	6812      	ldr	r2, [r2, #0]
 80102f0:	210d      	movs	r1, #13
 80102f2:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80102f4:	4798      	blx	r3
                if(indev_reset_check(state)) return;
 80102f6:	6878      	ldr	r0, [r7, #4]
 80102f8:	f000 f9aa 	bl	8010650 <indev_reset_check>
 80102fc:	4603      	mov	r3, r0
 80102fe:	2b00      	cmp	r3, #0
 8010300:	d15b      	bne.n	80103ba <indev_drag+0x31a>
                lv_event_send(drag_obj, LV_EVENT_DRAG_BEGIN, NULL);
 8010302:	2200      	movs	r2, #0
 8010304:	2108      	movs	r1, #8
 8010306:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010308:	f001 fda9 	bl	8011e5e <lv_event_send>
                if(indev_reset_check(state)) return;
 801030c:	6878      	ldr	r0, [r7, #4]
 801030e:	f000 f99f 	bl	8010650 <indev_reset_check>
 8010312:	4603      	mov	r3, r0
 8010314:	2b00      	cmp	r3, #0
 8010316:	d152      	bne.n	80103be <indev_drag+0x31e>
            }

            state->types.pointer.drag_in_prog = 1;
 8010318:	687a      	ldr	r2, [r7, #4]
 801031a:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801031e:	f043 0302 	orr.w	r3, r3, #2
 8010322:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24

            /*If the object didn't moved then clear the invalidated areas*/
            if(drag_obj->coords.x1 == prev_x && drag_obj->coords.y1 == prev_y) {
 8010326:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010328:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801032c:	f9b7 2018 	ldrsh.w	r2, [r7, #24]
 8010330:	429a      	cmp	r2, r3
 8010332:	d145      	bne.n	80103c0 <indev_drag+0x320>
 8010334:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010336:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801033a:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 801033e:	429a      	cmp	r2, r3
 8010340:	d13e      	bne.n	80103c0 <indev_drag+0x320>
                state->types.pointer.drag_in_prog = 0;
 8010342:	687a      	ldr	r2, [r7, #4]
 8010344:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8010348:	f36f 0341 	bfc	r3, #1, #1
 801034c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
                /*In a special case if the object is moved on a page and
                 * the scrollable has fit == true and the object is dragged of the page then
                 * while its coordinate is not changing only the parent's size is reduced */
                lv_coord_t act_par_w = lv_obj_get_width(lv_obj_get_parent(drag_obj));
 8010350:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010352:	f001 feb5 	bl	80120c0 <lv_obj_get_parent>
 8010356:	4603      	mov	r3, r0
 8010358:	4618      	mov	r0, r3
 801035a:	f001 ff1b 	bl	8012194 <lv_obj_get_width>
 801035e:	4603      	mov	r3, r0
 8010360:	823b      	strh	r3, [r7, #16]
                lv_coord_t act_par_h = lv_obj_get_height(lv_obj_get_parent(drag_obj));
 8010362:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010364:	f001 feac 	bl	80120c0 <lv_obj_get_parent>
 8010368:	4603      	mov	r3, r0
 801036a:	4618      	mov	r0, r3
 801036c:	f001 ff20 	bl	80121b0 <lv_obj_get_height>
 8010370:	4603      	mov	r3, r0
 8010372:	81fb      	strh	r3, [r7, #14]
                if(act_par_w == prev_par_w && act_par_h == prev_par_h) {
 8010374:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 8010378:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801037c:	429a      	cmp	r2, r3
 801037e:	d11f      	bne.n	80103c0 <indev_drag+0x320>
 8010380:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8010384:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8010388:	429a      	cmp	r2, r3
 801038a:	d119      	bne.n	80103c0 <indev_drag+0x320>
                    uint16_t new_inv_buf_size = lv_disp_get_inv_buf_size(indev_act->driver.disp);
 801038c:	4b0e      	ldr	r3, [pc, #56]	; (80103c8 <indev_drag+0x328>)
 801038e:	681b      	ldr	r3, [r3, #0]
 8010390:	691b      	ldr	r3, [r3, #16]
 8010392:	4618      	mov	r0, r3
 8010394:	f00a ff3a 	bl	801b20c <lv_disp_get_inv_buf_size>
 8010398:	4603      	mov	r3, r0
 801039a:	81bb      	strh	r3, [r7, #12]
                    lv_disp_pop_from_inv_buf(indev_act->driver.disp, new_inv_buf_size - inv_buf_size);
 801039c:	4b0a      	ldr	r3, [pc, #40]	; (80103c8 <indev_drag+0x328>)
 801039e:	681b      	ldr	r3, [r3, #0]
 80103a0:	6918      	ldr	r0, [r3, #16]
 80103a2:	89ba      	ldrh	r2, [r7, #12]
 80103a4:	8b7b      	ldrh	r3, [r7, #26]
 80103a6:	1ad3      	subs	r3, r2, r3
 80103a8:	b29b      	uxth	r3, r3
 80103aa:	4619      	mov	r1, r3
 80103ac:	f00a ff3e 	bl	801b22c <lv_disp_pop_from_inv_buf>
 80103b0:	e006      	b.n	80103c0 <indev_drag+0x320>
    if(drag_obj == NULL) return;
 80103b2:	bf00      	nop
 80103b4:	e004      	b.n	80103c0 <indev_drag+0x320>
    if(lv_obj_get_drag(drag_obj) == false) return;
 80103b6:	bf00      	nop
 80103b8:	e002      	b.n	80103c0 <indev_drag+0x320>
                if(indev_reset_check(state)) return;
 80103ba:	bf00      	nop
 80103bc:	e000      	b.n	80103c0 <indev_drag+0x320>
                if(indev_reset_check(state)) return;
 80103be:	bf00      	nop
                }
            }
        }
    }
}
 80103c0:	3728      	adds	r7, #40	; 0x28
 80103c2:	46bd      	mov	sp, r7
 80103c4:	bd80      	pop	{r7, pc}
 80103c6:	bf00      	nop
 80103c8:	20003f94 	.word	0x20003f94

080103cc <indev_drag_throw>:
/**
 * Handle throwing by drag if the drag is ended
 * @param indev pointer to an input device state
 */
static void indev_drag_throw(lv_indev_proc_t * proc)
{
 80103cc:	b580      	push	{r7, lr}
 80103ce:	b08a      	sub	sp, #40	; 0x28
 80103d0:	af00      	add	r7, sp, #0
 80103d2:	6078      	str	r0, [r7, #4]
    if(proc->types.pointer.drag_in_prog == 0) return;
 80103d4:	687b      	ldr	r3, [r7, #4]
 80103d6:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80103da:	f003 0302 	and.w	r3, r3, #2
 80103de:	b2db      	uxtb	r3, r3
 80103e0:	2b00      	cmp	r3, #0
 80103e2:	f000 8123 	beq.w	801062c <indev_drag_throw+0x260>

    lv_obj_t * drag_obj = proc->types.pointer.last_obj;
 80103e6:	687b      	ldr	r3, [r7, #4]
 80103e8:	69db      	ldr	r3, [r3, #28]
 80103ea:	627b      	str	r3, [r7, #36]	; 0x24

    /*If drag parent is active check recursively the drag_parent attribute*/
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
 80103ec:	e003      	b.n	80103f6 <indev_drag_throw+0x2a>
        drag_obj = lv_obj_get_parent(drag_obj);
 80103ee:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80103f0:	f001 fe66 	bl	80120c0 <lv_obj_get_parent>
 80103f4:	6278      	str	r0, [r7, #36]	; 0x24
    while(lv_obj_get_drag_parent(drag_obj) != false && drag_obj != NULL) {
 80103f6:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80103f8:	f001 ffb8 	bl	801236c <lv_obj_get_drag_parent>
 80103fc:	4603      	mov	r3, r0
 80103fe:	2b00      	cmp	r3, #0
 8010400:	d002      	beq.n	8010408 <indev_drag_throw+0x3c>
 8010402:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010404:	2b00      	cmp	r3, #0
 8010406:	d1f2      	bne.n	80103ee <indev_drag_throw+0x22>
    }

    if(drag_obj == NULL) {
 8010408:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801040a:	2b00      	cmp	r3, #0
 801040c:	f000 8110 	beq.w	8010630 <indev_drag_throw+0x264>
        return;
    }

    /*Return if the drag throw is not enabled*/
    if(lv_obj_get_drag_throw(drag_obj) == false) {
 8010410:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010412:	f001 ff96 	bl	8012342 <lv_obj_get_drag_throw>
 8010416:	4603      	mov	r3, r0
 8010418:	f083 0301 	eor.w	r3, r3, #1
 801041c:	b2db      	uxtb	r3, r3
 801041e:	2b00      	cmp	r3, #0
 8010420:	d01f      	beq.n	8010462 <indev_drag_throw+0x96>
        proc->types.pointer.drag_in_prog = 0;
 8010422:	687a      	ldr	r2, [r7, #4]
 8010424:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 8010428:	f36f 0341 	bfc	r3, #1, #1
 801042c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
 8010430:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010432:	69db      	ldr	r3, [r3, #28]
 8010434:	4a84      	ldr	r2, [pc, #528]	; (8010648 <indev_drag_throw+0x27c>)
 8010436:	6812      	ldr	r2, [r2, #0]
 8010438:	210e      	movs	r1, #14
 801043a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801043c:	4798      	blx	r3
        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
 801043e:	2200      	movs	r2, #0
 8010440:	2109      	movs	r1, #9
 8010442:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010444:	f001 fd0b 	bl	8011e5e <lv_event_send>
        if(indev_reset_check(proc)) return;
 8010448:	6878      	ldr	r0, [r7, #4]
 801044a:	f000 f901 	bl	8010650 <indev_reset_check>
 801044e:	4603      	mov	r3, r0
 8010450:	2b00      	cmp	r3, #0
 8010452:	f040 80ef 	bne.w	8010634 <indev_drag_throw+0x268>

        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
 8010456:	2200      	movs	r2, #0
 8010458:	2109      	movs	r1, #9
 801045a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801045c:	f001 fcff 	bl	8011e5e <lv_event_send>
        return;
 8010460:	e0ef      	b.n	8010642 <indev_drag_throw+0x276>
    }

    lv_drag_dir_t allowed_dirs = lv_obj_get_drag_dir(drag_obj);
 8010462:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010464:	f001 ff5d 	bl	8012322 <lv_obj_get_drag_dir>
 8010468:	4603      	mov	r3, r0
 801046a:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    /*Reduce the vectors*/
    proc->types.pointer.drag_throw_vect.x =
        proc->types.pointer.drag_throw_vect.x * (100 - indev_act->driver.drag_throw) / 100;
 801046e:	687b      	ldr	r3, [r7, #4]
 8010470:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8010474:	461a      	mov	r2, r3
 8010476:	4b74      	ldr	r3, [pc, #464]	; (8010648 <indev_drag_throw+0x27c>)
 8010478:	681b      	ldr	r3, [r3, #0]
 801047a:	7e5b      	ldrb	r3, [r3, #25]
 801047c:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 8010480:	fb03 f302 	mul.w	r3, r3, r2
 8010484:	4a71      	ldr	r2, [pc, #452]	; (801064c <indev_drag_throw+0x280>)
 8010486:	fb82 1203 	smull	r1, r2, r2, r3
 801048a:	1152      	asrs	r2, r2, #5
 801048c:	17db      	asrs	r3, r3, #31
 801048e:	1ad3      	subs	r3, r2, r3
    proc->types.pointer.drag_throw_vect.x =
 8010490:	b21a      	sxth	r2, r3
 8010492:	687b      	ldr	r3, [r7, #4]
 8010494:	829a      	strh	r2, [r3, #20]
    proc->types.pointer.drag_throw_vect.y =
        proc->types.pointer.drag_throw_vect.y * (100 - indev_act->driver.drag_throw) / 100;
 8010496:	687b      	ldr	r3, [r7, #4]
 8010498:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 801049c:	461a      	mov	r2, r3
 801049e:	4b6a      	ldr	r3, [pc, #424]	; (8010648 <indev_drag_throw+0x27c>)
 80104a0:	681b      	ldr	r3, [r3, #0]
 80104a2:	7e5b      	ldrb	r3, [r3, #25]
 80104a4:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 80104a8:	fb03 f302 	mul.w	r3, r3, r2
 80104ac:	4a67      	ldr	r2, [pc, #412]	; (801064c <indev_drag_throw+0x280>)
 80104ae:	fb82 1203 	smull	r1, r2, r2, r3
 80104b2:	1152      	asrs	r2, r2, #5
 80104b4:	17db      	asrs	r3, r3, #31
 80104b6:	1ad3      	subs	r3, r2, r3
    proc->types.pointer.drag_throw_vect.y =
 80104b8:	b21a      	sxth	r2, r3
 80104ba:	687b      	ldr	r3, [r7, #4]
 80104bc:	82da      	strh	r2, [r3, #22]

    if(proc->types.pointer.drag_throw_vect.x != 0 || proc->types.pointer.drag_throw_vect.y != 0) {
 80104be:	687b      	ldr	r3, [r7, #4]
 80104c0:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80104c4:	2b00      	cmp	r3, #0
 80104c6:	d105      	bne.n	80104d4 <indev_drag_throw+0x108>
 80104c8:	687b      	ldr	r3, [r7, #4]
 80104ca:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80104ce:	2b00      	cmp	r3, #0
 80104d0:	f000 808d 	beq.w	80105ee <indev_drag_throw+0x222>
        /*Get the coordinates and modify them*/
        lv_area_t coords_ori;
        lv_obj_get_coords(drag_obj, &coords_ori);
 80104d4:	f107 0314 	add.w	r3, r7, #20
 80104d8:	4619      	mov	r1, r3
 80104da:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80104dc:	f001 fe19 	bl	8012112 <lv_obj_get_coords>
        lv_coord_t act_x = lv_obj_get_x(drag_obj) + proc->types.pointer.drag_throw_vect.x;
 80104e0:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80104e2:	f001 fe25 	bl	8012130 <lv_obj_get_x>
 80104e6:	4603      	mov	r3, r0
 80104e8:	b29a      	uxth	r2, r3
 80104ea:	687b      	ldr	r3, [r7, #4]
 80104ec:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80104f0:	b29b      	uxth	r3, r3
 80104f2:	4413      	add	r3, r2
 80104f4:	b29b      	uxth	r3, r3
 80104f6:	843b      	strh	r3, [r7, #32]
        lv_coord_t act_y = lv_obj_get_y(drag_obj) + proc->types.pointer.drag_throw_vect.y;
 80104f8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80104fa:	f001 fe32 	bl	8012162 <lv_obj_get_y>
 80104fe:	4603      	mov	r3, r0
 8010500:	b29a      	uxth	r2, r3
 8010502:	687b      	ldr	r3, [r7, #4]
 8010504:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8010508:	b29b      	uxth	r3, r3
 801050a:	4413      	add	r3, r2
 801050c:	b29b      	uxth	r3, r3
 801050e:	83fb      	strh	r3, [r7, #30]

        if(allowed_dirs == LV_DRAG_DIR_ALL)
 8010510:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010514:	2b03      	cmp	r3, #3
 8010516:	d108      	bne.n	801052a <indev_drag_throw+0x15e>
            lv_obj_set_pos(drag_obj, act_x, act_y);
 8010518:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 801051c:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8010520:	4619      	mov	r1, r3
 8010522:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010524:	f000 fd94 	bl	8011050 <lv_obj_set_pos>
 8010528:	e018      	b.n	801055c <indev_drag_throw+0x190>
        else if(allowed_dirs & LV_DRAG_DIR_HOR)
 801052a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 801052e:	f003 0301 	and.w	r3, r3, #1
 8010532:	2b00      	cmp	r3, #0
 8010534:	d006      	beq.n	8010544 <indev_drag_throw+0x178>
            lv_obj_set_x(drag_obj, act_x);
 8010536:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801053a:	4619      	mov	r1, r3
 801053c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801053e:	f000 fe12 	bl	8011166 <lv_obj_set_x>
 8010542:	e00b      	b.n	801055c <indev_drag_throw+0x190>
        else if(allowed_dirs & LV_DRAG_DIR_VER)
 8010544:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010548:	f003 0302 	and.w	r3, r3, #2
 801054c:	2b00      	cmp	r3, #0
 801054e:	d005      	beq.n	801055c <indev_drag_throw+0x190>
            lv_obj_set_y(drag_obj, act_y);
 8010550:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8010554:	4619      	mov	r1, r3
 8010556:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010558:	f000 fe1a 	bl	8011190 <lv_obj_set_y>

        lv_area_t coord_new;
        lv_obj_get_coords(drag_obj, &coord_new);
 801055c:	f107 030c 	add.w	r3, r7, #12
 8010560:	4619      	mov	r1, r3
 8010562:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010564:	f001 fdd5 	bl	8012112 <lv_obj_get_coords>

        /*If non of the coordinates are changed then do not continue throwing*/
        if((coords_ori.x1 == coord_new.x1 || proc->types.pointer.drag_throw_vect.x == 0) &&
 8010568:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 801056c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8010570:	429a      	cmp	r2, r3
 8010572:	d004      	beq.n	801057e <indev_drag_throw+0x1b2>
 8010574:	687b      	ldr	r3, [r7, #4]
 8010576:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 801057a:	2b00      	cmp	r3, #0
 801057c:	d15c      	bne.n	8010638 <indev_drag_throw+0x26c>
           (coords_ori.y1 == coord_new.y1 || proc->types.pointer.drag_throw_vect.y == 0)) {
 801057e:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8010582:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
        if((coords_ori.x1 == coord_new.x1 || proc->types.pointer.drag_throw_vect.x == 0) &&
 8010586:	429a      	cmp	r2, r3
 8010588:	d004      	beq.n	8010594 <indev_drag_throw+0x1c8>
           (coords_ori.y1 == coord_new.y1 || proc->types.pointer.drag_throw_vect.y == 0)) {
 801058a:	687b      	ldr	r3, [r7, #4]
 801058c:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8010590:	2b00      	cmp	r3, #0
 8010592:	d151      	bne.n	8010638 <indev_drag_throw+0x26c>
            proc->types.pointer.drag_in_prog      = 0;
 8010594:	687a      	ldr	r2, [r7, #4]
 8010596:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801059a:	f36f 0341 	bfc	r3, #1, #1
 801059e:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            proc->types.pointer.vect.x            = 0;
 80105a2:	687b      	ldr	r3, [r7, #4]
 80105a4:	2200      	movs	r2, #0
 80105a6:	819a      	strh	r2, [r3, #12]
            proc->types.pointer.vect.y            = 0;
 80105a8:	687b      	ldr	r3, [r7, #4]
 80105aa:	2200      	movs	r2, #0
 80105ac:	81da      	strh	r2, [r3, #14]
            proc->types.pointer.drag_throw_vect.x = 0;
 80105ae:	687b      	ldr	r3, [r7, #4]
 80105b0:	2200      	movs	r2, #0
 80105b2:	829a      	strh	r2, [r3, #20]
            proc->types.pointer.drag_throw_vect.y = 0;
 80105b4:	687b      	ldr	r3, [r7, #4]
 80105b6:	2200      	movs	r2, #0
 80105b8:	82da      	strh	r2, [r3, #22]
            drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
 80105ba:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105bc:	69db      	ldr	r3, [r3, #28]
 80105be:	4a22      	ldr	r2, [pc, #136]	; (8010648 <indev_drag_throw+0x27c>)
 80105c0:	6812      	ldr	r2, [r2, #0]
 80105c2:	210e      	movs	r1, #14
 80105c4:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80105c6:	4798      	blx	r3
            if(indev_reset_check(proc)) return;
 80105c8:	6878      	ldr	r0, [r7, #4]
 80105ca:	f000 f841 	bl	8010650 <indev_reset_check>
 80105ce:	4603      	mov	r3, r0
 80105d0:	2b00      	cmp	r3, #0
 80105d2:	d133      	bne.n	801063c <indev_drag_throw+0x270>
            lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
 80105d4:	2200      	movs	r2, #0
 80105d6:	2109      	movs	r1, #9
 80105d8:	6a78      	ldr	r0, [r7, #36]	; 0x24
 80105da:	f001 fc40 	bl	8011e5e <lv_event_send>
            if(indev_reset_check(proc)) return;
 80105de:	6878      	ldr	r0, [r7, #4]
 80105e0:	f000 f836 	bl	8010650 <indev_reset_check>
 80105e4:	4603      	mov	r3, r0
 80105e6:	2b00      	cmp	r3, #0
 80105e8:	d026      	beq.n	8010638 <indev_drag_throw+0x26c>
 80105ea:	bf00      	nop
 80105ec:	e029      	b.n	8010642 <indev_drag_throw+0x276>
        }
    }
    /*If the types.pointer.vectors become 0 -> types.pointer.drag_in_prog = 0 and send a drag end
       signal*/
    else {
        proc->types.pointer.drag_in_prog = 0;
 80105ee:	687a      	ldr	r2, [r7, #4]
 80105f0:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 80105f4:	f36f 0341 	bfc	r3, #1, #1
 80105f8:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
        drag_obj->signal_cb(drag_obj, LV_SIGNAL_DRAG_END, indev_act);
 80105fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80105fe:	69db      	ldr	r3, [r3, #28]
 8010600:	4a11      	ldr	r2, [pc, #68]	; (8010648 <indev_drag_throw+0x27c>)
 8010602:	6812      	ldr	r2, [r2, #0]
 8010604:	210e      	movs	r1, #14
 8010606:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010608:	4798      	blx	r3
        if(indev_reset_check(proc)) return;
 801060a:	6878      	ldr	r0, [r7, #4]
 801060c:	f000 f820 	bl	8010650 <indev_reset_check>
 8010610:	4603      	mov	r3, r0
 8010612:	2b00      	cmp	r3, #0
 8010614:	d114      	bne.n	8010640 <indev_drag_throw+0x274>
        lv_event_send(drag_obj, LV_EVENT_DRAG_END, NULL);
 8010616:	2200      	movs	r2, #0
 8010618:	2109      	movs	r1, #9
 801061a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801061c:	f001 fc1f 	bl	8011e5e <lv_event_send>
        if(indev_reset_check(proc)) return;
 8010620:	6878      	ldr	r0, [r7, #4]
 8010622:	f000 f815 	bl	8010650 <indev_reset_check>
 8010626:	4603      	mov	r3, r0
 8010628:	2b00      	cmp	r3, #0
 801062a:	e00a      	b.n	8010642 <indev_drag_throw+0x276>
    if(proc->types.pointer.drag_in_prog == 0) return;
 801062c:	bf00      	nop
 801062e:	e008      	b.n	8010642 <indev_drag_throw+0x276>
        return;
 8010630:	bf00      	nop
 8010632:	e006      	b.n	8010642 <indev_drag_throw+0x276>
        if(indev_reset_check(proc)) return;
 8010634:	bf00      	nop
 8010636:	e004      	b.n	8010642 <indev_drag_throw+0x276>
    if(proc->types.pointer.drag_throw_vect.x != 0 || proc->types.pointer.drag_throw_vect.y != 0) {
 8010638:	bf00      	nop
 801063a:	e002      	b.n	8010642 <indev_drag_throw+0x276>
            if(indev_reset_check(proc)) return;
 801063c:	bf00      	nop
 801063e:	e000      	b.n	8010642 <indev_drag_throw+0x276>
        if(indev_reset_check(proc)) return;
 8010640:	bf00      	nop
    }
}
 8010642:	3728      	adds	r7, #40	; 0x28
 8010644:	46bd      	mov	sp, r7
 8010646:	bd80      	pop	{r7, pc}
 8010648:	20003f94 	.word	0x20003f94
 801064c:	51eb851f 	.word	0x51eb851f

08010650 <indev_reset_check>:
 * Checks if the reset_query flag has been set. If so, perform necessary global indev cleanup actions
 * @param proc pointer to an input device 'proc'
 * return true if indev query should be immediately truncated.
 */
static bool indev_reset_check(lv_indev_proc_t * proc)
{
 8010650:	b480      	push	{r7}
 8010652:	b083      	sub	sp, #12
 8010654:	af00      	add	r7, sp, #0
 8010656:	6078      	str	r0, [r7, #4]
    if(proc->reset_query) {
 8010658:	687b      	ldr	r3, [r7, #4]
 801065a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801065e:	f003 0302 	and.w	r3, r3, #2
 8010662:	b2db      	uxtb	r3, r3
 8010664:	2b00      	cmp	r3, #0
 8010666:	d002      	beq.n	801066e <indev_reset_check+0x1e>
        indev_obj_act = NULL;
 8010668:	4b0a      	ldr	r3, [pc, #40]	; (8010694 <indev_reset_check+0x44>)
 801066a:	2200      	movs	r2, #0
 801066c:	601a      	str	r2, [r3, #0]
    }

    return proc->reset_query ? true : false;
 801066e:	687b      	ldr	r3, [r7, #4]
 8010670:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010674:	085b      	lsrs	r3, r3, #1
 8010676:	b2db      	uxtb	r3, r3
 8010678:	f003 0301 	and.w	r3, r3, #1
 801067c:	2b00      	cmp	r3, #0
 801067e:	bf14      	ite	ne
 8010680:	2301      	movne	r3, #1
 8010682:	2300      	moveq	r3, #0
 8010684:	b2db      	uxtb	r3, r3
}
 8010686:	4618      	mov	r0, r3
 8010688:	370c      	adds	r7, #12
 801068a:	46bd      	mov	sp, r7
 801068c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010690:	4770      	bx	lr
 8010692:	bf00      	nop
 8010694:	20003f98 	.word	0x20003f98

08010698 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 8010698:	b580      	push	{r7, lr}
 801069a:	b082      	sub	sp, #8
 801069c:	af00      	add	r7, sp, #0
 801069e:	6078      	str	r0, [r7, #4]
 80106a0:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80106a2:	2208      	movs	r2, #8
 80106a4:	6839      	ldr	r1, [r7, #0]
 80106a6:	6878      	ldr	r0, [r7, #4]
 80106a8:	f016 fd88 	bl	80271bc <memcpy>
}
 80106ac:	bf00      	nop
 80106ae:	3708      	adds	r7, #8
 80106b0:	46bd      	mov	sp, r7
 80106b2:	bd80      	pop	{r7, pc}

080106b4 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 80106b4:	b480      	push	{r7}
 80106b6:	b083      	sub	sp, #12
 80106b8:	af00      	add	r7, sp, #0
 80106ba:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80106bc:	687b      	ldr	r3, [r7, #4]
 80106be:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80106c2:	b29a      	uxth	r2, r3
 80106c4:	687b      	ldr	r3, [r7, #4]
 80106c6:	f9b3 3000 	ldrsh.w	r3, [r3]
 80106ca:	b29b      	uxth	r3, r3
 80106cc:	1ad3      	subs	r3, r2, r3
 80106ce:	b29b      	uxth	r3, r3
 80106d0:	3301      	adds	r3, #1
 80106d2:	b29b      	uxth	r3, r3
 80106d4:	b21b      	sxth	r3, r3
}
 80106d6:	4618      	mov	r0, r3
 80106d8:	370c      	adds	r7, #12
 80106da:	46bd      	mov	sp, r7
 80106dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80106e0:	4770      	bx	lr

080106e2 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80106e2:	b480      	push	{r7}
 80106e4:	b083      	sub	sp, #12
 80106e6:	af00      	add	r7, sp, #0
 80106e8:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 80106ea:	687b      	ldr	r3, [r7, #4]
 80106ec:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80106f0:	b29a      	uxth	r2, r3
 80106f2:	687b      	ldr	r3, [r7, #4]
 80106f4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80106f8:	b29b      	uxth	r3, r3
 80106fa:	1ad3      	subs	r3, r2, r3
 80106fc:	b29b      	uxth	r3, r3
 80106fe:	3301      	adds	r3, #1
 8010700:	b29b      	uxth	r3, r3
 8010702:	b21b      	sxth	r3, r3
}
 8010704:	4618      	mov	r0, r3
 8010706:	370c      	adds	r7, #12
 8010708:	46bd      	mov	sp, r7
 801070a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801070e:	4770      	bx	lr

08010710 <lv_init>:

/**
 * Init. the 'lv' library.
 */
void lv_init(void)
{
 8010710:	b580      	push	{r7, lr}
 8010712:	af00      	add	r7, sp, #0
    /* Do nothing if already initialized */
    if(lv_initialized) {
 8010714:	4b16      	ldr	r3, [pc, #88]	; (8010770 <lv_init+0x60>)
 8010716:	781b      	ldrb	r3, [r3, #0]
 8010718:	2b00      	cmp	r3, #0
 801071a:	d006      	beq.n	801072a <lv_init+0x1a>
        LV_LOG_WARN("lv_init: already inited");
 801071c:	4b15      	ldr	r3, [pc, #84]	; (8010774 <lv_init+0x64>)
 801071e:	224d      	movs	r2, #77	; 0x4d
 8010720:	4915      	ldr	r1, [pc, #84]	; (8010778 <lv_init+0x68>)
 8010722:	2002      	movs	r0, #2
 8010724:	f00c f872 	bl	801c80c <lv_log_add>
        return;
 8010728:	e020      	b.n	801076c <lv_init+0x5c>
    }

    LV_LOG_TRACE("lv_init started");

    /*Initialize the lv_misc modules*/
    lv_mem_init();
 801072a:	f00c f893 	bl	801c854 <lv_mem_init>
    lv_task_core_init();
 801072e:	f00c fa61 	bl	801cbf4 <lv_task_core_init>

#if LV_USE_FILESYSTEM
    lv_fs_init();
 8010732:	f00b fc53 	bl	801bfdc <lv_fs_init>
#endif

#if LV_USE_ANIMATION
    lv_anim_core_init();
 8010736:	f00a feef 	bl	801b518 <lv_anim_core_init>
#endif

#if LV_USE_GROUP
    lv_group_init();
 801073a:	f7fd fc73 	bl	800e024 <lv_group_init>
#endif

    /*Init. the sstyles*/
    lv_style_init();
 801073e:	f002 ff39 	bl	80135b4 <lv_style_init>

    /*Initialize the screen refresh system*/
    lv_refr_init();
 8010742:	f002 f8f3 	bl	801292c <lv_refr_init>

    lv_ll_init(&LV_GC_ROOT(_lv_disp_ll), sizeof(lv_disp_t));
 8010746:	f44f 71b8 	mov.w	r1, #368	; 0x170
 801074a:	480c      	ldr	r0, [pc, #48]	; (801077c <lv_init+0x6c>)
 801074c:	f00b fdd4 	bl	801c2f8 <lv_ll_init>
    lv_ll_init(&LV_GC_ROOT(_lv_indev_ll), sizeof(lv_indev_t));
 8010750:	2160      	movs	r1, #96	; 0x60
 8010752:	480b      	ldr	r0, [pc, #44]	; (8010780 <lv_init+0x70>)
 8010754:	f00b fdd0 	bl	801c2f8 <lv_ll_init>

    /*Init the input device handling*/
    lv_indev_init();
 8010758:	f7fe f953 	bl	800ea02 <lv_indev_init>

    lv_img_decoder_init();
 801075c:	f009 f8d0 	bl	8019900 <lv_img_decoder_init>
    lv_img_cache_set_size(LV_IMG_CACHE_DEF_SIZE);
 8010760:	2001      	movs	r0, #1
 8010762:	f008 ffe3 	bl	801972c <lv_img_cache_set_size>

    lv_initialized = true;
 8010766:	4b02      	ldr	r3, [pc, #8]	; (8010770 <lv_init+0x60>)
 8010768:	2201      	movs	r2, #1
 801076a:	701a      	strb	r2, [r3, #0]
    LV_LOG_INFO("lv_init ready");
}
 801076c:	bd80      	pop	{r7, pc}
 801076e:	bf00      	nop
 8010770:	20003f9c 	.word	0x20003f9c
 8010774:	08028758 	.word	0x08028758
 8010778:	08028770 	.word	0x08028770
 801077c:	2000df60 	.word	0x2000df60
 8010780:	2000df50 	.word	0x2000df50

08010784 <lv_obj_create>:
 *                  If NULL then a screen will be created
 * @param copy pointer to a base object, if not NULL then the new object will be copied from it
 * @return pointer to the new object
 */
lv_obj_t * lv_obj_create(lv_obj_t * parent, const lv_obj_t * copy)
{
 8010784:	b590      	push	{r4, r7, lr}
 8010786:	b087      	sub	sp, #28
 8010788:	af00      	add	r7, sp, #0
 801078a:	6078      	str	r0, [r7, #4]
 801078c:	6039      	str	r1, [r7, #0]

    lv_obj_t * new_obj = NULL;
 801078e:	2300      	movs	r3, #0
 8010790:	617b      	str	r3, [r7, #20]
    /*Create a screen if the parent is NULL*/
    if(parent == NULL) {
 8010792:	687b      	ldr	r3, [r7, #4]
 8010794:	2b00      	cmp	r3, #0
 8010796:	f040 80cb 	bne.w	8010930 <lv_obj_create+0x1ac>
        LV_LOG_TRACE("Screen create started");
        lv_disp_t * disp = lv_disp_get_default();
 801079a:	f00a fc97 	bl	801b0cc <lv_disp_get_default>
 801079e:	60f8      	str	r0, [r7, #12]
        if(!disp) {
 80107a0:	68fb      	ldr	r3, [r7, #12]
 80107a2:	2b00      	cmp	r3, #0
 80107a4:	d107      	bne.n	80107b6 <lv_obj_create+0x32>
            LV_LOG_WARN("lv_obj_create: not display created to so far. No place to assign the new screen");
 80107a6:	4b90      	ldr	r3, [pc, #576]	; (80109e8 <lv_obj_create+0x264>)
 80107a8:	228a      	movs	r2, #138	; 0x8a
 80107aa:	4990      	ldr	r1, [pc, #576]	; (80109ec <lv_obj_create+0x268>)
 80107ac:	2002      	movs	r0, #2
 80107ae:	f00c f82d 	bl	801c80c <lv_log_add>
            return NULL;
 80107b2:	2300      	movs	r3, #0
 80107b4:	e27c      	b.n	8010cb0 <lv_obj_create+0x52c>
        }

        new_obj = lv_ll_ins_head(&disp->scr_ll);
 80107b6:	68fb      	ldr	r3, [r7, #12]
 80107b8:	3330      	adds	r3, #48	; 0x30
 80107ba:	4618      	mov	r0, r3
 80107bc:	f00b fdbc 	bl	801c338 <lv_ll_ins_head>
 80107c0:	6178      	str	r0, [r7, #20]
        lv_mem_assert(new_obj);
 80107c2:	697b      	ldr	r3, [r7, #20]
 80107c4:	2b00      	cmp	r3, #0
 80107c6:	d106      	bne.n	80107d6 <lv_obj_create+0x52>
 80107c8:	4b89      	ldr	r3, [pc, #548]	; (80109f0 <lv_obj_create+0x26c>)
 80107ca:	228f      	movs	r2, #143	; 0x8f
 80107cc:	4987      	ldr	r1, [pc, #540]	; (80109ec <lv_obj_create+0x268>)
 80107ce:	2003      	movs	r0, #3
 80107d0:	f00c f81c 	bl	801c80c <lv_log_add>
 80107d4:	e7fe      	b.n	80107d4 <lv_obj_create+0x50>
        if(new_obj == NULL) return NULL;
 80107d6:	697b      	ldr	r3, [r7, #20]
 80107d8:	2b00      	cmp	r3, #0
 80107da:	d101      	bne.n	80107e0 <lv_obj_create+0x5c>
 80107dc:	2300      	movs	r3, #0
 80107de:	e267      	b.n	8010cb0 <lv_obj_create+0x52c>

        new_obj->par = NULL; /*Screens has no a parent*/
 80107e0:	697b      	ldr	r3, [r7, #20]
 80107e2:	2200      	movs	r2, #0
 80107e4:	601a      	str	r2, [r3, #0]
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 80107e6:	697b      	ldr	r3, [r7, #20]
 80107e8:	3304      	adds	r3, #4
 80107ea:	2148      	movs	r1, #72	; 0x48
 80107ec:	4618      	mov	r0, r3
 80107ee:	f00b fd83 	bl	801c2f8 <lv_ll_init>

        /*Set coordinates to full screen size*/
        new_obj->coords.x1    = 0;
 80107f2:	697b      	ldr	r3, [r7, #20]
 80107f4:	2200      	movs	r2, #0
 80107f6:	821a      	strh	r2, [r3, #16]
        new_obj->coords.y1    = 0;
 80107f8:	697b      	ldr	r3, [r7, #20]
 80107fa:	2200      	movs	r2, #0
 80107fc:	825a      	strh	r2, [r3, #18]
        new_obj->coords.x2    = lv_disp_get_hor_res(NULL) - 1;
 80107fe:	2000      	movs	r0, #0
 8010800:	f00a fc70 	bl	801b0e4 <lv_disp_get_hor_res>
 8010804:	4603      	mov	r3, r0
 8010806:	b29b      	uxth	r3, r3
 8010808:	3b01      	subs	r3, #1
 801080a:	b29b      	uxth	r3, r3
 801080c:	b21a      	sxth	r2, r3
 801080e:	697b      	ldr	r3, [r7, #20]
 8010810:	829a      	strh	r2, [r3, #20]
        new_obj->coords.y2    = lv_disp_get_ver_res(NULL) - 1;
 8010812:	2000      	movs	r0, #0
 8010814:	f00a fc88 	bl	801b128 <lv_disp_get_ver_res>
 8010818:	4603      	mov	r3, r0
 801081a:	b29b      	uxth	r3, r3
 801081c:	3b01      	subs	r3, #1
 801081e:	b29b      	uxth	r3, r3
 8010820:	b21a      	sxth	r2, r3
 8010822:	697b      	ldr	r3, [r7, #20]
 8010824:	82da      	strh	r2, [r3, #22]
        new_obj->ext_draw_pad = 0;
 8010826:	697b      	ldr	r3, [r7, #20]
 8010828:	2200      	movs	r2, #0
 801082a:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = LV_ALIGN_CENTER;
 801082c:	697b      	ldr	r3, [r7, #20]
 801082e:	2200      	movs	r2, #0
 8010830:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = 0;
 8010834:	697b      	ldr	r3, [r7, #20]
 8010836:	2200      	movs	r2, #0
 8010838:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = 0;
 801083a:	697b      	ldr	r3, [r7, #20]
 801083c:	2200      	movs	r2, #0
 801083e:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = NULL;
 8010840:	697b      	ldr	r3, [r7, #20]
 8010842:	2200      	movs	r2, #0
 8010844:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = 0;
 8010846:	697a      	ldr	r2, [r7, #20]
 8010848:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 801084c:	f36f 0300 	bfc	r3, #0, #1
 8010850:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 8010854:	f015 f89c 	bl	8025990 <lv_theme_get_current>
 8010858:	60b8      	str	r0, [r7, #8]
        if(th) {
 801085a:	68bb      	ldr	r3, [r7, #8]
 801085c:	2b00      	cmp	r3, #0
 801085e:	d004      	beq.n	801086a <lv_obj_create+0xe6>
            new_obj->style_p = th->style.scr;
 8010860:	68bb      	ldr	r3, [r7, #8]
 8010862:	681a      	ldr	r2, [r3, #0]
 8010864:	697b      	ldr	r3, [r7, #20]
 8010866:	629a      	str	r2, [r3, #40]	; 0x28
 8010868:	e002      	b.n	8010870 <lv_obj_create+0xec>
        } else {
            new_obj->style_p = &lv_style_scr;
 801086a:	697b      	ldr	r3, [r7, #20]
 801086c:	4a61      	ldr	r2, [pc, #388]	; (80109f4 <lv_obj_create+0x270>)
 801086e:	629a      	str	r2, [r3, #40]	; 0x28
        }
        /*Set the callbacks*/
        lv_obj_set_signal_cb(new_obj, lv_obj_signal);
 8010870:	4961      	ldr	r1, [pc, #388]	; (80109f8 <lv_obj_create+0x274>)
 8010872:	6978      	ldr	r0, [r7, #20]
 8010874:	f001 fb84 	bl	8011f80 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_obj, lv_obj_design);
 8010878:	4960      	ldr	r1, [pc, #384]	; (80109fc <lv_obj_create+0x278>)
 801087a:	6978      	ldr	r0, [r7, #20]
 801087c:	f001 fb8e 	bl	8011f9c <lv_obj_set_design_cb>
        new_obj->event_cb = NULL;
 8010880:	697b      	ldr	r3, [r7, #20]
 8010882:	2200      	movs	r2, #0
 8010884:	619a      	str	r2, [r3, #24]

        /*Init. user date*/
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
 8010886:	697b      	ldr	r3, [r7, #20]
 8010888:	3344      	adds	r3, #68	; 0x44
 801088a:	2204      	movs	r2, #4
 801088c:	2100      	movs	r1, #0
 801088e:	4618      	mov	r0, r3
 8010890:	f016 fc9f 	bl	80271d2 <memset>
#endif

#if LV_USE_GROUP
        new_obj->group_p = NULL;
 8010894:	697b      	ldr	r3, [r7, #20]
 8010896:	2200      	movs	r2, #0
 8010898:	62da      	str	r2, [r3, #44]	; 0x2c
#endif
        /*Set attributes*/
        new_obj->click        = 0;
 801089a:	697a      	ldr	r2, [r7, #20]
 801089c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108a0:	f36f 0300 	bfc	r3, #0, #1
 80108a4:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = 0;
 80108a8:	697a      	ldr	r2, [r7, #20]
 80108aa:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108ae:	f36f 0341 	bfc	r3, #1, #1
 80108b2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_throw   = 0;
 80108b6:	697a      	ldr	r2, [r7, #20]
 80108b8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108bc:	f36f 0382 	bfc	r3, #2, #1
 80108c0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = 0;
 80108c4:	697a      	ldr	r2, [r7, #20]
 80108c6:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108ca:	f36f 03c3 	bfc	r3, #3, #1
 80108ce:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = 0;
 80108d2:	697a      	ldr	r2, [r7, #20]
 80108d4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108d8:	f36f 1304 	bfc	r3, #4, #1
 80108dc:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = 0;
 80108e0:	697a      	ldr	r2, [r7, #20]
 80108e2:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108e6:	f36f 1345 	bfc	r3, #5, #1
 80108ea:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = LV_PROTECT_NONE;
 80108ee:	697b      	ldr	r3, [r7, #20]
 80108f0:	2200      	movs	r2, #0
 80108f2:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale_en = 0;
 80108f6:	697a      	ldr	r2, [r7, #20]
 80108f8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 80108fc:	f36f 1386 	bfc	r3, #6, #1
 8010900:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->opa_scale    = LV_OPA_COVER;
 8010904:	697b      	ldr	r3, [r7, #20]
 8010906:	22ff      	movs	r2, #255	; 0xff
 8010908:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
        new_obj->parent_event = 0;
 801090c:	697a      	ldr	r2, [r7, #20]
 801090e:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010912:	f36f 13c7 	bfc	r3, #7, #1
 8010916:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->reserved     = 0;
 801091a:	697a      	ldr	r2, [r7, #20]
 801091c:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8010920:	f36f 0387 	bfc	r3, #2, #6
 8010924:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31

        new_obj->ext_attr = NULL;
 8010928:	697b      	ldr	r3, [r7, #20]
 801092a:	2200      	movs	r2, #0
 801092c:	625a      	str	r2, [r3, #36]	; 0x24
 801092e:	e0c9      	b.n	8010ac4 <lv_obj_create+0x340>
    }
    /*parent != NULL create normal obj. on a parent*/
    else {
        LV_LOG_TRACE("Object create started");

        new_obj = lv_ll_ins_head(&parent->child_ll);
 8010930:	687b      	ldr	r3, [r7, #4]
 8010932:	3304      	adds	r3, #4
 8010934:	4618      	mov	r0, r3
 8010936:	f00b fcff 	bl	801c338 <lv_ll_ins_head>
 801093a:	6178      	str	r0, [r7, #20]
        lv_mem_assert(new_obj);
 801093c:	697b      	ldr	r3, [r7, #20]
 801093e:	2b00      	cmp	r3, #0
 8010940:	d106      	bne.n	8010950 <lv_obj_create+0x1cc>
 8010942:	4b2b      	ldr	r3, [pc, #172]	; (80109f0 <lv_obj_create+0x26c>)
 8010944:	22d8      	movs	r2, #216	; 0xd8
 8010946:	4929      	ldr	r1, [pc, #164]	; (80109ec <lv_obj_create+0x268>)
 8010948:	2003      	movs	r0, #3
 801094a:	f00b ff5f 	bl	801c80c <lv_log_add>
 801094e:	e7fe      	b.n	801094e <lv_obj_create+0x1ca>
        if(new_obj == NULL) return NULL;
 8010950:	697b      	ldr	r3, [r7, #20]
 8010952:	2b00      	cmp	r3, #0
 8010954:	d101      	bne.n	801095a <lv_obj_create+0x1d6>
 8010956:	2300      	movs	r3, #0
 8010958:	e1aa      	b.n	8010cb0 <lv_obj_create+0x52c>

        new_obj->par = parent; /*Set the parent*/
 801095a:	697b      	ldr	r3, [r7, #20]
 801095c:	687a      	ldr	r2, [r7, #4]
 801095e:	601a      	str	r2, [r3, #0]
        lv_ll_init(&(new_obj->child_ll), sizeof(lv_obj_t));
 8010960:	697b      	ldr	r3, [r7, #20]
 8010962:	3304      	adds	r3, #4
 8010964:	2148      	movs	r1, #72	; 0x48
 8010966:	4618      	mov	r0, r3
 8010968:	f00b fcc6 	bl	801c2f8 <lv_ll_init>

        /*Set coordinates left top corner of parent*/
        new_obj->coords.x1    = parent->coords.x1;
 801096c:	687b      	ldr	r3, [r7, #4]
 801096e:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 8010972:	697b      	ldr	r3, [r7, #20]
 8010974:	821a      	strh	r2, [r3, #16]
        new_obj->coords.y1    = parent->coords.y1;
 8010976:	687b      	ldr	r3, [r7, #4]
 8010978:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 801097c:	697b      	ldr	r3, [r7, #20]
 801097e:	825a      	strh	r2, [r3, #18]
        new_obj->coords.x2    = parent->coords.x1 + LV_OBJ_DEF_WIDTH;
 8010980:	687b      	ldr	r3, [r7, #4]
 8010982:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8010986:	b29b      	uxth	r3, r3
 8010988:	3364      	adds	r3, #100	; 0x64
 801098a:	b29b      	uxth	r3, r3
 801098c:	b21a      	sxth	r2, r3
 801098e:	697b      	ldr	r3, [r7, #20]
 8010990:	829a      	strh	r2, [r3, #20]
        new_obj->coords.y2    = parent->coords.y1 + LV_OBJ_DEF_HEIGHT;
 8010992:	687b      	ldr	r3, [r7, #4]
 8010994:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8010998:	b29b      	uxth	r3, r3
 801099a:	3342      	adds	r3, #66	; 0x42
 801099c:	b29b      	uxth	r3, r3
 801099e:	b21a      	sxth	r2, r3
 80109a0:	697b      	ldr	r3, [r7, #20]
 80109a2:	82da      	strh	r2, [r3, #22]
        new_obj->ext_draw_pad = 0;
 80109a4:	697b      	ldr	r3, [r7, #20]
 80109a6:	2200      	movs	r2, #0
 80109a8:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = LV_ALIGN_CENTER;
 80109aa:	697b      	ldr	r3, [r7, #20]
 80109ac:	2200      	movs	r2, #0
 80109ae:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = 0;
 80109b2:	697b      	ldr	r3, [r7, #20]
 80109b4:	2200      	movs	r2, #0
 80109b6:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = 0;
 80109b8:	697b      	ldr	r3, [r7, #20]
 80109ba:	2200      	movs	r2, #0
 80109bc:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = NULL;
 80109be:	697b      	ldr	r3, [r7, #20]
 80109c0:	2200      	movs	r2, #0
 80109c2:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = 0;
 80109c4:	697a      	ldr	r2, [r7, #20]
 80109c6:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 80109ca:	f36f 0300 	bfc	r3, #0, #1
 80109ce:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
        /*Set appearance*/
        lv_theme_t * th = lv_theme_get_current();
 80109d2:	f014 ffdd 	bl	8025990 <lv_theme_get_current>
 80109d6:	6138      	str	r0, [r7, #16]
        if(th) {
 80109d8:	693b      	ldr	r3, [r7, #16]
 80109da:	2b00      	cmp	r3, #0
 80109dc:	d010      	beq.n	8010a00 <lv_obj_create+0x27c>
            new_obj->style_p = th->style.panel;
 80109de:	693b      	ldr	r3, [r7, #16]
 80109e0:	689a      	ldr	r2, [r3, #8]
 80109e2:	697b      	ldr	r3, [r7, #20]
 80109e4:	629a      	str	r2, [r3, #40]	; 0x28
 80109e6:	e00e      	b.n	8010a06 <lv_obj_create+0x282>
 80109e8:	08028790 	.word	0x08028790
 80109ec:	08028770 	.word	0x08028770
 80109f0:	080287e0 	.word	0x080287e0
 80109f4:	2000de90 	.word	0x2000de90
 80109f8:	080125ad 	.word	0x080125ad
 80109fc:	08012493 	.word	0x08012493
        } else {
            new_obj->style_p = &lv_style_plain_color;
 8010a00:	697b      	ldr	r3, [r7, #20]
 8010a02:	4aad      	ldr	r2, [pc, #692]	; (8010cb8 <lv_obj_create+0x534>)
 8010a04:	629a      	str	r2, [r3, #40]	; 0x28
        }

        /*Set the callbacks*/
        lv_obj_set_signal_cb(new_obj, lv_obj_signal);
 8010a06:	49ad      	ldr	r1, [pc, #692]	; (8010cbc <lv_obj_create+0x538>)
 8010a08:	6978      	ldr	r0, [r7, #20]
 8010a0a:	f001 fab9 	bl	8011f80 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_obj, lv_obj_design);
 8010a0e:	49ac      	ldr	r1, [pc, #688]	; (8010cc0 <lv_obj_create+0x53c>)
 8010a10:	6978      	ldr	r0, [r7, #20]
 8010a12:	f001 fac3 	bl	8011f9c <lv_obj_set_design_cb>
        new_obj->event_cb = NULL;
 8010a16:	697b      	ldr	r3, [r7, #20]
 8010a18:	2200      	movs	r2, #0
 8010a1a:	619a      	str	r2, [r3, #24]
        new_obj->ext_click_pad_ver = 0;
#endif

        /*Init. user date*/
#if LV_USE_USER_DATA
        memset(&new_obj->user_data, 0, sizeof(lv_obj_user_data_t));
 8010a1c:	697b      	ldr	r3, [r7, #20]
 8010a1e:	3344      	adds	r3, #68	; 0x44
 8010a20:	2204      	movs	r2, #4
 8010a22:	2100      	movs	r1, #0
 8010a24:	4618      	mov	r0, r3
 8010a26:	f016 fbd4 	bl	80271d2 <memset>
#endif

#if LV_USE_GROUP
        new_obj->group_p = NULL;
 8010a2a:	697b      	ldr	r3, [r7, #20]
 8010a2c:	2200      	movs	r2, #0
 8010a2e:	62da      	str	r2, [r3, #44]	; 0x2c
#endif

        /*Set attributes*/
        new_obj->click        = 1;
 8010a30:	697a      	ldr	r2, [r7, #20]
 8010a32:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010a36:	f043 0301 	orr.w	r3, r3, #1
 8010a3a:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = 0;
 8010a3e:	697a      	ldr	r2, [r7, #20]
 8010a40:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010a44:	f36f 0341 	bfc	r3, #1, #1
 8010a48:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_dir     = LV_DRAG_DIR_ALL;
 8010a4c:	697a      	ldr	r2, [r7, #20]
 8010a4e:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8010a52:	f043 0303 	orr.w	r3, r3, #3
 8010a56:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        new_obj->drag_throw   = 0;
 8010a5a:	697a      	ldr	r2, [r7, #20]
 8010a5c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010a60:	f36f 0382 	bfc	r3, #2, #1
 8010a64:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = 0;
 8010a68:	697a      	ldr	r2, [r7, #20]
 8010a6a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010a6e:	f36f 03c3 	bfc	r3, #3, #1
 8010a72:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = 0;
 8010a76:	697a      	ldr	r2, [r7, #20]
 8010a78:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010a7c:	f36f 1304 	bfc	r3, #4, #1
 8010a80:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = 0;
 8010a84:	697a      	ldr	r2, [r7, #20]
 8010a86:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010a8a:	f36f 1345 	bfc	r3, #5, #1
 8010a8e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = LV_PROTECT_NONE;
 8010a92:	697b      	ldr	r3, [r7, #20]
 8010a94:	2200      	movs	r2, #0
 8010a96:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale    = LV_OPA_COVER;
 8010a9a:	697b      	ldr	r3, [r7, #20]
 8010a9c:	22ff      	movs	r2, #255	; 0xff
 8010a9e:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
        new_obj->opa_scale_en = 0;
 8010aa2:	697a      	ldr	r2, [r7, #20]
 8010aa4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010aa8:	f36f 1386 	bfc	r3, #6, #1
 8010aac:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->parent_event = 0;
 8010ab0:	697a      	ldr	r2, [r7, #20]
 8010ab2:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010ab6:	f36f 13c7 	bfc	r3, #7, #1
 8010aba:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

        new_obj->ext_attr = NULL;
 8010abe:	697b      	ldr	r3, [r7, #20]
 8010ac0:	2200      	movs	r2, #0
 8010ac2:	625a      	str	r2, [r3, #36]	; 0x24
    }

    /*Copy the attributes if required*/
    if(copy != NULL) {
 8010ac4:	683b      	ldr	r3, [r7, #0]
 8010ac6:	2b00      	cmp	r3, #0
 8010ac8:	f000 80e5 	beq.w	8010c96 <lv_obj_create+0x512>
        lv_area_copy(&new_obj->coords, &copy->coords);
 8010acc:	697b      	ldr	r3, [r7, #20]
 8010ace:	f103 0210 	add.w	r2, r3, #16
 8010ad2:	683b      	ldr	r3, [r7, #0]
 8010ad4:	3310      	adds	r3, #16
 8010ad6:	4619      	mov	r1, r3
 8010ad8:	4610      	mov	r0, r2
 8010ada:	f7ff fddd 	bl	8010698 <lv_area_copy>
        new_obj->ext_draw_pad = copy->ext_draw_pad;
 8010ade:	683b      	ldr	r3, [r7, #0]
 8010ae0:	f9b3 2034 	ldrsh.w	r2, [r3, #52]	; 0x34
 8010ae4:	697b      	ldr	r3, [r7, #20]
 8010ae6:	869a      	strh	r2, [r3, #52]	; 0x34
        new_obj->ext_click_pad_ver = copy->ext_click_pad_ver;
#endif

        /*Set free data*/
#if LV_USE_USER_DATA
        memcpy(&new_obj->user_data, &copy->user_data, sizeof(lv_obj_user_data_t));
 8010ae8:	697b      	ldr	r3, [r7, #20]
 8010aea:	3344      	adds	r3, #68	; 0x44
 8010aec:	683a      	ldr	r2, [r7, #0]
 8010aee:	3244      	adds	r2, #68	; 0x44
 8010af0:	6812      	ldr	r2, [r2, #0]
 8010af2:	601a      	str	r2, [r3, #0]
#endif
        /*Copy realign*/
#if LV_USE_OBJ_REALIGN
        new_obj->realign.align        = copy->realign.align;
 8010af4:	683b      	ldr	r3, [r7, #0]
 8010af6:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8010afa:	697b      	ldr	r3, [r7, #20]
 8010afc:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
        new_obj->realign.xofs         = copy->realign.xofs;
 8010b00:	683b      	ldr	r3, [r7, #0]
 8010b02:	f9b3 203c 	ldrsh.w	r2, [r3, #60]	; 0x3c
 8010b06:	697b      	ldr	r3, [r7, #20]
 8010b08:	879a      	strh	r2, [r3, #60]	; 0x3c
        new_obj->realign.yofs         = copy->realign.yofs;
 8010b0a:	683b      	ldr	r3, [r7, #0]
 8010b0c:	f9b3 203e 	ldrsh.w	r2, [r3, #62]	; 0x3e
 8010b10:	697b      	ldr	r3, [r7, #20]
 8010b12:	87da      	strh	r2, [r3, #62]	; 0x3e
        new_obj->realign.base         = copy->realign.base;
 8010b14:	683b      	ldr	r3, [r7, #0]
 8010b16:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8010b18:	697b      	ldr	r3, [r7, #20]
 8010b1a:	639a      	str	r2, [r3, #56]	; 0x38
        new_obj->realign.auto_realign = copy->realign.auto_realign;
 8010b1c:	683b      	ldr	r3, [r7, #0]
 8010b1e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8010b22:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8010b26:	b2d9      	uxtb	r1, r3
 8010b28:	697a      	ldr	r2, [r7, #20]
 8010b2a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8010b2e:	f361 0300 	bfi	r3, r1, #0, #1
 8010b32:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif

        /*Only copy the `event_cb`. `signal_cb` and `design_cb` will be copied the the derived
         * object type (e.g. `lv_btn`)*/
        new_obj->event_cb = copy->event_cb;
 8010b36:	683b      	ldr	r3, [r7, #0]
 8010b38:	699a      	ldr	r2, [r3, #24]
 8010b3a:	697b      	ldr	r3, [r7, #20]
 8010b3c:	619a      	str	r2, [r3, #24]

        /*Copy attributes*/
        new_obj->click        = copy->click;
 8010b3e:	683b      	ldr	r3, [r7, #0]
 8010b40:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010b44:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8010b48:	b2d9      	uxtb	r1, r3
 8010b4a:	697a      	ldr	r2, [r7, #20]
 8010b4c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010b50:	f361 0300 	bfi	r3, r1, #0, #1
 8010b54:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag         = copy->drag;
 8010b58:	683b      	ldr	r3, [r7, #0]
 8010b5a:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010b5e:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8010b62:	b2d9      	uxtb	r1, r3
 8010b64:	697a      	ldr	r2, [r7, #20]
 8010b66:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010b6a:	f361 0341 	bfi	r3, r1, #1, #1
 8010b6e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_dir     = copy->drag_dir;
 8010b72:	683b      	ldr	r3, [r7, #0]
 8010b74:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8010b78:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8010b7c:	b2d9      	uxtb	r1, r3
 8010b7e:	697a      	ldr	r2, [r7, #20]
 8010b80:	f892 3031 	ldrb.w	r3, [r2, #49]	; 0x31
 8010b84:	f361 0301 	bfi	r3, r1, #0, #2
 8010b88:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
        new_obj->drag_throw   = copy->drag_throw;
 8010b8c:	683b      	ldr	r3, [r7, #0]
 8010b8e:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010b92:	f3c3 0380 	ubfx	r3, r3, #2, #1
 8010b96:	b2d9      	uxtb	r1, r3
 8010b98:	697a      	ldr	r2, [r7, #20]
 8010b9a:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010b9e:	f361 0382 	bfi	r3, r1, #2, #1
 8010ba2:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->drag_parent  = copy->drag_parent;
 8010ba6:	683b      	ldr	r3, [r7, #0]
 8010ba8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010bac:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8010bb0:	b2d9      	uxtb	r1, r3
 8010bb2:	697a      	ldr	r2, [r7, #20]
 8010bb4:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010bb8:	f361 03c3 	bfi	r3, r1, #3, #1
 8010bbc:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->hidden       = copy->hidden;
 8010bc0:	683b      	ldr	r3, [r7, #0]
 8010bc2:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010bc6:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8010bca:	b2d9      	uxtb	r1, r3
 8010bcc:	697a      	ldr	r2, [r7, #20]
 8010bce:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010bd2:	f361 1304 	bfi	r3, r1, #4, #1
 8010bd6:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->top          = copy->top;
 8010bda:	683b      	ldr	r3, [r7, #0]
 8010bdc:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010be0:	f3c3 1340 	ubfx	r3, r3, #5, #1
 8010be4:	b2d9      	uxtb	r1, r3
 8010be6:	697a      	ldr	r2, [r7, #20]
 8010be8:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010bec:	f361 1345 	bfi	r3, r1, #5, #1
 8010bf0:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->parent_event = copy->parent_event;
 8010bf4:	683b      	ldr	r3, [r7, #0]
 8010bf6:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010bfa:	f3c3 13c0 	ubfx	r3, r3, #7, #1
 8010bfe:	b2d9      	uxtb	r1, r3
 8010c00:	697a      	ldr	r2, [r7, #20]
 8010c02:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010c06:	f361 13c7 	bfi	r3, r1, #7, #1
 8010c0a:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30

        new_obj->opa_scale_en = copy->opa_scale_en;
 8010c0e:	683b      	ldr	r3, [r7, #0]
 8010c10:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8010c14:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8010c18:	b2d9      	uxtb	r1, r3
 8010c1a:	697a      	ldr	r2, [r7, #20]
 8010c1c:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8010c20:	f361 1386 	bfi	r3, r1, #6, #1
 8010c24:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
        new_obj->protect      = copy->protect;
 8010c28:	683b      	ldr	r3, [r7, #0]
 8010c2a:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8010c2e:	697b      	ldr	r3, [r7, #20]
 8010c30:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
        new_obj->opa_scale    = copy->opa_scale;
 8010c34:	683b      	ldr	r3, [r7, #0]
 8010c36:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
 8010c3a:	697b      	ldr	r3, [r7, #20]
 8010c3c:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

        new_obj->style_p = copy->style_p;
 8010c40:	683b      	ldr	r3, [r7, #0]
 8010c42:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8010c44:	697b      	ldr	r3, [r7, #20]
 8010c46:	629a      	str	r2, [r3, #40]	; 0x28

#if LV_USE_GROUP
        /*Add to the same group*/
        if(copy->group_p != NULL) {
 8010c48:	683b      	ldr	r3, [r7, #0]
 8010c4a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010c4c:	2b00      	cmp	r3, #0
 8010c4e:	d005      	beq.n	8010c5c <lv_obj_create+0x4d8>
            lv_group_add_obj(copy->group_p, new_obj);
 8010c50:	683b      	ldr	r3, [r7, #0]
 8010c52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8010c54:	6979      	ldr	r1, [r7, #20]
 8010c56:	4618      	mov	r0, r3
 8010c58:	f7fd f9ee 	bl	800e038 <lv_group_add_obj>
        }
#endif

        /*Set the same coordinates for non screen objects*/
        if(lv_obj_get_parent(copy) != NULL && parent != NULL) {
 8010c5c:	6838      	ldr	r0, [r7, #0]
 8010c5e:	f001 fa2f 	bl	80120c0 <lv_obj_get_parent>
 8010c62:	4603      	mov	r3, r0
 8010c64:	2b00      	cmp	r3, #0
 8010c66:	d011      	beq.n	8010c8c <lv_obj_create+0x508>
 8010c68:	687b      	ldr	r3, [r7, #4]
 8010c6a:	2b00      	cmp	r3, #0
 8010c6c:	d00e      	beq.n	8010c8c <lv_obj_create+0x508>
            lv_obj_set_pos(new_obj, lv_obj_get_x(copy), lv_obj_get_y(copy));
 8010c6e:	6838      	ldr	r0, [r7, #0]
 8010c70:	f001 fa5e 	bl	8012130 <lv_obj_get_x>
 8010c74:	4603      	mov	r3, r0
 8010c76:	461c      	mov	r4, r3
 8010c78:	6838      	ldr	r0, [r7, #0]
 8010c7a:	f001 fa72 	bl	8012162 <lv_obj_get_y>
 8010c7e:	4603      	mov	r3, r0
 8010c80:	461a      	mov	r2, r3
 8010c82:	4621      	mov	r1, r4
 8010c84:	6978      	ldr	r0, [r7, #20]
 8010c86:	f000 f9e3 	bl	8011050 <lv_obj_set_pos>
 8010c8a:	e004      	b.n	8010c96 <lv_obj_create+0x512>
        } else {
            lv_obj_set_pos(new_obj, 0, 0);
 8010c8c:	2200      	movs	r2, #0
 8010c8e:	2100      	movs	r1, #0
 8010c90:	6978      	ldr	r0, [r7, #20]
 8010c92:	f000 f9dd 	bl	8011050 <lv_obj_set_pos>

        LV_LOG_INFO("Object create ready");
    }

    /*Send a signal to the parent to notify it about the new child*/
    if(parent != NULL) {
 8010c96:	687b      	ldr	r3, [r7, #4]
 8010c98:	2b00      	cmp	r3, #0
 8010c9a:	d008      	beq.n	8010cae <lv_obj_create+0x52a>
        parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, new_obj);
 8010c9c:	687b      	ldr	r3, [r7, #4]
 8010c9e:	69db      	ldr	r3, [r3, #28]
 8010ca0:	697a      	ldr	r2, [r7, #20]
 8010ca2:	2101      	movs	r1, #1
 8010ca4:	6878      	ldr	r0, [r7, #4]
 8010ca6:	4798      	blx	r3

        /*Invalidate the area if not screen created*/
        lv_obj_invalidate(new_obj);
 8010ca8:	6978      	ldr	r0, [r7, #20]
 8010caa:	f000 f8c0 	bl	8010e2e <lv_obj_invalidate>
    }

    return new_obj;
 8010cae:	697b      	ldr	r3, [r7, #20]
}
 8010cb0:	4618      	mov	r0, r3
 8010cb2:	371c      	adds	r7, #28
 8010cb4:	46bd      	mov	sp, r7
 8010cb6:	bd90      	pop	{r4, r7, pc}
 8010cb8:	2000df08 	.word	0x2000df08
 8010cbc:	080125ad 	.word	0x080125ad
 8010cc0:	08012493 	.word	0x08012493

08010cc4 <lv_obj_del>:
 * Delete 'obj' and all of its children
 * @param obj pointer to an object to delete
 * @return LV_RES_INV because the object is deleted
 */
lv_res_t lv_obj_del(lv_obj_t * obj)
{
 8010cc4:	b580      	push	{r7, lr}
 8010cc6:	b088      	sub	sp, #32
 8010cc8:	af00      	add	r7, sp, #0
 8010cca:	6078      	str	r0, [r7, #4]
    lv_obj_invalidate(obj);
 8010ccc:	6878      	ldr	r0, [r7, #4]
 8010cce:	f000 f8ae 	bl	8010e2e <lv_obj_invalidate>

    /*Delete from the group*/
#if LV_USE_GROUP
    lv_group_t * group = lv_obj_get_group(obj);
 8010cd2:	6878      	ldr	r0, [r7, #4]
 8010cd4:	f001 fbb9 	bl	801244a <lv_obj_get_group>
 8010cd8:	6178      	str	r0, [r7, #20]
    if(group) lv_group_remove_obj(obj);
 8010cda:	697b      	ldr	r3, [r7, #20]
 8010cdc:	2b00      	cmp	r3, #0
 8010cde:	d002      	beq.n	8010ce6 <lv_obj_del+0x22>
 8010ce0:	6878      	ldr	r0, [r7, #4]
 8010ce2:	f7fd fa05 	bl	800e0f0 <lv_group_remove_obj>
#endif

        /*Remove the animations from this object*/
#if LV_USE_ANIMATION
    lv_anim_del(obj, NULL);
 8010ce6:	2100      	movs	r1, #0
 8010ce8:	6878      	ldr	r0, [r7, #4]
 8010cea:	f00a fc79 	bl	801b5e0 <lv_anim_del>
#endif

    /*Recursively delete the children*/
    lv_obj_t * i;
    lv_obj_t * i_next;
    i = lv_ll_get_head(&(obj->child_ll));
 8010cee:	687b      	ldr	r3, [r7, #4]
 8010cf0:	3304      	adds	r3, #4
 8010cf2:	4618      	mov	r0, r3
 8010cf4:	f00b fc82 	bl	801c5fc <lv_ll_get_head>
 8010cf8:	61f8      	str	r0, [r7, #28]
    while(i != NULL) {
 8010cfa:	e00b      	b.n	8010d14 <lv_obj_del+0x50>
        /*Get the next object before delete this*/
        i_next = lv_ll_get_next(&(obj->child_ll), i);
 8010cfc:	687b      	ldr	r3, [r7, #4]
 8010cfe:	3304      	adds	r3, #4
 8010d00:	69f9      	ldr	r1, [r7, #28]
 8010d02:	4618      	mov	r0, r3
 8010d04:	f00b fca0 	bl	801c648 <lv_ll_get_next>
 8010d08:	60b8      	str	r0, [r7, #8]

        /*Call the recursive del to the child too*/
        delete_children(i);
 8010d0a:	69f8      	ldr	r0, [r7, #28]
 8010d0c:	f001 fd35 	bl	801277a <delete_children>

        /*Set i to the next node*/
        i = i_next;
 8010d10:	68bb      	ldr	r3, [r7, #8]
 8010d12:	61fb      	str	r3, [r7, #28]
    while(i != NULL) {
 8010d14:	69fb      	ldr	r3, [r7, #28]
 8010d16:	2b00      	cmp	r3, #0
 8010d18:	d1f0      	bne.n	8010cfc <lv_obj_del+0x38>
    }

    /*Let the user free the resources used in `LV_EVENT_DELETE`*/
    lv_event_send(obj, LV_EVENT_DELETE, NULL);
 8010d1a:	2200      	movs	r2, #0
 8010d1c:	2113      	movs	r1, #19
 8010d1e:	6878      	ldr	r0, [r7, #4]
 8010d20:	f001 f89d 	bl	8011e5e <lv_event_send>

    lv_event_mark_deleted(obj);
 8010d24:	6878      	ldr	r0, [r7, #4]
 8010d26:	f001 fda7 	bl	8012878 <lv_event_mark_deleted>

    /*Remove the object from parent's children list*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 8010d2a:	6878      	ldr	r0, [r7, #4]
 8010d2c:	f001 f9c8 	bl	80120c0 <lv_obj_get_parent>
 8010d30:	6138      	str	r0, [r7, #16]
    if(par == NULL) { /*It is a screen*/
 8010d32:	693b      	ldr	r3, [r7, #16]
 8010d34:	2b00      	cmp	r3, #0
 8010d36:	d10a      	bne.n	8010d4e <lv_obj_del+0x8a>
        lv_disp_t * d = lv_obj_get_disp(obj);
 8010d38:	6878      	ldr	r0, [r7, #4]
 8010d3a:	f001 f97b 	bl	8012034 <lv_obj_get_disp>
 8010d3e:	60f8      	str	r0, [r7, #12]
        lv_ll_rem(&d->scr_ll, obj);
 8010d40:	68fb      	ldr	r3, [r7, #12]
 8010d42:	3330      	adds	r3, #48	; 0x30
 8010d44:	6879      	ldr	r1, [r7, #4]
 8010d46:	4618      	mov	r0, r3
 8010d48:	f00b fbaa 	bl	801c4a0 <lv_ll_rem>
 8010d4c:	e005      	b.n	8010d5a <lv_obj_del+0x96>
    } else {
        lv_ll_rem(&(par->child_ll), obj);
 8010d4e:	693b      	ldr	r3, [r7, #16]
 8010d50:	3304      	adds	r3, #4
 8010d52:	6879      	ldr	r1, [r7, #4]
 8010d54:	4618      	mov	r0, r3
 8010d56:	f00b fba3 	bl	801c4a0 <lv_ll_rem>
    }

    /* Reset all input devices if the object to delete is used*/
    lv_indev_t * indev = lv_indev_get_next(NULL);
 8010d5a:	2000      	movs	r0, #0
 8010d5c:	f00a fb4e 	bl	801b3fc <lv_indev_get_next>
 8010d60:	61b8      	str	r0, [r7, #24]
    while(indev) {
 8010d62:	e026      	b.n	8010db2 <lv_obj_del+0xee>
        if(indev->proc.types.pointer.act_obj == obj || indev->proc.types.pointer.last_obj == obj) {
 8010d64:	69bb      	ldr	r3, [r7, #24]
 8010d66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8010d68:	687a      	ldr	r2, [r7, #4]
 8010d6a:	429a      	cmp	r2, r3
 8010d6c:	d004      	beq.n	8010d78 <lv_obj_del+0xb4>
 8010d6e:	69bb      	ldr	r3, [r7, #24]
 8010d70:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8010d72:	687a      	ldr	r2, [r7, #4]
 8010d74:	429a      	cmp	r2, r3
 8010d76:	d102      	bne.n	8010d7e <lv_obj_del+0xba>
            lv_indev_reset(indev);
 8010d78:	69b8      	ldr	r0, [r7, #24]
 8010d7a:	f7fd ff0a 	bl	800eb92 <lv_indev_reset>
        }
        if(indev->proc.types.pointer.last_pressed == obj) {
 8010d7e:	69bb      	ldr	r3, [r7, #24]
 8010d80:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010d82:	687a      	ldr	r2, [r7, #4]
 8010d84:	429a      	cmp	r2, r3
 8010d86:	d102      	bne.n	8010d8e <lv_obj_del+0xca>
            indev->proc.types.pointer.last_pressed = NULL;
 8010d88:	69bb      	ldr	r3, [r7, #24]
 8010d8a:	2200      	movs	r2, #0
 8010d8c:	641a      	str	r2, [r3, #64]	; 0x40
        }

#if LV_USE_GROUP
        if(indev->group == group && obj == lv_indev_get_obj_act()) {
 8010d8e:	69bb      	ldr	r3, [r7, #24]
 8010d90:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8010d92:	697a      	ldr	r2, [r7, #20]
 8010d94:	429a      	cmp	r2, r3
 8010d96:	d108      	bne.n	8010daa <lv_obj_del+0xe6>
 8010d98:	f7fd ff98 	bl	800eccc <lv_indev_get_obj_act>
 8010d9c:	4602      	mov	r2, r0
 8010d9e:	687b      	ldr	r3, [r7, #4]
 8010da0:	4293      	cmp	r3, r2
 8010da2:	d102      	bne.n	8010daa <lv_obj_del+0xe6>
            lv_indev_reset(indev);
 8010da4:	69b8      	ldr	r0, [r7, #24]
 8010da6:	f7fd fef4 	bl	800eb92 <lv_indev_reset>
        }
#endif
        indev = lv_indev_get_next(indev);
 8010daa:	69b8      	ldr	r0, [r7, #24]
 8010dac:	f00a fb26 	bl	801b3fc <lv_indev_get_next>
 8010db0:	61b8      	str	r0, [r7, #24]
    while(indev) {
 8010db2:	69bb      	ldr	r3, [r7, #24]
 8010db4:	2b00      	cmp	r3, #0
 8010db6:	d1d5      	bne.n	8010d64 <lv_obj_del+0xa0>
    }

    /* All children deleted.
     * Now clean up the object specific data*/
    obj->signal_cb(obj, LV_SIGNAL_CLEANUP, NULL);
 8010db8:	687b      	ldr	r3, [r7, #4]
 8010dba:	69db      	ldr	r3, [r3, #28]
 8010dbc:	2200      	movs	r2, #0
 8010dbe:	2100      	movs	r1, #0
 8010dc0:	6878      	ldr	r0, [r7, #4]
 8010dc2:	4798      	blx	r3

    /*Delete the base objects*/
    if(obj->ext_attr != NULL) lv_mem_free(obj->ext_attr);
 8010dc4:	687b      	ldr	r3, [r7, #4]
 8010dc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010dc8:	2b00      	cmp	r3, #0
 8010dca:	d004      	beq.n	8010dd6 <lv_obj_del+0x112>
 8010dcc:	687b      	ldr	r3, [r7, #4]
 8010dce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010dd0:	4618      	mov	r0, r3
 8010dd2:	f00b fda7 	bl	801c924 <lv_mem_free>
    lv_mem_free(obj); /*Free the object itself*/
 8010dd6:	6878      	ldr	r0, [r7, #4]
 8010dd8:	f00b fda4 	bl	801c924 <lv_mem_free>

    /*Send a signal to the parent to notify it about the child delete*/
    if(par != NULL) {
 8010ddc:	693b      	ldr	r3, [r7, #16]
 8010dde:	2b00      	cmp	r3, #0
 8010de0:	d005      	beq.n	8010dee <lv_obj_del+0x12a>
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, NULL);
 8010de2:	693b      	ldr	r3, [r7, #16]
 8010de4:	69db      	ldr	r3, [r3, #28]
 8010de6:	2200      	movs	r2, #0
 8010de8:	2101      	movs	r1, #1
 8010dea:	6938      	ldr	r0, [r7, #16]
 8010dec:	4798      	blx	r3
    }

    return LV_RES_INV;
 8010dee:	2300      	movs	r3, #0
}
 8010df0:	4618      	mov	r0, r3
 8010df2:	3720      	adds	r7, #32
 8010df4:	46bd      	mov	sp, r7
 8010df6:	bd80      	pop	{r7, pc}

08010df8 <lv_obj_clean>:
/**
 * Delete all children of an object
 * @param obj pointer to an object
 */
void lv_obj_clean(lv_obj_t * obj)
{
 8010df8:	b580      	push	{r7, lr}
 8010dfa:	b084      	sub	sp, #16
 8010dfc:	af00      	add	r7, sp, #0
 8010dfe:	6078      	str	r0, [r7, #4]
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 8010e00:	2100      	movs	r1, #0
 8010e02:	6878      	ldr	r0, [r7, #4]
 8010e04:	f001 f968 	bl	80120d8 <lv_obj_get_child>
 8010e08:	60f8      	str	r0, [r7, #12]
    lv_obj_t * child_next;
    while(child) {
 8010e0a:	e009      	b.n	8010e20 <lv_obj_clean+0x28>
        /* Read the next child before deleting the current
         * because the next couldn't be read from a deleted (invalid) node*/
        child_next = lv_obj_get_child(obj, child);
 8010e0c:	68f9      	ldr	r1, [r7, #12]
 8010e0e:	6878      	ldr	r0, [r7, #4]
 8010e10:	f001 f962 	bl	80120d8 <lv_obj_get_child>
 8010e14:	60b8      	str	r0, [r7, #8]
        lv_obj_del(child);
 8010e16:	68f8      	ldr	r0, [r7, #12]
 8010e18:	f7ff ff54 	bl	8010cc4 <lv_obj_del>
        child = child_next;
 8010e1c:	68bb      	ldr	r3, [r7, #8]
 8010e1e:	60fb      	str	r3, [r7, #12]
    while(child) {
 8010e20:	68fb      	ldr	r3, [r7, #12]
 8010e22:	2b00      	cmp	r3, #0
 8010e24:	d1f2      	bne.n	8010e0c <lv_obj_clean+0x14>
    }
}
 8010e26:	bf00      	nop
 8010e28:	3710      	adds	r7, #16
 8010e2a:	46bd      	mov	sp, r7
 8010e2c:	bd80      	pop	{r7, pc}

08010e2e <lv_obj_invalidate>:
/**
 * Mark the object as invalid therefore its current position will be redrawn by 'lv_refr_task'
 * @param obj pointer to an object
 */
void lv_obj_invalidate(const lv_obj_t * obj)
{
 8010e2e:	b580      	push	{r7, lr}
 8010e30:	b08a      	sub	sp, #40	; 0x28
 8010e32:	af00      	add	r7, sp, #0
 8010e34:	6078      	str	r0, [r7, #4]
    if(lv_obj_get_hidden(obj)) return;
 8010e36:	6878      	ldr	r0, [r7, #4]
 8010e38:	f001 fa34 	bl	80122a4 <lv_obj_get_hidden>
 8010e3c:	4603      	mov	r3, r0
 8010e3e:	2b00      	cmp	r3, #0
 8010e40:	d17e      	bne.n	8010f40 <lv_obj_invalidate+0x112>

    /*Invalidate the object only if it belongs to the 'LV_GC_ROOT(_lv_act_scr)'*/
    lv_obj_t * obj_scr = lv_obj_get_screen(obj);
 8010e42:	6878      	ldr	r0, [r7, #4]
 8010e44:	f001 f8e2 	bl	801200c <lv_obj_get_screen>
 8010e48:	61f8      	str	r0, [r7, #28]
    lv_disp_t * disp   = lv_obj_get_disp(obj_scr);
 8010e4a:	69f8      	ldr	r0, [r7, #28]
 8010e4c:	f001 f8f2 	bl	8012034 <lv_obj_get_disp>
 8010e50:	61b8      	str	r0, [r7, #24]
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
 8010e52:	69b8      	ldr	r0, [r7, #24]
 8010e54:	f7fd f802 	bl	800de5c <lv_disp_get_scr_act>
 8010e58:	4602      	mov	r2, r0
 8010e5a:	69fb      	ldr	r3, [r7, #28]
 8010e5c:	4293      	cmp	r3, r2
 8010e5e:	d00d      	beq.n	8010e7c <lv_obj_invalidate+0x4e>
 8010e60:	69b8      	ldr	r0, [r7, #24]
 8010e62:	f7fd f82d 	bl	800dec0 <lv_disp_get_layer_top>
 8010e66:	4602      	mov	r2, r0
 8010e68:	69fb      	ldr	r3, [r7, #28]
 8010e6a:	4293      	cmp	r3, r2
 8010e6c:	d006      	beq.n	8010e7c <lv_obj_invalidate+0x4e>
       obj_scr == lv_disp_get_layer_sys(disp)) {
 8010e6e:	69b8      	ldr	r0, [r7, #24]
 8010e70:	f7fd f846 	bl	800df00 <lv_disp_get_layer_sys>
 8010e74:	4602      	mov	r2, r0
    if(obj_scr == lv_disp_get_scr_act(disp) || obj_scr == lv_disp_get_layer_top(disp) ||
 8010e76:	69fb      	ldr	r3, [r7, #28]
 8010e78:	4293      	cmp	r3, r2
 8010e7a:	d164      	bne.n	8010f46 <lv_obj_invalidate+0x118>
        /*Truncate recursively to the parents*/
        lv_area_t area_trunc;
        lv_obj_t * par = lv_obj_get_parent(obj);
 8010e7c:	6878      	ldr	r0, [r7, #4]
 8010e7e:	f001 f91f 	bl	80120c0 <lv_obj_get_parent>
 8010e82:	6278      	str	r0, [r7, #36]	; 0x24
        bool union_ok  = true;
 8010e84:	2301      	movs	r3, #1
 8010e86:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
        /*Start with the original coordinates*/
        lv_coord_t ext_size = obj->ext_draw_pad;
 8010e8a:	687b      	ldr	r3, [r7, #4]
 8010e8c:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8010e8e:	82fb      	strh	r3, [r7, #22]
        lv_area_copy(&area_trunc, &obj->coords);
 8010e90:	687b      	ldr	r3, [r7, #4]
 8010e92:	f103 0210 	add.w	r2, r3, #16
 8010e96:	f107 030c 	add.w	r3, r7, #12
 8010e9a:	4611      	mov	r1, r2
 8010e9c:	4618      	mov	r0, r3
 8010e9e:	f7ff fbfb 	bl	8010698 <lv_area_copy>
        area_trunc.x1 -= ext_size;
 8010ea2:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8010ea6:	b29a      	uxth	r2, r3
 8010ea8:	8afb      	ldrh	r3, [r7, #22]
 8010eaa:	1ad3      	subs	r3, r2, r3
 8010eac:	b29b      	uxth	r3, r3
 8010eae:	b21b      	sxth	r3, r3
 8010eb0:	81bb      	strh	r3, [r7, #12]
        area_trunc.y1 -= ext_size;
 8010eb2:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8010eb6:	b29a      	uxth	r2, r3
 8010eb8:	8afb      	ldrh	r3, [r7, #22]
 8010eba:	1ad3      	subs	r3, r2, r3
 8010ebc:	b29b      	uxth	r3, r3
 8010ebe:	b21b      	sxth	r3, r3
 8010ec0:	81fb      	strh	r3, [r7, #14]
        area_trunc.x2 += ext_size;
 8010ec2:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8010ec6:	b29a      	uxth	r2, r3
 8010ec8:	8afb      	ldrh	r3, [r7, #22]
 8010eca:	4413      	add	r3, r2
 8010ecc:	b29b      	uxth	r3, r3
 8010ece:	b21b      	sxth	r3, r3
 8010ed0:	823b      	strh	r3, [r7, #16]
        area_trunc.y2 += ext_size;
 8010ed2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8010ed6:	b29a      	uxth	r2, r3
 8010ed8:	8afb      	ldrh	r3, [r7, #22]
 8010eda:	4413      	add	r3, r2
 8010edc:	b29b      	uxth	r3, r3
 8010ede:	b21b      	sxth	r3, r3
 8010ee0:	827b      	strh	r3, [r7, #18]

        /*Check through all parents*/
        while(par != NULL) {
 8010ee2:	e01d      	b.n	8010f20 <lv_obj_invalidate+0xf2>
            union_ok = lv_area_intersect(&area_trunc, &area_trunc, &par->coords);
 8010ee4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ee6:	f103 0210 	add.w	r2, r3, #16
 8010eea:	f107 010c 	add.w	r1, r7, #12
 8010eee:	f107 030c 	add.w	r3, r7, #12
 8010ef2:	4618      	mov	r0, r3
 8010ef4:	f00a fdf0 	bl	801bad8 <lv_area_intersect>
 8010ef8:	4603      	mov	r3, r0
 8010efa:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
            if(union_ok == false) break;       /*If no common parts with parent break;*/
 8010efe:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010f02:	f083 0301 	eor.w	r3, r3, #1
 8010f06:	b2db      	uxtb	r3, r3
 8010f08:	2b00      	cmp	r3, #0
 8010f0a:	d10d      	bne.n	8010f28 <lv_obj_invalidate+0xfa>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8010f0c:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010f0e:	f001 f9c9 	bl	80122a4 <lv_obj_get_hidden>
 8010f12:	4603      	mov	r3, r0
 8010f14:	2b00      	cmp	r3, #0
 8010f16:	d115      	bne.n	8010f44 <lv_obj_invalidate+0x116>

            par = lv_obj_get_parent(par);
 8010f18:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8010f1a:	f001 f8d1 	bl	80120c0 <lv_obj_get_parent>
 8010f1e:	6278      	str	r0, [r7, #36]	; 0x24
        while(par != NULL) {
 8010f20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010f22:	2b00      	cmp	r3, #0
 8010f24:	d1de      	bne.n	8010ee4 <lv_obj_invalidate+0xb6>
 8010f26:	e000      	b.n	8010f2a <lv_obj_invalidate+0xfc>
            if(union_ok == false) break;       /*If no common parts with parent break;*/
 8010f28:	bf00      	nop
        }

        if(union_ok) lv_inv_area(disp, &area_trunc);
 8010f2a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8010f2e:	2b00      	cmp	r3, #0
 8010f30:	d009      	beq.n	8010f46 <lv_obj_invalidate+0x118>
 8010f32:	f107 030c 	add.w	r3, r7, #12
 8010f36:	4619      	mov	r1, r3
 8010f38:	69b8      	ldr	r0, [r7, #24]
 8010f3a:	f001 fcff 	bl	801293c <lv_inv_area>
 8010f3e:	e002      	b.n	8010f46 <lv_obj_invalidate+0x118>
    if(lv_obj_get_hidden(obj)) return;
 8010f40:	bf00      	nop
 8010f42:	e000      	b.n	8010f46 <lv_obj_invalidate+0x118>
            if(lv_obj_get_hidden(par)) return; /*If the parent is hidden then the child is hidden and won't be drawn*/
 8010f44:	bf00      	nop
    }
}
 8010f46:	3728      	adds	r7, #40	; 0x28
 8010f48:	46bd      	mov	sp, r7
 8010f4a:	bd80      	pop	{r7, pc}

08010f4c <lv_obj_set_parent>:
 * Set a new parent for an object. Its relative position will be the same.
 * @param obj pointer to an object. Can't be a screen.
 * @param parent pointer to the new parent object. (Can't be NULL)
 */
void lv_obj_set_parent(lv_obj_t * obj, lv_obj_t * parent)
{
 8010f4c:	b580      	push	{r7, lr}
 8010f4e:	b084      	sub	sp, #16
 8010f50:	af00      	add	r7, sp, #0
 8010f52:	6078      	str	r0, [r7, #4]
 8010f54:	6039      	str	r1, [r7, #0]
    if(obj->par == NULL) {
 8010f56:	687b      	ldr	r3, [r7, #4]
 8010f58:	681b      	ldr	r3, [r3, #0]
 8010f5a:	2b00      	cmp	r3, #0
 8010f5c:	d107      	bne.n	8010f6e <lv_obj_set_parent+0x22>
        LV_LOG_WARN("Can't set the parent of a screen");
 8010f5e:	4b24      	ldr	r3, [pc, #144]	; (8010ff0 <lv_obj_set_parent+0xa4>)
 8010f60:	f240 220a 	movw	r2, #522	; 0x20a
 8010f64:	4923      	ldr	r1, [pc, #140]	; (8010ff4 <lv_obj_set_parent+0xa8>)
 8010f66:	2002      	movs	r0, #2
 8010f68:	f00b fc50 	bl	801c80c <lv_log_add>
        return;
 8010f6c:	e03d      	b.n	8010fea <lv_obj_set_parent+0x9e>
    }

    if(parent == NULL) {
 8010f6e:	683b      	ldr	r3, [r7, #0]
 8010f70:	2b00      	cmp	r3, #0
 8010f72:	d107      	bne.n	8010f84 <lv_obj_set_parent+0x38>
        LV_LOG_WARN("Can't set parent == NULL to an object");
 8010f74:	4b20      	ldr	r3, [pc, #128]	; (8010ff8 <lv_obj_set_parent+0xac>)
 8010f76:	f240 220f 	movw	r2, #527	; 0x20f
 8010f7a:	491e      	ldr	r1, [pc, #120]	; (8010ff4 <lv_obj_set_parent+0xa8>)
 8010f7c:	2002      	movs	r0, #2
 8010f7e:	f00b fc45 	bl	801c80c <lv_log_add>
        return;
 8010f82:	e032      	b.n	8010fea <lv_obj_set_parent+0x9e>
    }

    lv_obj_invalidate(obj);
 8010f84:	6878      	ldr	r0, [r7, #4]
 8010f86:	f7ff ff52 	bl	8010e2e <lv_obj_invalidate>

    lv_point_t old_pos;
    old_pos.x = lv_obj_get_x(obj);
 8010f8a:	6878      	ldr	r0, [r7, #4]
 8010f8c:	f001 f8d0 	bl	8012130 <lv_obj_get_x>
 8010f90:	4603      	mov	r3, r0
 8010f92:	813b      	strh	r3, [r7, #8]
    old_pos.y = lv_obj_get_y(obj);
 8010f94:	6878      	ldr	r0, [r7, #4]
 8010f96:	f001 f8e4 	bl	8012162 <lv_obj_get_y>
 8010f9a:	4603      	mov	r3, r0
 8010f9c:	817b      	strh	r3, [r7, #10]

    lv_obj_t * old_par = obj->par;
 8010f9e:	687b      	ldr	r3, [r7, #4]
 8010fa0:	681b      	ldr	r3, [r3, #0]
 8010fa2:	60fb      	str	r3, [r7, #12]

    lv_ll_chg_list(&obj->par->child_ll, &parent->child_ll, obj, true);
 8010fa4:	687b      	ldr	r3, [r7, #4]
 8010fa6:	681b      	ldr	r3, [r3, #0]
 8010fa8:	1d18      	adds	r0, r3, #4
 8010faa:	683b      	ldr	r3, [r7, #0]
 8010fac:	1d19      	adds	r1, r3, #4
 8010fae:	2301      	movs	r3, #1
 8010fb0:	687a      	ldr	r2, [r7, #4]
 8010fb2:	f00b face 	bl	801c552 <lv_ll_chg_list>
    obj->par = parent;
 8010fb6:	687b      	ldr	r3, [r7, #4]
 8010fb8:	683a      	ldr	r2, [r7, #0]
 8010fba:	601a      	str	r2, [r3, #0]
    lv_obj_set_pos(obj, old_pos.x, old_pos.y);
 8010fbc:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8010fc0:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8010fc4:	4619      	mov	r1, r3
 8010fc6:	6878      	ldr	r0, [r7, #4]
 8010fc8:	f000 f842 	bl	8011050 <lv_obj_set_pos>

    /*Notify the original parent because one of its children is lost*/
    old_par->signal_cb(old_par, LV_SIGNAL_CHILD_CHG, NULL);
 8010fcc:	68fb      	ldr	r3, [r7, #12]
 8010fce:	69db      	ldr	r3, [r3, #28]
 8010fd0:	2200      	movs	r2, #0
 8010fd2:	2101      	movs	r1, #1
 8010fd4:	68f8      	ldr	r0, [r7, #12]
 8010fd6:	4798      	blx	r3

    /*Notify the new parent about the child*/
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
 8010fd8:	683b      	ldr	r3, [r7, #0]
 8010fda:	69db      	ldr	r3, [r3, #28]
 8010fdc:	687a      	ldr	r2, [r7, #4]
 8010fde:	2101      	movs	r1, #1
 8010fe0:	6838      	ldr	r0, [r7, #0]
 8010fe2:	4798      	blx	r3

    lv_obj_invalidate(obj);
 8010fe4:	6878      	ldr	r0, [r7, #4]
 8010fe6:	f7ff ff22 	bl	8010e2e <lv_obj_invalidate>
}
 8010fea:	3710      	adds	r7, #16
 8010fec:	46bd      	mov	sp, r7
 8010fee:	bd80      	pop	{r7, pc}
 8010ff0:	080287f0 	.word	0x080287f0
 8010ff4:	08028770 	.word	0x08028770
 8010ff8:	08028814 	.word	0x08028814

08010ffc <lv_obj_move_foreground>:
/**
 * Move and object to the foreground
 * @param obj pointer to an object
 */
void lv_obj_move_foreground(lv_obj_t * obj)
{
 8010ffc:	b580      	push	{r7, lr}
 8010ffe:	b084      	sub	sp, #16
 8011000:	af00      	add	r7, sp, #0
 8011002:	6078      	str	r0, [r7, #4]
    lv_obj_t * parent = lv_obj_get_parent(obj);
 8011004:	6878      	ldr	r0, [r7, #4]
 8011006:	f001 f85b 	bl	80120c0 <lv_obj_get_parent>
 801100a:	60f8      	str	r0, [r7, #12]

    /*Do nothing of already in the foreground*/
    if(lv_ll_get_head(&parent->child_ll) == obj) return;
 801100c:	68fb      	ldr	r3, [r7, #12]
 801100e:	3304      	adds	r3, #4
 8011010:	4618      	mov	r0, r3
 8011012:	f00b faf3 	bl	801c5fc <lv_ll_get_head>
 8011016:	4602      	mov	r2, r0
 8011018:	687b      	ldr	r3, [r7, #4]
 801101a:	4293      	cmp	r3, r2
 801101c:	d014      	beq.n	8011048 <lv_obj_move_foreground+0x4c>

    lv_obj_invalidate(parent);
 801101e:	68f8      	ldr	r0, [r7, #12]
 8011020:	f7ff ff05 	bl	8010e2e <lv_obj_invalidate>

    lv_ll_chg_list(&parent->child_ll, &parent->child_ll, obj, true);
 8011024:	68fb      	ldr	r3, [r7, #12]
 8011026:	1d18      	adds	r0, r3, #4
 8011028:	68fb      	ldr	r3, [r7, #12]
 801102a:	1d19      	adds	r1, r3, #4
 801102c:	2301      	movs	r3, #1
 801102e:	687a      	ldr	r2, [r7, #4]
 8011030:	f00b fa8f 	bl	801c552 <lv_ll_chg_list>

    /*Notify the new parent about the child*/
    parent->signal_cb(parent, LV_SIGNAL_CHILD_CHG, obj);
 8011034:	68fb      	ldr	r3, [r7, #12]
 8011036:	69db      	ldr	r3, [r3, #28]
 8011038:	687a      	ldr	r2, [r7, #4]
 801103a:	2101      	movs	r1, #1
 801103c:	68f8      	ldr	r0, [r7, #12]
 801103e:	4798      	blx	r3

    lv_obj_invalidate(parent);
 8011040:	68f8      	ldr	r0, [r7, #12]
 8011042:	f7ff fef4 	bl	8010e2e <lv_obj_invalidate>
 8011046:	e000      	b.n	801104a <lv_obj_move_foreground+0x4e>
    if(lv_ll_get_head(&parent->child_ll) == obj) return;
 8011048:	bf00      	nop
}
 801104a:	3710      	adds	r7, #16
 801104c:	46bd      	mov	sp, r7
 801104e:	bd80      	pop	{r7, pc}

08011050 <lv_obj_set_pos>:
 * @param obj pointer to an object
 * @param x new distance from the left side of the parent
 * @param y new distance from the top of the parent
 */
void lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y)
{
 8011050:	b580      	push	{r7, lr}
 8011052:	b086      	sub	sp, #24
 8011054:	af00      	add	r7, sp, #0
 8011056:	6078      	str	r0, [r7, #4]
 8011058:	460b      	mov	r3, r1
 801105a:	807b      	strh	r3, [r7, #2]
 801105c:	4613      	mov	r3, r2
 801105e:	803b      	strh	r3, [r7, #0]
    /*Convert x and y to absolute coordinates*/
    lv_obj_t * par = obj->par;
 8011060:	687b      	ldr	r3, [r7, #4]
 8011062:	681b      	ldr	r3, [r3, #0]
 8011064:	617b      	str	r3, [r7, #20]

    x = x + par->coords.x1;
 8011066:	697b      	ldr	r3, [r7, #20]
 8011068:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801106c:	b29a      	uxth	r2, r3
 801106e:	887b      	ldrh	r3, [r7, #2]
 8011070:	4413      	add	r3, r2
 8011072:	b29b      	uxth	r3, r3
 8011074:	807b      	strh	r3, [r7, #2]
    y = y + par->coords.y1;
 8011076:	697b      	ldr	r3, [r7, #20]
 8011078:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801107c:	b29a      	uxth	r2, r3
 801107e:	883b      	ldrh	r3, [r7, #0]
 8011080:	4413      	add	r3, r2
 8011082:	b29b      	uxth	r3, r3
 8011084:	803b      	strh	r3, [r7, #0]

    /*Calculate and set the movement*/
    lv_point_t diff;
    diff.x = x - obj->coords.x1;
 8011086:	887a      	ldrh	r2, [r7, #2]
 8011088:	687b      	ldr	r3, [r7, #4]
 801108a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801108e:	b29b      	uxth	r3, r3
 8011090:	1ad3      	subs	r3, r2, r3
 8011092:	b29b      	uxth	r3, r3
 8011094:	b21b      	sxth	r3, r3
 8011096:	823b      	strh	r3, [r7, #16]
    diff.y = y - obj->coords.y1;
 8011098:	883a      	ldrh	r2, [r7, #0]
 801109a:	687b      	ldr	r3, [r7, #4]
 801109c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80110a0:	b29b      	uxth	r3, r3
 80110a2:	1ad3      	subs	r3, r2, r3
 80110a4:	b29b      	uxth	r3, r3
 80110a6:	b21b      	sxth	r3, r3
 80110a8:	827b      	strh	r3, [r7, #18]

    /* Do nothing if the position is not changed */
    /* It is very important else recursive positioning can
     * occur without position change*/
    if(diff.x == 0 && diff.y == 0) return;
 80110aa:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80110ae:	2b00      	cmp	r3, #0
 80110b0:	d103      	bne.n	80110ba <lv_obj_set_pos+0x6a>
 80110b2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80110b6:	2b00      	cmp	r3, #0
 80110b8:	d051      	beq.n	801115e <lv_obj_set_pos+0x10e>

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 80110ba:	6878      	ldr	r0, [r7, #4]
 80110bc:	f7ff feb7 	bl	8010e2e <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 80110c0:	f107 0308 	add.w	r3, r7, #8
 80110c4:	4619      	mov	r1, r3
 80110c6:	6878      	ldr	r0, [r7, #4]
 80110c8:	f001 f823 	bl	8012112 <lv_obj_get_coords>

    obj->coords.x1 += diff.x;
 80110cc:	687b      	ldr	r3, [r7, #4]
 80110ce:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80110d2:	b29a      	uxth	r2, r3
 80110d4:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80110d8:	b29b      	uxth	r3, r3
 80110da:	4413      	add	r3, r2
 80110dc:	b29b      	uxth	r3, r3
 80110de:	b21a      	sxth	r2, r3
 80110e0:	687b      	ldr	r3, [r7, #4]
 80110e2:	821a      	strh	r2, [r3, #16]
    obj->coords.y1 += diff.y;
 80110e4:	687b      	ldr	r3, [r7, #4]
 80110e6:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80110ea:	b29a      	uxth	r2, r3
 80110ec:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80110f0:	b29b      	uxth	r3, r3
 80110f2:	4413      	add	r3, r2
 80110f4:	b29b      	uxth	r3, r3
 80110f6:	b21a      	sxth	r2, r3
 80110f8:	687b      	ldr	r3, [r7, #4]
 80110fa:	825a      	strh	r2, [r3, #18]
    obj->coords.x2 += diff.x;
 80110fc:	687b      	ldr	r3, [r7, #4]
 80110fe:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8011102:	b29a      	uxth	r2, r3
 8011104:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8011108:	b29b      	uxth	r3, r3
 801110a:	4413      	add	r3, r2
 801110c:	b29b      	uxth	r3, r3
 801110e:	b21a      	sxth	r2, r3
 8011110:	687b      	ldr	r3, [r7, #4]
 8011112:	829a      	strh	r2, [r3, #20]
    obj->coords.y2 += diff.y;
 8011114:	687b      	ldr	r3, [r7, #4]
 8011116:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 801111a:	b29a      	uxth	r2, r3
 801111c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8011120:	b29b      	uxth	r3, r3
 8011122:	4413      	add	r3, r2
 8011124:	b29b      	uxth	r3, r3
 8011126:	b21a      	sxth	r2, r3
 8011128:	687b      	ldr	r3, [r7, #4]
 801112a:	82da      	strh	r2, [r3, #22]

    refresh_children_position(obj, diff.x, diff.y);
 801112c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8011130:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8011134:	4619      	mov	r1, r3
 8011136:	6878      	ldr	r0, [r7, #4]
 8011138:	f001 fa7a 	bl	8012630 <refresh_children_position>

    /*Inform the object about its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
 801113c:	687b      	ldr	r3, [r7, #4]
 801113e:	69db      	ldr	r3, [r3, #28]
 8011140:	f107 0208 	add.w	r2, r7, #8
 8011144:	2102      	movs	r1, #2
 8011146:	6878      	ldr	r0, [r7, #4]
 8011148:	4798      	blx	r3

    /*Send a signal to the parent too*/
    par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 801114a:	697b      	ldr	r3, [r7, #20]
 801114c:	69db      	ldr	r3, [r3, #28]
 801114e:	687a      	ldr	r2, [r7, #4]
 8011150:	2101      	movs	r1, #1
 8011152:	6978      	ldr	r0, [r7, #20]
 8011154:	4798      	blx	r3

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8011156:	6878      	ldr	r0, [r7, #4]
 8011158:	f7ff fe69 	bl	8010e2e <lv_obj_invalidate>
 801115c:	e000      	b.n	8011160 <lv_obj_set_pos+0x110>
    if(diff.x == 0 && diff.y == 0) return;
 801115e:	bf00      	nop
}
 8011160:	3718      	adds	r7, #24
 8011162:	46bd      	mov	sp, r7
 8011164:	bd80      	pop	{r7, pc}

08011166 <lv_obj_set_x>:
 * Set the x coordinate of a object
 * @param obj pointer to an object
 * @param x new distance from the left side from the parent
 */
void lv_obj_set_x(lv_obj_t * obj, lv_coord_t x)
{
 8011166:	b580      	push	{r7, lr}
 8011168:	b082      	sub	sp, #8
 801116a:	af00      	add	r7, sp, #0
 801116c:	6078      	str	r0, [r7, #4]
 801116e:	460b      	mov	r3, r1
 8011170:	807b      	strh	r3, [r7, #2]
    lv_obj_set_pos(obj, x, lv_obj_get_y(obj));
 8011172:	6878      	ldr	r0, [r7, #4]
 8011174:	f000 fff5 	bl	8012162 <lv_obj_get_y>
 8011178:	4603      	mov	r3, r0
 801117a:	461a      	mov	r2, r3
 801117c:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8011180:	4619      	mov	r1, r3
 8011182:	6878      	ldr	r0, [r7, #4]
 8011184:	f7ff ff64 	bl	8011050 <lv_obj_set_pos>
}
 8011188:	bf00      	nop
 801118a:	3708      	adds	r7, #8
 801118c:	46bd      	mov	sp, r7
 801118e:	bd80      	pop	{r7, pc}

08011190 <lv_obj_set_y>:
 * Set the y coordinate of a object
 * @param obj pointer to an object
 * @param y new distance from the top of the parent
 */
void lv_obj_set_y(lv_obj_t * obj, lv_coord_t y)
{
 8011190:	b580      	push	{r7, lr}
 8011192:	b082      	sub	sp, #8
 8011194:	af00      	add	r7, sp, #0
 8011196:	6078      	str	r0, [r7, #4]
 8011198:	460b      	mov	r3, r1
 801119a:	807b      	strh	r3, [r7, #2]
    lv_obj_set_pos(obj, lv_obj_get_x(obj), y);
 801119c:	6878      	ldr	r0, [r7, #4]
 801119e:	f000 ffc7 	bl	8012130 <lv_obj_get_x>
 80111a2:	4603      	mov	r3, r0
 80111a4:	4619      	mov	r1, r3
 80111a6:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80111aa:	461a      	mov	r2, r3
 80111ac:	6878      	ldr	r0, [r7, #4]
 80111ae:	f7ff ff4f 	bl	8011050 <lv_obj_set_pos>
}
 80111b2:	bf00      	nop
 80111b4:	3708      	adds	r7, #8
 80111b6:	46bd      	mov	sp, r7
 80111b8:	bd80      	pop	{r7, pc}

080111ba <lv_obj_set_size>:
 * @param obj pointer to an object
 * @param w new width
 * @param h new height
 */
void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h)
{
 80111ba:	b580      	push	{r7, lr}
 80111bc:	b086      	sub	sp, #24
 80111be:	af00      	add	r7, sp, #0
 80111c0:	6078      	str	r0, [r7, #4]
 80111c2:	460b      	mov	r3, r1
 80111c4:	807b      	strh	r3, [r7, #2]
 80111c6:	4613      	mov	r3, r2
 80111c8:	803b      	strh	r3, [r7, #0]

    /* Do nothing if the size is not changed */
    /* It is very important else recursive resizing can
     * occur without size change*/
    if(lv_obj_get_width(obj) == w && lv_obj_get_height(obj) == h) {
 80111ca:	6878      	ldr	r0, [r7, #4]
 80111cc:	f000 ffe2 	bl	8012194 <lv_obj_get_width>
 80111d0:	4603      	mov	r3, r0
 80111d2:	461a      	mov	r2, r3
 80111d4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80111d8:	4293      	cmp	r3, r2
 80111da:	d108      	bne.n	80111ee <lv_obj_set_size+0x34>
 80111dc:	6878      	ldr	r0, [r7, #4]
 80111de:	f000 ffe7 	bl	80121b0 <lv_obj_get_height>
 80111e2:	4603      	mov	r3, r0
 80111e4:	461a      	mov	r2, r3
 80111e6:	f9b7 3000 	ldrsh.w	r3, [r7]
 80111ea:	4293      	cmp	r3, r2
 80111ec:	d05a      	beq.n	80112a4 <lv_obj_set_size+0xea>
        return;
    }

    /*Invalidate the original area*/
    lv_obj_invalidate(obj);
 80111ee:	6878      	ldr	r0, [r7, #4]
 80111f0:	f7ff fe1d 	bl	8010e2e <lv_obj_invalidate>

    /*Save the original coordinates*/
    lv_area_t ori;
    lv_obj_get_coords(obj, &ori);
 80111f4:	f107 0308 	add.w	r3, r7, #8
 80111f8:	4619      	mov	r1, r3
 80111fa:	6878      	ldr	r0, [r7, #4]
 80111fc:	f000 ff89 	bl	8012112 <lv_obj_get_coords>

    /*Set the length and height*/
    obj->coords.x2 = obj->coords.x1 + w - 1;
 8011200:	687b      	ldr	r3, [r7, #4]
 8011202:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8011206:	b29a      	uxth	r2, r3
 8011208:	887b      	ldrh	r3, [r7, #2]
 801120a:	4413      	add	r3, r2
 801120c:	b29b      	uxth	r3, r3
 801120e:	3b01      	subs	r3, #1
 8011210:	b29b      	uxth	r3, r3
 8011212:	b21a      	sxth	r2, r3
 8011214:	687b      	ldr	r3, [r7, #4]
 8011216:	829a      	strh	r2, [r3, #20]
    obj->coords.y2 = obj->coords.y1 + h - 1;
 8011218:	687b      	ldr	r3, [r7, #4]
 801121a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801121e:	b29a      	uxth	r2, r3
 8011220:	883b      	ldrh	r3, [r7, #0]
 8011222:	4413      	add	r3, r2
 8011224:	b29b      	uxth	r3, r3
 8011226:	3b01      	subs	r3, #1
 8011228:	b29b      	uxth	r3, r3
 801122a:	b21a      	sxth	r2, r3
 801122c:	687b      	ldr	r3, [r7, #4]
 801122e:	82da      	strh	r2, [r3, #22]

    /*Send a signal to the object with its new coordinates*/
    obj->signal_cb(obj, LV_SIGNAL_CORD_CHG, &ori);
 8011230:	687b      	ldr	r3, [r7, #4]
 8011232:	69db      	ldr	r3, [r3, #28]
 8011234:	f107 0208 	add.w	r2, r7, #8
 8011238:	2102      	movs	r1, #2
 801123a:	6878      	ldr	r0, [r7, #4]
 801123c:	4798      	blx	r3

    /*Send a signal to the parent too*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 801123e:	6878      	ldr	r0, [r7, #4]
 8011240:	f000 ff3e 	bl	80120c0 <lv_obj_get_parent>
 8011244:	6138      	str	r0, [r7, #16]
    if(par != NULL) par->signal_cb(par, LV_SIGNAL_CHILD_CHG, obj);
 8011246:	693b      	ldr	r3, [r7, #16]
 8011248:	2b00      	cmp	r3, #0
 801124a:	d005      	beq.n	8011258 <lv_obj_set_size+0x9e>
 801124c:	693b      	ldr	r3, [r7, #16]
 801124e:	69db      	ldr	r3, [r3, #28]
 8011250:	687a      	ldr	r2, [r7, #4]
 8011252:	2101      	movs	r1, #1
 8011254:	6938      	ldr	r0, [r7, #16]
 8011256:	4798      	blx	r3

    /*Tell the children the parent's size has changed*/
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 8011258:	687b      	ldr	r3, [r7, #4]
 801125a:	3304      	adds	r3, #4
 801125c:	4618      	mov	r0, r3
 801125e:	f00b f9cd 	bl	801c5fc <lv_ll_get_head>
 8011262:	6178      	str	r0, [r7, #20]
 8011264:	e00c      	b.n	8011280 <lv_obj_set_size+0xc6>
    {
        i->signal_cb(i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
 8011266:	697b      	ldr	r3, [r7, #20]
 8011268:	69db      	ldr	r3, [r3, #28]
 801126a:	2200      	movs	r2, #0
 801126c:	2103      	movs	r1, #3
 801126e:	6978      	ldr	r0, [r7, #20]
 8011270:	4798      	blx	r3
    LV_LL_READ(obj->child_ll, i)
 8011272:	687b      	ldr	r3, [r7, #4]
 8011274:	3304      	adds	r3, #4
 8011276:	6979      	ldr	r1, [r7, #20]
 8011278:	4618      	mov	r0, r3
 801127a:	f00b f9e5 	bl	801c648 <lv_ll_get_next>
 801127e:	6178      	str	r0, [r7, #20]
 8011280:	697b      	ldr	r3, [r7, #20]
 8011282:	2b00      	cmp	r3, #0
 8011284:	d1ef      	bne.n	8011266 <lv_obj_set_size+0xac>
    }

    /*Invalidate the new area*/
    lv_obj_invalidate(obj);
 8011286:	6878      	ldr	r0, [r7, #4]
 8011288:	f7ff fdd1 	bl	8010e2e <lv_obj_invalidate>

    /*Automatically realign the object if required*/
#if LV_USE_OBJ_REALIGN
    if(obj->realign.auto_realign) lv_obj_realign(obj);
 801128c:	687b      	ldr	r3, [r7, #4]
 801128e:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8011292:	f003 0301 	and.w	r3, r3, #1
 8011296:	b2db      	uxtb	r3, r3
 8011298:	2b00      	cmp	r3, #0
 801129a:	d004      	beq.n	80112a6 <lv_obj_set_size+0xec>
 801129c:	6878      	ldr	r0, [r7, #4]
 801129e:	f000 fcc3 	bl	8011c28 <lv_obj_realign>
 80112a2:	e000      	b.n	80112a6 <lv_obj_set_size+0xec>
        return;
 80112a4:	bf00      	nop
#endif
}
 80112a6:	3718      	adds	r7, #24
 80112a8:	46bd      	mov	sp, r7
 80112aa:	bd80      	pop	{r7, pc}

080112ac <lv_obj_set_width>:
 * Set the width of an object
 * @param obj pointer to an object
 * @param w new width
 */
void lv_obj_set_width(lv_obj_t * obj, lv_coord_t w)
{
 80112ac:	b580      	push	{r7, lr}
 80112ae:	b082      	sub	sp, #8
 80112b0:	af00      	add	r7, sp, #0
 80112b2:	6078      	str	r0, [r7, #4]
 80112b4:	460b      	mov	r3, r1
 80112b6:	807b      	strh	r3, [r7, #2]
    lv_obj_set_size(obj, w, lv_obj_get_height(obj));
 80112b8:	6878      	ldr	r0, [r7, #4]
 80112ba:	f000 ff79 	bl	80121b0 <lv_obj_get_height>
 80112be:	4603      	mov	r3, r0
 80112c0:	461a      	mov	r2, r3
 80112c2:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80112c6:	4619      	mov	r1, r3
 80112c8:	6878      	ldr	r0, [r7, #4]
 80112ca:	f7ff ff76 	bl	80111ba <lv_obj_set_size>
}
 80112ce:	bf00      	nop
 80112d0:	3708      	adds	r7, #8
 80112d2:	46bd      	mov	sp, r7
 80112d4:	bd80      	pop	{r7, pc}

080112d6 <lv_obj_set_height>:
 * Set the height of an object
 * @param obj pointer to an object
 * @param h new height
 */
void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h)
{
 80112d6:	b580      	push	{r7, lr}
 80112d8:	b082      	sub	sp, #8
 80112da:	af00      	add	r7, sp, #0
 80112dc:	6078      	str	r0, [r7, #4]
 80112de:	460b      	mov	r3, r1
 80112e0:	807b      	strh	r3, [r7, #2]
    lv_obj_set_size(obj, lv_obj_get_width(obj), h);
 80112e2:	6878      	ldr	r0, [r7, #4]
 80112e4:	f000 ff56 	bl	8012194 <lv_obj_get_width>
 80112e8:	4603      	mov	r3, r0
 80112ea:	4619      	mov	r1, r3
 80112ec:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80112f0:	461a      	mov	r2, r3
 80112f2:	6878      	ldr	r0, [r7, #4]
 80112f4:	f7ff ff61 	bl	80111ba <lv_obj_set_size>
}
 80112f8:	bf00      	nop
 80112fa:	3708      	adds	r7, #8
 80112fc:	46bd      	mov	sp, r7
 80112fe:	bd80      	pop	{r7, pc}

08011300 <lv_obj_align>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_mod x coordinate shift after alignment
 * @param y_mod y coordinate shift after alignment
 */
void lv_obj_align(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_mod, lv_coord_t y_mod)
{
 8011300:	b590      	push	{r4, r7, lr}
 8011302:	b089      	sub	sp, #36	; 0x24
 8011304:	af00      	add	r7, sp, #0
 8011306:	60f8      	str	r0, [r7, #12]
 8011308:	60b9      	str	r1, [r7, #8]
 801130a:	4611      	mov	r1, r2
 801130c:	461a      	mov	r2, r3
 801130e:	460b      	mov	r3, r1
 8011310:	71fb      	strb	r3, [r7, #7]
 8011312:	4613      	mov	r3, r2
 8011314:	80bb      	strh	r3, [r7, #4]
    lv_coord_t new_x = lv_obj_get_x(obj);
 8011316:	68f8      	ldr	r0, [r7, #12]
 8011318:	f000 ff0a 	bl	8012130 <lv_obj_get_x>
 801131c:	4603      	mov	r3, r0
 801131e:	83fb      	strh	r3, [r7, #30]
    lv_coord_t new_y = lv_obj_get_y(obj);
 8011320:	68f8      	ldr	r0, [r7, #12]
 8011322:	f000 ff1e 	bl	8012162 <lv_obj_get_y>
 8011326:	4603      	mov	r3, r0
 8011328:	83bb      	strh	r3, [r7, #28]

    if(base == NULL) {
 801132a:	68bb      	ldr	r3, [r7, #8]
 801132c:	2b00      	cmp	r3, #0
 801132e:	d103      	bne.n	8011338 <lv_obj_align+0x38>
        base = lv_obj_get_parent(obj);
 8011330:	68f8      	ldr	r0, [r7, #12]
 8011332:	f000 fec5 	bl	80120c0 <lv_obj_get_parent>
 8011336:	60b8      	str	r0, [r7, #8]
    }

    switch(align) {
 8011338:	79fb      	ldrb	r3, [r7, #7]
 801133a:	2b14      	cmp	r3, #20
 801133c:	f200 820d 	bhi.w	801175a <lv_obj_align+0x45a>
 8011340:	a201      	add	r2, pc, #4	; (adr r2, 8011348 <lv_obj_align+0x48>)
 8011342:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011346:	bf00      	nop
 8011348:	0801139d 	.word	0x0801139d
 801134c:	080113fb 	.word	0x080113fb
 8011350:	08011405 	.word	0x08011405
 8011354:	08011439 	.word	0x08011439
 8011358:	08011459 	.word	0x08011459
 801135c:	08011479 	.word	0x08011479
 8011360:	080114c3 	.word	0x080114c3
 8011364:	080114f9 	.word	0x080114f9
 8011368:	0801152d 	.word	0x0801152d
 801136c:	08011577 	.word	0x08011577
 8011370:	0801158d 	.word	0x0801158d
 8011374:	080115cd 	.word	0x080115cd
 8011378:	080115f9 	.word	0x080115f9
 801137c:	08011609 	.word	0x08011609
 8011380:	08011643 	.word	0x08011643
 8011384:	08011669 	.word	0x08011669
 8011388:	0801167f 	.word	0x0801167f
 801138c:	080116bf 	.word	0x080116bf
 8011390:	080116eb 	.word	0x080116eb
 8011394:	080116fb 	.word	0x080116fb
 8011398:	08011735 	.word	0x08011735
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 801139c:	68b8      	ldr	r0, [r7, #8]
 801139e:	f000 fef9 	bl	8012194 <lv_obj_get_width>
 80113a2:	4603      	mov	r3, r0
 80113a4:	2b00      	cmp	r3, #0
 80113a6:	da00      	bge.n	80113aa <lv_obj_align+0xaa>
 80113a8:	3301      	adds	r3, #1
 80113aa:	105b      	asrs	r3, r3, #1
 80113ac:	b21b      	sxth	r3, r3
 80113ae:	b29c      	uxth	r4, r3
 80113b0:	68f8      	ldr	r0, [r7, #12]
 80113b2:	f000 feef 	bl	8012194 <lv_obj_get_width>
 80113b6:	4603      	mov	r3, r0
 80113b8:	2b00      	cmp	r3, #0
 80113ba:	da00      	bge.n	80113be <lv_obj_align+0xbe>
 80113bc:	3301      	adds	r3, #1
 80113be:	105b      	asrs	r3, r3, #1
 80113c0:	b21b      	sxth	r3, r3
 80113c2:	b29b      	uxth	r3, r3
 80113c4:	1ae3      	subs	r3, r4, r3
 80113c6:	b29b      	uxth	r3, r3
 80113c8:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 80113ca:	68b8      	ldr	r0, [r7, #8]
 80113cc:	f000 fef0 	bl	80121b0 <lv_obj_get_height>
 80113d0:	4603      	mov	r3, r0
 80113d2:	2b00      	cmp	r3, #0
 80113d4:	da00      	bge.n	80113d8 <lv_obj_align+0xd8>
 80113d6:	3301      	adds	r3, #1
 80113d8:	105b      	asrs	r3, r3, #1
 80113da:	b21b      	sxth	r3, r3
 80113dc:	b29c      	uxth	r4, r3
 80113de:	68f8      	ldr	r0, [r7, #12]
 80113e0:	f000 fee6 	bl	80121b0 <lv_obj_get_height>
 80113e4:	4603      	mov	r3, r0
 80113e6:	2b00      	cmp	r3, #0
 80113e8:	da00      	bge.n	80113ec <lv_obj_align+0xec>
 80113ea:	3301      	adds	r3, #1
 80113ec:	105b      	asrs	r3, r3, #1
 80113ee:	b21b      	sxth	r3, r3
 80113f0:	b29b      	uxth	r3, r3
 80113f2:	1ae3      	subs	r3, r4, r3
 80113f4:	b29b      	uxth	r3, r3
 80113f6:	83bb      	strh	r3, [r7, #28]
            break;
 80113f8:	e1af      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = 0;
 80113fa:	2300      	movs	r3, #0
 80113fc:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 80113fe:	2300      	movs	r3, #0
 8011400:	83bb      	strh	r3, [r7, #28]
            break;
 8011402:	e1aa      	b.n	801175a <lv_obj_align+0x45a>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8011404:	68b8      	ldr	r0, [r7, #8]
 8011406:	f000 fec5 	bl	8012194 <lv_obj_get_width>
 801140a:	4603      	mov	r3, r0
 801140c:	2b00      	cmp	r3, #0
 801140e:	da00      	bge.n	8011412 <lv_obj_align+0x112>
 8011410:	3301      	adds	r3, #1
 8011412:	105b      	asrs	r3, r3, #1
 8011414:	b21b      	sxth	r3, r3
 8011416:	b29c      	uxth	r4, r3
 8011418:	68f8      	ldr	r0, [r7, #12]
 801141a:	f000 febb 	bl	8012194 <lv_obj_get_width>
 801141e:	4603      	mov	r3, r0
 8011420:	2b00      	cmp	r3, #0
 8011422:	da00      	bge.n	8011426 <lv_obj_align+0x126>
 8011424:	3301      	adds	r3, #1
 8011426:	105b      	asrs	r3, r3, #1
 8011428:	b21b      	sxth	r3, r3
 801142a:	b29b      	uxth	r3, r3
 801142c:	1ae3      	subs	r3, r4, r3
 801142e:	b29b      	uxth	r3, r3
 8011430:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 8011432:	2300      	movs	r3, #0
 8011434:	83bb      	strh	r3, [r7, #28]
            break;
 8011436:	e190      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 8011438:	68b8      	ldr	r0, [r7, #8]
 801143a:	f000 feab 	bl	8012194 <lv_obj_get_width>
 801143e:	4603      	mov	r3, r0
 8011440:	b29c      	uxth	r4, r3
 8011442:	68f8      	ldr	r0, [r7, #12]
 8011444:	f000 fea6 	bl	8012194 <lv_obj_get_width>
 8011448:	4603      	mov	r3, r0
 801144a:	b29b      	uxth	r3, r3
 801144c:	1ae3      	subs	r3, r4, r3
 801144e:	b29b      	uxth	r3, r3
 8011450:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 8011452:	2300      	movs	r3, #0
 8011454:	83bb      	strh	r3, [r7, #28]
            break;
 8011456:	e180      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = 0;
 8011458:	2300      	movs	r3, #0
 801145a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 801145c:	68b8      	ldr	r0, [r7, #8]
 801145e:	f000 fea7 	bl	80121b0 <lv_obj_get_height>
 8011462:	4603      	mov	r3, r0
 8011464:	b29c      	uxth	r4, r3
 8011466:	68f8      	ldr	r0, [r7, #12]
 8011468:	f000 fea2 	bl	80121b0 <lv_obj_get_height>
 801146c:	4603      	mov	r3, r0
 801146e:	b29b      	uxth	r3, r3
 8011470:	1ae3      	subs	r3, r4, r3
 8011472:	b29b      	uxth	r3, r3
 8011474:	83bb      	strh	r3, [r7, #28]
            break;
 8011476:	e170      	b.n	801175a <lv_obj_align+0x45a>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8011478:	68b8      	ldr	r0, [r7, #8]
 801147a:	f000 fe8b 	bl	8012194 <lv_obj_get_width>
 801147e:	4603      	mov	r3, r0
 8011480:	2b00      	cmp	r3, #0
 8011482:	da00      	bge.n	8011486 <lv_obj_align+0x186>
 8011484:	3301      	adds	r3, #1
 8011486:	105b      	asrs	r3, r3, #1
 8011488:	b21b      	sxth	r3, r3
 801148a:	b29c      	uxth	r4, r3
 801148c:	68f8      	ldr	r0, [r7, #12]
 801148e:	f000 fe81 	bl	8012194 <lv_obj_get_width>
 8011492:	4603      	mov	r3, r0
 8011494:	2b00      	cmp	r3, #0
 8011496:	da00      	bge.n	801149a <lv_obj_align+0x19a>
 8011498:	3301      	adds	r3, #1
 801149a:	105b      	asrs	r3, r3, #1
 801149c:	b21b      	sxth	r3, r3
 801149e:	b29b      	uxth	r3, r3
 80114a0:	1ae3      	subs	r3, r4, r3
 80114a2:	b29b      	uxth	r3, r3
 80114a4:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 80114a6:	68b8      	ldr	r0, [r7, #8]
 80114a8:	f000 fe82 	bl	80121b0 <lv_obj_get_height>
 80114ac:	4603      	mov	r3, r0
 80114ae:	b29c      	uxth	r4, r3
 80114b0:	68f8      	ldr	r0, [r7, #12]
 80114b2:	f000 fe7d 	bl	80121b0 <lv_obj_get_height>
 80114b6:	4603      	mov	r3, r0
 80114b8:	b29b      	uxth	r3, r3
 80114ba:	1ae3      	subs	r3, r4, r3
 80114bc:	b29b      	uxth	r3, r3
 80114be:	83bb      	strh	r3, [r7, #28]
            break;
 80114c0:	e14b      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 80114c2:	68b8      	ldr	r0, [r7, #8]
 80114c4:	f000 fe66 	bl	8012194 <lv_obj_get_width>
 80114c8:	4603      	mov	r3, r0
 80114ca:	b29c      	uxth	r4, r3
 80114cc:	68f8      	ldr	r0, [r7, #12]
 80114ce:	f000 fe61 	bl	8012194 <lv_obj_get_width>
 80114d2:	4603      	mov	r3, r0
 80114d4:	b29b      	uxth	r3, r3
 80114d6:	1ae3      	subs	r3, r4, r3
 80114d8:	b29b      	uxth	r3, r3
 80114da:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 80114dc:	68b8      	ldr	r0, [r7, #8]
 80114de:	f000 fe67 	bl	80121b0 <lv_obj_get_height>
 80114e2:	4603      	mov	r3, r0
 80114e4:	b29c      	uxth	r4, r3
 80114e6:	68f8      	ldr	r0, [r7, #12]
 80114e8:	f000 fe62 	bl	80121b0 <lv_obj_get_height>
 80114ec:	4603      	mov	r3, r0
 80114ee:	b29b      	uxth	r3, r3
 80114f0:	1ae3      	subs	r3, r4, r3
 80114f2:	b29b      	uxth	r3, r3
 80114f4:	83bb      	strh	r3, [r7, #28]
            break;
 80114f6:	e130      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = 0;
 80114f8:	2300      	movs	r3, #0
 80114fa:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 80114fc:	68b8      	ldr	r0, [r7, #8]
 80114fe:	f000 fe57 	bl	80121b0 <lv_obj_get_height>
 8011502:	4603      	mov	r3, r0
 8011504:	2b00      	cmp	r3, #0
 8011506:	da00      	bge.n	801150a <lv_obj_align+0x20a>
 8011508:	3301      	adds	r3, #1
 801150a:	105b      	asrs	r3, r3, #1
 801150c:	b21b      	sxth	r3, r3
 801150e:	b29c      	uxth	r4, r3
 8011510:	68f8      	ldr	r0, [r7, #12]
 8011512:	f000 fe4d 	bl	80121b0 <lv_obj_get_height>
 8011516:	4603      	mov	r3, r0
 8011518:	2b00      	cmp	r3, #0
 801151a:	da00      	bge.n	801151e <lv_obj_align+0x21e>
 801151c:	3301      	adds	r3, #1
 801151e:	105b      	asrs	r3, r3, #1
 8011520:	b21b      	sxth	r3, r3
 8011522:	b29b      	uxth	r3, r3
 8011524:	1ae3      	subs	r3, r4, r3
 8011526:	b29b      	uxth	r3, r3
 8011528:	83bb      	strh	r3, [r7, #28]
            break;
 801152a:	e116      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 801152c:	68b8      	ldr	r0, [r7, #8]
 801152e:	f000 fe31 	bl	8012194 <lv_obj_get_width>
 8011532:	4603      	mov	r3, r0
 8011534:	b29c      	uxth	r4, r3
 8011536:	68f8      	ldr	r0, [r7, #12]
 8011538:	f000 fe2c 	bl	8012194 <lv_obj_get_width>
 801153c:	4603      	mov	r3, r0
 801153e:	b29b      	uxth	r3, r3
 8011540:	1ae3      	subs	r3, r4, r3
 8011542:	b29b      	uxth	r3, r3
 8011544:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 8011546:	68b8      	ldr	r0, [r7, #8]
 8011548:	f000 fe32 	bl	80121b0 <lv_obj_get_height>
 801154c:	4603      	mov	r3, r0
 801154e:	2b00      	cmp	r3, #0
 8011550:	da00      	bge.n	8011554 <lv_obj_align+0x254>
 8011552:	3301      	adds	r3, #1
 8011554:	105b      	asrs	r3, r3, #1
 8011556:	b21b      	sxth	r3, r3
 8011558:	b29c      	uxth	r4, r3
 801155a:	68f8      	ldr	r0, [r7, #12]
 801155c:	f000 fe28 	bl	80121b0 <lv_obj_get_height>
 8011560:	4603      	mov	r3, r0
 8011562:	2b00      	cmp	r3, #0
 8011564:	da00      	bge.n	8011568 <lv_obj_align+0x268>
 8011566:	3301      	adds	r3, #1
 8011568:	105b      	asrs	r3, r3, #1
 801156a:	b21b      	sxth	r3, r3
 801156c:	b29b      	uxth	r3, r3
 801156e:	1ae3      	subs	r3, r4, r3
 8011570:	b29b      	uxth	r3, r3
 8011572:	83bb      	strh	r3, [r7, #28]
            break;
 8011574:	e0f1      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = 0;
 8011576:	2300      	movs	r3, #0
 8011578:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 801157a:	68f8      	ldr	r0, [r7, #12]
 801157c:	f000 fe18 	bl	80121b0 <lv_obj_get_height>
 8011580:	4603      	mov	r3, r0
 8011582:	b29b      	uxth	r3, r3
 8011584:	425b      	negs	r3, r3
 8011586:	b29b      	uxth	r3, r3
 8011588:	83bb      	strh	r3, [r7, #28]
            break;
 801158a:	e0e6      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 801158c:	68b8      	ldr	r0, [r7, #8]
 801158e:	f000 fe01 	bl	8012194 <lv_obj_get_width>
 8011592:	4603      	mov	r3, r0
 8011594:	2b00      	cmp	r3, #0
 8011596:	da00      	bge.n	801159a <lv_obj_align+0x29a>
 8011598:	3301      	adds	r3, #1
 801159a:	105b      	asrs	r3, r3, #1
 801159c:	b21b      	sxth	r3, r3
 801159e:	b29c      	uxth	r4, r3
 80115a0:	68f8      	ldr	r0, [r7, #12]
 80115a2:	f000 fdf7 	bl	8012194 <lv_obj_get_width>
 80115a6:	4603      	mov	r3, r0
 80115a8:	2b00      	cmp	r3, #0
 80115aa:	da00      	bge.n	80115ae <lv_obj_align+0x2ae>
 80115ac:	3301      	adds	r3, #1
 80115ae:	105b      	asrs	r3, r3, #1
 80115b0:	b21b      	sxth	r3, r3
 80115b2:	b29b      	uxth	r3, r3
 80115b4:	1ae3      	subs	r3, r4, r3
 80115b6:	b29b      	uxth	r3, r3
 80115b8:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 80115ba:	68f8      	ldr	r0, [r7, #12]
 80115bc:	f000 fdf8 	bl	80121b0 <lv_obj_get_height>
 80115c0:	4603      	mov	r3, r0
 80115c2:	b29b      	uxth	r3, r3
 80115c4:	425b      	negs	r3, r3
 80115c6:	b29b      	uxth	r3, r3
 80115c8:	83bb      	strh	r3, [r7, #28]
            break;
 80115ca:	e0c6      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 80115cc:	68b8      	ldr	r0, [r7, #8]
 80115ce:	f000 fde1 	bl	8012194 <lv_obj_get_width>
 80115d2:	4603      	mov	r3, r0
 80115d4:	b29c      	uxth	r4, r3
 80115d6:	68f8      	ldr	r0, [r7, #12]
 80115d8:	f000 fddc 	bl	8012194 <lv_obj_get_width>
 80115dc:	4603      	mov	r3, r0
 80115de:	b29b      	uxth	r3, r3
 80115e0:	1ae3      	subs	r3, r4, r3
 80115e2:	b29b      	uxth	r3, r3
 80115e4:	83fb      	strh	r3, [r7, #30]
            new_y = -lv_obj_get_height(obj);
 80115e6:	68f8      	ldr	r0, [r7, #12]
 80115e8:	f000 fde2 	bl	80121b0 <lv_obj_get_height>
 80115ec:	4603      	mov	r3, r0
 80115ee:	b29b      	uxth	r3, r3
 80115f0:	425b      	negs	r3, r3
 80115f2:	b29b      	uxth	r3, r3
 80115f4:	83bb      	strh	r3, [r7, #28]
            break;
 80115f6:	e0b0      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = 0;
 80115f8:	2300      	movs	r3, #0
 80115fa:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 80115fc:	68b8      	ldr	r0, [r7, #8]
 80115fe:	f000 fdd7 	bl	80121b0 <lv_obj_get_height>
 8011602:	4603      	mov	r3, r0
 8011604:	83bb      	strh	r3, [r7, #28]
            break;
 8011606:	e0a8      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - lv_obj_get_width(obj) / 2;
 8011608:	68b8      	ldr	r0, [r7, #8]
 801160a:	f000 fdc3 	bl	8012194 <lv_obj_get_width>
 801160e:	4603      	mov	r3, r0
 8011610:	2b00      	cmp	r3, #0
 8011612:	da00      	bge.n	8011616 <lv_obj_align+0x316>
 8011614:	3301      	adds	r3, #1
 8011616:	105b      	asrs	r3, r3, #1
 8011618:	b21b      	sxth	r3, r3
 801161a:	b29c      	uxth	r4, r3
 801161c:	68f8      	ldr	r0, [r7, #12]
 801161e:	f000 fdb9 	bl	8012194 <lv_obj_get_width>
 8011622:	4603      	mov	r3, r0
 8011624:	2b00      	cmp	r3, #0
 8011626:	da00      	bge.n	801162a <lv_obj_align+0x32a>
 8011628:	3301      	adds	r3, #1
 801162a:	105b      	asrs	r3, r3, #1
 801162c:	b21b      	sxth	r3, r3
 801162e:	b29b      	uxth	r3, r3
 8011630:	1ae3      	subs	r3, r4, r3
 8011632:	b29b      	uxth	r3, r3
 8011634:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 8011636:	68b8      	ldr	r0, [r7, #8]
 8011638:	f000 fdba 	bl	80121b0 <lv_obj_get_height>
 801163c:	4603      	mov	r3, r0
 801163e:	83bb      	strh	r3, [r7, #28]
            break;
 8011640:	e08b      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - lv_obj_get_width(obj);
 8011642:	68b8      	ldr	r0, [r7, #8]
 8011644:	f000 fda6 	bl	8012194 <lv_obj_get_width>
 8011648:	4603      	mov	r3, r0
 801164a:	b29c      	uxth	r4, r3
 801164c:	68f8      	ldr	r0, [r7, #12]
 801164e:	f000 fda1 	bl	8012194 <lv_obj_get_width>
 8011652:	4603      	mov	r3, r0
 8011654:	b29b      	uxth	r3, r3
 8011656:	1ae3      	subs	r3, r4, r3
 8011658:	b29b      	uxth	r3, r3
 801165a:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base);
 801165c:	68b8      	ldr	r0, [r7, #8]
 801165e:	f000 fda7 	bl	80121b0 <lv_obj_get_height>
 8011662:	4603      	mov	r3, r0
 8011664:	83bb      	strh	r3, [r7, #28]
            break;
 8011666:	e078      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -lv_obj_get_width(obj);
 8011668:	68f8      	ldr	r0, [r7, #12]
 801166a:	f000 fd93 	bl	8012194 <lv_obj_get_width>
 801166e:	4603      	mov	r3, r0
 8011670:	b29b      	uxth	r3, r3
 8011672:	425b      	negs	r3, r3
 8011674:	b29b      	uxth	r3, r3
 8011676:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 8011678:	2300      	movs	r3, #0
 801167a:	83bb      	strh	r3, [r7, #28]
            break;
 801167c:	e06d      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -lv_obj_get_width(obj);
 801167e:	68f8      	ldr	r0, [r7, #12]
 8011680:	f000 fd88 	bl	8012194 <lv_obj_get_width>
 8011684:	4603      	mov	r3, r0
 8011686:	b29b      	uxth	r3, r3
 8011688:	425b      	negs	r3, r3
 801168a:	b29b      	uxth	r3, r3
 801168c:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 801168e:	68b8      	ldr	r0, [r7, #8]
 8011690:	f000 fd8e 	bl	80121b0 <lv_obj_get_height>
 8011694:	4603      	mov	r3, r0
 8011696:	2b00      	cmp	r3, #0
 8011698:	da00      	bge.n	801169c <lv_obj_align+0x39c>
 801169a:	3301      	adds	r3, #1
 801169c:	105b      	asrs	r3, r3, #1
 801169e:	b21b      	sxth	r3, r3
 80116a0:	b29c      	uxth	r4, r3
 80116a2:	68f8      	ldr	r0, [r7, #12]
 80116a4:	f000 fd84 	bl	80121b0 <lv_obj_get_height>
 80116a8:	4603      	mov	r3, r0
 80116aa:	2b00      	cmp	r3, #0
 80116ac:	da00      	bge.n	80116b0 <lv_obj_align+0x3b0>
 80116ae:	3301      	adds	r3, #1
 80116b0:	105b      	asrs	r3, r3, #1
 80116b2:	b21b      	sxth	r3, r3
 80116b4:	b29b      	uxth	r3, r3
 80116b6:	1ae3      	subs	r3, r4, r3
 80116b8:	b29b      	uxth	r3, r3
 80116ba:	83bb      	strh	r3, [r7, #28]
            break;
 80116bc:	e04d      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -lv_obj_get_width(obj);
 80116be:	68f8      	ldr	r0, [r7, #12]
 80116c0:	f000 fd68 	bl	8012194 <lv_obj_get_width>
 80116c4:	4603      	mov	r3, r0
 80116c6:	b29b      	uxth	r3, r3
 80116c8:	425b      	negs	r3, r3
 80116ca:	b29b      	uxth	r3, r3
 80116cc:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 80116ce:	68b8      	ldr	r0, [r7, #8]
 80116d0:	f000 fd6e 	bl	80121b0 <lv_obj_get_height>
 80116d4:	4603      	mov	r3, r0
 80116d6:	b29c      	uxth	r4, r3
 80116d8:	68f8      	ldr	r0, [r7, #12]
 80116da:	f000 fd69 	bl	80121b0 <lv_obj_get_height>
 80116de:	4603      	mov	r3, r0
 80116e0:	b29b      	uxth	r3, r3
 80116e2:	1ae3      	subs	r3, r4, r3
 80116e4:	b29b      	uxth	r3, r3
 80116e6:	83bb      	strh	r3, [r7, #28]
            break;
 80116e8:	e037      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base);
 80116ea:	68b8      	ldr	r0, [r7, #8]
 80116ec:	f000 fd52 	bl	8012194 <lv_obj_get_width>
 80116f0:	4603      	mov	r3, r0
 80116f2:	83fb      	strh	r3, [r7, #30]
            new_y = 0;
 80116f4:	2300      	movs	r3, #0
 80116f6:	83bb      	strh	r3, [r7, #28]
            break;
 80116f8:	e02f      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base);
 80116fa:	68b8      	ldr	r0, [r7, #8]
 80116fc:	f000 fd4a 	bl	8012194 <lv_obj_get_width>
 8011700:	4603      	mov	r3, r0
 8011702:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) / 2 - lv_obj_get_height(obj) / 2;
 8011704:	68b8      	ldr	r0, [r7, #8]
 8011706:	f000 fd53 	bl	80121b0 <lv_obj_get_height>
 801170a:	4603      	mov	r3, r0
 801170c:	2b00      	cmp	r3, #0
 801170e:	da00      	bge.n	8011712 <lv_obj_align+0x412>
 8011710:	3301      	adds	r3, #1
 8011712:	105b      	asrs	r3, r3, #1
 8011714:	b21b      	sxth	r3, r3
 8011716:	b29c      	uxth	r4, r3
 8011718:	68f8      	ldr	r0, [r7, #12]
 801171a:	f000 fd49 	bl	80121b0 <lv_obj_get_height>
 801171e:	4603      	mov	r3, r0
 8011720:	2b00      	cmp	r3, #0
 8011722:	da00      	bge.n	8011726 <lv_obj_align+0x426>
 8011724:	3301      	adds	r3, #1
 8011726:	105b      	asrs	r3, r3, #1
 8011728:	b21b      	sxth	r3, r3
 801172a:	b29b      	uxth	r3, r3
 801172c:	1ae3      	subs	r3, r4, r3
 801172e:	b29b      	uxth	r3, r3
 8011730:	83bb      	strh	r3, [r7, #28]
            break;
 8011732:	e012      	b.n	801175a <lv_obj_align+0x45a>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base);
 8011734:	68b8      	ldr	r0, [r7, #8]
 8011736:	f000 fd2d 	bl	8012194 <lv_obj_get_width>
 801173a:	4603      	mov	r3, r0
 801173c:	83fb      	strh	r3, [r7, #30]
            new_y = lv_obj_get_height(base) - lv_obj_get_height(obj);
 801173e:	68b8      	ldr	r0, [r7, #8]
 8011740:	f000 fd36 	bl	80121b0 <lv_obj_get_height>
 8011744:	4603      	mov	r3, r0
 8011746:	b29c      	uxth	r4, r3
 8011748:	68f8      	ldr	r0, [r7, #12]
 801174a:	f000 fd31 	bl	80121b0 <lv_obj_get_height>
 801174e:	4603      	mov	r3, r0
 8011750:	b29b      	uxth	r3, r3
 8011752:	1ae3      	subs	r3, r4, r3
 8011754:	b29b      	uxth	r3, r3
 8011756:	83bb      	strh	r3, [r7, #28]
            break;
 8011758:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 801175a:	68f8      	ldr	r0, [r7, #12]
 801175c:	f000 fcb0 	bl	80120c0 <lv_obj_get_parent>
 8011760:	61b8      	str	r0, [r7, #24]
    lv_coord_t base_abs_x = base->coords.x1;
 8011762:	68bb      	ldr	r3, [r7, #8]
 8011764:	8a1b      	ldrh	r3, [r3, #16]
 8011766:	82fb      	strh	r3, [r7, #22]
    lv_coord_t base_abs_y = base->coords.y1;
 8011768:	68bb      	ldr	r3, [r7, #8]
 801176a:	8a5b      	ldrh	r3, [r3, #18]
 801176c:	82bb      	strh	r3, [r7, #20]
    lv_coord_t par_abs_x  = par->coords.x1;
 801176e:	69bb      	ldr	r3, [r7, #24]
 8011770:	8a1b      	ldrh	r3, [r3, #16]
 8011772:	827b      	strh	r3, [r7, #18]
    lv_coord_t par_abs_y  = par->coords.y1;
 8011774:	69bb      	ldr	r3, [r7, #24]
 8011776:	8a5b      	ldrh	r3, [r3, #18]
 8011778:	823b      	strh	r3, [r7, #16]
    new_x += x_mod + base_abs_x;
 801177a:	88ba      	ldrh	r2, [r7, #4]
 801177c:	8afb      	ldrh	r3, [r7, #22]
 801177e:	4413      	add	r3, r2
 8011780:	b29a      	uxth	r2, r3
 8011782:	8bfb      	ldrh	r3, [r7, #30]
 8011784:	4413      	add	r3, r2
 8011786:	b29b      	uxth	r3, r3
 8011788:	83fb      	strh	r3, [r7, #30]
    new_y += y_mod + base_abs_y;
 801178a:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 801178c:	8abb      	ldrh	r3, [r7, #20]
 801178e:	4413      	add	r3, r2
 8011790:	b29a      	uxth	r2, r3
 8011792:	8bbb      	ldrh	r3, [r7, #28]
 8011794:	4413      	add	r3, r2
 8011796:	b29b      	uxth	r3, r3
 8011798:	83bb      	strh	r3, [r7, #28]
    new_x -= par_abs_x;
 801179a:	8bfa      	ldrh	r2, [r7, #30]
 801179c:	8a7b      	ldrh	r3, [r7, #18]
 801179e:	1ad3      	subs	r3, r2, r3
 80117a0:	b29b      	uxth	r3, r3
 80117a2:	83fb      	strh	r3, [r7, #30]
    new_y -= par_abs_y;
 80117a4:	8bba      	ldrh	r2, [r7, #28]
 80117a6:	8a3b      	ldrh	r3, [r7, #16]
 80117a8:	1ad3      	subs	r3, r2, r3
 80117aa:	b29b      	uxth	r3, r3
 80117ac:	83bb      	strh	r3, [r7, #28]

    lv_obj_set_pos(obj, new_x, new_y);
 80117ae:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 80117b2:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80117b6:	4619      	mov	r1, r3
 80117b8:	68f8      	ldr	r0, [r7, #12]
 80117ba:	f7ff fc49 	bl	8011050 <lv_obj_set_pos>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 80117be:	68fb      	ldr	r3, [r7, #12]
 80117c0:	79fa      	ldrb	r2, [r7, #7]
 80117c2:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    obj->realign.xofs        = x_mod;
 80117c6:	68fb      	ldr	r3, [r7, #12]
 80117c8:	88ba      	ldrh	r2, [r7, #4]
 80117ca:	879a      	strh	r2, [r3, #60]	; 0x3c
    obj->realign.yofs        = y_mod;
 80117cc:	68fb      	ldr	r3, [r7, #12]
 80117ce:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 80117d0:	87da      	strh	r2, [r3, #62]	; 0x3e
    obj->realign.base        = base;
 80117d2:	68fb      	ldr	r3, [r7, #12]
 80117d4:	68ba      	ldr	r2, [r7, #8]
 80117d6:	639a      	str	r2, [r3, #56]	; 0x38
    obj->realign.origo_align = 0;
 80117d8:	68fa      	ldr	r2, [r7, #12]
 80117da:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 80117de:	f36f 0341 	bfc	r3, #1, #1
 80117e2:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
}
 80117e6:	bf00      	nop
 80117e8:	3724      	adds	r7, #36	; 0x24
 80117ea:	46bd      	mov	sp, r7
 80117ec:	bd90      	pop	{r4, r7, pc}
 80117ee:	bf00      	nop

080117f0 <lv_obj_align_origo>:
 * @param align type of alignment (see 'lv_align_t' enum)
 * @param x_mod x coordinate shift after alignment
 * @param y_mod y coordinate shift after alignment
 */
void lv_obj_align_origo(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_mod, lv_coord_t y_mod)
{
 80117f0:	b580      	push	{r7, lr}
 80117f2:	b08a      	sub	sp, #40	; 0x28
 80117f4:	af00      	add	r7, sp, #0
 80117f6:	60f8      	str	r0, [r7, #12]
 80117f8:	60b9      	str	r1, [r7, #8]
 80117fa:	4611      	mov	r1, r2
 80117fc:	461a      	mov	r2, r3
 80117fe:	460b      	mov	r3, r1
 8011800:	71fb      	strb	r3, [r7, #7]
 8011802:	4613      	mov	r3, r2
 8011804:	80bb      	strh	r3, [r7, #4]
    lv_coord_t new_x = lv_obj_get_x(obj);
 8011806:	68f8      	ldr	r0, [r7, #12]
 8011808:	f000 fc92 	bl	8012130 <lv_obj_get_x>
 801180c:	4603      	mov	r3, r0
 801180e:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t new_y = lv_obj_get_y(obj);
 8011810:	68f8      	ldr	r0, [r7, #12]
 8011812:	f000 fca6 	bl	8012162 <lv_obj_get_y>
 8011816:	4603      	mov	r3, r0
 8011818:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_coord_t obj_w_half = lv_obj_get_width(obj) / 2;
 801181a:	68f8      	ldr	r0, [r7, #12]
 801181c:	f000 fcba 	bl	8012194 <lv_obj_get_width>
 8011820:	4603      	mov	r3, r0
 8011822:	2b00      	cmp	r3, #0
 8011824:	da00      	bge.n	8011828 <lv_obj_align_origo+0x38>
 8011826:	3301      	adds	r3, #1
 8011828:	105b      	asrs	r3, r3, #1
 801182a:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_coord_t obj_h_half = lv_obj_get_height(obj) / 2;
 801182c:	68f8      	ldr	r0, [r7, #12]
 801182e:	f000 fcbf 	bl	80121b0 <lv_obj_get_height>
 8011832:	4603      	mov	r3, r0
 8011834:	2b00      	cmp	r3, #0
 8011836:	da00      	bge.n	801183a <lv_obj_align_origo+0x4a>
 8011838:	3301      	adds	r3, #1
 801183a:	105b      	asrs	r3, r3, #1
 801183c:	843b      	strh	r3, [r7, #32]

    if(base == NULL) {
 801183e:	68bb      	ldr	r3, [r7, #8]
 8011840:	2b00      	cmp	r3, #0
 8011842:	d103      	bne.n	801184c <lv_obj_align_origo+0x5c>
        base = lv_obj_get_parent(obj);
 8011844:	68f8      	ldr	r0, [r7, #12]
 8011846:	f000 fc3b 	bl	80120c0 <lv_obj_get_parent>
 801184a:	60b8      	str	r0, [r7, #8]
    }

    switch(align) {
 801184c:	79fb      	ldrb	r3, [r7, #7]
 801184e:	2b14      	cmp	r3, #20
 8011850:	f200 819f 	bhi.w	8011b92 <lv_obj_align_origo+0x3a2>
 8011854:	a201      	add	r2, pc, #4	; (adr r2, 801185c <lv_obj_align_origo+0x6c>)
 8011856:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801185a:	bf00      	nop
 801185c:	080118b1 	.word	0x080118b1
 8011860:	080118eb 	.word	0x080118eb
 8011864:	080118fd 	.word	0x080118fd
 8011868:	08011923 	.word	0x08011923
 801186c:	0801193f 	.word	0x0801193f
 8011870:	0801195b 	.word	0x0801195b
 8011874:	0801198b 	.word	0x0801198b
 8011878:	080119b1 	.word	0x080119b1
 801187c:	080119d7 	.word	0x080119d7
 8011880:	08011a07 	.word	0x08011a07
 8011884:	08011a19 	.word	0x08011a19
 8011888:	08011a3f 	.word	0x08011a3f
 801188c:	08011a5b 	.word	0x08011a5b
 8011890:	08011a77 	.word	0x08011a77
 8011894:	08011aa7 	.word	0x08011aa7
 8011898:	08011acd 	.word	0x08011acd
 801189c:	08011adf 	.word	0x08011adf
 80118a0:	08011b05 	.word	0x08011b05
 80118a4:	08011b21 	.word	0x08011b21
 80118a8:	08011b3d 	.word	0x08011b3d
 80118ac:	08011b6d 	.word	0x08011b6d
        case LV_ALIGN_CENTER:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 80118b0:	68b8      	ldr	r0, [r7, #8]
 80118b2:	f000 fc6f 	bl	8012194 <lv_obj_get_width>
 80118b6:	4603      	mov	r3, r0
 80118b8:	2b00      	cmp	r3, #0
 80118ba:	da00      	bge.n	80118be <lv_obj_align_origo+0xce>
 80118bc:	3301      	adds	r3, #1
 80118be:	105b      	asrs	r3, r3, #1
 80118c0:	b21b      	sxth	r3, r3
 80118c2:	b29a      	uxth	r2, r3
 80118c4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80118c6:	1ad3      	subs	r3, r2, r3
 80118c8:	b29b      	uxth	r3, r3
 80118ca:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 80118cc:	68b8      	ldr	r0, [r7, #8]
 80118ce:	f000 fc6f 	bl	80121b0 <lv_obj_get_height>
 80118d2:	4603      	mov	r3, r0
 80118d4:	2b00      	cmp	r3, #0
 80118d6:	da00      	bge.n	80118da <lv_obj_align_origo+0xea>
 80118d8:	3301      	adds	r3, #1
 80118da:	105b      	asrs	r3, r3, #1
 80118dc:	b21b      	sxth	r3, r3
 80118de:	b29a      	uxth	r2, r3
 80118e0:	8c3b      	ldrh	r3, [r7, #32]
 80118e2:	1ad3      	subs	r3, r2, r3
 80118e4:	b29b      	uxth	r3, r3
 80118e6:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80118e8:	e153      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_TOP_LEFT:
            new_x = -obj_w_half;
 80118ea:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80118ec:	425b      	negs	r3, r3
 80118ee:	b29b      	uxth	r3, r3
 80118f0:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 80118f2:	8c3b      	ldrh	r3, [r7, #32]
 80118f4:	425b      	negs	r3, r3
 80118f6:	b29b      	uxth	r3, r3
 80118f8:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80118fa:	e14a      	b.n	8011b92 <lv_obj_align_origo+0x3a2>
        case LV_ALIGN_IN_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 80118fc:	68b8      	ldr	r0, [r7, #8]
 80118fe:	f000 fc49 	bl	8012194 <lv_obj_get_width>
 8011902:	4603      	mov	r3, r0
 8011904:	2b00      	cmp	r3, #0
 8011906:	da00      	bge.n	801190a <lv_obj_align_origo+0x11a>
 8011908:	3301      	adds	r3, #1
 801190a:	105b      	asrs	r3, r3, #1
 801190c:	b21b      	sxth	r3, r3
 801190e:	b29a      	uxth	r2, r3
 8011910:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011912:	1ad3      	subs	r3, r2, r3
 8011914:	b29b      	uxth	r3, r3
 8011916:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011918:	8c3b      	ldrh	r3, [r7, #32]
 801191a:	425b      	negs	r3, r3
 801191c:	b29b      	uxth	r3, r3
 801191e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011920:	e137      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8011922:	68b8      	ldr	r0, [r7, #8]
 8011924:	f000 fc36 	bl	8012194 <lv_obj_get_width>
 8011928:	4603      	mov	r3, r0
 801192a:	b29a      	uxth	r2, r3
 801192c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801192e:	1ad3      	subs	r3, r2, r3
 8011930:	b29b      	uxth	r3, r3
 8011932:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011934:	8c3b      	ldrh	r3, [r7, #32]
 8011936:	425b      	negs	r3, r3
 8011938:	b29b      	uxth	r3, r3
 801193a:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 801193c:	e129      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_BOTTOM_LEFT:
            new_x = -obj_w_half;
 801193e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011940:	425b      	negs	r3, r3
 8011942:	b29b      	uxth	r3, r3
 8011944:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011946:	68b8      	ldr	r0, [r7, #8]
 8011948:	f000 fc32 	bl	80121b0 <lv_obj_get_height>
 801194c:	4603      	mov	r3, r0
 801194e:	b29a      	uxth	r2, r3
 8011950:	8c3b      	ldrh	r3, [r7, #32]
 8011952:	1ad3      	subs	r3, r2, r3
 8011954:	b29b      	uxth	r3, r3
 8011956:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011958:	e11b      	b.n	8011b92 <lv_obj_align_origo+0x3a2>
        case LV_ALIGN_IN_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 801195a:	68b8      	ldr	r0, [r7, #8]
 801195c:	f000 fc1a 	bl	8012194 <lv_obj_get_width>
 8011960:	4603      	mov	r3, r0
 8011962:	2b00      	cmp	r3, #0
 8011964:	da00      	bge.n	8011968 <lv_obj_align_origo+0x178>
 8011966:	3301      	adds	r3, #1
 8011968:	105b      	asrs	r3, r3, #1
 801196a:	b21b      	sxth	r3, r3
 801196c:	b29a      	uxth	r2, r3
 801196e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011970:	1ad3      	subs	r3, r2, r3
 8011972:	b29b      	uxth	r3, r3
 8011974:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011976:	68b8      	ldr	r0, [r7, #8]
 8011978:	f000 fc1a 	bl	80121b0 <lv_obj_get_height>
 801197c:	4603      	mov	r3, r0
 801197e:	b29a      	uxth	r2, r3
 8011980:	8c3b      	ldrh	r3, [r7, #32]
 8011982:	1ad3      	subs	r3, r2, r3
 8011984:	b29b      	uxth	r3, r3
 8011986:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011988:	e103      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 801198a:	68b8      	ldr	r0, [r7, #8]
 801198c:	f000 fc02 	bl	8012194 <lv_obj_get_width>
 8011990:	4603      	mov	r3, r0
 8011992:	b29a      	uxth	r2, r3
 8011994:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011996:	1ad3      	subs	r3, r2, r3
 8011998:	b29b      	uxth	r3, r3
 801199a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 801199c:	68b8      	ldr	r0, [r7, #8]
 801199e:	f000 fc07 	bl	80121b0 <lv_obj_get_height>
 80119a2:	4603      	mov	r3, r0
 80119a4:	b29a      	uxth	r2, r3
 80119a6:	8c3b      	ldrh	r3, [r7, #32]
 80119a8:	1ad3      	subs	r3, r2, r3
 80119aa:	b29b      	uxth	r3, r3
 80119ac:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80119ae:	e0f0      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_LEFT_MID:
            new_x = -obj_w_half;
 80119b0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80119b2:	425b      	negs	r3, r3
 80119b4:	b29b      	uxth	r3, r3
 80119b6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 80119b8:	68b8      	ldr	r0, [r7, #8]
 80119ba:	f000 fbf9 	bl	80121b0 <lv_obj_get_height>
 80119be:	4603      	mov	r3, r0
 80119c0:	2b00      	cmp	r3, #0
 80119c2:	da00      	bge.n	80119c6 <lv_obj_align_origo+0x1d6>
 80119c4:	3301      	adds	r3, #1
 80119c6:	105b      	asrs	r3, r3, #1
 80119c8:	b21b      	sxth	r3, r3
 80119ca:	b29a      	uxth	r2, r3
 80119cc:	8c3b      	ldrh	r3, [r7, #32]
 80119ce:	1ad3      	subs	r3, r2, r3
 80119d0:	b29b      	uxth	r3, r3
 80119d2:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 80119d4:	e0dd      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_IN_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 80119d6:	68b8      	ldr	r0, [r7, #8]
 80119d8:	f000 fbdc 	bl	8012194 <lv_obj_get_width>
 80119dc:	4603      	mov	r3, r0
 80119de:	b29a      	uxth	r2, r3
 80119e0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80119e2:	1ad3      	subs	r3, r2, r3
 80119e4:	b29b      	uxth	r3, r3
 80119e6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 80119e8:	68b8      	ldr	r0, [r7, #8]
 80119ea:	f000 fbe1 	bl	80121b0 <lv_obj_get_height>
 80119ee:	4603      	mov	r3, r0
 80119f0:	2b00      	cmp	r3, #0
 80119f2:	da00      	bge.n	80119f6 <lv_obj_align_origo+0x206>
 80119f4:	3301      	adds	r3, #1
 80119f6:	105b      	asrs	r3, r3, #1
 80119f8:	b21b      	sxth	r3, r3
 80119fa:	b29a      	uxth	r2, r3
 80119fc:	8c3b      	ldrh	r3, [r7, #32]
 80119fe:	1ad3      	subs	r3, r2, r3
 8011a00:	b29b      	uxth	r3, r3
 8011a02:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011a04:	e0c5      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_TOP_LEFT:
            new_x = -obj_w_half;
 8011a06:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011a08:	425b      	negs	r3, r3
 8011a0a:	b29b      	uxth	r3, r3
 8011a0c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011a0e:	8c3b      	ldrh	r3, [r7, #32]
 8011a10:	425b      	negs	r3, r3
 8011a12:	b29b      	uxth	r3, r3
 8011a14:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011a16:	e0bc      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_TOP_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8011a18:	68b8      	ldr	r0, [r7, #8]
 8011a1a:	f000 fbbb 	bl	8012194 <lv_obj_get_width>
 8011a1e:	4603      	mov	r3, r0
 8011a20:	2b00      	cmp	r3, #0
 8011a22:	da00      	bge.n	8011a26 <lv_obj_align_origo+0x236>
 8011a24:	3301      	adds	r3, #1
 8011a26:	105b      	asrs	r3, r3, #1
 8011a28:	b21b      	sxth	r3, r3
 8011a2a:	b29a      	uxth	r2, r3
 8011a2c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011a2e:	1ad3      	subs	r3, r2, r3
 8011a30:	b29b      	uxth	r3, r3
 8011a32:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011a34:	8c3b      	ldrh	r3, [r7, #32]
 8011a36:	425b      	negs	r3, r3
 8011a38:	b29b      	uxth	r3, r3
 8011a3a:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011a3c:	e0a9      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_TOP_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8011a3e:	68b8      	ldr	r0, [r7, #8]
 8011a40:	f000 fba8 	bl	8012194 <lv_obj_get_width>
 8011a44:	4603      	mov	r3, r0
 8011a46:	b29a      	uxth	r2, r3
 8011a48:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011a4a:	1ad3      	subs	r3, r2, r3
 8011a4c:	b29b      	uxth	r3, r3
 8011a4e:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011a50:	8c3b      	ldrh	r3, [r7, #32]
 8011a52:	425b      	negs	r3, r3
 8011a54:	b29b      	uxth	r3, r3
 8011a56:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011a58:	e09b      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_BOTTOM_LEFT:
            new_x = -obj_w_half;
 8011a5a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011a5c:	425b      	negs	r3, r3
 8011a5e:	b29b      	uxth	r3, r3
 8011a60:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011a62:	68b8      	ldr	r0, [r7, #8]
 8011a64:	f000 fba4 	bl	80121b0 <lv_obj_get_height>
 8011a68:	4603      	mov	r3, r0
 8011a6a:	b29a      	uxth	r2, r3
 8011a6c:	8c3b      	ldrh	r3, [r7, #32]
 8011a6e:	1ad3      	subs	r3, r2, r3
 8011a70:	b29b      	uxth	r3, r3
 8011a72:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011a74:	e08d      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_BOTTOM_MID:
            new_x = lv_obj_get_width(base) / 2 - obj_w_half;
 8011a76:	68b8      	ldr	r0, [r7, #8]
 8011a78:	f000 fb8c 	bl	8012194 <lv_obj_get_width>
 8011a7c:	4603      	mov	r3, r0
 8011a7e:	2b00      	cmp	r3, #0
 8011a80:	da00      	bge.n	8011a84 <lv_obj_align_origo+0x294>
 8011a82:	3301      	adds	r3, #1
 8011a84:	105b      	asrs	r3, r3, #1
 8011a86:	b21b      	sxth	r3, r3
 8011a88:	b29a      	uxth	r2, r3
 8011a8a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011a8c:	1ad3      	subs	r3, r2, r3
 8011a8e:	b29b      	uxth	r3, r3
 8011a90:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011a92:	68b8      	ldr	r0, [r7, #8]
 8011a94:	f000 fb8c 	bl	80121b0 <lv_obj_get_height>
 8011a98:	4603      	mov	r3, r0
 8011a9a:	b29a      	uxth	r2, r3
 8011a9c:	8c3b      	ldrh	r3, [r7, #32]
 8011a9e:	1ad3      	subs	r3, r2, r3
 8011aa0:	b29b      	uxth	r3, r3
 8011aa2:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011aa4:	e075      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_BOTTOM_RIGHT:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8011aa6:	68b8      	ldr	r0, [r7, #8]
 8011aa8:	f000 fb74 	bl	8012194 <lv_obj_get_width>
 8011aac:	4603      	mov	r3, r0
 8011aae:	b29a      	uxth	r2, r3
 8011ab0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011ab2:	1ad3      	subs	r3, r2, r3
 8011ab4:	b29b      	uxth	r3, r3
 8011ab6:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011ab8:	68b8      	ldr	r0, [r7, #8]
 8011aba:	f000 fb79 	bl	80121b0 <lv_obj_get_height>
 8011abe:	4603      	mov	r3, r0
 8011ac0:	b29a      	uxth	r2, r3
 8011ac2:	8c3b      	ldrh	r3, [r7, #32]
 8011ac4:	1ad3      	subs	r3, r2, r3
 8011ac6:	b29b      	uxth	r3, r3
 8011ac8:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011aca:	e062      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_LEFT_TOP:
            new_x = -obj_w_half;
 8011acc:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011ace:	425b      	negs	r3, r3
 8011ad0:	b29b      	uxth	r3, r3
 8011ad2:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011ad4:	8c3b      	ldrh	r3, [r7, #32]
 8011ad6:	425b      	negs	r3, r3
 8011ad8:	b29b      	uxth	r3, r3
 8011ada:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011adc:	e059      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_LEFT_MID:
            new_x = -obj_w_half;
 8011ade:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011ae0:	425b      	negs	r3, r3
 8011ae2:	b29b      	uxth	r3, r3
 8011ae4:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8011ae6:	68b8      	ldr	r0, [r7, #8]
 8011ae8:	f000 fb62 	bl	80121b0 <lv_obj_get_height>
 8011aec:	4603      	mov	r3, r0
 8011aee:	2b00      	cmp	r3, #0
 8011af0:	da00      	bge.n	8011af4 <lv_obj_align_origo+0x304>
 8011af2:	3301      	adds	r3, #1
 8011af4:	105b      	asrs	r3, r3, #1
 8011af6:	b21b      	sxth	r3, r3
 8011af8:	b29a      	uxth	r2, r3
 8011afa:	8c3b      	ldrh	r3, [r7, #32]
 8011afc:	1ad3      	subs	r3, r2, r3
 8011afe:	b29b      	uxth	r3, r3
 8011b00:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011b02:	e046      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_LEFT_BOTTOM:
            new_x = -obj_w_half;
 8011b04:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011b06:	425b      	negs	r3, r3
 8011b08:	b29b      	uxth	r3, r3
 8011b0a:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011b0c:	68b8      	ldr	r0, [r7, #8]
 8011b0e:	f000 fb4f 	bl	80121b0 <lv_obj_get_height>
 8011b12:	4603      	mov	r3, r0
 8011b14:	b29a      	uxth	r2, r3
 8011b16:	8c3b      	ldrh	r3, [r7, #32]
 8011b18:	1ad3      	subs	r3, r2, r3
 8011b1a:	b29b      	uxth	r3, r3
 8011b1c:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011b1e:	e038      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_RIGHT_TOP:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8011b20:	68b8      	ldr	r0, [r7, #8]
 8011b22:	f000 fb37 	bl	8012194 <lv_obj_get_width>
 8011b26:	4603      	mov	r3, r0
 8011b28:	b29a      	uxth	r2, r3
 8011b2a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011b2c:	1ad3      	subs	r3, r2, r3
 8011b2e:	b29b      	uxth	r3, r3
 8011b30:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = -obj_h_half;
 8011b32:	8c3b      	ldrh	r3, [r7, #32]
 8011b34:	425b      	negs	r3, r3
 8011b36:	b29b      	uxth	r3, r3
 8011b38:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011b3a:	e02a      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_RIGHT_MID:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8011b3c:	68b8      	ldr	r0, [r7, #8]
 8011b3e:	f000 fb29 	bl	8012194 <lv_obj_get_width>
 8011b42:	4603      	mov	r3, r0
 8011b44:	b29a      	uxth	r2, r3
 8011b46:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011b48:	1ad3      	subs	r3, r2, r3
 8011b4a:	b29b      	uxth	r3, r3
 8011b4c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) / 2 - obj_h_half;
 8011b4e:	68b8      	ldr	r0, [r7, #8]
 8011b50:	f000 fb2e 	bl	80121b0 <lv_obj_get_height>
 8011b54:	4603      	mov	r3, r0
 8011b56:	2b00      	cmp	r3, #0
 8011b58:	da00      	bge.n	8011b5c <lv_obj_align_origo+0x36c>
 8011b5a:	3301      	adds	r3, #1
 8011b5c:	105b      	asrs	r3, r3, #1
 8011b5e:	b21b      	sxth	r3, r3
 8011b60:	b29a      	uxth	r2, r3
 8011b62:	8c3b      	ldrh	r3, [r7, #32]
 8011b64:	1ad3      	subs	r3, r2, r3
 8011b66:	b29b      	uxth	r3, r3
 8011b68:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011b6a:	e012      	b.n	8011b92 <lv_obj_align_origo+0x3a2>

        case LV_ALIGN_OUT_RIGHT_BOTTOM:
            new_x = lv_obj_get_width(base) - obj_w_half;
 8011b6c:	68b8      	ldr	r0, [r7, #8]
 8011b6e:	f000 fb11 	bl	8012194 <lv_obj_get_width>
 8011b72:	4603      	mov	r3, r0
 8011b74:	b29a      	uxth	r2, r3
 8011b76:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8011b78:	1ad3      	subs	r3, r2, r3
 8011b7a:	b29b      	uxth	r3, r3
 8011b7c:	84fb      	strh	r3, [r7, #38]	; 0x26
            new_y = lv_obj_get_height(base) - obj_h_half;
 8011b7e:	68b8      	ldr	r0, [r7, #8]
 8011b80:	f000 fb16 	bl	80121b0 <lv_obj_get_height>
 8011b84:	4603      	mov	r3, r0
 8011b86:	b29a      	uxth	r2, r3
 8011b88:	8c3b      	ldrh	r3, [r7, #32]
 8011b8a:	1ad3      	subs	r3, r2, r3
 8011b8c:	b29b      	uxth	r3, r3
 8011b8e:	84bb      	strh	r3, [r7, #36]	; 0x24
            break;
 8011b90:	bf00      	nop
    }

    /*Bring together the coordination system of base and obj*/
    lv_obj_t * par        = lv_obj_get_parent(obj);
 8011b92:	68f8      	ldr	r0, [r7, #12]
 8011b94:	f000 fa94 	bl	80120c0 <lv_obj_get_parent>
 8011b98:	61f8      	str	r0, [r7, #28]
    lv_coord_t base_abs_x = base->coords.x1;
 8011b9a:	68bb      	ldr	r3, [r7, #8]
 8011b9c:	8a1b      	ldrh	r3, [r3, #16]
 8011b9e:	837b      	strh	r3, [r7, #26]
    lv_coord_t base_abs_y = base->coords.y1;
 8011ba0:	68bb      	ldr	r3, [r7, #8]
 8011ba2:	8a5b      	ldrh	r3, [r3, #18]
 8011ba4:	833b      	strh	r3, [r7, #24]
    lv_coord_t par_abs_x  = par->coords.x1;
 8011ba6:	69fb      	ldr	r3, [r7, #28]
 8011ba8:	8a1b      	ldrh	r3, [r3, #16]
 8011baa:	82fb      	strh	r3, [r7, #22]
    lv_coord_t par_abs_y  = par->coords.y1;
 8011bac:	69fb      	ldr	r3, [r7, #28]
 8011bae:	8a5b      	ldrh	r3, [r3, #18]
 8011bb0:	82bb      	strh	r3, [r7, #20]
    new_x += x_mod + base_abs_x;
 8011bb2:	88ba      	ldrh	r2, [r7, #4]
 8011bb4:	8b7b      	ldrh	r3, [r7, #26]
 8011bb6:	4413      	add	r3, r2
 8011bb8:	b29a      	uxth	r2, r3
 8011bba:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8011bbc:	4413      	add	r3, r2
 8011bbe:	b29b      	uxth	r3, r3
 8011bc0:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y += y_mod + base_abs_y;
 8011bc2:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8011bc4:	8b3b      	ldrh	r3, [r7, #24]
 8011bc6:	4413      	add	r3, r2
 8011bc8:	b29a      	uxth	r2, r3
 8011bca:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8011bcc:	4413      	add	r3, r2
 8011bce:	b29b      	uxth	r3, r3
 8011bd0:	84bb      	strh	r3, [r7, #36]	; 0x24
    new_x -= par_abs_x;
 8011bd2:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8011bd4:	8afb      	ldrh	r3, [r7, #22]
 8011bd6:	1ad3      	subs	r3, r2, r3
 8011bd8:	b29b      	uxth	r3, r3
 8011bda:	84fb      	strh	r3, [r7, #38]	; 0x26
    new_y -= par_abs_y;
 8011bdc:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8011bde:	8abb      	ldrh	r3, [r7, #20]
 8011be0:	1ad3      	subs	r3, r2, r3
 8011be2:	b29b      	uxth	r3, r3
 8011be4:	84bb      	strh	r3, [r7, #36]	; 0x24

    lv_obj_set_pos(obj, new_x, new_y);
 8011be6:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8011bea:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8011bee:	4619      	mov	r1, r3
 8011bf0:	68f8      	ldr	r0, [r7, #12]
 8011bf2:	f7ff fa2d 	bl	8011050 <lv_obj_set_pos>

#if LV_USE_OBJ_REALIGN
    /*Save the last align parameters to use them in `lv_obj_realign`*/
    obj->realign.align       = align;
 8011bf6:	68fb      	ldr	r3, [r7, #12]
 8011bf8:	79fa      	ldrb	r2, [r7, #7]
 8011bfa:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    obj->realign.xofs        = x_mod;
 8011bfe:	68fb      	ldr	r3, [r7, #12]
 8011c00:	88ba      	ldrh	r2, [r7, #4]
 8011c02:	879a      	strh	r2, [r3, #60]	; 0x3c
    obj->realign.yofs        = y_mod;
 8011c04:	68fb      	ldr	r3, [r7, #12]
 8011c06:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8011c08:	87da      	strh	r2, [r3, #62]	; 0x3e
    obj->realign.base        = base;
 8011c0a:	68fb      	ldr	r3, [r7, #12]
 8011c0c:	68ba      	ldr	r2, [r7, #8]
 8011c0e:	639a      	str	r2, [r3, #56]	; 0x38
    obj->realign.origo_align = 1;
 8011c10:	68fa      	ldr	r2, [r7, #12]
 8011c12:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8011c16:	f043 0302 	orr.w	r3, r3, #2
 8011c1a:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#endif
}
 8011c1e:	bf00      	nop
 8011c20:	3728      	adds	r7, #40	; 0x28
 8011c22:	46bd      	mov	sp, r7
 8011c24:	bd80      	pop	{r7, pc}
 8011c26:	bf00      	nop

08011c28 <lv_obj_realign>:
/**
 * Realign the object based on the last `lv_obj_align` parameters.
 * @param obj pointer to an object
 */
void lv_obj_realign(lv_obj_t * obj)
{
 8011c28:	b580      	push	{r7, lr}
 8011c2a:	b084      	sub	sp, #16
 8011c2c:	af02      	add	r7, sp, #8
 8011c2e:	6078      	str	r0, [r7, #4]
#if LV_USE_OBJ_REALIGN
    if(obj->realign.origo_align)
 8011c30:	687b      	ldr	r3, [r7, #4]
 8011c32:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8011c36:	f003 0302 	and.w	r3, r3, #2
 8011c3a:	b2db      	uxtb	r3, r3
 8011c3c:	2b00      	cmp	r3, #0
 8011c3e:	d010      	beq.n	8011c62 <lv_obj_realign+0x3a>
        lv_obj_align_origo(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 8011c40:	687b      	ldr	r3, [r7, #4]
 8011c42:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8011c44:	687b      	ldr	r3, [r7, #4]
 8011c46:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8011c4a:	687b      	ldr	r3, [r7, #4]
 8011c4c:	f9b3 003c 	ldrsh.w	r0, [r3, #60]	; 0x3c
 8011c50:	687b      	ldr	r3, [r7, #4]
 8011c52:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8011c56:	9300      	str	r3, [sp, #0]
 8011c58:	4603      	mov	r3, r0
 8011c5a:	6878      	ldr	r0, [r7, #4]
 8011c5c:	f7ff fdc8 	bl	80117f0 <lv_obj_align_origo>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
#else
    (void)obj;
    LV_LOG_WARN("lv_obj_realaign: no effect because LV_USE_OBJ_REALIGN = 0");
#endif
}
 8011c60:	e00f      	b.n	8011c82 <lv_obj_realign+0x5a>
        lv_obj_align(obj, obj->realign.base, obj->realign.align, obj->realign.xofs, obj->realign.yofs);
 8011c62:	687b      	ldr	r3, [r7, #4]
 8011c64:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8011c66:	687b      	ldr	r3, [r7, #4]
 8011c68:	f893 2040 	ldrb.w	r2, [r3, #64]	; 0x40
 8011c6c:	687b      	ldr	r3, [r7, #4]
 8011c6e:	f9b3 003c 	ldrsh.w	r0, [r3, #60]	; 0x3c
 8011c72:	687b      	ldr	r3, [r7, #4]
 8011c74:	f9b3 303e 	ldrsh.w	r3, [r3, #62]	; 0x3e
 8011c78:	9300      	str	r3, [sp, #0]
 8011c7a:	4603      	mov	r3, r0
 8011c7c:	6878      	ldr	r0, [r7, #4]
 8011c7e:	f7ff fb3f 	bl	8011300 <lv_obj_align>
}
 8011c82:	bf00      	nop
 8011c84:	3708      	adds	r7, #8
 8011c86:	46bd      	mov	sp, r7
 8011c88:	bd80      	pop	{r7, pc}

08011c8a <lv_obj_set_auto_realign>:
 * `lv_obj_align` parameters.
 * @param obj pointer to an object
 * @param en true: enable auto realign; false: disable auto realign
 */
void lv_obj_set_auto_realign(lv_obj_t * obj, bool en)
{
 8011c8a:	b480      	push	{r7}
 8011c8c:	b083      	sub	sp, #12
 8011c8e:	af00      	add	r7, sp, #0
 8011c90:	6078      	str	r0, [r7, #4]
 8011c92:	460b      	mov	r3, r1
 8011c94:	70fb      	strb	r3, [r7, #3]
#if LV_USE_OBJ_REALIGN
    obj->realign.auto_realign = en ? 1 : 0;
 8011c96:	78f9      	ldrb	r1, [r7, #3]
 8011c98:	687a      	ldr	r2, [r7, #4]
 8011c9a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8011c9e:	f361 0300 	bfi	r3, r1, #0, #1
 8011ca2:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
#else
    (void)obj;
    (void)en;
    LV_LOG_WARN("lv_obj_set_auto_realign: no effect because LV_USE_OBJ_REALIGN = 0");
#endif
}
 8011ca6:	bf00      	nop
 8011ca8:	370c      	adds	r7, #12
 8011caa:	46bd      	mov	sp, r7
 8011cac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011cb0:	4770      	bx	lr

08011cb2 <lv_obj_set_style>:
 * Set a new style for an object
 * @param obj pointer to an object
 * @param style_p pointer to the new style
 */
void lv_obj_set_style(lv_obj_t * obj, const lv_style_t * style)
{
 8011cb2:	b580      	push	{r7, lr}
 8011cb4:	b082      	sub	sp, #8
 8011cb6:	af00      	add	r7, sp, #0
 8011cb8:	6078      	str	r0, [r7, #4]
 8011cba:	6039      	str	r1, [r7, #0]
    obj->style_p = style;
 8011cbc:	687b      	ldr	r3, [r7, #4]
 8011cbe:	683a      	ldr	r2, [r7, #0]
 8011cc0:	629a      	str	r2, [r3, #40]	; 0x28

    /*Send a signal about style change to every children with NULL style*/
    refresh_children_style(obj);
 8011cc2:	6878      	ldr	r0, [r7, #4]
 8011cc4:	f000 fd2d 	bl	8012722 <refresh_children_style>

    /*Notify the object about the style change too*/
    lv_obj_refresh_style(obj);
 8011cc8:	6878      	ldr	r0, [r7, #4]
 8011cca:	f000 f804 	bl	8011cd6 <lv_obj_refresh_style>
}
 8011cce:	bf00      	nop
 8011cd0:	3708      	adds	r7, #8
 8011cd2:	46bd      	mov	sp, r7
 8011cd4:	bd80      	pop	{r7, pc}

08011cd6 <lv_obj_refresh_style>:
/**
 * Notify an object about its style is modified
 * @param obj pointer to an object
 */
void lv_obj_refresh_style(lv_obj_t * obj)
{
 8011cd6:	b580      	push	{r7, lr}
 8011cd8:	b082      	sub	sp, #8
 8011cda:	af00      	add	r7, sp, #0
 8011cdc:	6078      	str	r0, [r7, #4]
    lv_obj_invalidate(obj);
 8011cde:	6878      	ldr	r0, [r7, #4]
 8011ce0:	f7ff f8a5 	bl	8010e2e <lv_obj_invalidate>
    obj->signal_cb(obj, LV_SIGNAL_STYLE_CHG, NULL);
 8011ce4:	687b      	ldr	r3, [r7, #4]
 8011ce6:	69db      	ldr	r3, [r3, #28]
 8011ce8:	2200      	movs	r2, #0
 8011cea:	2104      	movs	r1, #4
 8011cec:	6878      	ldr	r0, [r7, #4]
 8011cee:	4798      	blx	r3
    lv_obj_invalidate(obj);
 8011cf0:	6878      	ldr	r0, [r7, #4]
 8011cf2:	f7ff f89c 	bl	8010e2e <lv_obj_invalidate>
}
 8011cf6:	bf00      	nop
 8011cf8:	3708      	adds	r7, #8
 8011cfa:	46bd      	mov	sp, r7
 8011cfc:	bd80      	pop	{r7, pc}

08011cfe <lv_obj_report_style_mod>:
 * Notify all object if a style is modified
 * @param style pointer to a style. Only the objects with this style will be notified
 *               (NULL to notify all objects)
 */
void lv_obj_report_style_mod(lv_style_t * style)
{
 8011cfe:	b580      	push	{r7, lr}
 8011d00:	b084      	sub	sp, #16
 8011d02:	af00      	add	r7, sp, #0
 8011d04:	6078      	str	r0, [r7, #4]
    lv_disp_t * d = lv_disp_get_next(NULL);
 8011d06:	2000      	movs	r0, #0
 8011d08:	f009 fa5c 	bl	801b1c4 <lv_disp_get_next>
 8011d0c:	60f8      	str	r0, [r7, #12]

    while(d) {
 8011d0e:	e023      	b.n	8011d58 <lv_obj_report_style_mod+0x5a>
        lv_obj_t * i;
        LV_LL_READ(d->scr_ll, i)
 8011d10:	68fb      	ldr	r3, [r7, #12]
 8011d12:	3330      	adds	r3, #48	; 0x30
 8011d14:	4618      	mov	r0, r3
 8011d16:	f00a fc71 	bl	801c5fc <lv_ll_get_head>
 8011d1a:	60b8      	str	r0, [r7, #8]
 8011d1c:	e015      	b.n	8011d4a <lv_obj_report_style_mod+0x4c>
        {
            if(i->style_p == style || style == NULL) {
 8011d1e:	68bb      	ldr	r3, [r7, #8]
 8011d20:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8011d22:	687a      	ldr	r2, [r7, #4]
 8011d24:	429a      	cmp	r2, r3
 8011d26:	d002      	beq.n	8011d2e <lv_obj_report_style_mod+0x30>
 8011d28:	687b      	ldr	r3, [r7, #4]
 8011d2a:	2b00      	cmp	r3, #0
 8011d2c:	d102      	bne.n	8011d34 <lv_obj_report_style_mod+0x36>
                lv_obj_refresh_style(i);
 8011d2e:	68b8      	ldr	r0, [r7, #8]
 8011d30:	f7ff ffd1 	bl	8011cd6 <lv_obj_refresh_style>
            }

            report_style_mod_core(style, i);
 8011d34:	68b9      	ldr	r1, [r7, #8]
 8011d36:	6878      	ldr	r0, [r7, #4]
 8011d38:	f000 fcc7 	bl	80126ca <report_style_mod_core>
        LV_LL_READ(d->scr_ll, i)
 8011d3c:	68fb      	ldr	r3, [r7, #12]
 8011d3e:	3330      	adds	r3, #48	; 0x30
 8011d40:	68b9      	ldr	r1, [r7, #8]
 8011d42:	4618      	mov	r0, r3
 8011d44:	f00a fc80 	bl	801c648 <lv_ll_get_next>
 8011d48:	60b8      	str	r0, [r7, #8]
 8011d4a:	68bb      	ldr	r3, [r7, #8]
 8011d4c:	2b00      	cmp	r3, #0
 8011d4e:	d1e6      	bne.n	8011d1e <lv_obj_report_style_mod+0x20>
        }
        d = lv_disp_get_next(d);
 8011d50:	68f8      	ldr	r0, [r7, #12]
 8011d52:	f009 fa37 	bl	801b1c4 <lv_disp_get_next>
 8011d56:	60f8      	str	r0, [r7, #12]
    while(d) {
 8011d58:	68fb      	ldr	r3, [r7, #12]
 8011d5a:	2b00      	cmp	r3, #0
 8011d5c:	d1d8      	bne.n	8011d10 <lv_obj_report_style_mod+0x12>
    }
}
 8011d5e:	bf00      	nop
 8011d60:	3710      	adds	r7, #16
 8011d62:	46bd      	mov	sp, r7
 8011d64:	bd80      	pop	{r7, pc}

08011d66 <lv_obj_set_click>:
 * Enable or disable the clicking of an object
 * @param obj pointer to an object
 * @param en true: make the object clickable
 */
void lv_obj_set_click(lv_obj_t * obj, bool en)
{
 8011d66:	b480      	push	{r7}
 8011d68:	b083      	sub	sp, #12
 8011d6a:	af00      	add	r7, sp, #0
 8011d6c:	6078      	str	r0, [r7, #4]
 8011d6e:	460b      	mov	r3, r1
 8011d70:	70fb      	strb	r3, [r7, #3]
    obj->click = (en == true ? 1 : 0);
 8011d72:	78f9      	ldrb	r1, [r7, #3]
 8011d74:	687a      	ldr	r2, [r7, #4]
 8011d76:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8011d7a:	f361 0300 	bfi	r3, r1, #0, #1
 8011d7e:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
}
 8011d82:	bf00      	nop
 8011d84:	370c      	adds	r7, #12
 8011d86:	46bd      	mov	sp, r7
 8011d88:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011d8c:	4770      	bx	lr

08011d8e <lv_obj_set_drag>:
 * Enable the dragging of an object
 * @param obj pointer to an object
 * @param en true: make the object dragable
 */
void lv_obj_set_drag(lv_obj_t * obj, bool en)
{
 8011d8e:	b580      	push	{r7, lr}
 8011d90:	b082      	sub	sp, #8
 8011d92:	af00      	add	r7, sp, #0
 8011d94:	6078      	str	r0, [r7, #4]
 8011d96:	460b      	mov	r3, r1
 8011d98:	70fb      	strb	r3, [r7, #3]
    if(en == true) lv_obj_set_click(obj, true); /*Drag is useless without enabled clicking*/
 8011d9a:	78fb      	ldrb	r3, [r7, #3]
 8011d9c:	2b00      	cmp	r3, #0
 8011d9e:	d003      	beq.n	8011da8 <lv_obj_set_drag+0x1a>
 8011da0:	2101      	movs	r1, #1
 8011da2:	6878      	ldr	r0, [r7, #4]
 8011da4:	f7ff ffdf 	bl	8011d66 <lv_obj_set_click>
    obj->drag = (en == true ? 1 : 0);
 8011da8:	78f9      	ldrb	r1, [r7, #3]
 8011daa:	687a      	ldr	r2, [r7, #4]
 8011dac:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8011db0:	f361 0341 	bfi	r3, r1, #1, #1
 8011db4:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
}
 8011db8:	bf00      	nop
 8011dba:	3708      	adds	r7, #8
 8011dbc:	46bd      	mov	sp, r7
 8011dbe:	bd80      	pop	{r7, pc}

08011dc0 <lv_obj_set_drag_throw>:
 * Enable the throwing of an object after is is dragged
 * @param obj pointer to an object
 * @param en true: enable the drag throw
 */
void lv_obj_set_drag_throw(lv_obj_t * obj, bool en)
{
 8011dc0:	b480      	push	{r7}
 8011dc2:	b083      	sub	sp, #12
 8011dc4:	af00      	add	r7, sp, #0
 8011dc6:	6078      	str	r0, [r7, #4]
 8011dc8:	460b      	mov	r3, r1
 8011dca:	70fb      	strb	r3, [r7, #3]
    obj->drag_throw = (en == true ? 1 : 0);
 8011dcc:	78f9      	ldrb	r1, [r7, #3]
 8011dce:	687a      	ldr	r2, [r7, #4]
 8011dd0:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
 8011dd4:	f361 0382 	bfi	r3, r1, #2, #1
 8011dd8:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
}
 8011ddc:	bf00      	nop
 8011dde:	370c      	adds	r7, #12
 8011de0:	46bd      	mov	sp, r7
 8011de2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011de6:	4770      	bx	lr

08011de8 <lv_obj_set_protect>:
 * Set a bit or bits in the protect filed
 * @param obj pointer to an object
 * @param prot 'OR'-ed values from `lv_protect_t`
 */
void lv_obj_set_protect(lv_obj_t * obj, uint8_t prot)
{
 8011de8:	b480      	push	{r7}
 8011dea:	b083      	sub	sp, #12
 8011dec:	af00      	add	r7, sp, #0
 8011dee:	6078      	str	r0, [r7, #4]
 8011df0:	460b      	mov	r3, r1
 8011df2:	70fb      	strb	r3, [r7, #3]
    obj->protect |= prot;
 8011df4:	687b      	ldr	r3, [r7, #4]
 8011df6:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8011dfa:	78fb      	ldrb	r3, [r7, #3]
 8011dfc:	4313      	orrs	r3, r2
 8011dfe:	b2da      	uxtb	r2, r3
 8011e00:	687b      	ldr	r3, [r7, #4]
 8011e02:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
 8011e06:	bf00      	nop
 8011e08:	370c      	adds	r7, #12
 8011e0a:	46bd      	mov	sp, r7
 8011e0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e10:	4770      	bx	lr

08011e12 <lv_obj_clear_protect>:
 * Clear a bit or bits in the protect filed
 * @param obj pointer to an object
 * @param prot 'OR'-ed values from `lv_protect_t`
 */
void lv_obj_clear_protect(lv_obj_t * obj, uint8_t prot)
{
 8011e12:	b480      	push	{r7}
 8011e14:	b083      	sub	sp, #12
 8011e16:	af00      	add	r7, sp, #0
 8011e18:	6078      	str	r0, [r7, #4]
 8011e1a:	460b      	mov	r3, r1
 8011e1c:	70fb      	strb	r3, [r7, #3]
    prot = (~prot) & 0xFF;
 8011e1e:	78fb      	ldrb	r3, [r7, #3]
 8011e20:	43db      	mvns	r3, r3
 8011e22:	70fb      	strb	r3, [r7, #3]
    obj->protect &= prot;
 8011e24:	687b      	ldr	r3, [r7, #4]
 8011e26:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8011e2a:	78fb      	ldrb	r3, [r7, #3]
 8011e2c:	4013      	ands	r3, r2
 8011e2e:	b2da      	uxtb	r2, r3
 8011e30:	687b      	ldr	r3, [r7, #4]
 8011e32:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
 8011e36:	bf00      	nop
 8011e38:	370c      	adds	r7, #12
 8011e3a:	46bd      	mov	sp, r7
 8011e3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e40:	4770      	bx	lr

08011e42 <lv_obj_set_event_cb>:
 * Used by the user to react on event which happens with the object.
 * @param obj pointer to an object
 * @param event_cb the new event function
 */
void lv_obj_set_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb)
{
 8011e42:	b480      	push	{r7}
 8011e44:	b083      	sub	sp, #12
 8011e46:	af00      	add	r7, sp, #0
 8011e48:	6078      	str	r0, [r7, #4]
 8011e4a:	6039      	str	r1, [r7, #0]
    obj->event_cb = event_cb;
 8011e4c:	687b      	ldr	r3, [r7, #4]
 8011e4e:	683a      	ldr	r2, [r7, #0]
 8011e50:	619a      	str	r2, [r3, #24]
}
 8011e52:	bf00      	nop
 8011e54:	370c      	adds	r7, #12
 8011e56:	46bd      	mov	sp, r7
 8011e58:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011e5c:	4770      	bx	lr

08011e5e <lv_event_send>:
 * @param event the type of the event from `lv_event_t`
 * @param data arbitrary data depending on the object type and the event. (Usually `NULL`)
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send(lv_obj_t * obj, lv_event_t event, const void * data)
{
 8011e5e:	b580      	push	{r7, lr}
 8011e60:	b086      	sub	sp, #24
 8011e62:	af00      	add	r7, sp, #0
 8011e64:	60f8      	str	r0, [r7, #12]
 8011e66:	460b      	mov	r3, r1
 8011e68:	607a      	str	r2, [r7, #4]
 8011e6a:	72fb      	strb	r3, [r7, #11]
    if(obj == NULL) return LV_RES_OK;
 8011e6c:	68fb      	ldr	r3, [r7, #12]
 8011e6e:	2b00      	cmp	r3, #0
 8011e70:	d101      	bne.n	8011e76 <lv_event_send+0x18>
 8011e72:	2301      	movs	r3, #1
 8011e74:	e009      	b.n	8011e8a <lv_event_send+0x2c>

    lv_res_t res;
    res = lv_event_send_func(obj->event_cb, obj, event, data);
 8011e76:	68fb      	ldr	r3, [r7, #12]
 8011e78:	6998      	ldr	r0, [r3, #24]
 8011e7a:	7afa      	ldrb	r2, [r7, #11]
 8011e7c:	687b      	ldr	r3, [r7, #4]
 8011e7e:	68f9      	ldr	r1, [r7, #12]
 8011e80:	f000 f808 	bl	8011e94 <lv_event_send_func>
 8011e84:	4603      	mov	r3, r0
 8011e86:	75fb      	strb	r3, [r7, #23]
    return res;
 8011e88:	7dfb      	ldrb	r3, [r7, #23]
}
 8011e8a:	4618      	mov	r0, r3
 8011e8c:	3718      	adds	r7, #24
 8011e8e:	46bd      	mov	sp, r7
 8011e90:	bd80      	pop	{r7, pc}
	...

08011e94 <lv_event_send_func>:
 * @param event an event
 * @param data pointer to a custom data
 * @return LV_RES_OK: `obj` was not deleted in the event; LV_RES_INV: `obj` was deleted in the event
 */
lv_res_t lv_event_send_func(lv_event_cb_t event_xcb, lv_obj_t * obj, lv_event_t event, const void * data)
{
 8011e94:	b580      	push	{r7, lr}
 8011e96:	b08a      	sub	sp, #40	; 0x28
 8011e98:	af00      	add	r7, sp, #0
 8011e9a:	60f8      	str	r0, [r7, #12]
 8011e9c:	60b9      	str	r1, [r7, #8]
 8011e9e:	603b      	str	r3, [r7, #0]
 8011ea0:	4613      	mov	r3, r2
 8011ea2:	71fb      	strb	r3, [r7, #7]
    /* Build a simple linked list from the objects used in the events
     * It's important to know if an this object was deleted by a nested event
     * called from this `even_cb`. */
    lv_event_temp_data_t event_temp_data;
    event_temp_data.obj     = obj;
 8011ea4:	68bb      	ldr	r3, [r7, #8]
 8011ea6:	613b      	str	r3, [r7, #16]
    event_temp_data.deleted = false;
 8011ea8:	2300      	movs	r3, #0
 8011eaa:	753b      	strb	r3, [r7, #20]
    event_temp_data.prev    = NULL;
 8011eac:	2300      	movs	r3, #0
 8011eae:	61bb      	str	r3, [r7, #24]

    if(event_temp_data_head) {
 8011eb0:	4b2b      	ldr	r3, [pc, #172]	; (8011f60 <lv_event_send_func+0xcc>)
 8011eb2:	681b      	ldr	r3, [r3, #0]
 8011eb4:	2b00      	cmp	r3, #0
 8011eb6:	d002      	beq.n	8011ebe <lv_event_send_func+0x2a>
        event_temp_data.prev = event_temp_data_head;
 8011eb8:	4b29      	ldr	r3, [pc, #164]	; (8011f60 <lv_event_send_func+0xcc>)
 8011eba:	681b      	ldr	r3, [r3, #0]
 8011ebc:	61bb      	str	r3, [r7, #24]
    }
    event_temp_data_head = &event_temp_data;
 8011ebe:	4a28      	ldr	r2, [pc, #160]	; (8011f60 <lv_event_send_func+0xcc>)
 8011ec0:	f107 0310 	add.w	r3, r7, #16
 8011ec4:	6013      	str	r3, [r2, #0]

    const void * event_act_data_save = event_act_data;
 8011ec6:	4b27      	ldr	r3, [pc, #156]	; (8011f64 <lv_event_send_func+0xd0>)
 8011ec8:	681b      	ldr	r3, [r3, #0]
 8011eca:	627b      	str	r3, [r7, #36]	; 0x24
    event_act_data                   = data;
 8011ecc:	4a25      	ldr	r2, [pc, #148]	; (8011f64 <lv_event_send_func+0xd0>)
 8011ece:	683b      	ldr	r3, [r7, #0]
 8011ed0:	6013      	str	r3, [r2, #0]

    /*Call the input device's feedback callback if set*/
    lv_indev_t * indev_act = lv_indev_get_act();
 8011ed2:	f7fc fe41 	bl	800eb58 <lv_indev_get_act>
 8011ed6:	6238      	str	r0, [r7, #32]
    if(indev_act) {
 8011ed8:	6a3b      	ldr	r3, [r7, #32]
 8011eda:	2b00      	cmp	r3, #0
 8011edc:	d009      	beq.n	8011ef2 <lv_event_send_func+0x5e>
        if(indev_act->driver.feedback_cb) indev_act->driver.feedback_cb(&indev_act->driver, event);
 8011ede:	6a3b      	ldr	r3, [r7, #32]
 8011ee0:	689b      	ldr	r3, [r3, #8]
 8011ee2:	2b00      	cmp	r3, #0
 8011ee4:	d005      	beq.n	8011ef2 <lv_event_send_func+0x5e>
 8011ee6:	6a3b      	ldr	r3, [r7, #32]
 8011ee8:	689b      	ldr	r3, [r3, #8]
 8011eea:	6a3a      	ldr	r2, [r7, #32]
 8011eec:	79f9      	ldrb	r1, [r7, #7]
 8011eee:	4610      	mov	r0, r2
 8011ef0:	4798      	blx	r3
    }

    /*Call the event callback itself*/
    if(event_xcb) event_xcb(obj, event);
 8011ef2:	68fb      	ldr	r3, [r7, #12]
 8011ef4:	2b00      	cmp	r3, #0
 8011ef6:	d004      	beq.n	8011f02 <lv_event_send_func+0x6e>
 8011ef8:	79fa      	ldrb	r2, [r7, #7]
 8011efa:	68fb      	ldr	r3, [r7, #12]
 8011efc:	4611      	mov	r1, r2
 8011efe:	68b8      	ldr	r0, [r7, #8]
 8011f00:	4798      	blx	r3

    /*Restore the event data*/
    event_act_data = event_act_data_save;
 8011f02:	4a18      	ldr	r2, [pc, #96]	; (8011f64 <lv_event_send_func+0xd0>)
 8011f04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011f06:	6013      	str	r3, [r2, #0]

    /*Remove this element from the list*/
    event_temp_data_head = event_temp_data_head->prev;
 8011f08:	4b15      	ldr	r3, [pc, #84]	; (8011f60 <lv_event_send_func+0xcc>)
 8011f0a:	681b      	ldr	r3, [r3, #0]
 8011f0c:	689b      	ldr	r3, [r3, #8]
 8011f0e:	4a14      	ldr	r2, [pc, #80]	; (8011f60 <lv_event_send_func+0xcc>)
 8011f10:	6013      	str	r3, [r2, #0]

    if(event_temp_data.deleted) {
 8011f12:	7d3b      	ldrb	r3, [r7, #20]
 8011f14:	2b00      	cmp	r3, #0
 8011f16:	d001      	beq.n	8011f1c <lv_event_send_func+0x88>
        return LV_RES_INV;
 8011f18:	2300      	movs	r3, #0
 8011f1a:	e01d      	b.n	8011f58 <lv_event_send_func+0xc4>
    }

    if(obj) {
 8011f1c:	68bb      	ldr	r3, [r7, #8]
 8011f1e:	2b00      	cmp	r3, #0
 8011f20:	d019      	beq.n	8011f56 <lv_event_send_func+0xc2>
        if(obj->parent_event && obj->par) {
 8011f22:	68bb      	ldr	r3, [r7, #8]
 8011f24:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8011f28:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8011f2c:	b2db      	uxtb	r3, r3
 8011f2e:	2b00      	cmp	r3, #0
 8011f30:	d011      	beq.n	8011f56 <lv_event_send_func+0xc2>
 8011f32:	68bb      	ldr	r3, [r7, #8]
 8011f34:	681b      	ldr	r3, [r3, #0]
 8011f36:	2b00      	cmp	r3, #0
 8011f38:	d00d      	beq.n	8011f56 <lv_event_send_func+0xc2>
            lv_res_t res = lv_event_send(obj->par, event, data);
 8011f3a:	68bb      	ldr	r3, [r7, #8]
 8011f3c:	681b      	ldr	r3, [r3, #0]
 8011f3e:	79f9      	ldrb	r1, [r7, #7]
 8011f40:	683a      	ldr	r2, [r7, #0]
 8011f42:	4618      	mov	r0, r3
 8011f44:	f7ff ff8b 	bl	8011e5e <lv_event_send>
 8011f48:	4603      	mov	r3, r0
 8011f4a:	77fb      	strb	r3, [r7, #31]
            if(res != LV_RES_OK) {
 8011f4c:	7ffb      	ldrb	r3, [r7, #31]
 8011f4e:	2b01      	cmp	r3, #1
 8011f50:	d001      	beq.n	8011f56 <lv_event_send_func+0xc2>
                return LV_RES_INV;
 8011f52:	2300      	movs	r3, #0
 8011f54:	e000      	b.n	8011f58 <lv_event_send_func+0xc4>
            }
        }
    }

    return LV_RES_OK;
 8011f56:	2301      	movs	r3, #1
}
 8011f58:	4618      	mov	r0, r3
 8011f5a:	3728      	adds	r7, #40	; 0x28
 8011f5c:	46bd      	mov	sp, r7
 8011f5e:	bd80      	pop	{r7, pc}
 8011f60:	20003fa0 	.word	0x20003fa0
 8011f64:	20003fa4 	.word	0x20003fa4

08011f68 <lv_event_get_data>:
/**
 * Get the `data` parameter of the current event
 * @return the `data` parameter
 */
const void * lv_event_get_data(void)
{
 8011f68:	b480      	push	{r7}
 8011f6a:	af00      	add	r7, sp, #0
    return event_act_data;
 8011f6c:	4b03      	ldr	r3, [pc, #12]	; (8011f7c <lv_event_get_data+0x14>)
 8011f6e:	681b      	ldr	r3, [r3, #0]
}
 8011f70:	4618      	mov	r0, r3
 8011f72:	46bd      	mov	sp, r7
 8011f74:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f78:	4770      	bx	lr
 8011f7a:	bf00      	nop
 8011f7c:	20003fa4 	.word	0x20003fa4

08011f80 <lv_obj_set_signal_cb>:
 * Always call the previous signal function in the new.
 * @param obj pointer to an object
 * @param cb the new signal function
 */
void lv_obj_set_signal_cb(lv_obj_t * obj, lv_signal_cb_t signal_cb)
{
 8011f80:	b480      	push	{r7}
 8011f82:	b083      	sub	sp, #12
 8011f84:	af00      	add	r7, sp, #0
 8011f86:	6078      	str	r0, [r7, #4]
 8011f88:	6039      	str	r1, [r7, #0]
    obj->signal_cb = signal_cb;
 8011f8a:	687b      	ldr	r3, [r7, #4]
 8011f8c:	683a      	ldr	r2, [r7, #0]
 8011f8e:	61da      	str	r2, [r3, #28]
}
 8011f90:	bf00      	nop
 8011f92:	370c      	adds	r7, #12
 8011f94:	46bd      	mov	sp, r7
 8011f96:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011f9a:	4770      	bx	lr

08011f9c <lv_obj_set_design_cb>:
 * Set a new design function for an object
 * @param obj pointer to an object
 * @param design_cb the new design function
 */
void lv_obj_set_design_cb(lv_obj_t * obj, lv_design_cb_t design_cb)
{
 8011f9c:	b480      	push	{r7}
 8011f9e:	b083      	sub	sp, #12
 8011fa0:	af00      	add	r7, sp, #0
 8011fa2:	6078      	str	r0, [r7, #4]
 8011fa4:	6039      	str	r1, [r7, #0]
    obj->design_cb = design_cb;
 8011fa6:	687b      	ldr	r3, [r7, #4]
 8011fa8:	683a      	ldr	r2, [r7, #0]
 8011faa:	621a      	str	r2, [r3, #32]
}
 8011fac:	bf00      	nop
 8011fae:	370c      	adds	r7, #12
 8011fb0:	46bd      	mov	sp, r7
 8011fb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011fb6:	4770      	bx	lr

08011fb8 <lv_obj_allocate_ext_attr>:
 * @param obj pointer to an object
 * @param ext_size the size of the new ext. data
 * @return Normal pointer to the allocated ext
 */
void * lv_obj_allocate_ext_attr(lv_obj_t * obj, uint16_t ext_size)
{
 8011fb8:	b580      	push	{r7, lr}
 8011fba:	b082      	sub	sp, #8
 8011fbc:	af00      	add	r7, sp, #0
 8011fbe:	6078      	str	r0, [r7, #4]
 8011fc0:	460b      	mov	r3, r1
 8011fc2:	807b      	strh	r3, [r7, #2]
    obj->ext_attr = lv_mem_realloc(obj->ext_attr, ext_size);
 8011fc4:	687b      	ldr	r3, [r7, #4]
 8011fc6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011fc8:	887a      	ldrh	r2, [r7, #2]
 8011fca:	4611      	mov	r1, r2
 8011fcc:	4618      	mov	r0, r3
 8011fce:	f00a fcf5 	bl	801c9bc <lv_mem_realloc>
 8011fd2:	4602      	mov	r2, r0
 8011fd4:	687b      	ldr	r3, [r7, #4]
 8011fd6:	625a      	str	r2, [r3, #36]	; 0x24

    return (void *)obj->ext_attr;
 8011fd8:	687b      	ldr	r3, [r7, #4]
 8011fda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 8011fdc:	4618      	mov	r0, r3
 8011fde:	3708      	adds	r7, #8
 8011fe0:	46bd      	mov	sp, r7
 8011fe2:	bd80      	pop	{r7, pc}

08011fe4 <lv_obj_refresh_ext_draw_pad>:
/**
 * Send a 'LV_SIGNAL_REFR_EXT_SIZE' signal to the object
 * @param obj pointer to an object
 */
void lv_obj_refresh_ext_draw_pad(lv_obj_t * obj)
{
 8011fe4:	b580      	push	{r7, lr}
 8011fe6:	b082      	sub	sp, #8
 8011fe8:	af00      	add	r7, sp, #0
 8011fea:	6078      	str	r0, [r7, #4]
    obj->ext_draw_pad = 0;
 8011fec:	687b      	ldr	r3, [r7, #4]
 8011fee:	2200      	movs	r2, #0
 8011ff0:	869a      	strh	r2, [r3, #52]	; 0x34
    obj->signal_cb(obj, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
 8011ff2:	687b      	ldr	r3, [r7, #4]
 8011ff4:	69db      	ldr	r3, [r3, #28]
 8011ff6:	2200      	movs	r2, #0
 8011ff8:	2105      	movs	r1, #5
 8011ffa:	6878      	ldr	r0, [r7, #4]
 8011ffc:	4798      	blx	r3

    lv_obj_invalidate(obj);
 8011ffe:	6878      	ldr	r0, [r7, #4]
 8012000:	f7fe ff15 	bl	8010e2e <lv_obj_invalidate>
}
 8012004:	bf00      	nop
 8012006:	3708      	adds	r7, #8
 8012008:	46bd      	mov	sp, r7
 801200a:	bd80      	pop	{r7, pc}

0801200c <lv_obj_get_screen>:
 * Return with the screen of an object
 * @param obj pointer to an object
 * @return pointer to a screen
 */
lv_obj_t * lv_obj_get_screen(const lv_obj_t * obj)
{
 801200c:	b580      	push	{r7, lr}
 801200e:	b084      	sub	sp, #16
 8012010:	af00      	add	r7, sp, #0
 8012012:	6078      	str	r0, [r7, #4]
    const lv_obj_t * par = obj;
 8012014:	687b      	ldr	r3, [r7, #4]
 8012016:	60fb      	str	r3, [r7, #12]
    const lv_obj_t * act_p;

    do {
        act_p = par;
 8012018:	68fb      	ldr	r3, [r7, #12]
 801201a:	60bb      	str	r3, [r7, #8]
        par   = lv_obj_get_parent(act_p);
 801201c:	68b8      	ldr	r0, [r7, #8]
 801201e:	f000 f84f 	bl	80120c0 <lv_obj_get_parent>
 8012022:	60f8      	str	r0, [r7, #12]
    } while(par != NULL);
 8012024:	68fb      	ldr	r3, [r7, #12]
 8012026:	2b00      	cmp	r3, #0
 8012028:	d1f6      	bne.n	8012018 <lv_obj_get_screen+0xc>

    return (lv_obj_t *)act_p;
 801202a:	68bb      	ldr	r3, [r7, #8]
}
 801202c:	4618      	mov	r0, r3
 801202e:	3710      	adds	r7, #16
 8012030:	46bd      	mov	sp, r7
 8012032:	bd80      	pop	{r7, pc}

08012034 <lv_obj_get_disp>:
 * Get the display of an object
 * @param scr pointer to an object
 * @return pointer the object's display
 */
lv_disp_t * lv_obj_get_disp(const lv_obj_t * obj)
{
 8012034:	b580      	push	{r7, lr}
 8012036:	b086      	sub	sp, #24
 8012038:	af00      	add	r7, sp, #0
 801203a:	6078      	str	r0, [r7, #4]
    const lv_obj_t * scr;

    if(obj->par == NULL)
 801203c:	687b      	ldr	r3, [r7, #4]
 801203e:	681b      	ldr	r3, [r3, #0]
 8012040:	2b00      	cmp	r3, #0
 8012042:	d102      	bne.n	801204a <lv_obj_get_disp+0x16>
        scr = obj; /*`obj` is a screen*/
 8012044:	687b      	ldr	r3, [r7, #4]
 8012046:	617b      	str	r3, [r7, #20]
 8012048:	e003      	b.n	8012052 <lv_obj_get_disp+0x1e>
    else
        scr = lv_obj_get_screen(obj); /*get the screen of `obj`*/
 801204a:	6878      	ldr	r0, [r7, #4]
 801204c:	f7ff ffde 	bl	801200c <lv_obj_get_screen>
 8012050:	6178      	str	r0, [r7, #20]

    lv_disp_t * d;
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
 8012052:	4818      	ldr	r0, [pc, #96]	; (80120b4 <lv_obj_get_disp+0x80>)
 8012054:	f00a fad2 	bl	801c5fc <lv_ll_get_head>
 8012058:	6138      	str	r0, [r7, #16]
 801205a:	e01b      	b.n	8012094 <lv_obj_get_disp+0x60>
    {
        lv_obj_t * s;
        LV_LL_READ(d->scr_ll, s)
 801205c:	693b      	ldr	r3, [r7, #16]
 801205e:	3330      	adds	r3, #48	; 0x30
 8012060:	4618      	mov	r0, r3
 8012062:	f00a facb 	bl	801c5fc <lv_ll_get_head>
 8012066:	60f8      	str	r0, [r7, #12]
 8012068:	e00c      	b.n	8012084 <lv_obj_get_disp+0x50>
        {
            if(s == scr) return d;
 801206a:	68fa      	ldr	r2, [r7, #12]
 801206c:	697b      	ldr	r3, [r7, #20]
 801206e:	429a      	cmp	r2, r3
 8012070:	d101      	bne.n	8012076 <lv_obj_get_disp+0x42>
 8012072:	693b      	ldr	r3, [r7, #16]
 8012074:	e019      	b.n	80120aa <lv_obj_get_disp+0x76>
        LV_LL_READ(d->scr_ll, s)
 8012076:	693b      	ldr	r3, [r7, #16]
 8012078:	3330      	adds	r3, #48	; 0x30
 801207a:	68f9      	ldr	r1, [r7, #12]
 801207c:	4618      	mov	r0, r3
 801207e:	f00a fae3 	bl	801c648 <lv_ll_get_next>
 8012082:	60f8      	str	r0, [r7, #12]
 8012084:	68fb      	ldr	r3, [r7, #12]
 8012086:	2b00      	cmp	r3, #0
 8012088:	d1ef      	bne.n	801206a <lv_obj_get_disp+0x36>
    LV_LL_READ(LV_GC_ROOT(_lv_disp_ll), d)
 801208a:	6939      	ldr	r1, [r7, #16]
 801208c:	4809      	ldr	r0, [pc, #36]	; (80120b4 <lv_obj_get_disp+0x80>)
 801208e:	f00a fadb 	bl	801c648 <lv_ll_get_next>
 8012092:	6138      	str	r0, [r7, #16]
 8012094:	693b      	ldr	r3, [r7, #16]
 8012096:	2b00      	cmp	r3, #0
 8012098:	d1e0      	bne.n	801205c <lv_obj_get_disp+0x28>
        }
    }

    LV_LOG_WARN("lv_scr_get_disp: screen not found")
 801209a:	4b07      	ldr	r3, [pc, #28]	; (80120b8 <lv_obj_get_disp+0x84>)
 801209c:	f240 52db 	movw	r2, #1499	; 0x5db
 80120a0:	4906      	ldr	r1, [pc, #24]	; (80120bc <lv_obj_get_disp+0x88>)
 80120a2:	2002      	movs	r0, #2
 80120a4:	f00a fbb2 	bl	801c80c <lv_log_add>
    return NULL;
 80120a8:	2300      	movs	r3, #0
}
 80120aa:	4618      	mov	r0, r3
 80120ac:	3718      	adds	r7, #24
 80120ae:	46bd      	mov	sp, r7
 80120b0:	bd80      	pop	{r7, pc}
 80120b2:	bf00      	nop
 80120b4:	2000df60 	.word	0x2000df60
 80120b8:	0802883c 	.word	0x0802883c
 80120bc:	08028770 	.word	0x08028770

080120c0 <lv_obj_get_parent>:
 * Returns with the parent of an object
 * @param obj pointer to an object
 * @return pointer to the parent of  'obj'
 */
lv_obj_t * lv_obj_get_parent(const lv_obj_t * obj)
{
 80120c0:	b480      	push	{r7}
 80120c2:	b083      	sub	sp, #12
 80120c4:	af00      	add	r7, sp, #0
 80120c6:	6078      	str	r0, [r7, #4]
    return obj->par;
 80120c8:	687b      	ldr	r3, [r7, #4]
 80120ca:	681b      	ldr	r3, [r3, #0]
}
 80120cc:	4618      	mov	r0, r3
 80120ce:	370c      	adds	r7, #12
 80120d0:	46bd      	mov	sp, r7
 80120d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80120d6:	4770      	bx	lr

080120d8 <lv_obj_get_child>:
 * @param child NULL at first call to get the next children
 *                  and the previous return value later
 * @return the child after 'act_child' or NULL if no more child
 */
lv_obj_t * lv_obj_get_child(const lv_obj_t * obj, const lv_obj_t * child)
{
 80120d8:	b580      	push	{r7, lr}
 80120da:	b084      	sub	sp, #16
 80120dc:	af00      	add	r7, sp, #0
 80120de:	6078      	str	r0, [r7, #4]
 80120e0:	6039      	str	r1, [r7, #0]
    lv_obj_t * result = NULL;
 80120e2:	2300      	movs	r3, #0
 80120e4:	60fb      	str	r3, [r7, #12]

    if(child == NULL) {
 80120e6:	683b      	ldr	r3, [r7, #0]
 80120e8:	2b00      	cmp	r3, #0
 80120ea:	d106      	bne.n	80120fa <lv_obj_get_child+0x22>
        result = lv_ll_get_head(&obj->child_ll);
 80120ec:	687b      	ldr	r3, [r7, #4]
 80120ee:	3304      	adds	r3, #4
 80120f0:	4618      	mov	r0, r3
 80120f2:	f00a fa83 	bl	801c5fc <lv_ll_get_head>
 80120f6:	60f8      	str	r0, [r7, #12]
 80120f8:	e006      	b.n	8012108 <lv_obj_get_child+0x30>
    } else {
        result = lv_ll_get_next(&obj->child_ll, child);
 80120fa:	687b      	ldr	r3, [r7, #4]
 80120fc:	3304      	adds	r3, #4
 80120fe:	6839      	ldr	r1, [r7, #0]
 8012100:	4618      	mov	r0, r3
 8012102:	f00a faa1 	bl	801c648 <lv_ll_get_next>
 8012106:	60f8      	str	r0, [r7, #12]
    }

    return result;
 8012108:	68fb      	ldr	r3, [r7, #12]
}
 801210a:	4618      	mov	r0, r3
 801210c:	3710      	adds	r7, #16
 801210e:	46bd      	mov	sp, r7
 8012110:	bd80      	pop	{r7, pc}

08012112 <lv_obj_get_coords>:
 * Copy the coordinates of an object to an area
 * @param obj pointer to an object
 * @param cords_p pointer to an area to store the coordinates
 */
void lv_obj_get_coords(const lv_obj_t * obj, lv_area_t * cords_p)
{
 8012112:	b580      	push	{r7, lr}
 8012114:	b082      	sub	sp, #8
 8012116:	af00      	add	r7, sp, #0
 8012118:	6078      	str	r0, [r7, #4]
 801211a:	6039      	str	r1, [r7, #0]
    lv_area_copy(cords_p, &obj->coords);
 801211c:	687b      	ldr	r3, [r7, #4]
 801211e:	3310      	adds	r3, #16
 8012120:	4619      	mov	r1, r3
 8012122:	6838      	ldr	r0, [r7, #0]
 8012124:	f7fe fab8 	bl	8010698 <lv_area_copy>
}
 8012128:	bf00      	nop
 801212a:	3708      	adds	r7, #8
 801212c:	46bd      	mov	sp, r7
 801212e:	bd80      	pop	{r7, pc}

08012130 <lv_obj_get_x>:
 * Get the x coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the left side of its parent
 */
lv_coord_t lv_obj_get_x(const lv_obj_t * obj)
{
 8012130:	b580      	push	{r7, lr}
 8012132:	b084      	sub	sp, #16
 8012134:	af00      	add	r7, sp, #0
 8012136:	6078      	str	r0, [r7, #4]
    lv_coord_t rel_x;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 8012138:	6878      	ldr	r0, [r7, #4]
 801213a:	f7ff ffc1 	bl	80120c0 <lv_obj_get_parent>
 801213e:	60f8      	str	r0, [r7, #12]
    rel_x             = obj->coords.x1 - parent->coords.x1;
 8012140:	687b      	ldr	r3, [r7, #4]
 8012142:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012146:	b29a      	uxth	r2, r3
 8012148:	68fb      	ldr	r3, [r7, #12]
 801214a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801214e:	b29b      	uxth	r3, r3
 8012150:	1ad3      	subs	r3, r2, r3
 8012152:	b29b      	uxth	r3, r3
 8012154:	817b      	strh	r3, [r7, #10]

    return rel_x;
 8012156:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
}
 801215a:	4618      	mov	r0, r3
 801215c:	3710      	adds	r7, #16
 801215e:	46bd      	mov	sp, r7
 8012160:	bd80      	pop	{r7, pc}

08012162 <lv_obj_get_y>:
 * Get the y coordinate of object
 * @param obj pointer to an object
 * @return distance of 'obj' from the top of its parent
 */
lv_coord_t lv_obj_get_y(const lv_obj_t * obj)
{
 8012162:	b580      	push	{r7, lr}
 8012164:	b084      	sub	sp, #16
 8012166:	af00      	add	r7, sp, #0
 8012168:	6078      	str	r0, [r7, #4]
    lv_coord_t rel_y;
    lv_obj_t * parent = lv_obj_get_parent(obj);
 801216a:	6878      	ldr	r0, [r7, #4]
 801216c:	f7ff ffa8 	bl	80120c0 <lv_obj_get_parent>
 8012170:	60f8      	str	r0, [r7, #12]
    rel_y             = obj->coords.y1 - parent->coords.y1;
 8012172:	687b      	ldr	r3, [r7, #4]
 8012174:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012178:	b29a      	uxth	r2, r3
 801217a:	68fb      	ldr	r3, [r7, #12]
 801217c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012180:	b29b      	uxth	r3, r3
 8012182:	1ad3      	subs	r3, r2, r3
 8012184:	b29b      	uxth	r3, r3
 8012186:	817b      	strh	r3, [r7, #10]

    return rel_y;
 8012188:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
}
 801218c:	4618      	mov	r0, r3
 801218e:	3710      	adds	r7, #16
 8012190:	46bd      	mov	sp, r7
 8012192:	bd80      	pop	{r7, pc}

08012194 <lv_obj_get_width>:
 * Get the width of an object
 * @param obj pointer to an object
 * @return the width
 */
lv_coord_t lv_obj_get_width(const lv_obj_t * obj)
{
 8012194:	b580      	push	{r7, lr}
 8012196:	b082      	sub	sp, #8
 8012198:	af00      	add	r7, sp, #0
 801219a:	6078      	str	r0, [r7, #4]
    return lv_area_get_width(&obj->coords);
 801219c:	687b      	ldr	r3, [r7, #4]
 801219e:	3310      	adds	r3, #16
 80121a0:	4618      	mov	r0, r3
 80121a2:	f7fe fa87 	bl	80106b4 <lv_area_get_width>
 80121a6:	4603      	mov	r3, r0
}
 80121a8:	4618      	mov	r0, r3
 80121aa:	3708      	adds	r7, #8
 80121ac:	46bd      	mov	sp, r7
 80121ae:	bd80      	pop	{r7, pc}

080121b0 <lv_obj_get_height>:
 * Get the height of an object
 * @param obj pointer to an object
 * @return the height
 */
lv_coord_t lv_obj_get_height(const lv_obj_t * obj)
{
 80121b0:	b580      	push	{r7, lr}
 80121b2:	b082      	sub	sp, #8
 80121b4:	af00      	add	r7, sp, #0
 80121b6:	6078      	str	r0, [r7, #4]
    return lv_area_get_height(&obj->coords);
 80121b8:	687b      	ldr	r3, [r7, #4]
 80121ba:	3310      	adds	r3, #16
 80121bc:	4618      	mov	r0, r3
 80121be:	f7fe fa90 	bl	80106e2 <lv_area_get_height>
 80121c2:	4603      	mov	r3, r0
}
 80121c4:	4618      	mov	r0, r3
 80121c6:	3708      	adds	r7, #8
 80121c8:	46bd      	mov	sp, r7
 80121ca:	bd80      	pop	{r7, pc}

080121cc <lv_obj_get_auto_realign>:
 * Get the automatic realign property of the object.
 * @param obj pointer to an object
 * @return  true: auto realign is enabled; false: auto realign is disabled
 */
bool lv_obj_get_auto_realign(lv_obj_t * obj)
{
 80121cc:	b480      	push	{r7}
 80121ce:	b083      	sub	sp, #12
 80121d0:	af00      	add	r7, sp, #0
 80121d2:	6078      	str	r0, [r7, #4]
#if LV_USE_OBJ_REALIGN
    return obj->realign.auto_realign ? true : false;
 80121d4:	687b      	ldr	r3, [r7, #4]
 80121d6:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 80121da:	f003 0301 	and.w	r3, r3, #1
 80121de:	2b00      	cmp	r3, #0
 80121e0:	bf14      	ite	ne
 80121e2:	2301      	movne	r3, #1
 80121e4:	2300      	moveq	r3, #0
 80121e6:	b2db      	uxtb	r3, r3
#else
    (void)obj;
    return false;
#endif
}
 80121e8:	4618      	mov	r0, r3
 80121ea:	370c      	adds	r7, #12
 80121ec:	46bd      	mov	sp, r7
 80121ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80121f2:	4770      	bx	lr

080121f4 <lv_obj_get_style>:
 * Get the style pointer of an object (if NULL get style of the parent)
 * @param obj pointer to an object
 * @return pointer to a style
 */
const lv_style_t * lv_obj_get_style(const lv_obj_t * obj)
{
 80121f4:	b580      	push	{r7, lr}
 80121f6:	b086      	sub	sp, #24
 80121f8:	af00      	add	r7, sp, #0
 80121fa:	6078      	str	r0, [r7, #4]
    const lv_style_t * style_act = obj->style_p;
 80121fc:	687b      	ldr	r3, [r7, #4]
 80121fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012200:	617b      	str	r3, [r7, #20]
    if(style_act == NULL) {
 8012202:	697b      	ldr	r3, [r7, #20]
 8012204:	2b00      	cmp	r3, #0
 8012206:	d12c      	bne.n	8012262 <lv_obj_get_style+0x6e>
        lv_obj_t * par = obj->par;
 8012208:	687b      	ldr	r3, [r7, #4]
 801220a:	681b      	ldr	r3, [r3, #0]
 801220c:	613b      	str	r3, [r7, #16]

        while(par) {
 801220e:	e025      	b.n	801225c <lv_obj_get_style+0x68>
            if(par->style_p) {
 8012210:	693b      	ldr	r3, [r7, #16]
 8012212:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012214:	2b00      	cmp	r3, #0
 8012216:	d01e      	beq.n	8012256 <lv_obj_get_style+0x62>
                if(par->style_p->glass == 0) {
 8012218:	693b      	ldr	r3, [r7, #16]
 801221a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801221c:	781b      	ldrb	r3, [r3, #0]
 801221e:	f003 0301 	and.w	r3, r3, #1
 8012222:	b2db      	uxtb	r3, r3
 8012224:	2b00      	cmp	r3, #0
 8012226:	d116      	bne.n	8012256 <lv_obj_get_style+0x62>
#if LV_USE_GROUP == 0
                    style_act = par->style_p;
#else
                    /*If a parent is focused then use then focused style*/
                    lv_group_t * g = lv_obj_get_group(par);
 8012228:	6938      	ldr	r0, [r7, #16]
 801222a:	f000 f90e 	bl	801244a <lv_obj_get_group>
 801222e:	60f8      	str	r0, [r7, #12]
                    if(lv_group_get_focused(g) == par) {
 8012230:	68f8      	ldr	r0, [r7, #12]
 8012232:	f7fc f913 	bl	800e45c <lv_group_get_focused>
 8012236:	4602      	mov	r2, r0
 8012238:	693b      	ldr	r3, [r7, #16]
 801223a:	4293      	cmp	r3, r2
 801223c:	d107      	bne.n	801224e <lv_obj_get_style+0x5a>
                        style_act = lv_group_mod_style(g, par->style_p);
 801223e:	693b      	ldr	r3, [r7, #16]
 8012240:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012242:	4619      	mov	r1, r3
 8012244:	68f8      	ldr	r0, [r7, #12]
 8012246:	f7fc f8d9 	bl	800e3fc <lv_group_mod_style>
 801224a:	6178      	str	r0, [r7, #20]
                    } else {
                        style_act = par->style_p;
                    }
#endif
                    break;
 801224c:	e009      	b.n	8012262 <lv_obj_get_style+0x6e>
                        style_act = par->style_p;
 801224e:	693b      	ldr	r3, [r7, #16]
 8012250:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012252:	617b      	str	r3, [r7, #20]
                    break;
 8012254:	e005      	b.n	8012262 <lv_obj_get_style+0x6e>
                }
            }
            par = par->par;
 8012256:	693b      	ldr	r3, [r7, #16]
 8012258:	681b      	ldr	r3, [r3, #0]
 801225a:	613b      	str	r3, [r7, #16]
        while(par) {
 801225c:	693b      	ldr	r3, [r7, #16]
 801225e:	2b00      	cmp	r3, #0
 8012260:	d1d6      	bne.n	8012210 <lv_obj_get_style+0x1c>
        }
    }
#if LV_USE_GROUP
    if(obj->group_p) {
 8012262:	687b      	ldr	r3, [r7, #4]
 8012264:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012266:	2b00      	cmp	r3, #0
 8012268:	d00f      	beq.n	801228a <lv_obj_get_style+0x96>
        if(lv_group_get_focused(obj->group_p) == obj) {
 801226a:	687b      	ldr	r3, [r7, #4]
 801226c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801226e:	4618      	mov	r0, r3
 8012270:	f7fc f8f4 	bl	800e45c <lv_group_get_focused>
 8012274:	4602      	mov	r2, r0
 8012276:	687b      	ldr	r3, [r7, #4]
 8012278:	4293      	cmp	r3, r2
 801227a:	d106      	bne.n	801228a <lv_obj_get_style+0x96>
            style_act = lv_group_mod_style(obj->group_p, style_act);
 801227c:	687b      	ldr	r3, [r7, #4]
 801227e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012280:	6979      	ldr	r1, [r7, #20]
 8012282:	4618      	mov	r0, r3
 8012284:	f7fc f8ba 	bl	800e3fc <lv_group_mod_style>
 8012288:	6178      	str	r0, [r7, #20]
        }
    }
#endif

    if(style_act == NULL) style_act = &lv_style_plain;
 801228a:	697b      	ldr	r3, [r7, #20]
 801228c:	2b00      	cmp	r3, #0
 801228e:	d101      	bne.n	8012294 <lv_obj_get_style+0xa0>
 8012290:	4b03      	ldr	r3, [pc, #12]	; (80122a0 <lv_obj_get_style+0xac>)
 8012292:	617b      	str	r3, [r7, #20]

    return style_act;
 8012294:	697b      	ldr	r3, [r7, #20]
}
 8012296:	4618      	mov	r0, r3
 8012298:	3718      	adds	r7, #24
 801229a:	46bd      	mov	sp, r7
 801229c:	bd80      	pop	{r7, pc}
 801229e:	bf00      	nop
 80122a0:	2000de18 	.word	0x2000de18

080122a4 <lv_obj_get_hidden>:
 * Get the hidden attribute of an object
 * @param obj pointer to an object
 * @return true: the object is hidden
 */
bool lv_obj_get_hidden(const lv_obj_t * obj)
{
 80122a4:	b480      	push	{r7}
 80122a6:	b083      	sub	sp, #12
 80122a8:	af00      	add	r7, sp, #0
 80122aa:	6078      	str	r0, [r7, #4]
    return obj->hidden == 0 ? false : true;
 80122ac:	687b      	ldr	r3, [r7, #4]
 80122ae:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80122b2:	f003 0310 	and.w	r3, r3, #16
 80122b6:	b2db      	uxtb	r3, r3
 80122b8:	2b00      	cmp	r3, #0
 80122ba:	bf14      	ite	ne
 80122bc:	2301      	movne	r3, #1
 80122be:	2300      	moveq	r3, #0
 80122c0:	b2db      	uxtb	r3, r3
}
 80122c2:	4618      	mov	r0, r3
 80122c4:	370c      	adds	r7, #12
 80122c6:	46bd      	mov	sp, r7
 80122c8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122cc:	4770      	bx	lr

080122ce <lv_obj_get_click>:
 * Get the click enable attribute of an object
 * @param obj pointer to an object
 * @return true: the object is clickable
 */
bool lv_obj_get_click(const lv_obj_t * obj)
{
 80122ce:	b480      	push	{r7}
 80122d0:	b083      	sub	sp, #12
 80122d2:	af00      	add	r7, sp, #0
 80122d4:	6078      	str	r0, [r7, #4]
    return obj->click == 0 ? false : true;
 80122d6:	687b      	ldr	r3, [r7, #4]
 80122d8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80122dc:	f003 0301 	and.w	r3, r3, #1
 80122e0:	b2db      	uxtb	r3, r3
 80122e2:	2b00      	cmp	r3, #0
 80122e4:	bf14      	ite	ne
 80122e6:	2301      	movne	r3, #1
 80122e8:	2300      	moveq	r3, #0
 80122ea:	b2db      	uxtb	r3, r3
}
 80122ec:	4618      	mov	r0, r3
 80122ee:	370c      	adds	r7, #12
 80122f0:	46bd      	mov	sp, r7
 80122f2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80122f6:	4770      	bx	lr

080122f8 <lv_obj_get_drag>:
 * Get the drag enable attribute of an object
 * @param obj pointer to an object
 * @return true: the object is dragable
 */
bool lv_obj_get_drag(const lv_obj_t * obj)
{
 80122f8:	b480      	push	{r7}
 80122fa:	b083      	sub	sp, #12
 80122fc:	af00      	add	r7, sp, #0
 80122fe:	6078      	str	r0, [r7, #4]
    return obj->drag == 0 ? false : true;
 8012300:	687b      	ldr	r3, [r7, #4]
 8012302:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012306:	f003 0302 	and.w	r3, r3, #2
 801230a:	b2db      	uxtb	r3, r3
 801230c:	2b00      	cmp	r3, #0
 801230e:	bf14      	ite	ne
 8012310:	2301      	movne	r3, #1
 8012312:	2300      	moveq	r3, #0
 8012314:	b2db      	uxtb	r3, r3
}
 8012316:	4618      	mov	r0, r3
 8012318:	370c      	adds	r7, #12
 801231a:	46bd      	mov	sp, r7
 801231c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012320:	4770      	bx	lr

08012322 <lv_obj_get_drag_dir>:
 * Get the directions an object can be dragged
 * @param obj pointer to an object
 * @return bitwise OR of allowed directions an object can be dragged in
 */
lv_drag_dir_t lv_obj_get_drag_dir(const lv_obj_t * obj)
{
 8012322:	b480      	push	{r7}
 8012324:	b083      	sub	sp, #12
 8012326:	af00      	add	r7, sp, #0
 8012328:	6078      	str	r0, [r7, #4]
    return obj->drag_dir;
 801232a:	687b      	ldr	r3, [r7, #4]
 801232c:	f893 3031 	ldrb.w	r3, [r3, #49]	; 0x31
 8012330:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8012334:	b2db      	uxtb	r3, r3
}
 8012336:	4618      	mov	r0, r3
 8012338:	370c      	adds	r7, #12
 801233a:	46bd      	mov	sp, r7
 801233c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012340:	4770      	bx	lr

08012342 <lv_obj_get_drag_throw>:
 * Get the drag throw enable attribute of an object
 * @param obj pointer to an object
 * @return true: drag throw is enabled
 */
bool lv_obj_get_drag_throw(const lv_obj_t * obj)
{
 8012342:	b480      	push	{r7}
 8012344:	b083      	sub	sp, #12
 8012346:	af00      	add	r7, sp, #0
 8012348:	6078      	str	r0, [r7, #4]
    return obj->drag_throw == 0 ? false : true;
 801234a:	687b      	ldr	r3, [r7, #4]
 801234c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8012350:	f003 0304 	and.w	r3, r3, #4
 8012354:	b2db      	uxtb	r3, r3
 8012356:	2b00      	cmp	r3, #0
 8012358:	bf14      	ite	ne
 801235a:	2301      	movne	r3, #1
 801235c:	2300      	moveq	r3, #0
 801235e:	b2db      	uxtb	r3, r3
}
 8012360:	4618      	mov	r0, r3
 8012362:	370c      	adds	r7, #12
 8012364:	46bd      	mov	sp, r7
 8012366:	f85d 7b04 	ldr.w	r7, [sp], #4
 801236a:	4770      	bx	lr

0801236c <lv_obj_get_drag_parent>:
 * Get the drag parent attribute of an object
 * @param obj pointer to an object
 * @return true: drag parent is enabled
 */
bool lv_obj_get_drag_parent(const lv_obj_t * obj)
{
 801236c:	b480      	push	{r7}
 801236e:	b083      	sub	sp, #12
 8012370:	af00      	add	r7, sp, #0
 8012372:	6078      	str	r0, [r7, #4]
    return obj->drag_parent == 0 ? false : true;
 8012374:	687b      	ldr	r3, [r7, #4]
 8012376:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 801237a:	f003 0308 	and.w	r3, r3, #8
 801237e:	b2db      	uxtb	r3, r3
 8012380:	2b00      	cmp	r3, #0
 8012382:	bf14      	ite	ne
 8012384:	2301      	movne	r3, #1
 8012386:	2300      	moveq	r3, #0
 8012388:	b2db      	uxtb	r3, r3
}
 801238a:	4618      	mov	r0, r3
 801238c:	370c      	adds	r7, #12
 801238e:	46bd      	mov	sp, r7
 8012390:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012394:	4770      	bx	lr

08012396 <lv_obj_get_opa_scale>:
 * Get the opa scale parameter of an object
 * @param obj pointer to an object
 * @return opa scale [0..255]
 */
lv_opa_t lv_obj_get_opa_scale(const lv_obj_t * obj)
{
 8012396:	b580      	push	{r7, lr}
 8012398:	b084      	sub	sp, #16
 801239a:	af00      	add	r7, sp, #0
 801239c:	6078      	str	r0, [r7, #4]
    const lv_obj_t * parent = obj;
 801239e:	687b      	ldr	r3, [r7, #4]
 80123a0:	60fb      	str	r3, [r7, #12]

    while(parent) {
 80123a2:	e00f      	b.n	80123c4 <lv_obj_get_opa_scale+0x2e>
        if(parent->opa_scale_en) return parent->opa_scale;
 80123a4:	68fb      	ldr	r3, [r7, #12]
 80123a6:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 80123aa:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80123ae:	b2db      	uxtb	r3, r3
 80123b0:	2b00      	cmp	r3, #0
 80123b2:	d003      	beq.n	80123bc <lv_obj_get_opa_scale+0x26>
 80123b4:	68fb      	ldr	r3, [r7, #12]
 80123b6:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 80123ba:	e007      	b.n	80123cc <lv_obj_get_opa_scale+0x36>
        parent = lv_obj_get_parent(parent);
 80123bc:	68f8      	ldr	r0, [r7, #12]
 80123be:	f7ff fe7f 	bl	80120c0 <lv_obj_get_parent>
 80123c2:	60f8      	str	r0, [r7, #12]
    while(parent) {
 80123c4:	68fb      	ldr	r3, [r7, #12]
 80123c6:	2b00      	cmp	r3, #0
 80123c8:	d1ec      	bne.n	80123a4 <lv_obj_get_opa_scale+0xe>
    }

    return LV_OPA_COVER;
 80123ca:	23ff      	movs	r3, #255	; 0xff
}
 80123cc:	4618      	mov	r0, r3
 80123ce:	3710      	adds	r7, #16
 80123d0:	46bd      	mov	sp, r7
 80123d2:	bd80      	pop	{r7, pc}

080123d4 <lv_obj_is_protected>:
 * @param obj pointer to an object
 * @param prot protect bits to test ('OR'ed values of `lv_protect_t`)
 * @return false: none of the given bits are set, true: at least one bit is set
 */
bool lv_obj_is_protected(const lv_obj_t * obj, uint8_t prot)
{
 80123d4:	b480      	push	{r7}
 80123d6:	b083      	sub	sp, #12
 80123d8:	af00      	add	r7, sp, #0
 80123da:	6078      	str	r0, [r7, #4]
 80123dc:	460b      	mov	r3, r1
 80123de:	70fb      	strb	r3, [r7, #3]
    return (obj->protect & prot) == 0 ? false : true;
 80123e0:	687b      	ldr	r3, [r7, #4]
 80123e2:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 80123e6:	78fb      	ldrb	r3, [r7, #3]
 80123e8:	4013      	ands	r3, r2
 80123ea:	b2db      	uxtb	r3, r3
 80123ec:	2b00      	cmp	r3, #0
 80123ee:	bf14      	ite	ne
 80123f0:	2301      	movne	r3, #1
 80123f2:	2300      	moveq	r3, #0
 80123f4:	b2db      	uxtb	r3, r3
}
 80123f6:	4618      	mov	r0, r3
 80123f8:	370c      	adds	r7, #12
 80123fa:	46bd      	mov	sp, r7
 80123fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012400:	4770      	bx	lr

08012402 <lv_obj_get_signal_cb>:
 * Get the signal function of an object
 * @param obj pointer to an object
 * @return the signal function
 */
lv_signal_cb_t lv_obj_get_signal_cb(const lv_obj_t * obj)
{
 8012402:	b480      	push	{r7}
 8012404:	b083      	sub	sp, #12
 8012406:	af00      	add	r7, sp, #0
 8012408:	6078      	str	r0, [r7, #4]
    return obj->signal_cb;
 801240a:	687b      	ldr	r3, [r7, #4]
 801240c:	69db      	ldr	r3, [r3, #28]
}
 801240e:	4618      	mov	r0, r3
 8012410:	370c      	adds	r7, #12
 8012412:	46bd      	mov	sp, r7
 8012414:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012418:	4770      	bx	lr

0801241a <lv_obj_get_design_cb>:
 * Get the design function of an object
 * @param obj pointer to an object
 * @return the design function
 */
lv_design_cb_t lv_obj_get_design_cb(const lv_obj_t * obj)
{
 801241a:	b480      	push	{r7}
 801241c:	b083      	sub	sp, #12
 801241e:	af00      	add	r7, sp, #0
 8012420:	6078      	str	r0, [r7, #4]
    return obj->design_cb;
 8012422:	687b      	ldr	r3, [r7, #4]
 8012424:	6a1b      	ldr	r3, [r3, #32]
}
 8012426:	4618      	mov	r0, r3
 8012428:	370c      	adds	r7, #12
 801242a:	46bd      	mov	sp, r7
 801242c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012430:	4770      	bx	lr

08012432 <lv_obj_get_ext_attr>:
 * @param obj pointer to an object
 * @return the ext pointer but not the dynamic version
 *         Use it as ext->data1, and NOT da(ext)->data1
 */
void * lv_obj_get_ext_attr(const lv_obj_t * obj)
{
 8012432:	b480      	push	{r7}
 8012434:	b083      	sub	sp, #12
 8012436:	af00      	add	r7, sp, #0
 8012438:	6078      	str	r0, [r7, #4]
    return obj->ext_attr;
 801243a:	687b      	ldr	r3, [r7, #4]
 801243c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 801243e:	4618      	mov	r0, r3
 8012440:	370c      	adds	r7, #12
 8012442:	46bd      	mov	sp, r7
 8012444:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012448:	4770      	bx	lr

0801244a <lv_obj_get_group>:
 * Get the group of the object
 * @param obj pointer to an object
 * @return the pointer to group of the object
 */
void * lv_obj_get_group(const lv_obj_t * obj)
{
 801244a:	b480      	push	{r7}
 801244c:	b083      	sub	sp, #12
 801244e:	af00      	add	r7, sp, #0
 8012450:	6078      	str	r0, [r7, #4]
    return obj->group_p;
 8012452:	687b      	ldr	r3, [r7, #4]
 8012454:	6adb      	ldr	r3, [r3, #44]	; 0x2c
}
 8012456:	4618      	mov	r0, r3
 8012458:	370c      	adds	r7, #12
 801245a:	46bd      	mov	sp, r7
 801245c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012460:	4770      	bx	lr

08012462 <lv_obj_is_focused>:
 * Tell whether the object is the focused object of a group or not.
 * @param obj pointer to an object
 * @return true: the object is focused, false: the object is not focused or not in a group
 */
bool lv_obj_is_focused(const lv_obj_t * obj)
{
 8012462:	b580      	push	{r7, lr}
 8012464:	b082      	sub	sp, #8
 8012466:	af00      	add	r7, sp, #0
 8012468:	6078      	str	r0, [r7, #4]
    if(obj->group_p) {
 801246a:	687b      	ldr	r3, [r7, #4]
 801246c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801246e:	2b00      	cmp	r3, #0
 8012470:	d00a      	beq.n	8012488 <lv_obj_is_focused+0x26>
        if(lv_group_get_focused(obj->group_p) == obj) return true;
 8012472:	687b      	ldr	r3, [r7, #4]
 8012474:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8012476:	4618      	mov	r0, r3
 8012478:	f7fb fff0 	bl	800e45c <lv_group_get_focused>
 801247c:	4602      	mov	r2, r0
 801247e:	687b      	ldr	r3, [r7, #4]
 8012480:	4293      	cmp	r3, r2
 8012482:	d101      	bne.n	8012488 <lv_obj_is_focused+0x26>
 8012484:	2301      	movs	r3, #1
 8012486:	e000      	b.n	801248a <lv_obj_is_focused+0x28>
    }

    return false;
 8012488:	2300      	movs	r3, #0
}
 801248a:	4618      	mov	r0, r3
 801248c:	3708      	adds	r7, #8
 801248e:	46bd      	mov	sp, r7
 8012490:	bd80      	pop	{r7, pc}

08012492 <lv_obj_design>:
 *                                  (return 'true' if yes)
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 * @param return true/false, depends on 'mode'
 */
static bool lv_obj_design(lv_obj_t * obj, const lv_area_t * mask_p, lv_design_mode_t mode)
{
 8012492:	b590      	push	{r4, r7, lr}
 8012494:	b08b      	sub	sp, #44	; 0x2c
 8012496:	af00      	add	r7, sp, #0
 8012498:	60f8      	str	r0, [r7, #12]
 801249a:	60b9      	str	r1, [r7, #8]
 801249c:	4613      	mov	r3, r2
 801249e:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 80124a0:	79fb      	ldrb	r3, [r7, #7]
 80124a2:	2b02      	cmp	r3, #2
 80124a4:	d16a      	bne.n	801257c <lv_obj_design+0xea>

        /*Most trivial test. Is the mask fully IN the object? If no it surely doesn't cover it*/
        if(lv_area_is_in(mask_p, &obj->coords) == false) return false;
 80124a6:	68fb      	ldr	r3, [r7, #12]
 80124a8:	3310      	adds	r3, #16
 80124aa:	4619      	mov	r1, r3
 80124ac:	68b8      	ldr	r0, [r7, #8]
 80124ae:	f009 fbfe 	bl	801bcae <lv_area_is_in>
 80124b2:	4603      	mov	r3, r0
 80124b4:	f083 0301 	eor.w	r3, r3, #1
 80124b8:	b2db      	uxtb	r3, r3
 80124ba:	2b00      	cmp	r3, #0
 80124bc:	d001      	beq.n	80124c2 <lv_obj_design+0x30>
 80124be:	2300      	movs	r3, #0
 80124c0:	e070      	b.n	80125a4 <lv_obj_design+0x112>

        /*Can cover the area only if fully solid (no opacity)*/
        const lv_style_t * style = lv_obj_get_style(obj);
 80124c2:	68f8      	ldr	r0, [r7, #12]
 80124c4:	f7ff fe96 	bl	80121f4 <lv_obj_get_style>
 80124c8:	6238      	str	r0, [r7, #32]
        if(style->body.opa < LV_OPA_MAX) return false;
 80124ca:	6a3b      	ldr	r3, [r7, #32]
 80124cc:	7a1b      	ldrb	r3, [r3, #8]
 80124ce:	2bfa      	cmp	r3, #250	; 0xfa
 80124d0:	d801      	bhi.n	80124d6 <lv_obj_design+0x44>
 80124d2:	2300      	movs	r3, #0
 80124d4:	e066      	b.n	80125a4 <lv_obj_design+0x112>

        /* Because of the radius it is not sure the area is covered
         * Check the areas where there is no radius*/
        lv_coord_t r = style->body.radius;
 80124d6:	6a3b      	ldr	r3, [r7, #32]
 80124d8:	88db      	ldrh	r3, [r3, #6]
 80124da:	83fb      	strh	r3, [r7, #30]

        if(r == LV_RADIUS_CIRCLE) return false;
 80124dc:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80124e0:	f647 4218 	movw	r2, #31768	; 0x7c18
 80124e4:	4293      	cmp	r3, r2
 80124e6:	d101      	bne.n	80124ec <lv_obj_design+0x5a>
 80124e8:	2300      	movs	r3, #0
 80124ea:	e05b      	b.n	80125a4 <lv_obj_design+0x112>

        lv_area_t area_tmp;

        /*Check horizontally without radius*/
        lv_obj_get_coords(obj, &area_tmp);
 80124ec:	f107 0314 	add.w	r3, r7, #20
 80124f0:	4619      	mov	r1, r3
 80124f2:	68f8      	ldr	r0, [r7, #12]
 80124f4:	f7ff fe0d 	bl	8012112 <lv_obj_get_coords>
        area_tmp.x1 += r;
 80124f8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80124fc:	b29a      	uxth	r2, r3
 80124fe:	8bfb      	ldrh	r3, [r7, #30]
 8012500:	4413      	add	r3, r2
 8012502:	b29b      	uxth	r3, r3
 8012504:	b21b      	sxth	r3, r3
 8012506:	82bb      	strh	r3, [r7, #20]
        area_tmp.x2 -= r;
 8012508:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801250c:	b29a      	uxth	r2, r3
 801250e:	8bfb      	ldrh	r3, [r7, #30]
 8012510:	1ad3      	subs	r3, r2, r3
 8012512:	b29b      	uxth	r3, r3
 8012514:	b21b      	sxth	r3, r3
 8012516:	833b      	strh	r3, [r7, #24]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
 8012518:	f107 0314 	add.w	r3, r7, #20
 801251c:	4619      	mov	r1, r3
 801251e:	68b8      	ldr	r0, [r7, #8]
 8012520:	f009 fbc5 	bl	801bcae <lv_area_is_in>
 8012524:	4603      	mov	r3, r0
 8012526:	f083 0301 	eor.w	r3, r3, #1
 801252a:	b2db      	uxtb	r3, r3
 801252c:	2b00      	cmp	r3, #0
 801252e:	d001      	beq.n	8012534 <lv_obj_design+0xa2>
 8012530:	2300      	movs	r3, #0
 8012532:	e037      	b.n	80125a4 <lv_obj_design+0x112>

        /*Check vertically without radius*/
        lv_obj_get_coords(obj, &area_tmp);
 8012534:	f107 0314 	add.w	r3, r7, #20
 8012538:	4619      	mov	r1, r3
 801253a:	68f8      	ldr	r0, [r7, #12]
 801253c:	f7ff fde9 	bl	8012112 <lv_obj_get_coords>
        area_tmp.y1 += r;
 8012540:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8012544:	b29a      	uxth	r2, r3
 8012546:	8bfb      	ldrh	r3, [r7, #30]
 8012548:	4413      	add	r3, r2
 801254a:	b29b      	uxth	r3, r3
 801254c:	b21b      	sxth	r3, r3
 801254e:	82fb      	strh	r3, [r7, #22]
        area_tmp.y2 -= r;
 8012550:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8012554:	b29a      	uxth	r2, r3
 8012556:	8bfb      	ldrh	r3, [r7, #30]
 8012558:	1ad3      	subs	r3, r2, r3
 801255a:	b29b      	uxth	r3, r3
 801255c:	b21b      	sxth	r3, r3
 801255e:	837b      	strh	r3, [r7, #26]
        if(lv_area_is_in(mask_p, &area_tmp) == false) return false;
 8012560:	f107 0314 	add.w	r3, r7, #20
 8012564:	4619      	mov	r1, r3
 8012566:	68b8      	ldr	r0, [r7, #8]
 8012568:	f009 fba1 	bl	801bcae <lv_area_is_in>
 801256c:	4603      	mov	r3, r0
 801256e:	f083 0301 	eor.w	r3, r3, #1
 8012572:	b2db      	uxtb	r3, r3
 8012574:	2b00      	cmp	r3, #0
 8012576:	d014      	beq.n	80125a2 <lv_obj_design+0x110>
 8012578:	2300      	movs	r3, #0
 801257a:	e013      	b.n	80125a4 <lv_obj_design+0x112>

    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 801257c:	79fb      	ldrb	r3, [r7, #7]
 801257e:	2b00      	cmp	r3, #0
 8012580:	d10f      	bne.n	80125a2 <lv_obj_design+0x110>
        const lv_style_t * style = lv_obj_get_style(obj);
 8012582:	68f8      	ldr	r0, [r7, #12]
 8012584:	f7ff fe36 	bl	80121f4 <lv_obj_get_style>
 8012588:	6278      	str	r0, [r7, #36]	; 0x24
        lv_draw_rect(&obj->coords, mask_p, style, lv_obj_get_opa_scale(obj));
 801258a:	68fb      	ldr	r3, [r7, #12]
 801258c:	f103 0410 	add.w	r4, r3, #16
 8012590:	68f8      	ldr	r0, [r7, #12]
 8012592:	f7ff ff00 	bl	8012396 <lv_obj_get_opa_scale>
 8012596:	4603      	mov	r3, r0
 8012598:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801259a:	68b9      	ldr	r1, [r7, #8]
 801259c:	4620      	mov	r0, r4
 801259e:	f003 f9b0 	bl	8015902 <lv_draw_rect>
    }

    return true;
 80125a2:	2301      	movs	r3, #1
}
 80125a4:	4618      	mov	r0, r3
 80125a6:	372c      	adds	r7, #44	; 0x2c
 80125a8:	46bd      	mov	sp, r7
 80125aa:	bd90      	pop	{r4, r7, pc}

080125ac <lv_obj_signal>:
 * @param sign signal type
 * @param param parameter for the signal (depends on signal type)
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_obj_signal(lv_obj_t * obj, lv_signal_t sign, void * param)
{
 80125ac:	b580      	push	{r7, lr}
 80125ae:	b088      	sub	sp, #32
 80125b0:	af00      	add	r7, sp, #0
 80125b2:	60f8      	str	r0, [r7, #12]
 80125b4:	460b      	mov	r3, r1
 80125b6:	607a      	str	r2, [r7, #4]
 80125b8:	72fb      	strb	r3, [r7, #11]
    (void)param;

    lv_res_t res = LV_RES_OK;
 80125ba:	2301      	movs	r3, #1
 80125bc:	77fb      	strb	r3, [r7, #31]

    const lv_style_t * style = lv_obj_get_style(obj);
 80125be:	68f8      	ldr	r0, [r7, #12]
 80125c0:	f7ff fe18 	bl	80121f4 <lv_obj_get_style>
 80125c4:	61b8      	str	r0, [r7, #24]

    if(sign == LV_SIGNAL_CHILD_CHG) {
 80125c6:	7afb      	ldrb	r3, [r7, #11]
 80125c8:	2b01      	cmp	r3, #1
 80125ca:	d109      	bne.n	80125e0 <lv_obj_signal+0x34>
        /*Return 'invalid' if the child change signal is not enabled*/
        if(lv_obj_is_protected(obj, LV_PROTECT_CHILD_CHG) != false) res = LV_RES_INV;
 80125cc:	2101      	movs	r1, #1
 80125ce:	68f8      	ldr	r0, [r7, #12]
 80125d0:	f7ff ff00 	bl	80123d4 <lv_obj_is_protected>
 80125d4:	4603      	mov	r3, r0
 80125d6:	2b00      	cmp	r3, #0
 80125d8:	d022      	beq.n	8012620 <lv_obj_signal+0x74>
 80125da:	2300      	movs	r3, #0
 80125dc:	77fb      	strb	r3, [r7, #31]
 80125de:	e01f      	b.n	8012620 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 80125e0:	7afb      	ldrb	r3, [r7, #11]
 80125e2:	2b05      	cmp	r3, #5
 80125e4:	d10d      	bne.n	8012602 <lv_obj_signal+0x56>
        if(style->body.shadow.width > obj->ext_draw_pad) obj->ext_draw_pad = style->body.shadow.width;
 80125e6:	69bb      	ldr	r3, [r7, #24]
 80125e8:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 80125ec:	68fb      	ldr	r3, [r7, #12]
 80125ee:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80125f2:	429a      	cmp	r2, r3
 80125f4:	dd14      	ble.n	8012620 <lv_obj_signal+0x74>
 80125f6:	69bb      	ldr	r3, [r7, #24]
 80125f8:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 80125fc:	68fb      	ldr	r3, [r7, #12]
 80125fe:	869a      	strh	r2, [r3, #52]	; 0x34
 8012600:	e00e      	b.n	8012620 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 8012602:	7afb      	ldrb	r3, [r7, #11]
 8012604:	2b04      	cmp	r3, #4
 8012606:	d103      	bne.n	8012610 <lv_obj_signal+0x64>
        lv_obj_refresh_ext_draw_pad(obj);
 8012608:	68f8      	ldr	r0, [r7, #12]
 801260a:	f7ff fceb 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>
 801260e:	e007      	b.n	8012620 <lv_obj_signal+0x74>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 8012610:	7afb      	ldrb	r3, [r7, #11]
 8012612:	2b06      	cmp	r3, #6
 8012614:	d104      	bne.n	8012620 <lv_obj_signal+0x74>
        lv_obj_type_t * buf = param;
 8012616:	687b      	ldr	r3, [r7, #4]
 8012618:	617b      	str	r3, [r7, #20]
        buf->type[0]        = "lv_obj";
 801261a:	697b      	ldr	r3, [r7, #20]
 801261c:	4a03      	ldr	r2, [pc, #12]	; (801262c <lv_obj_signal+0x80>)
 801261e:	601a      	str	r2, [r3, #0]
    }

    return res;
 8012620:	7ffb      	ldrb	r3, [r7, #31]
}
 8012622:	4618      	mov	r0, r3
 8012624:	3720      	adds	r7, #32
 8012626:	46bd      	mov	sp, r7
 8012628:	bd80      	pop	{r7, pc}
 801262a:	bf00      	nop
 801262c:	08028860 	.word	0x08028860

08012630 <refresh_children_position>:
 * @param obj pointer to an object which children will be repositioned
 * @param x_diff x coordinate shift
 * @param y_diff y coordinate shift
 */
static void refresh_children_position(lv_obj_t * obj, lv_coord_t x_diff, lv_coord_t y_diff)
{
 8012630:	b580      	push	{r7, lr}
 8012632:	b084      	sub	sp, #16
 8012634:	af00      	add	r7, sp, #0
 8012636:	6078      	str	r0, [r7, #4]
 8012638:	460b      	mov	r3, r1
 801263a:	807b      	strh	r3, [r7, #2]
 801263c:	4613      	mov	r3, r2
 801263e:	803b      	strh	r3, [r7, #0]
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 8012640:	687b      	ldr	r3, [r7, #4]
 8012642:	3304      	adds	r3, #4
 8012644:	4618      	mov	r0, r3
 8012646:	f009 ffd9 	bl	801c5fc <lv_ll_get_head>
 801264a:	60f8      	str	r0, [r7, #12]
 801264c:	e036      	b.n	80126bc <refresh_children_position+0x8c>
    {
        i->coords.x1 += x_diff;
 801264e:	68fb      	ldr	r3, [r7, #12]
 8012650:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8012654:	b29a      	uxth	r2, r3
 8012656:	887b      	ldrh	r3, [r7, #2]
 8012658:	4413      	add	r3, r2
 801265a:	b29b      	uxth	r3, r3
 801265c:	b21a      	sxth	r2, r3
 801265e:	68fb      	ldr	r3, [r7, #12]
 8012660:	821a      	strh	r2, [r3, #16]
        i->coords.y1 += y_diff;
 8012662:	68fb      	ldr	r3, [r7, #12]
 8012664:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8012668:	b29a      	uxth	r2, r3
 801266a:	883b      	ldrh	r3, [r7, #0]
 801266c:	4413      	add	r3, r2
 801266e:	b29b      	uxth	r3, r3
 8012670:	b21a      	sxth	r2, r3
 8012672:	68fb      	ldr	r3, [r7, #12]
 8012674:	825a      	strh	r2, [r3, #18]
        i->coords.x2 += x_diff;
 8012676:	68fb      	ldr	r3, [r7, #12]
 8012678:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 801267c:	b29a      	uxth	r2, r3
 801267e:	887b      	ldrh	r3, [r7, #2]
 8012680:	4413      	add	r3, r2
 8012682:	b29b      	uxth	r3, r3
 8012684:	b21a      	sxth	r2, r3
 8012686:	68fb      	ldr	r3, [r7, #12]
 8012688:	829a      	strh	r2, [r3, #20]
        i->coords.y2 += y_diff;
 801268a:	68fb      	ldr	r3, [r7, #12]
 801268c:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8012690:	b29a      	uxth	r2, r3
 8012692:	883b      	ldrh	r3, [r7, #0]
 8012694:	4413      	add	r3, r2
 8012696:	b29b      	uxth	r3, r3
 8012698:	b21a      	sxth	r2, r3
 801269a:	68fb      	ldr	r3, [r7, #12]
 801269c:	82da      	strh	r2, [r3, #22]

        refresh_children_position(i, x_diff, y_diff);
 801269e:	f9b7 2000 	ldrsh.w	r2, [r7]
 80126a2:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80126a6:	4619      	mov	r1, r3
 80126a8:	68f8      	ldr	r0, [r7, #12]
 80126aa:	f7ff ffc1 	bl	8012630 <refresh_children_position>
    LV_LL_READ(obj->child_ll, i)
 80126ae:	687b      	ldr	r3, [r7, #4]
 80126b0:	3304      	adds	r3, #4
 80126b2:	68f9      	ldr	r1, [r7, #12]
 80126b4:	4618      	mov	r0, r3
 80126b6:	f009 ffc7 	bl	801c648 <lv_ll_get_next>
 80126ba:	60f8      	str	r0, [r7, #12]
 80126bc:	68fb      	ldr	r3, [r7, #12]
 80126be:	2b00      	cmp	r3, #0
 80126c0:	d1c5      	bne.n	801264e <refresh_children_position+0x1e>
    }
}
 80126c2:	bf00      	nop
 80126c4:	3710      	adds	r7, #16
 80126c6:	46bd      	mov	sp, r7
 80126c8:	bd80      	pop	{r7, pc}

080126ca <report_style_mod_core>:
 * Refresh the style of all children of an object. (Called recursively)
 * @param style_p refresh objects only with this style.
 * @param obj pointer to an object
 */
static void report_style_mod_core(void * style_p, lv_obj_t * obj)
{
 80126ca:	b580      	push	{r7, lr}
 80126cc:	b084      	sub	sp, #16
 80126ce:	af00      	add	r7, sp, #0
 80126d0:	6078      	str	r0, [r7, #4]
 80126d2:	6039      	str	r1, [r7, #0]
    lv_obj_t * i;
    LV_LL_READ(obj->child_ll, i)
 80126d4:	683b      	ldr	r3, [r7, #0]
 80126d6:	3304      	adds	r3, #4
 80126d8:	4618      	mov	r0, r3
 80126da:	f009 ff8f 	bl	801c5fc <lv_ll_get_head>
 80126de:	60f8      	str	r0, [r7, #12]
 80126e0:	e018      	b.n	8012714 <report_style_mod_core+0x4a>
    {
        if(i->style_p == style_p || style_p == NULL) {
 80126e2:	68fb      	ldr	r3, [r7, #12]
 80126e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80126e6:	687a      	ldr	r2, [r7, #4]
 80126e8:	429a      	cmp	r2, r3
 80126ea:	d002      	beq.n	80126f2 <report_style_mod_core+0x28>
 80126ec:	687b      	ldr	r3, [r7, #4]
 80126ee:	2b00      	cmp	r3, #0
 80126f0:	d105      	bne.n	80126fe <report_style_mod_core+0x34>
            refresh_children_style(i);
 80126f2:	68f8      	ldr	r0, [r7, #12]
 80126f4:	f000 f815 	bl	8012722 <refresh_children_style>
            lv_obj_refresh_style(i);
 80126f8:	68f8      	ldr	r0, [r7, #12]
 80126fa:	f7ff faec 	bl	8011cd6 <lv_obj_refresh_style>
        }

        report_style_mod_core(style_p, i);
 80126fe:	68f9      	ldr	r1, [r7, #12]
 8012700:	6878      	ldr	r0, [r7, #4]
 8012702:	f7ff ffe2 	bl	80126ca <report_style_mod_core>
    LV_LL_READ(obj->child_ll, i)
 8012706:	683b      	ldr	r3, [r7, #0]
 8012708:	3304      	adds	r3, #4
 801270a:	68f9      	ldr	r1, [r7, #12]
 801270c:	4618      	mov	r0, r3
 801270e:	f009 ff9b 	bl	801c648 <lv_ll_get_next>
 8012712:	60f8      	str	r0, [r7, #12]
 8012714:	68fb      	ldr	r3, [r7, #12]
 8012716:	2b00      	cmp	r3, #0
 8012718:	d1e3      	bne.n	80126e2 <report_style_mod_core+0x18>
    }
}
 801271a:	bf00      	nop
 801271c:	3710      	adds	r7, #16
 801271e:	46bd      	mov	sp, r7
 8012720:	bd80      	pop	{r7, pc}

08012722 <refresh_children_style>:
 * Recursively refresh the style of the children. Go deeper until a not NULL style is found
 * because the NULL styles are inherited from the parent
 * @param obj pointer to an object
 */
static void refresh_children_style(lv_obj_t * obj)
{
 8012722:	b580      	push	{r7, lr}
 8012724:	b084      	sub	sp, #16
 8012726:	af00      	add	r7, sp, #0
 8012728:	6078      	str	r0, [r7, #4]
    lv_obj_t * child = lv_obj_get_child(obj, NULL);
 801272a:	2100      	movs	r1, #0
 801272c:	6878      	ldr	r0, [r7, #4]
 801272e:	f7ff fcd3 	bl	80120d8 <lv_obj_get_child>
 8012732:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 8012734:	e01a      	b.n	801276c <refresh_children_style+0x4a>
        if(child->style_p == NULL) {
 8012736:	68fb      	ldr	r3, [r7, #12]
 8012738:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801273a:	2b00      	cmp	r3, #0
 801273c:	d106      	bne.n	801274c <refresh_children_style+0x2a>
            refresh_children_style(child); /*Check children too*/
 801273e:	68f8      	ldr	r0, [r7, #12]
 8012740:	f7ff ffef 	bl	8012722 <refresh_children_style>
            lv_obj_refresh_style(child);   /*Notify the child about the style change*/
 8012744:	68f8      	ldr	r0, [r7, #12]
 8012746:	f7ff fac6 	bl	8011cd6 <lv_obj_refresh_style>
 801274a:	e00a      	b.n	8012762 <refresh_children_style+0x40>
        } else if(child->style_p->glass) {
 801274c:	68fb      	ldr	r3, [r7, #12]
 801274e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8012750:	781b      	ldrb	r3, [r3, #0]
 8012752:	f003 0301 	and.w	r3, r3, #1
 8012756:	b2db      	uxtb	r3, r3
 8012758:	2b00      	cmp	r3, #0
 801275a:	d002      	beq.n	8012762 <refresh_children_style+0x40>
            /*Children with 'glass' parent might be effected if their style == NULL*/
            refresh_children_style(child);
 801275c:	68f8      	ldr	r0, [r7, #12]
 801275e:	f7ff ffe0 	bl	8012722 <refresh_children_style>
        }
        child = lv_obj_get_child(obj, child);
 8012762:	68f9      	ldr	r1, [r7, #12]
 8012764:	6878      	ldr	r0, [r7, #4]
 8012766:	f7ff fcb7 	bl	80120d8 <lv_obj_get_child>
 801276a:	60f8      	str	r0, [r7, #12]
    while(child != NULL) {
 801276c:	68fb      	ldr	r3, [r7, #12]
 801276e:	2b00      	cmp	r3, #0
 8012770:	d1e1      	bne.n	8012736 <refresh_children_style+0x14>
    }
}
 8012772:	bf00      	nop
 8012774:	3710      	adds	r7, #16
 8012776:	46bd      	mov	sp, r7
 8012778:	bd80      	pop	{r7, pc}

0801277a <delete_children>:
/**
 * Called by 'lv_obj_del' to delete the children objects
 * @param obj pointer to an object (all of its children will be deleted)
 */
static void delete_children(lv_obj_t * obj)
{
 801277a:	b580      	push	{r7, lr}
 801277c:	b088      	sub	sp, #32
 801277e:	af00      	add	r7, sp, #0
 8012780:	6078      	str	r0, [r7, #4]
    lv_obj_t * i;
    lv_obj_t * i_next;
    i = lv_ll_get_head(&(obj->child_ll));
 8012782:	687b      	ldr	r3, [r7, #4]
 8012784:	3304      	adds	r3, #4
 8012786:	4618      	mov	r0, r3
 8012788:	f009 ff38 	bl	801c5fc <lv_ll_get_head>
 801278c:	61f8      	str	r0, [r7, #28]

    /*Remove from the group; remove before transversing children so that
     * the object still has access to all children during the
     * LV_SIGNAL_DEFOCUS call*/
#if LV_USE_GROUP
    lv_group_t * group = lv_obj_get_group(obj);
 801278e:	6878      	ldr	r0, [r7, #4]
 8012790:	f7ff fe5b 	bl	801244a <lv_obj_get_group>
 8012794:	6178      	str	r0, [r7, #20]
    if(group) lv_group_remove_obj(obj);
 8012796:	697b      	ldr	r3, [r7, #20]
 8012798:	2b00      	cmp	r3, #0
 801279a:	d00f      	beq.n	80127bc <delete_children+0x42>
 801279c:	6878      	ldr	r0, [r7, #4]
 801279e:	f7fb fca7 	bl	800e0f0 <lv_group_remove_obj>
#endif

    while(i != NULL) {
 80127a2:	e00b      	b.n	80127bc <delete_children+0x42>
        /*Get the next object before delete this*/
        i_next = lv_ll_get_next(&(obj->child_ll), i);
 80127a4:	687b      	ldr	r3, [r7, #4]
 80127a6:	3304      	adds	r3, #4
 80127a8:	69f9      	ldr	r1, [r7, #28]
 80127aa:	4618      	mov	r0, r3
 80127ac:	f009 ff4c 	bl	801c648 <lv_ll_get_next>
 80127b0:	60f8      	str	r0, [r7, #12]

        /*Call the recursive del to the child too*/
        delete_children(i);
 80127b2:	69f8      	ldr	r0, [r7, #28]
 80127b4:	f7ff ffe1 	bl	801277a <delete_children>

        /*Set i to the next node*/
        i = i_next;
 80127b8:	68fb      	ldr	r3, [r7, #12]
 80127ba:	61fb      	str	r3, [r7, #28]
    while(i != NULL) {
 80127bc:	69fb      	ldr	r3, [r7, #28]
 80127be:	2b00      	cmp	r3, #0
 80127c0:	d1f0      	bne.n	80127a4 <delete_children+0x2a>
    }

    /*Let the suer free the resources used in `LV_EVENT_DELETE`*/
    lv_event_send(obj, LV_EVENT_DELETE, NULL);
 80127c2:	2200      	movs	r2, #0
 80127c4:	2113      	movs	r1, #19
 80127c6:	6878      	ldr	r0, [r7, #4]
 80127c8:	f7ff fb49 	bl	8011e5e <lv_event_send>

    lv_event_mark_deleted(obj);
 80127cc:	6878      	ldr	r0, [r7, #4]
 80127ce:	f000 f853 	bl	8012878 <lv_event_mark_deleted>

    /*Remove the animations from this object*/
#if LV_USE_ANIMATION
    lv_anim_del(obj, NULL);
 80127d2:	2100      	movs	r1, #0
 80127d4:	6878      	ldr	r0, [r7, #4]
 80127d6:	f008 ff03 	bl	801b5e0 <lv_anim_del>
#endif

    /* Reset the input devices if
     * the object to delete is used*/
    lv_indev_t * indev = lv_indev_get_next(NULL);
 80127da:	2000      	movs	r0, #0
 80127dc:	f008 fe0e 	bl	801b3fc <lv_indev_get_next>
 80127e0:	61b8      	str	r0, [r7, #24]
    while(indev) {
 80127e2:	e026      	b.n	8012832 <delete_children+0xb8>
        if(indev->proc.types.pointer.act_obj == obj || indev->proc.types.pointer.last_obj == obj) {
 80127e4:	69bb      	ldr	r3, [r7, #24]
 80127e6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80127e8:	687a      	ldr	r2, [r7, #4]
 80127ea:	429a      	cmp	r2, r3
 80127ec:	d004      	beq.n	80127f8 <delete_children+0x7e>
 80127ee:	69bb      	ldr	r3, [r7, #24]
 80127f0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80127f2:	687a      	ldr	r2, [r7, #4]
 80127f4:	429a      	cmp	r2, r3
 80127f6:	d102      	bne.n	80127fe <delete_children+0x84>
            lv_indev_reset(indev);
 80127f8:	69b8      	ldr	r0, [r7, #24]
 80127fa:	f7fc f9ca 	bl	800eb92 <lv_indev_reset>
        }

        if(indev->proc.types.pointer.last_pressed == obj) {
 80127fe:	69bb      	ldr	r3, [r7, #24]
 8012800:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8012802:	687a      	ldr	r2, [r7, #4]
 8012804:	429a      	cmp	r2, r3
 8012806:	d102      	bne.n	801280e <delete_children+0x94>
            indev->proc.types.pointer.last_pressed = NULL;
 8012808:	69bb      	ldr	r3, [r7, #24]
 801280a:	2200      	movs	r2, #0
 801280c:	641a      	str	r2, [r3, #64]	; 0x40
        }
#if LV_USE_GROUP
        if(indev->group == group && obj == lv_indev_get_obj_act()) {
 801280e:	69bb      	ldr	r3, [r7, #24]
 8012810:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8012812:	697a      	ldr	r2, [r7, #20]
 8012814:	429a      	cmp	r2, r3
 8012816:	d108      	bne.n	801282a <delete_children+0xb0>
 8012818:	f7fc fa58 	bl	800eccc <lv_indev_get_obj_act>
 801281c:	4602      	mov	r2, r0
 801281e:	687b      	ldr	r3, [r7, #4]
 8012820:	4293      	cmp	r3, r2
 8012822:	d102      	bne.n	801282a <delete_children+0xb0>
            lv_indev_reset(indev);
 8012824:	69b8      	ldr	r0, [r7, #24]
 8012826:	f7fc f9b4 	bl	800eb92 <lv_indev_reset>
        }
#endif
        indev = lv_indev_get_next(indev);
 801282a:	69b8      	ldr	r0, [r7, #24]
 801282c:	f008 fde6 	bl	801b3fc <lv_indev_get_next>
 8012830:	61b8      	str	r0, [r7, #24]
    while(indev) {
 8012832:	69bb      	ldr	r3, [r7, #24]
 8012834:	2b00      	cmp	r3, #0
 8012836:	d1d5      	bne.n	80127e4 <delete_children+0x6a>
    }

    /*Remove the object from parent's children list*/
    lv_obj_t * par = lv_obj_get_parent(obj);
 8012838:	6878      	ldr	r0, [r7, #4]
 801283a:	f7ff fc41 	bl	80120c0 <lv_obj_get_parent>
 801283e:	6138      	str	r0, [r7, #16]
    lv_ll_rem(&(par->child_ll), obj);
 8012840:	693b      	ldr	r3, [r7, #16]
 8012842:	3304      	adds	r3, #4
 8012844:	6879      	ldr	r1, [r7, #4]
 8012846:	4618      	mov	r0, r3
 8012848:	f009 fe2a 	bl	801c4a0 <lv_ll_rem>

    /* Clean up the object specific data*/
    obj->signal_cb(obj, LV_SIGNAL_CLEANUP, NULL);
 801284c:	687b      	ldr	r3, [r7, #4]
 801284e:	69db      	ldr	r3, [r3, #28]
 8012850:	2200      	movs	r2, #0
 8012852:	2100      	movs	r1, #0
 8012854:	6878      	ldr	r0, [r7, #4]
 8012856:	4798      	blx	r3

    /*Delete the base objects*/
    if(obj->ext_attr != NULL) lv_mem_free(obj->ext_attr);
 8012858:	687b      	ldr	r3, [r7, #4]
 801285a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801285c:	2b00      	cmp	r3, #0
 801285e:	d004      	beq.n	801286a <delete_children+0xf0>
 8012860:	687b      	ldr	r3, [r7, #4]
 8012862:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8012864:	4618      	mov	r0, r3
 8012866:	f00a f85d 	bl	801c924 <lv_mem_free>
    lv_mem_free(obj); /*Free the object itself*/
 801286a:	6878      	ldr	r0, [r7, #4]
 801286c:	f00a f85a 	bl	801c924 <lv_mem_free>
}
 8012870:	bf00      	nop
 8012872:	3720      	adds	r7, #32
 8012874:	46bd      	mov	sp, r7
 8012876:	bd80      	pop	{r7, pc}

08012878 <lv_event_mark_deleted>:

static void lv_event_mark_deleted(lv_obj_t * obj)
{
 8012878:	b480      	push	{r7}
 801287a:	b085      	sub	sp, #20
 801287c:	af00      	add	r7, sp, #0
 801287e:	6078      	str	r0, [r7, #4]
    lv_event_temp_data_t * t = event_temp_data_head;
 8012880:	4b0b      	ldr	r3, [pc, #44]	; (80128b0 <lv_event_mark_deleted+0x38>)
 8012882:	681b      	ldr	r3, [r3, #0]
 8012884:	60fb      	str	r3, [r7, #12]

    while(t) {
 8012886:	e00a      	b.n	801289e <lv_event_mark_deleted+0x26>
        if(t->obj == obj) t->deleted = true;
 8012888:	68fb      	ldr	r3, [r7, #12]
 801288a:	681b      	ldr	r3, [r3, #0]
 801288c:	687a      	ldr	r2, [r7, #4]
 801288e:	429a      	cmp	r2, r3
 8012890:	d102      	bne.n	8012898 <lv_event_mark_deleted+0x20>
 8012892:	68fb      	ldr	r3, [r7, #12]
 8012894:	2201      	movs	r2, #1
 8012896:	711a      	strb	r2, [r3, #4]
        t = t->prev;
 8012898:	68fb      	ldr	r3, [r7, #12]
 801289a:	689b      	ldr	r3, [r3, #8]
 801289c:	60fb      	str	r3, [r7, #12]
    while(t) {
 801289e:	68fb      	ldr	r3, [r7, #12]
 80128a0:	2b00      	cmp	r3, #0
 80128a2:	d1f1      	bne.n	8012888 <lv_event_mark_deleted+0x10>
    }
}
 80128a4:	bf00      	nop
 80128a6:	3714      	adds	r7, #20
 80128a8:	46bd      	mov	sp, r7
 80128aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128ae:	4770      	bx	lr
 80128b0:	20003fa0 	.word	0x20003fa0

080128b4 <lv_area_copy>:
{
 80128b4:	b580      	push	{r7, lr}
 80128b6:	b082      	sub	sp, #8
 80128b8:	af00      	add	r7, sp, #0
 80128ba:	6078      	str	r0, [r7, #4]
 80128bc:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80128be:	2208      	movs	r2, #8
 80128c0:	6839      	ldr	r1, [r7, #0]
 80128c2:	6878      	ldr	r0, [r7, #4]
 80128c4:	f014 fc7a 	bl	80271bc <memcpy>
}
 80128c8:	bf00      	nop
 80128ca:	3708      	adds	r7, #8
 80128cc:	46bd      	mov	sp, r7
 80128ce:	bd80      	pop	{r7, pc}

080128d0 <lv_area_get_width>:
{
 80128d0:	b480      	push	{r7}
 80128d2:	b083      	sub	sp, #12
 80128d4:	af00      	add	r7, sp, #0
 80128d6:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80128d8:	687b      	ldr	r3, [r7, #4]
 80128da:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80128de:	b29a      	uxth	r2, r3
 80128e0:	687b      	ldr	r3, [r7, #4]
 80128e2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80128e6:	b29b      	uxth	r3, r3
 80128e8:	1ad3      	subs	r3, r2, r3
 80128ea:	b29b      	uxth	r3, r3
 80128ec:	3301      	adds	r3, #1
 80128ee:	b29b      	uxth	r3, r3
 80128f0:	b21b      	sxth	r3, r3
}
 80128f2:	4618      	mov	r0, r3
 80128f4:	370c      	adds	r7, #12
 80128f6:	46bd      	mov	sp, r7
 80128f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80128fc:	4770      	bx	lr

080128fe <lv_area_get_height>:
{
 80128fe:	b480      	push	{r7}
 8012900:	b083      	sub	sp, #12
 8012902:	af00      	add	r7, sp, #0
 8012904:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 8012906:	687b      	ldr	r3, [r7, #4]
 8012908:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801290c:	b29a      	uxth	r2, r3
 801290e:	687b      	ldr	r3, [r7, #4]
 8012910:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012914:	b29b      	uxth	r3, r3
 8012916:	1ad3      	subs	r3, r2, r3
 8012918:	b29b      	uxth	r3, r3
 801291a:	3301      	adds	r3, #1
 801291c:	b29b      	uxth	r3, r3
 801291e:	b21b      	sxth	r3, r3
}
 8012920:	4618      	mov	r0, r3
 8012922:	370c      	adds	r7, #12
 8012924:	46bd      	mov	sp, r7
 8012926:	f85d 7b04 	ldr.w	r7, [sp], #4
 801292a:	4770      	bx	lr

0801292c <lv_refr_init>:

/**
 * Initialize the screen refresh subsystem
 */
void lv_refr_init(void)
{
 801292c:	b480      	push	{r7}
 801292e:	af00      	add	r7, sp, #0
    /*Nothing to do*/
}
 8012930:	bf00      	nop
 8012932:	46bd      	mov	sp, r7
 8012934:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012938:	4770      	bx	lr
	...

0801293c <lv_inv_area>:
 * @param area_p pointer to area which should be invalidated (NULL: delete the invalidated areas)
 * @param disp pointer to display where the area should be invalidated (NULL can be used if there is
 * only one display)
 */
void lv_inv_area(lv_disp_t * disp, const lv_area_t * area_p)
{
 801293c:	b580      	push	{r7, lr}
 801293e:	b088      	sub	sp, #32
 8012940:	af00      	add	r7, sp, #0
 8012942:	6078      	str	r0, [r7, #4]
 8012944:	6039      	str	r1, [r7, #0]
    if(!disp) disp = lv_disp_get_default();
 8012946:	687b      	ldr	r3, [r7, #4]
 8012948:	2b00      	cmp	r3, #0
 801294a:	d102      	bne.n	8012952 <lv_inv_area+0x16>
 801294c:	f008 fbbe 	bl	801b0cc <lv_disp_get_default>
 8012950:	6078      	str	r0, [r7, #4]
    if(!disp) return;
 8012952:	687b      	ldr	r3, [r7, #4]
 8012954:	2b00      	cmp	r3, #0
 8012956:	f000 809b 	beq.w	8012a90 <lv_inv_area+0x154>

    /*Clear the invalidate buffer if the parameter is NULL*/
    if(area_p == NULL) {
 801295a:	683b      	ldr	r3, [r7, #0]
 801295c:	2b00      	cmp	r3, #0
 801295e:	d107      	bne.n	8012970 <lv_inv_area+0x34>
        disp->inv_p = 0;
 8012960:	687a      	ldr	r2, [r7, #4]
 8012962:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 8012966:	f36f 0309 	bfc	r3, #0, #10
 801296a:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168
        return;
 801296e:	e092      	b.n	8012a96 <lv_inv_area+0x15a>
    }

    lv_area_t scr_area;
    scr_area.x1 = 0;
 8012970:	2300      	movs	r3, #0
 8012972:	82bb      	strh	r3, [r7, #20]
    scr_area.y1 = 0;
 8012974:	2300      	movs	r3, #0
 8012976:	82fb      	strh	r3, [r7, #22]
    scr_area.x2 = lv_disp_get_hor_res(disp) - 1;
 8012978:	6878      	ldr	r0, [r7, #4]
 801297a:	f008 fbb3 	bl	801b0e4 <lv_disp_get_hor_res>
 801297e:	4603      	mov	r3, r0
 8012980:	b29b      	uxth	r3, r3
 8012982:	3b01      	subs	r3, #1
 8012984:	b29b      	uxth	r3, r3
 8012986:	b21b      	sxth	r3, r3
 8012988:	833b      	strh	r3, [r7, #24]
    scr_area.y2 = lv_disp_get_ver_res(disp) - 1;
 801298a:	6878      	ldr	r0, [r7, #4]
 801298c:	f008 fbcc 	bl	801b128 <lv_disp_get_ver_res>
 8012990:	4603      	mov	r3, r0
 8012992:	b29b      	uxth	r3, r3
 8012994:	3b01      	subs	r3, #1
 8012996:	b29b      	uxth	r3, r3
 8012998:	b21b      	sxth	r3, r3
 801299a:	837b      	strh	r3, [r7, #26]

    lv_area_t com_area;
    bool suc;

    suc = lv_area_intersect(&com_area, area_p, &scr_area);
 801299c:	f107 0214 	add.w	r2, r7, #20
 80129a0:	f107 030c 	add.w	r3, r7, #12
 80129a4:	6839      	ldr	r1, [r7, #0]
 80129a6:	4618      	mov	r0, r3
 80129a8:	f009 f896 	bl	801bad8 <lv_area_intersect>
 80129ac:	4603      	mov	r3, r0
 80129ae:	777b      	strb	r3, [r7, #29]

    /*The area is truncated to the screen*/
    if(suc != false) {
 80129b0:	7f7b      	ldrb	r3, [r7, #29]
 80129b2:	2b00      	cmp	r3, #0
 80129b4:	d06f      	beq.n	8012a96 <lv_inv_area+0x15a>
        if(disp->driver.rounder_cb) disp->driver.rounder_cb(&disp_refr->driver, &com_area);
 80129b6:	687b      	ldr	r3, [r7, #4]
 80129b8:	691b      	ldr	r3, [r3, #16]
 80129ba:	2b00      	cmp	r3, #0
 80129bc:	d008      	beq.n	80129d0 <lv_inv_area+0x94>
 80129be:	687b      	ldr	r3, [r7, #4]
 80129c0:	691b      	ldr	r3, [r3, #16]
 80129c2:	4a36      	ldr	r2, [pc, #216]	; (8012a9c <lv_inv_area+0x160>)
 80129c4:	6812      	ldr	r2, [r2, #0]
 80129c6:	4610      	mov	r0, r2
 80129c8:	f107 020c 	add.w	r2, r7, #12
 80129cc:	4611      	mov	r1, r2
 80129ce:	4798      	blx	r3

        /*Save only if this area is not in one of the saved areas*/
        uint16_t i;
        for(i = 0; i < disp->inv_p; i++) {
 80129d0:	2300      	movs	r3, #0
 80129d2:	83fb      	strh	r3, [r7, #30]
 80129d4:	e010      	b.n	80129f8 <lv_inv_area+0xbc>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
 80129d6:	8bfb      	ldrh	r3, [r7, #30]
 80129d8:	3309      	adds	r3, #9
 80129da:	00db      	lsls	r3, r3, #3
 80129dc:	687a      	ldr	r2, [r7, #4]
 80129de:	441a      	add	r2, r3
 80129e0:	f107 030c 	add.w	r3, r7, #12
 80129e4:	4611      	mov	r1, r2
 80129e6:	4618      	mov	r0, r3
 80129e8:	f009 f961 	bl	801bcae <lv_area_is_in>
 80129ec:	4603      	mov	r3, r0
 80129ee:	2b00      	cmp	r3, #0
 80129f0:	d150      	bne.n	8012a94 <lv_inv_area+0x158>
        for(i = 0; i < disp->inv_p; i++) {
 80129f2:	8bfb      	ldrh	r3, [r7, #30]
 80129f4:	3301      	adds	r3, #1
 80129f6:	83fb      	strh	r3, [r7, #30]
 80129f8:	687b      	ldr	r3, [r7, #4]
 80129fa:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 80129fe:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012a02:	b29b      	uxth	r3, r3
 8012a04:	461a      	mov	r2, r3
 8012a06:	8bfb      	ldrh	r3, [r7, #30]
 8012a08:	4293      	cmp	r3, r2
 8012a0a:	d3e4      	bcc.n	80129d6 <lv_inv_area+0x9a>
        }

        /*Save the area*/
        if(disp->inv_p < LV_INV_BUF_SIZE) {
 8012a0c:	687b      	ldr	r3, [r7, #4]
 8012a0e:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012a12:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012a16:	b29b      	uxth	r3, r3
 8012a18:	2b1f      	cmp	r3, #31
 8012a1a:	d810      	bhi.n	8012a3e <lv_inv_area+0x102>
            lv_area_copy(&disp->inv_areas[disp->inv_p], &com_area);
 8012a1c:	687b      	ldr	r3, [r7, #4]
 8012a1e:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012a22:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012a26:	b29b      	uxth	r3, r3
 8012a28:	3309      	adds	r3, #9
 8012a2a:	00db      	lsls	r3, r3, #3
 8012a2c:	687a      	ldr	r2, [r7, #4]
 8012a2e:	4413      	add	r3, r2
 8012a30:	f107 020c 	add.w	r2, r7, #12
 8012a34:	4611      	mov	r1, r2
 8012a36:	4618      	mov	r0, r3
 8012a38:	f7ff ff3c 	bl	80128b4 <lv_area_copy>
 8012a3c:	e016      	b.n	8012a6c <lv_inv_area+0x130>
        } else { /*If no place for the area add the screen*/
            disp->inv_p = 0;
 8012a3e:	687a      	ldr	r2, [r7, #4]
 8012a40:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 8012a44:	f36f 0309 	bfc	r3, #0, #10
 8012a48:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168
            lv_area_copy(&disp->inv_areas[disp->inv_p], &scr_area);
 8012a4c:	687b      	ldr	r3, [r7, #4]
 8012a4e:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012a52:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012a56:	b29b      	uxth	r3, r3
 8012a58:	3309      	adds	r3, #9
 8012a5a:	00db      	lsls	r3, r3, #3
 8012a5c:	687a      	ldr	r2, [r7, #4]
 8012a5e:	4413      	add	r3, r2
 8012a60:	f107 0214 	add.w	r2, r7, #20
 8012a64:	4611      	mov	r1, r2
 8012a66:	4618      	mov	r0, r3
 8012a68:	f7ff ff24 	bl	80128b4 <lv_area_copy>
        }
        disp->inv_p++;
 8012a6c:	687b      	ldr	r3, [r7, #4]
 8012a6e:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012a72:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012a76:	b29b      	uxth	r3, r3
 8012a78:	3301      	adds	r3, #1
 8012a7a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012a7e:	b299      	uxth	r1, r3
 8012a80:	687a      	ldr	r2, [r7, #4]
 8012a82:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 8012a86:	f361 0309 	bfi	r3, r1, #0, #10
 8012a8a:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168
 8012a8e:	e002      	b.n	8012a96 <lv_inv_area+0x15a>
    if(!disp) return;
 8012a90:	bf00      	nop
 8012a92:	e000      	b.n	8012a96 <lv_inv_area+0x15a>
            if(lv_area_is_in(&com_area, &disp->inv_areas[i]) != false) return;
 8012a94:	bf00      	nop
    }
}
 8012a96:	3720      	adds	r7, #32
 8012a98:	46bd      	mov	sp, r7
 8012a9a:	bd80      	pop	{r7, pc}
 8012a9c:	20003fac 	.word	0x20003fac

08012aa0 <lv_refr_get_disp_refreshing>:
/**
 * Get the display which is being refreshed
 * @return the display being refreshed
 */
lv_disp_t * lv_refr_get_disp_refreshing(void)
{
 8012aa0:	b480      	push	{r7}
 8012aa2:	af00      	add	r7, sp, #0
    return disp_refr;
 8012aa4:	4b03      	ldr	r3, [pc, #12]	; (8012ab4 <lv_refr_get_disp_refreshing+0x14>)
 8012aa6:	681b      	ldr	r3, [r3, #0]
}
 8012aa8:	4618      	mov	r0, r3
 8012aaa:	46bd      	mov	sp, r7
 8012aac:	f85d 7b04 	ldr.w	r7, [sp], #4
 8012ab0:	4770      	bx	lr
 8012ab2:	bf00      	nop
 8012ab4:	20003fac 	.word	0x20003fac

08012ab8 <lv_disp_refr_task>:
/**
 * Called periodically to handle the refreshing
 * @param task pointer to the task itself
 */
void lv_disp_refr_task(lv_task_t * task)
{
 8012ab8:	b5b0      	push	{r4, r5, r7, lr}
 8012aba:	b08a      	sub	sp, #40	; 0x28
 8012abc:	af00      	add	r7, sp, #0
 8012abe:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("lv_refr_task: started");

    uint32_t start = lv_tick_get();
 8012ac0:	f008 fcf4 	bl	801b4ac <lv_tick_get>
 8012ac4:	61f8      	str	r0, [r7, #28]

    disp_refr = task->user_data;
 8012ac6:	687b      	ldr	r3, [r7, #4]
 8012ac8:	68db      	ldr	r3, [r3, #12]
 8012aca:	4a6c      	ldr	r2, [pc, #432]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012acc:	6013      	str	r3, [r2, #0]

    lv_refr_join_area();
 8012ace:	f000 f8d9 	bl	8012c84 <lv_refr_join_area>

    lv_refr_areas();
 8012ad2:	f000 f973 	bl	8012dbc <lv_refr_areas>

    /*If refresh happened ...*/
    if(disp_refr->inv_p != 0) {
 8012ad6:	4b69      	ldr	r3, [pc, #420]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012ad8:	681b      	ldr	r3, [r3, #0]
 8012ada:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012ade:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012ae2:	b29b      	uxth	r3, r3
 8012ae4:	2b00      	cmp	r3, #0
 8012ae6:	f000 80c2 	beq.w	8012c6e <lv_disp_refr_task+0x1b6>
        /*In true double buffered mode copy the refreshed areas to the new VDB to keep it up to
         * date*/
        if(lv_disp_is_true_double_buf(disp_refr)) {
 8012aea:	4b64      	ldr	r3, [pc, #400]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012aec:	681b      	ldr	r3, [r3, #0]
 8012aee:	4618      	mov	r0, r3
 8012af0:	f008 fbe5 	bl	801b2be <lv_disp_is_true_double_buf>
 8012af4:	4603      	mov	r3, r0
 8012af6:	2b00      	cmp	r3, #0
 8012af8:	f000 808b 	beq.w	8012c12 <lv_disp_refr_task+0x15a>
            lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8012afc:	4b5f      	ldr	r3, [pc, #380]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012afe:	681b      	ldr	r3, [r3, #0]
 8012b00:	4618      	mov	r0, r3
 8012b02:	f008 fb77 	bl	801b1f4 <lv_disp_get_buf>
 8012b06:	61b8      	str	r0, [r7, #24]

            /*Flush the content of the VDB*/
            lv_refr_vdb_flush();
 8012b08:	f000 fc68 	bl	80133dc <lv_refr_vdb_flush>

            /* With true double buffering the flushing should be only the address change of the
             * current frame buffer. Wait until the address change is ready and copy the changed
             * content to the other frame buffer (new active VDB) to keep the buffers synchronized*/
            while(vdb->flushing)
 8012b0c:	bf00      	nop
 8012b0e:	69bb      	ldr	r3, [r7, #24]
 8012b10:	699b      	ldr	r3, [r3, #24]
 8012b12:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8012b16:	b2db      	uxtb	r3, r3
 8012b18:	2b00      	cmp	r3, #0
 8012b1a:	d1f8      	bne.n	8012b0e <lv_disp_refr_task+0x56>
                ;

            uint8_t * buf_act = (uint8_t *)vdb->buf_act;
 8012b1c:	69bb      	ldr	r3, [r7, #24]
 8012b1e:	689b      	ldr	r3, [r3, #8]
 8012b20:	617b      	str	r3, [r7, #20]
            uint8_t * buf_ina = (uint8_t *)vdb->buf_act == vdb->buf1 ? vdb->buf2 : vdb->buf1;
 8012b22:	69bb      	ldr	r3, [r7, #24]
 8012b24:	689a      	ldr	r2, [r3, #8]
 8012b26:	69bb      	ldr	r3, [r7, #24]
 8012b28:	681b      	ldr	r3, [r3, #0]
 8012b2a:	429a      	cmp	r2, r3
 8012b2c:	d102      	bne.n	8012b34 <lv_disp_refr_task+0x7c>
 8012b2e:	69bb      	ldr	r3, [r7, #24]
 8012b30:	685b      	ldr	r3, [r3, #4]
 8012b32:	e001      	b.n	8012b38 <lv_disp_refr_task+0x80>
 8012b34:	69bb      	ldr	r3, [r7, #24]
 8012b36:	681b      	ldr	r3, [r3, #0]
 8012b38:	613b      	str	r3, [r7, #16]

            lv_coord_t hres = lv_disp_get_hor_res(disp_refr);
 8012b3a:	4b50      	ldr	r3, [pc, #320]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012b3c:	681b      	ldr	r3, [r3, #0]
 8012b3e:	4618      	mov	r0, r3
 8012b40:	f008 fad0 	bl	801b0e4 <lv_disp_get_hor_res>
 8012b44:	4603      	mov	r3, r0
 8012b46:	81fb      	strh	r3, [r7, #14]
            uint16_t a;
            for(a = 0; a < disp_refr->inv_p; a++) {
 8012b48:	2300      	movs	r3, #0
 8012b4a:	84fb      	strh	r3, [r7, #38]	; 0x26
 8012b4c:	e056      	b.n	8012bfc <lv_disp_refr_task+0x144>
                if(disp_refr->inv_area_joined[a] == 0) {
 8012b4e:	4b4b      	ldr	r3, [pc, #300]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012b50:	681a      	ldr	r2, [r3, #0]
 8012b52:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012b54:	4413      	add	r3, r2
 8012b56:	f893 3148 	ldrb.w	r3, [r3, #328]	; 0x148
 8012b5a:	2b00      	cmp	r3, #0
 8012b5c:	d14b      	bne.n	8012bf6 <lv_disp_refr_task+0x13e>
                    lv_coord_t y;
                    uint32_t start_offs =
                        (hres * disp_refr->inv_areas[a].y1 + disp_refr->inv_areas[a].x1) * sizeof(lv_color_t);
 8012b5e:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 8012b62:	4b46      	ldr	r3, [pc, #280]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012b64:	6819      	ldr	r1, [r3, #0]
 8012b66:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012b68:	3309      	adds	r3, #9
 8012b6a:	00db      	lsls	r3, r3, #3
 8012b6c:	440b      	add	r3, r1
 8012b6e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8012b72:	fb03 f302 	mul.w	r3, r3, r2
 8012b76:	4a41      	ldr	r2, [pc, #260]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012b78:	6812      	ldr	r2, [r2, #0]
 8012b7a:	8cf9      	ldrh	r1, [r7, #38]	; 0x26
 8012b7c:	3109      	adds	r1, #9
 8012b7e:	f932 2031 	ldrsh.w	r2, [r2, r1, lsl #3]
 8012b82:	4413      	add	r3, r2
                    uint32_t start_offs =
 8012b84:	005b      	lsls	r3, r3, #1
 8012b86:	623b      	str	r3, [r7, #32]
                    uint32_t line_length = lv_area_get_width(&disp_refr->inv_areas[a]) * sizeof(lv_color_t);
 8012b88:	4b3c      	ldr	r3, [pc, #240]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012b8a:	681a      	ldr	r2, [r3, #0]
 8012b8c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012b8e:	3309      	adds	r3, #9
 8012b90:	00db      	lsls	r3, r3, #3
 8012b92:	4413      	add	r3, r2
 8012b94:	4618      	mov	r0, r3
 8012b96:	f7ff fe9b 	bl	80128d0 <lv_area_get_width>
 8012b9a:	4603      	mov	r3, r0
 8012b9c:	005b      	lsls	r3, r3, #1
 8012b9e:	60bb      	str	r3, [r7, #8]

                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 8012ba0:	4b36      	ldr	r3, [pc, #216]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012ba2:	681a      	ldr	r2, [r3, #0]
 8012ba4:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012ba6:	3309      	adds	r3, #9
 8012ba8:	00db      	lsls	r3, r3, #3
 8012baa:	4413      	add	r3, r2
 8012bac:	885b      	ldrh	r3, [r3, #2]
 8012bae:	84bb      	strh	r3, [r7, #36]	; 0x24
 8012bb0:	e015      	b.n	8012bde <lv_disp_refr_task+0x126>
                        memcpy(buf_act + start_offs, buf_ina + start_offs, line_length);
 8012bb2:	697a      	ldr	r2, [r7, #20]
 8012bb4:	6a3b      	ldr	r3, [r7, #32]
 8012bb6:	18d0      	adds	r0, r2, r3
 8012bb8:	693a      	ldr	r2, [r7, #16]
 8012bba:	6a3b      	ldr	r3, [r7, #32]
 8012bbc:	4413      	add	r3, r2
 8012bbe:	68ba      	ldr	r2, [r7, #8]
 8012bc0:	4619      	mov	r1, r3
 8012bc2:	f014 fafb 	bl	80271bc <memcpy>
                        start_offs += hres * sizeof(lv_color_t);
 8012bc6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8012bca:	005b      	lsls	r3, r3, #1
 8012bcc:	6a3a      	ldr	r2, [r7, #32]
 8012bce:	4413      	add	r3, r2
 8012bd0:	623b      	str	r3, [r7, #32]
                    for(y = disp_refr->inv_areas[a].y1; y <= disp_refr->inv_areas[a].y2; y++) {
 8012bd2:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8012bd6:	b29b      	uxth	r3, r3
 8012bd8:	3301      	adds	r3, #1
 8012bda:	b29b      	uxth	r3, r3
 8012bdc:	84bb      	strh	r3, [r7, #36]	; 0x24
 8012bde:	4b27      	ldr	r3, [pc, #156]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012be0:	681a      	ldr	r2, [r3, #0]
 8012be2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012be4:	3309      	adds	r3, #9
 8012be6:	00db      	lsls	r3, r3, #3
 8012be8:	4413      	add	r3, r2
 8012bea:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8012bee:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8012bf2:	429a      	cmp	r2, r3
 8012bf4:	dddd      	ble.n	8012bb2 <lv_disp_refr_task+0xfa>
            for(a = 0; a < disp_refr->inv_p; a++) {
 8012bf6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012bf8:	3301      	adds	r3, #1
 8012bfa:	84fb      	strh	r3, [r7, #38]	; 0x26
 8012bfc:	4b1f      	ldr	r3, [pc, #124]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012bfe:	681b      	ldr	r3, [r3, #0]
 8012c00:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012c04:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012c08:	b29b      	uxth	r3, r3
 8012c0a:	461a      	mov	r2, r3
 8012c0c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8012c0e:	4293      	cmp	r3, r2
 8012c10:	d39d      	bcc.n	8012b4e <lv_disp_refr_task+0x96>
                }
            }
        } /*End of true double buffer handling*/

        /*Clean up*/
        memset(disp_refr->inv_areas, 0, sizeof(disp_refr->inv_areas));
 8012c12:	4b1a      	ldr	r3, [pc, #104]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012c14:	681b      	ldr	r3, [r3, #0]
 8012c16:	3348      	adds	r3, #72	; 0x48
 8012c18:	f44f 7280 	mov.w	r2, #256	; 0x100
 8012c1c:	2100      	movs	r1, #0
 8012c1e:	4618      	mov	r0, r3
 8012c20:	f014 fad7 	bl	80271d2 <memset>
        memset(disp_refr->inv_area_joined, 0, sizeof(disp_refr->inv_area_joined));
 8012c24:	4b15      	ldr	r3, [pc, #84]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012c26:	681b      	ldr	r3, [r3, #0]
 8012c28:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8012c2c:	2220      	movs	r2, #32
 8012c2e:	2100      	movs	r1, #0
 8012c30:	4618      	mov	r0, r3
 8012c32:	f014 face 	bl	80271d2 <memset>
        disp_refr->inv_p = 0;
 8012c36:	4b11      	ldr	r3, [pc, #68]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012c38:	681a      	ldr	r2, [r3, #0]
 8012c3a:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 8012c3e:	f36f 0309 	bfc	r3, #0, #10
 8012c42:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168

        /*Call monitor cb if present*/
        if(disp_refr->driver.monitor_cb) {
 8012c46:	4b0d      	ldr	r3, [pc, #52]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012c48:	681b      	ldr	r3, [r3, #0]
 8012c4a:	699b      	ldr	r3, [r3, #24]
 8012c4c:	2b00      	cmp	r3, #0
 8012c4e:	d00e      	beq.n	8012c6e <lv_disp_refr_task+0x1b6>
            disp_refr->driver.monitor_cb(&disp_refr->driver, lv_tick_elaps(start), px_num);
 8012c50:	4b0a      	ldr	r3, [pc, #40]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012c52:	681b      	ldr	r3, [r3, #0]
 8012c54:	699c      	ldr	r4, [r3, #24]
 8012c56:	4b09      	ldr	r3, [pc, #36]	; (8012c7c <lv_disp_refr_task+0x1c4>)
 8012c58:	681b      	ldr	r3, [r3, #0]
 8012c5a:	461d      	mov	r5, r3
 8012c5c:	69f8      	ldr	r0, [r7, #28]
 8012c5e:	f008 fc3f 	bl	801b4e0 <lv_tick_elaps>
 8012c62:	4601      	mov	r1, r0
 8012c64:	4b06      	ldr	r3, [pc, #24]	; (8012c80 <lv_disp_refr_task+0x1c8>)
 8012c66:	681b      	ldr	r3, [r3, #0]
 8012c68:	461a      	mov	r2, r3
 8012c6a:	4628      	mov	r0, r5
 8012c6c:	47a0      	blx	r4
        }
    }

    lv_draw_free_buf();
 8012c6e:	f001 fa43 	bl	80140f8 <lv_draw_free_buf>

    LV_LOG_TRACE("lv_refr_task: ready");
}
 8012c72:	bf00      	nop
 8012c74:	3728      	adds	r7, #40	; 0x28
 8012c76:	46bd      	mov	sp, r7
 8012c78:	bdb0      	pop	{r4, r5, r7, pc}
 8012c7a:	bf00      	nop
 8012c7c:	20003fac 	.word	0x20003fac
 8012c80:	20003fa8 	.word	0x20003fa8

08012c84 <lv_refr_join_area>:

/**
 * Join the areas which has got common parts
 */
static void lv_refr_join_area(void)
{
 8012c84:	b5b0      	push	{r4, r5, r7, lr}
 8012c86:	b084      	sub	sp, #16
 8012c88:	af00      	add	r7, sp, #0
    uint32_t join_from;
    uint32_t join_in;
    lv_area_t joined_area;
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 8012c8a:	2300      	movs	r3, #0
 8012c8c:	60bb      	str	r3, [r7, #8]
 8012c8e:	e083      	b.n	8012d98 <lv_refr_join_area+0x114>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 8012c90:	4b49      	ldr	r3, [pc, #292]	; (8012db8 <lv_refr_join_area+0x134>)
 8012c92:	681a      	ldr	r2, [r3, #0]
 8012c94:	68bb      	ldr	r3, [r7, #8]
 8012c96:	4413      	add	r3, r2
 8012c98:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8012c9c:	781b      	ldrb	r3, [r3, #0]
 8012c9e:	2b00      	cmp	r3, #0
 8012ca0:	d176      	bne.n	8012d90 <lv_refr_join_area+0x10c>

        /*Check all areas to join them in 'join_in'*/
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 8012ca2:	2300      	movs	r3, #0
 8012ca4:	60fb      	str	r3, [r7, #12]
 8012ca6:	e067      	b.n	8012d78 <lv_refr_join_area+0xf4>
            /*Handle only unjoined areas and ignore itself*/
            if(disp_refr->inv_area_joined[join_from] != 0 || join_in == join_from) {
 8012ca8:	4b43      	ldr	r3, [pc, #268]	; (8012db8 <lv_refr_join_area+0x134>)
 8012caa:	681a      	ldr	r2, [r3, #0]
 8012cac:	68fb      	ldr	r3, [r7, #12]
 8012cae:	4413      	add	r3, r2
 8012cb0:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8012cb4:	781b      	ldrb	r3, [r3, #0]
 8012cb6:	2b00      	cmp	r3, #0
 8012cb8:	d158      	bne.n	8012d6c <lv_refr_join_area+0xe8>
 8012cba:	68ba      	ldr	r2, [r7, #8]
 8012cbc:	68fb      	ldr	r3, [r7, #12]
 8012cbe:	429a      	cmp	r2, r3
 8012cc0:	d054      	beq.n	8012d6c <lv_refr_join_area+0xe8>
                continue;
            }

            /*Check if the areas are on each other*/
            if(lv_area_is_on(&disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]) == false) {
 8012cc2:	4b3d      	ldr	r3, [pc, #244]	; (8012db8 <lv_refr_join_area+0x134>)
 8012cc4:	681a      	ldr	r2, [r3, #0]
 8012cc6:	68bb      	ldr	r3, [r7, #8]
 8012cc8:	3309      	adds	r3, #9
 8012cca:	00db      	lsls	r3, r3, #3
 8012ccc:	18d0      	adds	r0, r2, r3
 8012cce:	4b3a      	ldr	r3, [pc, #232]	; (8012db8 <lv_refr_join_area+0x134>)
 8012cd0:	681a      	ldr	r2, [r3, #0]
 8012cd2:	68fb      	ldr	r3, [r7, #12]
 8012cd4:	3309      	adds	r3, #9
 8012cd6:	00db      	lsls	r3, r3, #3
 8012cd8:	4413      	add	r3, r2
 8012cda:	4619      	mov	r1, r3
 8012cdc:	f008 ffb9 	bl	801bc52 <lv_area_is_on>
 8012ce0:	4603      	mov	r3, r0
 8012ce2:	f083 0301 	eor.w	r3, r3, #1
 8012ce6:	b2db      	uxtb	r3, r3
 8012ce8:	2b00      	cmp	r3, #0
 8012cea:	d141      	bne.n	8012d70 <lv_refr_join_area+0xec>
                continue;
            }

            lv_area_join(&joined_area, &disp_refr->inv_areas[join_in], &disp_refr->inv_areas[join_from]);
 8012cec:	4b32      	ldr	r3, [pc, #200]	; (8012db8 <lv_refr_join_area+0x134>)
 8012cee:	681a      	ldr	r2, [r3, #0]
 8012cf0:	68bb      	ldr	r3, [r7, #8]
 8012cf2:	3309      	adds	r3, #9
 8012cf4:	00db      	lsls	r3, r3, #3
 8012cf6:	18d1      	adds	r1, r2, r3
 8012cf8:	4b2f      	ldr	r3, [pc, #188]	; (8012db8 <lv_refr_join_area+0x134>)
 8012cfa:	681a      	ldr	r2, [r3, #0]
 8012cfc:	68fb      	ldr	r3, [r7, #12]
 8012cfe:	3309      	adds	r3, #9
 8012d00:	00db      	lsls	r3, r3, #3
 8012d02:	441a      	add	r2, r3
 8012d04:	463b      	mov	r3, r7
 8012d06:	4618      	mov	r0, r3
 8012d08:	f008 ff37 	bl	801bb7a <lv_area_join>

            /*Join two area only if the joined area size is smaller*/
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 8012d0c:	463b      	mov	r3, r7
 8012d0e:	4618      	mov	r0, r3
 8012d10:	f008 fec1 	bl	801ba96 <lv_area_get_size>
 8012d14:	4604      	mov	r4, r0
 8012d16:	4b28      	ldr	r3, [pc, #160]	; (8012db8 <lv_refr_join_area+0x134>)
 8012d18:	681a      	ldr	r2, [r3, #0]
 8012d1a:	68bb      	ldr	r3, [r7, #8]
 8012d1c:	3309      	adds	r3, #9
 8012d1e:	00db      	lsls	r3, r3, #3
 8012d20:	4413      	add	r3, r2
 8012d22:	4618      	mov	r0, r3
 8012d24:	f008 feb7 	bl	801ba96 <lv_area_get_size>
 8012d28:	4605      	mov	r5, r0
                                                 lv_area_get_size(&disp_refr->inv_areas[join_from]))) {
 8012d2a:	4b23      	ldr	r3, [pc, #140]	; (8012db8 <lv_refr_join_area+0x134>)
 8012d2c:	681a      	ldr	r2, [r3, #0]
 8012d2e:	68fb      	ldr	r3, [r7, #12]
 8012d30:	3309      	adds	r3, #9
 8012d32:	00db      	lsls	r3, r3, #3
 8012d34:	4413      	add	r3, r2
 8012d36:	4618      	mov	r0, r3
 8012d38:	f008 fead 	bl	801ba96 <lv_area_get_size>
 8012d3c:	4603      	mov	r3, r0
            if(lv_area_get_size(&joined_area) < (lv_area_get_size(&disp_refr->inv_areas[join_in]) +
 8012d3e:	442b      	add	r3, r5
 8012d40:	429c      	cmp	r4, r3
 8012d42:	d216      	bcs.n	8012d72 <lv_refr_join_area+0xee>
                lv_area_copy(&disp_refr->inv_areas[join_in], &joined_area);
 8012d44:	4b1c      	ldr	r3, [pc, #112]	; (8012db8 <lv_refr_join_area+0x134>)
 8012d46:	681a      	ldr	r2, [r3, #0]
 8012d48:	68bb      	ldr	r3, [r7, #8]
 8012d4a:	3309      	adds	r3, #9
 8012d4c:	00db      	lsls	r3, r3, #3
 8012d4e:	4413      	add	r3, r2
 8012d50:	463a      	mov	r2, r7
 8012d52:	4611      	mov	r1, r2
 8012d54:	4618      	mov	r0, r3
 8012d56:	f7ff fdad 	bl	80128b4 <lv_area_copy>

                /*Mark 'join_form' is joined into 'join_in'*/
                disp_refr->inv_area_joined[join_from] = 1;
 8012d5a:	4b17      	ldr	r3, [pc, #92]	; (8012db8 <lv_refr_join_area+0x134>)
 8012d5c:	681a      	ldr	r2, [r3, #0]
 8012d5e:	68fb      	ldr	r3, [r7, #12]
 8012d60:	4413      	add	r3, r2
 8012d62:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8012d66:	2201      	movs	r2, #1
 8012d68:	701a      	strb	r2, [r3, #0]
 8012d6a:	e002      	b.n	8012d72 <lv_refr_join_area+0xee>
                continue;
 8012d6c:	bf00      	nop
 8012d6e:	e000      	b.n	8012d72 <lv_refr_join_area+0xee>
                continue;
 8012d70:	bf00      	nop
        for(join_from = 0; join_from < disp_refr->inv_p; join_from++) {
 8012d72:	68fb      	ldr	r3, [r7, #12]
 8012d74:	3301      	adds	r3, #1
 8012d76:	60fb      	str	r3, [r7, #12]
 8012d78:	4b0f      	ldr	r3, [pc, #60]	; (8012db8 <lv_refr_join_area+0x134>)
 8012d7a:	681b      	ldr	r3, [r3, #0]
 8012d7c:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012d80:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012d84:	b29b      	uxth	r3, r3
 8012d86:	461a      	mov	r2, r3
 8012d88:	68fb      	ldr	r3, [r7, #12]
 8012d8a:	4293      	cmp	r3, r2
 8012d8c:	d38c      	bcc.n	8012ca8 <lv_refr_join_area+0x24>
 8012d8e:	e000      	b.n	8012d92 <lv_refr_join_area+0x10e>
        if(disp_refr->inv_area_joined[join_in] != 0) continue;
 8012d90:	bf00      	nop
    for(join_in = 0; join_in < disp_refr->inv_p; join_in++) {
 8012d92:	68bb      	ldr	r3, [r7, #8]
 8012d94:	3301      	adds	r3, #1
 8012d96:	60bb      	str	r3, [r7, #8]
 8012d98:	4b07      	ldr	r3, [pc, #28]	; (8012db8 <lv_refr_join_area+0x134>)
 8012d9a:	681b      	ldr	r3, [r3, #0]
 8012d9c:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012da0:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012da4:	b29b      	uxth	r3, r3
 8012da6:	461a      	mov	r2, r3
 8012da8:	68bb      	ldr	r3, [r7, #8]
 8012daa:	4293      	cmp	r3, r2
 8012dac:	f4ff af70 	bcc.w	8012c90 <lv_refr_join_area+0xc>
            }
        }
    }
}
 8012db0:	bf00      	nop
 8012db2:	3710      	adds	r7, #16
 8012db4:	46bd      	mov	sp, r7
 8012db6:	bdb0      	pop	{r4, r5, r7, pc}
 8012db8:	20003fac 	.word	0x20003fac

08012dbc <lv_refr_areas>:

/**
 * Refresh the joined areas
 */
static void lv_refr_areas(void)
{
 8012dbc:	b580      	push	{r7, lr}
 8012dbe:	b082      	sub	sp, #8
 8012dc0:	af00      	add	r7, sp, #0
    px_num = 0;
 8012dc2:	4b1f      	ldr	r3, [pc, #124]	; (8012e40 <lv_refr_areas+0x84>)
 8012dc4:	2200      	movs	r2, #0
 8012dc6:	601a      	str	r2, [r3, #0]
    uint32_t i;

    for(i = 0; i < disp_refr->inv_p; i++) {
 8012dc8:	2300      	movs	r3, #0
 8012dca:	607b      	str	r3, [r7, #4]
 8012dcc:	e028      	b.n	8012e20 <lv_refr_areas+0x64>
        /*Refresh the unjoined areas*/
        if(disp_refr->inv_area_joined[i] == 0) {
 8012dce:	4b1d      	ldr	r3, [pc, #116]	; (8012e44 <lv_refr_areas+0x88>)
 8012dd0:	681a      	ldr	r2, [r3, #0]
 8012dd2:	687b      	ldr	r3, [r7, #4]
 8012dd4:	4413      	add	r3, r2
 8012dd6:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 8012dda:	781b      	ldrb	r3, [r3, #0]
 8012ddc:	2b00      	cmp	r3, #0
 8012dde:	d11c      	bne.n	8012e1a <lv_refr_areas+0x5e>

            lv_refr_area(&disp_refr->inv_areas[i]);
 8012de0:	4b18      	ldr	r3, [pc, #96]	; (8012e44 <lv_refr_areas+0x88>)
 8012de2:	681a      	ldr	r2, [r3, #0]
 8012de4:	687b      	ldr	r3, [r7, #4]
 8012de6:	3309      	adds	r3, #9
 8012de8:	00db      	lsls	r3, r3, #3
 8012dea:	4413      	add	r3, r2
 8012dec:	4618      	mov	r0, r3
 8012dee:	f000 f82b 	bl	8012e48 <lv_refr_area>

            if(disp_refr->driver.monitor_cb) px_num += lv_area_get_size(&disp_refr->inv_areas[i]);
 8012df2:	4b14      	ldr	r3, [pc, #80]	; (8012e44 <lv_refr_areas+0x88>)
 8012df4:	681b      	ldr	r3, [r3, #0]
 8012df6:	699b      	ldr	r3, [r3, #24]
 8012df8:	2b00      	cmp	r3, #0
 8012dfa:	d00e      	beq.n	8012e1a <lv_refr_areas+0x5e>
 8012dfc:	4b11      	ldr	r3, [pc, #68]	; (8012e44 <lv_refr_areas+0x88>)
 8012dfe:	681a      	ldr	r2, [r3, #0]
 8012e00:	687b      	ldr	r3, [r7, #4]
 8012e02:	3309      	adds	r3, #9
 8012e04:	00db      	lsls	r3, r3, #3
 8012e06:	4413      	add	r3, r2
 8012e08:	4618      	mov	r0, r3
 8012e0a:	f008 fe44 	bl	801ba96 <lv_area_get_size>
 8012e0e:	4602      	mov	r2, r0
 8012e10:	4b0b      	ldr	r3, [pc, #44]	; (8012e40 <lv_refr_areas+0x84>)
 8012e12:	681b      	ldr	r3, [r3, #0]
 8012e14:	4413      	add	r3, r2
 8012e16:	4a0a      	ldr	r2, [pc, #40]	; (8012e40 <lv_refr_areas+0x84>)
 8012e18:	6013      	str	r3, [r2, #0]
    for(i = 0; i < disp_refr->inv_p; i++) {
 8012e1a:	687b      	ldr	r3, [r7, #4]
 8012e1c:	3301      	adds	r3, #1
 8012e1e:	607b      	str	r3, [r7, #4]
 8012e20:	4b08      	ldr	r3, [pc, #32]	; (8012e44 <lv_refr_areas+0x88>)
 8012e22:	681b      	ldr	r3, [r3, #0]
 8012e24:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 8012e28:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8012e2c:	b29b      	uxth	r3, r3
 8012e2e:	461a      	mov	r2, r3
 8012e30:	687b      	ldr	r3, [r7, #4]
 8012e32:	4293      	cmp	r3, r2
 8012e34:	d3cb      	bcc.n	8012dce <lv_refr_areas+0x12>
        }
    }
}
 8012e36:	bf00      	nop
 8012e38:	3708      	adds	r7, #8
 8012e3a:	46bd      	mov	sp, r7
 8012e3c:	bd80      	pop	{r7, pc}
 8012e3e:	bf00      	nop
 8012e40:	20003fa8 	.word	0x20003fa8
 8012e44:	20003fac 	.word	0x20003fac

08012e48 <lv_refr_area>:
/**
 * Refresh an area if there is Virtual Display Buffer
 * @param area_p  pointer to an area to refresh
 */
static void lv_refr_area(const lv_area_t * area_p)
{
 8012e48:	b590      	push	{r4, r7, lr}
 8012e4a:	b08d      	sub	sp, #52	; 0x34
 8012e4c:	af00      	add	r7, sp, #0
 8012e4e:	6078      	str	r0, [r7, #4]
    /*True double buffering: there are two screen sized buffers. Just redraw directly into a
     * buffer*/
    if(lv_disp_is_true_double_buf(disp_refr)) {
 8012e50:	4b82      	ldr	r3, [pc, #520]	; (801305c <lv_refr_area+0x214>)
 8012e52:	681b      	ldr	r3, [r3, #0]
 8012e54:	4618      	mov	r0, r3
 8012e56:	f008 fa32 	bl	801b2be <lv_disp_is_true_double_buf>
 8012e5a:	4603      	mov	r3, r0
 8012e5c:	2b00      	cmp	r3, #0
 8012e5e:	d027      	beq.n	8012eb0 <lv_refr_area+0x68>
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8012e60:	4b7e      	ldr	r3, [pc, #504]	; (801305c <lv_refr_area+0x214>)
 8012e62:	681b      	ldr	r3, [r3, #0]
 8012e64:	4618      	mov	r0, r3
 8012e66:	f008 f9c5 	bl	801b1f4 <lv_disp_get_buf>
 8012e6a:	6178      	str	r0, [r7, #20]
        vdb->area.x1        = 0;
 8012e6c:	697b      	ldr	r3, [r7, #20]
 8012e6e:	2200      	movs	r2, #0
 8012e70:	821a      	strh	r2, [r3, #16]
        vdb->area.x2        = lv_disp_get_hor_res(disp_refr) - 1;
 8012e72:	4b7a      	ldr	r3, [pc, #488]	; (801305c <lv_refr_area+0x214>)
 8012e74:	681b      	ldr	r3, [r3, #0]
 8012e76:	4618      	mov	r0, r3
 8012e78:	f008 f934 	bl	801b0e4 <lv_disp_get_hor_res>
 8012e7c:	4603      	mov	r3, r0
 8012e7e:	b29b      	uxth	r3, r3
 8012e80:	3b01      	subs	r3, #1
 8012e82:	b29b      	uxth	r3, r3
 8012e84:	b21a      	sxth	r2, r3
 8012e86:	697b      	ldr	r3, [r7, #20]
 8012e88:	829a      	strh	r2, [r3, #20]
        vdb->area.y1        = 0;
 8012e8a:	697b      	ldr	r3, [r7, #20]
 8012e8c:	2200      	movs	r2, #0
 8012e8e:	825a      	strh	r2, [r3, #18]
        vdb->area.y2        = lv_disp_get_ver_res(disp_refr) - 1;
 8012e90:	4b72      	ldr	r3, [pc, #456]	; (801305c <lv_refr_area+0x214>)
 8012e92:	681b      	ldr	r3, [r3, #0]
 8012e94:	4618      	mov	r0, r3
 8012e96:	f008 f947 	bl	801b128 <lv_disp_get_ver_res>
 8012e9a:	4603      	mov	r3, r0
 8012e9c:	b29b      	uxth	r3, r3
 8012e9e:	3b01      	subs	r3, #1
 8012ea0:	b29b      	uxth	r3, r3
 8012ea2:	b21a      	sxth	r2, r3
 8012ea4:	697b      	ldr	r3, [r7, #20]
 8012ea6:	82da      	strh	r2, [r3, #22]
        lv_refr_area_part(area_p);
 8012ea8:	6878      	ldr	r0, [r7, #4]
 8012eaa:	f000 f8dd 	bl	8013068 <lv_refr_area_part>
 8012eae:	e0d1      	b.n	8013054 <lv_refr_area+0x20c>
    }
    /*The buffer is smaller: refresh the area in parts*/
    else {
        lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8012eb0:	4b6a      	ldr	r3, [pc, #424]	; (801305c <lv_refr_area+0x214>)
 8012eb2:	681b      	ldr	r3, [r3, #0]
 8012eb4:	4618      	mov	r0, r3
 8012eb6:	f008 f99d 	bl	801b1f4 <lv_disp_get_buf>
 8012eba:	6238      	str	r0, [r7, #32]
        /*Calculate the max row num*/
        lv_coord_t w = lv_area_get_width(area_p);
 8012ebc:	6878      	ldr	r0, [r7, #4]
 8012ebe:	f7ff fd07 	bl	80128d0 <lv_area_get_width>
 8012ec2:	4603      	mov	r3, r0
 8012ec4:	83fb      	strh	r3, [r7, #30]
        lv_coord_t h = lv_area_get_height(area_p);
 8012ec6:	6878      	ldr	r0, [r7, #4]
 8012ec8:	f7ff fd19 	bl	80128fe <lv_area_get_height>
 8012ecc:	4603      	mov	r3, r0
 8012ece:	83bb      	strh	r3, [r7, #28]
        lv_coord_t y2 =
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 8012ed0:	687b      	ldr	r3, [r7, #4]
 8012ed2:	f9b3 4006 	ldrsh.w	r4, [r3, #6]
 8012ed6:	4b61      	ldr	r3, [pc, #388]	; (801305c <lv_refr_area+0x214>)
 8012ed8:	681b      	ldr	r3, [r3, #0]
 8012eda:	4618      	mov	r0, r3
 8012edc:	f008 f924 	bl	801b128 <lv_disp_get_ver_res>
 8012ee0:	4603      	mov	r3, r0
        lv_coord_t y2 =
 8012ee2:	429c      	cmp	r4, r3
 8012ee4:	db0c      	blt.n	8012f00 <lv_refr_area+0xb8>
            area_p->y2 >= lv_disp_get_ver_res(disp_refr) ? y2 = lv_disp_get_ver_res(disp_refr) - 1 : area_p->y2;
 8012ee6:	4b5d      	ldr	r3, [pc, #372]	; (801305c <lv_refr_area+0x214>)
 8012ee8:	681b      	ldr	r3, [r3, #0]
 8012eea:	4618      	mov	r0, r3
 8012eec:	f008 f91c 	bl	801b128 <lv_disp_get_ver_res>
 8012ef0:	4603      	mov	r3, r0
 8012ef2:	b29b      	uxth	r3, r3
 8012ef4:	3b01      	subs	r3, #1
 8012ef6:	b29b      	uxth	r3, r3
 8012ef8:	837b      	strh	r3, [r7, #26]
        lv_coord_t y2 =
 8012efa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8012efe:	e002      	b.n	8012f06 <lv_refr_area+0xbe>
 8012f00:	687b      	ldr	r3, [r7, #4]
 8012f02:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8012f06:	837b      	strh	r3, [r7, #26]

        int32_t max_row = (uint32_t)vdb->size / w;
 8012f08:	6a3b      	ldr	r3, [r7, #32]
 8012f0a:	68da      	ldr	r2, [r3, #12]
 8012f0c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8012f10:	fbb2 f3f3 	udiv	r3, r2, r3
 8012f14:	62fb      	str	r3, [r7, #44]	; 0x2c

        if(max_row > h) max_row = h;
 8012f16:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8012f1a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8012f1c:	429a      	cmp	r2, r3
 8012f1e:	dd02      	ble.n	8012f26 <lv_refr_area+0xde>
 8012f20:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8012f24:	62fb      	str	r3, [r7, #44]	; 0x2c

        /*Round down the lines of VDB if rounding is added*/
        if(disp_refr->driver.rounder_cb) {
 8012f26:	4b4d      	ldr	r3, [pc, #308]	; (801305c <lv_refr_area+0x214>)
 8012f28:	681b      	ldr	r3, [r3, #0]
 8012f2a:	691b      	ldr	r3, [r3, #16]
 8012f2c:	2b00      	cmp	r3, #0
 8012f2e:	d03c      	beq.n	8012faa <lv_refr_area+0x162>
            lv_area_t tmp;
            tmp.x1 = 0;
 8012f30:	2300      	movs	r3, #0
 8012f32:	81bb      	strh	r3, [r7, #12]
            tmp.x2 = 0;
 8012f34:	2300      	movs	r3, #0
 8012f36:	823b      	strh	r3, [r7, #16]
            tmp.y1 = 0;
 8012f38:	2300      	movs	r3, #0
 8012f3a:	81fb      	strh	r3, [r7, #14]

            lv_coord_t y_tmp = max_row - 1;
 8012f3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012f3e:	b29b      	uxth	r3, r3
 8012f40:	3b01      	subs	r3, #1
 8012f42:	b29b      	uxth	r3, r3
 8012f44:	857b      	strh	r3, [r7, #42]	; 0x2a
            do {
                tmp.y2 = y_tmp;
 8012f46:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8012f48:	827b      	strh	r3, [r7, #18]
                disp_refr->driver.rounder_cb(&disp_refr->driver, &tmp);
 8012f4a:	4b44      	ldr	r3, [pc, #272]	; (801305c <lv_refr_area+0x214>)
 8012f4c:	681b      	ldr	r3, [r3, #0]
 8012f4e:	691b      	ldr	r3, [r3, #16]
 8012f50:	4a42      	ldr	r2, [pc, #264]	; (801305c <lv_refr_area+0x214>)
 8012f52:	6812      	ldr	r2, [r2, #0]
 8012f54:	4610      	mov	r0, r2
 8012f56:	f107 020c 	add.w	r2, r7, #12
 8012f5a:	4611      	mov	r1, r2
 8012f5c:	4798      	blx	r3

                /*If this height fits into `max_row` then fine*/
                if(lv_area_get_height(&tmp) <= max_row) break;
 8012f5e:	f107 030c 	add.w	r3, r7, #12
 8012f62:	4618      	mov	r0, r3
 8012f64:	f7ff fccb 	bl	80128fe <lv_area_get_height>
 8012f68:	4603      	mov	r3, r0
 8012f6a:	461a      	mov	r2, r3
 8012f6c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012f6e:	4293      	cmp	r3, r2
 8012f70:	da0a      	bge.n	8012f88 <lv_refr_area+0x140>

                /*Decrement the height of the area until it fits into `max_row` after rounding*/
                y_tmp--;
 8012f72:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8012f76:	b29b      	uxth	r3, r3
 8012f78:	3b01      	subs	r3, #1
 8012f7a:	b29b      	uxth	r3, r3
 8012f7c:	857b      	strh	r3, [r7, #42]	; 0x2a
            } while(y_tmp != 0);
 8012f7e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8012f82:	2b00      	cmp	r3, #0
 8012f84:	d1df      	bne.n	8012f46 <lv_refr_area+0xfe>
 8012f86:	e000      	b.n	8012f8a <lv_refr_area+0x142>
                if(lv_area_get_height(&tmp) <= max_row) break;
 8012f88:	bf00      	nop

            if(y_tmp == 0) {
 8012f8a:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8012f8e:	2b00      	cmp	r3, #0
 8012f90:	d107      	bne.n	8012fa2 <lv_refr_area+0x15a>
                LV_LOG_WARN("Can't set VDB height using the round function. (Wrong round_cb or to "
 8012f92:	4b33      	ldr	r3, [pc, #204]	; (8013060 <lv_refr_area+0x218>)
 8012f94:	f240 124f 	movw	r2, #335	; 0x14f
 8012f98:	4932      	ldr	r1, [pc, #200]	; (8013064 <lv_refr_area+0x21c>)
 8012f9a:	2002      	movs	r0, #2
 8012f9c:	f009 fc36 	bl	801c80c <lv_log_add>
 8012fa0:	e058      	b.n	8013054 <lv_refr_area+0x20c>
                            "small VDB)");
                return;
            } else {
                max_row = tmp.y2 + 1;
 8012fa2:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8012fa6:	3301      	adds	r3, #1
 8012fa8:	62fb      	str	r3, [r7, #44]	; 0x2c
            }
        }

        /*Always use the full row*/
        lv_coord_t row;
        lv_coord_t row_last = 0;
 8012faa:	2300      	movs	r3, #0
 8012fac:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 8012fae:	687b      	ldr	r3, [r7, #4]
 8012fb0:	885b      	ldrh	r3, [r3, #2]
 8012fb2:	853b      	strh	r3, [r7, #40]	; 0x28
 8012fb4:	e02c      	b.n	8013010 <lv_refr_area+0x1c8>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 8012fb6:	687b      	ldr	r3, [r7, #4]
 8012fb8:	f9b3 2000 	ldrsh.w	r2, [r3]
 8012fbc:	6a3b      	ldr	r3, [r7, #32]
 8012fbe:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 8012fc0:	687b      	ldr	r3, [r7, #4]
 8012fc2:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 8012fc6:	6a3b      	ldr	r3, [r7, #32]
 8012fc8:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 8012fca:	6a3b      	ldr	r3, [r7, #32]
 8012fcc:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8012fce:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = row + max_row - 1;
 8012fd0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8012fd2:	b29a      	uxth	r2, r3
 8012fd4:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8012fd6:	4413      	add	r3, r2
 8012fd8:	b29b      	uxth	r3, r3
 8012fda:	3b01      	subs	r3, #1
 8012fdc:	b29b      	uxth	r3, r3
 8012fde:	b21a      	sxth	r2, r3
 8012fe0:	6a3b      	ldr	r3, [r7, #32]
 8012fe2:	82da      	strh	r2, [r3, #22]
            if(vdb->area.y2 > y2) vdb->area.y2 = y2;
 8012fe4:	6a3b      	ldr	r3, [r7, #32]
 8012fe6:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8012fea:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8012fee:	429a      	cmp	r2, r3
 8012ff0:	da02      	bge.n	8012ff8 <lv_refr_area+0x1b0>
 8012ff2:	6a3b      	ldr	r3, [r7, #32]
 8012ff4:	8b7a      	ldrh	r2, [r7, #26]
 8012ff6:	82da      	strh	r2, [r3, #22]
            row_last = vdb->area.y2;
 8012ff8:	6a3b      	ldr	r3, [r7, #32]
 8012ffa:	8adb      	ldrh	r3, [r3, #22]
 8012ffc:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_refr_area_part(area_p);
 8012ffe:	6878      	ldr	r0, [r7, #4]
 8013000:	f000 f832 	bl	8013068 <lv_refr_area_part>
        for(row = area_p->y1; row + max_row - 1 <= y2; row += max_row) {
 8013004:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013006:	b29a      	uxth	r2, r3
 8013008:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801300a:	4413      	add	r3, r2
 801300c:	b29b      	uxth	r3, r3
 801300e:	853b      	strh	r3, [r7, #40]	; 0x28
 8013010:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 8013014:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8013016:	4413      	add	r3, r2
 8013018:	1e5a      	subs	r2, r3, #1
 801301a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801301e:	429a      	cmp	r2, r3
 8013020:	ddc9      	ble.n	8012fb6 <lv_refr_area+0x16e>
        }

        /*If the last y coordinates are not handled yet ...*/
        if(y2 != row_last) {
 8013022:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8013026:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801302a:	429a      	cmp	r2, r3
 801302c:	d012      	beq.n	8013054 <lv_refr_area+0x20c>
            /*Calc. the next y coordinates of VDB*/
            vdb->area.x1 = area_p->x1;
 801302e:	687b      	ldr	r3, [r7, #4]
 8013030:	f9b3 2000 	ldrsh.w	r2, [r3]
 8013034:	6a3b      	ldr	r3, [r7, #32]
 8013036:	821a      	strh	r2, [r3, #16]
            vdb->area.x2 = area_p->x2;
 8013038:	687b      	ldr	r3, [r7, #4]
 801303a:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801303e:	6a3b      	ldr	r3, [r7, #32]
 8013040:	829a      	strh	r2, [r3, #20]
            vdb->area.y1 = row;
 8013042:	6a3b      	ldr	r3, [r7, #32]
 8013044:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
 8013046:	825a      	strh	r2, [r3, #18]
            vdb->area.y2 = y2;
 8013048:	6a3b      	ldr	r3, [r7, #32]
 801304a:	8b7a      	ldrh	r2, [r7, #26]
 801304c:	82da      	strh	r2, [r3, #22]

            /*Refresh this part too*/
            lv_refr_area_part(area_p);
 801304e:	6878      	ldr	r0, [r7, #4]
 8013050:	f000 f80a 	bl	8013068 <lv_refr_area_part>
        }
    }
}
 8013054:	3734      	adds	r7, #52	; 0x34
 8013056:	46bd      	mov	sp, r7
 8013058:	bd90      	pop	{r4, r7, pc}
 801305a:	bf00      	nop
 801305c:	20003fac 	.word	0x20003fac
 8013060:	08028868 	.word	0x08028868
 8013064:	080288b8 	.word	0x080288b8

08013068 <lv_refr_area_part>:
/**
 * Refresh a part of an area which is on the actual Virtual Display Buffer
 * @param area_p pointer to an area to refresh
 */
static void lv_refr_area_part(const lv_area_t * area_p)
{
 8013068:	b580      	push	{r7, lr}
 801306a:	b086      	sub	sp, #24
 801306c:	af00      	add	r7, sp, #0
 801306e:	6078      	str	r0, [r7, #4]

    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 8013070:	4b2e      	ldr	r3, [pc, #184]	; (801312c <lv_refr_area_part+0xc4>)
 8013072:	681b      	ldr	r3, [r3, #0]
 8013074:	4618      	mov	r0, r3
 8013076:	f008 f8bd 	bl	801b1f4 <lv_disp_get_buf>
 801307a:	6178      	str	r0, [r7, #20]

    /*In non double buffered mode, before rendering the next part wait until the previous image is
     * flushed*/
    if(lv_disp_is_double_buf(disp_refr) == false) {
 801307c:	4b2b      	ldr	r3, [pc, #172]	; (801312c <lv_refr_area_part+0xc4>)
 801307e:	681b      	ldr	r3, [r3, #0]
 8013080:	4618      	mov	r0, r3
 8013082:	f008 f905 	bl	801b290 <lv_disp_is_double_buf>
 8013086:	4603      	mov	r3, r0
 8013088:	f083 0301 	eor.w	r3, r3, #1
 801308c:	b2db      	uxtb	r3, r3
 801308e:	2b00      	cmp	r3, #0
 8013090:	d007      	beq.n	80130a2 <lv_refr_area_part+0x3a>
        while(vdb->flushing)
 8013092:	bf00      	nop
 8013094:	697b      	ldr	r3, [r7, #20]
 8013096:	699b      	ldr	r3, [r3, #24]
 8013098:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801309c:	b2db      	uxtb	r3, r3
 801309e:	2b00      	cmp	r3, #0
 80130a0:	d1f8      	bne.n	8013094 <lv_refr_area_part+0x2c>
    lv_obj_t * top_p;

    /*Get the new mask from the original area and the act. VDB
     It will be a part of 'area_p'*/
    lv_area_t start_mask;
    lv_area_intersect(&start_mask, area_p, &vdb->area);
 80130a2:	697b      	ldr	r3, [r7, #20]
 80130a4:	f103 0210 	add.w	r2, r3, #16
 80130a8:	f107 0308 	add.w	r3, r7, #8
 80130ac:	6879      	ldr	r1, [r7, #4]
 80130ae:	4618      	mov	r0, r3
 80130b0:	f008 fd12 	bl	801bad8 <lv_area_intersect>

    /*Get the most top object which is not covered by others*/
    top_p = lv_refr_get_top_obj(&start_mask, lv_disp_get_scr_act(disp_refr));
 80130b4:	4b1d      	ldr	r3, [pc, #116]	; (801312c <lv_refr_area_part+0xc4>)
 80130b6:	681b      	ldr	r3, [r3, #0]
 80130b8:	4618      	mov	r0, r3
 80130ba:	f7fa fecf 	bl	800de5c <lv_disp_get_scr_act>
 80130be:	4602      	mov	r2, r0
 80130c0:	f107 0308 	add.w	r3, r7, #8
 80130c4:	4611      	mov	r1, r2
 80130c6:	4618      	mov	r0, r3
 80130c8:	f000 f832 	bl	8013130 <lv_refr_get_top_obj>
 80130cc:	6138      	str	r0, [r7, #16]

    /*Do the refreshing from the top object*/
    lv_refr_obj_and_children(top_p, &start_mask);
 80130ce:	f107 0308 	add.w	r3, r7, #8
 80130d2:	4619      	mov	r1, r3
 80130d4:	6938      	ldr	r0, [r7, #16]
 80130d6:	f000 f87f 	bl	80131d8 <lv_refr_obj_and_children>

    /*Also refresh top and sys layer unconditionally*/
    lv_refr_obj_and_children(lv_disp_get_layer_top(disp_refr), &start_mask);
 80130da:	4b14      	ldr	r3, [pc, #80]	; (801312c <lv_refr_area_part+0xc4>)
 80130dc:	681b      	ldr	r3, [r3, #0]
 80130de:	4618      	mov	r0, r3
 80130e0:	f7fa feee 	bl	800dec0 <lv_disp_get_layer_top>
 80130e4:	4602      	mov	r2, r0
 80130e6:	f107 0308 	add.w	r3, r7, #8
 80130ea:	4619      	mov	r1, r3
 80130ec:	4610      	mov	r0, r2
 80130ee:	f000 f873 	bl	80131d8 <lv_refr_obj_and_children>
    lv_refr_obj_and_children(lv_disp_get_layer_sys(disp_refr), &start_mask);
 80130f2:	4b0e      	ldr	r3, [pc, #56]	; (801312c <lv_refr_area_part+0xc4>)
 80130f4:	681b      	ldr	r3, [r3, #0]
 80130f6:	4618      	mov	r0, r3
 80130f8:	f7fa ff02 	bl	800df00 <lv_disp_get_layer_sys>
 80130fc:	4602      	mov	r2, r0
 80130fe:	f107 0308 	add.w	r3, r7, #8
 8013102:	4619      	mov	r1, r3
 8013104:	4610      	mov	r0, r2
 8013106:	f000 f867 	bl	80131d8 <lv_refr_obj_and_children>

    /* In true double buffered mode flush only once when all areas were rendered.
     * In normal mode flush after every area */
    if(lv_disp_is_true_double_buf(disp_refr) == false) {
 801310a:	4b08      	ldr	r3, [pc, #32]	; (801312c <lv_refr_area_part+0xc4>)
 801310c:	681b      	ldr	r3, [r3, #0]
 801310e:	4618      	mov	r0, r3
 8013110:	f008 f8d5 	bl	801b2be <lv_disp_is_true_double_buf>
 8013114:	4603      	mov	r3, r0
 8013116:	f083 0301 	eor.w	r3, r3, #1
 801311a:	b2db      	uxtb	r3, r3
 801311c:	2b00      	cmp	r3, #0
 801311e:	d001      	beq.n	8013124 <lv_refr_area_part+0xbc>
        lv_refr_vdb_flush();
 8013120:	f000 f95c 	bl	80133dc <lv_refr_vdb_flush>
    }
}
 8013124:	bf00      	nop
 8013126:	3718      	adds	r7, #24
 8013128:	46bd      	mov	sp, r7
 801312a:	bd80      	pop	{r7, pc}
 801312c:	20003fac 	.word	0x20003fac

08013130 <lv_refr_get_top_obj>:
 * @param area_p pointer to an area
 * @param obj the first object to start the searching (typically a screen)
 * @return
 */
static lv_obj_t * lv_refr_get_top_obj(const lv_area_t * area_p, lv_obj_t * obj)
{
 8013130:	b580      	push	{r7, lr}
 8013132:	b086      	sub	sp, #24
 8013134:	af00      	add	r7, sp, #0
 8013136:	6078      	str	r0, [r7, #4]
 8013138:	6039      	str	r1, [r7, #0]
    lv_obj_t * found_p = NULL;
 801313a:	2300      	movs	r3, #0
 801313c:	617b      	str	r3, [r7, #20]

    /*If this object is fully cover the draw area check the children too */
    if(lv_area_is_in(area_p, &obj->coords) && obj->hidden == 0) {
 801313e:	683b      	ldr	r3, [r7, #0]
 8013140:	3310      	adds	r3, #16
 8013142:	4619      	mov	r1, r3
 8013144:	6878      	ldr	r0, [r7, #4]
 8013146:	f008 fdb2 	bl	801bcae <lv_area_is_in>
 801314a:	4603      	mov	r3, r0
 801314c:	2b00      	cmp	r3, #0
 801314e:	d03e      	beq.n	80131ce <lv_refr_get_top_obj+0x9e>
 8013150:	683b      	ldr	r3, [r7, #0]
 8013152:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013156:	f003 0310 	and.w	r3, r3, #16
 801315a:	b2db      	uxtb	r3, r3
 801315c:	2b00      	cmp	r3, #0
 801315e:	d136      	bne.n	80131ce <lv_refr_get_top_obj+0x9e>
        lv_obj_t * i;
        LV_LL_READ(obj->child_ll, i)
 8013160:	683b      	ldr	r3, [r7, #0]
 8013162:	3304      	adds	r3, #4
 8013164:	4618      	mov	r0, r3
 8013166:	f009 fa49 	bl	801c5fc <lv_ll_get_head>
 801316a:	6138      	str	r0, [r7, #16]
 801316c:	e00e      	b.n	801318c <lv_refr_get_top_obj+0x5c>
        {
            found_p = lv_refr_get_top_obj(area_p, i);
 801316e:	6939      	ldr	r1, [r7, #16]
 8013170:	6878      	ldr	r0, [r7, #4]
 8013172:	f7ff ffdd 	bl	8013130 <lv_refr_get_top_obj>
 8013176:	6178      	str	r0, [r7, #20]

            /*If a children is ok then break*/
            if(found_p != NULL) {
 8013178:	697b      	ldr	r3, [r7, #20]
 801317a:	2b00      	cmp	r3, #0
 801317c:	d10a      	bne.n	8013194 <lv_refr_get_top_obj+0x64>
        LV_LL_READ(obj->child_ll, i)
 801317e:	683b      	ldr	r3, [r7, #0]
 8013180:	3304      	adds	r3, #4
 8013182:	6939      	ldr	r1, [r7, #16]
 8013184:	4618      	mov	r0, r3
 8013186:	f009 fa5f 	bl	801c648 <lv_ll_get_next>
 801318a:	6138      	str	r0, [r7, #16]
 801318c:	693b      	ldr	r3, [r7, #16]
 801318e:	2b00      	cmp	r3, #0
 8013190:	d1ed      	bne.n	801316e <lv_refr_get_top_obj+0x3e>
 8013192:	e000      	b.n	8013196 <lv_refr_get_top_obj+0x66>
                break;
 8013194:	bf00      	nop
            }
        }

        /*If no better children check this object*/
        if(found_p == NULL) {
 8013196:	697b      	ldr	r3, [r7, #20]
 8013198:	2b00      	cmp	r3, #0
 801319a:	d118      	bne.n	80131ce <lv_refr_get_top_obj+0x9e>
            const lv_style_t * style = lv_obj_get_style(obj);
 801319c:	6838      	ldr	r0, [r7, #0]
 801319e:	f7ff f829 	bl	80121f4 <lv_obj_get_style>
 80131a2:	60f8      	str	r0, [r7, #12]
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
 80131a4:	68fb      	ldr	r3, [r7, #12]
 80131a6:	7a1b      	ldrb	r3, [r3, #8]
 80131a8:	2bff      	cmp	r3, #255	; 0xff
 80131aa:	d110      	bne.n	80131ce <lv_refr_get_top_obj+0x9e>
 80131ac:	683b      	ldr	r3, [r7, #0]
 80131ae:	6a1b      	ldr	r3, [r3, #32]
 80131b0:	2202      	movs	r2, #2
 80131b2:	6879      	ldr	r1, [r7, #4]
 80131b4:	6838      	ldr	r0, [r7, #0]
 80131b6:	4798      	blx	r3
 80131b8:	4603      	mov	r3, r0
 80131ba:	2b00      	cmp	r3, #0
 80131bc:	d007      	beq.n	80131ce <lv_refr_get_top_obj+0x9e>
               lv_obj_get_opa_scale(obj) == LV_OPA_COVER) {
 80131be:	6838      	ldr	r0, [r7, #0]
 80131c0:	f7ff f8e9 	bl	8012396 <lv_obj_get_opa_scale>
 80131c4:	4603      	mov	r3, r0
            if(style->body.opa == LV_OPA_COVER && obj->design_cb(obj, area_p, LV_DESIGN_COVER_CHK) != false &&
 80131c6:	2bff      	cmp	r3, #255	; 0xff
 80131c8:	d101      	bne.n	80131ce <lv_refr_get_top_obj+0x9e>
                found_p = obj;
 80131ca:	683b      	ldr	r3, [r7, #0]
 80131cc:	617b      	str	r3, [r7, #20]
            }
        }
    }

    return found_p;
 80131ce:	697b      	ldr	r3, [r7, #20]
}
 80131d0:	4618      	mov	r0, r3
 80131d2:	3718      	adds	r7, #24
 80131d4:	46bd      	mov	sp, r7
 80131d6:	bd80      	pop	{r7, pc}

080131d8 <lv_refr_obj_and_children>:
 * Make the refreshing from an object. Draw all its children and the youngers too.
 * @param top_p pointer to an objects. Start the drawing from it.
 * @param mask_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj_and_children(lv_obj_t * top_p, const lv_area_t * mask_p)
{
 80131d8:	b580      	push	{r7, lr}
 80131da:	b086      	sub	sp, #24
 80131dc:	af00      	add	r7, sp, #0
 80131de:	6078      	str	r0, [r7, #4]
 80131e0:	6039      	str	r1, [r7, #0]
    /* Normally always will be a top_obj (at least the screen)
     * but in special cases (e.g. if the screen has alpha) it won't.
     * In this case use the screen directly */
    if(top_p == NULL) top_p = lv_disp_get_scr_act(disp_refr);
 80131e2:	687b      	ldr	r3, [r7, #4]
 80131e4:	2b00      	cmp	r3, #0
 80131e6:	d105      	bne.n	80131f4 <lv_refr_obj_and_children+0x1c>
 80131e8:	4b1c      	ldr	r3, [pc, #112]	; (801325c <lv_refr_obj_and_children+0x84>)
 80131ea:	681b      	ldr	r3, [r3, #0]
 80131ec:	4618      	mov	r0, r3
 80131ee:	f7fa fe35 	bl	800de5c <lv_disp_get_scr_act>
 80131f2:	6078      	str	r0, [r7, #4]

    /*Refresh the top object and its children*/
    lv_refr_obj(top_p, mask_p);
 80131f4:	6839      	ldr	r1, [r7, #0]
 80131f6:	6878      	ldr	r0, [r7, #4]
 80131f8:	f000 f832 	bl	8013260 <lv_refr_obj>

    /*Draw the 'younger' sibling objects because they can be on top_obj */
    lv_obj_t * par;
    lv_obj_t * border_p = top_p;
 80131fc:	687b      	ldr	r3, [r7, #4]
 80131fe:	613b      	str	r3, [r7, #16]

    par = lv_obj_get_parent(top_p);
 8013200:	6878      	ldr	r0, [r7, #4]
 8013202:	f7fe ff5d 	bl	80120c0 <lv_obj_get_parent>
 8013206:	6178      	str	r0, [r7, #20]

    /*Do until not reach the screen*/
    while(par != NULL) {
 8013208:	e021      	b.n	801324e <lv_refr_obj_and_children+0x76>
        /*object before border_p has to be redrawn*/
        lv_obj_t * i = lv_ll_get_prev(&(par->child_ll), border_p);
 801320a:	697b      	ldr	r3, [r7, #20]
 801320c:	3304      	adds	r3, #4
 801320e:	6939      	ldr	r1, [r7, #16]
 8013210:	4618      	mov	r0, r3
 8013212:	f009 fa33 	bl	801c67c <lv_ll_get_prev>
 8013216:	60f8      	str	r0, [r7, #12]

        while(i != NULL) {
 8013218:	e00a      	b.n	8013230 <lv_refr_obj_and_children+0x58>
            /*Refresh the objects*/
            lv_refr_obj(i, mask_p);
 801321a:	6839      	ldr	r1, [r7, #0]
 801321c:	68f8      	ldr	r0, [r7, #12]
 801321e:	f000 f81f 	bl	8013260 <lv_refr_obj>
            i = lv_ll_get_prev(&(par->child_ll), i);
 8013222:	697b      	ldr	r3, [r7, #20]
 8013224:	3304      	adds	r3, #4
 8013226:	68f9      	ldr	r1, [r7, #12]
 8013228:	4618      	mov	r0, r3
 801322a:	f009 fa27 	bl	801c67c <lv_ll_get_prev>
 801322e:	60f8      	str	r0, [r7, #12]
        while(i != NULL) {
 8013230:	68fb      	ldr	r3, [r7, #12]
 8013232:	2b00      	cmp	r3, #0
 8013234:	d1f1      	bne.n	801321a <lv_refr_obj_and_children+0x42>
        }

        /*Call the post draw design function of the parents of the to object*/
        par->design_cb(par, mask_p, LV_DESIGN_DRAW_POST);
 8013236:	697b      	ldr	r3, [r7, #20]
 8013238:	6a1b      	ldr	r3, [r3, #32]
 801323a:	2201      	movs	r2, #1
 801323c:	6839      	ldr	r1, [r7, #0]
 801323e:	6978      	ldr	r0, [r7, #20]
 8013240:	4798      	blx	r3

        /*The new border will be there last parents,
         *so the 'younger' brothers of parent will be refreshed*/
        border_p = par;
 8013242:	697b      	ldr	r3, [r7, #20]
 8013244:	613b      	str	r3, [r7, #16]
        /*Go a level deeper*/
        par = lv_obj_get_parent(par);
 8013246:	6978      	ldr	r0, [r7, #20]
 8013248:	f7fe ff3a 	bl	80120c0 <lv_obj_get_parent>
 801324c:	6178      	str	r0, [r7, #20]
    while(par != NULL) {
 801324e:	697b      	ldr	r3, [r7, #20]
 8013250:	2b00      	cmp	r3, #0
 8013252:	d1da      	bne.n	801320a <lv_refr_obj_and_children+0x32>
    }
}
 8013254:	bf00      	nop
 8013256:	3718      	adds	r7, #24
 8013258:	46bd      	mov	sp, r7
 801325a:	bd80      	pop	{r7, pc}
 801325c:	20003fac 	.word	0x20003fac

08013260 <lv_refr_obj>:
 * Refresh an object an all of its children. (Called recursively)
 * @param obj pointer to an object to refresh
 * @param mask_ori_p pointer to an area, the objects will be drawn only here
 */
static void lv_refr_obj(lv_obj_t * obj, const lv_area_t * mask_ori_p)
{
 8013260:	b580      	push	{r7, lr}
 8013262:	b08e      	sub	sp, #56	; 0x38
 8013264:	af00      	add	r7, sp, #0
 8013266:	6078      	str	r0, [r7, #4]
 8013268:	6039      	str	r1, [r7, #0]
    /*Do not refresh hidden objects*/
    if(obj->hidden != 0) return;
 801326a:	687b      	ldr	r3, [r7, #4]
 801326c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
 8013270:	f003 0310 	and.w	r3, r3, #16
 8013274:	b2db      	uxtb	r3, r3
 8013276:	2b00      	cmp	r3, #0
 8013278:	f040 80ac 	bne.w	80133d4 <lv_refr_obj+0x174>
    /* Truncate the original mask to the coordinates of the parent
     * because the parent and its children are visible only here */
    lv_area_t obj_mask;
    lv_area_t obj_ext_mask;
    lv_area_t obj_area;
    lv_coord_t ext_size = obj->ext_draw_pad;
 801327c:	687b      	ldr	r3, [r7, #4]
 801327e:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8013280:	867b      	strh	r3, [r7, #50]	; 0x32
    lv_obj_get_coords(obj, &obj_area);
 8013282:	f107 0318 	add.w	r3, r7, #24
 8013286:	4619      	mov	r1, r3
 8013288:	6878      	ldr	r0, [r7, #4]
 801328a:	f7fe ff42 	bl	8012112 <lv_obj_get_coords>
    obj_area.x1 -= ext_size;
 801328e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8013292:	b29a      	uxth	r2, r3
 8013294:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8013296:	1ad3      	subs	r3, r2, r3
 8013298:	b29b      	uxth	r3, r3
 801329a:	b21b      	sxth	r3, r3
 801329c:	833b      	strh	r3, [r7, #24]
    obj_area.y1 -= ext_size;
 801329e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80132a2:	b29a      	uxth	r2, r3
 80132a4:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80132a6:	1ad3      	subs	r3, r2, r3
 80132a8:	b29b      	uxth	r3, r3
 80132aa:	b21b      	sxth	r3, r3
 80132ac:	837b      	strh	r3, [r7, #26]
    obj_area.x2 += ext_size;
 80132ae:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80132b2:	b29a      	uxth	r2, r3
 80132b4:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80132b6:	4413      	add	r3, r2
 80132b8:	b29b      	uxth	r3, r3
 80132ba:	b21b      	sxth	r3, r3
 80132bc:	83bb      	strh	r3, [r7, #28]
    obj_area.y2 += ext_size;
 80132be:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80132c2:	b29a      	uxth	r2, r3
 80132c4:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80132c6:	4413      	add	r3, r2
 80132c8:	b29b      	uxth	r3, r3
 80132ca:	b21b      	sxth	r3, r3
 80132cc:	83fb      	strh	r3, [r7, #30]
    union_ok = lv_area_intersect(&obj_ext_mask, mask_ori_p, &obj_area);
 80132ce:	f107 0218 	add.w	r2, r7, #24
 80132d2:	f107 0320 	add.w	r3, r7, #32
 80132d6:	6839      	ldr	r1, [r7, #0]
 80132d8:	4618      	mov	r0, r3
 80132da:	f008 fbfd 	bl	801bad8 <lv_area_intersect>
 80132de:	4603      	mov	r3, r0
 80132e0:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

    /*Draw the parent and its children only if they ore on 'mask_parent'*/
    if(union_ok != false) {
 80132e4:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 80132e8:	2b00      	cmp	r3, #0
 80132ea:	d074      	beq.n	80133d6 <lv_refr_obj+0x176>

        /* Redraw the object */
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_MAIN);
 80132ec:	687b      	ldr	r3, [r7, #4]
 80132ee:	6a1b      	ldr	r3, [r3, #32]
 80132f0:	f107 0120 	add.w	r1, r7, #32
 80132f4:	2200      	movs	r2, #0
 80132f6:	6878      	ldr	r0, [r7, #4]
 80132f8:	4798      	blx	r3
        lv_draw_fill(&obj_ext_mask, &obj_ext_mask, debug_color, LV_OPA_50);
        debug_color.full *= 17;
        debug_color.full += 0xA1;
#endif
        /*Create a new 'obj_mask' without 'ext_size' because the children can't be visible there*/
        lv_obj_get_coords(obj, &obj_area);
 80132fa:	f107 0318 	add.w	r3, r7, #24
 80132fe:	4619      	mov	r1, r3
 8013300:	6878      	ldr	r0, [r7, #4]
 8013302:	f7fe ff06 	bl	8012112 <lv_obj_get_coords>
        union_ok = lv_area_intersect(&obj_mask, mask_ori_p, &obj_area);
 8013306:	f107 0218 	add.w	r2, r7, #24
 801330a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801330e:	6839      	ldr	r1, [r7, #0]
 8013310:	4618      	mov	r0, r3
 8013312:	f008 fbe1 	bl	801bad8 <lv_area_intersect>
 8013316:	4603      	mov	r3, r0
 8013318:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
        if(union_ok != false) {
 801331c:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 8013320:	2b00      	cmp	r3, #0
 8013322:	d04f      	beq.n	80133c4 <lv_refr_obj+0x164>
            lv_area_t mask_child; /*Mask from obj and its child*/
            lv_obj_t * child_p;
            lv_area_t child_area;
            LV_LL_READ_BACK(obj->child_ll, child_p)
 8013324:	687b      	ldr	r3, [r7, #4]
 8013326:	3304      	adds	r3, #4
 8013328:	4618      	mov	r0, r3
 801332a:	f009 f97a 	bl	801c622 <lv_ll_get_tail>
 801332e:	6378      	str	r0, [r7, #52]	; 0x34
 8013330:	e045      	b.n	80133be <lv_refr_obj+0x15e>
            {
                lv_obj_get_coords(child_p, &child_area);
 8013332:	f107 0308 	add.w	r3, r7, #8
 8013336:	4619      	mov	r1, r3
 8013338:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801333a:	f7fe feea 	bl	8012112 <lv_obj_get_coords>
                ext_size = child_p->ext_draw_pad;
 801333e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8013340:	8e9b      	ldrh	r3, [r3, #52]	; 0x34
 8013342:	867b      	strh	r3, [r7, #50]	; 0x32
                child_area.x1 -= ext_size;
 8013344:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8013348:	b29a      	uxth	r2, r3
 801334a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 801334c:	1ad3      	subs	r3, r2, r3
 801334e:	b29b      	uxth	r3, r3
 8013350:	b21b      	sxth	r3, r3
 8013352:	813b      	strh	r3, [r7, #8]
                child_area.y1 -= ext_size;
 8013354:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8013358:	b29a      	uxth	r2, r3
 801335a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 801335c:	1ad3      	subs	r3, r2, r3
 801335e:	b29b      	uxth	r3, r3
 8013360:	b21b      	sxth	r3, r3
 8013362:	817b      	strh	r3, [r7, #10]
                child_area.x2 += ext_size;
 8013364:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8013368:	b29a      	uxth	r2, r3
 801336a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 801336c:	4413      	add	r3, r2
 801336e:	b29b      	uxth	r3, r3
 8013370:	b21b      	sxth	r3, r3
 8013372:	81bb      	strh	r3, [r7, #12]
                child_area.y2 += ext_size;
 8013374:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8013378:	b29a      	uxth	r2, r3
 801337a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 801337c:	4413      	add	r3, r2
 801337e:	b29b      	uxth	r3, r3
 8013380:	b21b      	sxth	r3, r3
 8013382:	81fb      	strh	r3, [r7, #14]
                /* Get the union (common parts) of original mask (from obj)
                 * and its child */
                union_ok = lv_area_intersect(&mask_child, &obj_mask, &child_area);
 8013384:	f107 0208 	add.w	r2, r7, #8
 8013388:	f107 0128 	add.w	r1, r7, #40	; 0x28
 801338c:	f107 0310 	add.w	r3, r7, #16
 8013390:	4618      	mov	r0, r3
 8013392:	f008 fba1 	bl	801bad8 <lv_area_intersect>
 8013396:	4603      	mov	r3, r0
 8013398:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31

                /*If the parent and the child has common area then refresh the child */
                if(union_ok) {
 801339c:	f897 3031 	ldrb.w	r3, [r7, #49]	; 0x31
 80133a0:	2b00      	cmp	r3, #0
 80133a2:	d005      	beq.n	80133b0 <lv_refr_obj+0x150>
                    /*Refresh the next children*/
                    lv_refr_obj(child_p, &mask_child);
 80133a4:	f107 0310 	add.w	r3, r7, #16
 80133a8:	4619      	mov	r1, r3
 80133aa:	6b78      	ldr	r0, [r7, #52]	; 0x34
 80133ac:	f7ff ff58 	bl	8013260 <lv_refr_obj>
            LV_LL_READ_BACK(obj->child_ll, child_p)
 80133b0:	687b      	ldr	r3, [r7, #4]
 80133b2:	3304      	adds	r3, #4
 80133b4:	6b79      	ldr	r1, [r7, #52]	; 0x34
 80133b6:	4618      	mov	r0, r3
 80133b8:	f009 f960 	bl	801c67c <lv_ll_get_prev>
 80133bc:	6378      	str	r0, [r7, #52]	; 0x34
 80133be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80133c0:	2b00      	cmp	r3, #0
 80133c2:	d1b6      	bne.n	8013332 <lv_refr_obj+0xd2>
                }
            }
        }

        /* If all the children are redrawn make 'post draw' design */
        obj->design_cb(obj, &obj_ext_mask, LV_DESIGN_DRAW_POST);
 80133c4:	687b      	ldr	r3, [r7, #4]
 80133c6:	6a1b      	ldr	r3, [r3, #32]
 80133c8:	f107 0120 	add.w	r1, r7, #32
 80133cc:	2201      	movs	r2, #1
 80133ce:	6878      	ldr	r0, [r7, #4]
 80133d0:	4798      	blx	r3
 80133d2:	e000      	b.n	80133d6 <lv_refr_obj+0x176>
    if(obj->hidden != 0) return;
 80133d4:	bf00      	nop
    }
}
 80133d6:	3738      	adds	r7, #56	; 0x38
 80133d8:	46bd      	mov	sp, r7
 80133da:	bd80      	pop	{r7, pc}

080133dc <lv_refr_vdb_flush>:

/**
 * Flush the content of the VDB
 */
static void lv_refr_vdb_flush(void)
{
 80133dc:	b580      	push	{r7, lr}
 80133de:	b082      	sub	sp, #8
 80133e0:	af00      	add	r7, sp, #0
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp_refr);
 80133e2:	4b23      	ldr	r3, [pc, #140]	; (8013470 <lv_refr_vdb_flush+0x94>)
 80133e4:	681b      	ldr	r3, [r3, #0]
 80133e6:	4618      	mov	r0, r3
 80133e8:	f007 ff04 	bl	801b1f4 <lv_disp_get_buf>
 80133ec:	6078      	str	r0, [r7, #4]

    /*In double buffered mode wait until the other buffer is flushed before flushing the current
     * one*/
    if(lv_disp_is_double_buf(disp_refr)) {
 80133ee:	4b20      	ldr	r3, [pc, #128]	; (8013470 <lv_refr_vdb_flush+0x94>)
 80133f0:	681b      	ldr	r3, [r3, #0]
 80133f2:	4618      	mov	r0, r3
 80133f4:	f007 ff4c 	bl	801b290 <lv_disp_is_double_buf>
 80133f8:	4603      	mov	r3, r0
 80133fa:	2b00      	cmp	r3, #0
 80133fc:	d007      	beq.n	801340e <lv_refr_vdb_flush+0x32>
        while(vdb->flushing)
 80133fe:	bf00      	nop
 8013400:	687b      	ldr	r3, [r7, #4]
 8013402:	699b      	ldr	r3, [r3, #24]
 8013404:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8013408:	b2db      	uxtb	r3, r3
 801340a:	2b00      	cmp	r3, #0
 801340c:	d1f8      	bne.n	8013400 <lv_refr_vdb_flush+0x24>
            ;
    }

    vdb->flushing = 1;
 801340e:	687a      	ldr	r2, [r7, #4]
 8013410:	7e13      	ldrb	r3, [r2, #24]
 8013412:	f043 0301 	orr.w	r3, r3, #1
 8013416:	7613      	strb	r3, [r2, #24]

    /*Flush the rendered content to the display*/
    lv_disp_t * disp = lv_refr_get_disp_refreshing();
 8013418:	f7ff fb42 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 801341c:	6038      	str	r0, [r7, #0]
    if(disp->driver.flush_cb) disp->driver.flush_cb(&disp->driver, &vdb->area, vdb->buf_act);
 801341e:	683b      	ldr	r3, [r7, #0]
 8013420:	68db      	ldr	r3, [r3, #12]
 8013422:	2b00      	cmp	r3, #0
 8013424:	d008      	beq.n	8013438 <lv_refr_vdb_flush+0x5c>
 8013426:	683b      	ldr	r3, [r7, #0]
 8013428:	68db      	ldr	r3, [r3, #12]
 801342a:	6838      	ldr	r0, [r7, #0]
 801342c:	687a      	ldr	r2, [r7, #4]
 801342e:	f102 0110 	add.w	r1, r2, #16
 8013432:	687a      	ldr	r2, [r7, #4]
 8013434:	6892      	ldr	r2, [r2, #8]
 8013436:	4798      	blx	r3

    if(vdb->buf1 && vdb->buf2) {
 8013438:	687b      	ldr	r3, [r7, #4]
 801343a:	681b      	ldr	r3, [r3, #0]
 801343c:	2b00      	cmp	r3, #0
 801343e:	d012      	beq.n	8013466 <lv_refr_vdb_flush+0x8a>
 8013440:	687b      	ldr	r3, [r7, #4]
 8013442:	685b      	ldr	r3, [r3, #4]
 8013444:	2b00      	cmp	r3, #0
 8013446:	d00e      	beq.n	8013466 <lv_refr_vdb_flush+0x8a>
        if(vdb->buf_act == vdb->buf1)
 8013448:	687b      	ldr	r3, [r7, #4]
 801344a:	689a      	ldr	r2, [r3, #8]
 801344c:	687b      	ldr	r3, [r7, #4]
 801344e:	681b      	ldr	r3, [r3, #0]
 8013450:	429a      	cmp	r2, r3
 8013452:	d104      	bne.n	801345e <lv_refr_vdb_flush+0x82>
            vdb->buf_act = vdb->buf2;
 8013454:	687b      	ldr	r3, [r7, #4]
 8013456:	685a      	ldr	r2, [r3, #4]
 8013458:	687b      	ldr	r3, [r7, #4]
 801345a:	609a      	str	r2, [r3, #8]
        else
            vdb->buf_act = vdb->buf1;
    }
}
 801345c:	e003      	b.n	8013466 <lv_refr_vdb_flush+0x8a>
            vdb->buf_act = vdb->buf1;
 801345e:	687b      	ldr	r3, [r7, #4]
 8013460:	681a      	ldr	r2, [r3, #0]
 8013462:	687b      	ldr	r3, [r7, #4]
 8013464:	609a      	str	r2, [r3, #8]
}
 8013466:	bf00      	nop
 8013468:	3708      	adds	r7, #8
 801346a:	46bd      	mov	sp, r7
 801346c:	bd80      	pop	{r7, pc}
 801346e:	bf00      	nop
 8013470:	20003fac 	.word	0x20003fac

08013474 <lv_color_mix>:
{
 8013474:	b480      	push	{r7}
 8013476:	b085      	sub	sp, #20
 8013478:	af00      	add	r7, sp, #0
 801347a:	80b8      	strh	r0, [r7, #4]
 801347c:	8039      	strh	r1, [r7, #0]
 801347e:	4613      	mov	r3, r2
 8013480:	70fb      	strb	r3, [r7, #3]
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 8013482:	797b      	ldrb	r3, [r7, #5]
 8013484:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 8013488:	b2db      	uxtb	r3, r3
 801348a:	b29a      	uxth	r2, r3
 801348c:	78fb      	ldrb	r3, [r7, #3]
 801348e:	b29b      	uxth	r3, r3
 8013490:	fb12 f303 	smulbb	r3, r2, r3
 8013494:	b29a      	uxth	r2, r3
 8013496:	787b      	ldrb	r3, [r7, #1]
 8013498:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 801349c:	b2db      	uxtb	r3, r3
 801349e:	b299      	uxth	r1, r3
 80134a0:	78fb      	ldrb	r3, [r7, #3]
 80134a2:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80134a6:	b29b      	uxth	r3, r3
 80134a8:	fb11 f303 	smulbb	r3, r1, r3
 80134ac:	b29b      	uxth	r3, r3
 80134ae:	4413      	add	r3, r2
 80134b0:	b29b      	uxth	r3, r3
 80134b2:	0a1b      	lsrs	r3, r3, #8
 80134b4:	b29b      	uxth	r3, r3
 80134b6:	f003 031f 	and.w	r3, r3, #31
 80134ba:	b2da      	uxtb	r2, r3
 80134bc:	7b7b      	ldrb	r3, [r7, #13]
 80134be:	f362 03c7 	bfi	r3, r2, #3, #5
 80134c2:	737b      	strb	r3, [r7, #13]
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 80134c4:	88bb      	ldrh	r3, [r7, #4]
 80134c6:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80134ca:	b2db      	uxtb	r3, r3
 80134cc:	b29a      	uxth	r2, r3
 80134ce:	78fb      	ldrb	r3, [r7, #3]
 80134d0:	b29b      	uxth	r3, r3
 80134d2:	fb12 f303 	smulbb	r3, r2, r3
 80134d6:	b29a      	uxth	r2, r3
 80134d8:	883b      	ldrh	r3, [r7, #0]
 80134da:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80134de:	b2db      	uxtb	r3, r3
 80134e0:	b299      	uxth	r1, r3
 80134e2:	78fb      	ldrb	r3, [r7, #3]
 80134e4:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80134e8:	b29b      	uxth	r3, r3
 80134ea:	fb11 f303 	smulbb	r3, r1, r3
 80134ee:	b29b      	uxth	r3, r3
 80134f0:	4413      	add	r3, r2
 80134f2:	b29b      	uxth	r3, r3
 80134f4:	0a1b      	lsrs	r3, r3, #8
 80134f6:	b29b      	uxth	r3, r3
 80134f8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80134fc:	b2da      	uxtb	r2, r3
 80134fe:	89bb      	ldrh	r3, [r7, #12]
 8013500:	f362 134a 	bfi	r3, r2, #5, #6
 8013504:	81bb      	strh	r3, [r7, #12]
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 8013506:	793b      	ldrb	r3, [r7, #4]
 8013508:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801350c:	b2db      	uxtb	r3, r3
 801350e:	b29a      	uxth	r2, r3
 8013510:	78fb      	ldrb	r3, [r7, #3]
 8013512:	b29b      	uxth	r3, r3
 8013514:	fb12 f303 	smulbb	r3, r2, r3
 8013518:	b29a      	uxth	r2, r3
 801351a:	783b      	ldrb	r3, [r7, #0]
 801351c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8013520:	b2db      	uxtb	r3, r3
 8013522:	b299      	uxth	r1, r3
 8013524:	78fb      	ldrb	r3, [r7, #3]
 8013526:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801352a:	b29b      	uxth	r3, r3
 801352c:	fb11 f303 	smulbb	r3, r1, r3
 8013530:	b29b      	uxth	r3, r3
 8013532:	4413      	add	r3, r2
 8013534:	b29b      	uxth	r3, r3
 8013536:	0a1b      	lsrs	r3, r3, #8
 8013538:	b29b      	uxth	r3, r3
 801353a:	f003 031f 	and.w	r3, r3, #31
 801353e:	b2da      	uxtb	r2, r3
 8013540:	7b3b      	ldrb	r3, [r7, #12]
 8013542:	f362 0304 	bfi	r3, r2, #0, #5
 8013546:	733b      	strb	r3, [r7, #12]
    return ret;
 8013548:	89bb      	ldrh	r3, [r7, #12]
}
 801354a:	4618      	mov	r0, r3
 801354c:	3714      	adds	r7, #20
 801354e:	46bd      	mov	sp, r7
 8013550:	f85d 7b04 	ldr.w	r7, [sp], #4
 8013554:	4770      	bx	lr

08013556 <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 8013556:	b480      	push	{r7}
 8013558:	b085      	sub	sp, #20
 801355a:	af00      	add	r7, sp, #0
 801355c:	4603      	mov	r3, r0
 801355e:	71fb      	strb	r3, [r7, #7]
 8013560:	460b      	mov	r3, r1
 8013562:	71bb      	strb	r3, [r7, #6]
 8013564:	4613      	mov	r3, r2
 8013566:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 8013568:	797b      	ldrb	r3, [r7, #5]
 801356a:	08db      	lsrs	r3, r3, #3
 801356c:	b2db      	uxtb	r3, r3
 801356e:	f003 031f 	and.w	r3, r3, #31
 8013572:	b2da      	uxtb	r2, r3
 8013574:	7b3b      	ldrb	r3, [r7, #12]
 8013576:	f362 0304 	bfi	r3, r2, #0, #5
 801357a:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 801357c:	79bb      	ldrb	r3, [r7, #6]
 801357e:	089b      	lsrs	r3, r3, #2
 8013580:	b2db      	uxtb	r3, r3
 8013582:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8013586:	b2da      	uxtb	r2, r3
 8013588:	89bb      	ldrh	r3, [r7, #12]
 801358a:	f362 134a 	bfi	r3, r2, #5, #6
 801358e:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 8013590:	79fb      	ldrb	r3, [r7, #7]
 8013592:	08db      	lsrs	r3, r3, #3
 8013594:	b2db      	uxtb	r3, r3
 8013596:	f003 031f 	and.w	r3, r3, #31
 801359a:	b2da      	uxtb	r2, r3
 801359c:	7b7b      	ldrb	r3, [r7, #13]
 801359e:	f362 03c7 	bfi	r3, r2, #3, #5
 80135a2:	737b      	strb	r3, [r7, #13]
    return color;
 80135a4:	89bb      	ldrh	r3, [r7, #12]
}
 80135a6:	4618      	mov	r0, r3
 80135a8:	3714      	adds	r7, #20
 80135aa:	46bd      	mov	sp, r7
 80135ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 80135b0:	4770      	bx	lr
	...

080135b4 <lv_style_init>:

/**
 *  Init the basic styles
 */
void lv_style_init(void)
{
 80135b4:	b598      	push	{r3, r4, r7, lr}
 80135b6:	af00      	add	r7, sp, #0
    /* Not White/Black/Gray colors are created by HSV model with
     * HUE = 210*/

    /*Screen style*/
    lv_style_scr.glass               = 0;
 80135b8:	4aae      	ldr	r2, [pc, #696]	; (8013874 <lv_style_init+0x2c0>)
 80135ba:	7813      	ldrb	r3, [r2, #0]
 80135bc:	f36f 0300 	bfc	r3, #0, #1
 80135c0:	7013      	strb	r3, [r2, #0]
    lv_style_scr.body.opa            = LV_OPA_COVER;
 80135c2:	4bac      	ldr	r3, [pc, #688]	; (8013874 <lv_style_init+0x2c0>)
 80135c4:	22ff      	movs	r2, #255	; 0xff
 80135c6:	721a      	strb	r2, [r3, #8]
    lv_style_scr.body.main_color     = LV_COLOR_WHITE;
 80135c8:	4aaa      	ldr	r2, [pc, #680]	; (8013874 <lv_style_init+0x2c0>)
 80135ca:	4bab      	ldr	r3, [pc, #684]	; (8013878 <lv_style_init+0x2c4>)
 80135cc:	881b      	ldrh	r3, [r3, #0]
 80135ce:	8053      	strh	r3, [r2, #2]
    lv_style_scr.body.grad_color     = LV_COLOR_WHITE;
 80135d0:	4aa8      	ldr	r2, [pc, #672]	; (8013874 <lv_style_init+0x2c0>)
 80135d2:	4ba9      	ldr	r3, [pc, #676]	; (8013878 <lv_style_init+0x2c4>)
 80135d4:	881b      	ldrh	r3, [r3, #0]
 80135d6:	8093      	strh	r3, [r2, #4]
    lv_style_scr.body.radius         = 0;
 80135d8:	4ba6      	ldr	r3, [pc, #664]	; (8013874 <lv_style_init+0x2c0>)
 80135da:	2200      	movs	r2, #0
 80135dc:	80da      	strh	r2, [r3, #6]
    lv_style_scr.body.padding.left   = 0;
 80135de:	4ba5      	ldr	r3, [pc, #660]	; (8013874 <lv_style_init+0x2c0>)
 80135e0:	2200      	movs	r2, #0
 80135e2:	835a      	strh	r2, [r3, #26]
    lv_style_scr.body.padding.right  = 0;
 80135e4:	4ba3      	ldr	r3, [pc, #652]	; (8013874 <lv_style_init+0x2c0>)
 80135e6:	2200      	movs	r2, #0
 80135e8:	839a      	strh	r2, [r3, #28]
    lv_style_scr.body.padding.top    = 0;
 80135ea:	4ba2      	ldr	r3, [pc, #648]	; (8013874 <lv_style_init+0x2c0>)
 80135ec:	2200      	movs	r2, #0
 80135ee:	82da      	strh	r2, [r3, #22]
    lv_style_scr.body.padding.bottom = 0;
 80135f0:	4ba0      	ldr	r3, [pc, #640]	; (8013874 <lv_style_init+0x2c0>)
 80135f2:	2200      	movs	r2, #0
 80135f4:	831a      	strh	r2, [r3, #24]
    lv_style_scr.body.padding.inner  = LV_DPI / 20;
 80135f6:	4b9f      	ldr	r3, [pc, #636]	; (8013874 <lv_style_init+0x2c0>)
 80135f8:	2205      	movs	r2, #5
 80135fa:	83da      	strh	r2, [r3, #30]

    lv_style_scr.body.border.color = LV_COLOR_BLACK;
 80135fc:	4a9d      	ldr	r2, [pc, #628]	; (8013874 <lv_style_init+0x2c0>)
 80135fe:	7a93      	ldrb	r3, [r2, #10]
 8013600:	f36f 0304 	bfc	r3, #0, #5
 8013604:	7293      	strb	r3, [r2, #10]
 8013606:	4a9b      	ldr	r2, [pc, #620]	; (8013874 <lv_style_init+0x2c0>)
 8013608:	8953      	ldrh	r3, [r2, #10]
 801360a:	f36f 134a 	bfc	r3, #5, #6
 801360e:	8153      	strh	r3, [r2, #10]
 8013610:	4a98      	ldr	r2, [pc, #608]	; (8013874 <lv_style_init+0x2c0>)
 8013612:	7ad3      	ldrb	r3, [r2, #11]
 8013614:	f36f 03c7 	bfc	r3, #3, #5
 8013618:	72d3      	strb	r3, [r2, #11]
    lv_style_scr.body.border.opa   = LV_OPA_COVER;
 801361a:	4b96      	ldr	r3, [pc, #600]	; (8013874 <lv_style_init+0x2c0>)
 801361c:	22ff      	movs	r2, #255	; 0xff
 801361e:	73da      	strb	r2, [r3, #15]
    lv_style_scr.body.border.width = 0;
 8013620:	4b94      	ldr	r3, [pc, #592]	; (8013874 <lv_style_init+0x2c0>)
 8013622:	2200      	movs	r2, #0
 8013624:	819a      	strh	r2, [r3, #12]
    lv_style_scr.body.border.part  = LV_BORDER_FULL;
 8013626:	4b93      	ldr	r3, [pc, #588]	; (8013874 <lv_style_init+0x2c0>)
 8013628:	220f      	movs	r2, #15
 801362a:	739a      	strb	r2, [r3, #14]

    lv_style_scr.body.shadow.color = LV_COLOR_GRAY;
 801362c:	4a91      	ldr	r2, [pc, #580]	; (8013874 <lv_style_init+0x2c0>)
 801362e:	4b93      	ldr	r3, [pc, #588]	; (801387c <lv_style_init+0x2c8>)
 8013630:	881b      	ldrh	r3, [r3, #0]
 8013632:	8213      	strh	r3, [r2, #16]
    lv_style_scr.body.shadow.type  = LV_SHADOW_FULL;
 8013634:	4b8f      	ldr	r3, [pc, #572]	; (8013874 <lv_style_init+0x2c0>)
 8013636:	2201      	movs	r2, #1
 8013638:	751a      	strb	r2, [r3, #20]
    lv_style_scr.body.shadow.width = 0;
 801363a:	4b8e      	ldr	r3, [pc, #568]	; (8013874 <lv_style_init+0x2c0>)
 801363c:	2200      	movs	r2, #0
 801363e:	825a      	strh	r2, [r3, #18]

    lv_style_scr.text.opa          = LV_OPA_COVER;
 8013640:	4b8c      	ldr	r3, [pc, #560]	; (8013874 <lv_style_init+0x2c0>)
 8013642:	22ff      	movs	r2, #255	; 0xff
 8013644:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    lv_style_scr.text.color        = lv_color_make(0x30, 0x30, 0x30);
 8013648:	4c8a      	ldr	r4, [pc, #552]	; (8013874 <lv_style_init+0x2c0>)
 801364a:	2230      	movs	r2, #48	; 0x30
 801364c:	2130      	movs	r1, #48	; 0x30
 801364e:	2030      	movs	r0, #48	; 0x30
 8013650:	f7ff ff81 	bl	8013556 <lv_color_make>
 8013654:	8420      	strh	r0, [r4, #32]
    lv_style_scr.text.sel_color    = lv_color_make(0x55, 0x96, 0xd8);
 8013656:	4c87      	ldr	r4, [pc, #540]	; (8013874 <lv_style_init+0x2c0>)
 8013658:	22d8      	movs	r2, #216	; 0xd8
 801365a:	2196      	movs	r1, #150	; 0x96
 801365c:	2055      	movs	r0, #85	; 0x55
 801365e:	f7ff ff7a 	bl	8013556 <lv_color_make>
 8013662:	8460      	strh	r0, [r4, #34]	; 0x22
    lv_style_scr.text.font         = LV_FONT_DEFAULT;
 8013664:	4b83      	ldr	r3, [pc, #524]	; (8013874 <lv_style_init+0x2c0>)
 8013666:	4a86      	ldr	r2, [pc, #536]	; (8013880 <lv_style_init+0x2cc>)
 8013668:	625a      	str	r2, [r3, #36]	; 0x24
    lv_style_scr.text.letter_space = 0;
 801366a:	4b82      	ldr	r3, [pc, #520]	; (8013874 <lv_style_init+0x2c0>)
 801366c:	2200      	movs	r2, #0
 801366e:	851a      	strh	r2, [r3, #40]	; 0x28
    lv_style_scr.text.line_space   = 2;
 8013670:	4b80      	ldr	r3, [pc, #512]	; (8013874 <lv_style_init+0x2c0>)
 8013672:	2202      	movs	r2, #2
 8013674:	855a      	strh	r2, [r3, #42]	; 0x2a

    lv_style_scr.image.opa     = LV_OPA_COVER;
 8013676:	4b7f      	ldr	r3, [pc, #508]	; (8013874 <lv_style_init+0x2c0>)
 8013678:	22ff      	movs	r2, #255	; 0xff
 801367a:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
    lv_style_scr.image.color   = lv_color_make(0x20, 0x20, 0x20);
 801367e:	4c7d      	ldr	r4, [pc, #500]	; (8013874 <lv_style_init+0x2c0>)
 8013680:	2220      	movs	r2, #32
 8013682:	2120      	movs	r1, #32
 8013684:	2020      	movs	r0, #32
 8013686:	f7ff ff66 	bl	8013556 <lv_color_make>
 801368a:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_scr.image.intense = LV_OPA_TRANSP;
 801368c:	4b79      	ldr	r3, [pc, #484]	; (8013874 <lv_style_init+0x2c0>)
 801368e:	2200      	movs	r2, #0
 8013690:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

    lv_style_scr.line.opa     = LV_OPA_COVER;
 8013694:	4b77      	ldr	r3, [pc, #476]	; (8013874 <lv_style_init+0x2c0>)
 8013696:	22ff      	movs	r2, #255	; 0xff
 8013698:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    lv_style_scr.line.color   = lv_color_make(0x20, 0x20, 0x20);
 801369c:	4c75      	ldr	r4, [pc, #468]	; (8013874 <lv_style_init+0x2c0>)
 801369e:	2220      	movs	r2, #32
 80136a0:	2120      	movs	r1, #32
 80136a2:	2020      	movs	r0, #32
 80136a4:	f7ff ff57 	bl	8013556 <lv_color_make>
 80136a8:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_scr.line.width   = 2;
 80136aa:	4b72      	ldr	r3, [pc, #456]	; (8013874 <lv_style_init+0x2c0>)
 80136ac:	2202      	movs	r2, #2
 80136ae:	86da      	strh	r2, [r3, #54]	; 0x36
    lv_style_scr.line.rounded = 0;
 80136b0:	4a70      	ldr	r2, [pc, #448]	; (8013874 <lv_style_init+0x2c0>)
 80136b2:	f892 3039 	ldrb.w	r3, [r2, #57]	; 0x39
 80136b6:	f36f 0300 	bfc	r3, #0, #1
 80136ba:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39

    /*Plain style (by default near the same as the screen style)*/
    lv_style_copy(&lv_style_plain, &lv_style_scr);
 80136be:	496d      	ldr	r1, [pc, #436]	; (8013874 <lv_style_init+0x2c0>)
 80136c0:	4870      	ldr	r0, [pc, #448]	; (8013884 <lv_style_init+0x2d0>)
 80136c2:	f000 f9cf 	bl	8013a64 <lv_style_copy>
    lv_style_plain.body.padding.left   = LV_DPI / 20;
 80136c6:	4b6f      	ldr	r3, [pc, #444]	; (8013884 <lv_style_init+0x2d0>)
 80136c8:	2205      	movs	r2, #5
 80136ca:	835a      	strh	r2, [r3, #26]
    lv_style_plain.body.padding.right  = LV_DPI / 20;
 80136cc:	4b6d      	ldr	r3, [pc, #436]	; (8013884 <lv_style_init+0x2d0>)
 80136ce:	2205      	movs	r2, #5
 80136d0:	839a      	strh	r2, [r3, #28]
    lv_style_plain.body.padding.top    = LV_DPI / 20;
 80136d2:	4b6c      	ldr	r3, [pc, #432]	; (8013884 <lv_style_init+0x2d0>)
 80136d4:	2205      	movs	r2, #5
 80136d6:	82da      	strh	r2, [r3, #22]
    lv_style_plain.body.padding.bottom = LV_DPI / 20;
 80136d8:	4b6a      	ldr	r3, [pc, #424]	; (8013884 <lv_style_init+0x2d0>)
 80136da:	2205      	movs	r2, #5
 80136dc:	831a      	strh	r2, [r3, #24]

    /*Plain color style*/
    lv_style_copy(&lv_style_plain_color, &lv_style_plain);
 80136de:	4969      	ldr	r1, [pc, #420]	; (8013884 <lv_style_init+0x2d0>)
 80136e0:	4869      	ldr	r0, [pc, #420]	; (8013888 <lv_style_init+0x2d4>)
 80136e2:	f000 f9bf 	bl	8013a64 <lv_style_copy>
    lv_style_plain_color.text.color      = lv_color_make(0xf0, 0xf0, 0xf0);
 80136e6:	4c68      	ldr	r4, [pc, #416]	; (8013888 <lv_style_init+0x2d4>)
 80136e8:	22f0      	movs	r2, #240	; 0xf0
 80136ea:	21f0      	movs	r1, #240	; 0xf0
 80136ec:	20f0      	movs	r0, #240	; 0xf0
 80136ee:	f7ff ff32 	bl	8013556 <lv_color_make>
 80136f2:	8420      	strh	r0, [r4, #32]
    lv_style_plain_color.image.color     = lv_color_make(0xf0, 0xf0, 0xf0);
 80136f4:	4c64      	ldr	r4, [pc, #400]	; (8013888 <lv_style_init+0x2d4>)
 80136f6:	22f0      	movs	r2, #240	; 0xf0
 80136f8:	21f0      	movs	r1, #240	; 0xf0
 80136fa:	20f0      	movs	r0, #240	; 0xf0
 80136fc:	f7ff ff2b 	bl	8013556 <lv_color_make>
 8013700:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_plain_color.line.color      = lv_color_make(0xf0, 0xf0, 0xf0);
 8013702:	4c61      	ldr	r4, [pc, #388]	; (8013888 <lv_style_init+0x2d4>)
 8013704:	22f0      	movs	r2, #240	; 0xf0
 8013706:	21f0      	movs	r1, #240	; 0xf0
 8013708:	20f0      	movs	r0, #240	; 0xf0
 801370a:	f7ff ff24 	bl	8013556 <lv_color_make>
 801370e:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_plain_color.body.main_color = lv_color_make(0x55, 0x96, 0xd8);
 8013710:	4c5d      	ldr	r4, [pc, #372]	; (8013888 <lv_style_init+0x2d4>)
 8013712:	22d8      	movs	r2, #216	; 0xd8
 8013714:	2196      	movs	r1, #150	; 0x96
 8013716:	2055      	movs	r0, #85	; 0x55
 8013718:	f7ff ff1d 	bl	8013556 <lv_color_make>
 801371c:	8060      	strh	r0, [r4, #2]
    lv_style_plain_color.body.grad_color = lv_style_plain_color.body.main_color;
 801371e:	4a5a      	ldr	r2, [pc, #360]	; (8013888 <lv_style_init+0x2d4>)
 8013720:	4b59      	ldr	r3, [pc, #356]	; (8013888 <lv_style_init+0x2d4>)
 8013722:	885b      	ldrh	r3, [r3, #2]
 8013724:	8093      	strh	r3, [r2, #4]

    /*Pretty style */
    lv_style_copy(&lv_style_pretty, &lv_style_plain);
 8013726:	4957      	ldr	r1, [pc, #348]	; (8013884 <lv_style_init+0x2d0>)
 8013728:	4858      	ldr	r0, [pc, #352]	; (801388c <lv_style_init+0x2d8>)
 801372a:	f000 f99b 	bl	8013a64 <lv_style_copy>
    lv_style_pretty.text.color        = lv_color_make(0x20, 0x20, 0x20);
 801372e:	4c57      	ldr	r4, [pc, #348]	; (801388c <lv_style_init+0x2d8>)
 8013730:	2220      	movs	r2, #32
 8013732:	2120      	movs	r1, #32
 8013734:	2020      	movs	r0, #32
 8013736:	f7ff ff0e 	bl	8013556 <lv_color_make>
 801373a:	8420      	strh	r0, [r4, #32]
    lv_style_pretty.image.color       = lv_color_make(0x20, 0x20, 0x20);
 801373c:	4c53      	ldr	r4, [pc, #332]	; (801388c <lv_style_init+0x2d8>)
 801373e:	2220      	movs	r2, #32
 8013740:	2120      	movs	r1, #32
 8013742:	2020      	movs	r0, #32
 8013744:	f7ff ff07 	bl	8013556 <lv_color_make>
 8013748:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_pretty.line.color        = lv_color_make(0x20, 0x20, 0x20);
 801374a:	4c50      	ldr	r4, [pc, #320]	; (801388c <lv_style_init+0x2d8>)
 801374c:	2220      	movs	r2, #32
 801374e:	2120      	movs	r1, #32
 8013750:	2020      	movs	r0, #32
 8013752:	f7ff ff00 	bl	8013556 <lv_color_make>
 8013756:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_pretty.body.main_color   = LV_COLOR_WHITE;
 8013758:	4a4c      	ldr	r2, [pc, #304]	; (801388c <lv_style_init+0x2d8>)
 801375a:	4b47      	ldr	r3, [pc, #284]	; (8013878 <lv_style_init+0x2c4>)
 801375c:	881b      	ldrh	r3, [r3, #0]
 801375e:	8053      	strh	r3, [r2, #2]
    lv_style_pretty.body.grad_color   = LV_COLOR_SILVER;
 8013760:	4a4a      	ldr	r2, [pc, #296]	; (801388c <lv_style_init+0x2d8>)
 8013762:	4b4b      	ldr	r3, [pc, #300]	; (8013890 <lv_style_init+0x2dc>)
 8013764:	881b      	ldrh	r3, [r3, #0]
 8013766:	8093      	strh	r3, [r2, #4]
    lv_style_pretty.body.radius       = LV_DPI / 15;
 8013768:	4b48      	ldr	r3, [pc, #288]	; (801388c <lv_style_init+0x2d8>)
 801376a:	2206      	movs	r2, #6
 801376c:	80da      	strh	r2, [r3, #6]
    lv_style_pretty.body.border.color = lv_color_make(0x40, 0x40, 0x40);
 801376e:	4c47      	ldr	r4, [pc, #284]	; (801388c <lv_style_init+0x2d8>)
 8013770:	2240      	movs	r2, #64	; 0x40
 8013772:	2140      	movs	r1, #64	; 0x40
 8013774:	2040      	movs	r0, #64	; 0x40
 8013776:	f7ff feee 	bl	8013556 <lv_color_make>
 801377a:	8160      	strh	r0, [r4, #10]
    lv_style_pretty.body.border.width = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
 801377c:	4b43      	ldr	r3, [pc, #268]	; (801388c <lv_style_init+0x2d8>)
 801377e:	2202      	movs	r2, #2
 8013780:	819a      	strh	r2, [r3, #12]
    lv_style_pretty.body.border.opa   = LV_OPA_30;
 8013782:	4b42      	ldr	r3, [pc, #264]	; (801388c <lv_style_init+0x2d8>)
 8013784:	224c      	movs	r2, #76	; 0x4c
 8013786:	73da      	strb	r2, [r3, #15]

    /*Pretty color style*/
    lv_style_copy(&lv_style_pretty_color, &lv_style_pretty);
 8013788:	4940      	ldr	r1, [pc, #256]	; (801388c <lv_style_init+0x2d8>)
 801378a:	4842      	ldr	r0, [pc, #264]	; (8013894 <lv_style_init+0x2e0>)
 801378c:	f000 f96a 	bl	8013a64 <lv_style_copy>
    lv_style_pretty_color.text.color        = lv_color_make(0xe0, 0xe0, 0xe0);
 8013790:	4c40      	ldr	r4, [pc, #256]	; (8013894 <lv_style_init+0x2e0>)
 8013792:	22e0      	movs	r2, #224	; 0xe0
 8013794:	21e0      	movs	r1, #224	; 0xe0
 8013796:	20e0      	movs	r0, #224	; 0xe0
 8013798:	f7ff fedd 	bl	8013556 <lv_color_make>
 801379c:	8420      	strh	r0, [r4, #32]
    lv_style_pretty_color.image.color       = lv_color_make(0xe0, 0xe0, 0xe0);
 801379e:	4c3d      	ldr	r4, [pc, #244]	; (8013894 <lv_style_init+0x2e0>)
 80137a0:	22e0      	movs	r2, #224	; 0xe0
 80137a2:	21e0      	movs	r1, #224	; 0xe0
 80137a4:	20e0      	movs	r0, #224	; 0xe0
 80137a6:	f7ff fed6 	bl	8013556 <lv_color_make>
 80137aa:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_pretty_color.line.color        = lv_color_make(0xc0, 0xc0, 0xc0);
 80137ac:	4c39      	ldr	r4, [pc, #228]	; (8013894 <lv_style_init+0x2e0>)
 80137ae:	22c0      	movs	r2, #192	; 0xc0
 80137b0:	21c0      	movs	r1, #192	; 0xc0
 80137b2:	20c0      	movs	r0, #192	; 0xc0
 80137b4:	f7ff fecf 	bl	8013556 <lv_color_make>
 80137b8:	86a0      	strh	r0, [r4, #52]	; 0x34
    lv_style_pretty_color.body.main_color   = lv_color_make(0x6b, 0x9a, 0xc7);
 80137ba:	4c36      	ldr	r4, [pc, #216]	; (8013894 <lv_style_init+0x2e0>)
 80137bc:	22c7      	movs	r2, #199	; 0xc7
 80137be:	219a      	movs	r1, #154	; 0x9a
 80137c0:	206b      	movs	r0, #107	; 0x6b
 80137c2:	f7ff fec8 	bl	8013556 <lv_color_make>
 80137c6:	8060      	strh	r0, [r4, #2]
    lv_style_pretty_color.body.grad_color   = lv_color_make(0x2b, 0x59, 0x8b);
 80137c8:	4c32      	ldr	r4, [pc, #200]	; (8013894 <lv_style_init+0x2e0>)
 80137ca:	228b      	movs	r2, #139	; 0x8b
 80137cc:	2159      	movs	r1, #89	; 0x59
 80137ce:	202b      	movs	r0, #43	; 0x2b
 80137d0:	f7ff fec1 	bl	8013556 <lv_color_make>
 80137d4:	80a0      	strh	r0, [r4, #4]
    lv_style_pretty_color.body.border.color = lv_color_make(0x15, 0x2c, 0x42);
 80137d6:	4c2f      	ldr	r4, [pc, #188]	; (8013894 <lv_style_init+0x2e0>)
 80137d8:	2242      	movs	r2, #66	; 0x42
 80137da:	212c      	movs	r1, #44	; 0x2c
 80137dc:	2015      	movs	r0, #21
 80137de:	f7ff feba 	bl	8013556 <lv_color_make>
 80137e2:	8160      	strh	r0, [r4, #10]

    /*Transparent style*/
    lv_style_copy(&lv_style_transp, &lv_style_plain);
 80137e4:	4927      	ldr	r1, [pc, #156]	; (8013884 <lv_style_init+0x2d0>)
 80137e6:	482c      	ldr	r0, [pc, #176]	; (8013898 <lv_style_init+0x2e4>)
 80137e8:	f000 f93c 	bl	8013a64 <lv_style_copy>
    lv_style_transp.glass             = 1;
 80137ec:	4a2a      	ldr	r2, [pc, #168]	; (8013898 <lv_style_init+0x2e4>)
 80137ee:	7813      	ldrb	r3, [r2, #0]
 80137f0:	f043 0301 	orr.w	r3, r3, #1
 80137f4:	7013      	strb	r3, [r2, #0]
    lv_style_transp.body.border.width = 0;
 80137f6:	4b28      	ldr	r3, [pc, #160]	; (8013898 <lv_style_init+0x2e4>)
 80137f8:	2200      	movs	r2, #0
 80137fa:	819a      	strh	r2, [r3, #12]
    lv_style_transp.body.opa          = LV_OPA_TRANSP;
 80137fc:	4b26      	ldr	r3, [pc, #152]	; (8013898 <lv_style_init+0x2e4>)
 80137fe:	2200      	movs	r2, #0
 8013800:	721a      	strb	r2, [r3, #8]

    /*Transparent fitting size*/
    lv_style_copy(&lv_style_transp_fit, &lv_style_transp);
 8013802:	4925      	ldr	r1, [pc, #148]	; (8013898 <lv_style_init+0x2e4>)
 8013804:	4825      	ldr	r0, [pc, #148]	; (801389c <lv_style_init+0x2e8>)
 8013806:	f000 f92d 	bl	8013a64 <lv_style_copy>
    lv_style_transp_fit.body.padding.left   = 0;
 801380a:	4b24      	ldr	r3, [pc, #144]	; (801389c <lv_style_init+0x2e8>)
 801380c:	2200      	movs	r2, #0
 801380e:	835a      	strh	r2, [r3, #26]
    lv_style_transp_fit.body.padding.right  = 0;
 8013810:	4b22      	ldr	r3, [pc, #136]	; (801389c <lv_style_init+0x2e8>)
 8013812:	2200      	movs	r2, #0
 8013814:	839a      	strh	r2, [r3, #28]
    lv_style_transp_fit.body.padding.top    = 0;
 8013816:	4b21      	ldr	r3, [pc, #132]	; (801389c <lv_style_init+0x2e8>)
 8013818:	2200      	movs	r2, #0
 801381a:	82da      	strh	r2, [r3, #22]
    lv_style_transp_fit.body.padding.bottom = 0;
 801381c:	4b1f      	ldr	r3, [pc, #124]	; (801389c <lv_style_init+0x2e8>)
 801381e:	2200      	movs	r2, #0
 8013820:	831a      	strh	r2, [r3, #24]

    /*Transparent tight style*/
    lv_style_copy(&lv_style_transp_tight, &lv_style_transp_fit);
 8013822:	491e      	ldr	r1, [pc, #120]	; (801389c <lv_style_init+0x2e8>)
 8013824:	481e      	ldr	r0, [pc, #120]	; (80138a0 <lv_style_init+0x2ec>)
 8013826:	f000 f91d 	bl	8013a64 <lv_style_copy>
    lv_style_transp_tight.body.padding.inner = 0;
 801382a:	4b1d      	ldr	r3, [pc, #116]	; (80138a0 <lv_style_init+0x2ec>)
 801382c:	2200      	movs	r2, #0
 801382e:	83da      	strh	r2, [r3, #30]

    /*Button released style*/
    lv_style_copy(&lv_style_btn_rel, &lv_style_plain);
 8013830:	4914      	ldr	r1, [pc, #80]	; (8013884 <lv_style_init+0x2d0>)
 8013832:	481c      	ldr	r0, [pc, #112]	; (80138a4 <lv_style_init+0x2f0>)
 8013834:	f000 f916 	bl	8013a64 <lv_style_copy>
    lv_style_btn_rel.body.main_color     = lv_color_make(0x76, 0xa2, 0xd0);
 8013838:	4c1a      	ldr	r4, [pc, #104]	; (80138a4 <lv_style_init+0x2f0>)
 801383a:	22d0      	movs	r2, #208	; 0xd0
 801383c:	21a2      	movs	r1, #162	; 0xa2
 801383e:	2076      	movs	r0, #118	; 0x76
 8013840:	f7ff fe89 	bl	8013556 <lv_color_make>
 8013844:	8060      	strh	r0, [r4, #2]
    lv_style_btn_rel.body.grad_color     = lv_color_make(0x19, 0x3a, 0x5d);
 8013846:	4c17      	ldr	r4, [pc, #92]	; (80138a4 <lv_style_init+0x2f0>)
 8013848:	225d      	movs	r2, #93	; 0x5d
 801384a:	213a      	movs	r1, #58	; 0x3a
 801384c:	2019      	movs	r0, #25
 801384e:	f7ff fe82 	bl	8013556 <lv_color_make>
 8013852:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_rel.body.radius         = LV_DPI / 15;
 8013854:	4b13      	ldr	r3, [pc, #76]	; (80138a4 <lv_style_init+0x2f0>)
 8013856:	2206      	movs	r2, #6
 8013858:	80da      	strh	r2, [r3, #6]
    lv_style_btn_rel.body.padding.left   = LV_DPI / 4;
 801385a:	4b12      	ldr	r3, [pc, #72]	; (80138a4 <lv_style_init+0x2f0>)
 801385c:	2219      	movs	r2, #25
 801385e:	835a      	strh	r2, [r3, #26]
    lv_style_btn_rel.body.padding.right  = LV_DPI / 4;
 8013860:	4b10      	ldr	r3, [pc, #64]	; (80138a4 <lv_style_init+0x2f0>)
 8013862:	2219      	movs	r2, #25
 8013864:	839a      	strh	r2, [r3, #28]
    lv_style_btn_rel.body.padding.top    = LV_DPI / 6;
 8013866:	4b0f      	ldr	r3, [pc, #60]	; (80138a4 <lv_style_init+0x2f0>)
 8013868:	2210      	movs	r2, #16
 801386a:	82da      	strh	r2, [r3, #22]
    lv_style_btn_rel.body.padding.bottom = LV_DPI / 6;
 801386c:	4b0d      	ldr	r3, [pc, #52]	; (80138a4 <lv_style_init+0x2f0>)
 801386e:	2210      	movs	r2, #16
 8013870:	831a      	strh	r2, [r3, #24]
 8013872:	e019      	b.n	80138a8 <lv_style_init+0x2f4>
 8013874:	2000de90 	.word	0x2000de90
 8013878:	080288d8 	.word	0x080288d8
 801387c:	080288dc 	.word	0x080288dc
 8013880:	20000c1c 	.word	0x20000c1c
 8013884:	2000de18 	.word	0x2000de18
 8013888:	2000df08 	.word	0x2000df08
 801388c:	2000dd28 	.word	0x2000dd28
 8013890:	080288e0 	.word	0x080288e0
 8013894:	2000dc38 	.word	0x2000dc38
 8013898:	2000dc74 	.word	0x2000dc74
 801389c:	2000dddc 	.word	0x2000dddc
 80138a0:	2000dd64 	.word	0x2000dd64
 80138a4:	2000dcb0 	.word	0x2000dcb0
    lv_style_btn_rel.body.padding.inner  = LV_DPI / 10;
 80138a8:	4b68      	ldr	r3, [pc, #416]	; (8013a4c <lv_style_init+0x498>)
 80138aa:	220a      	movs	r2, #10
 80138ac:	83da      	strh	r2, [r3, #30]
    lv_style_btn_rel.body.border.color   = lv_color_make(0x0b, 0x19, 0x28);
 80138ae:	4c67      	ldr	r4, [pc, #412]	; (8013a4c <lv_style_init+0x498>)
 80138b0:	2228      	movs	r2, #40	; 0x28
 80138b2:	2119      	movs	r1, #25
 80138b4:	200b      	movs	r0, #11
 80138b6:	f7ff fe4e 	bl	8013556 <lv_color_make>
 80138ba:	8160      	strh	r0, [r4, #10]
    lv_style_btn_rel.body.border.width   = LV_DPI / 50 >= 1 ? LV_DPI / 50 : 1;
 80138bc:	4b63      	ldr	r3, [pc, #396]	; (8013a4c <lv_style_init+0x498>)
 80138be:	2202      	movs	r2, #2
 80138c0:	819a      	strh	r2, [r3, #12]
    lv_style_btn_rel.body.border.opa     = LV_OPA_70;
 80138c2:	4b62      	ldr	r3, [pc, #392]	; (8013a4c <lv_style_init+0x498>)
 80138c4:	22b2      	movs	r2, #178	; 0xb2
 80138c6:	73da      	strb	r2, [r3, #15]
    lv_style_btn_rel.body.shadow.color   = LV_COLOR_GRAY;
 80138c8:	4a60      	ldr	r2, [pc, #384]	; (8013a4c <lv_style_init+0x498>)
 80138ca:	4b61      	ldr	r3, [pc, #388]	; (8013a50 <lv_style_init+0x49c>)
 80138cc:	881b      	ldrh	r3, [r3, #0]
 80138ce:	8213      	strh	r3, [r2, #16]
    lv_style_btn_rel.body.shadow.width   = 0;
 80138d0:	4b5e      	ldr	r3, [pc, #376]	; (8013a4c <lv_style_init+0x498>)
 80138d2:	2200      	movs	r2, #0
 80138d4:	825a      	strh	r2, [r3, #18]
    lv_style_btn_rel.text.color          = lv_color_make(0xff, 0xff, 0xff);
 80138d6:	4c5d      	ldr	r4, [pc, #372]	; (8013a4c <lv_style_init+0x498>)
 80138d8:	22ff      	movs	r2, #255	; 0xff
 80138da:	21ff      	movs	r1, #255	; 0xff
 80138dc:	20ff      	movs	r0, #255	; 0xff
 80138de:	f7ff fe3a 	bl	8013556 <lv_color_make>
 80138e2:	8420      	strh	r0, [r4, #32]
    lv_style_btn_rel.image.color         = lv_color_make(0xff, 0xff, 0xff);
 80138e4:	4c59      	ldr	r4, [pc, #356]	; (8013a4c <lv_style_init+0x498>)
 80138e6:	22ff      	movs	r2, #255	; 0xff
 80138e8:	21ff      	movs	r1, #255	; 0xff
 80138ea:	20ff      	movs	r0, #255	; 0xff
 80138ec:	f7ff fe33 	bl	8013556 <lv_color_make>
 80138f0:	8620      	strh	r0, [r4, #48]	; 0x30

    /*Button pressed style*/
    lv_style_copy(&lv_style_btn_pr, &lv_style_btn_rel);
 80138f2:	4956      	ldr	r1, [pc, #344]	; (8013a4c <lv_style_init+0x498>)
 80138f4:	4857      	ldr	r0, [pc, #348]	; (8013a54 <lv_style_init+0x4a0>)
 80138f6:	f000 f8b5 	bl	8013a64 <lv_style_copy>
    lv_style_btn_pr.body.main_color = lv_color_make(0x33, 0x62, 0x94);
 80138fa:	4c56      	ldr	r4, [pc, #344]	; (8013a54 <lv_style_init+0x4a0>)
 80138fc:	2294      	movs	r2, #148	; 0x94
 80138fe:	2162      	movs	r1, #98	; 0x62
 8013900:	2033      	movs	r0, #51	; 0x33
 8013902:	f7ff fe28 	bl	8013556 <lv_color_make>
 8013906:	8060      	strh	r0, [r4, #2]
    lv_style_btn_pr.body.grad_color = lv_color_make(0x10, 0x26, 0x3c);
 8013908:	4c52      	ldr	r4, [pc, #328]	; (8013a54 <lv_style_init+0x4a0>)
 801390a:	223c      	movs	r2, #60	; 0x3c
 801390c:	2126      	movs	r1, #38	; 0x26
 801390e:	2010      	movs	r0, #16
 8013910:	f7ff fe21 	bl	8013556 <lv_color_make>
 8013914:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 8013916:	4c4f      	ldr	r4, [pc, #316]	; (8013a54 <lv_style_init+0x4a0>)
 8013918:	22c6      	movs	r2, #198	; 0xc6
 801391a:	21b5      	movs	r1, #181	; 0xb5
 801391c:	20a4      	movs	r0, #164	; 0xa4
 801391e:	f7ff fe1a 	bl	8013556 <lv_color_make>
 8013922:	8420      	strh	r0, [r4, #32]
    lv_style_btn_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
 8013924:	4c4b      	ldr	r4, [pc, #300]	; (8013a54 <lv_style_init+0x4a0>)
 8013926:	22c6      	movs	r2, #198	; 0xc6
 8013928:	21b5      	movs	r1, #181	; 0xb5
 801392a:	20a4      	movs	r0, #164	; 0xa4
 801392c:	f7ff fe13 	bl	8013556 <lv_color_make>
 8013930:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 8013932:	4c48      	ldr	r4, [pc, #288]	; (8013a54 <lv_style_init+0x4a0>)
 8013934:	22c6      	movs	r2, #198	; 0xc6
 8013936:	21b5      	movs	r1, #181	; 0xb5
 8013938:	20a4      	movs	r0, #164	; 0xa4
 801393a:	f7ff fe0c 	bl	8013556 <lv_color_make>
 801393e:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button toggle released style*/
    lv_style_copy(&lv_style_btn_tgl_rel, &lv_style_btn_rel);
 8013940:	4942      	ldr	r1, [pc, #264]	; (8013a4c <lv_style_init+0x498>)
 8013942:	4845      	ldr	r0, [pc, #276]	; (8013a58 <lv_style_init+0x4a4>)
 8013944:	f000 f88e 	bl	8013a64 <lv_style_copy>
    lv_style_btn_tgl_rel.body.main_color   = lv_color_make(0x0a, 0x11, 0x22);
 8013948:	4c43      	ldr	r4, [pc, #268]	; (8013a58 <lv_style_init+0x4a4>)
 801394a:	2222      	movs	r2, #34	; 0x22
 801394c:	2111      	movs	r1, #17
 801394e:	200a      	movs	r0, #10
 8013950:	f7ff fe01 	bl	8013556 <lv_color_make>
 8013954:	8060      	strh	r0, [r4, #2]
    lv_style_btn_tgl_rel.body.grad_color   = lv_color_make(0x37, 0x62, 0x90);
 8013956:	4c40      	ldr	r4, [pc, #256]	; (8013a58 <lv_style_init+0x4a4>)
 8013958:	2290      	movs	r2, #144	; 0x90
 801395a:	2162      	movs	r1, #98	; 0x62
 801395c:	2037      	movs	r0, #55	; 0x37
 801395e:	f7ff fdfa 	bl	8013556 <lv_color_make>
 8013962:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_tgl_rel.body.border.color = lv_color_make(0x01, 0x07, 0x0d);
 8013964:	4c3c      	ldr	r4, [pc, #240]	; (8013a58 <lv_style_init+0x4a4>)
 8013966:	220d      	movs	r2, #13
 8013968:	2107      	movs	r1, #7
 801396a:	2001      	movs	r0, #1
 801396c:	f7ff fdf3 	bl	8013556 <lv_color_make>
 8013970:	8160      	strh	r0, [r4, #10]
    lv_style_btn_tgl_rel.text.color        = lv_color_make(0xc8, 0xdd, 0xf4);
 8013972:	4c39      	ldr	r4, [pc, #228]	; (8013a58 <lv_style_init+0x4a4>)
 8013974:	22f4      	movs	r2, #244	; 0xf4
 8013976:	21dd      	movs	r1, #221	; 0xdd
 8013978:	20c8      	movs	r0, #200	; 0xc8
 801397a:	f7ff fdec 	bl	8013556 <lv_color_make>
 801397e:	8420      	strh	r0, [r4, #32]
    lv_style_btn_tgl_rel.image.color       = lv_color_make(0xc8, 0xdd, 0xf4);
 8013980:	4c35      	ldr	r4, [pc, #212]	; (8013a58 <lv_style_init+0x4a4>)
 8013982:	22f4      	movs	r2, #244	; 0xf4
 8013984:	21dd      	movs	r1, #221	; 0xdd
 8013986:	20c8      	movs	r0, #200	; 0xc8
 8013988:	f7ff fde5 	bl	8013556 <lv_color_make>
 801398c:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_tgl_rel.line.color        = lv_color_make(0xc8, 0xdd, 0xf4);
 801398e:	4c32      	ldr	r4, [pc, #200]	; (8013a58 <lv_style_init+0x4a4>)
 8013990:	22f4      	movs	r2, #244	; 0xf4
 8013992:	21dd      	movs	r1, #221	; 0xdd
 8013994:	20c8      	movs	r0, #200	; 0xc8
 8013996:	f7ff fdde 	bl	8013556 <lv_color_make>
 801399a:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button toggle pressed style*/
    lv_style_copy(&lv_style_btn_tgl_pr, &lv_style_btn_tgl_rel);
 801399c:	492e      	ldr	r1, [pc, #184]	; (8013a58 <lv_style_init+0x4a4>)
 801399e:	482f      	ldr	r0, [pc, #188]	; (8013a5c <lv_style_init+0x4a8>)
 80139a0:	f000 f860 	bl	8013a64 <lv_style_copy>
    lv_style_btn_tgl_pr.body.main_color = lv_color_make(0x02, 0x14, 0x27);
 80139a4:	4c2d      	ldr	r4, [pc, #180]	; (8013a5c <lv_style_init+0x4a8>)
 80139a6:	2227      	movs	r2, #39	; 0x27
 80139a8:	2114      	movs	r1, #20
 80139aa:	2002      	movs	r0, #2
 80139ac:	f7ff fdd3 	bl	8013556 <lv_color_make>
 80139b0:	8060      	strh	r0, [r4, #2]
    lv_style_btn_tgl_pr.body.grad_color = lv_color_make(0x2b, 0x4c, 0x70);
 80139b2:	4c2a      	ldr	r4, [pc, #168]	; (8013a5c <lv_style_init+0x4a8>)
 80139b4:	2270      	movs	r2, #112	; 0x70
 80139b6:	214c      	movs	r1, #76	; 0x4c
 80139b8:	202b      	movs	r0, #43	; 0x2b
 80139ba:	f7ff fdcc 	bl	8013556 <lv_color_make>
 80139be:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_tgl_pr.text.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 80139c0:	4c26      	ldr	r4, [pc, #152]	; (8013a5c <lv_style_init+0x4a8>)
 80139c2:	22c6      	movs	r2, #198	; 0xc6
 80139c4:	21b5      	movs	r1, #181	; 0xb5
 80139c6:	20a4      	movs	r0, #164	; 0xa4
 80139c8:	f7ff fdc5 	bl	8013556 <lv_color_make>
 80139cc:	8420      	strh	r0, [r4, #32]
    lv_style_btn_tgl_pr.image.color     = lv_color_make(0xa4, 0xb5, 0xc6);
 80139ce:	4c23      	ldr	r4, [pc, #140]	; (8013a5c <lv_style_init+0x4a8>)
 80139d0:	22c6      	movs	r2, #198	; 0xc6
 80139d2:	21b5      	movs	r1, #181	; 0xb5
 80139d4:	20a4      	movs	r0, #164	; 0xa4
 80139d6:	f7ff fdbe 	bl	8013556 <lv_color_make>
 80139da:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_tgl_pr.line.color      = lv_color_make(0xa4, 0xb5, 0xc6);
 80139dc:	4c1f      	ldr	r4, [pc, #124]	; (8013a5c <lv_style_init+0x4a8>)
 80139de:	22c6      	movs	r2, #198	; 0xc6
 80139e0:	21b5      	movs	r1, #181	; 0xb5
 80139e2:	20a4      	movs	r0, #164	; 0xa4
 80139e4:	f7ff fdb7 	bl	8013556 <lv_color_make>
 80139e8:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Button inactive style*/
    lv_style_copy(&lv_style_btn_ina, &lv_style_btn_rel);
 80139ea:	4918      	ldr	r1, [pc, #96]	; (8013a4c <lv_style_init+0x498>)
 80139ec:	481c      	ldr	r0, [pc, #112]	; (8013a60 <lv_style_init+0x4ac>)
 80139ee:	f000 f839 	bl	8013a64 <lv_style_copy>
    lv_style_btn_ina.body.main_color   = lv_color_make(0xd8, 0xd8, 0xd8);
 80139f2:	4c1b      	ldr	r4, [pc, #108]	; (8013a60 <lv_style_init+0x4ac>)
 80139f4:	22d8      	movs	r2, #216	; 0xd8
 80139f6:	21d8      	movs	r1, #216	; 0xd8
 80139f8:	20d8      	movs	r0, #216	; 0xd8
 80139fa:	f7ff fdac 	bl	8013556 <lv_color_make>
 80139fe:	8060      	strh	r0, [r4, #2]
    lv_style_btn_ina.body.grad_color   = lv_color_make(0xd8, 0xd8, 0xd8);
 8013a00:	4c17      	ldr	r4, [pc, #92]	; (8013a60 <lv_style_init+0x4ac>)
 8013a02:	22d8      	movs	r2, #216	; 0xd8
 8013a04:	21d8      	movs	r1, #216	; 0xd8
 8013a06:	20d8      	movs	r0, #216	; 0xd8
 8013a08:	f7ff fda5 	bl	8013556 <lv_color_make>
 8013a0c:	80a0      	strh	r0, [r4, #4]
    lv_style_btn_ina.body.border.color = lv_color_make(0x90, 0x90, 0x90);
 8013a0e:	4c14      	ldr	r4, [pc, #80]	; (8013a60 <lv_style_init+0x4ac>)
 8013a10:	2290      	movs	r2, #144	; 0x90
 8013a12:	2190      	movs	r1, #144	; 0x90
 8013a14:	2090      	movs	r0, #144	; 0x90
 8013a16:	f7ff fd9e 	bl	8013556 <lv_color_make>
 8013a1a:	8160      	strh	r0, [r4, #10]
    lv_style_btn_ina.text.color        = lv_color_make(0x70, 0x70, 0x70);
 8013a1c:	4c10      	ldr	r4, [pc, #64]	; (8013a60 <lv_style_init+0x4ac>)
 8013a1e:	2270      	movs	r2, #112	; 0x70
 8013a20:	2170      	movs	r1, #112	; 0x70
 8013a22:	2070      	movs	r0, #112	; 0x70
 8013a24:	f7ff fd97 	bl	8013556 <lv_color_make>
 8013a28:	8420      	strh	r0, [r4, #32]
    lv_style_btn_ina.image.color       = lv_color_make(0x70, 0x70, 0x70);
 8013a2a:	4c0d      	ldr	r4, [pc, #52]	; (8013a60 <lv_style_init+0x4ac>)
 8013a2c:	2270      	movs	r2, #112	; 0x70
 8013a2e:	2170      	movs	r1, #112	; 0x70
 8013a30:	2070      	movs	r0, #112	; 0x70
 8013a32:	f7ff fd90 	bl	8013556 <lv_color_make>
 8013a36:	8620      	strh	r0, [r4, #48]	; 0x30
    lv_style_btn_ina.line.color        = lv_color_make(0x70, 0x70, 0x70);
 8013a38:	4c09      	ldr	r4, [pc, #36]	; (8013a60 <lv_style_init+0x4ac>)
 8013a3a:	2270      	movs	r2, #112	; 0x70
 8013a3c:	2170      	movs	r1, #112	; 0x70
 8013a3e:	2070      	movs	r0, #112	; 0x70
 8013a40:	f7ff fd89 	bl	8013556 <lv_color_make>
 8013a44:	86a0      	strh	r0, [r4, #52]	; 0x34
}
 8013a46:	bf00      	nop
 8013a48:	bd98      	pop	{r3, r4, r7, pc}
 8013a4a:	bf00      	nop
 8013a4c:	2000dcb0 	.word	0x2000dcb0
 8013a50:	080288dc 	.word	0x080288dc
 8013a54:	2000dcec 	.word	0x2000dcec
 8013a58:	2000de54 	.word	0x2000de54
 8013a5c:	2000decc 	.word	0x2000decc
 8013a60:	2000dda0 	.word	0x2000dda0

08013a64 <lv_style_copy>:
 * Copy a style to an other
 * @param dest pointer to the destination style
 * @param src pointer to the source style
 */
void lv_style_copy(lv_style_t * dest, const lv_style_t * src)
{
 8013a64:	b580      	push	{r7, lr}
 8013a66:	b082      	sub	sp, #8
 8013a68:	af00      	add	r7, sp, #0
 8013a6a:	6078      	str	r0, [r7, #4]
 8013a6c:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_style_t));
 8013a6e:	223c      	movs	r2, #60	; 0x3c
 8013a70:	6839      	ldr	r1, [r7, #0]
 8013a72:	6878      	ldr	r0, [r7, #4]
 8013a74:	f013 fba2 	bl	80271bc <memcpy>
}
 8013a78:	bf00      	nop
 8013a7a:	3708      	adds	r7, #8
 8013a7c:	46bd      	mov	sp, r7
 8013a7e:	bd80      	pop	{r7, pc}

08013a80 <lv_style_mix>:
 * @param end end style
 * @param res store the result style here
 * @param ratio the ratio of mix [0..256]; 0: `start` style; 256: `end` style
 */
void lv_style_mix(const lv_style_t * start, const lv_style_t * end, lv_style_t * res, uint16_t ratio)
{
 8013a80:	b590      	push	{r4, r7, lr}
 8013a82:	b087      	sub	sp, #28
 8013a84:	af00      	add	r7, sp, #0
 8013a86:	60f8      	str	r0, [r7, #12]
 8013a88:	60b9      	str	r1, [r7, #8]
 8013a8a:	607a      	str	r2, [r7, #4]
 8013a8c:	807b      	strh	r3, [r7, #2]
    STYLE_ATTR_MIX(body.opa, ratio);
 8013a8e:	68fb      	ldr	r3, [r7, #12]
 8013a90:	7a1a      	ldrb	r2, [r3, #8]
 8013a92:	68bb      	ldr	r3, [r7, #8]
 8013a94:	7a1b      	ldrb	r3, [r3, #8]
 8013a96:	429a      	cmp	r2, r3
 8013a98:	d011      	beq.n	8013abe <lv_style_mix+0x3e>
 8013a9a:	68fb      	ldr	r3, [r7, #12]
 8013a9c:	7a1a      	ldrb	r2, [r3, #8]
 8013a9e:	68bb      	ldr	r3, [r7, #8]
 8013aa0:	7a1b      	ldrb	r3, [r3, #8]
 8013aa2:	4619      	mov	r1, r3
 8013aa4:	68fb      	ldr	r3, [r7, #12]
 8013aa6:	7a1b      	ldrb	r3, [r3, #8]
 8013aa8:	1acb      	subs	r3, r1, r3
 8013aaa:	8879      	ldrh	r1, [r7, #2]
 8013aac:	fb01 f303 	mul.w	r3, r1, r3
 8013ab0:	121b      	asrs	r3, r3, #8
 8013ab2:	b2db      	uxtb	r3, r3
 8013ab4:	4413      	add	r3, r2
 8013ab6:	b2da      	uxtb	r2, r3
 8013ab8:	687b      	ldr	r3, [r7, #4]
 8013aba:	721a      	strb	r2, [r3, #8]
 8013abc:	e003      	b.n	8013ac6 <lv_style_mix+0x46>
 8013abe:	68fb      	ldr	r3, [r7, #12]
 8013ac0:	7a1a      	ldrb	r2, [r3, #8]
 8013ac2:	687b      	ldr	r3, [r7, #4]
 8013ac4:	721a      	strb	r2, [r3, #8]
    STYLE_ATTR_MIX(body.radius, ratio);
 8013ac6:	68fb      	ldr	r3, [r7, #12]
 8013ac8:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 8013acc:	68bb      	ldr	r3, [r7, #8]
 8013ace:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8013ad2:	429a      	cmp	r2, r3
 8013ad4:	d016      	beq.n	8013b04 <lv_style_mix+0x84>
 8013ad6:	68fb      	ldr	r3, [r7, #12]
 8013ad8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8013adc:	b29a      	uxth	r2, r3
 8013ade:	68bb      	ldr	r3, [r7, #8]
 8013ae0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8013ae4:	4619      	mov	r1, r3
 8013ae6:	68fb      	ldr	r3, [r7, #12]
 8013ae8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8013aec:	1acb      	subs	r3, r1, r3
 8013aee:	8879      	ldrh	r1, [r7, #2]
 8013af0:	fb01 f303 	mul.w	r3, r1, r3
 8013af4:	121b      	asrs	r3, r3, #8
 8013af6:	b29b      	uxth	r3, r3
 8013af8:	4413      	add	r3, r2
 8013afa:	b29b      	uxth	r3, r3
 8013afc:	b21a      	sxth	r2, r3
 8013afe:	687b      	ldr	r3, [r7, #4]
 8013b00:	80da      	strh	r2, [r3, #6]
 8013b02:	e004      	b.n	8013b0e <lv_style_mix+0x8e>
 8013b04:	68fb      	ldr	r3, [r7, #12]
 8013b06:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 8013b0a:	687b      	ldr	r3, [r7, #4]
 8013b0c:	80da      	strh	r2, [r3, #6]
    STYLE_ATTR_MIX(body.border.width, ratio);
 8013b0e:	68fb      	ldr	r3, [r7, #12]
 8013b10:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013b14:	68bb      	ldr	r3, [r7, #8]
 8013b16:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8013b1a:	429a      	cmp	r2, r3
 8013b1c:	d016      	beq.n	8013b4c <lv_style_mix+0xcc>
 8013b1e:	68fb      	ldr	r3, [r7, #12]
 8013b20:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8013b24:	b29a      	uxth	r2, r3
 8013b26:	68bb      	ldr	r3, [r7, #8]
 8013b28:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8013b2c:	4619      	mov	r1, r3
 8013b2e:	68fb      	ldr	r3, [r7, #12]
 8013b30:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8013b34:	1acb      	subs	r3, r1, r3
 8013b36:	8879      	ldrh	r1, [r7, #2]
 8013b38:	fb01 f303 	mul.w	r3, r1, r3
 8013b3c:	121b      	asrs	r3, r3, #8
 8013b3e:	b29b      	uxth	r3, r3
 8013b40:	4413      	add	r3, r2
 8013b42:	b29b      	uxth	r3, r3
 8013b44:	b21a      	sxth	r2, r3
 8013b46:	687b      	ldr	r3, [r7, #4]
 8013b48:	819a      	strh	r2, [r3, #12]
 8013b4a:	e004      	b.n	8013b56 <lv_style_mix+0xd6>
 8013b4c:	68fb      	ldr	r3, [r7, #12]
 8013b4e:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8013b52:	687b      	ldr	r3, [r7, #4]
 8013b54:	819a      	strh	r2, [r3, #12]
    STYLE_ATTR_MIX(body.border.opa, ratio);
 8013b56:	68fb      	ldr	r3, [r7, #12]
 8013b58:	7bda      	ldrb	r2, [r3, #15]
 8013b5a:	68bb      	ldr	r3, [r7, #8]
 8013b5c:	7bdb      	ldrb	r3, [r3, #15]
 8013b5e:	429a      	cmp	r2, r3
 8013b60:	d011      	beq.n	8013b86 <lv_style_mix+0x106>
 8013b62:	68fb      	ldr	r3, [r7, #12]
 8013b64:	7bda      	ldrb	r2, [r3, #15]
 8013b66:	68bb      	ldr	r3, [r7, #8]
 8013b68:	7bdb      	ldrb	r3, [r3, #15]
 8013b6a:	4619      	mov	r1, r3
 8013b6c:	68fb      	ldr	r3, [r7, #12]
 8013b6e:	7bdb      	ldrb	r3, [r3, #15]
 8013b70:	1acb      	subs	r3, r1, r3
 8013b72:	8879      	ldrh	r1, [r7, #2]
 8013b74:	fb01 f303 	mul.w	r3, r1, r3
 8013b78:	121b      	asrs	r3, r3, #8
 8013b7a:	b2db      	uxtb	r3, r3
 8013b7c:	4413      	add	r3, r2
 8013b7e:	b2da      	uxtb	r2, r3
 8013b80:	687b      	ldr	r3, [r7, #4]
 8013b82:	73da      	strb	r2, [r3, #15]
 8013b84:	e003      	b.n	8013b8e <lv_style_mix+0x10e>
 8013b86:	68fb      	ldr	r3, [r7, #12]
 8013b88:	7bda      	ldrb	r2, [r3, #15]
 8013b8a:	687b      	ldr	r3, [r7, #4]
 8013b8c:	73da      	strb	r2, [r3, #15]
    STYLE_ATTR_MIX(body.shadow.width, ratio);
 8013b8e:	68fb      	ldr	r3, [r7, #12]
 8013b90:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8013b94:	68bb      	ldr	r3, [r7, #8]
 8013b96:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013b9a:	429a      	cmp	r2, r3
 8013b9c:	d016      	beq.n	8013bcc <lv_style_mix+0x14c>
 8013b9e:	68fb      	ldr	r3, [r7, #12]
 8013ba0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013ba4:	b29a      	uxth	r2, r3
 8013ba6:	68bb      	ldr	r3, [r7, #8]
 8013ba8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013bac:	4619      	mov	r1, r3
 8013bae:	68fb      	ldr	r3, [r7, #12]
 8013bb0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8013bb4:	1acb      	subs	r3, r1, r3
 8013bb6:	8879      	ldrh	r1, [r7, #2]
 8013bb8:	fb01 f303 	mul.w	r3, r1, r3
 8013bbc:	121b      	asrs	r3, r3, #8
 8013bbe:	b29b      	uxth	r3, r3
 8013bc0:	4413      	add	r3, r2
 8013bc2:	b29b      	uxth	r3, r3
 8013bc4:	b21a      	sxth	r2, r3
 8013bc6:	687b      	ldr	r3, [r7, #4]
 8013bc8:	825a      	strh	r2, [r3, #18]
 8013bca:	e004      	b.n	8013bd6 <lv_style_mix+0x156>
 8013bcc:	68fb      	ldr	r3, [r7, #12]
 8013bce:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 8013bd2:	687b      	ldr	r3, [r7, #4]
 8013bd4:	825a      	strh	r2, [r3, #18]
    STYLE_ATTR_MIX(body.padding.left, ratio);
 8013bd6:	68fb      	ldr	r3, [r7, #12]
 8013bd8:	f9b3 201a 	ldrsh.w	r2, [r3, #26]
 8013bdc:	68bb      	ldr	r3, [r7, #8]
 8013bde:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8013be2:	429a      	cmp	r2, r3
 8013be4:	d016      	beq.n	8013c14 <lv_style_mix+0x194>
 8013be6:	68fb      	ldr	r3, [r7, #12]
 8013be8:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8013bec:	b29a      	uxth	r2, r3
 8013bee:	68bb      	ldr	r3, [r7, #8]
 8013bf0:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8013bf4:	4619      	mov	r1, r3
 8013bf6:	68fb      	ldr	r3, [r7, #12]
 8013bf8:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8013bfc:	1acb      	subs	r3, r1, r3
 8013bfe:	8879      	ldrh	r1, [r7, #2]
 8013c00:	fb01 f303 	mul.w	r3, r1, r3
 8013c04:	121b      	asrs	r3, r3, #8
 8013c06:	b29b      	uxth	r3, r3
 8013c08:	4413      	add	r3, r2
 8013c0a:	b29b      	uxth	r3, r3
 8013c0c:	b21a      	sxth	r2, r3
 8013c0e:	687b      	ldr	r3, [r7, #4]
 8013c10:	835a      	strh	r2, [r3, #26]
 8013c12:	e004      	b.n	8013c1e <lv_style_mix+0x19e>
 8013c14:	68fb      	ldr	r3, [r7, #12]
 8013c16:	f9b3 201a 	ldrsh.w	r2, [r3, #26]
 8013c1a:	687b      	ldr	r3, [r7, #4]
 8013c1c:	835a      	strh	r2, [r3, #26]
    STYLE_ATTR_MIX(body.padding.right, ratio);
 8013c1e:	68fb      	ldr	r3, [r7, #12]
 8013c20:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 8013c24:	68bb      	ldr	r3, [r7, #8]
 8013c26:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8013c2a:	429a      	cmp	r2, r3
 8013c2c:	d016      	beq.n	8013c5c <lv_style_mix+0x1dc>
 8013c2e:	68fb      	ldr	r3, [r7, #12]
 8013c30:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8013c34:	b29a      	uxth	r2, r3
 8013c36:	68bb      	ldr	r3, [r7, #8]
 8013c38:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8013c3c:	4619      	mov	r1, r3
 8013c3e:	68fb      	ldr	r3, [r7, #12]
 8013c40:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8013c44:	1acb      	subs	r3, r1, r3
 8013c46:	8879      	ldrh	r1, [r7, #2]
 8013c48:	fb01 f303 	mul.w	r3, r1, r3
 8013c4c:	121b      	asrs	r3, r3, #8
 8013c4e:	b29b      	uxth	r3, r3
 8013c50:	4413      	add	r3, r2
 8013c52:	b29b      	uxth	r3, r3
 8013c54:	b21a      	sxth	r2, r3
 8013c56:	687b      	ldr	r3, [r7, #4]
 8013c58:	839a      	strh	r2, [r3, #28]
 8013c5a:	e004      	b.n	8013c66 <lv_style_mix+0x1e6>
 8013c5c:	68fb      	ldr	r3, [r7, #12]
 8013c5e:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 8013c62:	687b      	ldr	r3, [r7, #4]
 8013c64:	839a      	strh	r2, [r3, #28]
    STYLE_ATTR_MIX(body.padding.top, ratio);
 8013c66:	68fb      	ldr	r3, [r7, #12]
 8013c68:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 8013c6c:	68bb      	ldr	r3, [r7, #8]
 8013c6e:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8013c72:	429a      	cmp	r2, r3
 8013c74:	d016      	beq.n	8013ca4 <lv_style_mix+0x224>
 8013c76:	68fb      	ldr	r3, [r7, #12]
 8013c78:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8013c7c:	b29a      	uxth	r2, r3
 8013c7e:	68bb      	ldr	r3, [r7, #8]
 8013c80:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8013c84:	4619      	mov	r1, r3
 8013c86:	68fb      	ldr	r3, [r7, #12]
 8013c88:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8013c8c:	1acb      	subs	r3, r1, r3
 8013c8e:	8879      	ldrh	r1, [r7, #2]
 8013c90:	fb01 f303 	mul.w	r3, r1, r3
 8013c94:	121b      	asrs	r3, r3, #8
 8013c96:	b29b      	uxth	r3, r3
 8013c98:	4413      	add	r3, r2
 8013c9a:	b29b      	uxth	r3, r3
 8013c9c:	b21a      	sxth	r2, r3
 8013c9e:	687b      	ldr	r3, [r7, #4]
 8013ca0:	82da      	strh	r2, [r3, #22]
 8013ca2:	e004      	b.n	8013cae <lv_style_mix+0x22e>
 8013ca4:	68fb      	ldr	r3, [r7, #12]
 8013ca6:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 8013caa:	687b      	ldr	r3, [r7, #4]
 8013cac:	82da      	strh	r2, [r3, #22]
    STYLE_ATTR_MIX(body.padding.bottom, ratio);
 8013cae:	68fb      	ldr	r3, [r7, #12]
 8013cb0:	f9b3 2018 	ldrsh.w	r2, [r3, #24]
 8013cb4:	68bb      	ldr	r3, [r7, #8]
 8013cb6:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8013cba:	429a      	cmp	r2, r3
 8013cbc:	d016      	beq.n	8013cec <lv_style_mix+0x26c>
 8013cbe:	68fb      	ldr	r3, [r7, #12]
 8013cc0:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8013cc4:	b29a      	uxth	r2, r3
 8013cc6:	68bb      	ldr	r3, [r7, #8]
 8013cc8:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8013ccc:	4619      	mov	r1, r3
 8013cce:	68fb      	ldr	r3, [r7, #12]
 8013cd0:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8013cd4:	1acb      	subs	r3, r1, r3
 8013cd6:	8879      	ldrh	r1, [r7, #2]
 8013cd8:	fb01 f303 	mul.w	r3, r1, r3
 8013cdc:	121b      	asrs	r3, r3, #8
 8013cde:	b29b      	uxth	r3, r3
 8013ce0:	4413      	add	r3, r2
 8013ce2:	b29b      	uxth	r3, r3
 8013ce4:	b21a      	sxth	r2, r3
 8013ce6:	687b      	ldr	r3, [r7, #4]
 8013ce8:	831a      	strh	r2, [r3, #24]
 8013cea:	e004      	b.n	8013cf6 <lv_style_mix+0x276>
 8013cec:	68fb      	ldr	r3, [r7, #12]
 8013cee:	f9b3 2018 	ldrsh.w	r2, [r3, #24]
 8013cf2:	687b      	ldr	r3, [r7, #4]
 8013cf4:	831a      	strh	r2, [r3, #24]
    STYLE_ATTR_MIX(body.padding.inner, ratio);
 8013cf6:	68fb      	ldr	r3, [r7, #12]
 8013cf8:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
 8013cfc:	68bb      	ldr	r3, [r7, #8]
 8013cfe:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8013d02:	429a      	cmp	r2, r3
 8013d04:	d016      	beq.n	8013d34 <lv_style_mix+0x2b4>
 8013d06:	68fb      	ldr	r3, [r7, #12]
 8013d08:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8013d0c:	b29a      	uxth	r2, r3
 8013d0e:	68bb      	ldr	r3, [r7, #8]
 8013d10:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8013d14:	4619      	mov	r1, r3
 8013d16:	68fb      	ldr	r3, [r7, #12]
 8013d18:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8013d1c:	1acb      	subs	r3, r1, r3
 8013d1e:	8879      	ldrh	r1, [r7, #2]
 8013d20:	fb01 f303 	mul.w	r3, r1, r3
 8013d24:	121b      	asrs	r3, r3, #8
 8013d26:	b29b      	uxth	r3, r3
 8013d28:	4413      	add	r3, r2
 8013d2a:	b29b      	uxth	r3, r3
 8013d2c:	b21a      	sxth	r2, r3
 8013d2e:	687b      	ldr	r3, [r7, #4]
 8013d30:	83da      	strh	r2, [r3, #30]
 8013d32:	e004      	b.n	8013d3e <lv_style_mix+0x2be>
 8013d34:	68fb      	ldr	r3, [r7, #12]
 8013d36:	f9b3 201e 	ldrsh.w	r2, [r3, #30]
 8013d3a:	687b      	ldr	r3, [r7, #4]
 8013d3c:	83da      	strh	r2, [r3, #30]
    STYLE_ATTR_MIX(text.line_space, ratio);
 8013d3e:	68fb      	ldr	r3, [r7, #12]
 8013d40:	f9b3 202a 	ldrsh.w	r2, [r3, #42]	; 0x2a
 8013d44:	68bb      	ldr	r3, [r7, #8]
 8013d46:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8013d4a:	429a      	cmp	r2, r3
 8013d4c:	d016      	beq.n	8013d7c <lv_style_mix+0x2fc>
 8013d4e:	68fb      	ldr	r3, [r7, #12]
 8013d50:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8013d54:	b29a      	uxth	r2, r3
 8013d56:	68bb      	ldr	r3, [r7, #8]
 8013d58:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8013d5c:	4619      	mov	r1, r3
 8013d5e:	68fb      	ldr	r3, [r7, #12]
 8013d60:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8013d64:	1acb      	subs	r3, r1, r3
 8013d66:	8879      	ldrh	r1, [r7, #2]
 8013d68:	fb01 f303 	mul.w	r3, r1, r3
 8013d6c:	121b      	asrs	r3, r3, #8
 8013d6e:	b29b      	uxth	r3, r3
 8013d70:	4413      	add	r3, r2
 8013d72:	b29b      	uxth	r3, r3
 8013d74:	b21a      	sxth	r2, r3
 8013d76:	687b      	ldr	r3, [r7, #4]
 8013d78:	855a      	strh	r2, [r3, #42]	; 0x2a
 8013d7a:	e004      	b.n	8013d86 <lv_style_mix+0x306>
 8013d7c:	68fb      	ldr	r3, [r7, #12]
 8013d7e:	f9b3 202a 	ldrsh.w	r2, [r3, #42]	; 0x2a
 8013d82:	687b      	ldr	r3, [r7, #4]
 8013d84:	855a      	strh	r2, [r3, #42]	; 0x2a
    STYLE_ATTR_MIX(text.letter_space, ratio);
 8013d86:	68fb      	ldr	r3, [r7, #12]
 8013d88:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8013d8c:	68bb      	ldr	r3, [r7, #8]
 8013d8e:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8013d92:	429a      	cmp	r2, r3
 8013d94:	d016      	beq.n	8013dc4 <lv_style_mix+0x344>
 8013d96:	68fb      	ldr	r3, [r7, #12]
 8013d98:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8013d9c:	b29a      	uxth	r2, r3
 8013d9e:	68bb      	ldr	r3, [r7, #8]
 8013da0:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8013da4:	4619      	mov	r1, r3
 8013da6:	68fb      	ldr	r3, [r7, #12]
 8013da8:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8013dac:	1acb      	subs	r3, r1, r3
 8013dae:	8879      	ldrh	r1, [r7, #2]
 8013db0:	fb01 f303 	mul.w	r3, r1, r3
 8013db4:	121b      	asrs	r3, r3, #8
 8013db6:	b29b      	uxth	r3, r3
 8013db8:	4413      	add	r3, r2
 8013dba:	b29b      	uxth	r3, r3
 8013dbc:	b21a      	sxth	r2, r3
 8013dbe:	687b      	ldr	r3, [r7, #4]
 8013dc0:	851a      	strh	r2, [r3, #40]	; 0x28
 8013dc2:	e004      	b.n	8013dce <lv_style_mix+0x34e>
 8013dc4:	68fb      	ldr	r3, [r7, #12]
 8013dc6:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8013dca:	687b      	ldr	r3, [r7, #4]
 8013dcc:	851a      	strh	r2, [r3, #40]	; 0x28
    STYLE_ATTR_MIX(text.opa, ratio);
 8013dce:	68fb      	ldr	r3, [r7, #12]
 8013dd0:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 8013dd4:	68bb      	ldr	r3, [r7, #8]
 8013dd6:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8013dda:	429a      	cmp	r2, r3
 8013ddc:	d015      	beq.n	8013e0a <lv_style_mix+0x38a>
 8013dde:	68fb      	ldr	r3, [r7, #12]
 8013de0:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 8013de4:	68bb      	ldr	r3, [r7, #8]
 8013de6:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8013dea:	4619      	mov	r1, r3
 8013dec:	68fb      	ldr	r3, [r7, #12]
 8013dee:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8013df2:	1acb      	subs	r3, r1, r3
 8013df4:	8879      	ldrh	r1, [r7, #2]
 8013df6:	fb01 f303 	mul.w	r3, r1, r3
 8013dfa:	121b      	asrs	r3, r3, #8
 8013dfc:	b2db      	uxtb	r3, r3
 8013dfe:	4413      	add	r3, r2
 8013e00:	b2da      	uxtb	r2, r3
 8013e02:	687b      	ldr	r3, [r7, #4]
 8013e04:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
 8013e08:	e005      	b.n	8013e16 <lv_style_mix+0x396>
 8013e0a:	68fb      	ldr	r3, [r7, #12]
 8013e0c:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 8013e10:	687b      	ldr	r3, [r7, #4]
 8013e12:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    STYLE_ATTR_MIX(line.width, ratio);
 8013e16:	68fb      	ldr	r3, [r7, #12]
 8013e18:	f9b3 2036 	ldrsh.w	r2, [r3, #54]	; 0x36
 8013e1c:	68bb      	ldr	r3, [r7, #8]
 8013e1e:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 8013e22:	429a      	cmp	r2, r3
 8013e24:	d016      	beq.n	8013e54 <lv_style_mix+0x3d4>
 8013e26:	68fb      	ldr	r3, [r7, #12]
 8013e28:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 8013e2c:	b29a      	uxth	r2, r3
 8013e2e:	68bb      	ldr	r3, [r7, #8]
 8013e30:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 8013e34:	4619      	mov	r1, r3
 8013e36:	68fb      	ldr	r3, [r7, #12]
 8013e38:	f9b3 3036 	ldrsh.w	r3, [r3, #54]	; 0x36
 8013e3c:	1acb      	subs	r3, r1, r3
 8013e3e:	8879      	ldrh	r1, [r7, #2]
 8013e40:	fb01 f303 	mul.w	r3, r1, r3
 8013e44:	121b      	asrs	r3, r3, #8
 8013e46:	b29b      	uxth	r3, r3
 8013e48:	4413      	add	r3, r2
 8013e4a:	b29b      	uxth	r3, r3
 8013e4c:	b21a      	sxth	r2, r3
 8013e4e:	687b      	ldr	r3, [r7, #4]
 8013e50:	86da      	strh	r2, [r3, #54]	; 0x36
 8013e52:	e004      	b.n	8013e5e <lv_style_mix+0x3de>
 8013e54:	68fb      	ldr	r3, [r7, #12]
 8013e56:	f9b3 2036 	ldrsh.w	r2, [r3, #54]	; 0x36
 8013e5a:	687b      	ldr	r3, [r7, #4]
 8013e5c:	86da      	strh	r2, [r3, #54]	; 0x36
    STYLE_ATTR_MIX(line.opa, ratio);
 8013e5e:	68fb      	ldr	r3, [r7, #12]
 8013e60:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
 8013e64:	68bb      	ldr	r3, [r7, #8]
 8013e66:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8013e6a:	429a      	cmp	r2, r3
 8013e6c:	d015      	beq.n	8013e9a <lv_style_mix+0x41a>
 8013e6e:	68fb      	ldr	r3, [r7, #12]
 8013e70:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
 8013e74:	68bb      	ldr	r3, [r7, #8]
 8013e76:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8013e7a:	4619      	mov	r1, r3
 8013e7c:	68fb      	ldr	r3, [r7, #12]
 8013e7e:	f893 3038 	ldrb.w	r3, [r3, #56]	; 0x38
 8013e82:	1acb      	subs	r3, r1, r3
 8013e84:	8879      	ldrh	r1, [r7, #2]
 8013e86:	fb01 f303 	mul.w	r3, r1, r3
 8013e8a:	121b      	asrs	r3, r3, #8
 8013e8c:	b2db      	uxtb	r3, r3
 8013e8e:	4413      	add	r3, r2
 8013e90:	b2da      	uxtb	r2, r3
 8013e92:	687b      	ldr	r3, [r7, #4]
 8013e94:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
 8013e98:	e005      	b.n	8013ea6 <lv_style_mix+0x426>
 8013e9a:	68fb      	ldr	r3, [r7, #12]
 8013e9c:	f893 2038 	ldrb.w	r2, [r3, #56]	; 0x38
 8013ea0:	687b      	ldr	r3, [r7, #4]
 8013ea2:	f883 2038 	strb.w	r2, [r3, #56]	; 0x38
    STYLE_ATTR_MIX(image.intense, ratio);
 8013ea6:	68fb      	ldr	r3, [r7, #12]
 8013ea8:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8013eac:	68bb      	ldr	r3, [r7, #8]
 8013eae:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 8013eb2:	429a      	cmp	r2, r3
 8013eb4:	d015      	beq.n	8013ee2 <lv_style_mix+0x462>
 8013eb6:	68fb      	ldr	r3, [r7, #12]
 8013eb8:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8013ebc:	68bb      	ldr	r3, [r7, #8]
 8013ebe:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 8013ec2:	4619      	mov	r1, r3
 8013ec4:	68fb      	ldr	r3, [r7, #12]
 8013ec6:	f893 3032 	ldrb.w	r3, [r3, #50]	; 0x32
 8013eca:	1acb      	subs	r3, r1, r3
 8013ecc:	8879      	ldrh	r1, [r7, #2]
 8013ece:	fb01 f303 	mul.w	r3, r1, r3
 8013ed2:	121b      	asrs	r3, r3, #8
 8013ed4:	b2db      	uxtb	r3, r3
 8013ed6:	4413      	add	r3, r2
 8013ed8:	b2da      	uxtb	r2, r3
 8013eda:	687b      	ldr	r3, [r7, #4]
 8013edc:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
 8013ee0:	e005      	b.n	8013eee <lv_style_mix+0x46e>
 8013ee2:	68fb      	ldr	r3, [r7, #12]
 8013ee4:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
 8013ee8:	687b      	ldr	r3, [r7, #4]
 8013eea:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
    STYLE_ATTR_MIX(image.opa, ratio);
 8013eee:	68fb      	ldr	r3, [r7, #12]
 8013ef0:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
 8013ef4:	68bb      	ldr	r3, [r7, #8]
 8013ef6:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8013efa:	429a      	cmp	r2, r3
 8013efc:	d015      	beq.n	8013f2a <lv_style_mix+0x4aa>
 8013efe:	68fb      	ldr	r3, [r7, #12]
 8013f00:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
 8013f04:	68bb      	ldr	r3, [r7, #8]
 8013f06:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8013f0a:	4619      	mov	r1, r3
 8013f0c:	68fb      	ldr	r3, [r7, #12]
 8013f0e:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
 8013f12:	1acb      	subs	r3, r1, r3
 8013f14:	8879      	ldrh	r1, [r7, #2]
 8013f16:	fb01 f303 	mul.w	r3, r1, r3
 8013f1a:	121b      	asrs	r3, r3, #8
 8013f1c:	b2db      	uxtb	r3, r3
 8013f1e:	4413      	add	r3, r2
 8013f20:	b2da      	uxtb	r2, r3
 8013f22:	687b      	ldr	r3, [r7, #4]
 8013f24:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33
 8013f28:	e005      	b.n	8013f36 <lv_style_mix+0x4b6>
 8013f2a:	68fb      	ldr	r3, [r7, #12]
 8013f2c:	f893 2033 	ldrb.w	r2, [r3, #51]	; 0x33
 8013f30:	687b      	ldr	r3, [r7, #4]
 8013f32:	f883 2033 	strb.w	r2, [r3, #51]	; 0x33

    lv_opa_t opa = ratio == STYLE_MIX_MAX ? LV_OPA_COVER : ratio;
 8013f36:	887b      	ldrh	r3, [r7, #2]
 8013f38:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8013f3c:	d002      	beq.n	8013f44 <lv_style_mix+0x4c4>
 8013f3e:	887b      	ldrh	r3, [r7, #2]
 8013f40:	b2db      	uxtb	r3, r3
 8013f42:	e000      	b.n	8013f46 <lv_style_mix+0x4c6>
 8013f44:	23ff      	movs	r3, #255	; 0xff
 8013f46:	75fb      	strb	r3, [r7, #23]

    res->body.main_color   = lv_color_mix(end->body.main_color, start->body.main_color, opa);
 8013f48:	687c      	ldr	r4, [r7, #4]
 8013f4a:	7dfa      	ldrb	r2, [r7, #23]
 8013f4c:	68f9      	ldr	r1, [r7, #12]
 8013f4e:	68bb      	ldr	r3, [r7, #8]
 8013f50:	8849      	ldrh	r1, [r1, #2]
 8013f52:	8858      	ldrh	r0, [r3, #2]
 8013f54:	f7ff fa8e 	bl	8013474 <lv_color_mix>
 8013f58:	8060      	strh	r0, [r4, #2]
    res->body.grad_color   = lv_color_mix(end->body.grad_color, start->body.grad_color, opa);
 8013f5a:	687c      	ldr	r4, [r7, #4]
 8013f5c:	7dfa      	ldrb	r2, [r7, #23]
 8013f5e:	68f9      	ldr	r1, [r7, #12]
 8013f60:	68bb      	ldr	r3, [r7, #8]
 8013f62:	8889      	ldrh	r1, [r1, #4]
 8013f64:	8898      	ldrh	r0, [r3, #4]
 8013f66:	f7ff fa85 	bl	8013474 <lv_color_mix>
 8013f6a:	80a0      	strh	r0, [r4, #4]
    res->body.border.color = lv_color_mix(end->body.border.color, start->body.border.color, opa);
 8013f6c:	687c      	ldr	r4, [r7, #4]
 8013f6e:	7dfa      	ldrb	r2, [r7, #23]
 8013f70:	68f9      	ldr	r1, [r7, #12]
 8013f72:	68bb      	ldr	r3, [r7, #8]
 8013f74:	8949      	ldrh	r1, [r1, #10]
 8013f76:	8958      	ldrh	r0, [r3, #10]
 8013f78:	f7ff fa7c 	bl	8013474 <lv_color_mix>
 8013f7c:	8160      	strh	r0, [r4, #10]
    res->body.shadow.color = lv_color_mix(end->body.shadow.color, start->body.shadow.color, opa);
 8013f7e:	687c      	ldr	r4, [r7, #4]
 8013f80:	7dfa      	ldrb	r2, [r7, #23]
 8013f82:	68f9      	ldr	r1, [r7, #12]
 8013f84:	68bb      	ldr	r3, [r7, #8]
 8013f86:	8a09      	ldrh	r1, [r1, #16]
 8013f88:	8a18      	ldrh	r0, [r3, #16]
 8013f8a:	f7ff fa73 	bl	8013474 <lv_color_mix>
 8013f8e:	8220      	strh	r0, [r4, #16]
    res->text.color        = lv_color_mix(end->text.color, start->text.color, opa);
 8013f90:	687c      	ldr	r4, [r7, #4]
 8013f92:	7dfa      	ldrb	r2, [r7, #23]
 8013f94:	68f9      	ldr	r1, [r7, #12]
 8013f96:	68bb      	ldr	r3, [r7, #8]
 8013f98:	8c09      	ldrh	r1, [r1, #32]
 8013f9a:	8c18      	ldrh	r0, [r3, #32]
 8013f9c:	f7ff fa6a 	bl	8013474 <lv_color_mix>
 8013fa0:	8420      	strh	r0, [r4, #32]
    res->image.color       = lv_color_mix(end->image.color, start->image.color, opa);
 8013fa2:	687c      	ldr	r4, [r7, #4]
 8013fa4:	7dfa      	ldrb	r2, [r7, #23]
 8013fa6:	68f9      	ldr	r1, [r7, #12]
 8013fa8:	68bb      	ldr	r3, [r7, #8]
 8013faa:	8e09      	ldrh	r1, [r1, #48]	; 0x30
 8013fac:	8e18      	ldrh	r0, [r3, #48]	; 0x30
 8013fae:	f7ff fa61 	bl	8013474 <lv_color_mix>
 8013fb2:	8620      	strh	r0, [r4, #48]	; 0x30
    res->line.color        = lv_color_mix(end->line.color, start->line.color, opa);
 8013fb4:	687c      	ldr	r4, [r7, #4]
 8013fb6:	7dfa      	ldrb	r2, [r7, #23]
 8013fb8:	68f9      	ldr	r1, [r7, #12]
 8013fba:	68bb      	ldr	r3, [r7, #8]
 8013fbc:	8e89      	ldrh	r1, [r1, #52]	; 0x34
 8013fbe:	8e98      	ldrh	r0, [r3, #52]	; 0x34
 8013fc0:	f7ff fa58 	bl	8013474 <lv_color_mix>
 8013fc4:	86a0      	strh	r0, [r4, #52]	; 0x34

    if(ratio < (STYLE_MIX_MAX >> 1)) {
 8013fc6:	887b      	ldrh	r3, [r7, #2]
 8013fc8:	2b7f      	cmp	r3, #127	; 0x7f
 8013fca:	d823      	bhi.n	8014014 <lv_style_mix+0x594>
        res->body.border.part = start->body.border.part;
 8013fcc:	68fb      	ldr	r3, [r7, #12]
 8013fce:	7b9a      	ldrb	r2, [r3, #14]
 8013fd0:	687b      	ldr	r3, [r7, #4]
 8013fd2:	739a      	strb	r2, [r3, #14]
        res->glass            = start->glass;
 8013fd4:	68fb      	ldr	r3, [r7, #12]
 8013fd6:	781b      	ldrb	r3, [r3, #0]
 8013fd8:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8013fdc:	b2d9      	uxtb	r1, r3
 8013fde:	687a      	ldr	r2, [r7, #4]
 8013fe0:	7813      	ldrb	r3, [r2, #0]
 8013fe2:	f361 0300 	bfi	r3, r1, #0, #1
 8013fe6:	7013      	strb	r3, [r2, #0]
        res->text.font        = start->text.font;
 8013fe8:	68fb      	ldr	r3, [r7, #12]
 8013fea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8013fec:	687b      	ldr	r3, [r7, #4]
 8013fee:	625a      	str	r2, [r3, #36]	; 0x24
        res->body.shadow.type = start->body.shadow.type;
 8013ff0:	68fb      	ldr	r3, [r7, #12]
 8013ff2:	7d1a      	ldrb	r2, [r3, #20]
 8013ff4:	687b      	ldr	r3, [r7, #4]
 8013ff6:	751a      	strb	r2, [r3, #20]
        res->line.rounded     = start->line.rounded;
 8013ff8:	68fb      	ldr	r3, [r7, #12]
 8013ffa:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8013ffe:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8014002:	b2d9      	uxtb	r1, r3
 8014004:	687a      	ldr	r2, [r7, #4]
 8014006:	f892 3039 	ldrb.w	r3, [r2, #57]	; 0x39
 801400a:	f361 0300 	bfi	r3, r1, #0, #1
 801400e:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39
        res->glass            = end->glass;
        res->text.font        = end->text.font;
        res->body.shadow.type = end->body.shadow.type;
        res->line.rounded     = end->line.rounded;
    }
}
 8014012:	e022      	b.n	801405a <lv_style_mix+0x5da>
        res->body.border.part = end->body.border.part;
 8014014:	68bb      	ldr	r3, [r7, #8]
 8014016:	7b9a      	ldrb	r2, [r3, #14]
 8014018:	687b      	ldr	r3, [r7, #4]
 801401a:	739a      	strb	r2, [r3, #14]
        res->glass            = end->glass;
 801401c:	68bb      	ldr	r3, [r7, #8]
 801401e:	781b      	ldrb	r3, [r3, #0]
 8014020:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8014024:	b2d9      	uxtb	r1, r3
 8014026:	687a      	ldr	r2, [r7, #4]
 8014028:	7813      	ldrb	r3, [r2, #0]
 801402a:	f361 0300 	bfi	r3, r1, #0, #1
 801402e:	7013      	strb	r3, [r2, #0]
        res->text.font        = end->text.font;
 8014030:	68bb      	ldr	r3, [r7, #8]
 8014032:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8014034:	687b      	ldr	r3, [r7, #4]
 8014036:	625a      	str	r2, [r3, #36]	; 0x24
        res->body.shadow.type = end->body.shadow.type;
 8014038:	68bb      	ldr	r3, [r7, #8]
 801403a:	7d1a      	ldrb	r2, [r3, #20]
 801403c:	687b      	ldr	r3, [r7, #4]
 801403e:	751a      	strb	r2, [r3, #20]
        res->line.rounded     = end->line.rounded;
 8014040:	68bb      	ldr	r3, [r7, #8]
 8014042:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 8014046:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801404a:	b2d9      	uxtb	r1, r3
 801404c:	687a      	ldr	r2, [r7, #4]
 801404e:	f892 3039 	ldrb.w	r3, [r2, #57]	; 0x39
 8014052:	f361 0300 	bfi	r3, r1, #0, #1
 8014056:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39
}
 801405a:	bf00      	nop
 801405c:	371c      	adds	r7, #28
 801405e:	46bd      	mov	sp, r7
 8014060:	bd90      	pop	{r4, r7, pc}
	...

08014064 <lv_draw_get_buf>:
 * Give a buffer with the given to use during drawing.
 * Be careful to not use the buffer while other processes are using it.
 * @param size the required size
 */
void * lv_draw_get_buf(uint32_t size)
{
 8014064:	b580      	push	{r7, lr}
 8014066:	b082      	sub	sp, #8
 8014068:	af00      	add	r7, sp, #0
 801406a:	6078      	str	r0, [r7, #4]
    if(size <= draw_buf_size) return LV_GC_ROOT(_lv_draw_buf);
 801406c:	4b1e      	ldr	r3, [pc, #120]	; (80140e8 <lv_draw_get_buf+0x84>)
 801406e:	681b      	ldr	r3, [r3, #0]
 8014070:	687a      	ldr	r2, [r7, #4]
 8014072:	429a      	cmp	r2, r3
 8014074:	d802      	bhi.n	801407c <lv_draw_get_buf+0x18>
 8014076:	4b1d      	ldr	r3, [pc, #116]	; (80140ec <lv_draw_get_buf+0x88>)
 8014078:	681b      	ldr	r3, [r3, #0]
 801407a:	e030      	b.n	80140de <lv_draw_get_buf+0x7a>

    LV_LOG_TRACE("lv_draw_get_buf: allocate");

    draw_buf_size = size;
 801407c:	4a1a      	ldr	r2, [pc, #104]	; (80140e8 <lv_draw_get_buf+0x84>)
 801407e:	687b      	ldr	r3, [r7, #4]
 8014080:	6013      	str	r3, [r2, #0]

    if(LV_GC_ROOT(_lv_draw_buf) == NULL) {
 8014082:	4b1a      	ldr	r3, [pc, #104]	; (80140ec <lv_draw_get_buf+0x88>)
 8014084:	681b      	ldr	r3, [r3, #0]
 8014086:	2b00      	cmp	r3, #0
 8014088:	d113      	bne.n	80140b2 <lv_draw_get_buf+0x4e>
        LV_GC_ROOT(_lv_draw_buf) = lv_mem_alloc(size);
 801408a:	6878      	ldr	r0, [r7, #4]
 801408c:	f008 fc02 	bl	801c894 <lv_mem_alloc>
 8014090:	4602      	mov	r2, r0
 8014092:	4b16      	ldr	r3, [pc, #88]	; (80140ec <lv_draw_get_buf+0x88>)
 8014094:	601a      	str	r2, [r3, #0]
        lv_mem_assert(LV_GC_ROOT(_lv_draw_buf));
 8014096:	4b15      	ldr	r3, [pc, #84]	; (80140ec <lv_draw_get_buf+0x88>)
 8014098:	681b      	ldr	r3, [r3, #0]
 801409a:	2b00      	cmp	r3, #0
 801409c:	d106      	bne.n	80140ac <lv_draw_get_buf+0x48>
 801409e:	4b14      	ldr	r3, [pc, #80]	; (80140f0 <lv_draw_get_buf+0x8c>)
 80140a0:	223f      	movs	r2, #63	; 0x3f
 80140a2:	4914      	ldr	r1, [pc, #80]	; (80140f4 <lv_draw_get_buf+0x90>)
 80140a4:	2003      	movs	r0, #3
 80140a6:	f008 fbb1 	bl	801c80c <lv_log_add>
 80140aa:	e7fe      	b.n	80140aa <lv_draw_get_buf+0x46>
        return LV_GC_ROOT(_lv_draw_buf);
 80140ac:	4b0f      	ldr	r3, [pc, #60]	; (80140ec <lv_draw_get_buf+0x88>)
 80140ae:	681b      	ldr	r3, [r3, #0]
 80140b0:	e015      	b.n	80140de <lv_draw_get_buf+0x7a>
    }

    LV_GC_ROOT(_lv_draw_buf) = lv_mem_realloc(LV_GC_ROOT(_lv_draw_buf), size);
 80140b2:	4b0e      	ldr	r3, [pc, #56]	; (80140ec <lv_draw_get_buf+0x88>)
 80140b4:	681b      	ldr	r3, [r3, #0]
 80140b6:	6879      	ldr	r1, [r7, #4]
 80140b8:	4618      	mov	r0, r3
 80140ba:	f008 fc7f 	bl	801c9bc <lv_mem_realloc>
 80140be:	4602      	mov	r2, r0
 80140c0:	4b0a      	ldr	r3, [pc, #40]	; (80140ec <lv_draw_get_buf+0x88>)
 80140c2:	601a      	str	r2, [r3, #0]
    lv_mem_assert(LV_GC_ROOT(_lv_draw_buf));
 80140c4:	4b09      	ldr	r3, [pc, #36]	; (80140ec <lv_draw_get_buf+0x88>)
 80140c6:	681b      	ldr	r3, [r3, #0]
 80140c8:	2b00      	cmp	r3, #0
 80140ca:	d106      	bne.n	80140da <lv_draw_get_buf+0x76>
 80140cc:	4b08      	ldr	r3, [pc, #32]	; (80140f0 <lv_draw_get_buf+0x8c>)
 80140ce:	2244      	movs	r2, #68	; 0x44
 80140d0:	4908      	ldr	r1, [pc, #32]	; (80140f4 <lv_draw_get_buf+0x90>)
 80140d2:	2003      	movs	r0, #3
 80140d4:	f008 fb9a 	bl	801c80c <lv_log_add>
 80140d8:	e7fe      	b.n	80140d8 <lv_draw_get_buf+0x74>
    return LV_GC_ROOT(_lv_draw_buf);
 80140da:	4b04      	ldr	r3, [pc, #16]	; (80140ec <lv_draw_get_buf+0x88>)
 80140dc:	681b      	ldr	r3, [r3, #0]
}
 80140de:	4618      	mov	r0, r3
 80140e0:	3708      	adds	r7, #8
 80140e2:	46bd      	mov	sp, r7
 80140e4:	bd80      	pop	{r7, pc}
 80140e6:	bf00      	nop
 80140e8:	20003fb0 	.word	0x20003fb0
 80140ec:	2000df5c 	.word	0x2000df5c
 80140f0:	08028914 	.word	0x08028914
 80140f4:	08028924 	.word	0x08028924

080140f8 <lv_draw_free_buf>:

/**
 * Free the draw buffer
 */
void lv_draw_free_buf(void)
{
 80140f8:	b580      	push	{r7, lr}
 80140fa:	af00      	add	r7, sp, #0
    if(LV_GC_ROOT(_lv_draw_buf)) {
 80140fc:	4b08      	ldr	r3, [pc, #32]	; (8014120 <lv_draw_free_buf+0x28>)
 80140fe:	681b      	ldr	r3, [r3, #0]
 8014100:	2b00      	cmp	r3, #0
 8014102:	d00a      	beq.n	801411a <lv_draw_free_buf+0x22>
        lv_mem_free(LV_GC_ROOT(_lv_draw_buf));
 8014104:	4b06      	ldr	r3, [pc, #24]	; (8014120 <lv_draw_free_buf+0x28>)
 8014106:	681b      	ldr	r3, [r3, #0]
 8014108:	4618      	mov	r0, r3
 801410a:	f008 fc0b 	bl	801c924 <lv_mem_free>
        LV_GC_ROOT(_lv_draw_buf) = NULL;
 801410e:	4b04      	ldr	r3, [pc, #16]	; (8014120 <lv_draw_free_buf+0x28>)
 8014110:	2200      	movs	r2, #0
 8014112:	601a      	str	r2, [r3, #0]
        draw_buf_size = 0;
 8014114:	4b03      	ldr	r3, [pc, #12]	; (8014124 <lv_draw_free_buf+0x2c>)
 8014116:	2200      	movs	r2, #0
 8014118:	601a      	str	r2, [r3, #0]
    }
}
 801411a:	bf00      	nop
 801411c:	bd80      	pop	{r7, pc}
 801411e:	bf00      	nop
 8014120:	2000df5c 	.word	0x2000df5c
 8014124:	20003fb0 	.word	0x20003fb0

08014128 <lv_draw_aa_get_opa>:
 * @param px_id position of  of a pixel which opacity should be get [0..seg-1]
 * @param base_opa the base opacity
 * @return the opacity of the given pixel
 */
lv_opa_t lv_draw_aa_get_opa(lv_coord_t seg, lv_coord_t px_id, lv_opa_t base_opa)
{
 8014128:	b480      	push	{r7}
 801412a:	b083      	sub	sp, #12
 801412c:	af00      	add	r7, sp, #0
 801412e:	4603      	mov	r3, r0
 8014130:	80fb      	strh	r3, [r7, #6]
 8014132:	460b      	mov	r3, r1
 8014134:	80bb      	strh	r3, [r7, #4]
 8014136:	4613      	mov	r3, r2
 8014138:	70fb      	strb	r3, [r7, #3]
    static const lv_opa_t seg7[7] = {18, 55, 91, 128, 164, 200, 237};
    static const lv_opa_t seg8[8] = {16, 48, 80, 112, 143, 175, 207, 239};

    static const lv_opa_t * seg_map[] = {seg1, seg2, seg3, seg4, seg5, seg6, seg7, seg8};

    if(seg == 0)
 801413a:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801413e:	2b00      	cmp	r3, #0
 8014140:	d101      	bne.n	8014146 <lv_draw_aa_get_opa+0x1e>
        return LV_OPA_TRANSP;
 8014142:	2300      	movs	r3, #0
 8014144:	e021      	b.n	801418a <lv_draw_aa_get_opa+0x62>
    else if(seg < 8)
 8014146:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801414a:	2b07      	cmp	r3, #7
 801414c:	dc10      	bgt.n	8014170 <lv_draw_aa_get_opa+0x48>
        return (uint32_t)((uint32_t)seg_map[seg - 1][px_id] * base_opa) >> 8;
 801414e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8014152:	3b01      	subs	r3, #1
 8014154:	4a10      	ldr	r2, [pc, #64]	; (8014198 <lv_draw_aa_get_opa+0x70>)
 8014156:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 801415a:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801415e:	4413      	add	r3, r2
 8014160:	781b      	ldrb	r3, [r3, #0]
 8014162:	461a      	mov	r2, r3
 8014164:	78fb      	ldrb	r3, [r7, #3]
 8014166:	fb03 f302 	mul.w	r3, r3, r2
 801416a:	0a1b      	lsrs	r3, r3, #8
 801416c:	b2db      	uxtb	r3, r3
 801416e:	e00c      	b.n	801418a <lv_draw_aa_get_opa+0x62>
    else {
        return ((px_id * 2 + 1) * base_opa) / (2 * seg);
 8014170:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 8014174:	005b      	lsls	r3, r3, #1
 8014176:	3301      	adds	r3, #1
 8014178:	78fa      	ldrb	r2, [r7, #3]
 801417a:	fb02 f203 	mul.w	r2, r2, r3
 801417e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8014182:	005b      	lsls	r3, r3, #1
 8014184:	fb92 f3f3 	sdiv	r3, r2, r3
 8014188:	b2db      	uxtb	r3, r3
    }
}
 801418a:	4618      	mov	r0, r3
 801418c:	370c      	adds	r7, #12
 801418e:	46bd      	mov	sp, r7
 8014190:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014194:	4770      	bx	lr
 8014196:	bf00      	nop
 8014198:	20000038 	.word	0x20000038

0801419c <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 801419c:	b480      	push	{r7}
 801419e:	b085      	sub	sp, #20
 80141a0:	af00      	add	r7, sp, #0
 80141a2:	80b8      	strh	r0, [r7, #4]
 80141a4:	8039      	strh	r1, [r7, #0]
 80141a6:	4613      	mov	r3, r2
 80141a8:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 80141aa:	797b      	ldrb	r3, [r7, #5]
 80141ac:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80141b0:	b2db      	uxtb	r3, r3
 80141b2:	b29a      	uxth	r2, r3
 80141b4:	78fb      	ldrb	r3, [r7, #3]
 80141b6:	b29b      	uxth	r3, r3
 80141b8:	fb12 f303 	smulbb	r3, r2, r3
 80141bc:	b29a      	uxth	r2, r3
 80141be:	787b      	ldrb	r3, [r7, #1]
 80141c0:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80141c4:	b2db      	uxtb	r3, r3
 80141c6:	b299      	uxth	r1, r3
 80141c8:	78fb      	ldrb	r3, [r7, #3]
 80141ca:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80141ce:	b29b      	uxth	r3, r3
 80141d0:	fb11 f303 	smulbb	r3, r1, r3
 80141d4:	b29b      	uxth	r3, r3
 80141d6:	4413      	add	r3, r2
 80141d8:	b29b      	uxth	r3, r3
 80141da:	0a1b      	lsrs	r3, r3, #8
 80141dc:	b29b      	uxth	r3, r3
 80141de:	f003 031f 	and.w	r3, r3, #31
 80141e2:	b2da      	uxtb	r2, r3
 80141e4:	7b7b      	ldrb	r3, [r7, #13]
 80141e6:	f362 03c7 	bfi	r3, r2, #3, #5
 80141ea:	737b      	strb	r3, [r7, #13]
    uint16_t g_2   = (c2.ch.green_h << 3) + c2.ch.green_l;
    uint16_t g_out = (uint16_t)((uint16_t)g_1 * mix + (g_2 * (255 - mix))) >> 8;
    ret.ch.green_h = g_out >> 3;
    ret.ch.green_l = g_out & 0x7;
#else
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 80141ec:	88bb      	ldrh	r3, [r7, #4]
 80141ee:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80141f2:	b2db      	uxtb	r3, r3
 80141f4:	b29a      	uxth	r2, r3
 80141f6:	78fb      	ldrb	r3, [r7, #3]
 80141f8:	b29b      	uxth	r3, r3
 80141fa:	fb12 f303 	smulbb	r3, r2, r3
 80141fe:	b29a      	uxth	r2, r3
 8014200:	883b      	ldrh	r3, [r7, #0]
 8014202:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8014206:	b2db      	uxtb	r3, r3
 8014208:	b299      	uxth	r1, r3
 801420a:	78fb      	ldrb	r3, [r7, #3]
 801420c:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8014210:	b29b      	uxth	r3, r3
 8014212:	fb11 f303 	smulbb	r3, r1, r3
 8014216:	b29b      	uxth	r3, r3
 8014218:	4413      	add	r3, r2
 801421a:	b29b      	uxth	r3, r3
 801421c:	0a1b      	lsrs	r3, r3, #8
 801421e:	b29b      	uxth	r3, r3
 8014220:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8014224:	b2da      	uxtb	r2, r3
 8014226:	89bb      	ldrh	r3, [r7, #12]
 8014228:	f362 134a 	bfi	r3, r2, #5, #6
 801422c:	81bb      	strh	r3, [r7, #12]
#endif
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 801422e:	793b      	ldrb	r3, [r7, #4]
 8014230:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8014234:	b2db      	uxtb	r3, r3
 8014236:	b29a      	uxth	r2, r3
 8014238:	78fb      	ldrb	r3, [r7, #3]
 801423a:	b29b      	uxth	r3, r3
 801423c:	fb12 f303 	smulbb	r3, r2, r3
 8014240:	b29a      	uxth	r2, r3
 8014242:	783b      	ldrb	r3, [r7, #0]
 8014244:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8014248:	b2db      	uxtb	r3, r3
 801424a:	b299      	uxth	r1, r3
 801424c:	78fb      	ldrb	r3, [r7, #3]
 801424e:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8014252:	b29b      	uxth	r3, r3
 8014254:	fb11 f303 	smulbb	r3, r1, r3
 8014258:	b29b      	uxth	r3, r3
 801425a:	4413      	add	r3, r2
 801425c:	b29b      	uxth	r3, r3
 801425e:	0a1b      	lsrs	r3, r3, #8
 8014260:	b29b      	uxth	r3, r3
 8014262:	f003 031f 	and.w	r3, r3, #31
 8014266:	b2da      	uxtb	r2, r3
 8014268:	7b3b      	ldrb	r3, [r7, #12]
 801426a:	f362 0304 	bfi	r3, r2, #0, #5
 801426e:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 8014270:	89bb      	ldrh	r3, [r7, #12]
}
 8014272:	4618      	mov	r0, r3
 8014274:	3714      	adds	r7, #20
 8014276:	46bd      	mov	sp, r7
 8014278:	f85d 7b04 	ldr.w	r7, [sp], #4
 801427c:	4770      	bx	lr

0801427e <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 801427e:	b480      	push	{r7}
 8014280:	b083      	sub	sp, #12
 8014282:	af00      	add	r7, sp, #0
 8014284:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 8014286:	687b      	ldr	r3, [r7, #4]
 8014288:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801428c:	b29a      	uxth	r2, r3
 801428e:	687b      	ldr	r3, [r7, #4]
 8014290:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014294:	b29b      	uxth	r3, r3
 8014296:	1ad3      	subs	r3, r2, r3
 8014298:	b29b      	uxth	r3, r3
 801429a:	3301      	adds	r3, #1
 801429c:	b29b      	uxth	r3, r3
 801429e:	b21b      	sxth	r3, r3
}
 80142a0:	4618      	mov	r0, r3
 80142a2:	370c      	adds	r7, #12
 80142a4:	46bd      	mov	sp, r7
 80142a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142aa:	4770      	bx	lr

080142ac <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80142ac:	b480      	push	{r7}
 80142ae:	b083      	sub	sp, #12
 80142b0:	af00      	add	r7, sp, #0
 80142b2:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 80142b4:	687b      	ldr	r3, [r7, #4]
 80142b6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80142ba:	b29a      	uxth	r2, r3
 80142bc:	687b      	ldr	r3, [r7, #4]
 80142be:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80142c2:	b29b      	uxth	r3, r3
 80142c4:	1ad3      	subs	r3, r2, r3
 80142c6:	b29b      	uxth	r3, r3
 80142c8:	3301      	adds	r3, #1
 80142ca:	b29b      	uxth	r3, r3
 80142cc:	b21b      	sxth	r3, r3
}
 80142ce:	4618      	mov	r0, r3
 80142d0:	370c      	adds	r7, #12
 80142d2:	46bd      	mov	sp, r7
 80142d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80142d8:	4770      	bx	lr

080142da <lv_draw_px>:
 * @param mask_p fill only on this mask (truncated to VDB area)
 * @param color pixel color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_px(lv_coord_t x, lv_coord_t y, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
 80142da:	b5b0      	push	{r4, r5, r7, lr}
 80142dc:	b08e      	sub	sp, #56	; 0x38
 80142de:	af04      	add	r7, sp, #16
 80142e0:	60ba      	str	r2, [r7, #8]
 80142e2:	80bb      	strh	r3, [r7, #4]
 80142e4:	4603      	mov	r3, r0
 80142e6:	81fb      	strh	r3, [r7, #14]
 80142e8:	460b      	mov	r3, r1
 80142ea:	81bb      	strh	r3, [r7, #12]

    if(opa < LV_OPA_MIN) return;
 80142ec:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80142f0:	2b0f      	cmp	r3, #15
 80142f2:	f240 8084 	bls.w	80143fe <lv_draw_px+0x124>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 80142f6:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80142fa:	2bfb      	cmp	r3, #251	; 0xfb
 80142fc:	d902      	bls.n	8014304 <lv_draw_px+0x2a>
 80142fe:	23ff      	movs	r3, #255	; 0xff
 8014300:	f887 3038 	strb.w	r3, [r7, #56]	; 0x38

    /*Pixel out of the mask*/
    if(x < mask_p->x1 || x > mask_p->x2 || y < mask_p->y1 || y > mask_p->y2) {
 8014304:	68bb      	ldr	r3, [r7, #8]
 8014306:	f9b3 3000 	ldrsh.w	r3, [r3]
 801430a:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 801430e:	429a      	cmp	r2, r3
 8014310:	db77      	blt.n	8014402 <lv_draw_px+0x128>
 8014312:	68bb      	ldr	r3, [r7, #8]
 8014314:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014318:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 801431c:	429a      	cmp	r2, r3
 801431e:	dc70      	bgt.n	8014402 <lv_draw_px+0x128>
 8014320:	68bb      	ldr	r3, [r7, #8]
 8014322:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014326:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 801432a:	429a      	cmp	r2, r3
 801432c:	db69      	blt.n	8014402 <lv_draw_px+0x128>
 801432e:	68bb      	ldr	r3, [r7, #8]
 8014330:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014334:	f9b7 200c 	ldrsh.w	r2, [r7, #12]
 8014338:	429a      	cmp	r2, r3
 801433a:	dc62      	bgt.n	8014402 <lv_draw_px+0x128>
        return;
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 801433c:	f7fe fbb0 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8014340:	6278      	str	r0, [r7, #36]	; 0x24
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8014342:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8014344:	f006 ff56 	bl	801b1f4 <lv_disp_get_buf>
 8014348:	6238      	str	r0, [r7, #32]
    uint32_t vdb_width  = lv_area_get_width(&vdb->area);
 801434a:	6a3b      	ldr	r3, [r7, #32]
 801434c:	3310      	adds	r3, #16
 801434e:	4618      	mov	r0, r3
 8014350:	f7ff ff95 	bl	801427e <lv_area_get_width>
 8014354:	4603      	mov	r3, r0
 8014356:	61fb      	str	r3, [r7, #28]

    /*Make the coordinates relative to VDB*/
    x -= vdb->area.x1;
 8014358:	89fa      	ldrh	r2, [r7, #14]
 801435a:	6a3b      	ldr	r3, [r7, #32]
 801435c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8014360:	b29b      	uxth	r3, r3
 8014362:	1ad3      	subs	r3, r2, r3
 8014364:	b29b      	uxth	r3, r3
 8014366:	81fb      	strh	r3, [r7, #14]
    y -= vdb->area.y1;
 8014368:	89ba      	ldrh	r2, [r7, #12]
 801436a:	6a3b      	ldr	r3, [r7, #32]
 801436c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8014370:	b29b      	uxth	r3, r3
 8014372:	1ad3      	subs	r3, r2, r3
 8014374:	b29b      	uxth	r3, r3
 8014376:	81bb      	strh	r3, [r7, #12]

    if(disp->driver.set_px_cb) {
 8014378:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801437a:	695b      	ldr	r3, [r3, #20]
 801437c:	2b00      	cmp	r3, #0
 801437e:	d014      	beq.n	80143aa <lv_draw_px+0xd0>
        disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width, x, y, color, opa);
 8014380:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014382:	695c      	ldr	r4, [r3, #20]
 8014384:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8014386:	6a3b      	ldr	r3, [r7, #32]
 8014388:	6899      	ldr	r1, [r3, #8]
 801438a:	69fb      	ldr	r3, [r7, #28]
 801438c:	b21a      	sxth	r2, r3
 801438e:	f9b7 500e 	ldrsh.w	r5, [r7, #14]
 8014392:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8014396:	9302      	str	r3, [sp, #8]
 8014398:	88bb      	ldrh	r3, [r7, #4]
 801439a:	f8ad 3004 	strh.w	r3, [sp, #4]
 801439e:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80143a2:	9300      	str	r3, [sp, #0]
 80143a4:	462b      	mov	r3, r5
 80143a6:	47a0      	blx	r4
 80143a8:	e02c      	b.n	8014404 <lv_draw_px+0x12a>
    } else {
        bool scr_transp = false;
 80143aa:	2300      	movs	r3, #0
 80143ac:	76fb      	strb	r3, [r7, #27]
#if LV_COLOR_SCREEN_TRANSP
        scr_transp = disp->driver.screen_transp;
#endif

        lv_color_t * vdb_px_p = vdb->buf_act;
 80143ae:	6a3b      	ldr	r3, [r7, #32]
 80143b0:	689b      	ldr	r3, [r3, #8]
 80143b2:	617b      	str	r3, [r7, #20]
        vdb_px_p += y * vdb_width + x;
 80143b4:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80143b8:	69fa      	ldr	r2, [r7, #28]
 80143ba:	fb02 f203 	mul.w	r2, r2, r3
 80143be:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80143c2:	4413      	add	r3, r2
 80143c4:	005b      	lsls	r3, r3, #1
 80143c6:	697a      	ldr	r2, [r7, #20]
 80143c8:	4413      	add	r3, r2
 80143ca:	617b      	str	r3, [r7, #20]

        if(scr_transp == false) {
 80143cc:	7efb      	ldrb	r3, [r7, #27]
 80143ce:	f083 0301 	eor.w	r3, r3, #1
 80143d2:	b2db      	uxtb	r3, r3
 80143d4:	2b00      	cmp	r3, #0
 80143d6:	d015      	beq.n	8014404 <lv_draw_px+0x12a>
            if(opa == LV_OPA_COVER) {
 80143d8:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 80143dc:	2bff      	cmp	r3, #255	; 0xff
 80143de:	d103      	bne.n	80143e8 <lv_draw_px+0x10e>
                *vdb_px_p = color;
 80143e0:	697b      	ldr	r3, [r7, #20]
 80143e2:	88ba      	ldrh	r2, [r7, #4]
 80143e4:	801a      	strh	r2, [r3, #0]
 80143e6:	e00d      	b.n	8014404 <lv_draw_px+0x12a>
            } else {
                *vdb_px_p = lv_color_mix(color, *vdb_px_p, opa);
 80143e8:	f897 2038 	ldrb.w	r2, [r7, #56]	; 0x38
 80143ec:	697b      	ldr	r3, [r7, #20]
 80143ee:	8819      	ldrh	r1, [r3, #0]
 80143f0:	88b8      	ldrh	r0, [r7, #4]
 80143f2:	f7ff fed3 	bl	801419c <lv_color_mix>
 80143f6:	4602      	mov	r2, r0
 80143f8:	697b      	ldr	r3, [r7, #20]
 80143fa:	801a      	strh	r2, [r3, #0]
 80143fc:	e002      	b.n	8014404 <lv_draw_px+0x12a>
    if(opa < LV_OPA_MIN) return;
 80143fe:	bf00      	nop
 8014400:	e000      	b.n	8014404 <lv_draw_px+0x12a>
        return;
 8014402:	bf00      	nop
#if LV_COLOR_DEPTH == 32
            *vdb_px_p = color_mix_2_alpha(*vdb_px_p, (*vdb_px_p).ch.alpha, color, opa);
#endif
        }
    }
}
 8014404:	3728      	adds	r7, #40	; 0x28
 8014406:	46bd      	mov	sp, r7
 8014408:	bdb0      	pop	{r4, r5, r7, pc}
	...

0801440c <lv_draw_fill>:
 * @param mask_p fill only o this mask  (truncated to VDB area)
 * @param color fill color
 * @param opa opacity of the area (0..255)
 */
void lv_draw_fill(const lv_area_t * cords_p, const lv_area_t * mask_p, lv_color_t color, lv_opa_t opa)
{
 801440c:	b5b0      	push	{r4, r5, r7, lr}
 801440e:	b092      	sub	sp, #72	; 0x48
 8014410:	af02      	add	r7, sp, #8
 8014412:	60f8      	str	r0, [r7, #12]
 8014414:	60b9      	str	r1, [r7, #8]
 8014416:	80ba      	strh	r2, [r7, #4]
 8014418:	71fb      	strb	r3, [r7, #7]
    if(opa < LV_OPA_MIN) return;
 801441a:	79fb      	ldrb	r3, [r7, #7]
 801441c:	2b0f      	cmp	r3, #15
 801441e:	f240 8139 	bls.w	8014694 <lv_draw_fill+0x288>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 8014422:	79fb      	ldrb	r3, [r7, #7]
 8014424:	2bfb      	cmp	r3, #251	; 0xfb
 8014426:	d901      	bls.n	801442c <lv_draw_fill+0x20>
 8014428:	23ff      	movs	r3, #255	; 0xff
 801442a:	71fb      	strb	r3, [r7, #7]
    bool union_ok;

    /*Get the union of cord and mask*/
    /* The mask is already truncated to the vdb size
     * in 'lv_refr_area_with_vdb' function */
    union_ok = lv_area_intersect(&res_a, cords_p, mask_p);
 801442c:	f107 0318 	add.w	r3, r7, #24
 8014430:	68ba      	ldr	r2, [r7, #8]
 8014432:	68f9      	ldr	r1, [r7, #12]
 8014434:	4618      	mov	r0, r3
 8014436:	f007 fb4f 	bl	801bad8 <lv_area_intersect>
 801443a:	4603      	mov	r3, r0
 801443c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    /*If there are common part of the three area then draw to the vdb*/
    if(union_ok == false) {
 8014440:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8014444:	f083 0301 	eor.w	r3, r3, #1
 8014448:	b2db      	uxtb	r3, r3
 801444a:	2b00      	cmp	r3, #0
 801444c:	f040 8124 	bne.w	8014698 <lv_draw_fill+0x28c>
        return;
    }

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 8014450:	f7fe fb26 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8014454:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8014456:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8014458:	f006 fecc 	bl	801b1f4 <lv_disp_get_buf>
 801445c:	62b8      	str	r0, [r7, #40]	; 0x28

    lv_area_t vdb_rel_a; /*Stores relative coordinates on vdb*/
    vdb_rel_a.x1 = res_a.x1 - vdb->area.x1;
 801445e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8014462:	b29a      	uxth	r2, r3
 8014464:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014466:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801446a:	b29b      	uxth	r3, r3
 801446c:	1ad3      	subs	r3, r2, r3
 801446e:	b29b      	uxth	r3, r3
 8014470:	b21b      	sxth	r3, r3
 8014472:	823b      	strh	r3, [r7, #16]
    vdb_rel_a.y1 = res_a.y1 - vdb->area.y1;
 8014474:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8014478:	b29a      	uxth	r2, r3
 801447a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801447c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8014480:	b29b      	uxth	r3, r3
 8014482:	1ad3      	subs	r3, r2, r3
 8014484:	b29b      	uxth	r3, r3
 8014486:	b21b      	sxth	r3, r3
 8014488:	827b      	strh	r3, [r7, #18]
    vdb_rel_a.x2 = res_a.x2 - vdb->area.x1;
 801448a:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 801448e:	b29a      	uxth	r2, r3
 8014490:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014492:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8014496:	b29b      	uxth	r3, r3
 8014498:	1ad3      	subs	r3, r2, r3
 801449a:	b29b      	uxth	r3, r3
 801449c:	b21b      	sxth	r3, r3
 801449e:	82bb      	strh	r3, [r7, #20]
    vdb_rel_a.y2 = res_a.y2 - vdb->area.y1;
 80144a0:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80144a4:	b29a      	uxth	r2, r3
 80144a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144a8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80144ac:	b29b      	uxth	r3, r3
 80144ae:	1ad3      	subs	r3, r2, r3
 80144b0:	b29b      	uxth	r3, r3
 80144b2:	b21b      	sxth	r3, r3
 80144b4:	82fb      	strh	r3, [r7, #22]

    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 80144b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144b8:	689b      	ldr	r3, [r3, #8]
 80144ba:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t vdb_width       = lv_area_get_width(&vdb->area);
 80144bc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144be:	3310      	adds	r3, #16
 80144c0:	4618      	mov	r0, r3
 80144c2:	f7ff fedc 	bl	801427e <lv_area_get_width>
 80144c6:	4603      	mov	r3, r0
 80144c8:	627b      	str	r3, [r7, #36]	; 0x24
    /*Move the vdb_tmp to the first row*/
    vdb_buf_tmp += vdb_width * vdb_rel_a.y1;
 80144ca:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80144ce:	461a      	mov	r2, r3
 80144d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80144d2:	fb03 f302 	mul.w	r3, r3, r2
 80144d6:	005b      	lsls	r3, r3, #1
 80144d8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80144da:	4413      	add	r3, r2
 80144dc:	63fb      	str	r3, [r7, #60]	; 0x3c

#if LV_USE_GPU
    static LV_ATTRIBUTE_MEM_ALIGN lv_color_t color_array_tmp[LV_HOR_RES_MAX]; /*Used by 'lv_disp_mem_blend'*/
    static lv_coord_t last_width = -1;

    lv_coord_t w = lv_area_get_width(&vdb_rel_a);
 80144de:	f107 0310 	add.w	r3, r7, #16
 80144e2:	4618      	mov	r0, r3
 80144e4:	f7ff fecb 	bl	801427e <lv_area_get_width>
 80144e8:	4603      	mov	r3, r0
 80144ea:	847b      	strh	r3, [r7, #34]	; 0x22
    /*Don't use hw. acc. for every small fill (because of the init overhead)*/
    if(w < VFILL_HW_ACC_SIZE_LIMIT) {
 80144ec:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 80144f0:	2b31      	cmp	r3, #49	; 0x31
 80144f2:	dc0b      	bgt.n	801450c <lv_draw_fill+0x100>
        sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 80144f4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80144f6:	6898      	ldr	r0, [r3, #8]
 80144f8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80144fa:	b219      	sxth	r1, r3
 80144fc:	f107 0210 	add.w	r2, r7, #16
 8014500:	79fb      	ldrb	r3, [r7, #7]
 8014502:	9300      	str	r3, [sp, #0]
 8014504:	88bb      	ldrh	r3, [r7, #4]
 8014506:	f000 fb7d 	bl	8014c04 <sw_color_fill>
 801450a:	e0c6      	b.n	801469a <lv_draw_fill+0x28e>
    }
    /*Not opaque fill*/
    else if(opa == LV_OPA_COVER) {
 801450c:	79fb      	ldrb	r3, [r7, #7]
 801450e:	2bff      	cmp	r3, #255	; 0xff
 8014510:	d16d      	bne.n	80145ee <lv_draw_fill+0x1e2>
        /*Use hw fill if present*/
        if(disp->driver.gpu_fill_cb) {
 8014512:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014514:	6a1b      	ldr	r3, [r3, #32]
 8014516:	2b00      	cmp	r3, #0
 8014518:	d00e      	beq.n	8014538 <lv_draw_fill+0x12c>
            disp->driver.gpu_fill_cb(&disp->driver, vdb->buf_act, vdb_width, &vdb_rel_a, color);
 801451a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801451c:	6a1c      	ldr	r4, [r3, #32]
 801451e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8014520:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8014522:	6899      	ldr	r1, [r3, #8]
 8014524:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014526:	b21a      	sxth	r2, r3
 8014528:	f107 0510 	add.w	r5, r7, #16
 801452c:	88bb      	ldrh	r3, [r7, #4]
 801452e:	f8ad 3000 	strh.w	r3, [sp]
 8014532:	462b      	mov	r3, r5
 8014534:	47a0      	blx	r4
 8014536:	e0b0      	b.n	801469a <lv_draw_fill+0x28e>
        }
        /*Use hw blend if present and the area is not too small*/
        else if(lv_area_get_height(&vdb_rel_a) > VFILL_HW_ACC_SIZE_LIMIT && disp->driver.gpu_blend_cb) {
 8014538:	f107 0310 	add.w	r3, r7, #16
 801453c:	4618      	mov	r0, r3
 801453e:	f7ff feb5 	bl	80142ac <lv_area_get_height>
 8014542:	4603      	mov	r3, r0
 8014544:	2b32      	cmp	r3, #50	; 0x32
 8014546:	dd46      	ble.n	80145d6 <lv_draw_fill+0x1ca>
 8014548:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801454a:	69db      	ldr	r3, [r3, #28]
 801454c:	2b00      	cmp	r3, #0
 801454e:	d042      	beq.n	80145d6 <lv_draw_fill+0x1ca>
            /*Fill a  one line sized buffer with a color and blend this later*/
            if(color_array_tmp[0].full != color.full || last_width != w) {
 8014550:	4b53      	ldr	r3, [pc, #332]	; (80146a0 <lv_draw_fill+0x294>)
 8014552:	881a      	ldrh	r2, [r3, #0]
 8014554:	88bb      	ldrh	r3, [r7, #4]
 8014556:	429a      	cmp	r2, r3
 8014558:	d106      	bne.n	8014568 <lv_draw_fill+0x15c>
 801455a:	4b52      	ldr	r3, [pc, #328]	; (80146a4 <lv_draw_fill+0x298>)
 801455c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014560:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 8014564:	429a      	cmp	r2, r3
 8014566:	d012      	beq.n	801458e <lv_draw_fill+0x182>
                uint16_t i;
                for(i = 0; i < w; i++) {
 8014568:	2300      	movs	r3, #0
 801456a:	877b      	strh	r3, [r7, #58]	; 0x3a
 801456c:	e007      	b.n	801457e <lv_draw_fill+0x172>
                    color_array_tmp[i].full = color.full;
 801456e:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8014570:	88b9      	ldrh	r1, [r7, #4]
 8014572:	4a4b      	ldr	r2, [pc, #300]	; (80146a0 <lv_draw_fill+0x294>)
 8014574:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                for(i = 0; i < w; i++) {
 8014578:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801457a:	3301      	adds	r3, #1
 801457c:	877b      	strh	r3, [r7, #58]	; 0x3a
 801457e:	8f7a      	ldrh	r2, [r7, #58]	; 0x3a
 8014580:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8014584:	429a      	cmp	r2, r3
 8014586:	dbf2      	blt.n	801456e <lv_draw_fill+0x162>
                }
                last_width = w;
 8014588:	4a46      	ldr	r2, [pc, #280]	; (80146a4 <lv_draw_fill+0x298>)
 801458a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801458c:	8013      	strh	r3, [r2, #0]
            }

            /*Blend the filled line to every line VDB line-by-line*/
            lv_coord_t row;
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 801458e:	8a7b      	ldrh	r3, [r7, #18]
 8014590:	873b      	strh	r3, [r7, #56]	; 0x38
 8014592:	e019      	b.n	80145c8 <lv_draw_fill+0x1bc>
                disp->driver.gpu_blend_cb(&disp->driver, &vdb_buf_tmp[vdb_rel_a.x1], color_array_tmp, w, opa);
 8014594:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8014596:	69dc      	ldr	r4, [r3, #28]
 8014598:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801459a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801459e:	005b      	lsls	r3, r3, #1
 80145a0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80145a2:	18d1      	adds	r1, r2, r3
 80145a4:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 80145a8:	79fb      	ldrb	r3, [r7, #7]
 80145aa:	9300      	str	r3, [sp, #0]
 80145ac:	4613      	mov	r3, r2
 80145ae:	4a3c      	ldr	r2, [pc, #240]	; (80146a0 <lv_draw_fill+0x294>)
 80145b0:	47a0      	blx	r4
                vdb_buf_tmp += vdb_width;
 80145b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80145b4:	005b      	lsls	r3, r3, #1
 80145b6:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80145b8:	4413      	add	r3, r2
 80145ba:	63fb      	str	r3, [r7, #60]	; 0x3c
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 80145bc:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80145c0:	b29b      	uxth	r3, r3
 80145c2:	3301      	adds	r3, #1
 80145c4:	b29b      	uxth	r3, r3
 80145c6:	873b      	strh	r3, [r7, #56]	; 0x38
 80145c8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80145cc:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 80145d0:	429a      	cmp	r2, r3
 80145d2:	dddf      	ble.n	8014594 <lv_draw_fill+0x188>
        else if(lv_area_get_height(&vdb_rel_a) > VFILL_HW_ACC_SIZE_LIMIT && disp->driver.gpu_blend_cb) {
 80145d4:	e061      	b.n	801469a <lv_draw_fill+0x28e>
            }

        }
        /*Else use sw fill if no better option*/
        else {
            sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 80145d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80145d8:	6898      	ldr	r0, [r3, #8]
 80145da:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80145dc:	b219      	sxth	r1, r3
 80145de:	f107 0210 	add.w	r2, r7, #16
 80145e2:	79fb      	ldrb	r3, [r7, #7]
 80145e4:	9300      	str	r3, [sp, #0]
 80145e6:	88bb      	ldrh	r3, [r7, #4]
 80145e8:	f000 fb0c 	bl	8014c04 <sw_color_fill>
 80145ec:	e055      	b.n	801469a <lv_draw_fill+0x28e>

    }
    /*Fill with opacity*/
    else {
        /*Use hw blend if present*/
        if(disp->driver.gpu_blend_cb) {
 80145ee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80145f0:	69db      	ldr	r3, [r3, #28]
 80145f2:	2b00      	cmp	r3, #0
 80145f4:	d042      	beq.n	801467c <lv_draw_fill+0x270>
            if(color_array_tmp[0].full != color.full || last_width != w) {
 80145f6:	4b2a      	ldr	r3, [pc, #168]	; (80146a0 <lv_draw_fill+0x294>)
 80145f8:	881a      	ldrh	r2, [r3, #0]
 80145fa:	88bb      	ldrh	r3, [r7, #4]
 80145fc:	429a      	cmp	r2, r3
 80145fe:	d106      	bne.n	801460e <lv_draw_fill+0x202>
 8014600:	4b28      	ldr	r3, [pc, #160]	; (80146a4 <lv_draw_fill+0x298>)
 8014602:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014606:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 801460a:	429a      	cmp	r2, r3
 801460c:	d012      	beq.n	8014634 <lv_draw_fill+0x228>
                uint16_t i;
                for(i = 0; i < w; i++) {
 801460e:	2300      	movs	r3, #0
 8014610:	86fb      	strh	r3, [r7, #54]	; 0x36
 8014612:	e007      	b.n	8014624 <lv_draw_fill+0x218>
                    color_array_tmp[i].full = color.full;
 8014614:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8014616:	88b9      	ldrh	r1, [r7, #4]
 8014618:	4a21      	ldr	r2, [pc, #132]	; (80146a0 <lv_draw_fill+0x294>)
 801461a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                for(i = 0; i < w; i++) {
 801461e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8014620:	3301      	adds	r3, #1
 8014622:	86fb      	strh	r3, [r7, #54]	; 0x36
 8014624:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 8014626:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801462a:	429a      	cmp	r2, r3
 801462c:	dbf2      	blt.n	8014614 <lv_draw_fill+0x208>
                }

                last_width = w;
 801462e:	4a1d      	ldr	r2, [pc, #116]	; (80146a4 <lv_draw_fill+0x298>)
 8014630:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8014632:	8013      	strh	r3, [r2, #0]
            }
            lv_coord_t row;
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 8014634:	8a7b      	ldrh	r3, [r7, #18]
 8014636:	86bb      	strh	r3, [r7, #52]	; 0x34
 8014638:	e019      	b.n	801466e <lv_draw_fill+0x262>
                disp->driver.gpu_blend_cb(&disp->driver, &vdb_buf_tmp[vdb_rel_a.x1], color_array_tmp, w, opa);
 801463a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801463c:	69dc      	ldr	r4, [r3, #28]
 801463e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8014640:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8014644:	005b      	lsls	r3, r3, #1
 8014646:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8014648:	18d1      	adds	r1, r2, r3
 801464a:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 801464e:	79fb      	ldrb	r3, [r7, #7]
 8014650:	9300      	str	r3, [sp, #0]
 8014652:	4613      	mov	r3, r2
 8014654:	4a12      	ldr	r2, [pc, #72]	; (80146a0 <lv_draw_fill+0x294>)
 8014656:	47a0      	blx	r4
                vdb_buf_tmp += vdb_width;
 8014658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801465a:	005b      	lsls	r3, r3, #1
 801465c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801465e:	4413      	add	r3, r2
 8014660:	63fb      	str	r3, [r7, #60]	; 0x3c
            for(row = vdb_rel_a.y1; row <= vdb_rel_a.y2; row++) {
 8014662:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8014666:	b29b      	uxth	r3, r3
 8014668:	3301      	adds	r3, #1
 801466a:	b29b      	uxth	r3, r3
 801466c:	86bb      	strh	r3, [r7, #52]	; 0x34
 801466e:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8014672:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 8014676:	429a      	cmp	r2, r3
 8014678:	dddf      	ble.n	801463a <lv_draw_fill+0x22e>
 801467a:	e00e      	b.n	801469a <lv_draw_fill+0x28e>
            }

        }
        /*Use sw fill with opa if no better option*/
        else {
            sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
 801467c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801467e:	6898      	ldr	r0, [r3, #8]
 8014680:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8014682:	b219      	sxth	r1, r3
 8014684:	f107 0210 	add.w	r2, r7, #16
 8014688:	79fb      	ldrb	r3, [r7, #7]
 801468a:	9300      	str	r3, [sp, #0]
 801468c:	88bb      	ldrh	r3, [r7, #4]
 801468e:	f000 fab9 	bl	8014c04 <sw_color_fill>
 8014692:	e002      	b.n	801469a <lv_draw_fill+0x28e>
    if(opa < LV_OPA_MIN) return;
 8014694:	bf00      	nop
 8014696:	e000      	b.n	801469a <lv_draw_fill+0x28e>
        return;
 8014698:	bf00      	nop
        }
    }
#else
    sw_color_fill(vdb->buf_act, vdb_width, &vdb_rel_a, color, opa);
#endif
}
 801469a:	3740      	adds	r7, #64	; 0x40
 801469c:	46bd      	mov	sp, r7
 801469e:	bdb0      	pop	{r4, r5, r7, pc}
 80146a0:	20003fb4 	.word	0x20003fb4
 80146a4:	20000058 	.word	0x20000058

080146a8 <lv_draw_letter>:
 * @param color color of letter
 * @param opa opacity of letter (0..255)
 */
void lv_draw_letter(const lv_point_t * pos_p, const lv_area_t * mask_p, const lv_font_t * font_p, uint32_t letter,
                    lv_color_t color, lv_opa_t opa)
{
 80146a8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80146aa:	b0a1      	sub	sp, #132	; 0x84
 80146ac:	af04      	add	r7, sp, #16
 80146ae:	60f8      	str	r0, [r7, #12]
 80146b0:	60b9      	str	r1, [r7, #8]
 80146b2:	607a      	str	r2, [r7, #4]
 80146b4:	603b      	str	r3, [r7, #0]
    /*clang-format off*/
    const uint8_t bpp1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 80146b6:	2300      	movs	r3, #0
 80146b8:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
 80146bc:	23ff      	movs	r3, #255	; 0xff
 80146be:	f887 3031 	strb.w	r3, [r7, #49]	; 0x31
    const uint8_t bpp2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 80146c2:	4bba      	ldr	r3, [pc, #744]	; (80149ac <lv_draw_letter+0x304>)
 80146c4:	681b      	ldr	r3, [r3, #0]
 80146c6:	62fb      	str	r3, [r7, #44]	; 0x2c
    const uint8_t bpp4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 80146c8:	4bb9      	ldr	r3, [pc, #740]	; (80149b0 <lv_draw_letter+0x308>)
 80146ca:	f107 041c 	add.w	r4, r7, #28
 80146ce:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 80146d0:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                        68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};
    /*clang-format on*/

    if(opa < LV_OPA_MIN) return;
 80146d4:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 80146d8:	2b0f      	cmp	r3, #15
 80146da:	f240 8287 	bls.w	8014bec <lv_draw_letter+0x544>
    if(opa > LV_OPA_MAX) opa = LV_OPA_COVER;
 80146de:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 80146e2:	2bfb      	cmp	r3, #251	; 0xfb
 80146e4:	d902      	bls.n	80146ec <lv_draw_letter+0x44>
 80146e6:	23ff      	movs	r3, #255	; 0xff
 80146e8:	f887 308c 	strb.w	r3, [r7, #140]	; 0x8c

    if(font_p == NULL) {
 80146ec:	687b      	ldr	r3, [r7, #4]
 80146ee:	2b00      	cmp	r3, #0
 80146f0:	d106      	bne.n	8014700 <lv_draw_letter+0x58>
        LV_LOG_WARN("Font: character's bitmap not found");
 80146f2:	4bb0      	ldr	r3, [pc, #704]	; (80149b4 <lv_draw_letter+0x30c>)
 80146f4:	22f5      	movs	r2, #245	; 0xf5
 80146f6:	49b0      	ldr	r1, [pc, #704]	; (80149b8 <lv_draw_letter+0x310>)
 80146f8:	2002      	movs	r0, #2
 80146fa:	f008 f887 	bl	801c80c <lv_log_add>
        return;
 80146fe:	e27e      	b.n	8014bfe <lv_draw_letter+0x556>
    }

    lv_font_glyph_dsc_t g;
    bool g_ret = lv_font_get_glyph_dsc(font_p, &g, letter, '\0');
 8014700:	f107 0114 	add.w	r1, r7, #20
 8014704:	2300      	movs	r3, #0
 8014706:	683a      	ldr	r2, [r7, #0]
 8014708:	6878      	ldr	r0, [r7, #4]
 801470a:	f006 f8e2 	bl	801a8d2 <lv_font_get_glyph_dsc>
 801470e:	4603      	mov	r3, r0
 8014710:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    if(g_ret == false) return;
 8014714:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8014718:	f083 0301 	eor.w	r3, r3, #1
 801471c:	b2db      	uxtb	r3, r3
 801471e:	2b00      	cmp	r3, #0
 8014720:	f040 8266 	bne.w	8014bf0 <lv_draw_letter+0x548>

    lv_coord_t pos_x = pos_p->x + g.ofs_x;
 8014724:	68fb      	ldr	r3, [r7, #12]
 8014726:	f9b3 3000 	ldrsh.w	r3, [r3]
 801472a:	b29a      	uxth	r2, r3
 801472c:	f997 3018 	ldrsb.w	r3, [r7, #24]
 8014730:	b29b      	uxth	r3, r3
 8014732:	4413      	add	r3, r2
 8014734:	b29b      	uxth	r3, r3
 8014736:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lv_coord_t pos_y = pos_p->y + (font_p->line_height - font_p->base_line) - g.box_h - g.ofs_y;
 801473a:	68fb      	ldr	r3, [r7, #12]
 801473c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014740:	b29a      	uxth	r2, r3
 8014742:	687b      	ldr	r3, [r7, #4]
 8014744:	7a1b      	ldrb	r3, [r3, #8]
 8014746:	b299      	uxth	r1, r3
 8014748:	687b      	ldr	r3, [r7, #4]
 801474a:	7a5b      	ldrb	r3, [r3, #9]
 801474c:	b29b      	uxth	r3, r3
 801474e:	1acb      	subs	r3, r1, r3
 8014750:	b29b      	uxth	r3, r3
 8014752:	4413      	add	r3, r2
 8014754:	b29a      	uxth	r2, r3
 8014756:	7dfb      	ldrb	r3, [r7, #23]
 8014758:	b29b      	uxth	r3, r3
 801475a:	1ad3      	subs	r3, r2, r3
 801475c:	b29a      	uxth	r2, r3
 801475e:	f997 3019 	ldrsb.w	r3, [r7, #25]
 8014762:	b29b      	uxth	r3, r3
 8014764:	1ad3      	subs	r3, r2, r3
 8014766:	b29b      	uxth	r3, r3
 8014768:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    const uint8_t * bpp_opa_table;
    uint8_t bitmask_init;
    uint8_t bitmask;

    switch(g.bpp) {
 801476c:	7ebb      	ldrb	r3, [r7, #26]
 801476e:	3b01      	subs	r3, #1
 8014770:	2b07      	cmp	r3, #7
 8014772:	f200 823f 	bhi.w	8014bf4 <lv_draw_letter+0x54c>
 8014776:	a201      	add	r2, pc, #4	; (adr r2, 801477c <lv_draw_letter+0xd4>)
 8014778:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801477c:	0801479d 	.word	0x0801479d
 8014780:	080147ab 	.word	0x080147ab
 8014784:	08014bf5 	.word	0x08014bf5
 8014788:	080147b9 	.word	0x080147b9
 801478c:	08014bf5 	.word	0x08014bf5
 8014790:	08014bf5 	.word	0x08014bf5
 8014794:	08014bf5 	.word	0x08014bf5
 8014798:	080147c7 	.word	0x080147c7
        case 1:
            bpp_opa_table = bpp1_opa_table;
 801479c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80147a0:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0x80;
 80147a2:	2380      	movs	r3, #128	; 0x80
 80147a4:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;
 80147a8:	e013      	b.n	80147d2 <lv_draw_letter+0x12a>
        case 2:
            bpp_opa_table = bpp2_opa_table;
 80147aa:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80147ae:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0xC0;
 80147b0:	23c0      	movs	r3, #192	; 0xc0
 80147b2:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;
 80147b6:	e00c      	b.n	80147d2 <lv_draw_letter+0x12a>
        case 4:
            bpp_opa_table = bpp4_opa_table;
 80147b8:	f107 031c 	add.w	r3, r7, #28
 80147bc:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0xF0;
 80147be:	23f0      	movs	r3, #240	; 0xf0
 80147c0:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;
 80147c4:	e005      	b.n	80147d2 <lv_draw_letter+0x12a>
        case 8:
            bpp_opa_table = NULL;
 80147c6:	2300      	movs	r3, #0
 80147c8:	66fb      	str	r3, [r7, #108]	; 0x6c
            bitmask_init  = 0xFF;
 80147ca:	23ff      	movs	r3, #255	; 0xff
 80147cc:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            break;       /*No opa table, pixel value will be used directly*/
 80147d0:	bf00      	nop
        default: return; /*Invalid bpp. Can't render the letter*/
    }

    const uint8_t * map_p = lv_font_get_glyph_bitmap(font_p, letter);
 80147d2:	6839      	ldr	r1, [r7, #0]
 80147d4:	6878      	ldr	r0, [r7, #4]
 80147d6:	f006 f86d 	bl	801a8b4 <lv_font_get_glyph_bitmap>
 80147da:	6678      	str	r0, [r7, #100]	; 0x64

    if(map_p == NULL) return;
 80147dc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80147de:	2b00      	cmp	r3, #0
 80147e0:	f000 820a 	beq.w	8014bf8 <lv_draw_letter+0x550>

    /*If the letter is completely out of mask don't draw it */
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
 80147e4:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80147e8:	7dba      	ldrb	r2, [r7, #22]
 80147ea:	4413      	add	r3, r2
 80147ec:	68ba      	ldr	r2, [r7, #8]
 80147ee:	f9b2 2000 	ldrsh.w	r2, [r2]
 80147f2:	4293      	cmp	r3, r2
 80147f4:	f2c0 8202 	blt.w	8014bfc <lv_draw_letter+0x554>
 80147f8:	68bb      	ldr	r3, [r7, #8]
 80147fa:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80147fe:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8014802:	429a      	cmp	r2, r3
 8014804:	f300 81fa 	bgt.w	8014bfc <lv_draw_letter+0x554>
 8014808:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801480c:	7dfa      	ldrb	r2, [r7, #23]
 801480e:	4413      	add	r3, r2
 8014810:	68ba      	ldr	r2, [r7, #8]
 8014812:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8014816:	4293      	cmp	r3, r2
 8014818:	f2c0 81f0 	blt.w	8014bfc <lv_draw_letter+0x554>
 801481c:	68bb      	ldr	r3, [r7, #8]
 801481e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014822:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 8014826:	429a      	cmp	r2, r3
 8014828:	f300 81e8 	bgt.w	8014bfc <lv_draw_letter+0x554>

    lv_disp_t * disp    = lv_refr_get_disp_refreshing();
 801482c:	f7fe f938 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8014830:	64f8      	str	r0, [r7, #76]	; 0x4c
    lv_disp_buf_t * vdb = lv_disp_get_buf(disp);
 8014832:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8014834:	f006 fcde 	bl	801b1f4 <lv_disp_get_buf>
 8014838:	64b8      	str	r0, [r7, #72]	; 0x48

    lv_coord_t vdb_width     = lv_area_get_width(&vdb->area);
 801483a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801483c:	3310      	adds	r3, #16
 801483e:	4618      	mov	r0, r3
 8014840:	f7ff fd1d 	bl	801427e <lv_area_get_width>
 8014844:	4603      	mov	r3, r0
 8014846:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
    lv_color_t * vdb_buf_tmp = vdb->buf_act;
 801484a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801484c:	689b      	ldr	r3, [r3, #8]
 801484e:	663b      	str	r3, [r7, #96]	; 0x60
    lv_coord_t col, row;

    uint8_t width_byte_scr = g.box_w >> 3; /*Width in bytes (on the screen finally) (e.g. w = 11 -> 2 bytes wide)*/
 8014850:	7dbb      	ldrb	r3, [r7, #22]
 8014852:	08db      	lsrs	r3, r3, #3
 8014854:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
    if(g.box_w & 0x7) width_byte_scr++;
 8014858:	7dbb      	ldrb	r3, [r7, #22]
 801485a:	f003 0307 	and.w	r3, r3, #7
 801485e:	2b00      	cmp	r3, #0
 8014860:	d004      	beq.n	801486c <lv_draw_letter+0x1c4>
 8014862:	f897 3045 	ldrb.w	r3, [r7, #69]	; 0x45
 8014866:	3301      	adds	r3, #1
 8014868:	f887 3045 	strb.w	r3, [r7, #69]	; 0x45
    uint16_t width_bit = g.box_w * g.bpp; /*Letter width in bits*/
 801486c:	7dbb      	ldrb	r3, [r7, #22]
 801486e:	b29a      	uxth	r2, r3
 8014870:	7ebb      	ldrb	r3, [r7, #26]
 8014872:	b29b      	uxth	r3, r3
 8014874:	fb12 f303 	smulbb	r3, r2, r3
 8014878:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    /* Calculate the col/row start/end on the map*/
    lv_coord_t col_start = pos_x >= mask_p->x1 ? 0 : mask_p->x1 - pos_x;
 801487c:	68bb      	ldr	r3, [r7, #8]
 801487e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014882:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8014886:	429a      	cmp	r2, r3
 8014888:	da09      	bge.n	801489e <lv_draw_letter+0x1f6>
 801488a:	68bb      	ldr	r3, [r7, #8]
 801488c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014890:	b29a      	uxth	r2, r3
 8014892:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8014896:	1ad3      	subs	r3, r2, r3
 8014898:	b29b      	uxth	r3, r3
 801489a:	b21b      	sxth	r3, r3
 801489c:	e000      	b.n	80148a0 <lv_draw_letter+0x1f8>
 801489e:	2300      	movs	r3, #0
 80148a0:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    lv_coord_t col_end   = pos_x + g.box_w <= mask_p->x2 ? g.box_w : mask_p->x2 - pos_x + 1;
 80148a4:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80148a8:	7dba      	ldrb	r2, [r7, #22]
 80148aa:	4413      	add	r3, r2
 80148ac:	68ba      	ldr	r2, [r7, #8]
 80148ae:	f9b2 2004 	ldrsh.w	r2, [r2, #4]
 80148b2:	4293      	cmp	r3, r2
 80148b4:	dc02      	bgt.n	80148bc <lv_draw_letter+0x214>
 80148b6:	7dbb      	ldrb	r3, [r7, #22]
 80148b8:	b21b      	sxth	r3, r3
 80148ba:	e00a      	b.n	80148d2 <lv_draw_letter+0x22a>
 80148bc:	68bb      	ldr	r3, [r7, #8]
 80148be:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80148c2:	b29a      	uxth	r2, r3
 80148c4:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80148c8:	1ad3      	subs	r3, r2, r3
 80148ca:	b29b      	uxth	r3, r3
 80148cc:	3301      	adds	r3, #1
 80148ce:	b29b      	uxth	r3, r3
 80148d0:	b21b      	sxth	r3, r3
 80148d2:	87fb      	strh	r3, [r7, #62]	; 0x3e
    lv_coord_t row_start = pos_y >= mask_p->y1 ? 0 : mask_p->y1 - pos_y;
 80148d4:	68bb      	ldr	r3, [r7, #8]
 80148d6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80148da:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 80148de:	429a      	cmp	r2, r3
 80148e0:	da09      	bge.n	80148f6 <lv_draw_letter+0x24e>
 80148e2:	68bb      	ldr	r3, [r7, #8]
 80148e4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80148e8:	b29a      	uxth	r2, r3
 80148ea:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 80148ee:	1ad3      	subs	r3, r2, r3
 80148f0:	b29b      	uxth	r3, r3
 80148f2:	b21b      	sxth	r3, r3
 80148f4:	e000      	b.n	80148f8 <lv_draw_letter+0x250>
 80148f6:	2300      	movs	r3, #0
 80148f8:	87bb      	strh	r3, [r7, #60]	; 0x3c
    lv_coord_t row_end   = pos_y + g.box_h <= mask_p->y2 ? g.box_h : mask_p->y2 - pos_y + 1;
 80148fa:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80148fe:	7dfa      	ldrb	r2, [r7, #23]
 8014900:	4413      	add	r3, r2
 8014902:	68ba      	ldr	r2, [r7, #8]
 8014904:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 8014908:	4293      	cmp	r3, r2
 801490a:	dc02      	bgt.n	8014912 <lv_draw_letter+0x26a>
 801490c:	7dfb      	ldrb	r3, [r7, #23]
 801490e:	b21b      	sxth	r3, r3
 8014910:	e00a      	b.n	8014928 <lv_draw_letter+0x280>
 8014912:	68bb      	ldr	r3, [r7, #8]
 8014914:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014918:	b29a      	uxth	r2, r3
 801491a:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 801491e:	1ad3      	subs	r3, r2, r3
 8014920:	b29b      	uxth	r3, r3
 8014922:	3301      	adds	r3, #1
 8014924:	b29b      	uxth	r3, r3
 8014926:	b21b      	sxth	r3, r3
 8014928:	877b      	strh	r3, [r7, #58]	; 0x3a

    /*Set a pointer on VDB to the first pixel of the letter*/
    vdb_buf_tmp += ((pos_y - vdb->area.y1) * vdb_width) + pos_x - vdb->area.x1;
 801492a:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801492e:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8014930:	f9b2 2012 	ldrsh.w	r2, [r2, #18]
 8014934:	1a9b      	subs	r3, r3, r2
 8014936:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 801493a:	fb02 f203 	mul.w	r2, r2, r3
 801493e:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8014942:	4413      	add	r3, r2
 8014944:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8014946:	f9b2 2010 	ldrsh.w	r2, [r2, #16]
 801494a:	1a9b      	subs	r3, r3, r2
 801494c:	005b      	lsls	r3, r3, #1
 801494e:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8014950:	4413      	add	r3, r2
 8014952:	663b      	str	r3, [r7, #96]	; 0x60

    /*If the letter is partially out of mask the move there on VDB*/
    vdb_buf_tmp += (row_start * vdb_width) + col_start;
 8014954:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8014958:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 801495c:	fb02 f203 	mul.w	r2, r2, r3
 8014960:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8014964:	4413      	add	r3, r2
 8014966:	005b      	lsls	r3, r3, #1
 8014968:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 801496a:	4413      	add	r3, r2
 801496c:	663b      	str	r3, [r7, #96]	; 0x60

    /*Move on the map too*/
    uint32_t bit_ofs = (row_start * width_bit) + (col_start * g.bpp);
 801496e:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8014972:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 8014976:	fb02 f203 	mul.w	r2, r2, r3
 801497a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801497e:	7eb9      	ldrb	r1, [r7, #26]
 8014980:	fb01 f303 	mul.w	r3, r1, r3
 8014984:	4413      	add	r3, r2
 8014986:	637b      	str	r3, [r7, #52]	; 0x34
    map_p += bit_ofs >> 3;
 8014988:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801498a:	08db      	lsrs	r3, r3, #3
 801498c:	6e7a      	ldr	r2, [r7, #100]	; 0x64
 801498e:	4413      	add	r3, r2
 8014990:	667b      	str	r3, [r7, #100]	; 0x64

    uint8_t letter_px;
    lv_opa_t px_opa;
    uint16_t col_bit;
    col_bit = bit_ofs & 0x7; /* "& 0x7" equals to "% 8" just faster */
 8014992:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8014994:	b29b      	uxth	r3, r3
 8014996:	f003 0307 	and.w	r3, r3, #7
 801499a:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

    bool scr_transp = false;
 801499e:	2300      	movs	r3, #0
 80149a0:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
#if LV_COLOR_SCREEN_TRANSP
    scr_transp = disp->driver.screen_transp;
#endif

    for(row = row_start; row < row_end; row++) {
 80149a4:	8fbb      	ldrh	r3, [r7, #60]	; 0x3c
 80149a6:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80149aa:	e117      	b.n	8014bdc <lv_draw_letter+0x534>
 80149ac:	0802898c 	.word	0x0802898c
 80149b0:	08028990 	.word	0x08028990
 80149b4:	08028944 	.word	0x08028944
 80149b8:	08028968 	.word	0x08028968
        bitmask = bitmask_init >> col_bit;
 80149bc:	f897 206b 	ldrb.w	r2, [r7, #107]	; 0x6b
 80149c0:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 80149c4:	fa42 f303 	asr.w	r3, r2, r3
 80149c8:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
        for(col = col_start; col < col_end; col++) {
 80149cc:	f8b7 3040 	ldrh.w	r3, [r7, #64]	; 0x40
 80149d0:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80149d4:	e0c7      	b.n	8014b66 <lv_draw_letter+0x4be>
            letter_px = (*map_p & bitmask) >> (8 - col_bit - g.bpp);
 80149d6:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 80149d8:	781a      	ldrb	r2, [r3, #0]
 80149da:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 80149de:	4013      	ands	r3, r2
 80149e0:	b2db      	uxtb	r3, r3
 80149e2:	461a      	mov	r2, r3
 80149e4:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 80149e8:	f1c3 0308 	rsb	r3, r3, #8
 80149ec:	7eb9      	ldrb	r1, [r7, #26]
 80149ee:	1a5b      	subs	r3, r3, r1
 80149f0:	fa42 f303 	asr.w	r3, r2, r3
 80149f4:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
            if(letter_px != 0) {
 80149f8:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 80149fc:	2b00      	cmp	r3, #0
 80149fe:	f000 8089 	beq.w	8014b14 <lv_draw_letter+0x46c>
                if(opa == LV_OPA_COVER) {
 8014a02:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8014a06:	2bff      	cmp	r3, #255	; 0xff
 8014a08:	d10d      	bne.n	8014a26 <lv_draw_letter+0x37e>
                    px_opa = g.bpp == 8 ? letter_px : bpp_opa_table[letter_px];
 8014a0a:	7ebb      	ldrb	r3, [r7, #26]
 8014a0c:	2b08      	cmp	r3, #8
 8014a0e:	d005      	beq.n	8014a1c <lv_draw_letter+0x374>
 8014a10:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8014a14:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8014a16:	4413      	add	r3, r2
 8014a18:	781b      	ldrb	r3, [r3, #0]
 8014a1a:	e001      	b.n	8014a20 <lv_draw_letter+0x378>
 8014a1c:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8014a20:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
 8014a24:	e020      	b.n	8014a68 <lv_draw_letter+0x3c0>
                } else {
                    px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 8014a26:	7ebb      	ldrb	r3, [r7, #26]
 8014a28:	2b08      	cmp	r3, #8
 8014a2a:	d10c      	bne.n	8014a46 <lv_draw_letter+0x39e>
 8014a2c:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8014a30:	b29a      	uxth	r2, r3
 8014a32:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8014a36:	b29b      	uxth	r3, r3
 8014a38:	fb12 f303 	smulbb	r3, r2, r3
 8014a3c:	b29b      	uxth	r3, r3
 8014a3e:	0a1b      	lsrs	r3, r3, #8
 8014a40:	b29b      	uxth	r3, r3
 8014a42:	b2db      	uxtb	r3, r3
 8014a44:	e00e      	b.n	8014a64 <lv_draw_letter+0x3bc>
                                        : (uint16_t)((uint16_t)bpp_opa_table[letter_px] * opa) >> 8;
 8014a46:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8014a4a:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8014a4c:	4413      	add	r3, r2
 8014a4e:	781b      	ldrb	r3, [r3, #0]
 8014a50:	b29a      	uxth	r2, r3
 8014a52:	f897 308c 	ldrb.w	r3, [r7, #140]	; 0x8c
 8014a56:	b29b      	uxth	r3, r3
 8014a58:	fb12 f303 	smulbb	r3, r2, r3
 8014a5c:	b29b      	uxth	r3, r3
                    px_opa = g.bpp == 8 ? (uint16_t)((uint16_t)letter_px * opa) >> 8
 8014a5e:	0a1b      	lsrs	r3, r3, #8
 8014a60:	b29b      	uxth	r3, r3
 8014a62:	b2db      	uxtb	r3, r3
 8014a64:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
                }

                if(disp->driver.set_px_cb) {
 8014a68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8014a6a:	695b      	ldr	r3, [r3, #20]
 8014a6c:	2b00      	cmp	r3, #0
 8014a6e:	d02c      	beq.n	8014aca <lv_draw_letter+0x422>
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8014a70:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8014a72:	695c      	ldr	r4, [r3, #20]
 8014a74:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8014a76:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014a78:	6899      	ldr	r1, [r3, #8]
                                           (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
 8014a7a:	f8b7 205e 	ldrh.w	r2, [r7, #94]	; 0x5e
 8014a7e:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8014a82:	4413      	add	r3, r2
 8014a84:	b29a      	uxth	r2, r3
 8014a86:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014a88:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8014a8c:	b29b      	uxth	r3, r3
 8014a8e:	1ad3      	subs	r3, r2, r3
 8014a90:	b29b      	uxth	r3, r3
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8014a92:	b21e      	sxth	r6, r3
                                           (col + pos_x) - vdb->area.x1, (row + pos_y) - vdb->area.y1, color, px_opa);
 8014a94:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8014a98:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8014a9c:	4413      	add	r3, r2
 8014a9e:	b29a      	uxth	r2, r3
 8014aa0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8014aa2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8014aa6:	b29b      	uxth	r3, r3
 8014aa8:	1ad3      	subs	r3, r2, r3
 8014aaa:	b29b      	uxth	r3, r3
                    disp->driver.set_px_cb(&disp->driver, (uint8_t *)vdb->buf_act, vdb_width,
 8014aac:	b21b      	sxth	r3, r3
 8014aae:	f9b7 5046 	ldrsh.w	r5, [r7, #70]	; 0x46
 8014ab2:	f897 205b 	ldrb.w	r2, [r7, #91]	; 0x5b
 8014ab6:	9202      	str	r2, [sp, #8]
 8014ab8:	f8b7 2088 	ldrh.w	r2, [r7, #136]	; 0x88
 8014abc:	f8ad 2004 	strh.w	r2, [sp, #4]
 8014ac0:	9300      	str	r3, [sp, #0]
 8014ac2:	4633      	mov	r3, r6
 8014ac4:	462a      	mov	r2, r5
 8014ac6:	47a0      	blx	r4
 8014ac8:	e024      	b.n	8014b14 <lv_draw_letter+0x46c>
                } else if(vdb_buf_tmp->full != color.full) {
 8014aca:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014acc:	881a      	ldrh	r2, [r3, #0]
 8014ace:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
 8014ad2:	429a      	cmp	r2, r3
 8014ad4:	d01e      	beq.n	8014b14 <lv_draw_letter+0x46c>
                    if(px_opa > LV_OPA_MAX)
 8014ad6:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8014ada:	2bfb      	cmp	r3, #251	; 0xfb
 8014adc:	d904      	bls.n	8014ae8 <lv_draw_letter+0x440>
                        *vdb_buf_tmp = color;
 8014ade:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014ae0:	f8b7 2088 	ldrh.w	r2, [r7, #136]	; 0x88
 8014ae4:	801a      	strh	r2, [r3, #0]
 8014ae6:	e015      	b.n	8014b14 <lv_draw_letter+0x46c>
                    else if(px_opa > LV_OPA_MIN) {
 8014ae8:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8014aec:	2b10      	cmp	r3, #16
 8014aee:	d911      	bls.n	8014b14 <lv_draw_letter+0x46c>
                        if(scr_transp == false) {
 8014af0:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8014af4:	f083 0301 	eor.w	r3, r3, #1
 8014af8:	b2db      	uxtb	r3, r3
 8014afa:	2b00      	cmp	r3, #0
 8014afc:	d00a      	beq.n	8014b14 <lv_draw_letter+0x46c>
                            *vdb_buf_tmp = lv_color_mix(color, *vdb_buf_tmp, px_opa);
 8014afe:	f897 205b 	ldrb.w	r2, [r7, #91]	; 0x5b
 8014b02:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014b04:	8819      	ldrh	r1, [r3, #0]
 8014b06:	f8b7 0088 	ldrh.w	r0, [r7, #136]	; 0x88
 8014b0a:	f7ff fb47 	bl	801419c <lv_color_mix>
 8014b0e:	4602      	mov	r2, r0
 8014b10:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014b12:	801a      	strh	r2, [r3, #0]
                        }
                    }
                }
            }

            vdb_buf_tmp++;
 8014b14:	6e3b      	ldr	r3, [r7, #96]	; 0x60
 8014b16:	3302      	adds	r3, #2
 8014b18:	663b      	str	r3, [r7, #96]	; 0x60

            if(col_bit < 8 - g.bpp) {
 8014b1a:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
 8014b1e:	7ebb      	ldrb	r3, [r7, #26]
 8014b20:	f1c3 0308 	rsb	r3, r3, #8
 8014b24:	429a      	cmp	r2, r3
 8014b26:	da0d      	bge.n	8014b44 <lv_draw_letter+0x49c>
                col_bit += g.bpp;
 8014b28:	7ebb      	ldrb	r3, [r7, #26]
 8014b2a:	b29a      	uxth	r2, r3
 8014b2c:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8014b30:	4413      	add	r3, r2
 8014b32:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
                bitmask = bitmask >> g.bpp;
 8014b36:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8014b3a:	7eba      	ldrb	r2, [r7, #26]
 8014b3c:	4113      	asrs	r3, r2
 8014b3e:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
 8014b42:	e009      	b.n	8014b58 <lv_draw_letter+0x4b0>
            } else {
                col_bit = 0;
 8014b44:	2300      	movs	r3, #0
 8014b46:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
                bitmask = bitmask_init;
 8014b4a:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8014b4e:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
                map_p++;
 8014b52:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8014b54:	3301      	adds	r3, #1
 8014b56:	667b      	str	r3, [r7, #100]	; 0x64
        for(col = col_start; col < col_end; col++) {
 8014b58:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8014b5c:	b29b      	uxth	r3, r3
 8014b5e:	3301      	adds	r3, #1
 8014b60:	b29b      	uxth	r3, r3
 8014b62:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8014b66:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 8014b6a:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8014b6e:	429a      	cmp	r2, r3
 8014b70:	f6ff af31 	blt.w	80149d6 <lv_draw_letter+0x32e>
            }
        }
        col_bit += ((g.box_w - col_end) + col_start) * g.bpp;
 8014b74:	7dbb      	ldrb	r3, [r7, #22]
 8014b76:	461a      	mov	r2, r3
 8014b78:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8014b7c:	1ad2      	subs	r2, r2, r3
 8014b7e:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8014b82:	4413      	add	r3, r2
 8014b84:	b29a      	uxth	r2, r3
 8014b86:	7ebb      	ldrb	r3, [r7, #26]
 8014b88:	b29b      	uxth	r3, r3
 8014b8a:	fb12 f303 	smulbb	r3, r2, r3
 8014b8e:	b29a      	uxth	r2, r3
 8014b90:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8014b94:	4413      	add	r3, r2
 8014b96:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

        map_p += (col_bit >> 3);
 8014b9a:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8014b9e:	08db      	lsrs	r3, r3, #3
 8014ba0:	b29b      	uxth	r3, r3
 8014ba2:	461a      	mov	r2, r3
 8014ba4:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 8014ba6:	4413      	add	r3, r2
 8014ba8:	667b      	str	r3, [r7, #100]	; 0x64
        col_bit = col_bit & 0x7;
 8014baa:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 8014bae:	f003 0307 	and.w	r3, r3, #7
 8014bb2:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
        vdb_buf_tmp += vdb_width - (col_end - col_start); /*Next row in VDB*/
 8014bb6:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 8014bba:	f9b7 103e 	ldrsh.w	r1, [r7, #62]	; 0x3e
 8014bbe:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8014bc2:	1acb      	subs	r3, r1, r3
 8014bc4:	1ad3      	subs	r3, r2, r3
 8014bc6:	005b      	lsls	r3, r3, #1
 8014bc8:	6e3a      	ldr	r2, [r7, #96]	; 0x60
 8014bca:	4413      	add	r3, r2
 8014bcc:	663b      	str	r3, [r7, #96]	; 0x60
    for(row = row_start; row < row_end; row++) {
 8014bce:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8014bd2:	b29b      	uxth	r3, r3
 8014bd4:	3301      	adds	r3, #1
 8014bd6:	b29b      	uxth	r3, r3
 8014bd8:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8014bdc:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 8014be0:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8014be4:	429a      	cmp	r2, r3
 8014be6:	f6ff aee9 	blt.w	80149bc <lv_draw_letter+0x314>
 8014bea:	e008      	b.n	8014bfe <lv_draw_letter+0x556>
    if(opa < LV_OPA_MIN) return;
 8014bec:	bf00      	nop
 8014bee:	e006      	b.n	8014bfe <lv_draw_letter+0x556>
    if(g_ret == false) return;
 8014bf0:	bf00      	nop
 8014bf2:	e004      	b.n	8014bfe <lv_draw_letter+0x556>
        default: return; /*Invalid bpp. Can't render the letter*/
 8014bf4:	bf00      	nop
 8014bf6:	e002      	b.n	8014bfe <lv_draw_letter+0x556>
    if(map_p == NULL) return;
 8014bf8:	bf00      	nop
 8014bfa:	e000      	b.n	8014bfe <lv_draw_letter+0x556>
    if(pos_x + g.box_w < mask_p->x1 || pos_x > mask_p->x2 || pos_y + g.box_h < mask_p->y1 || pos_y > mask_p->y2) return;
 8014bfc:	bf00      	nop
    }
}
 8014bfe:	3774      	adds	r7, #116	; 0x74
 8014c00:	46bd      	mov	sp, r7
 8014c02:	bdf0      	pop	{r4, r5, r6, r7, pc}

08014c04 <sw_color_fill>:
 * @param color fill color
 * @param opa opacity (0, LV_OPA_TRANSP: transparent ... 255, LV_OPA_COVER, fully cover)
 */
static void sw_color_fill(lv_color_t * mem, lv_coord_t mem_width, const lv_area_t * fill_area, lv_color_t color,
                          lv_opa_t opa)
{
 8014c04:	b590      	push	{r4, r7, lr}
 8014c06:	b08f      	sub	sp, #60	; 0x3c
 8014c08:	af04      	add	r7, sp, #16
 8014c0a:	60f8      	str	r0, [r7, #12]
 8014c0c:	607a      	str	r2, [r7, #4]
 8014c0e:	813b      	strh	r3, [r7, #8]
 8014c10:	460b      	mov	r3, r1
 8014c12:	817b      	strh	r3, [r7, #10]
    /*Set all row in vdb to the given color*/
    lv_coord_t row;
    lv_coord_t col;

    lv_disp_t * disp = lv_refr_get_disp_refreshing();
 8014c14:	f7fd ff44 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8014c18:	6238      	str	r0, [r7, #32]
    if(disp->driver.set_px_cb) {
 8014c1a:	6a3b      	ldr	r3, [r7, #32]
 8014c1c:	695b      	ldr	r3, [r3, #20]
 8014c1e:	2b00      	cmp	r3, #0
 8014c20:	d035      	beq.n	8014c8e <sw_color_fill+0x8a>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8014c22:	687b      	ldr	r3, [r7, #4]
 8014c24:	881b      	ldrh	r3, [r3, #0]
 8014c26:	84bb      	strh	r3, [r7, #36]	; 0x24
 8014c28:	e029      	b.n	8014c7e <sw_color_fill+0x7a>
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8014c2a:	687b      	ldr	r3, [r7, #4]
 8014c2c:	885b      	ldrh	r3, [r3, #2]
 8014c2e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014c30:	e018      	b.n	8014c64 <sw_color_fill+0x60>
                disp->driver.set_px_cb(&disp->driver, (uint8_t *)mem, mem_width, col, row, color, opa);
 8014c32:	6a3b      	ldr	r3, [r7, #32]
 8014c34:	695c      	ldr	r4, [r3, #20]
 8014c36:	6a38      	ldr	r0, [r7, #32]
 8014c38:	f9b7 1024 	ldrsh.w	r1, [r7, #36]	; 0x24
 8014c3c:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 8014c40:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8014c44:	9302      	str	r3, [sp, #8]
 8014c46:	893b      	ldrh	r3, [r7, #8]
 8014c48:	f8ad 3004 	strh.w	r3, [sp, #4]
 8014c4c:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014c50:	9300      	str	r3, [sp, #0]
 8014c52:	460b      	mov	r3, r1
 8014c54:	68f9      	ldr	r1, [r7, #12]
 8014c56:	47a0      	blx	r4
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8014c58:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014c5c:	b29b      	uxth	r3, r3
 8014c5e:	3301      	adds	r3, #1
 8014c60:	b29b      	uxth	r3, r3
 8014c62:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014c64:	687b      	ldr	r3, [r7, #4]
 8014c66:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014c6a:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8014c6e:	429a      	cmp	r2, r3
 8014c70:	dddf      	ble.n	8014c32 <sw_color_fill+0x2e>
        for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8014c72:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014c76:	b29b      	uxth	r3, r3
 8014c78:	3301      	adds	r3, #1
 8014c7a:	b29b      	uxth	r3, r3
 8014c7c:	84bb      	strh	r3, [r7, #36]	; 0x24
 8014c7e:	687b      	ldr	r3, [r7, #4]
 8014c80:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014c84:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8014c88:	429a      	cmp	r2, r3
 8014c8a:	ddce      	ble.n	8014c2a <sw_color_fill+0x26>
                }
                mem += mem_width;
            }
        }
    }
}
 8014c8c:	e0ce      	b.n	8014e2c <sw_color_fill+0x228>
        mem += fill_area->y1 * mem_width; /*Go to the first row*/
 8014c8e:	687b      	ldr	r3, [r7, #4]
 8014c90:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014c94:	461a      	mov	r2, r3
 8014c96:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8014c9a:	fb03 f302 	mul.w	r3, r3, r2
 8014c9e:	005b      	lsls	r3, r3, #1
 8014ca0:	68fa      	ldr	r2, [r7, #12]
 8014ca2:	4413      	add	r3, r2
 8014ca4:	60fb      	str	r3, [r7, #12]
        if(opa == LV_OPA_COVER) {
 8014ca6:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8014caa:	2bff      	cmp	r3, #255	; 0xff
 8014cac:	d159      	bne.n	8014d62 <sw_color_fill+0x15e>
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8014cae:	687b      	ldr	r3, [r7, #4]
 8014cb0:	881b      	ldrh	r3, [r3, #0]
 8014cb2:	84bb      	strh	r3, [r7, #36]	; 0x24
 8014cb4:	e00c      	b.n	8014cd0 <sw_color_fill+0xcc>
                mem[col] = color;
 8014cb6:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014cba:	005b      	lsls	r3, r3, #1
 8014cbc:	68fa      	ldr	r2, [r7, #12]
 8014cbe:	4413      	add	r3, r2
 8014cc0:	893a      	ldrh	r2, [r7, #8]
 8014cc2:	801a      	strh	r2, [r3, #0]
            for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8014cc4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014cc8:	b29b      	uxth	r3, r3
 8014cca:	3301      	adds	r3, #1
 8014ccc:	b29b      	uxth	r3, r3
 8014cce:	84bb      	strh	r3, [r7, #36]	; 0x24
 8014cd0:	687b      	ldr	r3, [r7, #4]
 8014cd2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014cd6:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8014cda:	429a      	cmp	r2, r3
 8014cdc:	ddeb      	ble.n	8014cb6 <sw_color_fill+0xb2>
            lv_color_t * mem_first = &mem[fill_area->x1];
 8014cde:	687b      	ldr	r3, [r7, #4]
 8014ce0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014ce4:	005b      	lsls	r3, r3, #1
 8014ce6:	68fa      	ldr	r2, [r7, #12]
 8014ce8:	4413      	add	r3, r2
 8014cea:	61bb      	str	r3, [r7, #24]
            lv_coord_t copy_size   = (fill_area->x2 - fill_area->x1 + 1) * sizeof(lv_color_t);
 8014cec:	687b      	ldr	r3, [r7, #4]
 8014cee:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014cf2:	461a      	mov	r2, r3
 8014cf4:	687b      	ldr	r3, [r7, #4]
 8014cf6:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014cfa:	1ad3      	subs	r3, r2, r3
 8014cfc:	3301      	adds	r3, #1
 8014cfe:	b29b      	uxth	r3, r3
 8014d00:	005b      	lsls	r3, r3, #1
 8014d02:	b29b      	uxth	r3, r3
 8014d04:	82fb      	strh	r3, [r7, #22]
            mem += mem_width;
 8014d06:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8014d0a:	005b      	lsls	r3, r3, #1
 8014d0c:	68fa      	ldr	r2, [r7, #12]
 8014d0e:	4413      	add	r3, r2
 8014d10:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
 8014d12:	687b      	ldr	r3, [r7, #4]
 8014d14:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8014d18:	b29b      	uxth	r3, r3
 8014d1a:	3301      	adds	r3, #1
 8014d1c:	b29b      	uxth	r3, r3
 8014d1e:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014d20:	e017      	b.n	8014d52 <sw_color_fill+0x14e>
                memcpy(&mem[fill_area->x1], mem_first, copy_size);
 8014d22:	687b      	ldr	r3, [r7, #4]
 8014d24:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014d28:	005b      	lsls	r3, r3, #1
 8014d2a:	68fa      	ldr	r2, [r7, #12]
 8014d2c:	4413      	add	r3, r2
 8014d2e:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8014d32:	69b9      	ldr	r1, [r7, #24]
 8014d34:	4618      	mov	r0, r3
 8014d36:	f012 fa41 	bl	80271bc <memcpy>
                mem += mem_width;
 8014d3a:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8014d3e:	005b      	lsls	r3, r3, #1
 8014d40:	68fa      	ldr	r2, [r7, #12]
 8014d42:	4413      	add	r3, r2
 8014d44:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1 + 1; row <= fill_area->y2; row++) {
 8014d46:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014d4a:	b29b      	uxth	r3, r3
 8014d4c:	3301      	adds	r3, #1
 8014d4e:	b29b      	uxth	r3, r3
 8014d50:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014d52:	687b      	ldr	r3, [r7, #4]
 8014d54:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014d58:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8014d5c:	429a      	cmp	r2, r3
 8014d5e:	dde0      	ble.n	8014d22 <sw_color_fill+0x11e>
}
 8014d60:	e064      	b.n	8014e2c <sw_color_fill+0x228>
            bool scr_transp = false;
 8014d62:	2300      	movs	r3, #0
 8014d64:	77fb      	strb	r3, [r7, #31]
            lv_color_t bg_tmp  = LV_COLOR_BLACK;
 8014d66:	7d3b      	ldrb	r3, [r7, #20]
 8014d68:	f36f 0304 	bfc	r3, #0, #5
 8014d6c:	753b      	strb	r3, [r7, #20]
 8014d6e:	8abb      	ldrh	r3, [r7, #20]
 8014d70:	f36f 134a 	bfc	r3, #5, #6
 8014d74:	82bb      	strh	r3, [r7, #20]
 8014d76:	7d7b      	ldrb	r3, [r7, #21]
 8014d78:	f36f 03c7 	bfc	r3, #3, #5
 8014d7c:	757b      	strb	r3, [r7, #21]
            lv_color_t opa_tmp = lv_color_mix(color, bg_tmp, opa);
 8014d7e:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8014d82:	461a      	mov	r2, r3
 8014d84:	8ab9      	ldrh	r1, [r7, #20]
 8014d86:	8938      	ldrh	r0, [r7, #8]
 8014d88:	f7ff fa08 	bl	801419c <lv_color_mix>
 8014d8c:	4603      	mov	r3, r0
 8014d8e:	823b      	strh	r3, [r7, #16]
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8014d90:	687b      	ldr	r3, [r7, #4]
 8014d92:	885b      	ldrh	r3, [r3, #2]
 8014d94:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014d96:	e042      	b.n	8014e1e <sw_color_fill+0x21a>
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8014d98:	687b      	ldr	r3, [r7, #4]
 8014d9a:	881b      	ldrh	r3, [r3, #0]
 8014d9c:	84bb      	strh	r3, [r7, #36]	; 0x24
 8014d9e:	e02b      	b.n	8014df8 <sw_color_fill+0x1f4>
                    if(scr_transp == false) {
 8014da0:	7ffb      	ldrb	r3, [r7, #31]
 8014da2:	f083 0301 	eor.w	r3, r3, #1
 8014da6:	b2db      	uxtb	r3, r3
 8014da8:	2b00      	cmp	r3, #0
 8014daa:	d01f      	beq.n	8014dec <sw_color_fill+0x1e8>
                        if(mem[col].full != bg_tmp.full) {
 8014dac:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014db0:	005b      	lsls	r3, r3, #1
 8014db2:	68fa      	ldr	r2, [r7, #12]
 8014db4:	4413      	add	r3, r2
 8014db6:	881a      	ldrh	r2, [r3, #0]
 8014db8:	8abb      	ldrh	r3, [r7, #20]
 8014dba:	429a      	cmp	r2, r3
 8014dbc:	d00f      	beq.n	8014dde <sw_color_fill+0x1da>
                            bg_tmp  = mem[col];
 8014dbe:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014dc2:	005b      	lsls	r3, r3, #1
 8014dc4:	68fa      	ldr	r2, [r7, #12]
 8014dc6:	4413      	add	r3, r2
 8014dc8:	881b      	ldrh	r3, [r3, #0]
 8014dca:	82bb      	strh	r3, [r7, #20]
                            opa_tmp = lv_color_mix(color, bg_tmp, opa);
 8014dcc:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 8014dd0:	461a      	mov	r2, r3
 8014dd2:	8ab9      	ldrh	r1, [r7, #20]
 8014dd4:	8938      	ldrh	r0, [r7, #8]
 8014dd6:	f7ff f9e1 	bl	801419c <lv_color_mix>
 8014dda:	4603      	mov	r3, r0
 8014ddc:	823b      	strh	r3, [r7, #16]
                        mem[col] = opa_tmp;
 8014dde:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014de2:	005b      	lsls	r3, r3, #1
 8014de4:	68fa      	ldr	r2, [r7, #12]
 8014de6:	4413      	add	r3, r2
 8014de8:	8a3a      	ldrh	r2, [r7, #16]
 8014dea:	801a      	strh	r2, [r3, #0]
                for(col = fill_area->x1; col <= fill_area->x2; col++) {
 8014dec:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8014df0:	b29b      	uxth	r3, r3
 8014df2:	3301      	adds	r3, #1
 8014df4:	b29b      	uxth	r3, r3
 8014df6:	84bb      	strh	r3, [r7, #36]	; 0x24
 8014df8:	687b      	ldr	r3, [r7, #4]
 8014dfa:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014dfe:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8014e02:	429a      	cmp	r2, r3
 8014e04:	ddcc      	ble.n	8014da0 <sw_color_fill+0x19c>
                mem += mem_width;
 8014e06:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 8014e0a:	005b      	lsls	r3, r3, #1
 8014e0c:	68fa      	ldr	r2, [r7, #12]
 8014e0e:	4413      	add	r3, r2
 8014e10:	60fb      	str	r3, [r7, #12]
            for(row = fill_area->y1; row <= fill_area->y2; row++) {
 8014e12:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8014e16:	b29b      	uxth	r3, r3
 8014e18:	3301      	adds	r3, #1
 8014e1a:	b29b      	uxth	r3, r3
 8014e1c:	84fb      	strh	r3, [r7, #38]	; 0x26
 8014e1e:	687b      	ldr	r3, [r7, #4]
 8014e20:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8014e24:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8014e28:	429a      	cmp	r2, r3
 8014e2a:	ddb5      	ble.n	8014d98 <sw_color_fill+0x194>
}
 8014e2c:	bf00      	nop
 8014e2e:	372c      	adds	r7, #44	; 0x2c
 8014e30:	46bd      	mov	sp, r7
 8014e32:	bd90      	pop	{r4, r7, pc}

08014e34 <lv_img_color_format_get_px_size>:
 * Get the pixel size of a color format in bits
 * @param cf a color format (`LV_IMG_CF_...`)
 * @return the pixel size in bits
 */
uint8_t lv_img_color_format_get_px_size(lv_img_cf_t cf)
{
 8014e34:	b480      	push	{r7}
 8014e36:	b085      	sub	sp, #20
 8014e38:	af00      	add	r7, sp, #0
 8014e3a:	4603      	mov	r3, r0
 8014e3c:	71fb      	strb	r3, [r7, #7]
    uint8_t px_size = 0;
 8014e3e:	2300      	movs	r3, #0
 8014e40:	73fb      	strb	r3, [r7, #15]

    switch(cf) {
 8014e42:	79fb      	ldrb	r3, [r7, #7]
 8014e44:	2b0e      	cmp	r3, #14
 8014e46:	d836      	bhi.n	8014eb6 <lv_img_color_format_get_px_size+0x82>
 8014e48:	a201      	add	r2, pc, #4	; (adr r2, 8014e50 <lv_img_color_format_get_px_size+0x1c>)
 8014e4a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8014e4e:	bf00      	nop
 8014e50:	08014e8d 	.word	0x08014e8d
 8014e54:	08014e8d 	.word	0x08014e8d
 8014e58:	08014eb7 	.word	0x08014eb7
 8014e5c:	08014eb7 	.word	0x08014eb7
 8014e60:	08014e93 	.word	0x08014e93
 8014e64:	08014e99 	.word	0x08014e99
 8014e68:	08014e93 	.word	0x08014e93
 8014e6c:	08014e9f 	.word	0x08014e9f
 8014e70:	08014ea5 	.word	0x08014ea5
 8014e74:	08014eab 	.word	0x08014eab
 8014e78:	08014eb1 	.word	0x08014eb1
 8014e7c:	08014e9f 	.word	0x08014e9f
 8014e80:	08014ea5 	.word	0x08014ea5
 8014e84:	08014eab 	.word	0x08014eab
 8014e88:	08014eb1 	.word	0x08014eb1
        case LV_IMG_CF_UNKNOWN:
        case LV_IMG_CF_RAW: px_size = 0; break;
 8014e8c:	2300      	movs	r3, #0
 8014e8e:	73fb      	strb	r3, [r7, #15]
 8014e90:	e014      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR:
        case LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED: px_size = LV_COLOR_SIZE; break;
 8014e92:	2310      	movs	r3, #16
 8014e94:	73fb      	strb	r3, [r7, #15]
 8014e96:	e011      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_TRUE_COLOR_ALPHA: px_size = LV_IMG_PX_SIZE_ALPHA_BYTE << 3; break;
 8014e98:	2318      	movs	r3, #24
 8014e9a:	73fb      	strb	r3, [r7, #15]
 8014e9c:	e00e      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_1BIT:
        case LV_IMG_CF_ALPHA_1BIT: px_size = 1; break;
 8014e9e:	2301      	movs	r3, #1
 8014ea0:	73fb      	strb	r3, [r7, #15]
 8014ea2:	e00b      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_2BIT:
        case LV_IMG_CF_ALPHA_2BIT: px_size = 2; break;
 8014ea4:	2302      	movs	r3, #2
 8014ea6:	73fb      	strb	r3, [r7, #15]
 8014ea8:	e008      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_4BIT:
        case LV_IMG_CF_ALPHA_4BIT: px_size = 4; break;
 8014eaa:	2304      	movs	r3, #4
 8014eac:	73fb      	strb	r3, [r7, #15]
 8014eae:	e005      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        case LV_IMG_CF_INDEXED_8BIT:
        case LV_IMG_CF_ALPHA_8BIT: px_size = 8; break;
 8014eb0:	2308      	movs	r3, #8
 8014eb2:	73fb      	strb	r3, [r7, #15]
 8014eb4:	e002      	b.n	8014ebc <lv_img_color_format_get_px_size+0x88>
        default: px_size = 0; break;
 8014eb6:	2300      	movs	r3, #0
 8014eb8:	73fb      	strb	r3, [r7, #15]
 8014eba:	bf00      	nop
    }

    return px_size;
 8014ebc:	7bfb      	ldrb	r3, [r7, #15]
}
 8014ebe:	4618      	mov	r0, r3
 8014ec0:	3714      	adds	r7, #20
 8014ec2:	46bd      	mov	sp, r7
 8014ec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014ec8:	4770      	bx	lr
 8014eca:	bf00      	nop

08014ecc <lv_img_src_get_type>:
 *  - a path to a file (e.g. "S:/folder/image.bin")
 *  - or a symbol (e.g. LV_SYMBOL_CLOSE)
 * @return type of the image source LV_IMG_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN
 */
lv_img_src_t lv_img_src_get_type(const void * src)
{
 8014ecc:	b580      	push	{r7, lr}
 8014ece:	b084      	sub	sp, #16
 8014ed0:	af00      	add	r7, sp, #0
 8014ed2:	6078      	str	r0, [r7, #4]
    lv_img_src_t img_src_type = LV_IMG_SRC_UNKNOWN;
 8014ed4:	2303      	movs	r3, #3
 8014ed6:	73fb      	strb	r3, [r7, #15]

    if(src == NULL) return img_src_type;
 8014ed8:	687b      	ldr	r3, [r7, #4]
 8014eda:	2b00      	cmp	r3, #0
 8014edc:	d101      	bne.n	8014ee2 <lv_img_src_get_type+0x16>
 8014ede:	7bfb      	ldrb	r3, [r7, #15]
 8014ee0:	e022      	b.n	8014f28 <lv_img_src_get_type+0x5c>
    const uint8_t * u8_p = src;
 8014ee2:	687b      	ldr	r3, [r7, #4]
 8014ee4:	60bb      	str	r3, [r7, #8]

    /*The first byte shows the type of the image source*/
    if(u8_p[0] >= 0x20 && u8_p[0] <= 0x7F) {
 8014ee6:	68bb      	ldr	r3, [r7, #8]
 8014ee8:	781b      	ldrb	r3, [r3, #0]
 8014eea:	2b1f      	cmp	r3, #31
 8014eec:	d907      	bls.n	8014efe <lv_img_src_get_type+0x32>
 8014eee:	68bb      	ldr	r3, [r7, #8]
 8014ef0:	781b      	ldrb	r3, [r3, #0]
 8014ef2:	b25b      	sxtb	r3, r3
 8014ef4:	2b00      	cmp	r3, #0
 8014ef6:	db02      	blt.n	8014efe <lv_img_src_get_type+0x32>
        img_src_type = LV_IMG_SRC_FILE; /*If it's an ASCII character then it's file name*/
 8014ef8:	2301      	movs	r3, #1
 8014efa:	73fb      	strb	r3, [r7, #15]
 8014efc:	e009      	b.n	8014f12 <lv_img_src_get_type+0x46>
    } else if(u8_p[0] >= 0x80) {
 8014efe:	68bb      	ldr	r3, [r7, #8]
 8014f00:	781b      	ldrb	r3, [r3, #0]
 8014f02:	b25b      	sxtb	r3, r3
 8014f04:	2b00      	cmp	r3, #0
 8014f06:	da02      	bge.n	8014f0e <lv_img_src_get_type+0x42>
        img_src_type = LV_IMG_SRC_SYMBOL; /*Symbols begins after 0x7F*/
 8014f08:	2302      	movs	r3, #2
 8014f0a:	73fb      	strb	r3, [r7, #15]
 8014f0c:	e001      	b.n	8014f12 <lv_img_src_get_type+0x46>
    } else {
        img_src_type = LV_IMG_SRC_VARIABLE; /*`lv_img_dsc_t` is design to the first byte < 0x20*/
 8014f0e:	2300      	movs	r3, #0
 8014f10:	73fb      	strb	r3, [r7, #15]
    }

    if(LV_IMG_SRC_UNKNOWN == img_src_type) {
 8014f12:	7bfb      	ldrb	r3, [r7, #15]
 8014f14:	2b03      	cmp	r3, #3
 8014f16:	d106      	bne.n	8014f26 <lv_img_src_get_type+0x5a>
        LV_LOG_WARN("lv_img_src_get_type: unknown image type");
 8014f18:	4b05      	ldr	r3, [pc, #20]	; (8014f30 <lv_img_src_get_type+0x64>)
 8014f1a:	f44f 72d3 	mov.w	r2, #422	; 0x1a6
 8014f1e:	4905      	ldr	r1, [pc, #20]	; (8014f34 <lv_img_src_get_type+0x68>)
 8014f20:	2002      	movs	r0, #2
 8014f22:	f007 fc73 	bl	801c80c <lv_log_add>
    }

    return img_src_type;
 8014f26:	7bfb      	ldrb	r3, [r7, #15]
}
 8014f28:	4618      	mov	r0, r3
 8014f2a:	3710      	adds	r7, #16
 8014f2c:	46bd      	mov	sp, r7
 8014f2e:	bd80      	pop	{r7, pc}
 8014f30:	08028af4 	.word	0x08028af4
 8014f34:	080289b8 	.word	0x080289b8

08014f38 <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 8014f38:	b480      	push	{r7}
 8014f3a:	b083      	sub	sp, #12
 8014f3c:	af00      	add	r7, sp, #0
 8014f3e:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 8014f40:	687b      	ldr	r3, [r7, #4]
 8014f42:	7a1b      	ldrb	r3, [r3, #8]
}
 8014f44:	4618      	mov	r0, r3
 8014f46:	370c      	adds	r7, #12
 8014f48:	46bd      	mov	sp, r7
 8014f4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014f4e:	4770      	bx	lr

08014f50 <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 8014f50:	b480      	push	{r7}
 8014f52:	b085      	sub	sp, #20
 8014f54:	af00      	add	r7, sp, #0
 8014f56:	4603      	mov	r3, r0
 8014f58:	71fb      	strb	r3, [r7, #7]
 8014f5a:	460b      	mov	r3, r1
 8014f5c:	71bb      	strb	r3, [r7, #6]
 8014f5e:	4613      	mov	r3, r2
 8014f60:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 8014f62:	797b      	ldrb	r3, [r7, #5]
 8014f64:	08db      	lsrs	r3, r3, #3
 8014f66:	b2db      	uxtb	r3, r3
 8014f68:	f003 031f 	and.w	r3, r3, #31
 8014f6c:	b2da      	uxtb	r2, r3
 8014f6e:	7b3b      	ldrb	r3, [r7, #12]
 8014f70:	f362 0304 	bfi	r3, r2, #0, #5
 8014f74:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 8014f76:	79bb      	ldrb	r3, [r7, #6]
 8014f78:	089b      	lsrs	r3, r3, #2
 8014f7a:	b2db      	uxtb	r3, r3
 8014f7c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8014f80:	b2da      	uxtb	r2, r3
 8014f82:	89bb      	ldrh	r3, [r7, #12]
 8014f84:	f362 134a 	bfi	r3, r2, #5, #6
 8014f88:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 8014f8a:	79fb      	ldrb	r3, [r7, #7]
 8014f8c:	08db      	lsrs	r3, r3, #3
 8014f8e:	b2db      	uxtb	r3, r3
 8014f90:	f003 031f 	and.w	r3, r3, #31
 8014f94:	b2da      	uxtb	r2, r3
 8014f96:	7b7b      	ldrb	r3, [r7, #13]
 8014f98:	f362 03c7 	bfi	r3, r2, #3, #5
 8014f9c:	737b      	strb	r3, [r7, #13]
    return color;
 8014f9e:	89bb      	ldrh	r3, [r7, #12]
}
 8014fa0:	4618      	mov	r0, r3
 8014fa2:	3714      	adds	r7, #20
 8014fa4:	46bd      	mov	sp, r7
 8014fa6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014faa:	4770      	bx	lr

08014fac <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 8014fac:	b480      	push	{r7}
 8014fae:	b083      	sub	sp, #12
 8014fb0:	af00      	add	r7, sp, #0
 8014fb2:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 8014fb4:	687b      	ldr	r3, [r7, #4]
 8014fb6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8014fba:	b29a      	uxth	r2, r3
 8014fbc:	687b      	ldr	r3, [r7, #4]
 8014fbe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8014fc2:	b29b      	uxth	r3, r3
 8014fc4:	1ad3      	subs	r3, r2, r3
 8014fc6:	b29b      	uxth	r3, r3
 8014fc8:	3301      	adds	r3, #1
 8014fca:	b29b      	uxth	r3, r3
 8014fcc:	b21b      	sxth	r3, r3
}
 8014fce:	4618      	mov	r0, r3
 8014fd0:	370c      	adds	r7, #12
 8014fd2:	46bd      	mov	sp, r7
 8014fd4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8014fd8:	4770      	bx	lr
	...

08014fdc <lv_draw_label>:
 * @param sel_end end index of selected area (`LV_LABEL_TXT_SEL_OFF` if none)
 */
void lv_draw_label(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale,
                   const char * txt, lv_txt_flag_t flag, lv_point_t * offset, uint16_t sel_start, uint16_t sel_end,
                   lv_draw_label_hint_t * hint)
{
 8014fdc:	b590      	push	{r4, r7, lr}
 8014fde:	b0b1      	sub	sp, #196	; 0xc4
 8014fe0:	af04      	add	r7, sp, #16
 8014fe2:	60f8      	str	r0, [r7, #12]
 8014fe4:	60b9      	str	r1, [r7, #8]
 8014fe6:	607a      	str	r2, [r7, #4]
 8014fe8:	70fb      	strb	r3, [r7, #3]
    const lv_font_t * font = style->text.font;
 8014fea:	687b      	ldr	r3, [r7, #4]
 8014fec:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8014fee:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    lv_coord_t w;
    if((flag & LV_TXT_FLAG_EXPAND) == 0) {
 8014ff2:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8014ff6:	f003 0302 	and.w	r3, r3, #2
 8014ffa:	2b00      	cmp	r3, #0
 8014ffc:	d106      	bne.n	801500c <lv_draw_label+0x30>
        /*Normally use the label's width as width*/
        w = lv_area_get_width(coords);
 8014ffe:	68f8      	ldr	r0, [r7, #12]
 8015000:	f7ff ffd4 	bl	8014fac <lv_area_get_width>
 8015004:	4603      	mov	r3, r0
 8015006:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
 801500a:	e019      	b.n	8015040 <lv_draw_label+0x64>
    } else {
        /*If EXAPND is enabled then not limit the text's width to the object's width*/
        lv_point_t p;
        lv_txt_get_size(&p, txt, style->text.font, style->text.letter_space, style->text.line_space, LV_COORD_MAX,
 801500c:	687b      	ldr	r3, [r7, #4]
 801500e:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8015010:	687b      	ldr	r3, [r7, #4]
 8015012:	f9b3 4028 	ldrsh.w	r4, [r3, #40]	; 0x28
 8015016:	687b      	ldr	r3, [r7, #4]
 8015018:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 801501c:	f107 0024 	add.w	r0, r7, #36	; 0x24
 8015020:	f897 20c4 	ldrb.w	r2, [r7, #196]	; 0xc4
 8015024:	9202      	str	r2, [sp, #8]
 8015026:	f647 4218 	movw	r2, #31768	; 0x7c18
 801502a:	9201      	str	r2, [sp, #4]
 801502c:	9300      	str	r3, [sp, #0]
 801502e:	4623      	mov	r3, r4
 8015030:	460a      	mov	r2, r1
 8015032:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 8015036:	f008 f885 	bl	801d144 <lv_txt_get_size>
                        flag);
        w = p.x;
 801503a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801503c:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
    }

    lv_coord_t line_height = lv_font_get_line_height(font) + style->text.line_space;
 8015040:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 8015044:	f7ff ff78 	bl	8014f38 <lv_font_get_line_height>
 8015048:	4603      	mov	r3, r0
 801504a:	b29a      	uxth	r2, r3
 801504c:	687b      	ldr	r3, [r7, #4]
 801504e:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8015052:	b29b      	uxth	r3, r3
 8015054:	4413      	add	r3, r2
 8015056:	b29b      	uxth	r3, r3
 8015058:	f8a7 3092 	strh.w	r3, [r7, #146]	; 0x92

    /*Init variables for the first line*/
    lv_coord_t line_width = 0;
 801505c:	2300      	movs	r3, #0
 801505e:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
    lv_point_t pos;
    pos.x = coords->x1;
 8015062:	68fb      	ldr	r3, [r7, #12]
 8015064:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015068:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    pos.y = coords->y1;
 801506c:	68fb      	ldr	r3, [r7, #12]
 801506e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015072:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e

    lv_coord_t x_ofs = 0;
 8015076:	2300      	movs	r3, #0
 8015078:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
    lv_coord_t y_ofs = 0;
 801507c:	2300      	movs	r3, #0
 801507e:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
    if(offset != NULL) {
 8015082:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8015086:	2b00      	cmp	r3, #0
 8015088:	d013      	beq.n	80150b2 <lv_draw_label+0xd6>
        x_ofs = offset->x;
 801508a:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 801508e:	881b      	ldrh	r3, [r3, #0]
 8015090:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
        y_ofs = offset->y;
 8015094:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8015098:	885b      	ldrh	r3, [r3, #2]
 801509a:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
        pos.y += y_ofs;
 801509e:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80150a2:	b29a      	uxth	r2, r3
 80150a4:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 80150a8:	4413      	add	r3, r2
 80150aa:	b29b      	uxth	r3, r3
 80150ac:	b21b      	sxth	r3, r3
 80150ae:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    }

    uint32_t line_start     = 0;
 80150b2:	2300      	movs	r3, #0
 80150b4:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    int32_t last_line_start = -1;
 80150b8:	f04f 33ff 	mov.w	r3, #4294967295
 80150bc:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0

    /*Check the hint to use the cached info*/
    if(hint && y_ofs == 0) {
 80150c0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80150c4:	2b00      	cmp	r3, #0
 80150c6:	d01f      	beq.n	8015108 <lv_draw_label+0x12c>
 80150c8:	f9b7 30aa 	ldrsh.w	r3, [r7, #170]	; 0xaa
 80150cc:	2b00      	cmp	r3, #0
 80150ce:	d11b      	bne.n	8015108 <lv_draw_label+0x12c>
        /*If the label changed too much recalculate the hint.*/
        if(LV_MATH_ABS(hint->coord_y - coords->y1) > LV_LABEL_HINT_UPDATE_TH - 2 * line_height) {
 80150d0:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80150d4:	689b      	ldr	r3, [r3, #8]
 80150d6:	68fa      	ldr	r2, [r7, #12]
 80150d8:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 80150dc:	1a9b      	subs	r3, r3, r2
 80150de:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 80150e2:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 80150e6:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 80150ea:	f5c3 7300 	rsb	r3, r3, #512	; 0x200
 80150ee:	005b      	lsls	r3, r3, #1
 80150f0:	429a      	cmp	r2, r3
 80150f2:	dd04      	ble.n	80150fe <lv_draw_label+0x122>
            hint->line_start = -1;
 80150f4:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80150f8:	f04f 32ff 	mov.w	r2, #4294967295
 80150fc:	601a      	str	r2, [r3, #0]
        }
        last_line_start = hint->line_start;
 80150fe:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8015102:	681b      	ldr	r3, [r3, #0]
 8015104:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
    }

    /*Use the hint if it's valid*/
    if(hint && last_line_start >= 0) {
 8015108:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801510c:	2b00      	cmp	r3, #0
 801510e:	d013      	beq.n	8015138 <lv_draw_label+0x15c>
 8015110:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8015114:	2b00      	cmp	r3, #0
 8015116:	db0f      	blt.n	8015138 <lv_draw_label+0x15c>
        line_start = last_line_start;
 8015118:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 801511c:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        pos.y += hint->y;
 8015120:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8015124:	b29a      	uxth	r2, r3
 8015126:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 801512a:	685b      	ldr	r3, [r3, #4]
 801512c:	b29b      	uxth	r3, r3
 801512e:	4413      	add	r3, r2
 8015130:	b29b      	uxth	r3, r3
 8015132:	b21b      	sxth	r3, r3
 8015134:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    }

    uint32_t line_end = line_start + lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 8015138:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801513c:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015140:	18d0      	adds	r0, r2, r3
 8015142:	687b      	ldr	r3, [r7, #4]
 8015144:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8015148:	f9b7 10ae 	ldrsh.w	r1, [r7, #174]	; 0xae
 801514c:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8015150:	9300      	str	r3, [sp, #0]
 8015152:	460b      	mov	r3, r1
 8015154:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8015158:	f008 f8a6 	bl	801d2a8 <lv_txt_get_next_line>
 801515c:	4603      	mov	r3, r0
 801515e:	461a      	mov	r2, r3
 8015160:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015164:	4413      	add	r3, r2
 8015166:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

    /*Go the first visible line*/
    while(pos.y + line_height < mask->y1) {
 801516a:	e053      	b.n	8015214 <lv_draw_label+0x238>
        /*Go to next line*/
        line_start = line_end;
 801516c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015170:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 8015174:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8015178:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801517c:	18d0      	adds	r0, r2, r3
 801517e:	687b      	ldr	r3, [r7, #4]
 8015180:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8015184:	f9b7 10ae 	ldrsh.w	r1, [r7, #174]	; 0xae
 8015188:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801518c:	9300      	str	r3, [sp, #0]
 801518e:	460b      	mov	r3, r1
 8015190:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8015194:	f008 f888 	bl	801d2a8 <lv_txt_get_next_line>
 8015198:	4603      	mov	r3, r0
 801519a:	461a      	mov	r2, r3
 801519c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80151a0:	4413      	add	r3, r2
 80151a2:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
        pos.y += line_height;
 80151a6:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80151aa:	b29a      	uxth	r2, r3
 80151ac:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 80151b0:	4413      	add	r3, r2
 80151b2:	b29b      	uxth	r3, r3
 80151b4:	b21b      	sxth	r3, r3
 80151b6:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e

        /*Save at the threshold coordinate*/
        if(hint && pos.y >= -LV_LABEL_HINT_UPDATE_TH && hint->line_start < 0) {
 80151ba:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80151be:	2b00      	cmp	r3, #0
 80151c0:	d01f      	beq.n	8015202 <lv_draw_label+0x226>
 80151c2:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80151c6:	f513 6f80 	cmn.w	r3, #1024	; 0x400
 80151ca:	db1a      	blt.n	8015202 <lv_draw_label+0x226>
 80151cc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80151d0:	681b      	ldr	r3, [r3, #0]
 80151d2:	2b00      	cmp	r3, #0
 80151d4:	da15      	bge.n	8015202 <lv_draw_label+0x226>
            hint->line_start = line_start;
 80151d6:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 80151da:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80151de:	601a      	str	r2, [r3, #0]
            hint->y          = pos.y - coords->y1;
 80151e0:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80151e4:	461a      	mov	r2, r3
 80151e6:	68fb      	ldr	r3, [r7, #12]
 80151e8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80151ec:	1ad2      	subs	r2, r2, r3
 80151ee:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 80151f2:	605a      	str	r2, [r3, #4]
            hint->coord_y    = coords->y1;
 80151f4:	68fb      	ldr	r3, [r7, #12]
 80151f6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80151fa:	461a      	mov	r2, r3
 80151fc:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 8015200:	609a      	str	r2, [r3, #8]
        }

        if(txt[line_start] == '\0') return;
 8015202:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8015206:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801520a:	4413      	add	r3, r2
 801520c:	781b      	ldrb	r3, [r3, #0]
 801520e:	2b00      	cmp	r3, #0
 8015210:	f000 827e 	beq.w	8015710 <lv_draw_label+0x734>
    while(pos.y + line_height < mask->y1) {
 8015214:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8015218:	461a      	mov	r2, r3
 801521a:	f9b7 3092 	ldrsh.w	r3, [r7, #146]	; 0x92
 801521e:	4413      	add	r3, r2
 8015220:	68ba      	ldr	r2, [r7, #8]
 8015222:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8015226:	4293      	cmp	r3, r2
 8015228:	dba0      	blt.n	801516c <lv_draw_label+0x190>
    }

    /*Align to middle*/
    if(flag & LV_TXT_FLAG_CENTER) {
 801522a:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801522e:	f003 0304 	and.w	r3, r3, #4
 8015232:	2b00      	cmp	r3, #0
 8015234:	d031      	beq.n	801529a <lv_draw_label+0x2be>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 8015236:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 801523a:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801523e:	18d0      	adds	r0, r2, r3
 8015240:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015244:	b29a      	uxth	r2, r3
 8015246:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801524a:	b29b      	uxth	r3, r3
 801524c:	1ad3      	subs	r3, r2, r3
 801524e:	b299      	uxth	r1, r3
 8015250:	687b      	ldr	r3, [r7, #4]
 8015252:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8015256:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801525a:	9300      	str	r3, [sp, #0]
 801525c:	4613      	mov	r3, r2
 801525e:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8015262:	f008 f8d3 	bl	801d40c <lv_txt_get_width>
 8015266:	4603      	mov	r3, r0
 8015268:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90

        pos.x += (lv_area_get_width(coords) - line_width) / 2;
 801526c:	68f8      	ldr	r0, [r7, #12]
 801526e:	f7ff fe9d 	bl	8014fac <lv_area_get_width>
 8015272:	4603      	mov	r3, r0
 8015274:	461a      	mov	r2, r3
 8015276:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 801527a:	1ad3      	subs	r3, r2, r3
 801527c:	2b00      	cmp	r3, #0
 801527e:	da00      	bge.n	8015282 <lv_draw_label+0x2a6>
 8015280:	3301      	adds	r3, #1
 8015282:	105b      	asrs	r3, r3, #1
 8015284:	4619      	mov	r1, r3
 8015286:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 801528a:	b29a      	uxth	r2, r3
 801528c:	b28b      	uxth	r3, r1
 801528e:	4413      	add	r3, r2
 8015290:	b29b      	uxth	r3, r3
 8015292:	b21b      	sxth	r3, r3
 8015294:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 8015298:	e031      	b.n	80152fe <lv_draw_label+0x322>

    }
    /*Align to the right*/
    else if(flag & LV_TXT_FLAG_RIGHT) {
 801529a:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801529e:	f003 0308 	and.w	r3, r3, #8
 80152a2:	2b00      	cmp	r3, #0
 80152a4:	d02b      	beq.n	80152fe <lv_draw_label+0x322>
        line_width = lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 80152a6:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80152aa:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80152ae:	18d0      	adds	r0, r2, r3
 80152b0:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80152b4:	b29a      	uxth	r2, r3
 80152b6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80152ba:	b29b      	uxth	r3, r3
 80152bc:	1ad3      	subs	r3, r2, r3
 80152be:	b299      	uxth	r1, r3
 80152c0:	687b      	ldr	r3, [r7, #4]
 80152c2:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80152c6:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80152ca:	9300      	str	r3, [sp, #0]
 80152cc:	4613      	mov	r3, r2
 80152ce:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80152d2:	f008 f89b 	bl	801d40c <lv_txt_get_width>
 80152d6:	4603      	mov	r3, r0
 80152d8:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
        pos.x += lv_area_get_width(coords) - line_width;
 80152dc:	68f8      	ldr	r0, [r7, #12]
 80152de:	f7ff fe65 	bl	8014fac <lv_area_get_width>
 80152e2:	4603      	mov	r3, r0
 80152e4:	461a      	mov	r2, r3
 80152e6:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 80152ea:	1ad3      	subs	r3, r2, r3
 80152ec:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 80152f0:	b292      	uxth	r2, r2
 80152f2:	b29b      	uxth	r3, r3
 80152f4:	4413      	add	r3, r2
 80152f6:	b29b      	uxth	r3, r3
 80152f8:	b21b      	sxth	r3, r3
 80152fa:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
    }

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->text.opa : (uint16_t)((uint16_t)style->text.opa * opa_scale) >> 8;
 80152fe:	78fb      	ldrb	r3, [r7, #3]
 8015300:	2bff      	cmp	r3, #255	; 0xff
 8015302:	d103      	bne.n	801530c <lv_draw_label+0x330>
 8015304:	687b      	ldr	r3, [r7, #4]
 8015306:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 801530a:	e00b      	b.n	8015324 <lv_draw_label+0x348>
 801530c:	687b      	ldr	r3, [r7, #4]
 801530e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8015312:	b29a      	uxth	r2, r3
 8015314:	78fb      	ldrb	r3, [r7, #3]
 8015316:	b29b      	uxth	r3, r3
 8015318:	fb12 f303 	smulbb	r3, r2, r3
 801531c:	b29b      	uxth	r3, r3
 801531e:	0a1b      	lsrs	r3, r3, #8
 8015320:	b29b      	uxth	r3, r3
 8015322:	b2db      	uxtb	r3, r3
 8015324:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f

    cmd_state_t cmd_state = CMD_STATE_WAIT;
 8015328:	2300      	movs	r3, #0
 801532a:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
    uint32_t i;
    uint16_t par_start = 0;
 801532e:	2300      	movs	r3, #0
 8015330:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
    lv_color_t recolor;
    lv_coord_t letter_w;
    lv_style_t sel_style;
    lv_style_copy(&sel_style, &lv_style_plain_color);
 8015334:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8015338:	499b      	ldr	r1, [pc, #620]	; (80155a8 <lv_draw_label+0x5cc>)
 801533a:	4618      	mov	r0, r3
 801533c:	f7fe fb92 	bl	8013a64 <lv_style_copy>
    sel_style.body.main_color = sel_style.body.grad_color = style->text.sel_color;
 8015340:	687b      	ldr	r3, [r7, #4]
 8015342:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 8015344:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8015346:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8015348:	857b      	strh	r3, [r7, #42]	; 0x2a

    /*Write out all lines*/
    while(txt[line_start] != '\0') {
 801534a:	e1d7      	b.n	80156fc <lv_draw_label+0x720>
        if(offset != NULL) {
 801534c:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8015350:	2b00      	cmp	r3, #0
 8015352:	d009      	beq.n	8015368 <lv_draw_label+0x38c>
            pos.x += x_ofs;
 8015354:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8015358:	b29a      	uxth	r2, r3
 801535a:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 801535e:	4413      	add	r3, r2
 8015360:	b29b      	uxth	r3, r3
 8015362:	b21b      	sxth	r3, r3
 8015364:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        }
        /*Write all letter of a line*/
        cmd_state = CMD_STATE_WAIT;
 8015368:	2300      	movs	r3, #0
 801536a:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
        i         = line_start;
 801536e:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015372:	66bb      	str	r3, [r7, #104]	; 0x68
        uint32_t letter;
        uint32_t letter_next;
        while(i < line_end) {
 8015374:	e11f      	b.n	80155b6 <lv_draw_label+0x5da>
            letter      = lv_txt_encoded_next(txt, &i);
 8015376:	4b8d      	ldr	r3, [pc, #564]	; (80155ac <lv_draw_label+0x5d0>)
 8015378:	681b      	ldr	r3, [r3, #0]
 801537a:	f107 0268 	add.w	r2, r7, #104	; 0x68
 801537e:	4611      	mov	r1, r2
 8015380:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 8015384:	4798      	blx	r3
 8015386:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 801538a:	4b88      	ldr	r3, [pc, #544]	; (80155ac <lv_draw_label+0x5d0>)
 801538c:	681b      	ldr	r3, [r3, #0]
 801538e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8015390:	f8d7 10c0 	ldr.w	r1, [r7, #192]	; 0xc0
 8015394:	440a      	add	r2, r1
 8015396:	2100      	movs	r1, #0
 8015398:	4610      	mov	r0, r2
 801539a:	4798      	blx	r3
 801539c:	f8c7 0084 	str.w	r0, [r7, #132]	; 0x84

            /*Handle the re-color command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 80153a0:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80153a4:	f003 0301 	and.w	r3, r3, #1
 80153a8:	2b00      	cmp	r3, #0
 80153aa:	d07a      	beq.n	80154a2 <lv_draw_label+0x4c6>
                if(letter == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 80153ac:	2323      	movs	r3, #35	; 0x23
 80153ae:	461a      	mov	r2, r3
 80153b0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80153b4:	4293      	cmp	r3, r2
 80153b6:	d11a      	bne.n	80153ee <lv_draw_label+0x412>
                    if(cmd_state == CMD_STATE_WAIT) { /*Start char*/
 80153b8:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 80153bc:	2b00      	cmp	r3, #0
 80153be:	d106      	bne.n	80153ce <lv_draw_label+0x3f2>
                        par_start = i;
 80153c0:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80153c2:	f8a7 3098 	strh.w	r3, [r7, #152]	; 0x98
                        cmd_state = CMD_STATE_PAR;
 80153c6:	2301      	movs	r3, #1
 80153c8:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                        continue;
 80153cc:	e0f3      	b.n	80155b6 <lv_draw_label+0x5da>
                    } else if(cmd_state == CMD_STATE_PAR) { /*Other start char in parameter escaped cmd. char */
 80153ce:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 80153d2:	2b01      	cmp	r3, #1
 80153d4:	d103      	bne.n	80153de <lv_draw_label+0x402>
                        cmd_state = CMD_STATE_WAIT;
 80153d6:	2300      	movs	r3, #0
 80153d8:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
 80153dc:	e007      	b.n	80153ee <lv_draw_label+0x412>
                    } else if(cmd_state == CMD_STATE_IN) { /*Command end */
 80153de:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 80153e2:	2b02      	cmp	r3, #2
 80153e4:	d103      	bne.n	80153ee <lv_draw_label+0x412>
                        cmd_state = CMD_STATE_WAIT;
 80153e6:	2300      	movs	r3, #0
 80153e8:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                        continue;
 80153ec:	e0e3      	b.n	80155b6 <lv_draw_label+0x5da>
                    }
                }

                /*Skip the color parameter and wait the space after it*/
                if(cmd_state == CMD_STATE_PAR) {
 80153ee:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 80153f2:	2b01      	cmp	r3, #1
 80153f4:	d155      	bne.n	80154a2 <lv_draw_label+0x4c6>
                    if(letter == ' ') {
 80153f6:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80153fa:	2b20      	cmp	r3, #32
 80153fc:	f040 80da 	bne.w	80155b4 <lv_draw_label+0x5d8>
                        /*Get the parameter*/
                        if(i - par_start == LABEL_RECOLOR_PAR_LENGTH + 1) {
 8015400:	6eba      	ldr	r2, [r7, #104]	; 0x68
 8015402:	f8b7 3098 	ldrh.w	r3, [r7, #152]	; 0x98
 8015406:	1ad3      	subs	r3, r2, r3
 8015408:	2b07      	cmp	r3, #7
 801540a:	d142      	bne.n	8015492 <lv_draw_label+0x4b6>
                            char buf[LABEL_RECOLOR_PAR_LENGTH + 1];
                            memcpy(buf, &txt[par_start], LABEL_RECOLOR_PAR_LENGTH);
 801540c:	f8b7 3098 	ldrh.w	r3, [r7, #152]	; 0x98
 8015410:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8015414:	18d1      	adds	r1, r2, r3
 8015416:	f107 0318 	add.w	r3, r7, #24
 801541a:	2206      	movs	r2, #6
 801541c:	4618      	mov	r0, r3
 801541e:	f011 fecd 	bl	80271bc <memcpy>
                            buf[LABEL_RECOLOR_PAR_LENGTH] = '\0';
 8015422:	2300      	movs	r3, #0
 8015424:	77bb      	strb	r3, [r7, #30]
                            int r, g, b;
                            r       = (hex_char_to_num(buf[0]) << 4) + hex_char_to_num(buf[1]);
 8015426:	7e3b      	ldrb	r3, [r7, #24]
 8015428:	4618      	mov	r0, r3
 801542a:	f000 f977 	bl	801571c <hex_char_to_num>
 801542e:	4603      	mov	r3, r0
 8015430:	011c      	lsls	r4, r3, #4
 8015432:	7e7b      	ldrb	r3, [r7, #25]
 8015434:	4618      	mov	r0, r3
 8015436:	f000 f971 	bl	801571c <hex_char_to_num>
 801543a:	4603      	mov	r3, r0
 801543c:	4423      	add	r3, r4
 801543e:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
                            g       = (hex_char_to_num(buf[2]) << 4) + hex_char_to_num(buf[3]);
 8015442:	7ebb      	ldrb	r3, [r7, #26]
 8015444:	4618      	mov	r0, r3
 8015446:	f000 f969 	bl	801571c <hex_char_to_num>
 801544a:	4603      	mov	r3, r0
 801544c:	011c      	lsls	r4, r3, #4
 801544e:	7efb      	ldrb	r3, [r7, #27]
 8015450:	4618      	mov	r0, r3
 8015452:	f000 f963 	bl	801571c <hex_char_to_num>
 8015456:	4603      	mov	r3, r0
 8015458:	4423      	add	r3, r4
 801545a:	67fb      	str	r3, [r7, #124]	; 0x7c
                            b       = (hex_char_to_num(buf[4]) << 4) + hex_char_to_num(buf[5]);
 801545c:	7f3b      	ldrb	r3, [r7, #28]
 801545e:	4618      	mov	r0, r3
 8015460:	f000 f95c 	bl	801571c <hex_char_to_num>
 8015464:	4603      	mov	r3, r0
 8015466:	011c      	lsls	r4, r3, #4
 8015468:	7f7b      	ldrb	r3, [r7, #29]
 801546a:	4618      	mov	r0, r3
 801546c:	f000 f956 	bl	801571c <hex_char_to_num>
 8015470:	4603      	mov	r3, r0
 8015472:	4423      	add	r3, r4
 8015474:	67bb      	str	r3, [r7, #120]	; 0x78
                            recolor = lv_color_make(r, g, b);
 8015476:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 801547a:	b2db      	uxtb	r3, r3
 801547c:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
 801547e:	b2d1      	uxtb	r1, r2
 8015480:	6fba      	ldr	r2, [r7, #120]	; 0x78
 8015482:	b2d2      	uxtb	r2, r2
 8015484:	4618      	mov	r0, r3
 8015486:	f7ff fd63 	bl	8014f50 <lv_color_make>
 801548a:	4603      	mov	r3, r0
 801548c:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
 8015490:	e003      	b.n	801549a <lv_draw_label+0x4be>
                        } else {
                            recolor.full = style->text.color.full;
 8015492:	687b      	ldr	r3, [r7, #4]
 8015494:	8c1b      	ldrh	r3, [r3, #32]
 8015496:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
                        }
                        cmd_state = CMD_STATE_IN; /*After the parameter the text is in the command*/
 801549a:	2302      	movs	r3, #2
 801549c:	f887 309b 	strb.w	r3, [r7, #155]	; 0x9b
                    }
                    continue;
 80154a0:	e088      	b.n	80155b4 <lv_draw_label+0x5d8>
                }
            }

            lv_color_t color = style->text.color;
 80154a2:	687b      	ldr	r3, [r7, #4]
 80154a4:	8c1b      	ldrh	r3, [r3, #32]
 80154a6:	843b      	strh	r3, [r7, #32]

            if(cmd_state == CMD_STATE_IN) color = recolor;
 80154a8:	f897 309b 	ldrb.w	r3, [r7, #155]	; 0x9b
 80154ac:	2b02      	cmp	r3, #2
 80154ae:	d102      	bne.n	80154b6 <lv_draw_label+0x4da>
 80154b0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80154b4:	843b      	strh	r3, [r7, #32]

            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 80154b6:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
 80154ba:	f8d7 1088 	ldr.w	r1, [r7, #136]	; 0x88
 80154be:	f8d7 0094 	ldr.w	r0, [r7, #148]	; 0x94
 80154c2:	f005 fa19 	bl	801a8f8 <lv_font_get_glyph_width>
 80154c6:	4603      	mov	r3, r0
 80154c8:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

            if(sel_start != 0xFFFF && sel_end != 0xFFFF) {
 80154cc:	f8b7 30cc 	ldrh.w	r3, [r7, #204]	; 0xcc
 80154d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80154d4:	4293      	cmp	r3, r2
 80154d6:	d043      	beq.n	8015560 <lv_draw_label+0x584>
 80154d8:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
 80154dc:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80154e0:	4293      	cmp	r3, r2
 80154e2:	d03d      	beq.n	8015560 <lv_draw_label+0x584>
                int char_ind = lv_encoded_get_char_id(txt, i);
 80154e4:	4b32      	ldr	r3, [pc, #200]	; (80155b0 <lv_draw_label+0x5d4>)
 80154e6:	681b      	ldr	r3, [r3, #0]
 80154e8:	6eba      	ldr	r2, [r7, #104]	; 0x68
 80154ea:	4611      	mov	r1, r2
 80154ec:	f8d7 00c0 	ldr.w	r0, [r7, #192]	; 0xc0
 80154f0:	4798      	blx	r3
 80154f2:	4603      	mov	r3, r0
 80154f4:	673b      	str	r3, [r7, #112]	; 0x70
                /*Do not draw the rectangle on the character at `sel_start`.*/
                if(char_ind > sel_start && char_ind <= sel_end) {
 80154f6:	f8b7 30cc 	ldrh.w	r3, [r7, #204]	; 0xcc
 80154fa:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 80154fc:	429a      	cmp	r2, r3
 80154fe:	dd2f      	ble.n	8015560 <lv_draw_label+0x584>
 8015500:	f8b7 30d0 	ldrh.w	r3, [r7, #208]	; 0xd0
 8015504:	6f3a      	ldr	r2, [r7, #112]	; 0x70
 8015506:	429a      	cmp	r2, r3
 8015508:	dc2a      	bgt.n	8015560 <lv_draw_label+0x584>
                    lv_area_t sel_coords;
                    sel_coords.x1 = pos.x;
 801550a:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 801550e:	823b      	strh	r3, [r7, #16]
                    sel_coords.y1 = pos.y;
 8015510:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8015514:	827b      	strh	r3, [r7, #18]
                    sel_coords.x2 = pos.x + letter_w + style->text.letter_space - 1;
 8015516:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 801551a:	b29a      	uxth	r2, r3
 801551c:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8015520:	4413      	add	r3, r2
 8015522:	b29a      	uxth	r2, r3
 8015524:	687b      	ldr	r3, [r7, #4]
 8015526:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 801552a:	b29b      	uxth	r3, r3
 801552c:	4413      	add	r3, r2
 801552e:	b29b      	uxth	r3, r3
 8015530:	3b01      	subs	r3, #1
 8015532:	b29b      	uxth	r3, r3
 8015534:	b21b      	sxth	r3, r3
 8015536:	82bb      	strh	r3, [r7, #20]
                    sel_coords.y2 = pos.y + line_height - 1;
 8015538:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 801553c:	b29a      	uxth	r2, r3
 801553e:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 8015542:	4413      	add	r3, r2
 8015544:	b29b      	uxth	r3, r3
 8015546:	3b01      	subs	r3, #1
 8015548:	b29b      	uxth	r3, r3
 801554a:	b21b      	sxth	r3, r3
 801554c:	82fb      	strh	r3, [r7, #22]
                    lv_draw_rect(&sel_coords, mask, &sel_style, opa);
 801554e:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8015552:	f107 0228 	add.w	r2, r7, #40	; 0x28
 8015556:	f107 0010 	add.w	r0, r7, #16
 801555a:	68b9      	ldr	r1, [r7, #8]
 801555c:	f000 f9d1 	bl	8015902 <lv_draw_rect>
                }
            }
            lv_draw_letter(&pos, mask, font, letter, color, opa);
 8015560:	f107 006c 	add.w	r0, r7, #108	; 0x6c
 8015564:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8015568:	9301      	str	r3, [sp, #4]
 801556a:	8c3b      	ldrh	r3, [r7, #32]
 801556c:	f8ad 3000 	strh.w	r3, [sp]
 8015570:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8015574:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8015578:	68b9      	ldr	r1, [r7, #8]
 801557a:	f7ff f895 	bl	80146a8 <lv_draw_letter>

            if(letter_w > 0) {
 801557e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8015582:	2b00      	cmp	r3, #0
 8015584:	dd17      	ble.n	80155b6 <lv_draw_label+0x5da>
                pos.x += letter_w + style->text.letter_space;
 8015586:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 801558a:	b29a      	uxth	r2, r3
 801558c:	687b      	ldr	r3, [r7, #4]
 801558e:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8015592:	b299      	uxth	r1, r3
 8015594:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8015598:	440b      	add	r3, r1
 801559a:	b29b      	uxth	r3, r3
 801559c:	4413      	add	r3, r2
 801559e:	b29b      	uxth	r3, r3
 80155a0:	b21b      	sxth	r3, r3
 80155a2:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 80155a6:	e006      	b.n	80155b6 <lv_draw_label+0x5da>
 80155a8:	2000df08 	.word	0x2000df08
 80155ac:	20000c34 	.word	0x20000c34
 80155b0:	20000c40 	.word	0x20000c40
                    continue;
 80155b4:	bf00      	nop
        while(i < line_end) {
 80155b6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 80155b8:	f8d7 209c 	ldr.w	r2, [r7, #156]	; 0x9c
 80155bc:	429a      	cmp	r2, r3
 80155be:	f63f aeda 	bhi.w	8015376 <lv_draw_label+0x39a>
            }
        }
        /*Go to next line*/
        line_start = line_end;
 80155c2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80155c6:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
        line_end += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, w, flag);
 80155ca:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 80155ce:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 80155d2:	18d0      	adds	r0, r2, r3
 80155d4:	687b      	ldr	r3, [r7, #4]
 80155d6:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 80155da:	f9b7 10ae 	ldrsh.w	r1, [r7, #174]	; 0xae
 80155de:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80155e2:	9300      	str	r3, [sp, #0]
 80155e4:	460b      	mov	r3, r1
 80155e6:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 80155ea:	f007 fe5d 	bl	801d2a8 <lv_txt_get_next_line>
 80155ee:	4603      	mov	r3, r0
 80155f0:	461a      	mov	r2, r3
 80155f2:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80155f6:	4413      	add	r3, r2
 80155f8:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

        pos.x = coords->x1;
 80155fc:	68fb      	ldr	r3, [r7, #12]
 80155fe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015602:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        /*Align to middle*/
        if(flag & LV_TXT_FLAG_CENTER) {
 8015606:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801560a:	f003 0304 	and.w	r3, r3, #4
 801560e:	2b00      	cmp	r3, #0
 8015610:	d031      	beq.n	8015676 <lv_draw_label+0x69a>
            line_width =
                lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 8015612:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8015616:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801561a:	18d0      	adds	r0, r2, r3
 801561c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015620:	b29a      	uxth	r2, r3
 8015622:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015626:	b29b      	uxth	r3, r3
 8015628:	1ad3      	subs	r3, r2, r3
 801562a:	b299      	uxth	r1, r3
 801562c:	687b      	ldr	r3, [r7, #4]
 801562e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
            line_width =
 8015632:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 8015636:	9300      	str	r3, [sp, #0]
 8015638:	4613      	mov	r3, r2
 801563a:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 801563e:	f007 fee5 	bl	801d40c <lv_txt_get_width>
 8015642:	4603      	mov	r3, r0
 8015644:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90

            pos.x += (lv_area_get_width(coords) - line_width) / 2;
 8015648:	68f8      	ldr	r0, [r7, #12]
 801564a:	f7ff fcaf 	bl	8014fac <lv_area_get_width>
 801564e:	4603      	mov	r3, r0
 8015650:	461a      	mov	r2, r3
 8015652:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 8015656:	1ad3      	subs	r3, r2, r3
 8015658:	2b00      	cmp	r3, #0
 801565a:	da00      	bge.n	801565e <lv_draw_label+0x682>
 801565c:	3301      	adds	r3, #1
 801565e:	105b      	asrs	r3, r3, #1
 8015660:	4619      	mov	r1, r3
 8015662:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8015666:	b29a      	uxth	r2, r3
 8015668:	b28b      	uxth	r3, r1
 801566a:	4413      	add	r3, r2
 801566c:	b29b      	uxth	r3, r3
 801566e:	b21b      	sxth	r3, r3
 8015670:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
 8015674:	e031      	b.n	80156da <lv_draw_label+0x6fe>

        }
        /*Align to the right*/
        else if(flag & LV_TXT_FLAG_RIGHT) {
 8015676:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 801567a:	f003 0308 	and.w	r3, r3, #8
 801567e:	2b00      	cmp	r3, #0
 8015680:	d02b      	beq.n	80156da <lv_draw_label+0x6fe>
            line_width =
                lv_txt_get_width(&txt[line_start], line_end - line_start, font, style->text.letter_space, flag);
 8015682:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8015686:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 801568a:	18d0      	adds	r0, r2, r3
 801568c:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8015690:	b29a      	uxth	r2, r3
 8015692:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015696:	b29b      	uxth	r3, r3
 8015698:	1ad3      	subs	r3, r2, r3
 801569a:	b299      	uxth	r1, r3
 801569c:	687b      	ldr	r3, [r7, #4]
 801569e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
            line_width =
 80156a2:	f897 30c4 	ldrb.w	r3, [r7, #196]	; 0xc4
 80156a6:	9300      	str	r3, [sp, #0]
 80156a8:	4613      	mov	r3, r2
 80156aa:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 80156ae:	f007 fead 	bl	801d40c <lv_txt_get_width>
 80156b2:	4603      	mov	r3, r0
 80156b4:	f8a7 3090 	strh.w	r3, [r7, #144]	; 0x90
            pos.x += lv_area_get_width(coords) - line_width;
 80156b8:	68f8      	ldr	r0, [r7, #12]
 80156ba:	f7ff fc77 	bl	8014fac <lv_area_get_width>
 80156be:	4603      	mov	r3, r0
 80156c0:	461a      	mov	r2, r3
 80156c2:	f9b7 3090 	ldrsh.w	r3, [r7, #144]	; 0x90
 80156c6:	1ad3      	subs	r3, r2, r3
 80156c8:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 80156cc:	b292      	uxth	r2, r2
 80156ce:	b29b      	uxth	r3, r3
 80156d0:	4413      	add	r3, r2
 80156d2:	b29b      	uxth	r3, r3
 80156d4:	b21b      	sxth	r3, r3
 80156d6:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        }

        /*Go the next line position*/
        pos.y += line_height;
 80156da:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 80156de:	b29a      	uxth	r2, r3
 80156e0:	f8b7 3092 	ldrh.w	r3, [r7, #146]	; 0x92
 80156e4:	4413      	add	r3, r2
 80156e6:	b29b      	uxth	r3, r3
 80156e8:	b21b      	sxth	r3, r3
 80156ea:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e

        if(pos.y > mask->y2) return;
 80156ee:	f9b7 206e 	ldrsh.w	r2, [r7, #110]	; 0x6e
 80156f2:	68bb      	ldr	r3, [r7, #8]
 80156f4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80156f8:	429a      	cmp	r2, r3
 80156fa:	dc0b      	bgt.n	8015714 <lv_draw_label+0x738>
    while(txt[line_start] != '\0') {
 80156fc:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 8015700:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8015704:	4413      	add	r3, r2
 8015706:	781b      	ldrb	r3, [r3, #0]
 8015708:	2b00      	cmp	r3, #0
 801570a:	f47f ae1f 	bne.w	801534c <lv_draw_label+0x370>
 801570e:	e002      	b.n	8015716 <lv_draw_label+0x73a>
        if(txt[line_start] == '\0') return;
 8015710:	bf00      	nop
 8015712:	e000      	b.n	8015716 <lv_draw_label+0x73a>
        if(pos.y > mask->y2) return;
 8015714:	bf00      	nop
    }
}
 8015716:	37b4      	adds	r7, #180	; 0xb4
 8015718:	46bd      	mov	sp, r7
 801571a:	bd90      	pop	{r4, r7, pc}

0801571c <hex_char_to_num>:
 * Convert a hexadecimal characters to a number (0..15)
 * @param hex Pointer to a hexadecimal character (0..9, A..F)
 * @return the numerical value of `hex` or 0 on error
 */
static uint8_t hex_char_to_num(char hex)
{
 801571c:	b480      	push	{r7}
 801571e:	b085      	sub	sp, #20
 8015720:	af00      	add	r7, sp, #0
 8015722:	4603      	mov	r3, r0
 8015724:	71fb      	strb	r3, [r7, #7]
    uint8_t result = 0;
 8015726:	2300      	movs	r3, #0
 8015728:	73fb      	strb	r3, [r7, #15]

    if(hex >= '0' && hex <= '9') {
 801572a:	79fb      	ldrb	r3, [r7, #7]
 801572c:	2b2f      	cmp	r3, #47	; 0x2f
 801572e:	d906      	bls.n	801573e <hex_char_to_num+0x22>
 8015730:	79fb      	ldrb	r3, [r7, #7]
 8015732:	2b39      	cmp	r3, #57	; 0x39
 8015734:	d803      	bhi.n	801573e <hex_char_to_num+0x22>
        result = hex - '0';
 8015736:	79fb      	ldrb	r3, [r7, #7]
 8015738:	3b30      	subs	r3, #48	; 0x30
 801573a:	73fb      	strb	r3, [r7, #15]
 801573c:	e02d      	b.n	801579a <hex_char_to_num+0x7e>
    } else {
        if(hex >= 'a') hex -= 'a' - 'A'; /*Convert to upper case*/
 801573e:	79fb      	ldrb	r3, [r7, #7]
 8015740:	2b60      	cmp	r3, #96	; 0x60
 8015742:	d902      	bls.n	801574a <hex_char_to_num+0x2e>
 8015744:	79fb      	ldrb	r3, [r7, #7]
 8015746:	3b20      	subs	r3, #32
 8015748:	71fb      	strb	r3, [r7, #7]

        switch(hex) {
 801574a:	79fb      	ldrb	r3, [r7, #7]
 801574c:	3b41      	subs	r3, #65	; 0x41
 801574e:	2b05      	cmp	r3, #5
 8015750:	d820      	bhi.n	8015794 <hex_char_to_num+0x78>
 8015752:	a201      	add	r2, pc, #4	; (adr r2, 8015758 <hex_char_to_num+0x3c>)
 8015754:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8015758:	08015771 	.word	0x08015771
 801575c:	08015777 	.word	0x08015777
 8015760:	0801577d 	.word	0x0801577d
 8015764:	08015783 	.word	0x08015783
 8015768:	08015789 	.word	0x08015789
 801576c:	0801578f 	.word	0x0801578f
            case 'A': result = 10; break;
 8015770:	230a      	movs	r3, #10
 8015772:	73fb      	strb	r3, [r7, #15]
 8015774:	e011      	b.n	801579a <hex_char_to_num+0x7e>
            case 'B': result = 11; break;
 8015776:	230b      	movs	r3, #11
 8015778:	73fb      	strb	r3, [r7, #15]
 801577a:	e00e      	b.n	801579a <hex_char_to_num+0x7e>
            case 'C': result = 12; break;
 801577c:	230c      	movs	r3, #12
 801577e:	73fb      	strb	r3, [r7, #15]
 8015780:	e00b      	b.n	801579a <hex_char_to_num+0x7e>
            case 'D': result = 13; break;
 8015782:	230d      	movs	r3, #13
 8015784:	73fb      	strb	r3, [r7, #15]
 8015786:	e008      	b.n	801579a <hex_char_to_num+0x7e>
            case 'E': result = 14; break;
 8015788:	230e      	movs	r3, #14
 801578a:	73fb      	strb	r3, [r7, #15]
 801578c:	e005      	b.n	801579a <hex_char_to_num+0x7e>
            case 'F': result = 15; break;
 801578e:	230f      	movs	r3, #15
 8015790:	73fb      	strb	r3, [r7, #15]
 8015792:	e002      	b.n	801579a <hex_char_to_num+0x7e>
            default: result = 0; break;
 8015794:	2300      	movs	r3, #0
 8015796:	73fb      	strb	r3, [r7, #15]
 8015798:	bf00      	nop
        }
    }

    return result;
 801579a:	7bfb      	ldrb	r3, [r7, #15]
}
 801579c:	4618      	mov	r0, r3
 801579e:	3714      	adds	r7, #20
 80157a0:	46bd      	mov	sp, r7
 80157a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80157a6:	4770      	bx	lr

080157a8 <lv_color_mix>:
{
 80157a8:	b480      	push	{r7}
 80157aa:	b085      	sub	sp, #20
 80157ac:	af00      	add	r7, sp, #0
 80157ae:	80b8      	strh	r0, [r7, #4]
 80157b0:	8039      	strh	r1, [r7, #0]
 80157b2:	4613      	mov	r3, r2
 80157b4:	70fb      	strb	r3, [r7, #3]
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 80157b6:	797b      	ldrb	r3, [r7, #5]
 80157b8:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80157bc:	b2db      	uxtb	r3, r3
 80157be:	b29a      	uxth	r2, r3
 80157c0:	78fb      	ldrb	r3, [r7, #3]
 80157c2:	b29b      	uxth	r3, r3
 80157c4:	fb12 f303 	smulbb	r3, r2, r3
 80157c8:	b29a      	uxth	r2, r3
 80157ca:	787b      	ldrb	r3, [r7, #1]
 80157cc:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80157d0:	b2db      	uxtb	r3, r3
 80157d2:	b299      	uxth	r1, r3
 80157d4:	78fb      	ldrb	r3, [r7, #3]
 80157d6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80157da:	b29b      	uxth	r3, r3
 80157dc:	fb11 f303 	smulbb	r3, r1, r3
 80157e0:	b29b      	uxth	r3, r3
 80157e2:	4413      	add	r3, r2
 80157e4:	b29b      	uxth	r3, r3
 80157e6:	0a1b      	lsrs	r3, r3, #8
 80157e8:	b29b      	uxth	r3, r3
 80157ea:	f003 031f 	and.w	r3, r3, #31
 80157ee:	b2da      	uxtb	r2, r3
 80157f0:	7b7b      	ldrb	r3, [r7, #13]
 80157f2:	f362 03c7 	bfi	r3, r2, #3, #5
 80157f6:	737b      	strb	r3, [r7, #13]
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 80157f8:	88bb      	ldrh	r3, [r7, #4]
 80157fa:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80157fe:	b2db      	uxtb	r3, r3
 8015800:	b29a      	uxth	r2, r3
 8015802:	78fb      	ldrb	r3, [r7, #3]
 8015804:	b29b      	uxth	r3, r3
 8015806:	fb12 f303 	smulbb	r3, r2, r3
 801580a:	b29a      	uxth	r2, r3
 801580c:	883b      	ldrh	r3, [r7, #0]
 801580e:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8015812:	b2db      	uxtb	r3, r3
 8015814:	b299      	uxth	r1, r3
 8015816:	78fb      	ldrb	r3, [r7, #3]
 8015818:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801581c:	b29b      	uxth	r3, r3
 801581e:	fb11 f303 	smulbb	r3, r1, r3
 8015822:	b29b      	uxth	r3, r3
 8015824:	4413      	add	r3, r2
 8015826:	b29b      	uxth	r3, r3
 8015828:	0a1b      	lsrs	r3, r3, #8
 801582a:	b29b      	uxth	r3, r3
 801582c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8015830:	b2da      	uxtb	r2, r3
 8015832:	89bb      	ldrh	r3, [r7, #12]
 8015834:	f362 134a 	bfi	r3, r2, #5, #6
 8015838:	81bb      	strh	r3, [r7, #12]
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 801583a:	793b      	ldrb	r3, [r7, #4]
 801583c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8015840:	b2db      	uxtb	r3, r3
 8015842:	b29a      	uxth	r2, r3
 8015844:	78fb      	ldrb	r3, [r7, #3]
 8015846:	b29b      	uxth	r3, r3
 8015848:	fb12 f303 	smulbb	r3, r2, r3
 801584c:	b29a      	uxth	r2, r3
 801584e:	783b      	ldrb	r3, [r7, #0]
 8015850:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8015854:	b2db      	uxtb	r3, r3
 8015856:	b299      	uxth	r1, r3
 8015858:	78fb      	ldrb	r3, [r7, #3]
 801585a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 801585e:	b29b      	uxth	r3, r3
 8015860:	fb11 f303 	smulbb	r3, r1, r3
 8015864:	b29b      	uxth	r3, r3
 8015866:	4413      	add	r3, r2
 8015868:	b29b      	uxth	r3, r3
 801586a:	0a1b      	lsrs	r3, r3, #8
 801586c:	b29b      	uxth	r3, r3
 801586e:	f003 031f 	and.w	r3, r3, #31
 8015872:	b2da      	uxtb	r2, r3
 8015874:	7b3b      	ldrb	r3, [r7, #12]
 8015876:	f362 0304 	bfi	r3, r2, #0, #5
 801587a:	733b      	strb	r3, [r7, #12]
    return ret;
 801587c:	89bb      	ldrh	r3, [r7, #12]
}
 801587e:	4618      	mov	r0, r3
 8015880:	3714      	adds	r7, #20
 8015882:	46bd      	mov	sp, r7
 8015884:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015888:	4770      	bx	lr

0801588a <lv_area_copy>:
{
 801588a:	b580      	push	{r7, lr}
 801588c:	b082      	sub	sp, #8
 801588e:	af00      	add	r7, sp, #0
 8015890:	6078      	str	r0, [r7, #4]
 8015892:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 8015894:	2208      	movs	r2, #8
 8015896:	6839      	ldr	r1, [r7, #0]
 8015898:	6878      	ldr	r0, [r7, #4]
 801589a:	f011 fc8f 	bl	80271bc <memcpy>
}
 801589e:	bf00      	nop
 80158a0:	3708      	adds	r7, #8
 80158a2:	46bd      	mov	sp, r7
 80158a4:	bd80      	pop	{r7, pc}

080158a6 <lv_area_get_width>:
{
 80158a6:	b480      	push	{r7}
 80158a8:	b083      	sub	sp, #12
 80158aa:	af00      	add	r7, sp, #0
 80158ac:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80158ae:	687b      	ldr	r3, [r7, #4]
 80158b0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80158b4:	b29a      	uxth	r2, r3
 80158b6:	687b      	ldr	r3, [r7, #4]
 80158b8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80158bc:	b29b      	uxth	r3, r3
 80158be:	1ad3      	subs	r3, r2, r3
 80158c0:	b29b      	uxth	r3, r3
 80158c2:	3301      	adds	r3, #1
 80158c4:	b29b      	uxth	r3, r3
 80158c6:	b21b      	sxth	r3, r3
}
 80158c8:	4618      	mov	r0, r3
 80158ca:	370c      	adds	r7, #12
 80158cc:	46bd      	mov	sp, r7
 80158ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80158d2:	4770      	bx	lr

080158d4 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80158d4:	b480      	push	{r7}
 80158d6:	b083      	sub	sp, #12
 80158d8:	af00      	add	r7, sp, #0
 80158da:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 80158dc:	687b      	ldr	r3, [r7, #4]
 80158de:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80158e2:	b29a      	uxth	r2, r3
 80158e4:	687b      	ldr	r3, [r7, #4]
 80158e6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80158ea:	b29b      	uxth	r3, r3
 80158ec:	1ad3      	subs	r3, r2, r3
 80158ee:	b29b      	uxth	r3, r3
 80158f0:	3301      	adds	r3, #1
 80158f2:	b29b      	uxth	r3, r3
 80158f4:	b21b      	sxth	r3, r3
}
 80158f6:	4618      	mov	r0, r3
 80158f8:	370c      	adds	r7, #12
 80158fa:	46bd      	mov	sp, r7
 80158fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8015900:	4770      	bx	lr

08015902 <lv_draw_rect>:
 * @param mask the rectangle will be drawn only in this mask
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
void lv_draw_rect(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style, lv_opa_t opa_scale)
{
 8015902:	b580      	push	{r7, lr}
 8015904:	b084      	sub	sp, #16
 8015906:	af00      	add	r7, sp, #0
 8015908:	60f8      	str	r0, [r7, #12]
 801590a:	60b9      	str	r1, [r7, #8]
 801590c:	607a      	str	r2, [r7, #4]
 801590e:	70fb      	strb	r3, [r7, #3]
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 8015910:	68f8      	ldr	r0, [r7, #12]
 8015912:	f7ff ffdf 	bl	80158d4 <lv_area_get_height>
 8015916:	4603      	mov	r3, r0
 8015918:	2b00      	cmp	r3, #0
 801591a:	dd4e      	ble.n	80159ba <lv_draw_rect+0xb8>
 801591c:	68f8      	ldr	r0, [r7, #12]
 801591e:	f7ff ffc2 	bl	80158a6 <lv_area_get_width>
 8015922:	4603      	mov	r3, r0
 8015924:	2b00      	cmp	r3, #0
 8015926:	dd48      	ble.n	80159ba <lv_draw_rect+0xb8>

#if LV_USE_SHADOW
    if(style->body.shadow.width != 0) {
 8015928:	687b      	ldr	r3, [r7, #4]
 801592a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801592e:	2b00      	cmp	r3, #0
 8015930:	d005      	beq.n	801593e <lv_draw_rect+0x3c>
        lv_draw_shadow(coords, mask, style, opa_scale);
 8015932:	78fb      	ldrb	r3, [r7, #3]
 8015934:	687a      	ldr	r2, [r7, #4]
 8015936:	68b9      	ldr	r1, [r7, #8]
 8015938:	68f8      	ldr	r0, [r7, #12]
 801593a:	f002 ff64 	bl	8018806 <lv_draw_shadow>
    }
#endif

    /* If the object is out of the mask there is nothing to draw.
     * Draw shadow before it because the shadow is out of `coords`*/
    if(lv_area_is_on(coords, mask) == false) return;
 801593e:	68b9      	ldr	r1, [r7, #8]
 8015940:	68f8      	ldr	r0, [r7, #12]
 8015942:	f006 f986 	bl	801bc52 <lv_area_is_on>
 8015946:	4603      	mov	r3, r0
 8015948:	f083 0301 	eor.w	r3, r3, #1
 801594c:	b2db      	uxtb	r3, r3
 801594e:	2b00      	cmp	r3, #0
 8015950:	d135      	bne.n	80159be <lv_draw_rect+0xbc>

    if(style->body.opa > LV_OPA_MIN) {
 8015952:	687b      	ldr	r3, [r7, #4]
 8015954:	7a1b      	ldrb	r3, [r3, #8]
 8015956:	2b10      	cmp	r3, #16
 8015958:	d910      	bls.n	801597c <lv_draw_rect+0x7a>
        lv_draw_rect_main_mid(coords, mask, style, opa_scale);
 801595a:	78fb      	ldrb	r3, [r7, #3]
 801595c:	687a      	ldr	r2, [r7, #4]
 801595e:	68b9      	ldr	r1, [r7, #8]
 8015960:	68f8      	ldr	r0, [r7, #12]
 8015962:	f000 f830 	bl	80159c6 <lv_draw_rect_main_mid>

        if(style->body.radius != 0) {
 8015966:	687b      	ldr	r3, [r7, #4]
 8015968:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801596c:	2b00      	cmp	r3, #0
 801596e:	d005      	beq.n	801597c <lv_draw_rect+0x7a>
            lv_draw_rect_main_corner(coords, mask, style, opa_scale);
 8015970:	78fb      	ldrb	r3, [r7, #3]
 8015972:	687a      	ldr	r2, [r7, #4]
 8015974:	68b9      	ldr	r1, [r7, #8]
 8015976:	68f8      	ldr	r0, [r7, #12]
 8015978:	f000 f928 	bl	8015bcc <lv_draw_rect_main_corner>
        }
    }

    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
 801597c:	687b      	ldr	r3, [r7, #4]
 801597e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8015982:	2b00      	cmp	r3, #0
 8015984:	d01c      	beq.n	80159c0 <lv_draw_rect+0xbe>
 8015986:	687b      	ldr	r3, [r7, #4]
 8015988:	7b9b      	ldrb	r3, [r3, #14]
 801598a:	2b00      	cmp	r3, #0
 801598c:	d018      	beq.n	80159c0 <lv_draw_rect+0xbe>
       style->body.border.opa >= LV_OPA_MIN) {
 801598e:	687b      	ldr	r3, [r7, #4]
 8015990:	7bdb      	ldrb	r3, [r3, #15]
    if(style->body.border.width != 0 && style->body.border.part != LV_BORDER_NONE &&
 8015992:	2b0f      	cmp	r3, #15
 8015994:	d914      	bls.n	80159c0 <lv_draw_rect+0xbe>
        lv_draw_rect_border_straight(coords, mask, style, opa_scale);
 8015996:	78fb      	ldrb	r3, [r7, #3]
 8015998:	687a      	ldr	r2, [r7, #4]
 801599a:	68b9      	ldr	r1, [r7, #8]
 801599c:	68f8      	ldr	r0, [r7, #12]
 801599e:	f001 f93e 	bl	8016c1e <lv_draw_rect_border_straight>

        if(style->body.radius != 0) {
 80159a2:	687b      	ldr	r3, [r7, #4]
 80159a4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80159a8:	2b00      	cmp	r3, #0
 80159aa:	d009      	beq.n	80159c0 <lv_draw_rect+0xbe>
            lv_draw_rect_border_corner(coords, mask, style, opa_scale);
 80159ac:	78fb      	ldrb	r3, [r7, #3]
 80159ae:	687a      	ldr	r2, [r7, #4]
 80159b0:	68b9      	ldr	r1, [r7, #8]
 80159b2:	68f8      	ldr	r0, [r7, #12]
 80159b4:	f001 fce0 	bl	8017378 <lv_draw_rect_border_corner>
 80159b8:	e002      	b.n	80159c0 <lv_draw_rect+0xbe>
    if(lv_area_get_height(coords) < 1 || lv_area_get_width(coords) < 1) return;
 80159ba:	bf00      	nop
 80159bc:	e000      	b.n	80159c0 <lv_draw_rect+0xbe>
    if(lv_area_is_on(coords, mask) == false) return;
 80159be:	bf00      	nop
        }
    }
}
 80159c0:	3710      	adds	r7, #16
 80159c2:	46bd      	mov	sp, r7
 80159c4:	bd80      	pop	{r7, pc}

080159c6 <lv_draw_rect_main_mid>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_mid(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
 80159c6:	b580      	push	{r7, lr}
 80159c8:	b08e      	sub	sp, #56	; 0x38
 80159ca:	af00      	add	r7, sp, #0
 80159cc:	60f8      	str	r0, [r7, #12]
 80159ce:	60b9      	str	r1, [r7, #8]
 80159d0:	607a      	str	r2, [r7, #4]
 80159d2:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 80159d4:	687b      	ldr	r3, [r7, #4]
 80159d6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80159da:	863b      	strh	r3, [r7, #48]	; 0x30
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 80159dc:	f7fd f860 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 80159e0:	4603      	mov	r3, r0
 80159e2:	4618      	mov	r0, r3
 80159e4:	f005 fbc2 	bl	801b16c <lv_disp_get_antialiasing>
 80159e8:	4603      	mov	r3, r0
 80159ea:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

    lv_color_t mcolor = style->body.main_color;
 80159ee:	687b      	ldr	r3, [r7, #4]
 80159f0:	885b      	ldrh	r3, [r3, #2]
 80159f2:	84bb      	strh	r3, [r7, #36]	; 0x24
    lv_color_t gcolor = style->body.grad_color;
 80159f4:	687b      	ldr	r3, [r7, #4]
 80159f6:	889b      	ldrh	r3, [r3, #4]
 80159f8:	843b      	strh	r3, [r7, #32]
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
 80159fa:	68f8      	ldr	r0, [r7, #12]
 80159fc:	f7ff ff6a 	bl	80158d4 <lv_area_get_height>
 8015a00:	4603      	mov	r3, r0
 8015a02:	85bb      	strh	r3, [r7, #44]	; 0x2c
    lv_coord_t width  = lv_area_get_width(coords);
 8015a04:	68f8      	ldr	r0, [r7, #12]
 8015a06:	f7ff ff4e 	bl	80158a6 <lv_area_get_width>
 8015a0a:	4603      	mov	r3, r0
 8015a0c:	857b      	strh	r3, [r7, #42]	; 0x2a
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8015a0e:	78fb      	ldrb	r3, [r7, #3]
 8015a10:	2bff      	cmp	r3, #255	; 0xff
 8015a12:	d102      	bne.n	8015a1a <lv_draw_rect_main_mid+0x54>
 8015a14:	687b      	ldr	r3, [r7, #4]
 8015a16:	7a1b      	ldrb	r3, [r3, #8]
 8015a18:	e00a      	b.n	8015a30 <lv_draw_rect_main_mid+0x6a>
 8015a1a:	687b      	ldr	r3, [r7, #4]
 8015a1c:	7a1b      	ldrb	r3, [r3, #8]
 8015a1e:	b29a      	uxth	r2, r3
 8015a20:	78fb      	ldrb	r3, [r7, #3]
 8015a22:	b29b      	uxth	r3, r3
 8015a24:	fb12 f303 	smulbb	r3, r2, r3
 8015a28:	b29b      	uxth	r3, r3
 8015a2a:	0a1b      	lsrs	r3, r3, #8
 8015a2c:	b29b      	uxth	r3, r3
 8015a2e:	b2db      	uxtb	r3, r3
 8015a30:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8015a34:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 8015a38:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 8015a3c:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8015a3e:	4618      	mov	r0, r3
 8015a40:	f003 fdd9 	bl	80195f6 <lv_draw_cont_radius_corr>
 8015a44:	4603      	mov	r3, r0
 8015a46:	863b      	strh	r3, [r7, #48]	; 0x30

    /*If the radius is too big then there is no body*/
    if(radius > height / 2) return;
 8015a48:	8e3a      	ldrh	r2, [r7, #48]	; 0x30
 8015a4a:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8015a4e:	2b00      	cmp	r3, #0
 8015a50:	da00      	bge.n	8015a54 <lv_draw_rect_main_mid+0x8e>
 8015a52:	3301      	adds	r3, #1
 8015a54:	105b      	asrs	r3, r3, #1
 8015a56:	b21b      	sxth	r3, r3
 8015a58:	429a      	cmp	r2, r3
 8015a5a:	f300 80b3 	bgt.w	8015bc4 <lv_draw_rect_main_mid+0x1fe>

    lv_area_t work_area;
    work_area.x1 = coords->x1;
 8015a5e:	68fb      	ldr	r3, [r7, #12]
 8015a60:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015a64:	833b      	strh	r3, [r7, #24]
    work_area.x2 = coords->x2;
 8015a66:	68fb      	ldr	r3, [r7, #12]
 8015a68:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015a6c:	83bb      	strh	r3, [r7, #28]

    if(mcolor.full == gcolor.full) {
 8015a6e:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8015a70:	8c3b      	ldrh	r3, [r7, #32]
 8015a72:	429a      	cmp	r2, r3
 8015a74:	d140      	bne.n	8015af8 <lv_draw_rect_main_mid+0x132>
        work_area.y1 = coords->y1 + radius;
 8015a76:	68fb      	ldr	r3, [r7, #12]
 8015a78:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015a7c:	b29a      	uxth	r2, r3
 8015a7e:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8015a80:	4413      	add	r3, r2
 8015a82:	b29b      	uxth	r3, r3
 8015a84:	b21b      	sxth	r3, r3
 8015a86:	837b      	strh	r3, [r7, #26]
        work_area.y2 = coords->y2 - radius;
 8015a88:	68fb      	ldr	r3, [r7, #12]
 8015a8a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015a8e:	b29a      	uxth	r2, r3
 8015a90:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8015a92:	1ad3      	subs	r3, r2, r3
 8015a94:	b29b      	uxth	r3, r3
 8015a96:	b21b      	sxth	r3, r3
 8015a98:	83fb      	strh	r3, [r7, #30]

        if(style->body.radius != 0) {
 8015a9a:	687b      	ldr	r3, [r7, #4]
 8015a9c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015aa0:	2b00      	cmp	r3, #0
 8015aa2:	d020      	beq.n	8015ae6 <lv_draw_rect_main_mid+0x120>

            if(aa) {
 8015aa4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015aa8:	2b00      	cmp	r3, #0
 8015aaa:	d00e      	beq.n	8015aca <lv_draw_rect_main_mid+0x104>
                work_area.y1 += 2;
 8015aac:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015ab0:	b29b      	uxth	r3, r3
 8015ab2:	3302      	adds	r3, #2
 8015ab4:	b29b      	uxth	r3, r3
 8015ab6:	b21b      	sxth	r3, r3
 8015ab8:	837b      	strh	r3, [r7, #26]
                work_area.y2 -= 2;
 8015aba:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015abe:	b29b      	uxth	r3, r3
 8015ac0:	3b02      	subs	r3, #2
 8015ac2:	b29b      	uxth	r3, r3
 8015ac4:	b21b      	sxth	r3, r3
 8015ac6:	83fb      	strh	r3, [r7, #30]
 8015ac8:	e00d      	b.n	8015ae6 <lv_draw_rect_main_mid+0x120>
            } else {
                work_area.y1 += 1;
 8015aca:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015ace:	b29b      	uxth	r3, r3
 8015ad0:	3301      	adds	r3, #1
 8015ad2:	b29b      	uxth	r3, r3
 8015ad4:	b21b      	sxth	r3, r3
 8015ad6:	837b      	strh	r3, [r7, #26]
                work_area.y2 -= 1;
 8015ad8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8015adc:	b29b      	uxth	r3, r3
 8015ade:	3b01      	subs	r3, #1
 8015ae0:	b29b      	uxth	r3, r3
 8015ae2:	b21b      	sxth	r3, r3
 8015ae4:	83fb      	strh	r3, [r7, #30]
            }
        }

        lv_draw_fill(&work_area, mask, mcolor, opa);
 8015ae6:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8015aea:	f107 0018 	add.w	r0, r7, #24
 8015aee:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8015af0:	68b9      	ldr	r1, [r7, #8]
 8015af2:	f7fe fc8b 	bl	801440c <lv_draw_fill>
 8015af6:	e066      	b.n	8015bc6 <lv_draw_rect_main_mid+0x200>
    } else {
        lv_coord_t row;
        lv_coord_t row_start = coords->y1 + radius;
 8015af8:	68fb      	ldr	r3, [r7, #12]
 8015afa:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015afe:	b29a      	uxth	r2, r3
 8015b00:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8015b02:	4413      	add	r3, r2
 8015b04:	b29b      	uxth	r3, r3
 8015b06:	86bb      	strh	r3, [r7, #52]	; 0x34
        lv_coord_t row_end   = coords->y2 - radius;
 8015b08:	68fb      	ldr	r3, [r7, #12]
 8015b0a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015b0e:	b29a      	uxth	r2, r3
 8015b10:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8015b12:	1ad3      	subs	r3, r2, r3
 8015b14:	b29b      	uxth	r3, r3
 8015b16:	867b      	strh	r3, [r7, #50]	; 0x32
        lv_color_t act_color;

        if(style->body.radius != 0) {
 8015b18:	687b      	ldr	r3, [r7, #4]
 8015b1a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015b1e:	2b00      	cmp	r3, #0
 8015b20:	d014      	beq.n	8015b4c <lv_draw_rect_main_mid+0x186>
            if(aa) {
 8015b22:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8015b26:	2b00      	cmp	r3, #0
 8015b28:	d008      	beq.n	8015b3c <lv_draw_rect_main_mid+0x176>
                row_start += 2;
 8015b2a:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8015b2c:	3302      	adds	r3, #2
 8015b2e:	b29b      	uxth	r3, r3
 8015b30:	86bb      	strh	r3, [r7, #52]	; 0x34
                row_end -= 2;
 8015b32:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8015b34:	3b02      	subs	r3, #2
 8015b36:	b29b      	uxth	r3, r3
 8015b38:	867b      	strh	r3, [r7, #50]	; 0x32
 8015b3a:	e007      	b.n	8015b4c <lv_draw_rect_main_mid+0x186>
            } else {
                row_start += 1;
 8015b3c:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8015b3e:	3301      	adds	r3, #1
 8015b40:	b29b      	uxth	r3, r3
 8015b42:	86bb      	strh	r3, [r7, #52]	; 0x34
                row_end -= 1;
 8015b44:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8015b46:	3b01      	subs	r3, #1
 8015b48:	b29b      	uxth	r3, r3
 8015b4a:	867b      	strh	r3, [r7, #50]	; 0x32
            }
        }
        if(row_start < 0) row_start = 0;
 8015b4c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8015b50:	2b00      	cmp	r3, #0
 8015b52:	da01      	bge.n	8015b58 <lv_draw_rect_main_mid+0x192>
 8015b54:	2300      	movs	r3, #0
 8015b56:	86bb      	strh	r3, [r7, #52]	; 0x34

        for(row = row_start; row <= row_end; row++) {
 8015b58:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8015b5a:	86fb      	strh	r3, [r7, #54]	; 0x36
 8015b5c:	e02b      	b.n	8015bb6 <lv_draw_rect_main_mid+0x1f0>
            work_area.y1 = row;
 8015b5e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8015b60:	837b      	strh	r3, [r7, #26]
            work_area.y2 = row;
 8015b62:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8015b64:	83fb      	strh	r3, [r7, #30]
            mix          = (uint32_t)((uint32_t)(coords->y2 - work_area.y1) * 255) / height;
 8015b66:	68fb      	ldr	r3, [r7, #12]
 8015b68:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015b6c:	461a      	mov	r2, r3
 8015b6e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015b72:	1ad3      	subs	r3, r2, r3
 8015b74:	461a      	mov	r2, r3
 8015b76:	4613      	mov	r3, r2
 8015b78:	021b      	lsls	r3, r3, #8
 8015b7a:	1a9a      	subs	r2, r3, r2
 8015b7c:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8015b80:	fbb2 f3f3 	udiv	r3, r2, r3
 8015b84:	f887 3028 	strb.w	r3, [r7, #40]	; 0x28
            act_color    = lv_color_mix(mcolor, gcolor, mix);
 8015b88:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
 8015b8c:	461a      	mov	r2, r3
 8015b8e:	8c39      	ldrh	r1, [r7, #32]
 8015b90:	8cb8      	ldrh	r0, [r7, #36]	; 0x24
 8015b92:	f7ff fe09 	bl	80157a8 <lv_color_mix>
 8015b96:	4603      	mov	r3, r0
 8015b98:	82bb      	strh	r3, [r7, #20]

            lv_draw_fill(&work_area, mask, act_color, opa);
 8015b9a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8015b9e:	f107 0018 	add.w	r0, r7, #24
 8015ba2:	8aba      	ldrh	r2, [r7, #20]
 8015ba4:	68b9      	ldr	r1, [r7, #8]
 8015ba6:	f7fe fc31 	bl	801440c <lv_draw_fill>
        for(row = row_start; row <= row_end; row++) {
 8015baa:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8015bae:	b29b      	uxth	r3, r3
 8015bb0:	3301      	adds	r3, #1
 8015bb2:	b29b      	uxth	r3, r3
 8015bb4:	86fb      	strh	r3, [r7, #54]	; 0x36
 8015bb6:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 8015bba:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8015bbe:	429a      	cmp	r2, r3
 8015bc0:	ddcd      	ble.n	8015b5e <lv_draw_rect_main_mid+0x198>
 8015bc2:	e000      	b.n	8015bc6 <lv_draw_rect_main_mid+0x200>
    if(radius > height / 2) return;
 8015bc4:	bf00      	nop
        }
    }
}
 8015bc6:	3738      	adds	r7, #56	; 0x38
 8015bc8:	46bd      	mov	sp, r7
 8015bca:	bd80      	pop	{r7, pc}

08015bcc <lv_draw_rect_main_corner>:
 * @param rects_p pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_main_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                     lv_opa_t opa_scale)
{
 8015bcc:	b5b0      	push	{r4, r5, r7, lr}
 8015bce:	b0a4      	sub	sp, #144	; 0x90
 8015bd0:	af02      	add	r7, sp, #8
 8015bd2:	60f8      	str	r0, [r7, #12]
 8015bd4:	60b9      	str	r1, [r7, #8]
 8015bd6:	607a      	str	r2, [r7, #4]
 8015bd8:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8015bda:	687b      	ldr	r3, [r7, #4]
 8015bdc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015be0:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8015be4:	f7fc ff5c 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8015be8:	4603      	mov	r3, r0
 8015bea:	4618      	mov	r0, r3
 8015bec:	f005 fabe 	bl	801b16c <lv_disp_get_antialiasing>
 8015bf0:	4603      	mov	r3, r0
 8015bf2:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77

    lv_color_t mcolor = style->body.main_color;
 8015bf6:	687b      	ldr	r3, [r7, #4]
 8015bf8:	885b      	ldrh	r3, [r3, #2]
 8015bfa:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    lv_color_t gcolor = style->body.grad_color;
 8015bfe:	687b      	ldr	r3, [r7, #4]
 8015c00:	889b      	ldrh	r3, [r3, #4]
 8015c02:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    lv_color_t act_color;
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8015c06:	78fb      	ldrb	r3, [r7, #3]
 8015c08:	2bff      	cmp	r3, #255	; 0xff
 8015c0a:	d102      	bne.n	8015c12 <lv_draw_rect_main_corner+0x46>
 8015c0c:	687b      	ldr	r3, [r7, #4]
 8015c0e:	7a1b      	ldrb	r3, [r3, #8]
 8015c10:	e00a      	b.n	8015c28 <lv_draw_rect_main_corner+0x5c>
 8015c12:	687b      	ldr	r3, [r7, #4]
 8015c14:	7a1b      	ldrb	r3, [r3, #8]
 8015c16:	b29a      	uxth	r2, r3
 8015c18:	78fb      	ldrb	r3, [r7, #3]
 8015c1a:	b29b      	uxth	r3, r3
 8015c1c:	fb12 f303 	smulbb	r3, r2, r3
 8015c20:	b29b      	uxth	r3, r3
 8015c22:	0a1b      	lsrs	r3, r3, #8
 8015c24:	b29b      	uxth	r3, r3
 8015c26:	b2db      	uxtb	r3, r3
 8015c28:	f887 3076 	strb.w	r3, [r7, #118]	; 0x76
    uint8_t mix;
    lv_coord_t height = lv_area_get_height(coords);
 8015c2c:	68f8      	ldr	r0, [r7, #12]
 8015c2e:	f7ff fe51 	bl	80158d4 <lv_area_get_height>
 8015c32:	4603      	mov	r3, r0
 8015c34:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    lv_coord_t width  = lv_area_get_width(coords);
 8015c38:	68f8      	ldr	r0, [r7, #12]
 8015c3a:	f7ff fe34 	bl	80158a6 <lv_area_get_width>
 8015c3e:	4603      	mov	r3, r0
 8015c40:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8015c44:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 8015c48:	f9b7 1072 	ldrsh.w	r1, [r7, #114]	; 0x72
 8015c4c:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015c50:	4618      	mov	r0, r3
 8015c52:	f003 fcd0 	bl	80195f6 <lv_draw_cont_radius_corr>
 8015c56:	4603      	mov	r3, r0
 8015c58:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
 8015c5c:	68fb      	ldr	r3, [r7, #12]
 8015c5e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015c62:	b29a      	uxth	r2, r3
 8015c64:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015c68:	4413      	add	r3, r2
 8015c6a:	b29a      	uxth	r2, r3
 8015c6c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015c70:	b29b      	uxth	r3, r3
 8015c72:	4413      	add	r3, r2
 8015c74:	b29b      	uxth	r3, r3
 8015c76:	b21b      	sxth	r3, r3
 8015c78:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
    lt_origo.y = coords->y1 + radius + aa;
 8015c7c:	68fb      	ldr	r3, [r7, #12]
 8015c7e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015c82:	b29a      	uxth	r2, r3
 8015c84:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015c88:	4413      	add	r3, r2
 8015c8a:	b29a      	uxth	r2, r3
 8015c8c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015c90:	b29b      	uxth	r3, r3
 8015c92:	4413      	add	r3, r2
 8015c94:	b29b      	uxth	r3, r3
 8015c96:	b21b      	sxth	r3, r3
 8015c98:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

    lb_origo.x = coords->x1 + radius + aa;
 8015c9c:	68fb      	ldr	r3, [r7, #12]
 8015c9e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8015ca2:	b29a      	uxth	r2, r3
 8015ca4:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015ca8:	4413      	add	r3, r2
 8015caa:	b29a      	uxth	r2, r3
 8015cac:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015cb0:	b29b      	uxth	r3, r3
 8015cb2:	4413      	add	r3, r2
 8015cb4:	b29b      	uxth	r3, r3
 8015cb6:	b21b      	sxth	r3, r3
 8015cb8:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lb_origo.y = coords->y2 - radius - aa;
 8015cbc:	68fb      	ldr	r3, [r7, #12]
 8015cbe:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015cc2:	b29a      	uxth	r2, r3
 8015cc4:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015cc8:	1ad3      	subs	r3, r2, r3
 8015cca:	b29a      	uxth	r2, r3
 8015ccc:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015cd0:	b29b      	uxth	r3, r3
 8015cd2:	1ad3      	subs	r3, r2, r3
 8015cd4:	b29b      	uxth	r3, r3
 8015cd6:	b21b      	sxth	r3, r3
 8015cd8:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

    rt_origo.x = coords->x2 - radius - aa;
 8015cdc:	68fb      	ldr	r3, [r7, #12]
 8015cde:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015ce2:	b29a      	uxth	r2, r3
 8015ce4:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015ce8:	1ad3      	subs	r3, r2, r3
 8015cea:	b29a      	uxth	r2, r3
 8015cec:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015cf0:	b29b      	uxth	r3, r3
 8015cf2:	1ad3      	subs	r3, r2, r3
 8015cf4:	b29b      	uxth	r3, r3
 8015cf6:	b21b      	sxth	r3, r3
 8015cf8:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    rt_origo.y = coords->y1 + radius + aa;
 8015cfc:	68fb      	ldr	r3, [r7, #12]
 8015cfe:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8015d02:	b29a      	uxth	r2, r3
 8015d04:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015d08:	4413      	add	r3, r2
 8015d0a:	b29a      	uxth	r2, r3
 8015d0c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015d10:	b29b      	uxth	r3, r3
 8015d12:	4413      	add	r3, r2
 8015d14:	b29b      	uxth	r3, r3
 8015d16:	b21b      	sxth	r3, r3
 8015d18:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    rb_origo.x = coords->x2 - radius - aa;
 8015d1c:	68fb      	ldr	r3, [r7, #12]
 8015d1e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8015d22:	b29a      	uxth	r2, r3
 8015d24:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015d28:	1ad3      	subs	r3, r2, r3
 8015d2a:	b29a      	uxth	r2, r3
 8015d2c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015d30:	b29b      	uxth	r3, r3
 8015d32:	1ad3      	subs	r3, r2, r3
 8015d34:	b29b      	uxth	r3, r3
 8015d36:	b21b      	sxth	r3, r3
 8015d38:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
    rb_origo.y = coords->y2 - radius - aa;
 8015d3c:	68fb      	ldr	r3, [r7, #12]
 8015d3e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8015d42:	b29a      	uxth	r2, r3
 8015d44:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015d48:	1ad3      	subs	r3, r2, r3
 8015d4a:	b29a      	uxth	r2, r3
 8015d4c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015d50:	b29b      	uxth	r3, r3
 8015d52:	1ad3      	subs	r3, r2, r3
 8015d54:	b29b      	uxth	r3, r3
 8015d56:	b21b      	sxth	r3, r3
 8015d58:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
    lv_area_t mid_bot_area;
    lv_area_t edge_bot_area;

    lv_point_t cir;
    lv_coord_t cir_tmp;
    lv_circ_init(&cir, &cir_tmp, radius);
 8015d5c:	f9b7 2078 	ldrsh.w	r2, [r7, #120]	; 0x78
 8015d60:	f107 0126 	add.w	r1, r7, #38	; 0x26
 8015d64:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8015d68:	4618      	mov	r0, r3
 8015d6a:	f005 ffd0 	bl	801bd0e <lv_circ_init>

    /*Init the areas*/
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8015d6e:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8015d72:	b29a      	uxth	r2, r3
 8015d74:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015d78:	b29b      	uxth	r3, r3
 8015d7a:	1ad3      	subs	r3, r2, r3
 8015d7c:	b29b      	uxth	r3, r3
 8015d7e:	b219      	sxth	r1, r3
 8015d80:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8015d84:	b29a      	uxth	r2, r3
 8015d86:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015d8a:	b29b      	uxth	r3, r3
 8015d8c:	4413      	add	r3, r2
 8015d8e:	b29b      	uxth	r3, r3
 8015d90:	b21c      	sxth	r4, r3
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8015d92:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8015d96:	b29a      	uxth	r2, r3
 8015d98:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015d9c:	b29b      	uxth	r3, r3
 8015d9e:	4413      	add	r3, r2
 8015da0:	b29b      	uxth	r3, r3
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8015da2:	b21d      	sxth	r5, r3
                rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8015da4:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8015da8:	b29a      	uxth	r2, r3
 8015daa:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015dae:	b29b      	uxth	r3, r3
 8015db0:	4413      	add	r3, r2
 8015db2:	b29b      	uxth	r3, r3
    lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8015db4:	b21b      	sxth	r3, r3
 8015db6:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8015dba:	9300      	str	r3, [sp, #0]
 8015dbc:	462b      	mov	r3, r5
 8015dbe:	4622      	mov	r2, r4
 8015dc0:	f005 fdf2 	bl	801b9a8 <lv_area_set>

    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8015dc4:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8015dc8:	b29a      	uxth	r2, r3
 8015dca:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015dce:	b29b      	uxth	r3, r3
 8015dd0:	1ad3      	subs	r3, r2, r3
 8015dd2:	b29b      	uxth	r3, r3
 8015dd4:	b219      	sxth	r1, r3
 8015dd6:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8015dda:	b29a      	uxth	r2, r3
 8015ddc:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015de0:	b29b      	uxth	r3, r3
 8015de2:	4413      	add	r3, r2
 8015de4:	b29b      	uxth	r3, r3
 8015de6:	b21c      	sxth	r4, r3
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8015de8:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8015dec:	b29a      	uxth	r2, r3
 8015dee:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015df2:	b29b      	uxth	r3, r3
 8015df4:	4413      	add	r3, r2
 8015df6:	b29b      	uxth	r3, r3
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8015df8:	b21d      	sxth	r5, r3
                rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 8015dfa:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8015dfe:	b29a      	uxth	r2, r3
 8015e00:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015e04:	b29b      	uxth	r3, r3
 8015e06:	4413      	add	r3, r2
 8015e08:	b29b      	uxth	r3, r3
    lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 8015e0a:	b21b      	sxth	r3, r3
 8015e0c:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8015e10:	9300      	str	r3, [sp, #0]
 8015e12:	462b      	mov	r3, r5
 8015e14:	4622      	mov	r2, r4
 8015e16:	f005 fdc7 	bl	801b9a8 <lv_area_set>

    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8015e1a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8015e1e:	b29a      	uxth	r2, r3
 8015e20:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015e24:	b29b      	uxth	r3, r3
 8015e26:	1ad3      	subs	r3, r2, r3
 8015e28:	b29b      	uxth	r3, r3
 8015e2a:	b219      	sxth	r1, r3
 8015e2c:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8015e30:	b29a      	uxth	r2, r3
 8015e32:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015e36:	b29b      	uxth	r3, r3
 8015e38:	1ad3      	subs	r3, r2, r3
 8015e3a:	b29b      	uxth	r3, r3
 8015e3c:	b21c      	sxth	r4, r3
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8015e3e:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8015e42:	b29a      	uxth	r2, r3
 8015e44:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015e48:	b29b      	uxth	r3, r3
 8015e4a:	4413      	add	r3, r2
 8015e4c:	b29b      	uxth	r3, r3
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8015e4e:	b21d      	sxth	r5, r3
                rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8015e50:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8015e54:	b29a      	uxth	r2, r3
 8015e56:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015e5a:	b29b      	uxth	r3, r3
 8015e5c:	1ad3      	subs	r3, r2, r3
 8015e5e:	b29b      	uxth	r3, r3
    lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8015e60:	b21b      	sxth	r3, r3
 8015e62:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8015e66:	9300      	str	r3, [sp, #0]
 8015e68:	462b      	mov	r3, r5
 8015e6a:	4622      	mov	r2, r4
 8015e6c:	f005 fd9c 	bl	801b9a8 <lv_area_set>

    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8015e70:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8015e74:	b29a      	uxth	r2, r3
 8015e76:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015e7a:	b29b      	uxth	r3, r3
 8015e7c:	1ad3      	subs	r3, r2, r3
 8015e7e:	b29b      	uxth	r3, r3
 8015e80:	b219      	sxth	r1, r3
 8015e82:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8015e86:	b29a      	uxth	r2, r3
 8015e88:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015e8c:	b29b      	uxth	r3, r3
 8015e8e:	1ad3      	subs	r3, r2, r3
 8015e90:	b29b      	uxth	r3, r3
 8015e92:	b21c      	sxth	r4, r3
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 8015e94:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8015e98:	b29a      	uxth	r2, r3
 8015e9a:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8015e9e:	b29b      	uxth	r3, r3
 8015ea0:	4413      	add	r3, r2
 8015ea2:	b29b      	uxth	r3, r3
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8015ea4:	b21d      	sxth	r5, r3
                rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 8015ea6:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8015eaa:	b29a      	uxth	r2, r3
 8015eac:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015eb0:	b29b      	uxth	r3, r3
 8015eb2:	1ad3      	subs	r3, r2, r3
 8015eb4:	b29b      	uxth	r3, r3
    lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8015eb6:	b21b      	sxth	r3, r3
 8015eb8:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8015ebc:	9300      	str	r3, [sp, #0]
 8015ebe:	462b      	mov	r3, r5
 8015ec0:	4622      	mov	r2, r4
 8015ec2:	f005 fd71 	bl	801b9a8 <lv_area_set>
#if LV_ANTIALIAS
    /*Store some internal states for anti-aliasing*/
    lv_coord_t out_y_seg_start = 0;
 8015ec6:	2300      	movs	r3, #0
 8015ec8:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
    lv_coord_t out_y_seg_end   = 0;
 8015ecc:	2300      	movs	r3, #0
 8015ece:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
    lv_coord_t out_x_last      = radius;
 8015ed2:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8015ed6:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
    lv_color_t aa_color_hor_top;
    lv_color_t aa_color_hor_bottom;
    lv_color_t aa_color_ver;
#endif

    while(lv_circ_cont(&cir)) {
 8015eda:	e367      	b.n	80165ac <lv_draw_rect_main_corner+0x9e0>
#if LV_ANTIALIAS
        if(aa) {
 8015edc:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8015ee0:	2b00      	cmp	r3, #0
 8015ee2:	f000 8197 	beq.w	8016214 <lv_draw_rect_main_corner+0x648>
            /*New step in y on the outter circle*/
            if(out_x_last != cir.x) {
 8015ee6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8015eea:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8015eee:	429a      	cmp	r2, r3
 8015ef0:	f000 8190 	beq.w	8016214 <lv_draw_rect_main_corner+0x648>
                out_y_seg_end       = cir.y;
 8015ef4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8015ef6:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
                lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 8015efa:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 8015efe:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8015f02:	1ad3      	subs	r3, r2, r3
 8015f04:	b29b      	uxth	r3, r3
 8015f06:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
                lv_point_t aa_p;

                aa_p.x = out_x_last;
 8015f0a:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8015f0e:	833b      	strh	r3, [r7, #24]
                aa_p.y = out_y_seg_start;
 8015f10:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8015f14:	837b      	strh	r3, [r7, #26]

                mix                 = (uint32_t)((uint32_t)(radius - out_x_last) * 255) / height;
 8015f16:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 8015f1a:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8015f1e:	1ad3      	subs	r3, r2, r3
 8015f20:	461a      	mov	r2, r3
 8015f22:	4613      	mov	r3, r2
 8015f24:	021b      	lsls	r3, r3, #8
 8015f26:	1a9a      	subs	r2, r3, r2
 8015f28:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8015f2c:	fbb2 f3f3 	udiv	r3, r2, r3
 8015f30:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                aa_color_hor_top    = lv_color_mix(gcolor, mcolor, mix);
 8015f34:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8015f38:	461a      	mov	r2, r3
 8015f3a:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8015f3e:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8015f42:	f7ff fc31 	bl	80157a8 <lv_color_mix>
 8015f46:	4603      	mov	r3, r0
 8015f48:	84bb      	strh	r3, [r7, #36]	; 0x24
                aa_color_hor_bottom = lv_color_mix(mcolor, gcolor, mix);
 8015f4a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8015f4e:	461a      	mov	r2, r3
 8015f50:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8015f54:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8015f58:	f7ff fc26 	bl	80157a8 <lv_color_mix>
 8015f5c:	4603      	mov	r3, r0
 8015f5e:	843b      	strh	r3, [r7, #32]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8015f60:	2300      	movs	r3, #0
 8015f62:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
 8015f66:	e147      	b.n	80161f8 <lv_draw_rect_main_corner+0x62c>
                    lv_opa_t aa_opa;
                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 8015f68:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8015f6c:	2b01      	cmp	r3, #1
 8015f6e:	dd0c      	ble.n	8015f8a <lv_draw_rect_main_corner+0x3be>
                                                                           on the first segment*/
                        aa_opa = antialias_get_opa_circ(seg_size, i, opa);
 8015f70:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 8015f74:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8015f78:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8015f7c:	4618      	mov	r0, r3
 8015f7e:	f003 fb7d 	bl	801967c <antialias_get_opa_circ>
 8015f82:	4603      	mov	r3, r0
 8015f84:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
 8015f88:	e00f      	b.n	8015faa <lv_draw_rect_main_corner+0x3de>
                    } else {
                        aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 8015f8a:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 8015f8e:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8015f92:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8015f96:	4618      	mov	r0, r3
 8015f98:	f7fe f8c6 	bl	8014128 <lv_draw_aa_get_opa>
 8015f9c:	4603      	mov	r3, r0
 8015f9e:	461a      	mov	r2, r3
 8015fa0:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8015fa4:	1a9b      	subs	r3, r3, r2
 8015fa6:	f887 3081 	strb.w	r3, [r7, #129]	; 0x81
                    }

                    lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 8015faa:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8015fae:	b29a      	uxth	r2, r3
 8015fb0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015fb4:	b29b      	uxth	r3, r3
 8015fb6:	4413      	add	r3, r2
 8015fb8:	b29a      	uxth	r2, r3
 8015fba:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8015fbe:	4413      	add	r3, r2
 8015fc0:	b29b      	uxth	r3, r3
 8015fc2:	b218      	sxth	r0, r3
 8015fc4:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8015fc8:	b29a      	uxth	r2, r3
 8015fca:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8015fce:	b29b      	uxth	r3, r3
 8015fd0:	4413      	add	r3, r2
 8015fd2:	b29b      	uxth	r3, r3
 8015fd4:	3301      	adds	r3, #1
 8015fd6:	b29b      	uxth	r3, r3
 8015fd8:	b219      	sxth	r1, r3
 8015fda:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8015fde:	9300      	str	r3, [sp, #0]
 8015fe0:	8c3b      	ldrh	r3, [r7, #32]
 8015fe2:	68ba      	ldr	r2, [r7, #8]
 8015fe4:	f7fe f979 	bl	80142da <lv_draw_px>
                               aa_color_hor_bottom, aa_opa);
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 8015fe8:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8015fec:	b29a      	uxth	r2, r3
 8015fee:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8015ff2:	b29b      	uxth	r3, r3
 8015ff4:	1ad3      	subs	r3, r2, r3
 8015ff6:	b29a      	uxth	r2, r3
 8015ff8:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8015ffc:	1ad3      	subs	r3, r2, r3
 8015ffe:	b29b      	uxth	r3, r3
 8016000:	b218      	sxth	r0, r3
 8016002:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8016006:	b29a      	uxth	r2, r3
 8016008:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801600c:	b29b      	uxth	r3, r3
 801600e:	4413      	add	r3, r2
 8016010:	b29b      	uxth	r3, r3
 8016012:	3301      	adds	r3, #1
 8016014:	b29b      	uxth	r3, r3
 8016016:	b219      	sxth	r1, r3
 8016018:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 801601c:	9300      	str	r3, [sp, #0]
 801601e:	8c3b      	ldrh	r3, [r7, #32]
 8016020:	68ba      	ldr	r2, [r7, #8]
 8016022:	f7fe f95a 	bl	80142da <lv_draw_px>
                               aa_color_hor_bottom, aa_opa);
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 8016026:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801602a:	b29a      	uxth	r2, r3
 801602c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8016030:	b29b      	uxth	r3, r3
 8016032:	1ad3      	subs	r3, r2, r3
 8016034:	b29a      	uxth	r2, r3
 8016036:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 801603a:	1ad3      	subs	r3, r2, r3
 801603c:	b29b      	uxth	r3, r3
 801603e:	b218      	sxth	r0, r3
 8016040:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8016044:	b29a      	uxth	r2, r3
 8016046:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801604a:	b29b      	uxth	r3, r3
 801604c:	1ad3      	subs	r3, r2, r3
 801604e:	b29b      	uxth	r3, r3
 8016050:	3b01      	subs	r3, #1
 8016052:	b29b      	uxth	r3, r3
 8016054:	b219      	sxth	r1, r3
 8016056:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 801605a:	9300      	str	r3, [sp, #0]
 801605c:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801605e:	68ba      	ldr	r2, [r7, #8]
 8016060:	f7fe f93b 	bl	80142da <lv_draw_px>
                               aa_color_hor_top, aa_opa);
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 8016064:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8016068:	b29a      	uxth	r2, r3
 801606a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801606e:	b29b      	uxth	r3, r3
 8016070:	4413      	add	r3, r2
 8016072:	b29a      	uxth	r2, r3
 8016074:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8016078:	4413      	add	r3, r2
 801607a:	b29b      	uxth	r3, r3
 801607c:	b218      	sxth	r0, r3
 801607e:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8016082:	b29a      	uxth	r2, r3
 8016084:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8016088:	b29b      	uxth	r3, r3
 801608a:	1ad3      	subs	r3, r2, r3
 801608c:	b29b      	uxth	r3, r3
 801608e:	3b01      	subs	r3, #1
 8016090:	b29b      	uxth	r3, r3
 8016092:	b219      	sxth	r1, r3
 8016094:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8016098:	9300      	str	r3, [sp, #0]
 801609a:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 801609c:	68ba      	ldr	r2, [r7, #8]
 801609e:	f7fe f91c 	bl	80142da <lv_draw_px>
                               aa_color_hor_top, aa_opa);

                    mix          = (uint32_t)((uint32_t)(radius - out_y_seg_start + i) * 255) / height;
 80160a2:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 80160a6:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 80160aa:	1ad2      	subs	r2, r2, r3
 80160ac:	f9b7 3082 	ldrsh.w	r3, [r7, #130]	; 0x82
 80160b0:	4413      	add	r3, r2
 80160b2:	461a      	mov	r2, r3
 80160b4:	4613      	mov	r3, r2
 80160b6:	021b      	lsls	r3, r3, #8
 80160b8:	1a9a      	subs	r2, r3, r2
 80160ba:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80160be:	fbb2 f3f3 	udiv	r3, r2, r3
 80160c2:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                    aa_color_ver = lv_color_mix(mcolor, gcolor, mix);
 80160c6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80160ca:	461a      	mov	r2, r3
 80160cc:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80160d0:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80160d4:	f7ff fb68 	bl	80157a8 <lv_color_mix>
 80160d8:	4603      	mov	r3, r0
 80160da:	83bb      	strh	r3, [r7, #28]
                    lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 80160dc:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 80160e0:	b29a      	uxth	r2, r3
 80160e2:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80160e6:	b29b      	uxth	r3, r3
 80160e8:	4413      	add	r3, r2
 80160ea:	b29b      	uxth	r3, r3
 80160ec:	3301      	adds	r3, #1
 80160ee:	b29b      	uxth	r3, r3
 80160f0:	b218      	sxth	r0, r3
 80160f2:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80160f6:	b29a      	uxth	r2, r3
 80160f8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80160fc:	b29b      	uxth	r3, r3
 80160fe:	4413      	add	r3, r2
 8016100:	b29a      	uxth	r2, r3
 8016102:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8016106:	4413      	add	r3, r2
 8016108:	b29b      	uxth	r3, r3
 801610a:	b219      	sxth	r1, r3
 801610c:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 8016110:	9300      	str	r3, [sp, #0]
 8016112:	8bbb      	ldrh	r3, [r7, #28]
 8016114:	68ba      	ldr	r2, [r7, #8]
 8016116:	f7fe f8e0 	bl	80142da <lv_draw_px>
                               aa_color_ver, aa_opa);
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 801611a:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801611e:	b29a      	uxth	r2, r3
 8016120:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8016124:	b29b      	uxth	r3, r3
 8016126:	1ad3      	subs	r3, r2, r3
 8016128:	b29b      	uxth	r3, r3
 801612a:	3b01      	subs	r3, #1
 801612c:	b29b      	uxth	r3, r3
 801612e:	b218      	sxth	r0, r3
 8016130:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8016134:	b29a      	uxth	r2, r3
 8016136:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801613a:	b29b      	uxth	r3, r3
 801613c:	4413      	add	r3, r2
 801613e:	b29a      	uxth	r2, r3
 8016140:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8016144:	4413      	add	r3, r2
 8016146:	b29b      	uxth	r3, r3
 8016148:	b219      	sxth	r1, r3
 801614a:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 801614e:	9300      	str	r3, [sp, #0]
 8016150:	8bbb      	ldrh	r3, [r7, #28]
 8016152:	68ba      	ldr	r2, [r7, #8]
 8016154:	f7fe f8c1 	bl	80142da <lv_draw_px>
                               aa_color_ver, aa_opa);

                    aa_color_ver = lv_color_mix(gcolor, mcolor, mix);
 8016158:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801615c:	461a      	mov	r2, r3
 801615e:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8016162:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8016166:	f7ff fb1f 	bl	80157a8 <lv_color_mix>
 801616a:	4603      	mov	r3, r0
 801616c:	83bb      	strh	r3, [r7, #28]
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 801616e:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8016172:	b29a      	uxth	r2, r3
 8016174:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8016178:	b29b      	uxth	r3, r3
 801617a:	1ad3      	subs	r3, r2, r3
 801617c:	b29b      	uxth	r3, r3
 801617e:	3b01      	subs	r3, #1
 8016180:	b29b      	uxth	r3, r3
 8016182:	b218      	sxth	r0, r3
 8016184:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8016188:	b29a      	uxth	r2, r3
 801618a:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801618e:	b29b      	uxth	r3, r3
 8016190:	1ad3      	subs	r3, r2, r3
 8016192:	b29a      	uxth	r2, r3
 8016194:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 8016198:	1ad3      	subs	r3, r2, r3
 801619a:	b29b      	uxth	r3, r3
 801619c:	b219      	sxth	r1, r3
 801619e:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80161a2:	9300      	str	r3, [sp, #0]
 80161a4:	8bbb      	ldrh	r3, [r7, #28]
 80161a6:	68ba      	ldr	r2, [r7, #8]
 80161a8:	f7fe f897 	bl	80142da <lv_draw_px>
                               aa_color_ver, aa_opa);
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 80161ac:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 80161b0:	b29a      	uxth	r2, r3
 80161b2:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80161b6:	b29b      	uxth	r3, r3
 80161b8:	4413      	add	r3, r2
 80161ba:	b29b      	uxth	r3, r3
 80161bc:	3301      	adds	r3, #1
 80161be:	b29b      	uxth	r3, r3
 80161c0:	b218      	sxth	r0, r3
 80161c2:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80161c6:	b29a      	uxth	r2, r3
 80161c8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80161cc:	b29b      	uxth	r3, r3
 80161ce:	1ad3      	subs	r3, r2, r3
 80161d0:	b29a      	uxth	r2, r3
 80161d2:	f8b7 3082 	ldrh.w	r3, [r7, #130]	; 0x82
 80161d6:	1ad3      	subs	r3, r2, r3
 80161d8:	b29b      	uxth	r3, r3
 80161da:	b219      	sxth	r1, r3
 80161dc:	f897 3081 	ldrb.w	r3, [r7, #129]	; 0x81
 80161e0:	9300      	str	r3, [sp, #0]
 80161e2:	8bbb      	ldrh	r3, [r7, #28]
 80161e4:	68ba      	ldr	r2, [r7, #8]
 80161e6:	f7fe f878 	bl	80142da <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 80161ea:	f9b7 3082 	ldrsh.w	r3, [r7, #130]	; 0x82
 80161ee:	b29b      	uxth	r3, r3
 80161f0:	3301      	adds	r3, #1
 80161f2:	b29b      	uxth	r3, r3
 80161f4:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82
 80161f8:	f9b7 2082 	ldrsh.w	r2, [r7, #130]	; 0x82
 80161fc:	f9b7 3068 	ldrsh.w	r3, [r7, #104]	; 0x68
 8016200:	429a      	cmp	r2, r3
 8016202:	f6ff aeb1 	blt.w	8015f68 <lv_draw_rect_main_corner+0x39c>
                               aa_color_ver, aa_opa);
                }

                out_x_last      = cir.x;
 8016206:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8016208:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
                out_y_seg_start = out_y_seg_end;
 801620c:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8016210:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86
            }
        }
#endif
        uint8_t edge_top_refr = 0;
 8016214:	2300      	movs	r3, #0
 8016216:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80
        uint8_t mid_top_refr  = 0;
 801621a:	2300      	movs	r3, #0
 801621c:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
        uint8_t mid_bot_refr  = 0;
 8016220:	2300      	movs	r3, #0
 8016222:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e
        uint8_t edge_bot_refr = 0;
 8016226:	2300      	movs	r3, #0
 8016228:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d

        /* If a new row coming draw the previous
         * The y coordinate can remain the same so wait for a new*/
        if(mid_bot_area.y1 != LV_CIRC_OCT4_Y(cir) + lb_origo.y) mid_bot_refr = 1;
 801622c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8016230:	461a      	mov	r2, r3
 8016232:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016236:	4619      	mov	r1, r3
 8016238:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801623c:	440b      	add	r3, r1
 801623e:	429a      	cmp	r2, r3
 8016240:	d002      	beq.n	8016248 <lv_draw_rect_main_corner+0x67c>
 8016242:	2301      	movs	r3, #1
 8016244:	f887 307e 	strb.w	r3, [r7, #126]	; 0x7e

        if(edge_bot_area.y1 != LV_CIRC_OCT2_Y(cir) + lb_origo.y) edge_bot_refr = 1;
 8016248:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 801624c:	461a      	mov	r2, r3
 801624e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8016252:	4619      	mov	r1, r3
 8016254:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8016258:	440b      	add	r3, r1
 801625a:	429a      	cmp	r2, r3
 801625c:	d002      	beq.n	8016264 <lv_draw_rect_main_corner+0x698>
 801625e:	2301      	movs	r3, #1
 8016260:	f887 307d 	strb.w	r3, [r7, #125]	; 0x7d

        if(mid_top_area.y1 != LV_CIRC_OCT8_Y(cir) + lt_origo.y) mid_top_refr = 1;
 8016264:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8016268:	461a      	mov	r2, r3
 801626a:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801626e:	4619      	mov	r1, r3
 8016270:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016274:	1acb      	subs	r3, r1, r3
 8016276:	429a      	cmp	r2, r3
 8016278:	d002      	beq.n	8016280 <lv_draw_rect_main_corner+0x6b4>
 801627a:	2301      	movs	r3, #1
 801627c:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f

        if(edge_top_area.y1 != LV_CIRC_OCT7_Y(cir) + lt_origo.y) edge_top_refr = 1;
 8016280:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8016284:	461a      	mov	r2, r3
 8016286:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801628a:	4619      	mov	r1, r3
 801628c:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8016290:	1acb      	subs	r3, r1, r3
 8016292:	429a      	cmp	r2, r3
 8016294:	d002      	beq.n	801629c <lv_draw_rect_main_corner+0x6d0>
 8016296:	2301      	movs	r3, #1
 8016298:	f887 3080 	strb.w	r3, [r7, #128]	; 0x80

        /*Draw the areas which are not disabled*/
        if(edge_top_refr != 0) {
 801629c:	f897 3080 	ldrb.w	r3, [r7, #128]	; 0x80
 80162a0:	2b00      	cmp	r3, #0
 80162a2:	d030      	beq.n	8016306 <lv_draw_rect_main_corner+0x73a>
            if(mcolor.full == gcolor.full)
 80162a4:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80162a8:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80162ac:	429a      	cmp	r2, r3
 80162ae:	d104      	bne.n	80162ba <lv_draw_rect_main_corner+0x6ee>
                act_color = mcolor;
 80162b0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80162b4:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80162b8:	e01c      	b.n	80162f4 <lv_draw_rect_main_corner+0x728>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
 80162ba:	68fb      	ldr	r3, [r7, #12]
 80162bc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80162c0:	461a      	mov	r2, r3
 80162c2:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80162c6:	1ad3      	subs	r3, r2, r3
 80162c8:	461a      	mov	r2, r3
 80162ca:	4613      	mov	r3, r2
 80162cc:	021b      	lsls	r3, r3, #8
 80162ce:	1a9a      	subs	r2, r3, r2
 80162d0:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80162d4:	fbb2 f3f3 	udiv	r3, r2, r3
 80162d8:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 80162dc:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80162e0:	461a      	mov	r2, r3
 80162e2:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80162e6:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80162ea:	f7ff fa5d 	bl	80157a8 <lv_color_mix>
 80162ee:	4603      	mov	r3, r0
 80162f0:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&edge_top_area, mask, act_color, opa);
 80162f4:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80162f8:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80162fc:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8016300:	68b9      	ldr	r1, [r7, #8]
 8016302:	f7fe f883 	bl	801440c <lv_draw_fill>
        }

        if(mid_top_refr != 0) {
 8016306:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 801630a:	2b00      	cmp	r3, #0
 801630c:	d030      	beq.n	8016370 <lv_draw_rect_main_corner+0x7a4>
            if(mcolor.full == gcolor.full)
 801630e:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8016312:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8016316:	429a      	cmp	r2, r3
 8016318:	d104      	bne.n	8016324 <lv_draw_rect_main_corner+0x758>
                act_color = mcolor;
 801631a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801631e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8016322:	e01c      	b.n	801635e <lv_draw_rect_main_corner+0x792>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
 8016324:	68fb      	ldr	r3, [r7, #12]
 8016326:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801632a:	461a      	mov	r2, r3
 801632c:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8016330:	1ad3      	subs	r3, r2, r3
 8016332:	461a      	mov	r2, r3
 8016334:	4613      	mov	r3, r2
 8016336:	021b      	lsls	r3, r3, #8
 8016338:	1a9a      	subs	r2, r3, r2
 801633a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801633e:	fbb2 f3f3 	udiv	r3, r2, r3
 8016342:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 8016346:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801634a:	461a      	mov	r2, r3
 801634c:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8016350:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8016354:	f7ff fa28 	bl	80157a8 <lv_color_mix>
 8016358:	4603      	mov	r3, r0
 801635a:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&mid_top_area, mask, act_color, opa);
 801635e:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016362:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8016366:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801636a:	68b9      	ldr	r1, [r7, #8]
 801636c:	f7fe f84e 	bl	801440c <lv_draw_fill>
        }

        if(mid_bot_refr != 0) {
 8016370:	f897 307e 	ldrb.w	r3, [r7, #126]	; 0x7e
 8016374:	2b00      	cmp	r3, #0
 8016376:	d030      	beq.n	80163da <lv_draw_rect_main_corner+0x80e>
            if(mcolor.full == gcolor.full)
 8016378:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 801637c:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8016380:	429a      	cmp	r2, r3
 8016382:	d104      	bne.n	801638e <lv_draw_rect_main_corner+0x7c2>
                act_color = mcolor;
 8016384:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8016388:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 801638c:	e01c      	b.n	80163c8 <lv_draw_rect_main_corner+0x7fc>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
 801638e:	68fb      	ldr	r3, [r7, #12]
 8016390:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016394:	461a      	mov	r2, r3
 8016396:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801639a:	1ad3      	subs	r3, r2, r3
 801639c:	461a      	mov	r2, r3
 801639e:	4613      	mov	r3, r2
 80163a0:	021b      	lsls	r3, r3, #8
 80163a2:	1a9a      	subs	r2, r3, r2
 80163a4:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80163a8:	fbb2 f3f3 	udiv	r3, r2, r3
 80163ac:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 80163b0:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80163b4:	461a      	mov	r2, r3
 80163b6:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80163ba:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80163be:	f7ff f9f3 	bl	80157a8 <lv_color_mix>
 80163c2:	4603      	mov	r3, r0
 80163c4:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&mid_bot_area, mask, act_color, opa);
 80163c8:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80163cc:	f107 0034 	add.w	r0, r7, #52	; 0x34
 80163d0:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80163d4:	68b9      	ldr	r1, [r7, #8]
 80163d6:	f7fe f819 	bl	801440c <lv_draw_fill>
        }

        if(edge_bot_refr != 0) {
 80163da:	f897 307d 	ldrb.w	r3, [r7, #125]	; 0x7d
 80163de:	2b00      	cmp	r3, #0
 80163e0:	d030      	beq.n	8016444 <lv_draw_rect_main_corner+0x878>

            if(mcolor.full == gcolor.full)
 80163e2:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80163e6:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80163ea:	429a      	cmp	r2, r3
 80163ec:	d104      	bne.n	80163f8 <lv_draw_rect_main_corner+0x82c>
                act_color = mcolor;
 80163ee:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80163f2:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80163f6:	e01c      	b.n	8016432 <lv_draw_rect_main_corner+0x866>
            else {
                mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
 80163f8:	68fb      	ldr	r3, [r7, #12]
 80163fa:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80163fe:	461a      	mov	r2, r3
 8016400:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8016404:	1ad3      	subs	r3, r2, r3
 8016406:	461a      	mov	r2, r3
 8016408:	4613      	mov	r3, r2
 801640a:	021b      	lsls	r3, r3, #8
 801640c:	1a9a      	subs	r2, r3, r2
 801640e:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8016412:	fbb2 f3f3 	udiv	r3, r2, r3
 8016416:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
                act_color = lv_color_mix(mcolor, gcolor, mix);
 801641a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801641e:	461a      	mov	r2, r3
 8016420:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8016424:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8016428:	f7ff f9be 	bl	80157a8 <lv_color_mix>
 801642c:	4603      	mov	r3, r0
 801642e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            lv_draw_fill(&edge_bot_area, mask, act_color, opa);
 8016432:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016436:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 801643a:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801643e:	68b9      	ldr	r1, [r7, #8]
 8016440:	f7fd ffe4 	bl	801440c <lv_draw_fill>
        }

        /*Save the current coordinates*/
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8016444:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8016448:	b29a      	uxth	r2, r3
 801644a:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801644e:	b29b      	uxth	r3, r3
 8016450:	1ad3      	subs	r3, r2, r3
 8016452:	b29b      	uxth	r3, r3
 8016454:	b219      	sxth	r1, r3
 8016456:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801645a:	b29a      	uxth	r2, r3
 801645c:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016460:	b29b      	uxth	r3, r3
 8016462:	4413      	add	r3, r2
 8016464:	b29b      	uxth	r3, r3
 8016466:	b21c      	sxth	r4, r3
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 8016468:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801646c:	b29a      	uxth	r2, r3
 801646e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8016472:	b29b      	uxth	r3, r3
 8016474:	4413      	add	r3, r2
 8016476:	b29b      	uxth	r3, r3
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 8016478:	b21d      	sxth	r5, r3
                    rb_origo.x + LV_CIRC_OCT1_X(cir), rb_origo.y + LV_CIRC_OCT1_Y(cir));
 801647a:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801647e:	b29a      	uxth	r2, r3
 8016480:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016484:	b29b      	uxth	r3, r3
 8016486:	4413      	add	r3, r2
 8016488:	b29b      	uxth	r3, r3
        lv_area_set(&mid_bot_area, lb_origo.x + LV_CIRC_OCT4_X(cir), lb_origo.y + LV_CIRC_OCT4_Y(cir),
 801648a:	b21b      	sxth	r3, r3
 801648c:	f107 0034 	add.w	r0, r7, #52	; 0x34
 8016490:	9300      	str	r3, [sp, #0]
 8016492:	462b      	mov	r3, r5
 8016494:	4622      	mov	r2, r4
 8016496:	f005 fa87 	bl	801b9a8 <lv_area_set>

        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 801649a:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801649e:	b29a      	uxth	r2, r3
 80164a0:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80164a4:	b29b      	uxth	r3, r3
 80164a6:	1ad3      	subs	r3, r2, r3
 80164a8:	b29b      	uxth	r3, r3
 80164aa:	b219      	sxth	r1, r3
 80164ac:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80164b0:	b29a      	uxth	r2, r3
 80164b2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80164b6:	b29b      	uxth	r3, r3
 80164b8:	4413      	add	r3, r2
 80164ba:	b29b      	uxth	r3, r3
 80164bc:	b21c      	sxth	r4, r3
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 80164be:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 80164c2:	b29a      	uxth	r2, r3
 80164c4:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 80164c8:	b29b      	uxth	r3, r3
 80164ca:	4413      	add	r3, r2
 80164cc:	b29b      	uxth	r3, r3
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 80164ce:	b21d      	sxth	r5, r3
                    rb_origo.x + LV_CIRC_OCT2_X(cir), rb_origo.y + LV_CIRC_OCT2_Y(cir));
 80164d0:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80164d4:	b29a      	uxth	r2, r3
 80164d6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80164da:	b29b      	uxth	r3, r3
 80164dc:	4413      	add	r3, r2
 80164de:	b29b      	uxth	r3, r3
        lv_area_set(&edge_bot_area, lb_origo.x + LV_CIRC_OCT3_X(cir), lb_origo.y + LV_CIRC_OCT3_Y(cir),
 80164e0:	b21b      	sxth	r3, r3
 80164e2:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 80164e6:	9300      	str	r3, [sp, #0]
 80164e8:	462b      	mov	r3, r5
 80164ea:	4622      	mov	r2, r4
 80164ec:	f005 fa5c 	bl	801b9a8 <lv_area_set>

        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 80164f0:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80164f4:	b29a      	uxth	r2, r3
 80164f6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80164fa:	b29b      	uxth	r3, r3
 80164fc:	1ad3      	subs	r3, r2, r3
 80164fe:	b29b      	uxth	r3, r3
 8016500:	b219      	sxth	r1, r3
 8016502:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8016506:	b29a      	uxth	r2, r3
 8016508:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801650c:	b29b      	uxth	r3, r3
 801650e:	1ad3      	subs	r3, r2, r3
 8016510:	b29b      	uxth	r3, r3
 8016512:	b21c      	sxth	r4, r3
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8016514:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8016518:	b29a      	uxth	r2, r3
 801651a:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801651e:	b29b      	uxth	r3, r3
 8016520:	4413      	add	r3, r2
 8016522:	b29b      	uxth	r3, r3
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8016524:	b21d      	sxth	r5, r3
                    rt_origo.x + LV_CIRC_OCT8_X(cir), rt_origo.y + LV_CIRC_OCT8_Y(cir));
 8016526:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801652a:	b29a      	uxth	r2, r3
 801652c:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016530:	b29b      	uxth	r3, r3
 8016532:	1ad3      	subs	r3, r2, r3
 8016534:	b29b      	uxth	r3, r3
        lv_area_set(&mid_top_area, lt_origo.x + LV_CIRC_OCT5_X(cir), lt_origo.y + LV_CIRC_OCT5_Y(cir),
 8016536:	b21b      	sxth	r3, r3
 8016538:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 801653c:	9300      	str	r3, [sp, #0]
 801653e:	462b      	mov	r3, r5
 8016540:	4622      	mov	r2, r4
 8016542:	f005 fa31 	bl	801b9a8 <lv_area_set>

        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 8016546:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 801654a:	b29a      	uxth	r2, r3
 801654c:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016550:	b29b      	uxth	r3, r3
 8016552:	1ad3      	subs	r3, r2, r3
 8016554:	b29b      	uxth	r3, r3
 8016556:	b219      	sxth	r1, r3
 8016558:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801655c:	b29a      	uxth	r2, r3
 801655e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8016562:	b29b      	uxth	r3, r3
 8016564:	1ad3      	subs	r3, r2, r3
 8016566:	b29b      	uxth	r3, r3
 8016568:	b21c      	sxth	r4, r3
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 801656a:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 801656e:	b29a      	uxth	r2, r3
 8016570:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8016574:	b29b      	uxth	r3, r3
 8016576:	4413      	add	r3, r2
 8016578:	b29b      	uxth	r3, r3
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 801657a:	b21d      	sxth	r5, r3
                    rt_origo.x + LV_CIRC_OCT7_X(cir), rt_origo.y + LV_CIRC_OCT7_Y(cir));
 801657c:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8016580:	b29a      	uxth	r2, r3
 8016582:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8016586:	b29b      	uxth	r3, r3
 8016588:	1ad3      	subs	r3, r2, r3
 801658a:	b29b      	uxth	r3, r3
        lv_area_set(&edge_top_area, lt_origo.x + LV_CIRC_OCT6_X(cir), lt_origo.y + LV_CIRC_OCT6_Y(cir),
 801658c:	b21b      	sxth	r3, r3
 801658e:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8016592:	9300      	str	r3, [sp, #0]
 8016594:	462b      	mov	r3, r5
 8016596:	4622      	mov	r2, r4
 8016598:	f005 fa06 	bl	801b9a8 <lv_area_set>

        lv_circ_next(&cir, &cir_tmp);
 801659c:	f107 0226 	add.w	r2, r7, #38	; 0x26
 80165a0:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80165a4:	4611      	mov	r1, r2
 80165a6:	4618      	mov	r0, r3
 80165a8:	f005 fbe0 	bl	801bd6c <lv_circ_next>
    while(lv_circ_cont(&cir)) {
 80165ac:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80165b0:	4618      	mov	r0, r3
 80165b2:	f005 fbc6 	bl	801bd42 <lv_circ_cont>
 80165b6:	4603      	mov	r3, r0
 80165b8:	2b00      	cmp	r3, #0
 80165ba:	f47f ac8f 	bne.w	8015edc <lv_draw_rect_main_corner+0x310>
    }

    if(mcolor.full == gcolor.full)
 80165be:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 80165c2:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 80165c6:	429a      	cmp	r2, r3
 80165c8:	d104      	bne.n	80165d4 <lv_draw_rect_main_corner+0xa08>
        act_color = mcolor;
 80165ca:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 80165ce:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80165d2:	e01c      	b.n	801660e <lv_draw_rect_main_corner+0xa42>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - edge_top_area.y1) * 255) / height;
 80165d4:	68fb      	ldr	r3, [r7, #12]
 80165d6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80165da:	461a      	mov	r2, r3
 80165dc:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80165e0:	1ad3      	subs	r3, r2, r3
 80165e2:	461a      	mov	r2, r3
 80165e4:	4613      	mov	r3, r2
 80165e6:	021b      	lsls	r3, r3, #8
 80165e8:	1a9a      	subs	r2, r3, r2
 80165ea:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80165ee:	fbb2 f3f3 	udiv	r3, r2, r3
 80165f2:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        act_color = lv_color_mix(mcolor, gcolor, mix);
 80165f6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80165fa:	461a      	mov	r2, r3
 80165fc:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8016600:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8016604:	f7ff f8d0 	bl	80157a8 <lv_color_mix>
 8016608:	4603      	mov	r3, r0
 801660a:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    }
    lv_draw_fill(&edge_top_area, mask, act_color, opa);
 801660e:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016612:	f107 0044 	add.w	r0, r7, #68	; 0x44
 8016616:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 801661a:	68b9      	ldr	r1, [r7, #8]
 801661c:	f7fd fef6 	bl	801440c <lv_draw_fill>

    if(edge_top_area.y1 != mid_top_area.y1) {
 8016620:	f9b7 2046 	ldrsh.w	r2, [r7, #70]	; 0x46
 8016624:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8016628:	429a      	cmp	r2, r3
 801662a:	d030      	beq.n	801668e <lv_draw_rect_main_corner+0xac2>

        if(mcolor.full == gcolor.full)
 801662c:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8016630:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8016634:	429a      	cmp	r2, r3
 8016636:	d104      	bne.n	8016642 <lv_draw_rect_main_corner+0xa76>
            act_color = mcolor;
 8016638:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801663c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8016640:	e01c      	b.n	801667c <lv_draw_rect_main_corner+0xab0>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - mid_top_area.y1) * 255) / height;
 8016642:	68fb      	ldr	r3, [r7, #12]
 8016644:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016648:	461a      	mov	r2, r3
 801664a:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801664e:	1ad3      	subs	r3, r2, r3
 8016650:	461a      	mov	r2, r3
 8016652:	4613      	mov	r3, r2
 8016654:	021b      	lsls	r3, r3, #8
 8016656:	1a9a      	subs	r2, r3, r2
 8016658:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801665c:	fbb2 f3f3 	udiv	r3, r2, r3
 8016660:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            act_color = lv_color_mix(mcolor, gcolor, mix);
 8016664:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8016668:	461a      	mov	r2, r3
 801666a:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 801666e:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8016672:	f7ff f899 	bl	80157a8 <lv_color_mix>
 8016676:	4603      	mov	r3, r0
 8016678:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        }
        lv_draw_fill(&mid_top_area, mask, act_color, opa);
 801667c:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016680:	f107 003c 	add.w	r0, r7, #60	; 0x3c
 8016684:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8016688:	68b9      	ldr	r1, [r7, #8]
 801668a:	f7fd febf 	bl	801440c <lv_draw_fill>
    }

    if(mcolor.full == gcolor.full)
 801668e:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8016692:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8016696:	429a      	cmp	r2, r3
 8016698:	d104      	bne.n	80166a4 <lv_draw_rect_main_corner+0xad8>
        act_color = mcolor;
 801669a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801669e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 80166a2:	e01c      	b.n	80166de <lv_draw_rect_main_corner+0xb12>
    else {
        mix       = (uint32_t)((uint32_t)(coords->y2 - mid_bot_area.y1) * 255) / height;
 80166a4:	68fb      	ldr	r3, [r7, #12]
 80166a6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80166aa:	461a      	mov	r2, r3
 80166ac:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80166b0:	1ad3      	subs	r3, r2, r3
 80166b2:	461a      	mov	r2, r3
 80166b4:	4613      	mov	r3, r2
 80166b6:	021b      	lsls	r3, r3, #8
 80166b8:	1a9a      	subs	r2, r3, r2
 80166ba:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80166be:	fbb2 f3f3 	udiv	r3, r2, r3
 80166c2:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        act_color = lv_color_mix(mcolor, gcolor, mix);
 80166c6:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 80166ca:	461a      	mov	r2, r3
 80166cc:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80166d0:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80166d4:	f7ff f868 	bl	80157a8 <lv_color_mix>
 80166d8:	4603      	mov	r3, r0
 80166da:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    }
    lv_draw_fill(&mid_bot_area, mask, act_color, opa);
 80166de:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80166e2:	f107 0034 	add.w	r0, r7, #52	; 0x34
 80166e6:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 80166ea:	68b9      	ldr	r1, [r7, #8]
 80166ec:	f7fd fe8e 	bl	801440c <lv_draw_fill>

    if(edge_bot_area.y1 != mid_bot_area.y1) {
 80166f0:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 80166f4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80166f8:	429a      	cmp	r2, r3
 80166fa:	d030      	beq.n	801675e <lv_draw_rect_main_corner+0xb92>

        if(mcolor.full == gcolor.full)
 80166fc:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8016700:	f8b7 3060 	ldrh.w	r3, [r7, #96]	; 0x60
 8016704:	429a      	cmp	r2, r3
 8016706:	d104      	bne.n	8016712 <lv_draw_rect_main_corner+0xb46>
            act_color = mcolor;
 8016708:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 801670c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8016710:	e01c      	b.n	801674c <lv_draw_rect_main_corner+0xb80>
        else {
            mix       = (uint32_t)((uint32_t)(coords->y2 - edge_bot_area.y1) * 255) / height;
 8016712:	68fb      	ldr	r3, [r7, #12]
 8016714:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016718:	461a      	mov	r2, r3
 801671a:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 801671e:	1ad3      	subs	r3, r2, r3
 8016720:	461a      	mov	r2, r3
 8016722:	4613      	mov	r3, r2
 8016724:	021b      	lsls	r3, r3, #8
 8016726:	1a9a      	subs	r2, r3, r2
 8016728:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801672c:	fbb2 f3f3 	udiv	r3, r2, r3
 8016730:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            act_color = lv_color_mix(mcolor, gcolor, mix);
 8016734:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8016738:	461a      	mov	r2, r3
 801673a:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 801673e:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8016742:	f7ff f831 	bl	80157a8 <lv_color_mix>
 8016746:	4603      	mov	r3, r0
 8016748:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        }
        lv_draw_fill(&edge_bot_area, mask, act_color, opa);
 801674c:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016750:	f107 002c 	add.w	r0, r7, #44	; 0x2c
 8016754:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8016758:	68b9      	ldr	r1, [r7, #8]
 801675a:	f7fd fe57 	bl	801440c <lv_draw_fill>
    }

#if LV_ANTIALIAS
    if(aa) {
 801675e:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 8016762:	2b00      	cmp	r3, #0
 8016764:	f000 8257 	beq.w	8016c16 <lv_draw_rect_main_corner+0x104a>
        /*The first and the last line is not drawn*/
        edge_top_area.x1 = coords->x1 + radius + 2;
 8016768:	68fb      	ldr	r3, [r7, #12]
 801676a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801676e:	b29a      	uxth	r2, r3
 8016770:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8016774:	4413      	add	r3, r2
 8016776:	b29b      	uxth	r3, r3
 8016778:	3302      	adds	r3, #2
 801677a:	b29b      	uxth	r3, r3
 801677c:	b21b      	sxth	r3, r3
 801677e:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        edge_top_area.x2 = coords->x2 - radius - 2;
 8016782:	68fb      	ldr	r3, [r7, #12]
 8016784:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016788:	b29a      	uxth	r2, r3
 801678a:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 801678e:	1ad3      	subs	r3, r2, r3
 8016790:	b29b      	uxth	r3, r3
 8016792:	3b02      	subs	r3, #2
 8016794:	b29b      	uxth	r3, r3
 8016796:	b21b      	sxth	r3, r3
 8016798:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
        edge_top_area.y1 = coords->y1;
 801679c:	68fb      	ldr	r3, [r7, #12]
 801679e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80167a2:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        edge_top_area.y2 = coords->y1;
 80167a6:	68fb      	ldr	r3, [r7, #12]
 80167a8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80167ac:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        lv_draw_fill(&edge_top_area, mask, style->body.main_color, opa);
 80167b0:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80167b4:	687a      	ldr	r2, [r7, #4]
 80167b6:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80167ba:	8852      	ldrh	r2, [r2, #2]
 80167bc:	68b9      	ldr	r1, [r7, #8]
 80167be:	f7fd fe25 	bl	801440c <lv_draw_fill>

        edge_top_area.y1 = coords->y2;
 80167c2:	68fb      	ldr	r3, [r7, #12]
 80167c4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80167c8:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
        edge_top_area.y2 = coords->y2;
 80167cc:	68fb      	ldr	r3, [r7, #12]
 80167ce:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80167d2:	f8a7 304a 	strh.w	r3, [r7, #74]	; 0x4a
        lv_draw_fill(&edge_top_area, mask, style->body.grad_color, opa);
 80167d6:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 80167da:	687a      	ldr	r2, [r7, #4]
 80167dc:	f107 0044 	add.w	r0, r7, #68	; 0x44
 80167e0:	8892      	ldrh	r2, [r2, #4]
 80167e2:	68b9      	ldr	r1, [r7, #8]
 80167e4:	f7fd fe12 	bl	801440c <lv_draw_fill>

        /*Last parts of the anti-alias*/
        out_y_seg_end       = cir.y;
 80167e8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80167ea:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 80167ee:	f8b7 2070 	ldrh.w	r2, [r7, #112]	; 0x70
 80167f2:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 80167f6:	1ad3      	subs	r3, r2, r3
 80167f8:	b29b      	uxth	r3, r3
 80167fa:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
        lv_point_t aa_p;

        aa_p.x = out_x_last;
 80167fe:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8016802:	82bb      	strh	r3, [r7, #20]
        aa_p.y = out_y_seg_start;
 8016804:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8016808:	82fb      	strh	r3, [r7, #22]

        mix                 = (uint32_t)((uint32_t)(radius - out_x_last) * 255) / height;
 801680a:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 801680e:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8016812:	1ad3      	subs	r3, r2, r3
 8016814:	461a      	mov	r2, r3
 8016816:	4613      	mov	r3, r2
 8016818:	021b      	lsls	r3, r3, #8
 801681a:	1a9a      	subs	r2, r3, r2
 801681c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8016820:	fbb2 f3f3 	udiv	r3, r2, r3
 8016824:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
        aa_color_hor_bottom = lv_color_mix(gcolor, mcolor, mix);
 8016828:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801682c:	461a      	mov	r2, r3
 801682e:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8016832:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8016836:	f7fe ffb7 	bl	80157a8 <lv_color_mix>
 801683a:	4603      	mov	r3, r0
 801683c:	843b      	strh	r3, [r7, #32]
        aa_color_hor_top    = lv_color_mix(mcolor, gcolor, mix);
 801683e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8016842:	461a      	mov	r2, r3
 8016844:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8016848:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 801684c:	f7fe ffac 	bl	80157a8 <lv_color_mix>
 8016850:	4603      	mov	r3, r0
 8016852:	84bb      	strh	r3, [r7, #36]	; 0x24

        lv_coord_t i;
        for(i = 0; i < seg_size; i++) {
 8016854:	2300      	movs	r3, #0
 8016856:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
 801685a:	e136      	b.n	8016aca <lv_draw_rect_main_corner+0xefe>
            lv_opa_t aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 801685c:	f897 2076 	ldrb.w	r2, [r7, #118]	; 0x76
 8016860:	f9b7 107a 	ldrsh.w	r1, [r7, #122]	; 0x7a
 8016864:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8016868:	4618      	mov	r0, r3
 801686a:	f7fd fc5d 	bl	8014128 <lv_draw_aa_get_opa>
 801686e:	4603      	mov	r3, r0
 8016870:	461a      	mov	r2, r3
 8016872:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016876:	1a9b      	subs	r3, r3, r2
 8016878:	f887 306a 	strb.w	r3, [r7, #106]	; 0x6a
            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 801687c:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8016880:	b29a      	uxth	r2, r3
 8016882:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016886:	b29b      	uxth	r3, r3
 8016888:	4413      	add	r3, r2
 801688a:	b29a      	uxth	r2, r3
 801688c:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8016890:	4413      	add	r3, r2
 8016892:	b29b      	uxth	r3, r3
 8016894:	b218      	sxth	r0, r3
 8016896:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801689a:	b29a      	uxth	r2, r3
 801689c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80168a0:	b29b      	uxth	r3, r3
 80168a2:	4413      	add	r3, r2
 80168a4:	b29b      	uxth	r3, r3
 80168a6:	3301      	adds	r3, #1
 80168a8:	b29b      	uxth	r3, r3
 80168aa:	b219      	sxth	r1, r3
 80168ac:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 80168b0:	9300      	str	r3, [sp, #0]
 80168b2:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80168b4:	68ba      	ldr	r2, [r7, #8]
 80168b6:	f7fd fd10 	bl	80142da <lv_draw_px>
                       aa_color_hor_top, aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 80168ba:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80168be:	b29a      	uxth	r2, r3
 80168c0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80168c4:	b29b      	uxth	r3, r3
 80168c6:	1ad3      	subs	r3, r2, r3
 80168c8:	b29a      	uxth	r2, r3
 80168ca:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 80168ce:	1ad3      	subs	r3, r2, r3
 80168d0:	b29b      	uxth	r3, r3
 80168d2:	b218      	sxth	r0, r3
 80168d4:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80168d8:	b29a      	uxth	r2, r3
 80168da:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80168de:	b29b      	uxth	r3, r3
 80168e0:	4413      	add	r3, r2
 80168e2:	b29b      	uxth	r3, r3
 80168e4:	3301      	adds	r3, #1
 80168e6:	b29b      	uxth	r3, r3
 80168e8:	b219      	sxth	r1, r3
 80168ea:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 80168ee:	9300      	str	r3, [sp, #0]
 80168f0:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 80168f2:	68ba      	ldr	r2, [r7, #8]
 80168f4:	f7fd fcf1 	bl	80142da <lv_draw_px>
                       aa_color_hor_top, aa_opa);
            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 80168f8:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80168fc:	b29a      	uxth	r2, r3
 80168fe:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016902:	b29b      	uxth	r3, r3
 8016904:	1ad3      	subs	r3, r2, r3
 8016906:	b29a      	uxth	r2, r3
 8016908:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 801690c:	1ad3      	subs	r3, r2, r3
 801690e:	b29b      	uxth	r3, r3
 8016910:	b218      	sxth	r0, r3
 8016912:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8016916:	b29a      	uxth	r2, r3
 8016918:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801691c:	b29b      	uxth	r3, r3
 801691e:	1ad3      	subs	r3, r2, r3
 8016920:	b29b      	uxth	r3, r3
 8016922:	3b01      	subs	r3, #1
 8016924:	b29b      	uxth	r3, r3
 8016926:	b219      	sxth	r1, r3
 8016928:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 801692c:	9300      	str	r3, [sp, #0]
 801692e:	8c3b      	ldrh	r3, [r7, #32]
 8016930:	68ba      	ldr	r2, [r7, #8]
 8016932:	f7fd fcd2 	bl	80142da <lv_draw_px>
                       aa_color_hor_bottom, aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 8016936:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 801693a:	b29a      	uxth	r2, r3
 801693c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016940:	b29b      	uxth	r3, r3
 8016942:	4413      	add	r3, r2
 8016944:	b29a      	uxth	r2, r3
 8016946:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 801694a:	4413      	add	r3, r2
 801694c:	b29b      	uxth	r3, r3
 801694e:	b218      	sxth	r0, r3
 8016950:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8016954:	b29a      	uxth	r2, r3
 8016956:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801695a:	b29b      	uxth	r3, r3
 801695c:	1ad3      	subs	r3, r2, r3
 801695e:	b29b      	uxth	r3, r3
 8016960:	3b01      	subs	r3, #1
 8016962:	b29b      	uxth	r3, r3
 8016964:	b219      	sxth	r1, r3
 8016966:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 801696a:	9300      	str	r3, [sp, #0]
 801696c:	8c3b      	ldrh	r3, [r7, #32]
 801696e:	68ba      	ldr	r2, [r7, #8]
 8016970:	f7fd fcb3 	bl	80142da <lv_draw_px>
                       aa_color_hor_bottom, aa_opa);

            mix          = (uint32_t)((uint32_t)(radius - out_y_seg_start + i) * 255) / height;
 8016974:	f8b7 2078 	ldrh.w	r2, [r7, #120]	; 0x78
 8016978:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 801697c:	1ad2      	subs	r2, r2, r3
 801697e:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8016982:	4413      	add	r3, r2
 8016984:	461a      	mov	r2, r3
 8016986:	4613      	mov	r3, r2
 8016988:	021b      	lsls	r3, r3, #8
 801698a:	1a9a      	subs	r2, r3, r2
 801698c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8016990:	fbb2 f3f3 	udiv	r3, r2, r3
 8016994:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            aa_color_ver = lv_color_mix(mcolor, gcolor, mix);
 8016998:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801699c:	461a      	mov	r2, r3
 801699e:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 80169a2:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 80169a6:	f7fe feff 	bl	80157a8 <lv_color_mix>
 80169aa:	4603      	mov	r3, r0
 80169ac:	83bb      	strh	r3, [r7, #28]
            lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask, aa_color_ver,
 80169ae:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 80169b2:	b29a      	uxth	r2, r3
 80169b4:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80169b8:	b29b      	uxth	r3, r3
 80169ba:	4413      	add	r3, r2
 80169bc:	b29b      	uxth	r3, r3
 80169be:	3301      	adds	r3, #1
 80169c0:	b29b      	uxth	r3, r3
 80169c2:	b218      	sxth	r0, r3
 80169c4:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80169c8:	b29a      	uxth	r2, r3
 80169ca:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80169ce:	b29b      	uxth	r3, r3
 80169d0:	4413      	add	r3, r2
 80169d2:	b29a      	uxth	r2, r3
 80169d4:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 80169d8:	4413      	add	r3, r2
 80169da:	b29b      	uxth	r3, r3
 80169dc:	b219      	sxth	r1, r3
 80169de:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 80169e2:	9300      	str	r3, [sp, #0]
 80169e4:	8bbb      	ldrh	r3, [r7, #28]
 80169e6:	68ba      	ldr	r2, [r7, #8]
 80169e8:	f7fd fc77 	bl	80142da <lv_draw_px>
                       aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask, aa_color_ver,
 80169ec:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80169f0:	b29a      	uxth	r2, r3
 80169f2:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80169f6:	b29b      	uxth	r3, r3
 80169f8:	1ad3      	subs	r3, r2, r3
 80169fa:	b29b      	uxth	r3, r3
 80169fc:	3b01      	subs	r3, #1
 80169fe:	b29b      	uxth	r3, r3
 8016a00:	b218      	sxth	r0, r3
 8016a02:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8016a06:	b29a      	uxth	r2, r3
 8016a08:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016a0c:	b29b      	uxth	r3, r3
 8016a0e:	4413      	add	r3, r2
 8016a10:	b29a      	uxth	r2, r3
 8016a12:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8016a16:	4413      	add	r3, r2
 8016a18:	b29b      	uxth	r3, r3
 8016a1a:	b219      	sxth	r1, r3
 8016a1c:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8016a20:	9300      	str	r3, [sp, #0]
 8016a22:	8bbb      	ldrh	r3, [r7, #28]
 8016a24:	68ba      	ldr	r2, [r7, #8]
 8016a26:	f7fd fc58 	bl	80142da <lv_draw_px>
                       aa_opa);

            aa_color_ver = lv_color_mix(gcolor, mcolor, mix);
 8016a2a:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8016a2e:	461a      	mov	r2, r3
 8016a30:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8016a34:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8016a38:	f7fe feb6 	bl	80157a8 <lv_color_mix>
 8016a3c:	4603      	mov	r3, r0
 8016a3e:	83bb      	strh	r3, [r7, #28]
            lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask, aa_color_ver,
 8016a40:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8016a44:	b29a      	uxth	r2, r3
 8016a46:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016a4a:	b29b      	uxth	r3, r3
 8016a4c:	1ad3      	subs	r3, r2, r3
 8016a4e:	b29b      	uxth	r3, r3
 8016a50:	3b01      	subs	r3, #1
 8016a52:	b29b      	uxth	r3, r3
 8016a54:	b218      	sxth	r0, r3
 8016a56:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8016a5a:	b29a      	uxth	r2, r3
 8016a5c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016a60:	b29b      	uxth	r3, r3
 8016a62:	1ad3      	subs	r3, r2, r3
 8016a64:	b29a      	uxth	r2, r3
 8016a66:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8016a6a:	1ad3      	subs	r3, r2, r3
 8016a6c:	b29b      	uxth	r3, r3
 8016a6e:	b219      	sxth	r1, r3
 8016a70:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8016a74:	9300      	str	r3, [sp, #0]
 8016a76:	8bbb      	ldrh	r3, [r7, #28]
 8016a78:	68ba      	ldr	r2, [r7, #8]
 8016a7a:	f7fd fc2e 	bl	80142da <lv_draw_px>
                       aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask, aa_color_ver,
 8016a7e:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8016a82:	b29a      	uxth	r2, r3
 8016a84:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016a88:	b29b      	uxth	r3, r3
 8016a8a:	4413      	add	r3, r2
 8016a8c:	b29b      	uxth	r3, r3
 8016a8e:	3301      	adds	r3, #1
 8016a90:	b29b      	uxth	r3, r3
 8016a92:	b218      	sxth	r0, r3
 8016a94:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8016a98:	b29a      	uxth	r2, r3
 8016a9a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016a9e:	b29b      	uxth	r3, r3
 8016aa0:	1ad3      	subs	r3, r2, r3
 8016aa2:	b29a      	uxth	r2, r3
 8016aa4:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 8016aa8:	1ad3      	subs	r3, r2, r3
 8016aaa:	b29b      	uxth	r3, r3
 8016aac:	b219      	sxth	r1, r3
 8016aae:	f897 306a 	ldrb.w	r3, [r7, #106]	; 0x6a
 8016ab2:	9300      	str	r3, [sp, #0]
 8016ab4:	8bbb      	ldrh	r3, [r7, #28]
 8016ab6:	68ba      	ldr	r2, [r7, #8]
 8016ab8:	f7fd fc0f 	bl	80142da <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 8016abc:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8016ac0:	b29b      	uxth	r3, r3
 8016ac2:	3301      	adds	r3, #1
 8016ac4:	b29b      	uxth	r3, r3
 8016ac6:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
 8016aca:	f9b7 207a 	ldrsh.w	r2, [r7, #122]	; 0x7a
 8016ace:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8016ad2:	429a      	cmp	r2, r3
 8016ad4:	f6ff aec2 	blt.w	801685c <lv_draw_rect_main_corner+0xc90>
                       aa_opa);
        }

        /*In some cases the last pixel is not drawn*/
        if(LV_MATH_ABS(aa_p.x - aa_p.y) == seg_size) {
 8016ad8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016adc:	461a      	mov	r2, r3
 8016ade:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016ae2:	1ad3      	subs	r3, r2, r3
 8016ae4:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8016ae8:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8016aec:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 8016af0:	429a      	cmp	r2, r3
 8016af2:	f040 8090 	bne.w	8016c16 <lv_draw_rect_main_corner+0x104a>
            aa_p.x = out_x_last;
 8016af6:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8016afa:	82bb      	strh	r3, [r7, #20]
            aa_p.y = out_x_last;
 8016afc:	f8b7 3084 	ldrh.w	r3, [r7, #132]	; 0x84
 8016b00:	82fb      	strh	r3, [r7, #22]

            mix                 = (uint32_t)((uint32_t)(out_x_last)*255) / height;
 8016b02:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8016b06:	4613      	mov	r3, r2
 8016b08:	021b      	lsls	r3, r3, #8
 8016b0a:	1a9a      	subs	r2, r3, r2
 8016b0c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 8016b10:	fbb2 f3f3 	udiv	r3, r2, r3
 8016b14:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            aa_color_hor_top    = lv_color_mix(gcolor, mcolor, mix);
 8016b18:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8016b1c:	461a      	mov	r2, r3
 8016b1e:	f8b7 1064 	ldrh.w	r1, [r7, #100]	; 0x64
 8016b22:	f8b7 0060 	ldrh.w	r0, [r7, #96]	; 0x60
 8016b26:	f7fe fe3f 	bl	80157a8 <lv_color_mix>
 8016b2a:	4603      	mov	r3, r0
 8016b2c:	84bb      	strh	r3, [r7, #36]	; 0x24
            aa_color_hor_bottom = lv_color_mix(mcolor, gcolor, mix);
 8016b2e:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 8016b32:	461a      	mov	r2, r3
 8016b34:	f8b7 1060 	ldrh.w	r1, [r7, #96]	; 0x60
 8016b38:	f8b7 0064 	ldrh.w	r0, [r7, #100]	; 0x64
 8016b3c:	f7fe fe34 	bl	80157a8 <lv_color_mix>
 8016b40:	4603      	mov	r3, r0
 8016b42:	843b      	strh	r3, [r7, #32]

            lv_opa_t aa_opa = opa >> 1;
 8016b44:	f897 3076 	ldrb.w	r3, [r7, #118]	; 0x76
 8016b48:	085b      	lsrs	r3, r3, #1
 8016b4a:	f887 306b 	strb.w	r3, [r7, #107]	; 0x6b
            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p), rb_origo.y + LV_CIRC_OCT2_Y(aa_p), mask, aa_color_hor_bottom,
 8016b4e:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 8016b52:	b29a      	uxth	r2, r3
 8016b54:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016b58:	b29b      	uxth	r3, r3
 8016b5a:	4413      	add	r3, r2
 8016b5c:	b29b      	uxth	r3, r3
 8016b5e:	b218      	sxth	r0, r3
 8016b60:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 8016b64:	b29a      	uxth	r2, r3
 8016b66:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016b6a:	b29b      	uxth	r3, r3
 8016b6c:	4413      	add	r3, r2
 8016b6e:	b29b      	uxth	r3, r3
 8016b70:	b219      	sxth	r1, r3
 8016b72:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8016b76:	9300      	str	r3, [sp, #0]
 8016b78:	8c3b      	ldrh	r3, [r7, #32]
 8016b7a:	68ba      	ldr	r2, [r7, #8]
 8016b7c:	f7fd fbad 	bl	80142da <lv_draw_px>
                       aa_opa);
            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p), lb_origo.y + LV_CIRC_OCT4_Y(aa_p), mask, aa_color_hor_bottom,
 8016b80:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8016b84:	b29a      	uxth	r2, r3
 8016b86:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016b8a:	b29b      	uxth	r3, r3
 8016b8c:	1ad3      	subs	r3, r2, r3
 8016b8e:	b29b      	uxth	r3, r3
 8016b90:	b218      	sxth	r0, r3
 8016b92:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8016b96:	b29a      	uxth	r2, r3
 8016b98:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016b9c:	b29b      	uxth	r3, r3
 8016b9e:	4413      	add	r3, r2
 8016ba0:	b29b      	uxth	r3, r3
 8016ba2:	b219      	sxth	r1, r3
 8016ba4:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8016ba8:	9300      	str	r3, [sp, #0]
 8016baa:	8c3b      	ldrh	r3, [r7, #32]
 8016bac:	68ba      	ldr	r2, [r7, #8]
 8016bae:	f7fd fb94 	bl	80142da <lv_draw_px>
                       aa_opa);
            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p), lt_origo.y + LV_CIRC_OCT6_Y(aa_p), mask, aa_color_hor_top,
 8016bb2:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8016bb6:	b29a      	uxth	r2, r3
 8016bb8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016bbc:	b29b      	uxth	r3, r3
 8016bbe:	1ad3      	subs	r3, r2, r3
 8016bc0:	b29b      	uxth	r3, r3
 8016bc2:	b218      	sxth	r0, r3
 8016bc4:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8016bc8:	b29a      	uxth	r2, r3
 8016bca:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016bce:	b29b      	uxth	r3, r3
 8016bd0:	1ad3      	subs	r3, r2, r3
 8016bd2:	b29b      	uxth	r3, r3
 8016bd4:	b219      	sxth	r1, r3
 8016bd6:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8016bda:	9300      	str	r3, [sp, #0]
 8016bdc:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016bde:	68ba      	ldr	r2, [r7, #8]
 8016be0:	f7fd fb7b 	bl	80142da <lv_draw_px>
                       aa_opa);
            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask, aa_color_hor_top,
 8016be4:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8016be8:	b29a      	uxth	r2, r3
 8016bea:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016bee:	b29b      	uxth	r3, r3
 8016bf0:	4413      	add	r3, r2
 8016bf2:	b29b      	uxth	r3, r3
 8016bf4:	b218      	sxth	r0, r3
 8016bf6:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8016bfa:	b29a      	uxth	r2, r3
 8016bfc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8016c00:	b29b      	uxth	r3, r3
 8016c02:	1ad3      	subs	r3, r2, r3
 8016c04:	b29b      	uxth	r3, r3
 8016c06:	b219      	sxth	r1, r3
 8016c08:	f897 306b 	ldrb.w	r3, [r7, #107]	; 0x6b
 8016c0c:	9300      	str	r3, [sp, #0]
 8016c0e:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8016c10:	68ba      	ldr	r2, [r7, #8]
 8016c12:	f7fd fb62 	bl	80142da <lv_draw_px>
                       aa_opa);
        }
    }
#endif
}
 8016c16:	bf00      	nop
 8016c18:	3788      	adds	r7, #136	; 0x88
 8016c1a:	46bd      	mov	sp, r7
 8016c1c:	bdb0      	pop	{r4, r5, r7, pc}

08016c1e <lv_draw_rect_border_straight>:
 * @param rstyle pointer to a rectangle style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         lv_opa_t opa_scale)
{
 8016c1e:	b580      	push	{r7, lr}
 8016c20:	b08c      	sub	sp, #48	; 0x30
 8016c22:	af00      	add	r7, sp, #0
 8016c24:	60f8      	str	r0, [r7, #12]
 8016c26:	60b9      	str	r1, [r7, #8]
 8016c28:	607a      	str	r2, [r7, #4]
 8016c2a:	70fb      	strb	r3, [r7, #3]
    uint16_t radius = style->body.radius;
 8016c2c:	687b      	ldr	r3, [r7, #4]
 8016c2e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016c32:	857b      	strh	r3, [r7, #42]	; 0x2a
    bool aa         = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8016c34:	f7fb ff34 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8016c38:	4603      	mov	r3, r0
 8016c3a:	4618      	mov	r0, r3
 8016c3c:	f004 fa96 	bl	801b16c <lv_disp_get_antialiasing>
 8016c40:	4603      	mov	r3, r0
 8016c42:	f887 3029 	strb.w	r3, [r7, #41]	; 0x29

    lv_coord_t width  = lv_area_get_width(coords);
 8016c46:	68f8      	ldr	r0, [r7, #12]
 8016c48:	f7fe fe2d 	bl	80158a6 <lv_area_get_width>
 8016c4c:	4603      	mov	r3, r0
 8016c4e:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_coord_t height = lv_area_get_height(coords);
 8016c50:	68f8      	ldr	r0, [r7, #12]
 8016c52:	f7fe fe3f 	bl	80158d4 <lv_area_get_height>
 8016c56:	4603      	mov	r3, r0
 8016c58:	84bb      	strh	r3, [r7, #36]	; 0x24
    lv_coord_t bwidth = style->body.border.width;
 8016c5a:	687b      	ldr	r3, [r7, #4]
 8016c5c:	899b      	ldrh	r3, [r3, #12]
 8016c5e:	847b      	strh	r3, [r7, #34]	; 0x22
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8016c60:	78fb      	ldrb	r3, [r7, #3]
 8016c62:	2bff      	cmp	r3, #255	; 0xff
 8016c64:	d102      	bne.n	8016c6c <lv_draw_rect_border_straight+0x4e>
 8016c66:	687b      	ldr	r3, [r7, #4]
 8016c68:	7bdb      	ldrb	r3, [r3, #15]
 8016c6a:	e00a      	b.n	8016c82 <lv_draw_rect_border_straight+0x64>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
 8016c6c:	687b      	ldr	r3, [r7, #4]
 8016c6e:	7bdb      	ldrb	r3, [r3, #15]
 8016c70:	b29a      	uxth	r2, r3
 8016c72:	78fb      	ldrb	r3, [r7, #3]
 8016c74:	b29b      	uxth	r3, r3
 8016c76:	fb12 f303 	smulbb	r3, r2, r3
 8016c7a:	b29b      	uxth	r3, r3
    lv_opa_t opa      = opa_scale == LV_OPA_COVER ? style->body.border.opa
 8016c7c:	0a1b      	lsrs	r3, r3, #8
 8016c7e:	b29b      	uxth	r3, r3
 8016c80:	b2db      	uxtb	r3, r3
 8016c82:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
    lv_border_part_t part = style->body.border.part;
 8016c86:	687b      	ldr	r3, [r7, #4]
 8016c88:	7b9b      	ldrb	r3, [r3, #14]
 8016c8a:	f887 3020 	strb.w	r3, [r7, #32]
    lv_color_t color      = style->body.border.color;
 8016c8e:	687b      	ldr	r3, [r7, #4]
 8016c90:	895b      	ldrh	r3, [r3, #10]
 8016c92:	83bb      	strh	r3, [r7, #28]
    lv_area_t work_area;
    lv_coord_t length_corr = 0;
 8016c94:	2300      	movs	r3, #0
 8016c96:	85fb      	strh	r3, [r7, #46]	; 0x2e
    lv_coord_t corner_size = 0;
 8016c98:	2300      	movs	r3, #0
 8016c9a:	85bb      	strh	r3, [r7, #44]	; 0x2c

    /*the 0 px border width drawn as 1 px, so decrement the b_width*/
    bwidth--;
 8016c9c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016ca0:	b29b      	uxth	r3, r3
 8016ca2:	3b01      	subs	r3, #1
 8016ca4:	b29b      	uxth	r3, r3
 8016ca6:	847b      	strh	r3, [r7, #34]	; 0x22

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8016ca8:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8016cac:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 8016cb0:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8016cb2:	4618      	mov	r0, r3
 8016cb4:	f002 fc9f 	bl	80195f6 <lv_draw_cont_radius_corr>
 8016cb8:	4603      	mov	r3, r0
 8016cba:	857b      	strh	r3, [r7, #42]	; 0x2a

    if(radius < bwidth) {
 8016cbc:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
 8016cbe:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8016cc2:	429a      	cmp	r2, r3
 8016cc4:	da0c      	bge.n	8016ce0 <lv_draw_rect_border_straight+0xc2>
        length_corr = bwidth - radius - aa;
 8016cc6:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8016cc8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8016cca:	1ad3      	subs	r3, r2, r3
 8016ccc:	b29a      	uxth	r2, r3
 8016cce:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8016cd2:	b29b      	uxth	r3, r3
 8016cd4:	1ad3      	subs	r3, r2, r3
 8016cd6:	b29b      	uxth	r3, r3
 8016cd8:	85fb      	strh	r3, [r7, #46]	; 0x2e
        corner_size = bwidth;
 8016cda:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016cdc:	85bb      	strh	r3, [r7, #44]	; 0x2c
 8016cde:	e006      	b.n	8016cee <lv_draw_rect_border_straight+0xd0>
    } else {
        corner_size = radius + aa;
 8016ce0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8016ce4:	b29a      	uxth	r2, r3
 8016ce6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8016ce8:	4413      	add	r3, r2
 8016cea:	b29b      	uxth	r3, r3
 8016cec:	85bb      	strh	r3, [r7, #44]	; 0x2c
    }

    /*If radius == 0 is a special case*/
    if(style->body.radius == 0) {
 8016cee:	687b      	ldr	r3, [r7, #4]
 8016cf0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016cf4:	2b00      	cmp	r3, #0
 8016cf6:	f040 80ca 	bne.w	8016e8e <lv_draw_rect_border_straight+0x270>
        /*Left top corner*/
        if(part & LV_BORDER_TOP) {
 8016cfa:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016cfe:	f003 0302 	and.w	r3, r3, #2
 8016d02:	2b00      	cmp	r3, #0
 8016d04:	d01c      	beq.n	8016d40 <lv_draw_rect_border_straight+0x122>
            work_area.x1 = coords->x1;
 8016d06:	68fb      	ldr	r3, [r7, #12]
 8016d08:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016d0c:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8016d0e:	68fb      	ldr	r3, [r7, #12]
 8016d10:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016d14:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 8016d16:	68fb      	ldr	r3, [r7, #12]
 8016d18:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016d1c:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 8016d1e:	68fb      	ldr	r3, [r7, #12]
 8016d20:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016d24:	b29a      	uxth	r2, r3
 8016d26:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016d28:	4413      	add	r3, r2
 8016d2a:	b29b      	uxth	r3, r3
 8016d2c:	b21b      	sxth	r3, r3
 8016d2e:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8016d30:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016d34:	f107 0014 	add.w	r0, r7, #20
 8016d38:	8bba      	ldrh	r2, [r7, #28]
 8016d3a:	68b9      	ldr	r1, [r7, #8]
 8016d3c:	f7fd fb66 	bl	801440c <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & LV_BORDER_RIGHT) {
 8016d40:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016d44:	f003 0308 	and.w	r3, r3, #8
 8016d48:	2b00      	cmp	r3, #0
 8016d4a:	d03a      	beq.n	8016dc2 <lv_draw_rect_border_straight+0x1a4>
            work_area.x1 = coords->x2 - bwidth;
 8016d4c:	68fb      	ldr	r3, [r7, #12]
 8016d4e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016d52:	b29a      	uxth	r2, r3
 8016d54:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016d56:	1ad3      	subs	r3, r2, r3
 8016d58:	b29b      	uxth	r3, r3
 8016d5a:	b21b      	sxth	r3, r3
 8016d5c:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8016d5e:	68fb      	ldr	r3, [r7, #12]
 8016d60:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016d64:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
 8016d66:	68fb      	ldr	r3, [r7, #12]
 8016d68:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016d6c:	b29a      	uxth	r2, r3
 8016d6e:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016d72:	f003 0302 	and.w	r3, r3, #2
 8016d76:	2b00      	cmp	r3, #0
 8016d78:	d003      	beq.n	8016d82 <lv_draw_rect_border_straight+0x164>
 8016d7a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016d7c:	3301      	adds	r3, #1
 8016d7e:	b29b      	uxth	r3, r3
 8016d80:	e000      	b.n	8016d84 <lv_draw_rect_border_straight+0x166>
 8016d82:	2300      	movs	r3, #0
 8016d84:	4413      	add	r3, r2
 8016d86:	b29b      	uxth	r3, r3
 8016d88:	b21b      	sxth	r3, r3
 8016d8a:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
 8016d8c:	68fb      	ldr	r3, [r7, #12]
 8016d8e:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016d92:	b29a      	uxth	r2, r3
 8016d94:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016d98:	f003 0301 	and.w	r3, r3, #1
 8016d9c:	2b00      	cmp	r3, #0
 8016d9e:	d003      	beq.n	8016da8 <lv_draw_rect_border_straight+0x18a>
 8016da0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016da2:	3301      	adds	r3, #1
 8016da4:	b29b      	uxth	r3, r3
 8016da6:	e000      	b.n	8016daa <lv_draw_rect_border_straight+0x18c>
 8016da8:	2300      	movs	r3, #0
 8016daa:	1ad3      	subs	r3, r2, r3
 8016dac:	b29b      	uxth	r3, r3
 8016dae:	b21b      	sxth	r3, r3
 8016db0:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8016db2:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016db6:	f107 0014 	add.w	r0, r7, #20
 8016dba:	8bba      	ldrh	r2, [r7, #28]
 8016dbc:	68b9      	ldr	r1, [r7, #8]
 8016dbe:	f7fd fb25 	bl	801440c <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & LV_BORDER_LEFT) {
 8016dc2:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016dc6:	f003 0304 	and.w	r3, r3, #4
 8016dca:	2b00      	cmp	r3, #0
 8016dcc:	d03a      	beq.n	8016e44 <lv_draw_rect_border_straight+0x226>
            work_area.x1 = coords->x1;
 8016dce:	68fb      	ldr	r3, [r7, #12]
 8016dd0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016dd4:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + bwidth;
 8016dd6:	68fb      	ldr	r3, [r7, #12]
 8016dd8:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016ddc:	b29a      	uxth	r2, r3
 8016dde:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016de0:	4413      	add	r3, r2
 8016de2:	b29b      	uxth	r3, r3
 8016de4:	b21b      	sxth	r3, r3
 8016de6:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + (part & LV_BORDER_TOP ? bwidth + 1 : 0);
 8016de8:	68fb      	ldr	r3, [r7, #12]
 8016dea:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016dee:	b29a      	uxth	r2, r3
 8016df0:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016df4:	f003 0302 	and.w	r3, r3, #2
 8016df8:	2b00      	cmp	r3, #0
 8016dfa:	d003      	beq.n	8016e04 <lv_draw_rect_border_straight+0x1e6>
 8016dfc:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016dfe:	3301      	adds	r3, #1
 8016e00:	b29b      	uxth	r3, r3
 8016e02:	e000      	b.n	8016e06 <lv_draw_rect_border_straight+0x1e8>
 8016e04:	2300      	movs	r3, #0
 8016e06:	4413      	add	r3, r2
 8016e08:	b29b      	uxth	r3, r3
 8016e0a:	b21b      	sxth	r3, r3
 8016e0c:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - (part & LV_BORDER_BOTTOM ? bwidth + 1 : 0);
 8016e0e:	68fb      	ldr	r3, [r7, #12]
 8016e10:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016e14:	b29a      	uxth	r2, r3
 8016e16:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016e1a:	f003 0301 	and.w	r3, r3, #1
 8016e1e:	2b00      	cmp	r3, #0
 8016e20:	d003      	beq.n	8016e2a <lv_draw_rect_border_straight+0x20c>
 8016e22:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016e24:	3301      	adds	r3, #1
 8016e26:	b29b      	uxth	r3, r3
 8016e28:	e000      	b.n	8016e2c <lv_draw_rect_border_straight+0x20e>
 8016e2a:	2300      	movs	r3, #0
 8016e2c:	1ad3      	subs	r3, r2, r3
 8016e2e:	b29b      	uxth	r3, r3
 8016e30:	b21b      	sxth	r3, r3
 8016e32:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8016e34:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016e38:	f107 0014 	add.w	r0, r7, #20
 8016e3c:	8bba      	ldrh	r2, [r7, #28]
 8016e3e:	68b9      	ldr	r1, [r7, #8]
 8016e40:	f7fd fae4 	bl	801440c <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & LV_BORDER_BOTTOM) {
 8016e44:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016e48:	f003 0301 	and.w	r3, r3, #1
 8016e4c:	2b00      	cmp	r3, #0
 8016e4e:	f000 828f 	beq.w	8017370 <lv_draw_rect_border_straight+0x752>
            work_area.x1 = coords->x1;
 8016e52:	68fb      	ldr	r3, [r7, #12]
 8016e54:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016e58:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8016e5a:	68fb      	ldr	r3, [r7, #12]
 8016e5c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016e60:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 8016e62:	68fb      	ldr	r3, [r7, #12]
 8016e64:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016e68:	b29a      	uxth	r2, r3
 8016e6a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016e6c:	1ad3      	subs	r3, r2, r3
 8016e6e:	b29b      	uxth	r3, r3
 8016e70:	b21b      	sxth	r3, r3
 8016e72:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 8016e74:	68fb      	ldr	r3, [r7, #12]
 8016e76:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016e7a:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8016e7c:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016e80:	f107 0014 	add.w	r0, r7, #20
 8016e84:	8bba      	ldrh	r2, [r7, #28]
 8016e86:	68b9      	ldr	r1, [r7, #8]
 8016e88:	f7fd fac0 	bl	801440c <lv_draw_fill>
 8016e8c:	e271      	b.n	8017372 <lv_draw_rect_border_straight+0x754>
        }
        return;
    }

    /* Modify the corner_size if corner is drawn */
    corner_size++;
 8016e8e:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8016e92:	b29b      	uxth	r3, r3
 8016e94:	3301      	adds	r3, #1
 8016e96:	b29b      	uxth	r3, r3
 8016e98:	85bb      	strh	r3, [r7, #44]	; 0x2c

    /*Depending one which part's are drawn modify the area lengths */
    if(part & LV_BORDER_TOP)
 8016e9a:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016e9e:	f003 0302 	and.w	r3, r3, #2
 8016ea2:	2b00      	cmp	r3, #0
 8016ea4:	d009      	beq.n	8016eba <lv_draw_rect_border_straight+0x29c>
        work_area.y1 = coords->y1 + corner_size;
 8016ea6:	68fb      	ldr	r3, [r7, #12]
 8016ea8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016eac:	b29a      	uxth	r2, r3
 8016eae:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8016eb0:	4413      	add	r3, r2
 8016eb2:	b29b      	uxth	r3, r3
 8016eb4:	b21b      	sxth	r3, r3
 8016eb6:	82fb      	strh	r3, [r7, #22]
 8016eb8:	e008      	b.n	8016ecc <lv_draw_rect_border_straight+0x2ae>
    else
        work_area.y1 = coords->y1 + radius;
 8016eba:	68fb      	ldr	r3, [r7, #12]
 8016ebc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016ec0:	b29a      	uxth	r2, r3
 8016ec2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8016ec4:	4413      	add	r3, r2
 8016ec6:	b29b      	uxth	r3, r3
 8016ec8:	b21b      	sxth	r3, r3
 8016eca:	82fb      	strh	r3, [r7, #22]

    if(part & LV_BORDER_BOTTOM)
 8016ecc:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016ed0:	f003 0301 	and.w	r3, r3, #1
 8016ed4:	2b00      	cmp	r3, #0
 8016ed6:	d009      	beq.n	8016eec <lv_draw_rect_border_straight+0x2ce>
        work_area.y2 = coords->y2 - corner_size;
 8016ed8:	68fb      	ldr	r3, [r7, #12]
 8016eda:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016ede:	b29a      	uxth	r2, r3
 8016ee0:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8016ee2:	1ad3      	subs	r3, r2, r3
 8016ee4:	b29b      	uxth	r3, r3
 8016ee6:	b21b      	sxth	r3, r3
 8016ee8:	837b      	strh	r3, [r7, #26]
 8016eea:	e008      	b.n	8016efe <lv_draw_rect_border_straight+0x2e0>
    else
        work_area.y2 = coords->y2 - radius;
 8016eec:	68fb      	ldr	r3, [r7, #12]
 8016eee:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016ef2:	b29a      	uxth	r2, r3
 8016ef4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8016ef6:	1ad3      	subs	r3, r2, r3
 8016ef8:	b29b      	uxth	r3, r3
 8016efa:	b21b      	sxth	r3, r3
 8016efc:	837b      	strh	r3, [r7, #26]

    /*Left border*/
    if(part & LV_BORDER_LEFT) {
 8016efe:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016f02:	f003 0304 	and.w	r3, r3, #4
 8016f06:	2b00      	cmp	r3, #0
 8016f08:	d013      	beq.n	8016f32 <lv_draw_rect_border_straight+0x314>
        work_area.x1 = coords->x1;
 8016f0a:	68fb      	ldr	r3, [r7, #12]
 8016f0c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016f10:	82bb      	strh	r3, [r7, #20]
        work_area.x2 = work_area.x1 + bwidth;
 8016f12:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8016f16:	b29a      	uxth	r2, r3
 8016f18:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016f1a:	4413      	add	r3, r2
 8016f1c:	b29b      	uxth	r3, r3
 8016f1e:	b21b      	sxth	r3, r3
 8016f20:	833b      	strh	r3, [r7, #24]
        lv_draw_fill(&work_area, mask, color, opa);
 8016f22:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016f26:	f107 0014 	add.w	r0, r7, #20
 8016f2a:	8bba      	ldrh	r2, [r7, #28]
 8016f2c:	68b9      	ldr	r1, [r7, #8]
 8016f2e:	f7fd fa6d 	bl	801440c <lv_draw_fill>
    }

    /*Right border*/
    if(part & LV_BORDER_RIGHT) {
 8016f32:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016f36:	f003 0308 	and.w	r3, r3, #8
 8016f3a:	2b00      	cmp	r3, #0
 8016f3c:	d013      	beq.n	8016f66 <lv_draw_rect_border_straight+0x348>
        work_area.x2 = coords->x2;
 8016f3e:	68fb      	ldr	r3, [r7, #12]
 8016f40:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016f44:	833b      	strh	r3, [r7, #24]
        work_area.x1 = work_area.x2 - bwidth;
 8016f46:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8016f4a:	b29a      	uxth	r2, r3
 8016f4c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016f4e:	1ad3      	subs	r3, r2, r3
 8016f50:	b29b      	uxth	r3, r3
 8016f52:	b21b      	sxth	r3, r3
 8016f54:	82bb      	strh	r3, [r7, #20]
        lv_draw_fill(&work_area, mask, color, opa);
 8016f56:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016f5a:	f107 0014 	add.w	r0, r7, #20
 8016f5e:	8bba      	ldrh	r2, [r7, #28]
 8016f60:	68b9      	ldr	r1, [r7, #8]
 8016f62:	f7fd fa53 	bl	801440c <lv_draw_fill>
    }

    work_area.x1 = coords->x1 + corner_size - length_corr;
 8016f66:	68fb      	ldr	r3, [r7, #12]
 8016f68:	f9b3 3000 	ldrsh.w	r3, [r3]
 8016f6c:	b29a      	uxth	r2, r3
 8016f6e:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8016f70:	4413      	add	r3, r2
 8016f72:	b29a      	uxth	r2, r3
 8016f74:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8016f76:	1ad3      	subs	r3, r2, r3
 8016f78:	b29b      	uxth	r3, r3
 8016f7a:	b21b      	sxth	r3, r3
 8016f7c:	82bb      	strh	r3, [r7, #20]
    work_area.x2 = coords->x2 - corner_size + length_corr;
 8016f7e:	68fb      	ldr	r3, [r7, #12]
 8016f80:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8016f84:	b29a      	uxth	r2, r3
 8016f86:	8dbb      	ldrh	r3, [r7, #44]	; 0x2c
 8016f88:	1ad3      	subs	r3, r2, r3
 8016f8a:	b29a      	uxth	r2, r3
 8016f8c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 8016f8e:	4413      	add	r3, r2
 8016f90:	b29b      	uxth	r3, r3
 8016f92:	b21b      	sxth	r3, r3
 8016f94:	833b      	strh	r3, [r7, #24]

    /*Upper border*/
    if(part & LV_BORDER_TOP) {
 8016f96:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016f9a:	f003 0302 	and.w	r3, r3, #2
 8016f9e:	2b00      	cmp	r3, #0
 8016fa0:	d014      	beq.n	8016fcc <lv_draw_rect_border_straight+0x3ae>
        work_area.y1 = coords->y1;
 8016fa2:	68fb      	ldr	r3, [r7, #12]
 8016fa4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016fa8:	82fb      	strh	r3, [r7, #22]
        work_area.y2 = coords->y1 + bwidth;
 8016faa:	68fb      	ldr	r3, [r7, #12]
 8016fac:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8016fb0:	b29a      	uxth	r2, r3
 8016fb2:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016fb4:	4413      	add	r3, r2
 8016fb6:	b29b      	uxth	r3, r3
 8016fb8:	b21b      	sxth	r3, r3
 8016fba:	837b      	strh	r3, [r7, #26]
        lv_draw_fill(&work_area, mask, color, opa);
 8016fbc:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016fc0:	f107 0014 	add.w	r0, r7, #20
 8016fc4:	8bba      	ldrh	r2, [r7, #28]
 8016fc6:	68b9      	ldr	r1, [r7, #8]
 8016fc8:	f7fd fa20 	bl	801440c <lv_draw_fill>
    }

    /*Lower border*/
    if(part & LV_BORDER_BOTTOM) {
 8016fcc:	f897 3020 	ldrb.w	r3, [r7, #32]
 8016fd0:	f003 0301 	and.w	r3, r3, #1
 8016fd4:	2b00      	cmp	r3, #0
 8016fd6:	d013      	beq.n	8017000 <lv_draw_rect_border_straight+0x3e2>
        work_area.y2 = coords->y2;
 8016fd8:	68fb      	ldr	r3, [r7, #12]
 8016fda:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8016fde:	837b      	strh	r3, [r7, #26]
        work_area.y1 = work_area.y2 - bwidth;
 8016fe0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8016fe4:	b29a      	uxth	r2, r3
 8016fe6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8016fe8:	1ad3      	subs	r3, r2, r3
 8016fea:	b29b      	uxth	r3, r3
 8016fec:	b21b      	sxth	r3, r3
 8016fee:	82fb      	strh	r3, [r7, #22]
        lv_draw_fill(&work_area, mask, color, opa);
 8016ff0:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8016ff4:	f107 0014 	add.w	r0, r7, #20
 8016ff8:	8bba      	ldrh	r2, [r7, #28]
 8016ffa:	68b9      	ldr	r1, [r7, #8]
 8016ffc:	f7fd fa06 	bl	801440c <lv_draw_fill>
    }

    /*Draw the a remaining rectangles if the radius is smaller then bwidth */
    if(length_corr != 0) {
 8017000:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8017004:	2b00      	cmp	r3, #0
 8017006:	f000 80fc 	beq.w	8017202 <lv_draw_rect_border_straight+0x5e4>
        /*Left top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 801700a:	f897 3020 	ldrb.w	r3, [r7, #32]
 801700e:	f003 0302 	and.w	r3, r3, #2
 8017012:	2b00      	cmp	r3, #0
 8017014:	d038      	beq.n	8017088 <lv_draw_rect_border_straight+0x46a>
 8017016:	f897 3020 	ldrb.w	r3, [r7, #32]
 801701a:	f003 0304 	and.w	r3, r3, #4
 801701e:	2b00      	cmp	r3, #0
 8017020:	d032      	beq.n	8017088 <lv_draw_rect_border_straight+0x46a>
            work_area.x1 = coords->x1;
 8017022:	68fb      	ldr	r3, [r7, #12]
 8017024:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017028:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + radius + aa;
 801702a:	68fb      	ldr	r3, [r7, #12]
 801702c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017030:	b29a      	uxth	r2, r3
 8017032:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8017034:	4413      	add	r3, r2
 8017036:	b29a      	uxth	r2, r3
 8017038:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801703c:	b29b      	uxth	r3, r3
 801703e:	4413      	add	r3, r2
 8017040:	b29b      	uxth	r3, r3
 8017042:	b21b      	sxth	r3, r3
 8017044:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + radius + 1 + aa;
 8017046:	68fb      	ldr	r3, [r7, #12]
 8017048:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801704c:	b29a      	uxth	r2, r3
 801704e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8017050:	4413      	add	r3, r2
 8017052:	b29a      	uxth	r2, r3
 8017054:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8017058:	b29b      	uxth	r3, r3
 801705a:	4413      	add	r3, r2
 801705c:	b29b      	uxth	r3, r3
 801705e:	3301      	adds	r3, #1
 8017060:	b29b      	uxth	r3, r3
 8017062:	b21b      	sxth	r3, r3
 8017064:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 8017066:	68fb      	ldr	r3, [r7, #12]
 8017068:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801706c:	b29a      	uxth	r2, r3
 801706e:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8017070:	4413      	add	r3, r2
 8017072:	b29b      	uxth	r3, r3
 8017074:	b21b      	sxth	r3, r3
 8017076:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8017078:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801707c:	f107 0014 	add.w	r0, r7, #20
 8017080:	8bba      	ldrh	r2, [r7, #28]
 8017082:	68b9      	ldr	r1, [r7, #8]
 8017084:	f7fd f9c2 	bl	801440c <lv_draw_fill>
        }

        /*Right top correction*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8017088:	f897 3020 	ldrb.w	r3, [r7, #32]
 801708c:	f003 0302 	and.w	r3, r3, #2
 8017090:	2b00      	cmp	r3, #0
 8017092:	d038      	beq.n	8017106 <lv_draw_rect_border_straight+0x4e8>
 8017094:	f897 3020 	ldrb.w	r3, [r7, #32]
 8017098:	f003 0308 	and.w	r3, r3, #8
 801709c:	2b00      	cmp	r3, #0
 801709e:	d032      	beq.n	8017106 <lv_draw_rect_border_straight+0x4e8>
            work_area.x1 = coords->x2 - radius - aa;
 80170a0:	68fb      	ldr	r3, [r7, #12]
 80170a2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80170a6:	b29a      	uxth	r2, r3
 80170a8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80170aa:	1ad3      	subs	r3, r2, r3
 80170ac:	b29a      	uxth	r2, r3
 80170ae:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80170b2:	b29b      	uxth	r3, r3
 80170b4:	1ad3      	subs	r3, r2, r3
 80170b6:	b29b      	uxth	r3, r3
 80170b8:	b21b      	sxth	r3, r3
 80170ba:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 80170bc:	68fb      	ldr	r3, [r7, #12]
 80170be:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80170c2:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1 + radius + 1 + aa;
 80170c4:	68fb      	ldr	r3, [r7, #12]
 80170c6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80170ca:	b29a      	uxth	r2, r3
 80170cc:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80170ce:	4413      	add	r3, r2
 80170d0:	b29a      	uxth	r2, r3
 80170d2:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80170d6:	b29b      	uxth	r3, r3
 80170d8:	4413      	add	r3, r2
 80170da:	b29b      	uxth	r3, r3
 80170dc:	3301      	adds	r3, #1
 80170de:	b29b      	uxth	r3, r3
 80170e0:	b21b      	sxth	r3, r3
 80170e2:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + bwidth;
 80170e4:	68fb      	ldr	r3, [r7, #12]
 80170e6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80170ea:	b29a      	uxth	r2, r3
 80170ec:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80170ee:	4413      	add	r3, r2
 80170f0:	b29b      	uxth	r3, r3
 80170f2:	b21b      	sxth	r3, r3
 80170f4:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80170f6:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80170fa:	f107 0014 	add.w	r0, r7, #20
 80170fe:	8bba      	ldrh	r2, [r7, #28]
 8017100:	68b9      	ldr	r1, [r7, #8]
 8017102:	f7fd f983 	bl	801440c <lv_draw_fill>
        }

        /*Left bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8017106:	f897 3020 	ldrb.w	r3, [r7, #32]
 801710a:	f003 0301 	and.w	r3, r3, #1
 801710e:	2b00      	cmp	r3, #0
 8017110:	d038      	beq.n	8017184 <lv_draw_rect_border_straight+0x566>
 8017112:	f897 3020 	ldrb.w	r3, [r7, #32]
 8017116:	f003 0304 	and.w	r3, r3, #4
 801711a:	2b00      	cmp	r3, #0
 801711c:	d032      	beq.n	8017184 <lv_draw_rect_border_straight+0x566>
            work_area.x1 = coords->x1;
 801711e:	68fb      	ldr	r3, [r7, #12]
 8017120:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017124:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + radius + aa;
 8017126:	68fb      	ldr	r3, [r7, #12]
 8017128:	f9b3 3000 	ldrsh.w	r3, [r3]
 801712c:	b29a      	uxth	r2, r3
 801712e:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 8017130:	4413      	add	r3, r2
 8017132:	b29a      	uxth	r2, r3
 8017134:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8017138:	b29b      	uxth	r3, r3
 801713a:	4413      	add	r3, r2
 801713c:	b29b      	uxth	r3, r3
 801713e:	b21b      	sxth	r3, r3
 8017140:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 8017142:	68fb      	ldr	r3, [r7, #12]
 8017144:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017148:	b29a      	uxth	r2, r3
 801714a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801714c:	1ad3      	subs	r3, r2, r3
 801714e:	b29b      	uxth	r3, r3
 8017150:	b21b      	sxth	r3, r3
 8017152:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - radius - 1 - aa;
 8017154:	68fb      	ldr	r3, [r7, #12]
 8017156:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801715a:	b29a      	uxth	r2, r3
 801715c:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801715e:	1ad3      	subs	r3, r2, r3
 8017160:	b29a      	uxth	r2, r3
 8017162:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 8017166:	b29b      	uxth	r3, r3
 8017168:	1ad3      	subs	r3, r2, r3
 801716a:	b29b      	uxth	r3, r3
 801716c:	3b01      	subs	r3, #1
 801716e:	b29b      	uxth	r3, r3
 8017170:	b21b      	sxth	r3, r3
 8017172:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8017174:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8017178:	f107 0014 	add.w	r0, r7, #20
 801717c:	8bba      	ldrh	r2, [r7, #28]
 801717e:	68b9      	ldr	r1, [r7, #8]
 8017180:	f7fd f944 	bl	801440c <lv_draw_fill>
        }

        /*Right bottom correction*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8017184:	f897 3020 	ldrb.w	r3, [r7, #32]
 8017188:	f003 0301 	and.w	r3, r3, #1
 801718c:	2b00      	cmp	r3, #0
 801718e:	d038      	beq.n	8017202 <lv_draw_rect_border_straight+0x5e4>
 8017190:	f897 3020 	ldrb.w	r3, [r7, #32]
 8017194:	f003 0308 	and.w	r3, r3, #8
 8017198:	2b00      	cmp	r3, #0
 801719a:	d032      	beq.n	8017202 <lv_draw_rect_border_straight+0x5e4>
            work_area.x1 = coords->x2 - radius - aa;
 801719c:	68fb      	ldr	r3, [r7, #12]
 801719e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80171a2:	b29a      	uxth	r2, r3
 80171a4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80171a6:	1ad3      	subs	r3, r2, r3
 80171a8:	b29a      	uxth	r2, r3
 80171aa:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80171ae:	b29b      	uxth	r3, r3
 80171b0:	1ad3      	subs	r3, r2, r3
 80171b2:	b29b      	uxth	r3, r3
 80171b4:	b21b      	sxth	r3, r3
 80171b6:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 80171b8:	68fb      	ldr	r3, [r7, #12]
 80171ba:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80171be:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - bwidth;
 80171c0:	68fb      	ldr	r3, [r7, #12]
 80171c2:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80171c6:	b29a      	uxth	r2, r3
 80171c8:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80171ca:	1ad3      	subs	r3, r2, r3
 80171cc:	b29b      	uxth	r3, r3
 80171ce:	b21b      	sxth	r3, r3
 80171d0:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2 - radius - 1 - aa;
 80171d2:	68fb      	ldr	r3, [r7, #12]
 80171d4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80171d8:	b29a      	uxth	r2, r3
 80171da:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80171dc:	1ad3      	subs	r3, r2, r3
 80171de:	b29a      	uxth	r2, r3
 80171e0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80171e4:	b29b      	uxth	r3, r3
 80171e6:	1ad3      	subs	r3, r2, r3
 80171e8:	b29b      	uxth	r3, r3
 80171ea:	3b01      	subs	r3, #1
 80171ec:	b29b      	uxth	r3, r3
 80171ee:	b21b      	sxth	r3, r3
 80171f0:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80171f2:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80171f6:	f107 0014 	add.w	r0, r7, #20
 80171fa:	8bba      	ldrh	r2, [r7, #28]
 80171fc:	68b9      	ldr	r1, [r7, #8]
 80171fe:	f7fd f905 	bl	801440c <lv_draw_fill>
        }
    }

    /*If radius == 0 one px on the corners are not drawn by main drawer*/
    if(style->body.radius == 0) {
 8017202:	687b      	ldr	r3, [r7, #4]
 8017204:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017208:	2b00      	cmp	r3, #0
 801720a:	f040 80b2 	bne.w	8017372 <lv_draw_rect_border_straight+0x754>
        /*Left top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_LEFT)) {
 801720e:	f897 3020 	ldrb.w	r3, [r7, #32]
 8017212:	f003 0306 	and.w	r3, r3, #6
 8017216:	2b00      	cmp	r3, #0
 8017218:	d025      	beq.n	8017266 <lv_draw_rect_border_straight+0x648>
            work_area.x1 = coords->x1;
 801721a:	68fb      	ldr	r3, [r7, #12]
 801721c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017220:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + aa;
 8017222:	68fb      	ldr	r3, [r7, #12]
 8017224:	f9b3 3000 	ldrsh.w	r3, [r3]
 8017228:	b29a      	uxth	r2, r3
 801722a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801722e:	b29b      	uxth	r3, r3
 8017230:	4413      	add	r3, r2
 8017232:	b29b      	uxth	r3, r3
 8017234:	b21b      	sxth	r3, r3
 8017236:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 8017238:	68fb      	ldr	r3, [r7, #12]
 801723a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801723e:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + aa;
 8017240:	68fb      	ldr	r3, [r7, #12]
 8017242:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017246:	b29a      	uxth	r2, r3
 8017248:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801724c:	b29b      	uxth	r3, r3
 801724e:	4413      	add	r3, r2
 8017250:	b29b      	uxth	r3, r3
 8017252:	b21b      	sxth	r3, r3
 8017254:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8017256:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801725a:	f107 0014 	add.w	r0, r7, #20
 801725e:	8bba      	ldrh	r2, [r7, #28]
 8017260:	68b9      	ldr	r1, [r7, #8]
 8017262:	f7fd f8d3 	bl	801440c <lv_draw_fill>
        }

        /*Right top corner*/
        if(part & (LV_BORDER_TOP | LV_BORDER_RIGHT)) {
 8017266:	f897 3020 	ldrb.w	r3, [r7, #32]
 801726a:	f003 030a 	and.w	r3, r3, #10
 801726e:	2b00      	cmp	r3, #0
 8017270:	d025      	beq.n	80172be <lv_draw_rect_border_straight+0x6a0>
            work_area.x1 = coords->x2 - aa;
 8017272:	68fb      	ldr	r3, [r7, #12]
 8017274:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017278:	b29a      	uxth	r2, r3
 801727a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801727e:	b29b      	uxth	r3, r3
 8017280:	1ad3      	subs	r3, r2, r3
 8017282:	b29b      	uxth	r3, r3
 8017284:	b21b      	sxth	r3, r3
 8017286:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8017288:	68fb      	ldr	r3, [r7, #12]
 801728a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801728e:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y1;
 8017290:	68fb      	ldr	r3, [r7, #12]
 8017292:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8017296:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y1 + aa;
 8017298:	68fb      	ldr	r3, [r7, #12]
 801729a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801729e:	b29a      	uxth	r2, r3
 80172a0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80172a4:	b29b      	uxth	r3, r3
 80172a6:	4413      	add	r3, r2
 80172a8:	b29b      	uxth	r3, r3
 80172aa:	b21b      	sxth	r3, r3
 80172ac:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 80172ae:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 80172b2:	f107 0014 	add.w	r0, r7, #20
 80172b6:	8bba      	ldrh	r2, [r7, #28]
 80172b8:	68b9      	ldr	r1, [r7, #8]
 80172ba:	f7fd f8a7 	bl	801440c <lv_draw_fill>
        }

        /*Left bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_LEFT)) {
 80172be:	f897 3020 	ldrb.w	r3, [r7, #32]
 80172c2:	f003 0305 	and.w	r3, r3, #5
 80172c6:	2b00      	cmp	r3, #0
 80172c8:	d025      	beq.n	8017316 <lv_draw_rect_border_straight+0x6f8>
            work_area.x1 = coords->x1;
 80172ca:	68fb      	ldr	r3, [r7, #12]
 80172cc:	f9b3 3000 	ldrsh.w	r3, [r3]
 80172d0:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x1 + aa;
 80172d2:	68fb      	ldr	r3, [r7, #12]
 80172d4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80172d8:	b29a      	uxth	r2, r3
 80172da:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80172de:	b29b      	uxth	r3, r3
 80172e0:	4413      	add	r3, r2
 80172e2:	b29b      	uxth	r3, r3
 80172e4:	b21b      	sxth	r3, r3
 80172e6:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - aa;
 80172e8:	68fb      	ldr	r3, [r7, #12]
 80172ea:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80172ee:	b29a      	uxth	r2, r3
 80172f0:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 80172f4:	b29b      	uxth	r3, r3
 80172f6:	1ad3      	subs	r3, r2, r3
 80172f8:	b29b      	uxth	r3, r3
 80172fa:	b21b      	sxth	r3, r3
 80172fc:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 80172fe:	68fb      	ldr	r3, [r7, #12]
 8017300:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017304:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 8017306:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 801730a:	f107 0014 	add.w	r0, r7, #20
 801730e:	8bba      	ldrh	r2, [r7, #28]
 8017310:	68b9      	ldr	r1, [r7, #8]
 8017312:	f7fd f87b 	bl	801440c <lv_draw_fill>
        }

        /*Right bottom corner*/
        if(part & (LV_BORDER_BOTTOM | LV_BORDER_RIGHT)) {
 8017316:	f897 3020 	ldrb.w	r3, [r7, #32]
 801731a:	f003 0309 	and.w	r3, r3, #9
 801731e:	2b00      	cmp	r3, #0
 8017320:	d027      	beq.n	8017372 <lv_draw_rect_border_straight+0x754>
            work_area.x1 = coords->x2 - aa;
 8017322:	68fb      	ldr	r3, [r7, #12]
 8017324:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8017328:	b29a      	uxth	r2, r3
 801732a:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801732e:	b29b      	uxth	r3, r3
 8017330:	1ad3      	subs	r3, r2, r3
 8017332:	b29b      	uxth	r3, r3
 8017334:	b21b      	sxth	r3, r3
 8017336:	82bb      	strh	r3, [r7, #20]
            work_area.x2 = coords->x2;
 8017338:	68fb      	ldr	r3, [r7, #12]
 801733a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801733e:	833b      	strh	r3, [r7, #24]
            work_area.y1 = coords->y2 - aa;
 8017340:	68fb      	ldr	r3, [r7, #12]
 8017342:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017346:	b29a      	uxth	r2, r3
 8017348:	f897 3029 	ldrb.w	r3, [r7, #41]	; 0x29
 801734c:	b29b      	uxth	r3, r3
 801734e:	1ad3      	subs	r3, r2, r3
 8017350:	b29b      	uxth	r3, r3
 8017352:	b21b      	sxth	r3, r3
 8017354:	82fb      	strh	r3, [r7, #22]
            work_area.y2 = coords->y2;
 8017356:	68fb      	ldr	r3, [r7, #12]
 8017358:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801735c:	837b      	strh	r3, [r7, #26]
            lv_draw_fill(&work_area, mask, color, opa);
 801735e:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 8017362:	f107 0014 	add.w	r0, r7, #20
 8017366:	8bba      	ldrh	r2, [r7, #28]
 8017368:	68b9      	ldr	r1, [r7, #8]
 801736a:	f7fd f84f 	bl	801440c <lv_draw_fill>
 801736e:	e000      	b.n	8017372 <lv_draw_rect_border_straight+0x754>
        return;
 8017370:	bf00      	nop
        }
    }
}
 8017372:	3730      	adds	r7, #48	; 0x30
 8017374:	46bd      	mov	sp, r7
 8017376:	bd80      	pop	{r7, pc}

08017378 <lv_draw_rect_border_corner>:
 * @param style pointer to a style
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_rect_border_corner(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                       lv_opa_t opa_scale)
{
 8017378:	b580      	push	{r7, lr}
 801737a:	b0a0      	sub	sp, #128	; 0x80
 801737c:	af02      	add	r7, sp, #8
 801737e:	60f8      	str	r0, [r7, #12]
 8017380:	60b9      	str	r1, [r7, #8]
 8017382:	607a      	str	r2, [r7, #4]
 8017384:	70fb      	strb	r3, [r7, #3]
    uint16_t radius       = style->body.radius;
 8017386:	687b      	ldr	r3, [r7, #4]
 8017388:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801738c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    bool aa               = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8017390:	f7fb fb86 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8017394:	4603      	mov	r3, r0
 8017396:	4618      	mov	r0, r3
 8017398:	f003 fee8 	bl	801b16c <lv_disp_get_antialiasing>
 801739c:	4603      	mov	r3, r0
 801739e:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
    lv_coord_t bwidth     = style->body.border.width;
 80173a2:	687b      	ldr	r3, [r7, #4]
 80173a4:	899b      	ldrh	r3, [r3, #12]
 80173a6:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
    lv_color_t color      = style->body.border.color;
 80173aa:	687b      	ldr	r3, [r7, #4]
 80173ac:	895b      	ldrh	r3, [r3, #10]
 80173ae:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
    lv_border_part_t part = style->body.border.part;
 80173b2:	687b      	ldr	r3, [r7, #4]
 80173b4:	7b9b      	ldrb	r3, [r3, #14]
 80173b6:	f887 305a 	strb.w	r3, [r7, #90]	; 0x5a
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
 80173ba:	78fb      	ldrb	r3, [r7, #3]
 80173bc:	2bff      	cmp	r3, #255	; 0xff
 80173be:	d102      	bne.n	80173c6 <lv_draw_rect_border_corner+0x4e>
 80173c0:	687b      	ldr	r3, [r7, #4]
 80173c2:	7bdb      	ldrb	r3, [r3, #15]
 80173c4:	e00a      	b.n	80173dc <lv_draw_rect_border_corner+0x64>
                                             : (uint16_t)((uint16_t)style->body.border.opa * opa_scale) >> 8;
 80173c6:	687b      	ldr	r3, [r7, #4]
 80173c8:	7bdb      	ldrb	r3, [r3, #15]
 80173ca:	b29a      	uxth	r2, r3
 80173cc:	78fb      	ldrb	r3, [r7, #3]
 80173ce:	b29b      	uxth	r3, r3
 80173d0:	fb12 f303 	smulbb	r3, r2, r3
 80173d4:	b29b      	uxth	r3, r3
    lv_opa_t opa          = opa_scale == LV_OPA_COVER ? style->body.border.opa
 80173d6:	0a1b      	lsrs	r3, r3, #8
 80173d8:	b29b      	uxth	r3, r3
 80173da:	b2db      	uxtb	r3, r3
 80173dc:	f887 3059 	strb.w	r3, [r7, #89]	; 0x59
    /*0 px border width drawn as 1 px, so decrement the bwidth*/
    bwidth--;
 80173e0:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 80173e4:	b29b      	uxth	r3, r3
 80173e6:	3b01      	subs	r3, #1
 80173e8:	b29b      	uxth	r3, r3
 80173ea:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

#if LV_ANTIALIAS
    if(aa) bwidth--; /*Because of anti-aliasing the border seems one pixel ticker*/
 80173ee:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80173f2:	2b00      	cmp	r3, #0
 80173f4:	d006      	beq.n	8017404 <lv_draw_rect_border_corner+0x8c>
 80173f6:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 80173fa:	b29b      	uxth	r3, r3
 80173fc:	3b01      	subs	r3, #1
 80173fe:	b29b      	uxth	r3, r3
 8017400:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
#endif

    lv_coord_t width  = lv_area_get_width(coords);
 8017404:	68f8      	ldr	r0, [r7, #12]
 8017406:	f7fe fa4e 	bl	80158a6 <lv_area_get_width>
 801740a:	4603      	mov	r3, r0
 801740c:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
    lv_coord_t height = lv_area_get_height(coords);
 8017410:	68f8      	ldr	r0, [r7, #12]
 8017412:	f7fe fa5f 	bl	80158d4 <lv_area_get_height>
 8017416:	4603      	mov	r3, r0
 8017418:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54

    radius = lv_draw_cont_radius_corr(radius, width, height);
 801741c:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8017420:	f9b7 1056 	ldrsh.w	r1, [r7, #86]	; 0x56
 8017424:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8017428:	4618      	mov	r0, r3
 801742a:	f002 f8e4 	bl	80195f6 <lv_draw_cont_radius_corr>
 801742e:	4603      	mov	r3, r0
 8017430:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    lv_point_t lt_origo; /*Left  Top    origo*/
    lv_point_t lb_origo; /*Left  Bottom origo*/
    lv_point_t rt_origo; /*Right Top    origo*/
    lv_point_t rb_origo; /*Left  Bottom origo*/

    lt_origo.x = coords->x1 + radius + aa;
 8017434:	68fb      	ldr	r3, [r7, #12]
 8017436:	f9b3 3000 	ldrsh.w	r3, [r3]
 801743a:	b29a      	uxth	r2, r3
 801743c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8017440:	4413      	add	r3, r2
 8017442:	b29a      	uxth	r2, r3
 8017444:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8017448:	b29b      	uxth	r3, r3
 801744a:	4413      	add	r3, r2
 801744c:	b29b      	uxth	r3, r3
 801744e:	b21b      	sxth	r3, r3
 8017450:	f8a7 3040 	strh.w	r3, [r7, #64]	; 0x40
    lt_origo.y = coords->y1 + radius + aa;
 8017454:	68fb      	ldr	r3, [r7, #12]
 8017456:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801745a:	b29a      	uxth	r2, r3
 801745c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8017460:	4413      	add	r3, r2
 8017462:	b29a      	uxth	r2, r3
 8017464:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8017468:	b29b      	uxth	r3, r3
 801746a:	4413      	add	r3, r2
 801746c:	b29b      	uxth	r3, r3
 801746e:	b21b      	sxth	r3, r3
 8017470:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42

    lb_origo.x = coords->x1 + radius + aa;
 8017474:	68fb      	ldr	r3, [r7, #12]
 8017476:	f9b3 3000 	ldrsh.w	r3, [r3]
 801747a:	b29a      	uxth	r2, r3
 801747c:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8017480:	4413      	add	r3, r2
 8017482:	b29a      	uxth	r2, r3
 8017484:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8017488:	b29b      	uxth	r3, r3
 801748a:	4413      	add	r3, r2
 801748c:	b29b      	uxth	r3, r3
 801748e:	b21b      	sxth	r3, r3
 8017490:	87bb      	strh	r3, [r7, #60]	; 0x3c
    lb_origo.y = coords->y2 - radius - aa;
 8017492:	68fb      	ldr	r3, [r7, #12]
 8017494:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017498:	b29a      	uxth	r2, r3
 801749a:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 801749e:	1ad3      	subs	r3, r2, r3
 80174a0:	b29a      	uxth	r2, r3
 80174a2:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80174a6:	b29b      	uxth	r3, r3
 80174a8:	1ad3      	subs	r3, r2, r3
 80174aa:	b29b      	uxth	r3, r3
 80174ac:	b21b      	sxth	r3, r3
 80174ae:	87fb      	strh	r3, [r7, #62]	; 0x3e

    rt_origo.x = coords->x2 - radius - aa;
 80174b0:	68fb      	ldr	r3, [r7, #12]
 80174b2:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80174b6:	b29a      	uxth	r2, r3
 80174b8:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80174bc:	1ad3      	subs	r3, r2, r3
 80174be:	b29a      	uxth	r2, r3
 80174c0:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80174c4:	b29b      	uxth	r3, r3
 80174c6:	1ad3      	subs	r3, r2, r3
 80174c8:	b29b      	uxth	r3, r3
 80174ca:	b21b      	sxth	r3, r3
 80174cc:	873b      	strh	r3, [r7, #56]	; 0x38
    rt_origo.y = coords->y1 + radius + aa;
 80174ce:	68fb      	ldr	r3, [r7, #12]
 80174d0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80174d4:	b29a      	uxth	r2, r3
 80174d6:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80174da:	4413      	add	r3, r2
 80174dc:	b29a      	uxth	r2, r3
 80174de:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80174e2:	b29b      	uxth	r3, r3
 80174e4:	4413      	add	r3, r2
 80174e6:	b29b      	uxth	r3, r3
 80174e8:	b21b      	sxth	r3, r3
 80174ea:	877b      	strh	r3, [r7, #58]	; 0x3a

    rb_origo.x = coords->x2 - radius - aa;
 80174ec:	68fb      	ldr	r3, [r7, #12]
 80174ee:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80174f2:	b29a      	uxth	r2, r3
 80174f4:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 80174f8:	1ad3      	subs	r3, r2, r3
 80174fa:	b29a      	uxth	r2, r3
 80174fc:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8017500:	b29b      	uxth	r3, r3
 8017502:	1ad3      	subs	r3, r2, r3
 8017504:	b29b      	uxth	r3, r3
 8017506:	b21b      	sxth	r3, r3
 8017508:	86bb      	strh	r3, [r7, #52]	; 0x34
    rb_origo.y = coords->y2 - radius - aa;
 801750a:	68fb      	ldr	r3, [r7, #12]
 801750c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8017510:	b29a      	uxth	r2, r3
 8017512:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 8017516:	1ad3      	subs	r3, r2, r3
 8017518:	b29a      	uxth	r2, r3
 801751a:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 801751e:	b29b      	uxth	r3, r3
 8017520:	1ad3      	subs	r3, r2, r3
 8017522:	b29b      	uxth	r3, r3
 8017524:	b21b      	sxth	r3, r3
 8017526:	86fb      	strh	r3, [r7, #54]	; 0x36

    lv_point_t cir_out;
    lv_coord_t tmp_out;
    lv_circ_init(&cir_out, &tmp_out, radius);
 8017528:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 801752c:	f107 012e 	add.w	r1, r7, #46	; 0x2e
 8017530:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8017534:	4618      	mov	r0, r3
 8017536:	f004 fbea 	bl	801bd0e <lv_circ_init>

    lv_point_t cir_in;
    lv_coord_t tmp_in;
    lv_coord_t radius_in = radius - bwidth;
 801753a:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801753e:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8017542:	1ad3      	subs	r3, r2, r3
 8017544:	b29b      	uxth	r3, r3
 8017546:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74

    if(radius_in < 0) {
 801754a:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 801754e:	2b00      	cmp	r3, #0
 8017550:	da02      	bge.n	8017558 <lv_draw_rect_border_corner+0x1e0>
        radius_in = 0;
 8017552:	2300      	movs	r3, #0
 8017554:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
    }

    lv_circ_init(&cir_in, &tmp_in, radius_in);
 8017558:	f9b7 2074 	ldrsh.w	r2, [r7, #116]	; 0x74
 801755c:	f107 0126 	add.w	r1, r7, #38	; 0x26
 8017560:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8017564:	4618      	mov	r0, r3
 8017566:	f004 fbd2 	bl	801bd0e <lv_circ_init>
    lv_coord_t act_w1;
    lv_coord_t act_w2;

#if LV_ANTIALIAS
    /*Store some internal states for anti-aliasing*/
    lv_coord_t out_y_seg_start = 0;
 801756a:	2300      	movs	r3, #0
 801756c:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
    lv_coord_t out_y_seg_end   = 0;
 8017570:	2300      	movs	r3, #0
 8017572:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    lv_coord_t out_x_last      = radius;
 8017576:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 801757a:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c

    lv_coord_t in_y_seg_start = 0;
 801757e:	2300      	movs	r3, #0
 8017580:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
    lv_coord_t in_y_seg_end   = 0;
 8017584:	2300      	movs	r3, #0
 8017586:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    lv_coord_t in_x_last      = radius - bwidth;
 801758a:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 801758e:	f8b7 205c 	ldrh.w	r2, [r7, #92]	; 0x5c
 8017592:	1ad3      	subs	r3, r2, r3
 8017594:	b29b      	uxth	r3, r3
 8017596:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
#endif

    while(cir_out.y <= cir_out.x) {
 801759a:	f000 bd74 	b.w	8018086 <lv_draw_rect_border_corner+0xd0e>

        /*Calculate the actual width to avoid overwriting pixels*/
        if(cir_in.y < cir_in.x) {
 801759e:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 80175a2:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80175a6:	429a      	cmp	r2, r3
 80175a8:	da0e      	bge.n	80175c8 <lv_draw_rect_border_corner+0x250>
            act_w1 = cir_out.x - cir_in.x;
 80175aa:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80175ae:	b29a      	uxth	r2, r3
 80175b0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80175b4:	b29b      	uxth	r3, r3
 80175b6:	1ad3      	subs	r3, r2, r3
 80175b8:	b29b      	uxth	r3, r3
 80175ba:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            act_w2 = act_w1;
 80175be:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 80175c2:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 80175c6:	e00f      	b.n	80175e8 <lv_draw_rect_border_corner+0x270>
        } else {
            act_w1 = cir_out.x - cir_out.y;
 80175c8:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80175cc:	b29a      	uxth	r2, r3
 80175ce:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 80175d2:	b29b      	uxth	r3, r3
 80175d4:	1ad3      	subs	r3, r2, r3
 80175d6:	b29b      	uxth	r3, r3
 80175d8:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            act_w2 = act_w1 - 1;
 80175dc:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 80175e0:	3b01      	subs	r3, #1
 80175e2:	b29b      	uxth	r3, r3
 80175e4:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
        }

#if LV_ANTIALIAS
        if(aa) {
 80175e8:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 80175ec:	2b00      	cmp	r3, #0
 80175ee:	f000 8340 	beq.w	8017c72 <lv_draw_rect_border_corner+0x8fa>
            /*New step in y on the outter circle*/
            if(out_x_last != cir_out.x) {
 80175f2:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 80175f6:	f9b7 206c 	ldrsh.w	r2, [r7, #108]	; 0x6c
 80175fa:	429a      	cmp	r2, r3
 80175fc:	f000 817b 	beq.w	80178f6 <lv_draw_rect_border_corner+0x57e>
                out_y_seg_end       = cir_out.y;
 8017600:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8017602:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 8017606:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 801760a:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 801760e:	1ad3      	subs	r3, r2, r3
 8017610:	b29b      	uxth	r3, r3
 8017612:	f8a7 3048 	strh.w	r3, [r7, #72]	; 0x48
                lv_point_t aa_p;

                aa_p.x = out_x_last;
 8017616:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 801761a:	833b      	strh	r3, [r7, #24]
                aa_p.y = out_y_seg_start;
 801761c:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 8017620:	837b      	strh	r3, [r7, #26]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8017622:	2300      	movs	r3, #0
 8017624:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8017628:	e157      	b.n	80178da <lv_draw_rect_border_corner+0x562>
                    lv_opa_t aa_opa;

                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 801762a:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 801762e:	2b01      	cmp	r3, #1
 8017630:	dd0c      	ble.n	801764c <lv_draw_rect_border_corner+0x2d4>
                                                                           on the first segment*/
                        aa_opa = antialias_get_opa_circ(seg_size, i, opa);
 8017632:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8017636:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 801763a:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 801763e:	4618      	mov	r0, r3
 8017640:	f002 f81c 	bl	801967c <antialias_get_opa_circ>
 8017644:	4603      	mov	r3, r0
 8017646:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
 801764a:	e00f      	b.n	801766c <lv_draw_rect_border_corner+0x2f4>
                    } else {
                        aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 801764c:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 8017650:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 8017654:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 8017658:	4618      	mov	r0, r3
 801765a:	f7fc fd65 	bl	8014128 <lv_draw_aa_get_opa>
 801765e:	4603      	mov	r3, r0
 8017660:	461a      	mov	r2, r3
 8017662:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017666:	1a9b      	subs	r3, r3, r2
 8017668:	f887 3065 	strb.w	r3, [r7, #101]	; 0x65
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801766c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017670:	f003 0301 	and.w	r3, r3, #1
 8017674:	2b00      	cmp	r3, #0
 8017676:	d045      	beq.n	8017704 <lv_draw_rect_border_corner+0x38c>
 8017678:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801767c:	f003 0308 	and.w	r3, r3, #8
 8017680:	2b00      	cmp	r3, #0
 8017682:	d03f      	beq.n	8017704 <lv_draw_rect_border_corner+0x38c>
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8017684:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017688:	b29a      	uxth	r2, r3
 801768a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801768e:	b29b      	uxth	r3, r3
 8017690:	4413      	add	r3, r2
 8017692:	b29b      	uxth	r3, r3
 8017694:	3301      	adds	r3, #1
 8017696:	b29b      	uxth	r3, r3
 8017698:	b218      	sxth	r0, r3
 801769a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801769e:	b29a      	uxth	r2, r3
 80176a0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80176a4:	b29b      	uxth	r3, r3
 80176a6:	4413      	add	r3, r2
 80176a8:	b29a      	uxth	r2, r3
 80176aa:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80176ae:	4413      	add	r3, r2
 80176b0:	b29b      	uxth	r3, r3
 80176b2:	b219      	sxth	r1, r3
 80176b4:	687b      	ldr	r3, [r7, #4]
 80176b6:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80176ba:	9200      	str	r2, [sp, #0]
 80176bc:	895b      	ldrh	r3, [r3, #10]
 80176be:	68ba      	ldr	r2, [r7, #8]
 80176c0:	f7fc fe0b 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 80176c4:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80176c8:	b29a      	uxth	r2, r3
 80176ca:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80176ce:	b29b      	uxth	r3, r3
 80176d0:	4413      	add	r3, r2
 80176d2:	b29a      	uxth	r2, r3
 80176d4:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80176d8:	4413      	add	r3, r2
 80176da:	b29b      	uxth	r3, r3
 80176dc:	b218      	sxth	r0, r3
 80176de:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80176e2:	b29a      	uxth	r2, r3
 80176e4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80176e8:	b29b      	uxth	r3, r3
 80176ea:	4413      	add	r3, r2
 80176ec:	b29b      	uxth	r3, r3
 80176ee:	3301      	adds	r3, #1
 80176f0:	b29b      	uxth	r3, r3
 80176f2:	b219      	sxth	r1, r3
 80176f4:	687b      	ldr	r3, [r7, #4]
 80176f6:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80176fa:	9200      	str	r2, [sp, #0]
 80176fc:	895b      	ldrh	r3, [r3, #10]
 80176fe:	68ba      	ldr	r2, [r7, #8]
 8017700:	f7fc fdeb 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8017704:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017708:	f003 0301 	and.w	r3, r3, #1
 801770c:	2b00      	cmp	r3, #0
 801770e:	d045      	beq.n	801779c <lv_draw_rect_border_corner+0x424>
 8017710:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017714:	f003 0304 	and.w	r3, r3, #4
 8017718:	2b00      	cmp	r3, #0
 801771a:	d03f      	beq.n	801779c <lv_draw_rect_border_corner+0x424>
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 801771c:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017720:	b29a      	uxth	r2, r3
 8017722:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017726:	b29b      	uxth	r3, r3
 8017728:	1ad3      	subs	r3, r2, r3
 801772a:	b29a      	uxth	r2, r3
 801772c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8017730:	1ad3      	subs	r3, r2, r3
 8017732:	b29b      	uxth	r3, r3
 8017734:	b218      	sxth	r0, r3
 8017736:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801773a:	b29a      	uxth	r2, r3
 801773c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8017740:	b29b      	uxth	r3, r3
 8017742:	4413      	add	r3, r2
 8017744:	b29b      	uxth	r3, r3
 8017746:	3301      	adds	r3, #1
 8017748:	b29b      	uxth	r3, r3
 801774a:	b219      	sxth	r1, r3
 801774c:	687b      	ldr	r3, [r7, #4]
 801774e:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8017752:	9200      	str	r2, [sp, #0]
 8017754:	895b      	ldrh	r3, [r3, #10]
 8017756:	68ba      	ldr	r2, [r7, #8]
 8017758:	f7fc fdbf 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 801775c:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017760:	b29a      	uxth	r2, r3
 8017762:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8017766:	b29b      	uxth	r3, r3
 8017768:	1ad3      	subs	r3, r2, r3
 801776a:	b29b      	uxth	r3, r3
 801776c:	3b01      	subs	r3, #1
 801776e:	b29b      	uxth	r3, r3
 8017770:	b218      	sxth	r0, r3
 8017772:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017776:	b29a      	uxth	r2, r3
 8017778:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801777c:	b29b      	uxth	r3, r3
 801777e:	4413      	add	r3, r2
 8017780:	b29a      	uxth	r2, r3
 8017782:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8017786:	4413      	add	r3, r2
 8017788:	b29b      	uxth	r3, r3
 801778a:	b219      	sxth	r1, r3
 801778c:	687b      	ldr	r3, [r7, #4]
 801778e:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8017792:	9200      	str	r2, [sp, #0]
 8017794:	895b      	ldrh	r3, [r3, #10]
 8017796:	68ba      	ldr	r2, [r7, #8]
 8017798:	f7fc fd9f 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 801779c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80177a0:	f003 0302 	and.w	r3, r3, #2
 80177a4:	2b00      	cmp	r3, #0
 80177a6:	d045      	beq.n	8017834 <lv_draw_rect_border_corner+0x4bc>
 80177a8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80177ac:	f003 0304 	and.w	r3, r3, #4
 80177b0:	2b00      	cmp	r3, #0
 80177b2:	d03f      	beq.n	8017834 <lv_draw_rect_border_corner+0x4bc>
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 80177b4:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80177b8:	b29a      	uxth	r2, r3
 80177ba:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80177be:	b29b      	uxth	r3, r3
 80177c0:	1ad3      	subs	r3, r2, r3
 80177c2:	b29b      	uxth	r3, r3
 80177c4:	3b01      	subs	r3, #1
 80177c6:	b29b      	uxth	r3, r3
 80177c8:	b218      	sxth	r0, r3
 80177ca:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80177ce:	b29a      	uxth	r2, r3
 80177d0:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80177d4:	b29b      	uxth	r3, r3
 80177d6:	1ad3      	subs	r3, r2, r3
 80177d8:	b29a      	uxth	r2, r3
 80177da:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80177de:	1ad3      	subs	r3, r2, r3
 80177e0:	b29b      	uxth	r3, r3
 80177e2:	b219      	sxth	r1, r3
 80177e4:	687b      	ldr	r3, [r7, #4]
 80177e6:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80177ea:	9200      	str	r2, [sp, #0]
 80177ec:	895b      	ldrh	r3, [r3, #10]
 80177ee:	68ba      	ldr	r2, [r7, #8]
 80177f0:	f7fc fd73 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 80177f4:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80177f8:	b29a      	uxth	r2, r3
 80177fa:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80177fe:	b29b      	uxth	r3, r3
 8017800:	1ad3      	subs	r3, r2, r3
 8017802:	b29a      	uxth	r2, r3
 8017804:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8017808:	1ad3      	subs	r3, r2, r3
 801780a:	b29b      	uxth	r3, r3
 801780c:	b218      	sxth	r0, r3
 801780e:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017812:	b29a      	uxth	r2, r3
 8017814:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8017818:	b29b      	uxth	r3, r3
 801781a:	1ad3      	subs	r3, r2, r3
 801781c:	b29b      	uxth	r3, r3
 801781e:	3b01      	subs	r3, #1
 8017820:	b29b      	uxth	r3, r3
 8017822:	b219      	sxth	r1, r3
 8017824:	687b      	ldr	r3, [r7, #4]
 8017826:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 801782a:	9200      	str	r2, [sp, #0]
 801782c:	895b      	ldrh	r3, [r3, #10]
 801782e:	68ba      	ldr	r2, [r7, #8]
 8017830:	f7fc fd53 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8017834:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017838:	f003 0302 	and.w	r3, r3, #2
 801783c:	2b00      	cmp	r3, #0
 801783e:	d045      	beq.n	80178cc <lv_draw_rect_border_corner+0x554>
 8017840:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017844:	f003 0308 	and.w	r3, r3, #8
 8017848:	2b00      	cmp	r3, #0
 801784a:	d03f      	beq.n	80178cc <lv_draw_rect_border_corner+0x554>
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 801784c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017850:	b29a      	uxth	r2, r3
 8017852:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8017856:	b29b      	uxth	r3, r3
 8017858:	4413      	add	r3, r2
 801785a:	b29a      	uxth	r2, r3
 801785c:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 8017860:	4413      	add	r3, r2
 8017862:	b29b      	uxth	r3, r3
 8017864:	b218      	sxth	r0, r3
 8017866:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 801786a:	b29a      	uxth	r2, r3
 801786c:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8017870:	b29b      	uxth	r3, r3
 8017872:	1ad3      	subs	r3, r2, r3
 8017874:	b29b      	uxth	r3, r3
 8017876:	3b01      	subs	r3, #1
 8017878:	b29b      	uxth	r3, r3
 801787a:	b219      	sxth	r1, r3
 801787c:	687b      	ldr	r3, [r7, #4]
 801787e:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 8017882:	9200      	str	r2, [sp, #0]
 8017884:	895b      	ldrh	r3, [r3, #10]
 8017886:	68ba      	ldr	r2, [r7, #8]
 8017888:	f7fc fd27 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 801788c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017890:	b29a      	uxth	r2, r3
 8017892:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8017896:	b29b      	uxth	r3, r3
 8017898:	4413      	add	r3, r2
 801789a:	b29b      	uxth	r3, r3
 801789c:	3301      	adds	r3, #1
 801789e:	b29b      	uxth	r3, r3
 80178a0:	b218      	sxth	r0, r3
 80178a2:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80178a6:	b29a      	uxth	r2, r3
 80178a8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80178ac:	b29b      	uxth	r3, r3
 80178ae:	1ad3      	subs	r3, r2, r3
 80178b0:	b29a      	uxth	r2, r3
 80178b2:	f8b7 3066 	ldrh.w	r3, [r7, #102]	; 0x66
 80178b6:	1ad3      	subs	r3, r2, r3
 80178b8:	b29b      	uxth	r3, r3
 80178ba:	b219      	sxth	r1, r3
 80178bc:	687b      	ldr	r3, [r7, #4]
 80178be:	f897 2065 	ldrb.w	r2, [r7, #101]	; 0x65
 80178c2:	9200      	str	r2, [sp, #0]
 80178c4:	895b      	ldrh	r3, [r3, #10]
 80178c6:	68ba      	ldr	r2, [r7, #8]
 80178c8:	f7fc fd07 	bl	80142da <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 80178cc:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 80178d0:	b29b      	uxth	r3, r3
 80178d2:	3301      	adds	r3, #1
 80178d4:	b29b      	uxth	r3, r3
 80178d6:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 80178da:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 80178de:	f9b7 3048 	ldrsh.w	r3, [r7, #72]	; 0x48
 80178e2:	429a      	cmp	r2, r3
 80178e4:	f6ff aea1 	blt.w	801762a <lv_draw_rect_border_corner+0x2b2>
                                   style->body.border.color, aa_opa);
                    }
                }

                out_x_last      = cir_out.x;
 80178e8:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 80178ea:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
                out_y_seg_start = out_y_seg_end;
 80178ee:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 80178f2:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
            }

            /*New step in y on the inner circle*/
            if(in_x_last != cir_in.x) {
 80178f6:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80178fa:	f9b7 2068 	ldrsh.w	r2, [r7, #104]	; 0x68
 80178fe:	429a      	cmp	r2, r3
 8017900:	f000 81b7 	beq.w	8017c72 <lv_draw_rect_border_corner+0x8fa>
                in_y_seg_end        = cir_out.y;
 8017904:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 8017906:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                lv_coord_t seg_size = in_y_seg_end - in_y_seg_start;
 801790a:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 801790e:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8017912:	1ad3      	subs	r3, r2, r3
 8017914:	b29b      	uxth	r3, r3
 8017916:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
                lv_point_t aa_p;

                aa_p.x = in_x_last;
 801791a:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 801791e:	82bb      	strh	r3, [r7, #20]
                aa_p.y = in_y_seg_start;
 8017920:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 8017924:	82fb      	strh	r3, [r7, #22]

                lv_coord_t i;
                for(i = 0; i < seg_size; i++) {
 8017926:	2300      	movs	r3, #0
 8017928:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 801792c:	e193      	b.n	8017c56 <lv_draw_rect_border_corner+0x8de>
                    lv_opa_t aa_opa;

                    if(seg_size > CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD) { /*Use non-linear opa mapping
 801792e:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8017932:	2b01      	cmp	r3, #1
 8017934:	dd10      	ble.n	8017958 <lv_draw_rect_border_corner+0x5e0>
                                                                           on the first segment*/
                        aa_opa = opa - antialias_get_opa_circ(seg_size, i, opa);
 8017936:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 801793a:	f9b7 1062 	ldrsh.w	r1, [r7, #98]	; 0x62
 801793e:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8017942:	4618      	mov	r0, r3
 8017944:	f001 fe9a 	bl	801967c <antialias_get_opa_circ>
 8017948:	4603      	mov	r3, r0
 801794a:	461a      	mov	r2, r3
 801794c:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017950:	1a9b      	subs	r3, r3, r2
 8017952:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
 8017956:	e00b      	b.n	8017970 <lv_draw_rect_border_corner+0x5f8>
                    } else {
                        aa_opa = lv_draw_aa_get_opa(seg_size, i, opa);
 8017958:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 801795c:	f9b7 1062 	ldrsh.w	r1, [r7, #98]	; 0x62
 8017960:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8017964:	4618      	mov	r0, r3
 8017966:	f7fc fbdf 	bl	8014128 <lv_draw_aa_get_opa>
 801796a:	4603      	mov	r3, r0
 801796c:	f887 3061 	strb.w	r3, [r7, #97]	; 0x61
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8017970:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017974:	f003 0301 	and.w	r3, r3, #1
 8017978:	2b00      	cmp	r3, #0
 801797a:	d025      	beq.n	80179c8 <lv_draw_rect_border_corner+0x650>
 801797c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017980:	f003 0308 	and.w	r3, r3, #8
 8017984:	2b00      	cmp	r3, #0
 8017986:	d01f      	beq.n	80179c8 <lv_draw_rect_border_corner+0x650>
                        lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) - 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8017988:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801798c:	b29a      	uxth	r2, r3
 801798e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017992:	b29b      	uxth	r3, r3
 8017994:	4413      	add	r3, r2
 8017996:	b29b      	uxth	r3, r3
 8017998:	3b01      	subs	r3, #1
 801799a:	b29b      	uxth	r3, r3
 801799c:	b218      	sxth	r0, r3
 801799e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80179a2:	b29a      	uxth	r2, r3
 80179a4:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80179a8:	b29b      	uxth	r3, r3
 80179aa:	4413      	add	r3, r2
 80179ac:	b29a      	uxth	r2, r3
 80179ae:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 80179b2:	4413      	add	r3, r2
 80179b4:	b29b      	uxth	r3, r3
 80179b6:	b219      	sxth	r1, r3
 80179b8:	687b      	ldr	r3, [r7, #4]
 80179ba:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 80179be:	9200      	str	r2, [sp, #0]
 80179c0:	895b      	ldrh	r3, [r3, #10]
 80179c2:	68ba      	ldr	r2, [r7, #8]
 80179c4:	f7fc fc89 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 80179c8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80179cc:	f003 0301 	and.w	r3, r3, #1
 80179d0:	2b00      	cmp	r3, #0
 80179d2:	d025      	beq.n	8017a20 <lv_draw_rect_border_corner+0x6a8>
 80179d4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80179d8:	f003 0304 	and.w	r3, r3, #4
 80179dc:	2b00      	cmp	r3, #0
 80179de:	d01f      	beq.n	8017a20 <lv_draw_rect_border_corner+0x6a8>
                        lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) - 1, mask,
 80179e0:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80179e4:	b29a      	uxth	r2, r3
 80179e6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80179ea:	b29b      	uxth	r3, r3
 80179ec:	1ad3      	subs	r3, r2, r3
 80179ee:	b29a      	uxth	r2, r3
 80179f0:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 80179f4:	1ad3      	subs	r3, r2, r3
 80179f6:	b29b      	uxth	r3, r3
 80179f8:	b218      	sxth	r0, r3
 80179fa:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80179fe:	b29a      	uxth	r2, r3
 8017a00:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017a04:	b29b      	uxth	r3, r3
 8017a06:	4413      	add	r3, r2
 8017a08:	b29b      	uxth	r3, r3
 8017a0a:	3b01      	subs	r3, #1
 8017a0c:	b29b      	uxth	r3, r3
 8017a0e:	b219      	sxth	r1, r3
 8017a10:	687b      	ldr	r3, [r7, #4]
 8017a12:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017a16:	9200      	str	r2, [sp, #0]
 8017a18:	895b      	ldrh	r3, [r3, #10]
 8017a1a:	68ba      	ldr	r2, [r7, #8]
 8017a1c:	f7fc fc5d 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8017a20:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017a24:	f003 0302 	and.w	r3, r3, #2
 8017a28:	2b00      	cmp	r3, #0
 8017a2a:	d025      	beq.n	8017a78 <lv_draw_rect_border_corner+0x700>
 8017a2c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017a30:	f003 0304 	and.w	r3, r3, #4
 8017a34:	2b00      	cmp	r3, #0
 8017a36:	d01f      	beq.n	8017a78 <lv_draw_rect_border_corner+0x700>
                        lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) + 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8017a38:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017a3c:	b29a      	uxth	r2, r3
 8017a3e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017a42:	b29b      	uxth	r3, r3
 8017a44:	1ad3      	subs	r3, r2, r3
 8017a46:	b29b      	uxth	r3, r3
 8017a48:	3301      	adds	r3, #1
 8017a4a:	b29b      	uxth	r3, r3
 8017a4c:	b218      	sxth	r0, r3
 8017a4e:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017a52:	b29a      	uxth	r2, r3
 8017a54:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017a58:	b29b      	uxth	r3, r3
 8017a5a:	1ad3      	subs	r3, r2, r3
 8017a5c:	b29a      	uxth	r2, r3
 8017a5e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017a62:	1ad3      	subs	r3, r2, r3
 8017a64:	b29b      	uxth	r3, r3
 8017a66:	b219      	sxth	r1, r3
 8017a68:	687b      	ldr	r3, [r7, #4]
 8017a6a:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017a6e:	9200      	str	r2, [sp, #0]
 8017a70:	895b      	ldrh	r3, [r3, #10]
 8017a72:	68ba      	ldr	r2, [r7, #8]
 8017a74:	f7fc fc31 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8017a78:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017a7c:	f003 0302 	and.w	r3, r3, #2
 8017a80:	2b00      	cmp	r3, #0
 8017a82:	d025      	beq.n	8017ad0 <lv_draw_rect_border_corner+0x758>
 8017a84:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017a88:	f003 0308 	and.w	r3, r3, #8
 8017a8c:	2b00      	cmp	r3, #0
 8017a8e:	d01f      	beq.n	8017ad0 <lv_draw_rect_border_corner+0x758>
                        lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) + 1, mask,
 8017a90:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017a94:	b29a      	uxth	r2, r3
 8017a96:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017a9a:	b29b      	uxth	r3, r3
 8017a9c:	4413      	add	r3, r2
 8017a9e:	b29a      	uxth	r2, r3
 8017aa0:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017aa4:	4413      	add	r3, r2
 8017aa6:	b29b      	uxth	r3, r3
 8017aa8:	b218      	sxth	r0, r3
 8017aaa:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8017aae:	b29a      	uxth	r2, r3
 8017ab0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017ab4:	b29b      	uxth	r3, r3
 8017ab6:	1ad3      	subs	r3, r2, r3
 8017ab8:	b29b      	uxth	r3, r3
 8017aba:	3301      	adds	r3, #1
 8017abc:	b29b      	uxth	r3, r3
 8017abe:	b219      	sxth	r1, r3
 8017ac0:	687b      	ldr	r3, [r7, #4]
 8017ac2:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017ac6:	9200      	str	r2, [sp, #0]
 8017ac8:	895b      	ldrh	r3, [r3, #10]
 8017aca:	68ba      	ldr	r2, [r7, #8]
 8017acc:	f7fc fc05 	bl	80142da <lv_draw_px>
                                   style->body.border.color, aa_opa);
                    }

                    /*Be sure the pixels on the middle are not drawn twice*/
                    if(LV_CIRC_OCT1_X(aa_p) - 1 != LV_CIRC_OCT2_X(aa_p) + i) {
 8017ad0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017ad4:	1e5a      	subs	r2, r3, #1
 8017ad6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017ada:	4619      	mov	r1, r3
 8017adc:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8017ae0:	440b      	add	r3, r1
 8017ae2:	429a      	cmp	r2, r3
 8017ae4:	f000 80b0 	beq.w	8017c48 <lv_draw_rect_border_corner+0x8d0>
                        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8017ae8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017aec:	f003 0301 	and.w	r3, r3, #1
 8017af0:	2b00      	cmp	r3, #0
 8017af2:	d025      	beq.n	8017b40 <lv_draw_rect_border_corner+0x7c8>
 8017af4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017af8:	f003 0308 	and.w	r3, r3, #8
 8017afc:	2b00      	cmp	r3, #0
 8017afe:	d01f      	beq.n	8017b40 <lv_draw_rect_border_corner+0x7c8>
                            lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) - 1,
 8017b00:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017b04:	b29a      	uxth	r2, r3
 8017b06:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017b0a:	b29b      	uxth	r3, r3
 8017b0c:	4413      	add	r3, r2
 8017b0e:	b29a      	uxth	r2, r3
 8017b10:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017b14:	4413      	add	r3, r2
 8017b16:	b29b      	uxth	r3, r3
 8017b18:	b218      	sxth	r0, r3
 8017b1a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017b1e:	b29a      	uxth	r2, r3
 8017b20:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017b24:	b29b      	uxth	r3, r3
 8017b26:	4413      	add	r3, r2
 8017b28:	b29b      	uxth	r3, r3
 8017b2a:	3b01      	subs	r3, #1
 8017b2c:	b29b      	uxth	r3, r3
 8017b2e:	b219      	sxth	r1, r3
 8017b30:	687b      	ldr	r3, [r7, #4]
 8017b32:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017b36:	9200      	str	r2, [sp, #0]
 8017b38:	895b      	ldrh	r3, [r3, #10]
 8017b3a:	68ba      	ldr	r2, [r7, #8]
 8017b3c:	f7fc fbcd 	bl	80142da <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8017b40:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017b44:	f003 0301 	and.w	r3, r3, #1
 8017b48:	2b00      	cmp	r3, #0
 8017b4a:	d025      	beq.n	8017b98 <lv_draw_rect_border_corner+0x820>
 8017b4c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017b50:	f003 0304 	and.w	r3, r3, #4
 8017b54:	2b00      	cmp	r3, #0
 8017b56:	d01f      	beq.n	8017b98 <lv_draw_rect_border_corner+0x820>
                            lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) + 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i,
 8017b58:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017b5c:	b29a      	uxth	r2, r3
 8017b5e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017b62:	b29b      	uxth	r3, r3
 8017b64:	1ad3      	subs	r3, r2, r3
 8017b66:	b29b      	uxth	r3, r3
 8017b68:	3301      	adds	r3, #1
 8017b6a:	b29b      	uxth	r3, r3
 8017b6c:	b218      	sxth	r0, r3
 8017b6e:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017b72:	b29a      	uxth	r2, r3
 8017b74:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017b78:	b29b      	uxth	r3, r3
 8017b7a:	4413      	add	r3, r2
 8017b7c:	b29a      	uxth	r2, r3
 8017b7e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017b82:	4413      	add	r3, r2
 8017b84:	b29b      	uxth	r3, r3
 8017b86:	b219      	sxth	r1, r3
 8017b88:	687b      	ldr	r3, [r7, #4]
 8017b8a:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017b8e:	9200      	str	r2, [sp, #0]
 8017b90:	895b      	ldrh	r3, [r3, #10]
 8017b92:	68ba      	ldr	r2, [r7, #8]
 8017b94:	f7fc fba1 	bl	80142da <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8017b98:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017b9c:	f003 0302 	and.w	r3, r3, #2
 8017ba0:	2b00      	cmp	r3, #0
 8017ba2:	d025      	beq.n	8017bf0 <lv_draw_rect_border_corner+0x878>
 8017ba4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017ba8:	f003 0304 	and.w	r3, r3, #4
 8017bac:	2b00      	cmp	r3, #0
 8017bae:	d01f      	beq.n	8017bf0 <lv_draw_rect_border_corner+0x878>
                            lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) + 1,
 8017bb0:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017bb4:	b29a      	uxth	r2, r3
 8017bb6:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017bba:	b29b      	uxth	r3, r3
 8017bbc:	1ad3      	subs	r3, r2, r3
 8017bbe:	b29a      	uxth	r2, r3
 8017bc0:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017bc4:	1ad3      	subs	r3, r2, r3
 8017bc6:	b29b      	uxth	r3, r3
 8017bc8:	b218      	sxth	r0, r3
 8017bca:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017bce:	b29a      	uxth	r2, r3
 8017bd0:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017bd4:	b29b      	uxth	r3, r3
 8017bd6:	1ad3      	subs	r3, r2, r3
 8017bd8:	b29b      	uxth	r3, r3
 8017bda:	3301      	adds	r3, #1
 8017bdc:	b29b      	uxth	r3, r3
 8017bde:	b219      	sxth	r1, r3
 8017be0:	687b      	ldr	r3, [r7, #4]
 8017be2:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017be6:	9200      	str	r2, [sp, #0]
 8017be8:	895b      	ldrh	r3, [r3, #10]
 8017bea:	68ba      	ldr	r2, [r7, #8]
 8017bec:	f7fc fb75 	bl	80142da <lv_draw_px>
                                       mask, style->body.border.color, aa_opa);
                        }

                        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8017bf0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017bf4:	f003 0302 	and.w	r3, r3, #2
 8017bf8:	2b00      	cmp	r3, #0
 8017bfa:	d025      	beq.n	8017c48 <lv_draw_rect_border_corner+0x8d0>
 8017bfc:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017c00:	f003 0308 	and.w	r3, r3, #8
 8017c04:	2b00      	cmp	r3, #0
 8017c06:	d01f      	beq.n	8017c48 <lv_draw_rect_border_corner+0x8d0>
                            lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) - 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i,
 8017c08:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017c0c:	b29a      	uxth	r2, r3
 8017c0e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8017c12:	b29b      	uxth	r3, r3
 8017c14:	4413      	add	r3, r2
 8017c16:	b29b      	uxth	r3, r3
 8017c18:	3b01      	subs	r3, #1
 8017c1a:	b29b      	uxth	r3, r3
 8017c1c:	b218      	sxth	r0, r3
 8017c1e:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8017c22:	b29a      	uxth	r2, r3
 8017c24:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8017c28:	b29b      	uxth	r3, r3
 8017c2a:	1ad3      	subs	r3, r2, r3
 8017c2c:	b29a      	uxth	r2, r3
 8017c2e:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8017c32:	1ad3      	subs	r3, r2, r3
 8017c34:	b29b      	uxth	r3, r3
 8017c36:	b219      	sxth	r1, r3
 8017c38:	687b      	ldr	r3, [r7, #4]
 8017c3a:	f897 2061 	ldrb.w	r2, [r7, #97]	; 0x61
 8017c3e:	9200      	str	r2, [sp, #0]
 8017c40:	895b      	ldrh	r3, [r3, #10]
 8017c42:	68ba      	ldr	r2, [r7, #8]
 8017c44:	f7fc fb49 	bl	80142da <lv_draw_px>
                for(i = 0; i < seg_size; i++) {
 8017c48:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8017c4c:	b29b      	uxth	r3, r3
 8017c4e:	3301      	adds	r3, #1
 8017c50:	b29b      	uxth	r3, r3
 8017c52:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
 8017c56:	f9b7 2062 	ldrsh.w	r2, [r7, #98]	; 0x62
 8017c5a:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8017c5e:	429a      	cmp	r2, r3
 8017c60:	f6ff ae65 	blt.w	801792e <lv_draw_rect_border_corner+0x5b6>
                                       mask, style->body.border.color, aa_opa);
                        }
                    }
                }

                in_x_last      = cir_in.x;
 8017c64:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 8017c66:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
                in_y_seg_start = in_y_seg_end;
 8017c6a:	f8b7 3050 	ldrh.w	r3, [r7, #80]	; 0x50
 8017c6e:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            }
        }
#endif

        /*Draw the octets to the right bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8017c72:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017c76:	f003 0301 	and.w	r3, r3, #1
 8017c7a:	2b00      	cmp	r3, #0
 8017c7c:	d06f      	beq.n	8017d5e <lv_draw_rect_border_corner+0x9e6>
 8017c7e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017c82:	f003 0308 	and.w	r3, r3, #8
 8017c86:	2b00      	cmp	r3, #0
 8017c88:	d069      	beq.n	8017d5e <lv_draw_rect_border_corner+0x9e6>
            circ_area.x1 = rb_origo.x + LV_CIRC_OCT1_X(cir_out) - act_w2;
 8017c8a:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017c8e:	b29a      	uxth	r2, r3
 8017c90:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017c94:	b29b      	uxth	r3, r3
 8017c96:	4413      	add	r3, r2
 8017c98:	b29a      	uxth	r2, r3
 8017c9a:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8017c9e:	1ad3      	subs	r3, r2, r3
 8017ca0:	b29b      	uxth	r3, r3
 8017ca2:	b21b      	sxth	r3, r3
 8017ca4:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT1_X(cir_out);
 8017ca6:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017caa:	b29a      	uxth	r2, r3
 8017cac:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017cb0:	b29b      	uxth	r3, r3
 8017cb2:	4413      	add	r3, r2
 8017cb4:	b29b      	uxth	r3, r3
 8017cb6:	b21b      	sxth	r3, r3
 8017cb8:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
 8017cba:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017cbe:	b29a      	uxth	r2, r3
 8017cc0:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017cc4:	b29b      	uxth	r3, r3
 8017cc6:	4413      	add	r3, r2
 8017cc8:	b29b      	uxth	r3, r3
 8017cca:	b21b      	sxth	r3, r3
 8017ccc:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT1_Y(cir_out);
 8017cce:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017cd2:	b29a      	uxth	r2, r3
 8017cd4:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017cd8:	b29b      	uxth	r3, r3
 8017cda:	4413      	add	r3, r2
 8017cdc:	b29b      	uxth	r3, r3
 8017cde:	b21b      	sxth	r3, r3
 8017ce0:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8017ce2:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017ce6:	f107 001c 	add.w	r0, r7, #28
 8017cea:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017cee:	68b9      	ldr	r1, [r7, #8]
 8017cf0:	f7fc fb8c 	bl	801440c <lv_draw_fill>

            circ_area.x1 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
 8017cf4:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017cf8:	b29a      	uxth	r2, r3
 8017cfa:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017cfe:	b29b      	uxth	r3, r3
 8017d00:	4413      	add	r3, r2
 8017d02:	b29b      	uxth	r3, r3
 8017d04:	b21b      	sxth	r3, r3
 8017d06:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rb_origo.x + LV_CIRC_OCT2_X(cir_out);
 8017d08:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8017d0c:	b29a      	uxth	r2, r3
 8017d0e:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017d12:	b29b      	uxth	r3, r3
 8017d14:	4413      	add	r3, r2
 8017d16:	b29b      	uxth	r3, r3
 8017d18:	b21b      	sxth	r3, r3
 8017d1a:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out) - act_w1;
 8017d1c:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017d20:	b29a      	uxth	r2, r3
 8017d22:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017d26:	b29b      	uxth	r3, r3
 8017d28:	4413      	add	r3, r2
 8017d2a:	b29a      	uxth	r2, r3
 8017d2c:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8017d30:	1ad3      	subs	r3, r2, r3
 8017d32:	b29b      	uxth	r3, r3
 8017d34:	b21b      	sxth	r3, r3
 8017d36:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rb_origo.y + LV_CIRC_OCT2_Y(cir_out);
 8017d38:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017d3c:	b29a      	uxth	r2, r3
 8017d3e:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017d42:	b29b      	uxth	r3, r3
 8017d44:	4413      	add	r3, r2
 8017d46:	b29b      	uxth	r3, r3
 8017d48:	b21b      	sxth	r3, r3
 8017d4a:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8017d4c:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017d50:	f107 001c 	add.w	r0, r7, #28
 8017d54:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017d58:	68b9      	ldr	r1, [r7, #8]
 8017d5a:	f7fc fb57 	bl	801440c <lv_draw_fill>
        }

        /*Draw the octets to the left bottom corner*/
        if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8017d5e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017d62:	f003 0301 	and.w	r3, r3, #1
 8017d66:	2b00      	cmp	r3, #0
 8017d68:	d06f      	beq.n	8017e4a <lv_draw_rect_border_corner+0xad2>
 8017d6a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017d6e:	f003 0304 	and.w	r3, r3, #4
 8017d72:	2b00      	cmp	r3, #0
 8017d74:	d069      	beq.n	8017e4a <lv_draw_rect_border_corner+0xad2>
            circ_area.x1 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
 8017d76:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017d7a:	b29a      	uxth	r2, r3
 8017d7c:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017d80:	b29b      	uxth	r3, r3
 8017d82:	1ad3      	subs	r3, r2, r3
 8017d84:	b29b      	uxth	r3, r3
 8017d86:	b21b      	sxth	r3, r3
 8017d88:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT3_X(cir_out);
 8017d8a:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017d8e:	b29a      	uxth	r2, r3
 8017d90:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017d94:	b29b      	uxth	r3, r3
 8017d96:	1ad3      	subs	r3, r2, r3
 8017d98:	b29b      	uxth	r3, r3
 8017d9a:	b21b      	sxth	r3, r3
 8017d9c:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out) - act_w2;
 8017d9e:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017da2:	b29a      	uxth	r2, r3
 8017da4:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017da8:	b29b      	uxth	r3, r3
 8017daa:	4413      	add	r3, r2
 8017dac:	b29a      	uxth	r2, r3
 8017dae:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8017db2:	1ad3      	subs	r3, r2, r3
 8017db4:	b29b      	uxth	r3, r3
 8017db6:	b21b      	sxth	r3, r3
 8017db8:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT3_Y(cir_out);
 8017dba:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017dbe:	b29a      	uxth	r2, r3
 8017dc0:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017dc4:	b29b      	uxth	r3, r3
 8017dc6:	4413      	add	r3, r2
 8017dc8:	b29b      	uxth	r3, r3
 8017dca:	b21b      	sxth	r3, r3
 8017dcc:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8017dce:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017dd2:	f107 001c 	add.w	r0, r7, #28
 8017dd6:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017dda:	68b9      	ldr	r1, [r7, #8]
 8017ddc:	f7fc fb16 	bl	801440c <lv_draw_fill>

            circ_area.x1 = lb_origo.x + LV_CIRC_OCT4_X(cir_out);
 8017de0:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017de4:	b29a      	uxth	r2, r3
 8017de6:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017dea:	b29b      	uxth	r3, r3
 8017dec:	1ad3      	subs	r3, r2, r3
 8017dee:	b29b      	uxth	r3, r3
 8017df0:	b21b      	sxth	r3, r3
 8017df2:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lb_origo.x + LV_CIRC_OCT4_X(cir_out) + act_w1;
 8017df4:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8017df8:	b29a      	uxth	r2, r3
 8017dfa:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017dfe:	b29b      	uxth	r3, r3
 8017e00:	1ad3      	subs	r3, r2, r3
 8017e02:	b29a      	uxth	r2, r3
 8017e04:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8017e08:	4413      	add	r3, r2
 8017e0a:	b29b      	uxth	r3, r3
 8017e0c:	b21b      	sxth	r3, r3
 8017e0e:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
 8017e10:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017e14:	b29a      	uxth	r2, r3
 8017e16:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017e1a:	b29b      	uxth	r3, r3
 8017e1c:	4413      	add	r3, r2
 8017e1e:	b29b      	uxth	r3, r3
 8017e20:	b21b      	sxth	r3, r3
 8017e22:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lb_origo.y + LV_CIRC_OCT4_Y(cir_out);
 8017e24:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017e28:	b29a      	uxth	r2, r3
 8017e2a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017e2e:	b29b      	uxth	r3, r3
 8017e30:	4413      	add	r3, r2
 8017e32:	b29b      	uxth	r3, r3
 8017e34:	b21b      	sxth	r3, r3
 8017e36:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8017e38:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017e3c:	f107 001c 	add.w	r0, r7, #28
 8017e40:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017e44:	68b9      	ldr	r1, [r7, #8]
 8017e46:	f7fc fae1 	bl	801440c <lv_draw_fill>
        }

        /*Draw the octets to the left top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8017e4a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017e4e:	f003 0302 	and.w	r3, r3, #2
 8017e52:	2b00      	cmp	r3, #0
 8017e54:	d07d      	beq.n	8017f52 <lv_draw_rect_border_corner+0xbda>
 8017e56:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017e5a:	f003 0304 	and.w	r3, r3, #4
 8017e5e:	2b00      	cmp	r3, #0
 8017e60:	d077      	beq.n	8017f52 <lv_draw_rect_border_corner+0xbda>
            if(lb_origo.y + LV_CIRC_OCT4_Y(cir_out) > lt_origo.y + LV_CIRC_OCT5_Y(cir_out)) {
 8017e62:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8017e66:	461a      	mov	r2, r3
 8017e68:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017e6c:	441a      	add	r2, r3
 8017e6e:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017e72:	4619      	mov	r1, r3
 8017e74:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017e78:	1acb      	subs	r3, r1, r3
 8017e7a:	429a      	cmp	r2, r3
 8017e7c:	dd34      	ble.n	8017ee8 <lv_draw_rect_border_corner+0xb70>
                /*Don't draw if the lines are common in the middle*/
                circ_area.x1 = lt_origo.x + LV_CIRC_OCT5_X(cir_out);
 8017e7e:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017e82:	b29a      	uxth	r2, r3
 8017e84:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017e88:	b29b      	uxth	r3, r3
 8017e8a:	1ad3      	subs	r3, r2, r3
 8017e8c:	b29b      	uxth	r3, r3
 8017e8e:	b21b      	sxth	r3, r3
 8017e90:	83bb      	strh	r3, [r7, #28]
                circ_area.x2 = lt_origo.x + LV_CIRC_OCT5_X(cir_out) + act_w2;
 8017e92:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017e96:	b29a      	uxth	r2, r3
 8017e98:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017e9c:	b29b      	uxth	r3, r3
 8017e9e:	1ad3      	subs	r3, r2, r3
 8017ea0:	b29a      	uxth	r2, r3
 8017ea2:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8017ea6:	4413      	add	r3, r2
 8017ea8:	b29b      	uxth	r3, r3
 8017eaa:	b21b      	sxth	r3, r3
 8017eac:	843b      	strh	r3, [r7, #32]
                circ_area.y1 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
 8017eae:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017eb2:	b29a      	uxth	r2, r3
 8017eb4:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017eb8:	b29b      	uxth	r3, r3
 8017eba:	1ad3      	subs	r3, r2, r3
 8017ebc:	b29b      	uxth	r3, r3
 8017ebe:	b21b      	sxth	r3, r3
 8017ec0:	83fb      	strh	r3, [r7, #30]
                circ_area.y2 = lt_origo.y + LV_CIRC_OCT5_Y(cir_out);
 8017ec2:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017ec6:	b29a      	uxth	r2, r3
 8017ec8:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017ecc:	b29b      	uxth	r3, r3
 8017ece:	1ad3      	subs	r3, r2, r3
 8017ed0:	b29b      	uxth	r3, r3
 8017ed2:	b21b      	sxth	r3, r3
 8017ed4:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_fill(&circ_area, mask, color, opa);
 8017ed6:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017eda:	f107 001c 	add.w	r0, r7, #28
 8017ede:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017ee2:	68b9      	ldr	r1, [r7, #8]
 8017ee4:	f7fc fa92 	bl	801440c <lv_draw_fill>
            }

            circ_area.x1 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
 8017ee8:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017eec:	b29a      	uxth	r2, r3
 8017eee:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017ef2:	b29b      	uxth	r3, r3
 8017ef4:	1ad3      	subs	r3, r2, r3
 8017ef6:	b29b      	uxth	r3, r3
 8017ef8:	b21b      	sxth	r3, r3
 8017efa:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = lt_origo.x + LV_CIRC_OCT6_X(cir_out);
 8017efc:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8017f00:	b29a      	uxth	r2, r3
 8017f02:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017f06:	b29b      	uxth	r3, r3
 8017f08:	1ad3      	subs	r3, r2, r3
 8017f0a:	b29b      	uxth	r3, r3
 8017f0c:	b21b      	sxth	r3, r3
 8017f0e:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out);
 8017f10:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017f14:	b29a      	uxth	r2, r3
 8017f16:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017f1a:	b29b      	uxth	r3, r3
 8017f1c:	1ad3      	subs	r3, r2, r3
 8017f1e:	b29b      	uxth	r3, r3
 8017f20:	b21b      	sxth	r3, r3
 8017f22:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = lt_origo.y + LV_CIRC_OCT6_Y(cir_out) + act_w1;
 8017f24:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8017f28:	b29a      	uxth	r2, r3
 8017f2a:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017f2e:	b29b      	uxth	r3, r3
 8017f30:	1ad3      	subs	r3, r2, r3
 8017f32:	b29a      	uxth	r2, r3
 8017f34:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8017f38:	4413      	add	r3, r2
 8017f3a:	b29b      	uxth	r3, r3
 8017f3c:	b21b      	sxth	r3, r3
 8017f3e:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8017f40:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017f44:	f107 001c 	add.w	r0, r7, #28
 8017f48:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017f4c:	68b9      	ldr	r1, [r7, #8]
 8017f4e:	f7fc fa5d 	bl	801440c <lv_draw_fill>
        }

        /*Draw the octets to the right top corner*/
        if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8017f52:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017f56:	f003 0302 	and.w	r3, r3, #2
 8017f5a:	2b00      	cmp	r3, #0
 8017f5c:	d07d      	beq.n	801805a <lv_draw_rect_border_corner+0xce2>
 8017f5e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8017f62:	f003 0308 	and.w	r3, r3, #8
 8017f66:	2b00      	cmp	r3, #0
 8017f68:	d077      	beq.n	801805a <lv_draw_rect_border_corner+0xce2>
            circ_area.x1 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
 8017f6a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017f6e:	b29a      	uxth	r2, r3
 8017f70:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017f74:	b29b      	uxth	r3, r3
 8017f76:	4413      	add	r3, r2
 8017f78:	b29b      	uxth	r3, r3
 8017f7a:	b21b      	sxth	r3, r3
 8017f7c:	83bb      	strh	r3, [r7, #28]
            circ_area.x2 = rt_origo.x + LV_CIRC_OCT7_X(cir_out);
 8017f7e:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017f82:	b29a      	uxth	r2, r3
 8017f84:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017f88:	b29b      	uxth	r3, r3
 8017f8a:	4413      	add	r3, r2
 8017f8c:	b29b      	uxth	r3, r3
 8017f8e:	b21b      	sxth	r3, r3
 8017f90:	843b      	strh	r3, [r7, #32]
            circ_area.y1 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out);
 8017f92:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8017f96:	b29a      	uxth	r2, r3
 8017f98:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017f9c:	b29b      	uxth	r3, r3
 8017f9e:	1ad3      	subs	r3, r2, r3
 8017fa0:	b29b      	uxth	r3, r3
 8017fa2:	b21b      	sxth	r3, r3
 8017fa4:	83fb      	strh	r3, [r7, #30]
            circ_area.y2 = rt_origo.y + LV_CIRC_OCT7_Y(cir_out) + act_w2;
 8017fa6:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8017faa:	b29a      	uxth	r2, r3
 8017fac:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017fb0:	b29b      	uxth	r3, r3
 8017fb2:	1ad3      	subs	r3, r2, r3
 8017fb4:	b29a      	uxth	r2, r3
 8017fb6:	f8b7 3070 	ldrh.w	r3, [r7, #112]	; 0x70
 8017fba:	4413      	add	r3, r2
 8017fbc:	b29b      	uxth	r3, r3
 8017fbe:	b21b      	sxth	r3, r3
 8017fc0:	847b      	strh	r3, [r7, #34]	; 0x22
            lv_draw_fill(&circ_area, mask, color, opa);
 8017fc2:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8017fc6:	f107 001c 	add.w	r0, r7, #28
 8017fca:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8017fce:	68b9      	ldr	r1, [r7, #8]
 8017fd0:	f7fc fa1c 	bl	801440c <lv_draw_fill>

            /*Don't draw if the lines are common in the middle*/
            if(rb_origo.y + LV_CIRC_OCT1_Y(cir_out) > rt_origo.y + LV_CIRC_OCT8_Y(cir_out)) {
 8017fd4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8017fd8:	461a      	mov	r2, r3
 8017fda:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017fde:	441a      	add	r2, r3
 8017fe0:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8017fe4:	4619      	mov	r1, r3
 8017fe6:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8017fea:	1acb      	subs	r3, r1, r3
 8017fec:	429a      	cmp	r2, r3
 8017fee:	dd34      	ble.n	801805a <lv_draw_rect_border_corner+0xce2>
                circ_area.x1 = rt_origo.x + LV_CIRC_OCT8_X(cir_out) - act_w1;
 8017ff0:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8017ff4:	b29a      	uxth	r2, r3
 8017ff6:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8017ffa:	b29b      	uxth	r3, r3
 8017ffc:	4413      	add	r3, r2
 8017ffe:	b29a      	uxth	r2, r3
 8018000:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 8018004:	1ad3      	subs	r3, r2, r3
 8018006:	b29b      	uxth	r3, r3
 8018008:	b21b      	sxth	r3, r3
 801800a:	83bb      	strh	r3, [r7, #28]
                circ_area.x2 = rt_origo.x + LV_CIRC_OCT8_X(cir_out);
 801800c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8018010:	b29a      	uxth	r2, r3
 8018012:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8018016:	b29b      	uxth	r3, r3
 8018018:	4413      	add	r3, r2
 801801a:	b29b      	uxth	r3, r3
 801801c:	b21b      	sxth	r3, r3
 801801e:	843b      	strh	r3, [r7, #32]
                circ_area.y1 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
 8018020:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8018024:	b29a      	uxth	r2, r3
 8018026:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801802a:	b29b      	uxth	r3, r3
 801802c:	1ad3      	subs	r3, r2, r3
 801802e:	b29b      	uxth	r3, r3
 8018030:	b21b      	sxth	r3, r3
 8018032:	83fb      	strh	r3, [r7, #30]
                circ_area.y2 = rt_origo.y + LV_CIRC_OCT8_Y(cir_out);
 8018034:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8018038:	b29a      	uxth	r2, r3
 801803a:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 801803e:	b29b      	uxth	r3, r3
 8018040:	1ad3      	subs	r3, r2, r3
 8018042:	b29b      	uxth	r3, r3
 8018044:	b21b      	sxth	r3, r3
 8018046:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_fill(&circ_area, mask, color, opa);
 8018048:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 801804c:	f107 001c 	add.w	r0, r7, #28
 8018050:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8018054:	68b9      	ldr	r1, [r7, #8]
 8018056:	f7fc f9d9 	bl	801440c <lv_draw_fill>
            }
        }
        lv_circ_next(&cir_out, &tmp_out);
 801805a:	f107 022e 	add.w	r2, r7, #46	; 0x2e
 801805e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8018062:	4611      	mov	r1, r2
 8018064:	4618      	mov	r0, r3
 8018066:	f003 fe81 	bl	801bd6c <lv_circ_next>

        /*The internal circle will be ready faster
         * so check it! */
        if(cir_in.y < cir_in.x) {
 801806a:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 801806e:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018072:	429a      	cmp	r2, r3
 8018074:	da07      	bge.n	8018086 <lv_draw_rect_border_corner+0xd0e>
            lv_circ_next(&cir_in, &tmp_in);
 8018076:	f107 0226 	add.w	r2, r7, #38	; 0x26
 801807a:	f107 0328 	add.w	r3, r7, #40	; 0x28
 801807e:	4611      	mov	r1, r2
 8018080:	4618      	mov	r0, r3
 8018082:	f003 fe73 	bl	801bd6c <lv_circ_next>
    while(cir_out.y <= cir_out.x) {
 8018086:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801808a:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 801808e:	429a      	cmp	r2, r3
 8018090:	f77f aa85 	ble.w	801759e <lv_draw_rect_border_corner+0x226>
        }
    }

#if LV_ANTIALIAS
    if(aa) {
 8018094:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8018098:	2b00      	cmp	r3, #0
 801809a:	f000 83b0 	beq.w	80187fe <lv_draw_rect_border_corner+0x1486>
        /*Last parts of the outer anti-alias*/
        out_y_seg_end       = cir_out.y;
 801809e:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 80180a0:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
        lv_coord_t seg_size = out_y_seg_end - out_y_seg_start;
 80180a4:	f8b7 2052 	ldrh.w	r2, [r7, #82]	; 0x52
 80180a8:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 80180ac:	1ad3      	subs	r3, r2, r3
 80180ae:	b29b      	uxth	r3, r3
 80180b0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
        lv_point_t aa_p;

        aa_p.x = out_x_last;
 80180b4:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80180b8:	823b      	strh	r3, [r7, #16]
        aa_p.y = out_y_seg_start;
 80180ba:	f8b7 306e 	ldrh.w	r3, [r7, #110]	; 0x6e
 80180be:	827b      	strh	r3, [r7, #18]

        lv_coord_t i;
        for(i = 0; i < seg_size; i++) {
 80180c0:	2300      	movs	r3, #0
 80180c2:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80180c6:	e146      	b.n	8018356 <lv_draw_rect_border_corner+0xfde>
            lv_opa_t aa_opa = opa - lv_draw_aa_get_opa(seg_size, i, opa);
 80180c8:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 80180cc:	f9b7 105e 	ldrsh.w	r1, [r7, #94]	; 0x5e
 80180d0:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80180d4:	4618      	mov	r0, r3
 80180d6:	f7fc f827 	bl	8014128 <lv_draw_aa_get_opa>
 80180da:	4603      	mov	r3, r0
 80180dc:	461a      	mov	r2, r3
 80180de:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 80180e2:	1a9b      	subs	r3, r3, r2
 80180e4:	f887 304b 	strb.w	r3, [r7, #75]	; 0x4b
            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 80180e8:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80180ec:	f003 0301 	and.w	r3, r3, #1
 80180f0:	2b00      	cmp	r3, #0
 80180f2:	d045      	beq.n	8018180 <lv_draw_rect_border_corner+0xe08>
 80180f4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80180f8:	f003 0308 	and.w	r3, r3, #8
 80180fc:	2b00      	cmp	r3, #0
 80180fe:	d03f      	beq.n	8018180 <lv_draw_rect_border_corner+0xe08>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) + 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8018100:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8018104:	b29a      	uxth	r2, r3
 8018106:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801810a:	b29b      	uxth	r3, r3
 801810c:	4413      	add	r3, r2
 801810e:	b29b      	uxth	r3, r3
 8018110:	3301      	adds	r3, #1
 8018112:	b29b      	uxth	r3, r3
 8018114:	b218      	sxth	r0, r3
 8018116:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801811a:	b29a      	uxth	r2, r3
 801811c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018120:	b29b      	uxth	r3, r3
 8018122:	4413      	add	r3, r2
 8018124:	b29a      	uxth	r2, r3
 8018126:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801812a:	4413      	add	r3, r2
 801812c:	b29b      	uxth	r3, r3
 801812e:	b219      	sxth	r1, r3
 8018130:	687b      	ldr	r3, [r7, #4]
 8018132:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8018136:	9200      	str	r2, [sp, #0]
 8018138:	895b      	ldrh	r3, [r3, #10]
 801813a:	68ba      	ldr	r2, [r7, #8]
 801813c:	f7fc f8cd 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) + 1, mask,
 8018140:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8018144:	b29a      	uxth	r2, r3
 8018146:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801814a:	b29b      	uxth	r3, r3
 801814c:	4413      	add	r3, r2
 801814e:	b29a      	uxth	r2, r3
 8018150:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8018154:	4413      	add	r3, r2
 8018156:	b29b      	uxth	r3, r3
 8018158:	b218      	sxth	r0, r3
 801815a:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801815e:	b29a      	uxth	r2, r3
 8018160:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018164:	b29b      	uxth	r3, r3
 8018166:	4413      	add	r3, r2
 8018168:	b29b      	uxth	r3, r3
 801816a:	3301      	adds	r3, #1
 801816c:	b29b      	uxth	r3, r3
 801816e:	b219      	sxth	r1, r3
 8018170:	687b      	ldr	r3, [r7, #4]
 8018172:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8018176:	9200      	str	r2, [sp, #0]
 8018178:	895b      	ldrh	r3, [r3, #10]
 801817a:	68ba      	ldr	r2, [r7, #8]
 801817c:	f7fc f8ad 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8018180:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018184:	f003 0301 	and.w	r3, r3, #1
 8018188:	2b00      	cmp	r3, #0
 801818a:	d045      	beq.n	8018218 <lv_draw_rect_border_corner+0xea0>
 801818c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018190:	f003 0304 	and.w	r3, r3, #4
 8018194:	2b00      	cmp	r3, #0
 8018196:	d03f      	beq.n	8018218 <lv_draw_rect_border_corner+0xea0>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) + 1, mask,
 8018198:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801819c:	b29a      	uxth	r2, r3
 801819e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80181a2:	b29b      	uxth	r3, r3
 80181a4:	1ad3      	subs	r3, r2, r3
 80181a6:	b29a      	uxth	r2, r3
 80181a8:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80181ac:	1ad3      	subs	r3, r2, r3
 80181ae:	b29b      	uxth	r3, r3
 80181b0:	b218      	sxth	r0, r3
 80181b2:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80181b6:	b29a      	uxth	r2, r3
 80181b8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80181bc:	b29b      	uxth	r3, r3
 80181be:	4413      	add	r3, r2
 80181c0:	b29b      	uxth	r3, r3
 80181c2:	3301      	adds	r3, #1
 80181c4:	b29b      	uxth	r3, r3
 80181c6:	b219      	sxth	r1, r3
 80181c8:	687b      	ldr	r3, [r7, #4]
 80181ca:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 80181ce:	9200      	str	r2, [sp, #0]
 80181d0:	895b      	ldrh	r3, [r3, #10]
 80181d2:	68ba      	ldr	r2, [r7, #8]
 80181d4:	f7fc f881 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) - 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 80181d8:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80181dc:	b29a      	uxth	r2, r3
 80181de:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80181e2:	b29b      	uxth	r3, r3
 80181e4:	1ad3      	subs	r3, r2, r3
 80181e6:	b29b      	uxth	r3, r3
 80181e8:	3b01      	subs	r3, #1
 80181ea:	b29b      	uxth	r3, r3
 80181ec:	b218      	sxth	r0, r3
 80181ee:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80181f2:	b29a      	uxth	r2, r3
 80181f4:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80181f8:	b29b      	uxth	r3, r3
 80181fa:	4413      	add	r3, r2
 80181fc:	b29a      	uxth	r2, r3
 80181fe:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8018202:	4413      	add	r3, r2
 8018204:	b29b      	uxth	r3, r3
 8018206:	b219      	sxth	r1, r3
 8018208:	687b      	ldr	r3, [r7, #4]
 801820a:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801820e:	9200      	str	r2, [sp, #0]
 8018210:	895b      	ldrh	r3, [r3, #10]
 8018212:	68ba      	ldr	r2, [r7, #8]
 8018214:	f7fc f861 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8018218:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801821c:	f003 0302 	and.w	r3, r3, #2
 8018220:	2b00      	cmp	r3, #0
 8018222:	d045      	beq.n	80182b0 <lv_draw_rect_border_corner+0xf38>
 8018224:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018228:	f003 0304 	and.w	r3, r3, #4
 801822c:	2b00      	cmp	r3, #0
 801822e:	d03f      	beq.n	80182b0 <lv_draw_rect_border_corner+0xf38>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) - 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 8018230:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8018234:	b29a      	uxth	r2, r3
 8018236:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801823a:	b29b      	uxth	r3, r3
 801823c:	1ad3      	subs	r3, r2, r3
 801823e:	b29b      	uxth	r3, r3
 8018240:	3b01      	subs	r3, #1
 8018242:	b29b      	uxth	r3, r3
 8018244:	b218      	sxth	r0, r3
 8018246:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801824a:	b29a      	uxth	r2, r3
 801824c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018250:	b29b      	uxth	r3, r3
 8018252:	1ad3      	subs	r3, r2, r3
 8018254:	b29a      	uxth	r2, r3
 8018256:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801825a:	1ad3      	subs	r3, r2, r3
 801825c:	b29b      	uxth	r3, r3
 801825e:	b219      	sxth	r1, r3
 8018260:	687b      	ldr	r3, [r7, #4]
 8018262:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 8018266:	9200      	str	r2, [sp, #0]
 8018268:	895b      	ldrh	r3, [r3, #10]
 801826a:	68ba      	ldr	r2, [r7, #8]
 801826c:	f7fc f835 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) - 1, mask,
 8018270:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 8018274:	b29a      	uxth	r2, r3
 8018276:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801827a:	b29b      	uxth	r3, r3
 801827c:	1ad3      	subs	r3, r2, r3
 801827e:	b29a      	uxth	r2, r3
 8018280:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8018284:	1ad3      	subs	r3, r2, r3
 8018286:	b29b      	uxth	r3, r3
 8018288:	b218      	sxth	r0, r3
 801828a:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801828e:	b29a      	uxth	r2, r3
 8018290:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018294:	b29b      	uxth	r3, r3
 8018296:	1ad3      	subs	r3, r2, r3
 8018298:	b29b      	uxth	r3, r3
 801829a:	3b01      	subs	r3, #1
 801829c:	b29b      	uxth	r3, r3
 801829e:	b219      	sxth	r1, r3
 80182a0:	687b      	ldr	r3, [r7, #4]
 80182a2:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 80182a6:	9200      	str	r2, [sp, #0]
 80182a8:	895b      	ldrh	r3, [r3, #10]
 80182aa:	68ba      	ldr	r2, [r7, #8]
 80182ac:	f7fc f815 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 80182b0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80182b4:	f003 0302 	and.w	r3, r3, #2
 80182b8:	2b00      	cmp	r3, #0
 80182ba:	d045      	beq.n	8018348 <lv_draw_rect_border_corner+0xfd0>
 80182bc:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80182c0:	f003 0308 	and.w	r3, r3, #8
 80182c4:	2b00      	cmp	r3, #0
 80182c6:	d03f      	beq.n	8018348 <lv_draw_rect_border_corner+0xfd0>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) - 1, mask,
 80182c8:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80182cc:	b29a      	uxth	r2, r3
 80182ce:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80182d2:	b29b      	uxth	r3, r3
 80182d4:	4413      	add	r3, r2
 80182d6:	b29a      	uxth	r2, r3
 80182d8:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80182dc:	4413      	add	r3, r2
 80182de:	b29b      	uxth	r3, r3
 80182e0:	b218      	sxth	r0, r3
 80182e2:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80182e6:	b29a      	uxth	r2, r3
 80182e8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80182ec:	b29b      	uxth	r3, r3
 80182ee:	1ad3      	subs	r3, r2, r3
 80182f0:	b29b      	uxth	r3, r3
 80182f2:	3b01      	subs	r3, #1
 80182f4:	b29b      	uxth	r3, r3
 80182f6:	b219      	sxth	r1, r3
 80182f8:	687b      	ldr	r3, [r7, #4]
 80182fa:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 80182fe:	9200      	str	r2, [sp, #0]
 8018300:	895b      	ldrh	r3, [r3, #10]
 8018302:	68ba      	ldr	r2, [r7, #8]
 8018304:	f7fb ffe9 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
                lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) + 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 8018308:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801830c:	b29a      	uxth	r2, r3
 801830e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018312:	b29b      	uxth	r3, r3
 8018314:	4413      	add	r3, r2
 8018316:	b29b      	uxth	r3, r3
 8018318:	3301      	adds	r3, #1
 801831a:	b29b      	uxth	r3, r3
 801831c:	b218      	sxth	r0, r3
 801831e:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8018322:	b29a      	uxth	r2, r3
 8018324:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018328:	b29b      	uxth	r3, r3
 801832a:	1ad3      	subs	r3, r2, r3
 801832c:	b29a      	uxth	r2, r3
 801832e:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8018332:	1ad3      	subs	r3, r2, r3
 8018334:	b29b      	uxth	r3, r3
 8018336:	b219      	sxth	r1, r3
 8018338:	687b      	ldr	r3, [r7, #4]
 801833a:	f897 204b 	ldrb.w	r2, [r7, #75]	; 0x4b
 801833e:	9200      	str	r2, [sp, #0]
 8018340:	895b      	ldrh	r3, [r3, #10]
 8018342:	68ba      	ldr	r2, [r7, #8]
 8018344:	f7fb ffc9 	bl	80142da <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 8018348:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801834c:	b29b      	uxth	r3, r3
 801834e:	3301      	adds	r3, #1
 8018350:	b29b      	uxth	r3, r3
 8018352:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8018356:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801835a:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801835e:	429a      	cmp	r2, r3
 8018360:	f6ff aeb2 	blt.w	80180c8 <lv_draw_rect_border_corner+0xd50>
                           style->body.border.color, aa_opa);
            }
        }

        /*In some cases the last pixel in the outer middle is not drawn*/
        if(LV_MATH_ABS(aa_p.x - aa_p.y) == seg_size) {
 8018364:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018368:	461a      	mov	r2, r3
 801836a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801836e:	1ad3      	subs	r3, r2, r3
 8018370:	ea83 72e3 	eor.w	r2, r3, r3, asr #31
 8018374:	eba2 72e3 	sub.w	r2, r2, r3, asr #31
 8018378:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801837c:	429a      	cmp	r2, r3
 801837e:	f040 80a3 	bne.w	80184c8 <lv_draw_rect_border_corner+0x1150>
            aa_p.x = out_x_last;
 8018382:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 8018386:	823b      	strh	r3, [r7, #16]
            aa_p.y = out_x_last;
 8018388:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 801838c:	827b      	strh	r3, [r7, #18]

            lv_opa_t aa_opa = opa >> 1;
 801838e:	f897 3059 	ldrb.w	r3, [r7, #89]	; 0x59
 8018392:	085b      	lsrs	r3, r3, #1
 8018394:	f887 304d 	strb.w	r3, [r7, #77]	; 0x4d

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8018398:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801839c:	f003 0301 	and.w	r3, r3, #1
 80183a0:	2b00      	cmp	r3, #0
 80183a2:	d01f      	beq.n	80183e4 <lv_draw_rect_border_corner+0x106c>
 80183a4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80183a8:	f003 0308 	and.w	r3, r3, #8
 80183ac:	2b00      	cmp	r3, #0
 80183ae:	d019      	beq.n	80183e4 <lv_draw_rect_border_corner+0x106c>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p), rb_origo.y + LV_CIRC_OCT2_Y(aa_p), mask,
 80183b0:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80183b4:	b29a      	uxth	r2, r3
 80183b6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80183ba:	b29b      	uxth	r3, r3
 80183bc:	4413      	add	r3, r2
 80183be:	b29b      	uxth	r3, r3
 80183c0:	b218      	sxth	r0, r3
 80183c2:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80183c6:	b29a      	uxth	r2, r3
 80183c8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80183cc:	b29b      	uxth	r3, r3
 80183ce:	4413      	add	r3, r2
 80183d0:	b29b      	uxth	r3, r3
 80183d2:	b219      	sxth	r1, r3
 80183d4:	687b      	ldr	r3, [r7, #4]
 80183d6:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 80183da:	9200      	str	r2, [sp, #0]
 80183dc:	895b      	ldrh	r3, [r3, #10]
 80183de:	68ba      	ldr	r2, [r7, #8]
 80183e0:	f7fb ff7b 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 80183e4:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80183e8:	f003 0301 	and.w	r3, r3, #1
 80183ec:	2b00      	cmp	r3, #0
 80183ee:	d01f      	beq.n	8018430 <lv_draw_rect_border_corner+0x10b8>
 80183f0:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80183f4:	f003 0304 	and.w	r3, r3, #4
 80183f8:	2b00      	cmp	r3, #0
 80183fa:	d019      	beq.n	8018430 <lv_draw_rect_border_corner+0x10b8>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p), lb_origo.y + LV_CIRC_OCT4_Y(aa_p), mask,
 80183fc:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 8018400:	b29a      	uxth	r2, r3
 8018402:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018406:	b29b      	uxth	r3, r3
 8018408:	1ad3      	subs	r3, r2, r3
 801840a:	b29b      	uxth	r3, r3
 801840c:	b218      	sxth	r0, r3
 801840e:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8018412:	b29a      	uxth	r2, r3
 8018414:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018418:	b29b      	uxth	r3, r3
 801841a:	4413      	add	r3, r2
 801841c:	b29b      	uxth	r3, r3
 801841e:	b219      	sxth	r1, r3
 8018420:	687b      	ldr	r3, [r7, #4]
 8018422:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 8018426:	9200      	str	r2, [sp, #0]
 8018428:	895b      	ldrh	r3, [r3, #10]
 801842a:	68ba      	ldr	r2, [r7, #8]
 801842c:	f7fb ff55 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8018430:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018434:	f003 0302 	and.w	r3, r3, #2
 8018438:	2b00      	cmp	r3, #0
 801843a:	d01f      	beq.n	801847c <lv_draw_rect_border_corner+0x1104>
 801843c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018440:	f003 0304 	and.w	r3, r3, #4
 8018444:	2b00      	cmp	r3, #0
 8018446:	d019      	beq.n	801847c <lv_draw_rect_border_corner+0x1104>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p), lt_origo.y + LV_CIRC_OCT6_Y(aa_p), mask,
 8018448:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801844c:	b29a      	uxth	r2, r3
 801844e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018452:	b29b      	uxth	r3, r3
 8018454:	1ad3      	subs	r3, r2, r3
 8018456:	b29b      	uxth	r3, r3
 8018458:	b218      	sxth	r0, r3
 801845a:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 801845e:	b29a      	uxth	r2, r3
 8018460:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018464:	b29b      	uxth	r3, r3
 8018466:	1ad3      	subs	r3, r2, r3
 8018468:	b29b      	uxth	r3, r3
 801846a:	b219      	sxth	r1, r3
 801846c:	687b      	ldr	r3, [r7, #4]
 801846e:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 8018472:	9200      	str	r2, [sp, #0]
 8018474:	895b      	ldrh	r3, [r3, #10]
 8018476:	68ba      	ldr	r2, [r7, #8]
 8018478:	f7fb ff2f 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801847c:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018480:	f003 0302 	and.w	r3, r3, #2
 8018484:	2b00      	cmp	r3, #0
 8018486:	d01f      	beq.n	80184c8 <lv_draw_rect_border_corner+0x1150>
 8018488:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801848c:	f003 0308 	and.w	r3, r3, #8
 8018490:	2b00      	cmp	r3, #0
 8018492:	d019      	beq.n	80184c8 <lv_draw_rect_border_corner+0x1150>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p), rt_origo.y + LV_CIRC_OCT8_Y(aa_p), mask,
 8018494:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8018498:	b29a      	uxth	r2, r3
 801849a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801849e:	b29b      	uxth	r3, r3
 80184a0:	4413      	add	r3, r2
 80184a2:	b29b      	uxth	r3, r3
 80184a4:	b218      	sxth	r0, r3
 80184a6:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80184aa:	b29a      	uxth	r2, r3
 80184ac:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80184b0:	b29b      	uxth	r3, r3
 80184b2:	1ad3      	subs	r3, r2, r3
 80184b4:	b29b      	uxth	r3, r3
 80184b6:	b219      	sxth	r1, r3
 80184b8:	687b      	ldr	r3, [r7, #4]
 80184ba:	f897 204d 	ldrb.w	r2, [r7, #77]	; 0x4d
 80184be:	9200      	str	r2, [sp, #0]
 80184c0:	895b      	ldrh	r3, [r3, #10]
 80184c2:	68ba      	ldr	r2, [r7, #8]
 80184c4:	f7fb ff09 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }
        }

        /*Last parts of the inner anti-alias*/
        in_y_seg_end = cir_in.y;
 80184c8:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 80184ca:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
        aa_p.x       = in_x_last;
 80184ce:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 80184d2:	823b      	strh	r3, [r7, #16]
        aa_p.y       = in_y_seg_start;
 80184d4:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 80184d8:	827b      	strh	r3, [r7, #18]
        seg_size     = in_y_seg_end - in_y_seg_start;
 80184da:	f8b7 2050 	ldrh.w	r2, [r7, #80]	; 0x50
 80184de:	f8b7 306a 	ldrh.w	r3, [r7, #106]	; 0x6a
 80184e2:	1ad3      	subs	r3, r2, r3
 80184e4:	b29b      	uxth	r3, r3
 80184e6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

        for(i = 0; i < seg_size; i++) {
 80184ea:	2300      	movs	r3, #0
 80184ec:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80184f0:	e17e      	b.n	80187f0 <lv_draw_rect_border_corner+0x1478>
            lv_opa_t aa_opa = lv_draw_aa_get_opa(seg_size, i, opa);
 80184f2:	f897 2059 	ldrb.w	r2, [r7, #89]	; 0x59
 80184f6:	f9b7 105e 	ldrsh.w	r1, [r7, #94]	; 0x5e
 80184fa:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80184fe:	4618      	mov	r0, r3
 8018500:	f7fb fe12 	bl	8014128 <lv_draw_aa_get_opa>
 8018504:	4603      	mov	r3, r0
 8018506:	f887 304c 	strb.w	r3, [r7, #76]	; 0x4c
            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 801850a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801850e:	f003 0301 	and.w	r3, r3, #1
 8018512:	2b00      	cmp	r3, #0
 8018514:	d025      	beq.n	8018562 <lv_draw_rect_border_corner+0x11ea>
 8018516:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801851a:	f003 0308 	and.w	r3, r3, #8
 801851e:	2b00      	cmp	r3, #0
 8018520:	d01f      	beq.n	8018562 <lv_draw_rect_border_corner+0x11ea>
                lv_draw_px(rb_origo.x + LV_CIRC_OCT1_X(aa_p) - 1, rb_origo.y + LV_CIRC_OCT1_Y(aa_p) + i, mask,
 8018522:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8018526:	b29a      	uxth	r2, r3
 8018528:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801852c:	b29b      	uxth	r3, r3
 801852e:	4413      	add	r3, r2
 8018530:	b29b      	uxth	r3, r3
 8018532:	3b01      	subs	r3, #1
 8018534:	b29b      	uxth	r3, r3
 8018536:	b218      	sxth	r0, r3
 8018538:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 801853c:	b29a      	uxth	r2, r3
 801853e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018542:	b29b      	uxth	r3, r3
 8018544:	4413      	add	r3, r2
 8018546:	b29a      	uxth	r2, r3
 8018548:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801854c:	4413      	add	r3, r2
 801854e:	b29b      	uxth	r3, r3
 8018550:	b219      	sxth	r1, r3
 8018552:	687b      	ldr	r3, [r7, #4]
 8018554:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8018558:	9200      	str	r2, [sp, #0]
 801855a:	895b      	ldrh	r3, [r3, #10]
 801855c:	68ba      	ldr	r2, [r7, #8]
 801855e:	f7fb febc 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 8018562:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018566:	f003 0301 	and.w	r3, r3, #1
 801856a:	2b00      	cmp	r3, #0
 801856c:	d025      	beq.n	80185ba <lv_draw_rect_border_corner+0x1242>
 801856e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018572:	f003 0304 	and.w	r3, r3, #4
 8018576:	2b00      	cmp	r3, #0
 8018578:	d01f      	beq.n	80185ba <lv_draw_rect_border_corner+0x1242>
                lv_draw_px(lb_origo.x + LV_CIRC_OCT3_X(aa_p) - i, lb_origo.y + LV_CIRC_OCT3_Y(aa_p) - 1, mask,
 801857a:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 801857e:	b29a      	uxth	r2, r3
 8018580:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018584:	b29b      	uxth	r3, r3
 8018586:	1ad3      	subs	r3, r2, r3
 8018588:	b29a      	uxth	r2, r3
 801858a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801858e:	1ad3      	subs	r3, r2, r3
 8018590:	b29b      	uxth	r3, r3
 8018592:	b218      	sxth	r0, r3
 8018594:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8018598:	b29a      	uxth	r2, r3
 801859a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801859e:	b29b      	uxth	r3, r3
 80185a0:	4413      	add	r3, r2
 80185a2:	b29b      	uxth	r3, r3
 80185a4:	3b01      	subs	r3, #1
 80185a6:	b29b      	uxth	r3, r3
 80185a8:	b219      	sxth	r1, r3
 80185aa:	687b      	ldr	r3, [r7, #4]
 80185ac:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 80185b0:	9200      	str	r2, [sp, #0]
 80185b2:	895b      	ldrh	r3, [r3, #10]
 80185b4:	68ba      	ldr	r2, [r7, #8]
 80185b6:	f7fb fe90 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 80185ba:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80185be:	f003 0302 	and.w	r3, r3, #2
 80185c2:	2b00      	cmp	r3, #0
 80185c4:	d025      	beq.n	8018612 <lv_draw_rect_border_corner+0x129a>
 80185c6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80185ca:	f003 0304 	and.w	r3, r3, #4
 80185ce:	2b00      	cmp	r3, #0
 80185d0:	d01f      	beq.n	8018612 <lv_draw_rect_border_corner+0x129a>
                lv_draw_px(lt_origo.x + LV_CIRC_OCT5_X(aa_p) + 1, lt_origo.y + LV_CIRC_OCT5_Y(aa_p) - i, mask,
 80185d2:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 80185d6:	b29a      	uxth	r2, r3
 80185d8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80185dc:	b29b      	uxth	r3, r3
 80185de:	1ad3      	subs	r3, r2, r3
 80185e0:	b29b      	uxth	r3, r3
 80185e2:	3301      	adds	r3, #1
 80185e4:	b29b      	uxth	r3, r3
 80185e6:	b218      	sxth	r0, r3
 80185e8:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 80185ec:	b29a      	uxth	r2, r3
 80185ee:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80185f2:	b29b      	uxth	r3, r3
 80185f4:	1ad3      	subs	r3, r2, r3
 80185f6:	b29a      	uxth	r2, r3
 80185f8:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80185fc:	1ad3      	subs	r3, r2, r3
 80185fe:	b29b      	uxth	r3, r3
 8018600:	b219      	sxth	r1, r3
 8018602:	687b      	ldr	r3, [r7, #4]
 8018604:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8018608:	9200      	str	r2, [sp, #0]
 801860a:	895b      	ldrh	r3, [r3, #10]
 801860c:	68ba      	ldr	r2, [r7, #8]
 801860e:	f7fb fe64 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 8018612:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018616:	f003 0302 	and.w	r3, r3, #2
 801861a:	2b00      	cmp	r3, #0
 801861c:	d025      	beq.n	801866a <lv_draw_rect_border_corner+0x12f2>
 801861e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018622:	f003 0308 	and.w	r3, r3, #8
 8018626:	2b00      	cmp	r3, #0
 8018628:	d01f      	beq.n	801866a <lv_draw_rect_border_corner+0x12f2>
                lv_draw_px(rt_origo.x + LV_CIRC_OCT7_X(aa_p) + i, rt_origo.y + LV_CIRC_OCT7_Y(aa_p) + 1, mask,
 801862a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 801862e:	b29a      	uxth	r2, r3
 8018630:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018634:	b29b      	uxth	r3, r3
 8018636:	4413      	add	r3, r2
 8018638:	b29a      	uxth	r2, r3
 801863a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801863e:	4413      	add	r3, r2
 8018640:	b29b      	uxth	r3, r3
 8018642:	b218      	sxth	r0, r3
 8018644:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8018648:	b29a      	uxth	r2, r3
 801864a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801864e:	b29b      	uxth	r3, r3
 8018650:	1ad3      	subs	r3, r2, r3
 8018652:	b29b      	uxth	r3, r3
 8018654:	3301      	adds	r3, #1
 8018656:	b29b      	uxth	r3, r3
 8018658:	b219      	sxth	r1, r3
 801865a:	687b      	ldr	r3, [r7, #4]
 801865c:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8018660:	9200      	str	r2, [sp, #0]
 8018662:	895b      	ldrh	r3, [r3, #10]
 8018664:	68ba      	ldr	r2, [r7, #8]
 8018666:	f7fb fe38 	bl	80142da <lv_draw_px>
                           style->body.border.color, aa_opa);
            }

            if(LV_CIRC_OCT1_X(aa_p) - 1 != LV_CIRC_OCT2_X(aa_p) + i) {
 801866a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801866e:	1e5a      	subs	r2, r3, #1
 8018670:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018674:	4619      	mov	r1, r3
 8018676:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801867a:	440b      	add	r3, r1
 801867c:	429a      	cmp	r2, r3
 801867e:	f000 80b0 	beq.w	80187e2 <lv_draw_rect_border_corner+0x146a>
                if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_RIGHT)) {
 8018682:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018686:	f003 0301 	and.w	r3, r3, #1
 801868a:	2b00      	cmp	r3, #0
 801868c:	d025      	beq.n	80186da <lv_draw_rect_border_corner+0x1362>
 801868e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018692:	f003 0308 	and.w	r3, r3, #8
 8018696:	2b00      	cmp	r3, #0
 8018698:	d01f      	beq.n	80186da <lv_draw_rect_border_corner+0x1362>
                    lv_draw_px(rb_origo.x + LV_CIRC_OCT2_X(aa_p) + i, rb_origo.y + LV_CIRC_OCT2_Y(aa_p) - 1, mask,
 801869a:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 801869e:	b29a      	uxth	r2, r3
 80186a0:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80186a4:	b29b      	uxth	r3, r3
 80186a6:	4413      	add	r3, r2
 80186a8:	b29a      	uxth	r2, r3
 80186aa:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80186ae:	4413      	add	r3, r2
 80186b0:	b29b      	uxth	r3, r3
 80186b2:	b218      	sxth	r0, r3
 80186b4:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 80186b8:	b29a      	uxth	r2, r3
 80186ba:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80186be:	b29b      	uxth	r3, r3
 80186c0:	4413      	add	r3, r2
 80186c2:	b29b      	uxth	r3, r3
 80186c4:	3b01      	subs	r3, #1
 80186c6:	b29b      	uxth	r3, r3
 80186c8:	b219      	sxth	r1, r3
 80186ca:	687b      	ldr	r3, [r7, #4]
 80186cc:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 80186d0:	9200      	str	r2, [sp, #0]
 80186d2:	895b      	ldrh	r3, [r3, #10]
 80186d4:	68ba      	ldr	r2, [r7, #8]
 80186d6:	f7fb fe00 	bl	80142da <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_BOTTOM) && (part & LV_BORDER_LEFT)) {
 80186da:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80186de:	f003 0301 	and.w	r3, r3, #1
 80186e2:	2b00      	cmp	r3, #0
 80186e4:	d025      	beq.n	8018732 <lv_draw_rect_border_corner+0x13ba>
 80186e6:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 80186ea:	f003 0304 	and.w	r3, r3, #4
 80186ee:	2b00      	cmp	r3, #0
 80186f0:	d01f      	beq.n	8018732 <lv_draw_rect_border_corner+0x13ba>
                    lv_draw_px(lb_origo.x + LV_CIRC_OCT4_X(aa_p) + 1, lb_origo.y + LV_CIRC_OCT4_Y(aa_p) + i, mask,
 80186f2:	f9b7 303c 	ldrsh.w	r3, [r7, #60]	; 0x3c
 80186f6:	b29a      	uxth	r2, r3
 80186f8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80186fc:	b29b      	uxth	r3, r3
 80186fe:	1ad3      	subs	r3, r2, r3
 8018700:	b29b      	uxth	r3, r3
 8018702:	3301      	adds	r3, #1
 8018704:	b29b      	uxth	r3, r3
 8018706:	b218      	sxth	r0, r3
 8018708:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 801870c:	b29a      	uxth	r2, r3
 801870e:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018712:	b29b      	uxth	r3, r3
 8018714:	4413      	add	r3, r2
 8018716:	b29a      	uxth	r2, r3
 8018718:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801871c:	4413      	add	r3, r2
 801871e:	b29b      	uxth	r3, r3
 8018720:	b219      	sxth	r1, r3
 8018722:	687b      	ldr	r3, [r7, #4]
 8018724:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8018728:	9200      	str	r2, [sp, #0]
 801872a:	895b      	ldrh	r3, [r3, #10]
 801872c:	68ba      	ldr	r2, [r7, #8]
 801872e:	f7fb fdd4 	bl	80142da <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_TOP) && (part & LV_BORDER_LEFT)) {
 8018732:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018736:	f003 0302 	and.w	r3, r3, #2
 801873a:	2b00      	cmp	r3, #0
 801873c:	d025      	beq.n	801878a <lv_draw_rect_border_corner+0x1412>
 801873e:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 8018742:	f003 0304 	and.w	r3, r3, #4
 8018746:	2b00      	cmp	r3, #0
 8018748:	d01f      	beq.n	801878a <lv_draw_rect_border_corner+0x1412>
                    lv_draw_px(lt_origo.x + LV_CIRC_OCT6_X(aa_p) - i, lt_origo.y + LV_CIRC_OCT6_Y(aa_p) + 1, mask,
 801874a:	f9b7 3040 	ldrsh.w	r3, [r7, #64]	; 0x40
 801874e:	b29a      	uxth	r2, r3
 8018750:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018754:	b29b      	uxth	r3, r3
 8018756:	1ad3      	subs	r3, r2, r3
 8018758:	b29a      	uxth	r2, r3
 801875a:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801875e:	1ad3      	subs	r3, r2, r3
 8018760:	b29b      	uxth	r3, r3
 8018762:	b218      	sxth	r0, r3
 8018764:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8018768:	b29a      	uxth	r2, r3
 801876a:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801876e:	b29b      	uxth	r3, r3
 8018770:	1ad3      	subs	r3, r2, r3
 8018772:	b29b      	uxth	r3, r3
 8018774:	3301      	adds	r3, #1
 8018776:	b29b      	uxth	r3, r3
 8018778:	b219      	sxth	r1, r3
 801877a:	687b      	ldr	r3, [r7, #4]
 801877c:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 8018780:	9200      	str	r2, [sp, #0]
 8018782:	895b      	ldrh	r3, [r3, #10]
 8018784:	68ba      	ldr	r2, [r7, #8]
 8018786:	f7fb fda8 	bl	80142da <lv_draw_px>
                               style->body.border.color, aa_opa);
                }

                if((part & LV_BORDER_TOP) && (part & LV_BORDER_RIGHT)) {
 801878a:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801878e:	f003 0302 	and.w	r3, r3, #2
 8018792:	2b00      	cmp	r3, #0
 8018794:	d025      	beq.n	80187e2 <lv_draw_rect_border_corner+0x146a>
 8018796:	f897 305a 	ldrb.w	r3, [r7, #90]	; 0x5a
 801879a:	f003 0308 	and.w	r3, r3, #8
 801879e:	2b00      	cmp	r3, #0
 80187a0:	d01f      	beq.n	80187e2 <lv_draw_rect_border_corner+0x146a>
                    lv_draw_px(rt_origo.x + LV_CIRC_OCT8_X(aa_p) - 1, rt_origo.y + LV_CIRC_OCT8_Y(aa_p) - i, mask,
 80187a2:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80187a6:	b29a      	uxth	r2, r3
 80187a8:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80187ac:	b29b      	uxth	r3, r3
 80187ae:	4413      	add	r3, r2
 80187b0:	b29b      	uxth	r3, r3
 80187b2:	3b01      	subs	r3, #1
 80187b4:	b29b      	uxth	r3, r3
 80187b6:	b218      	sxth	r0, r3
 80187b8:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80187bc:	b29a      	uxth	r2, r3
 80187be:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80187c2:	b29b      	uxth	r3, r3
 80187c4:	1ad3      	subs	r3, r2, r3
 80187c6:	b29a      	uxth	r2, r3
 80187c8:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 80187cc:	1ad3      	subs	r3, r2, r3
 80187ce:	b29b      	uxth	r3, r3
 80187d0:	b219      	sxth	r1, r3
 80187d2:	687b      	ldr	r3, [r7, #4]
 80187d4:	f897 204c 	ldrb.w	r2, [r7, #76]	; 0x4c
 80187d8:	9200      	str	r2, [sp, #0]
 80187da:	895b      	ldrh	r3, [r3, #10]
 80187dc:	68ba      	ldr	r2, [r7, #8]
 80187de:	f7fb fd7c 	bl	80142da <lv_draw_px>
        for(i = 0; i < seg_size; i++) {
 80187e2:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80187e6:	b29b      	uxth	r3, r3
 80187e8:	3301      	adds	r3, #1
 80187ea:	b29b      	uxth	r3, r3
 80187ec:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80187f0:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80187f4:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 80187f8:	429a      	cmp	r2, r3
 80187fa:	f6ff ae7a 	blt.w	80184f2 <lv_draw_rect_border_corner+0x117a>
                }
            }
        }
    }
#endif
}
 80187fe:	bf00      	nop
 8018800:	3778      	adds	r7, #120	; 0x78
 8018802:	46bd      	mov	sp, r7
 8018804:	bd80      	pop	{r7, pc}

08018806 <lv_draw_shadow>:
 * @param mask pointer to a mask area (from the design functions)
 * @param opa_scale scale down all opacities by the factor
 */
static void lv_draw_shadow(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                           lv_opa_t opa_scale)
{
 8018806:	b580      	push	{r7, lr}
 8018808:	b088      	sub	sp, #32
 801880a:	af00      	add	r7, sp, #0
 801880c:	60f8      	str	r0, [r7, #12]
 801880e:	60b9      	str	r1, [r7, #8]
 8018810:	607a      	str	r2, [r7, #4]
 8018812:	70fb      	strb	r3, [r7, #3]
    /* If mask is in the middle of cords do not draw shadow*/
    lv_coord_t radius = style->body.radius;
 8018814:	687b      	ldr	r3, [r7, #4]
 8018816:	88db      	ldrh	r3, [r3, #6]
 8018818:	83fb      	strh	r3, [r7, #30]
    lv_coord_t width  = lv_area_get_width(coords);
 801881a:	68f8      	ldr	r0, [r7, #12]
 801881c:	f7fd f843 	bl	80158a6 <lv_area_get_width>
 8018820:	4603      	mov	r3, r0
 8018822:	83bb      	strh	r3, [r7, #28]
    lv_coord_t height = lv_area_get_height(coords);
 8018824:	68f8      	ldr	r0, [r7, #12]
 8018826:	f7fd f855 	bl	80158d4 <lv_area_get_height>
 801882a:	4603      	mov	r3, r0
 801882c:	837b      	strh	r3, [r7, #26]
    radius            = lv_draw_cont_radius_corr(radius, width, height);
 801882e:	8bfb      	ldrh	r3, [r7, #30]
 8018830:	f9b7 201a 	ldrsh.w	r2, [r7, #26]
 8018834:	f9b7 101c 	ldrsh.w	r1, [r7, #28]
 8018838:	4618      	mov	r0, r3
 801883a:	f000 fedc 	bl	80195f6 <lv_draw_cont_radius_corr>
 801883e:	4603      	mov	r3, r0
 8018840:	83fb      	strh	r3, [r7, #30]
    lv_area_t area_tmp;

    /*Check horizontally without radius*/
    lv_area_copy(&area_tmp, coords);
 8018842:	f107 0310 	add.w	r3, r7, #16
 8018846:	68f9      	ldr	r1, [r7, #12]
 8018848:	4618      	mov	r0, r3
 801884a:	f7fd f81e 	bl	801588a <lv_area_copy>
    area_tmp.x1 += radius;
 801884e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8018852:	b29a      	uxth	r2, r3
 8018854:	8bfb      	ldrh	r3, [r7, #30]
 8018856:	4413      	add	r3, r2
 8018858:	b29b      	uxth	r3, r3
 801885a:	b21b      	sxth	r3, r3
 801885c:	823b      	strh	r3, [r7, #16]
    area_tmp.x2 -= radius;
 801885e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018862:	b29a      	uxth	r2, r3
 8018864:	8bfb      	ldrh	r3, [r7, #30]
 8018866:	1ad3      	subs	r3, r2, r3
 8018868:	b29b      	uxth	r3, r3
 801886a:	b21b      	sxth	r3, r3
 801886c:	82bb      	strh	r3, [r7, #20]
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 801886e:	f107 0310 	add.w	r3, r7, #16
 8018872:	4619      	mov	r1, r3
 8018874:	68b8      	ldr	r0, [r7, #8]
 8018876:	f003 fa1a 	bl	801bcae <lv_area_is_in>
 801887a:	4603      	mov	r3, r0
 801887c:	2b00      	cmp	r3, #0
 801887e:	d134      	bne.n	80188ea <lv_draw_shadow+0xe4>

    /*Check vertically without radius*/
    lv_area_copy(&area_tmp, coords);
 8018880:	f107 0310 	add.w	r3, r7, #16
 8018884:	68f9      	ldr	r1, [r7, #12]
 8018886:	4618      	mov	r0, r3
 8018888:	f7fc ffff 	bl	801588a <lv_area_copy>
    area_tmp.y1 += radius;
 801888c:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8018890:	b29a      	uxth	r2, r3
 8018892:	8bfb      	ldrh	r3, [r7, #30]
 8018894:	4413      	add	r3, r2
 8018896:	b29b      	uxth	r3, r3
 8018898:	b21b      	sxth	r3, r3
 801889a:	827b      	strh	r3, [r7, #18]
    area_tmp.y2 -= radius;
 801889c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80188a0:	b29a      	uxth	r2, r3
 80188a2:	8bfb      	ldrh	r3, [r7, #30]
 80188a4:	1ad3      	subs	r3, r2, r3
 80188a6:	b29b      	uxth	r3, r3
 80188a8:	b21b      	sxth	r3, r3
 80188aa:	82fb      	strh	r3, [r7, #22]
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 80188ac:	f107 0310 	add.w	r3, r7, #16
 80188b0:	4619      	mov	r1, r3
 80188b2:	68b8      	ldr	r0, [r7, #8]
 80188b4:	f003 f9fb 	bl	801bcae <lv_area_is_in>
 80188b8:	4603      	mov	r3, r0
 80188ba:	2b00      	cmp	r3, #0
 80188bc:	d117      	bne.n	80188ee <lv_draw_shadow+0xe8>

    if(style->body.shadow.type == LV_SHADOW_FULL) {
 80188be:	687b      	ldr	r3, [r7, #4]
 80188c0:	7d1b      	ldrb	r3, [r3, #20]
 80188c2:	2b01      	cmp	r3, #1
 80188c4:	d106      	bne.n	80188d4 <lv_draw_shadow+0xce>
        lv_draw_shadow_full(coords, mask, style, opa_scale);
 80188c6:	78fb      	ldrb	r3, [r7, #3]
 80188c8:	687a      	ldr	r2, [r7, #4]
 80188ca:	68b9      	ldr	r1, [r7, #8]
 80188cc:	68f8      	ldr	r0, [r7, #12]
 80188ce:	f000 f812 	bl	80188f6 <lv_draw_shadow_full>
 80188d2:	e00d      	b.n	80188f0 <lv_draw_shadow+0xea>
    } else if(style->body.shadow.type == LV_SHADOW_BOTTOM) {
 80188d4:	687b      	ldr	r3, [r7, #4]
 80188d6:	7d1b      	ldrb	r3, [r3, #20]
 80188d8:	2b00      	cmp	r3, #0
 80188da:	d109      	bne.n	80188f0 <lv_draw_shadow+0xea>
        lv_draw_shadow_bottom(coords, mask, style, opa_scale);
 80188dc:	78fb      	ldrb	r3, [r7, #3]
 80188de:	687a      	ldr	r2, [r7, #4]
 80188e0:	68b9      	ldr	r1, [r7, #8]
 80188e2:	68f8      	ldr	r0, [r7, #12]
 80188e4:	f000 fb2e 	bl	8018f44 <lv_draw_shadow_bottom>
 80188e8:	e002      	b.n	80188f0 <lv_draw_shadow+0xea>
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 80188ea:	bf00      	nop
 80188ec:	e000      	b.n	80188f0 <lv_draw_shadow+0xea>
    if(lv_area_is_in(mask, &area_tmp) != false) return;
 80188ee:	bf00      	nop
    }
}
 80188f0:	3720      	adds	r7, #32
 80188f2:	46bd      	mov	sp, r7
 80188f4:	bd80      	pop	{r7, pc}

080188f6 <lv_draw_shadow_full>:

static void lv_draw_shadow_full(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                lv_opa_t opa_scale)
{
 80188f6:	b580      	push	{r7, lr}
 80188f8:	b0a0      	sub	sp, #128	; 0x80
 80188fa:	af02      	add	r7, sp, #8
 80188fc:	60f8      	str	r0, [r7, #12]
 80188fe:	60b9      	str	r1, [r7, #8]
 8018900:	607a      	str	r2, [r7, #4]
 8018902:	70fb      	strb	r3, [r7, #3]
     * radius means smaller average shadow opacity. The solution should be to start `line` from `-
     * swidth` and handle if the straight part is short (or zero) and the value is taken from the
     * other corner. `col` also should start from `- swidth`
     */

    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8018904:	f7fa f8cc 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8018908:	4603      	mov	r3, r0
 801890a:	4618      	mov	r0, r3
 801890c:	f002 fc2e 	bl	801b16c <lv_disp_get_antialiasing>
 8018910:	4603      	mov	r3, r0
 8018912:	f887 3067 	strb.w	r3, [r7, #103]	; 0x67

    lv_coord_t radius = style->body.radius;
 8018916:	687b      	ldr	r3, [r7, #4]
 8018918:	88db      	ldrh	r3, [r3, #6]
 801891a:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
    lv_coord_t swidth = style->body.shadow.width;
 801891e:	687b      	ldr	r3, [r7, #4]
 8018920:	8a5b      	ldrh	r3, [r3, #18]
 8018922:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

    lv_coord_t width  = lv_area_get_width(coords);
 8018926:	68f8      	ldr	r0, [r7, #12]
 8018928:	f7fc ffbd 	bl	80158a6 <lv_area_get_width>
 801892c:	4603      	mov	r3, r0
 801892e:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
    lv_coord_t height = lv_area_get_height(coords);
 8018932:	68f8      	ldr	r0, [r7, #12]
 8018934:	f7fc ffce 	bl	80158d4 <lv_area_get_height>
 8018938:	4603      	mov	r3, r0
 801893a:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e

    radius = lv_draw_cont_radius_corr(radius, width, height);
 801893e:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018942:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 8018946:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801894a:	4618      	mov	r0, r3
 801894c:	f000 fe53 	bl	80195f6 <lv_draw_cont_radius_corr>
 8018950:	4603      	mov	r3, r0
 8018952:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

    radius += aa;
 8018956:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 801895a:	b29a      	uxth	r2, r3
 801895c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018960:	4413      	add	r3, r2
 8018962:	b29b      	uxth	r3, r3
 8018964:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

    /*Allocate a draw buffer the buffer required to draw the shadow*/
    int16_t filter_width = 2 * swidth + 1;
 8018968:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801896c:	005b      	lsls	r3, r3, #1
 801896e:	b29b      	uxth	r3, r3
 8018970:	3301      	adds	r3, #1
 8018972:	b29b      	uxth	r3, r3
 8018974:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
    uint32_t curve_x_size = ((radius + swidth + 1) + 3) & ~0x3; /*Round to 4*/
 8018978:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 801897c:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018980:	4413      	add	r3, r2
 8018982:	3304      	adds	r3, #4
 8018984:	f023 0303 	bic.w	r3, r3, #3
 8018988:	65bb      	str	r3, [r7, #88]	; 0x58
    curve_x_size *= sizeof(lv_coord_t);
 801898a:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 801898c:	005b      	lsls	r3, r3, #1
 801898e:	65bb      	str	r3, [r7, #88]	; 0x58
    uint32_t line_1d_blur_size = (filter_width + 3) & ~0x3;     /*Round to 4*/
 8018990:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8018994:	3303      	adds	r3, #3
 8018996:	f023 0303 	bic.w	r3, r3, #3
 801899a:	657b      	str	r3, [r7, #84]	; 0x54
    line_1d_blur_size *= sizeof(uint32_t);
 801899c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 801899e:	009b      	lsls	r3, r3, #2
 80189a0:	657b      	str	r3, [r7, #84]	; 0x54
    uint32_t line_2d_blur_size = ((radius + swidth + 1) + 3) & ~0x3;     /*Round to 4*/
 80189a2:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 80189a6:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 80189aa:	4413      	add	r3, r2
 80189ac:	3304      	adds	r3, #4
 80189ae:	f023 0303 	bic.w	r3, r3, #3
 80189b2:	653b      	str	r3, [r7, #80]	; 0x50
    line_2d_blur_size *= sizeof(lv_opa_t);

    uint8_t * draw_buf = lv_draw_get_buf(curve_x_size + line_1d_blur_size + line_2d_blur_size);
 80189b4:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80189b6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80189b8:	441a      	add	r2, r3
 80189ba:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 80189bc:	4413      	add	r3, r2
 80189be:	4618      	mov	r0, r3
 80189c0:	f7fb fb50 	bl	8014064 <lv_draw_get_buf>
 80189c4:	64f8      	str	r0, [r7, #76]	; 0x4c

    /*Divide the draw buffer*/
    lv_coord_t  * curve_x = (lv_coord_t *)&draw_buf[0]; /*Stores the 'x' coordinates of a quarter circle.*/
 80189c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80189c8:	64bb      	str	r3, [r7, #72]	; 0x48
    uint32_t * line_1d_blur = (uint32_t *)&draw_buf[curve_x_size];
 80189ca:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80189cc:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 80189ce:	4413      	add	r3, r2
 80189d0:	647b      	str	r3, [r7, #68]	; 0x44
    lv_opa_t * line_2d_blur = (lv_opa_t *)&draw_buf[curve_x_size + line_1d_blur_size];
 80189d2:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80189d4:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80189d6:	4413      	add	r3, r2
 80189d8:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80189da:	4413      	add	r3, r2
 80189dc:	643b      	str	r3, [r7, #64]	; 0x40

    memset(curve_x, 0, curve_x_size);
 80189de:	6dba      	ldr	r2, [r7, #88]	; 0x58
 80189e0:	2100      	movs	r1, #0
 80189e2:	6cb8      	ldr	r0, [r7, #72]	; 0x48
 80189e4:	f00e fbf5 	bl	80271d2 <memset>
    lv_point_t circ;
    lv_coord_t circ_tmp;
    lv_circ_init(&circ, &circ_tmp, radius);
 80189e8:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 80189ec:	f107 0136 	add.w	r1, r7, #54	; 0x36
 80189f0:	f107 0338 	add.w	r3, r7, #56	; 0x38
 80189f4:	4618      	mov	r0, r3
 80189f6:	f003 f98a 	bl	801bd0e <lv_circ_init>
    while(lv_circ_cont(&circ)) {
 80189fa:	e017      	b.n	8018a2c <lv_draw_shadow_full+0x136>
        curve_x[LV_CIRC_OCT1_Y(circ)] = LV_CIRC_OCT1_X(circ);
 80189fc:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8018a00:	005b      	lsls	r3, r3, #1
 8018a02:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8018a04:	4413      	add	r3, r2
 8018a06:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8018a0a:	801a      	strh	r2, [r3, #0]
        curve_x[LV_CIRC_OCT2_Y(circ)] = LV_CIRC_OCT2_X(circ);
 8018a0c:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8018a10:	005b      	lsls	r3, r3, #1
 8018a12:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8018a14:	4413      	add	r3, r2
 8018a16:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8018a1a:	801a      	strh	r2, [r3, #0]
        lv_circ_next(&circ, &circ_tmp);
 8018a1c:	f107 0236 	add.w	r2, r7, #54	; 0x36
 8018a20:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8018a24:	4611      	mov	r1, r2
 8018a26:	4618      	mov	r0, r3
 8018a28:	f003 f9a0 	bl	801bd6c <lv_circ_next>
    while(lv_circ_cont(&circ)) {
 8018a2c:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8018a30:	4618      	mov	r0, r3
 8018a32:	f003 f986 	bl	801bd42 <lv_circ_cont>
 8018a36:	4603      	mov	r3, r0
 8018a38:	2b00      	cmp	r3, #0
 8018a3a:	d1df      	bne.n	80189fc <lv_draw_shadow_full+0x106>
    }
    int16_t line;
    /*1D Blur horizontally*/
    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8018a3c:	78fb      	ldrb	r3, [r7, #3]
 8018a3e:	2bff      	cmp	r3, #255	; 0xff
 8018a40:	d102      	bne.n	8018a48 <lv_draw_shadow_full+0x152>
 8018a42:	687b      	ldr	r3, [r7, #4]
 8018a44:	7a1b      	ldrb	r3, [r3, #8]
 8018a46:	e00a      	b.n	8018a5e <lv_draw_shadow_full+0x168>
 8018a48:	687b      	ldr	r3, [r7, #4]
 8018a4a:	7a1b      	ldrb	r3, [r3, #8]
 8018a4c:	b29a      	uxth	r2, r3
 8018a4e:	78fb      	ldrb	r3, [r7, #3]
 8018a50:	b29b      	uxth	r3, r3
 8018a52:	fb12 f303 	smulbb	r3, r2, r3
 8018a56:	b29b      	uxth	r3, r3
 8018a58:	0a1b      	lsrs	r3, r3, #8
 8018a5a:	b29b      	uxth	r3, r3
 8018a5c:	b2db      	uxtb	r3, r3
 8018a5e:	f887 303f 	strb.w	r3, [r7, #63]	; 0x3f
    for(line = 0; line < filter_width; line++) {
 8018a62:	2300      	movs	r3, #0
 8018a64:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8018a68:	e021      	b.n	8018aae <lv_draw_shadow_full+0x1b8>
        line_1d_blur[line] = (uint32_t)((uint32_t)(filter_width - line) * (opa * 2) << SHADOW_OPA_EXTRA_PRECISION) /
 8018a6a:	f9b7 205c 	ldrsh.w	r2, [r7, #92]	; 0x5c
 8018a6e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018a72:	1ad3      	subs	r3, r2, r3
 8018a74:	461a      	mov	r2, r3
 8018a76:	f897 303f 	ldrb.w	r3, [r7, #63]	; 0x3f
 8018a7a:	fb03 f302 	mul.w	r3, r3, r2
 8018a7e:	005b      	lsls	r3, r3, #1
 8018a80:	021a      	lsls	r2, r3, #8
                             (filter_width * filter_width);
 8018a82:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8018a86:	f9b7 105c 	ldrsh.w	r1, [r7, #92]	; 0x5c
 8018a8a:	fb01 f303 	mul.w	r3, r1, r3
 8018a8e:	4618      	mov	r0, r3
        line_1d_blur[line] = (uint32_t)((uint32_t)(filter_width - line) * (opa * 2) << SHADOW_OPA_EXTRA_PRECISION) /
 8018a90:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018a94:	009b      	lsls	r3, r3, #2
 8018a96:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8018a98:	440b      	add	r3, r1
 8018a9a:	fbb2 f2f0 	udiv	r2, r2, r0
 8018a9e:	601a      	str	r2, [r3, #0]
    for(line = 0; line < filter_width; line++) {
 8018aa0:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018aa4:	b29b      	uxth	r3, r3
 8018aa6:	3301      	adds	r3, #1
 8018aa8:	b29b      	uxth	r3, r3
 8018aaa:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8018aae:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8018ab2:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8018ab6:	429a      	cmp	r2, r3
 8018ab8:	dbd7      	blt.n	8018a6a <lv_draw_shadow_full+0x174>
    lv_point_t point_lb;
    lv_point_t ofs_rb;
    lv_point_t ofs_rt;
    lv_point_t ofs_lb;
    lv_point_t ofs_lt;
    ofs_rb.x = coords->x2 - radius - aa;
 8018aba:	68fb      	ldr	r3, [r7, #12]
 8018abc:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018ac0:	b29a      	uxth	r2, r3
 8018ac2:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018ac6:	1ad3      	subs	r3, r2, r3
 8018ac8:	b29a      	uxth	r2, r3
 8018aca:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018ace:	b29b      	uxth	r3, r3
 8018ad0:	1ad3      	subs	r3, r2, r3
 8018ad2:	b29b      	uxth	r3, r3
 8018ad4:	b21b      	sxth	r3, r3
 8018ad6:	843b      	strh	r3, [r7, #32]
    ofs_rb.y = coords->y2 - radius - aa;
 8018ad8:	68fb      	ldr	r3, [r7, #12]
 8018ada:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018ade:	b29a      	uxth	r2, r3
 8018ae0:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018ae4:	1ad3      	subs	r3, r2, r3
 8018ae6:	b29a      	uxth	r2, r3
 8018ae8:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018aec:	b29b      	uxth	r3, r3
 8018aee:	1ad3      	subs	r3, r2, r3
 8018af0:	b29b      	uxth	r3, r3
 8018af2:	b21b      	sxth	r3, r3
 8018af4:	847b      	strh	r3, [r7, #34]	; 0x22

    ofs_rt.x = coords->x2 - radius - aa;
 8018af6:	68fb      	ldr	r3, [r7, #12]
 8018af8:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8018afc:	b29a      	uxth	r2, r3
 8018afe:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018b02:	1ad3      	subs	r3, r2, r3
 8018b04:	b29a      	uxth	r2, r3
 8018b06:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018b0a:	b29b      	uxth	r3, r3
 8018b0c:	1ad3      	subs	r3, r2, r3
 8018b0e:	b29b      	uxth	r3, r3
 8018b10:	b21b      	sxth	r3, r3
 8018b12:	83bb      	strh	r3, [r7, #28]
    ofs_rt.y = coords->y1 + radius + aa;
 8018b14:	68fb      	ldr	r3, [r7, #12]
 8018b16:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018b1a:	b29a      	uxth	r2, r3
 8018b1c:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018b20:	4413      	add	r3, r2
 8018b22:	b29a      	uxth	r2, r3
 8018b24:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018b28:	b29b      	uxth	r3, r3
 8018b2a:	4413      	add	r3, r2
 8018b2c:	b29b      	uxth	r3, r3
 8018b2e:	b21b      	sxth	r3, r3
 8018b30:	83fb      	strh	r3, [r7, #30]

    ofs_lb.x = coords->x1 + radius + aa;
 8018b32:	68fb      	ldr	r3, [r7, #12]
 8018b34:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018b38:	b29a      	uxth	r2, r3
 8018b3a:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018b3e:	4413      	add	r3, r2
 8018b40:	b29a      	uxth	r2, r3
 8018b42:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018b46:	b29b      	uxth	r3, r3
 8018b48:	4413      	add	r3, r2
 8018b4a:	b29b      	uxth	r3, r3
 8018b4c:	b21b      	sxth	r3, r3
 8018b4e:	833b      	strh	r3, [r7, #24]
    ofs_lb.y = coords->y2 - radius - aa;
 8018b50:	68fb      	ldr	r3, [r7, #12]
 8018b52:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8018b56:	b29a      	uxth	r2, r3
 8018b58:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018b5c:	1ad3      	subs	r3, r2, r3
 8018b5e:	b29a      	uxth	r2, r3
 8018b60:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018b64:	b29b      	uxth	r3, r3
 8018b66:	1ad3      	subs	r3, r2, r3
 8018b68:	b29b      	uxth	r3, r3
 8018b6a:	b21b      	sxth	r3, r3
 8018b6c:	837b      	strh	r3, [r7, #26]

    ofs_lt.x = coords->x1 + radius + aa;
 8018b6e:	68fb      	ldr	r3, [r7, #12]
 8018b70:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018b74:	b29a      	uxth	r2, r3
 8018b76:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018b7a:	4413      	add	r3, r2
 8018b7c:	b29a      	uxth	r2, r3
 8018b7e:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018b82:	b29b      	uxth	r3, r3
 8018b84:	4413      	add	r3, r2
 8018b86:	b29b      	uxth	r3, r3
 8018b88:	b21b      	sxth	r3, r3
 8018b8a:	82bb      	strh	r3, [r7, #20]
    ofs_lt.y = coords->y1 + radius + aa;
 8018b8c:	68fb      	ldr	r3, [r7, #12]
 8018b8e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8018b92:	b29a      	uxth	r2, r3
 8018b94:	f8b7 3064 	ldrh.w	r3, [r7, #100]	; 0x64
 8018b98:	4413      	add	r3, r2
 8018b9a:	b29a      	uxth	r2, r3
 8018b9c:	f897 3067 	ldrb.w	r3, [r7, #103]	; 0x67
 8018ba0:	b29b      	uxth	r3, r3
 8018ba2:	4413      	add	r3, r2
 8018ba4:	b29b      	uxth	r3, r3
 8018ba6:	b21b      	sxth	r3, r3
 8018ba8:	82fb      	strh	r3, [r7, #22]
    bool line_ready;
    for(line = 0; line <= radius + swidth; line++) { /*Check all rows and make the 1D blur to 2D*/
 8018baa:	2300      	movs	r3, #0
 8018bac:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8018bb0:	e1ba      	b.n	8018f28 <lv_draw_shadow_full+0x632>
        line_ready = false;
 8018bb2:	2300      	movs	r3, #0
 8018bb4:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
        for(col = 0; col <= radius + swidth; col++) { /*Check all pixels in a 1D blur line (from the origo to last
 8018bb8:	2300      	movs	r3, #0
 8018bba:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 8018bbe:	e098      	b.n	8018cf2 <lv_draw_shadow_full+0x3fc>
                                                         shadow pixel (radius + swidth))*/

            /*Sum the opacities from the lines above and below this 'row'*/
            int16_t line_rel;
            uint32_t px_opa_sum = 0;
 8018bc0:	2300      	movs	r3, #0
 8018bc2:	66fb      	str	r3, [r7, #108]	; 0x6c
            for(line_rel = -swidth; line_rel <= swidth; line_rel++) {
 8018bc4:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 8018bc8:	425b      	negs	r3, r3
 8018bca:	b29b      	uxth	r3, r3
 8018bcc:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 8018bd0:	e06e      	b.n	8018cb0 <lv_draw_shadow_full+0x3ba>
                /*Get the relative x position of the 'line_rel' to 'line'*/
                int16_t col_rel;
                if(line + line_rel < 0) { /*Below the radius, here is the blur of the edge */
 8018bd2:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8018bd6:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8018bda:	4413      	add	r3, r2
 8018bdc:	2b00      	cmp	r3, #0
 8018bde:	da12      	bge.n	8018c06 <lv_draw_shadow_full+0x310>
                    col_rel = radius - curve_x[line] - col;
 8018be0:	f8b7 2064 	ldrh.w	r2, [r7, #100]	; 0x64
 8018be4:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018be8:	005b      	lsls	r3, r3, #1
 8018bea:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8018bec:	440b      	add	r3, r1
 8018bee:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018bf2:	b29b      	uxth	r3, r3
 8018bf4:	1ad3      	subs	r3, r2, r3
 8018bf6:	b29a      	uxth	r2, r3
 8018bf8:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8018bfc:	1ad3      	subs	r3, r2, r3
 8018bfe:	b29b      	uxth	r3, r3
 8018c00:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
 8018c04:	e023      	b.n	8018c4e <lv_draw_shadow_full+0x358>
                } else if(line + line_rel > radius) { /*Above the radius, here won't be more 1D blur*/
 8018c06:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8018c0a:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8018c0e:	441a      	add	r2, r3
 8018c10:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8018c14:	429a      	cmp	r2, r3
 8018c16:	dc52      	bgt.n	8018cbe <lv_draw_shadow_full+0x3c8>
                    break;
                } else { /*Blur from the curve*/
                    col_rel = curve_x[line + line_rel] - curve_x[line] - col;
 8018c18:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8018c1c:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8018c20:	4413      	add	r3, r2
 8018c22:	005b      	lsls	r3, r3, #1
 8018c24:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8018c26:	4413      	add	r3, r2
 8018c28:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018c2c:	b29a      	uxth	r2, r3
 8018c2e:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018c32:	005b      	lsls	r3, r3, #1
 8018c34:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8018c36:	440b      	add	r3, r1
 8018c38:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018c3c:	b29b      	uxth	r3, r3
 8018c3e:	1ad3      	subs	r3, r2, r3
 8018c40:	b29a      	uxth	r2, r3
 8018c42:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8018c46:	1ad3      	subs	r3, r2, r3
 8018c48:	b29b      	uxth	r3, r3
 8018c4a:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
                }

                /*Add the value of the 1D blur on 'col_rel' position*/
                if(col_rel < -swidth) { /*Outside of the blurred area. */
 8018c4e:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 8018c52:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018c56:	425b      	negs	r3, r3
 8018c58:	429a      	cmp	r2, r3
 8018c5a:	da0a      	bge.n	8018c72 <lv_draw_shadow_full+0x37c>
                    if(line_rel == -swidth)
 8018c5c:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 8018c60:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018c64:	425b      	negs	r3, r3
 8018c66:	429a      	cmp	r2, r3
 8018c68:	d12b      	bne.n	8018cc2 <lv_draw_shadow_full+0x3cc>
                        line_ready = true; /*If no data even on the very first line then it wont't
 8018c6a:	2301      	movs	r3, #1
 8018c6c:	f887 3073 	strb.w	r3, [r7, #115]	; 0x73
                                              be anything else in this line*/
                    break;                 /*Break anyway because only smaller 'col_rel' values will come */
 8018c70:	e027      	b.n	8018cc2 <lv_draw_shadow_full+0x3cc>
                } else if(col_rel > swidth)
 8018c72:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 8018c76:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018c7a:	429a      	cmp	r2, r3
 8018c7c:	dd05      	ble.n	8018c8a <lv_draw_shadow_full+0x394>
                    px_opa_sum += line_1d_blur[0]; /*Inside the not blurred area*/
 8018c7e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8018c80:	681b      	ldr	r3, [r3, #0]
 8018c82:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8018c84:	4413      	add	r3, r2
 8018c86:	66fb      	str	r3, [r7, #108]	; 0x6c
 8018c88:	e00b      	b.n	8018ca2 <lv_draw_shadow_full+0x3ac>
                else
                    px_opa_sum += line_1d_blur[swidth - col_rel]; /*On the 1D blur (+ swidth to align to the center)*/
 8018c8a:	f9b7 2062 	ldrsh.w	r2, [r7, #98]	; 0x62
 8018c8e:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8018c92:	1ad3      	subs	r3, r2, r3
 8018c94:	009b      	lsls	r3, r3, #2
 8018c96:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8018c98:	4413      	add	r3, r2
 8018c9a:	681b      	ldr	r3, [r3, #0]
 8018c9c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 8018c9e:	4413      	add	r3, r2
 8018ca0:	66fb      	str	r3, [r7, #108]	; 0x6c
            for(line_rel = -swidth; line_rel <= swidth; line_rel++) {
 8018ca2:	f9b7 3070 	ldrsh.w	r3, [r7, #112]	; 0x70
 8018ca6:	b29b      	uxth	r3, r3
 8018ca8:	3301      	adds	r3, #1
 8018caa:	b29b      	uxth	r3, r3
 8018cac:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
 8018cb0:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 8018cb4:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018cb8:	429a      	cmp	r2, r3
 8018cba:	dd8a      	ble.n	8018bd2 <lv_draw_shadow_full+0x2dc>
 8018cbc:	e002      	b.n	8018cc4 <lv_draw_shadow_full+0x3ce>
                    break;
 8018cbe:	bf00      	nop
 8018cc0:	e000      	b.n	8018cc4 <lv_draw_shadow_full+0x3ce>
                    break;                 /*Break anyway because only smaller 'col_rel' values will come */
 8018cc2:	bf00      	nop
            }

            line_2d_blur[col] = px_opa_sum >> SHADOW_OPA_EXTRA_PRECISION;
 8018cc4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8018cc6:	0a19      	lsrs	r1, r3, #8
 8018cc8:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8018ccc:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018cce:	4413      	add	r3, r2
 8018cd0:	b2ca      	uxtb	r2, r1
 8018cd2:	701a      	strb	r2, [r3, #0]
            if(line_ready) {
 8018cd4:	f897 3073 	ldrb.w	r3, [r7, #115]	; 0x73
 8018cd8:	2b00      	cmp	r3, #0
 8018cda:	d005      	beq.n	8018ce8 <lv_draw_shadow_full+0x3f2>
                col++; /*To make this line to the last one ( drawing will go to '< col')*/
 8018cdc:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8018ce0:	3301      	adds	r3, #1
 8018ce2:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
                break;
 8018ce6:	e00e      	b.n	8018d06 <lv_draw_shadow_full+0x410>
        for(col = 0; col <= radius + swidth; col++) { /*Check all pixels in a 1D blur line (from the origo to last
 8018ce8:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8018cec:	3301      	adds	r3, #1
 8018cee:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
 8018cf2:	f8b7 2074 	ldrh.w	r2, [r7, #116]	; 0x74
 8018cf6:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 8018cfa:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018cfe:	440b      	add	r3, r1
 8018d00:	429a      	cmp	r2, r3
 8018d02:	f77f af5d 	ble.w	8018bc0 <lv_draw_shadow_full+0x2ca>
            }
        }

        /*Flush the line*/
        point_rt.x = curve_x[line] + ofs_rt.x + 1;
 8018d06:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018d0a:	005b      	lsls	r3, r3, #1
 8018d0c:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8018d0e:	4413      	add	r3, r2
 8018d10:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018d14:	b29a      	uxth	r2, r3
 8018d16:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8018d1a:	b29b      	uxth	r3, r3
 8018d1c:	4413      	add	r3, r2
 8018d1e:	b29b      	uxth	r3, r3
 8018d20:	3301      	adds	r3, #1
 8018d22:	b29b      	uxth	r3, r3
 8018d24:	b21b      	sxth	r3, r3
 8018d26:	863b      	strh	r3, [r7, #48]	; 0x30
        point_rt.y = ofs_rt.y - line;
 8018d28:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8018d2c:	b29a      	uxth	r2, r3
 8018d2e:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8018d32:	1ad3      	subs	r3, r2, r3
 8018d34:	b29b      	uxth	r3, r3
 8018d36:	b21b      	sxth	r3, r3
 8018d38:	867b      	strh	r3, [r7, #50]	; 0x32

        point_rb.x = curve_x[line] + ofs_rb.x + 1;
 8018d3a:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018d3e:	005b      	lsls	r3, r3, #1
 8018d40:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8018d42:	4413      	add	r3, r2
 8018d44:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018d48:	b29a      	uxth	r2, r3
 8018d4a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8018d4e:	b29b      	uxth	r3, r3
 8018d50:	4413      	add	r3, r2
 8018d52:	b29b      	uxth	r3, r3
 8018d54:	3301      	adds	r3, #1
 8018d56:	b29b      	uxth	r3, r3
 8018d58:	b21b      	sxth	r3, r3
 8018d5a:	85bb      	strh	r3, [r7, #44]	; 0x2c
        point_rb.y = ofs_rb.y + line;
 8018d5c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8018d60:	b29a      	uxth	r2, r3
 8018d62:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8018d66:	4413      	add	r3, r2
 8018d68:	b29b      	uxth	r3, r3
 8018d6a:	b21b      	sxth	r3, r3
 8018d6c:	85fb      	strh	r3, [r7, #46]	; 0x2e

        point_lt.x = ofs_lt.x - curve_x[line] - 1;
 8018d6e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018d72:	b29a      	uxth	r2, r3
 8018d74:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018d78:	005b      	lsls	r3, r3, #1
 8018d7a:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8018d7c:	440b      	add	r3, r1
 8018d7e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018d82:	b29b      	uxth	r3, r3
 8018d84:	1ad3      	subs	r3, r2, r3
 8018d86:	b29b      	uxth	r3, r3
 8018d88:	3b01      	subs	r3, #1
 8018d8a:	b29b      	uxth	r3, r3
 8018d8c:	b21b      	sxth	r3, r3
 8018d8e:	853b      	strh	r3, [r7, #40]	; 0x28
        point_lt.y = ofs_lt.y - line;
 8018d90:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018d94:	b29a      	uxth	r2, r3
 8018d96:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8018d9a:	1ad3      	subs	r3, r2, r3
 8018d9c:	b29b      	uxth	r3, r3
 8018d9e:	b21b      	sxth	r3, r3
 8018da0:	857b      	strh	r3, [r7, #42]	; 0x2a

        point_lb.x = ofs_lb.x - curve_x[line] - 1;
 8018da2:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8018da6:	b29a      	uxth	r2, r3
 8018da8:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018dac:	005b      	lsls	r3, r3, #1
 8018dae:	6cb9      	ldr	r1, [r7, #72]	; 0x48
 8018db0:	440b      	add	r3, r1
 8018db2:	f9b3 3000 	ldrsh.w	r3, [r3]
 8018db6:	b29b      	uxth	r3, r3
 8018db8:	1ad3      	subs	r3, r2, r3
 8018dba:	b29b      	uxth	r3, r3
 8018dbc:	3b01      	subs	r3, #1
 8018dbe:	b29b      	uxth	r3, r3
 8018dc0:	b21b      	sxth	r3, r3
 8018dc2:	84bb      	strh	r3, [r7, #36]	; 0x24
        point_lb.y = ofs_lb.y + line;
 8018dc4:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018dc8:	b29a      	uxth	r2, r3
 8018dca:	f8b7 3076 	ldrh.w	r3, [r7, #118]	; 0x76
 8018dce:	4413      	add	r3, r2
 8018dd0:	b29b      	uxth	r3, r3
 8018dd2:	b21b      	sxth	r3, r3
 8018dd4:	84fb      	strh	r3, [r7, #38]	; 0x26

        uint16_t d;
        for(d = 1; d < col; d++) {
 8018dd6:	2301      	movs	r3, #1
 8018dd8:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
 8018ddc:	e08c      	b.n	8018ef8 <lv_draw_shadow_full+0x602>

            if(point_lt.x < ofs_lt.x && point_lt.y < ofs_lt.y) {
 8018dde:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
 8018de2:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8018de6:	429a      	cmp	r2, r3
 8018de8:	da14      	bge.n	8018e14 <lv_draw_shadow_full+0x51e>
 8018dea:	f9b7 202a 	ldrsh.w	r2, [r7, #42]	; 0x2a
 8018dee:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8018df2:	429a      	cmp	r2, r3
 8018df4:	da0e      	bge.n	8018e14 <lv_draw_shadow_full+0x51e>
                lv_draw_px(point_lt.x, point_lt.y, mask, style->body.shadow.color, line_2d_blur[d]);
 8018df6:	f9b7 0028 	ldrsh.w	r0, [r7, #40]	; 0x28
 8018dfa:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 8018dfe:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8018e02:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018e04:	4413      	add	r3, r2
 8018e06:	781a      	ldrb	r2, [r3, #0]
 8018e08:	687b      	ldr	r3, [r7, #4]
 8018e0a:	9200      	str	r2, [sp, #0]
 8018e0c:	8a1b      	ldrh	r3, [r3, #16]
 8018e0e:	68ba      	ldr	r2, [r7, #8]
 8018e10:	f7fb fa63 	bl	80142da <lv_draw_px>
            }

            if(point_lb.x < ofs_lb.x && point_lb.y > ofs_lb.y) {
 8018e14:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 8018e18:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8018e1c:	429a      	cmp	r2, r3
 8018e1e:	da14      	bge.n	8018e4a <lv_draw_shadow_full+0x554>
 8018e20:	f9b7 2026 	ldrsh.w	r2, [r7, #38]	; 0x26
 8018e24:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8018e28:	429a      	cmp	r2, r3
 8018e2a:	dd0e      	ble.n	8018e4a <lv_draw_shadow_full+0x554>
                lv_draw_px(point_lb.x, point_lb.y, mask, style->body.shadow.color, line_2d_blur[d]);
 8018e2c:	f9b7 0024 	ldrsh.w	r0, [r7, #36]	; 0x24
 8018e30:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 8018e34:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8018e38:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018e3a:	4413      	add	r3, r2
 8018e3c:	781a      	ldrb	r2, [r3, #0]
 8018e3e:	687b      	ldr	r3, [r7, #4]
 8018e40:	9200      	str	r2, [sp, #0]
 8018e42:	8a1b      	ldrh	r3, [r3, #16]
 8018e44:	68ba      	ldr	r2, [r7, #8]
 8018e46:	f7fb fa48 	bl	80142da <lv_draw_px>
            }

            if(point_rt.x > ofs_rt.x && point_rt.y < ofs_rt.y) {
 8018e4a:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 8018e4e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8018e52:	429a      	cmp	r2, r3
 8018e54:	dd14      	ble.n	8018e80 <lv_draw_shadow_full+0x58a>
 8018e56:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 8018e5a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8018e5e:	429a      	cmp	r2, r3
 8018e60:	da0e      	bge.n	8018e80 <lv_draw_shadow_full+0x58a>
                lv_draw_px(point_rt.x, point_rt.y, mask, style->body.shadow.color, line_2d_blur[d]);
 8018e62:	f9b7 0030 	ldrsh.w	r0, [r7, #48]	; 0x30
 8018e66:	f9b7 1032 	ldrsh.w	r1, [r7, #50]	; 0x32
 8018e6a:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8018e6e:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018e70:	4413      	add	r3, r2
 8018e72:	781a      	ldrb	r2, [r3, #0]
 8018e74:	687b      	ldr	r3, [r7, #4]
 8018e76:	9200      	str	r2, [sp, #0]
 8018e78:	8a1b      	ldrh	r3, [r3, #16]
 8018e7a:	68ba      	ldr	r2, [r7, #8]
 8018e7c:	f7fb fa2d 	bl	80142da <lv_draw_px>
            }

            if(point_rb.x > ofs_rb.x && point_rb.y > ofs_rb.y) {
 8018e80:	f9b7 202c 	ldrsh.w	r2, [r7, #44]	; 0x2c
 8018e84:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8018e88:	429a      	cmp	r2, r3
 8018e8a:	dd14      	ble.n	8018eb6 <lv_draw_shadow_full+0x5c0>
 8018e8c:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 8018e90:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8018e94:	429a      	cmp	r2, r3
 8018e96:	dd0e      	ble.n	8018eb6 <lv_draw_shadow_full+0x5c0>
                lv_draw_px(point_rb.x, point_rb.y, mask, style->body.shadow.color, line_2d_blur[d]);
 8018e98:	f9b7 002c 	ldrsh.w	r0, [r7, #44]	; 0x2c
 8018e9c:	f9b7 102e 	ldrsh.w	r1, [r7, #46]	; 0x2e
 8018ea0:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8018ea4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8018ea6:	4413      	add	r3, r2
 8018ea8:	781a      	ldrb	r2, [r3, #0]
 8018eaa:	687b      	ldr	r3, [r7, #4]
 8018eac:	9200      	str	r2, [sp, #0]
 8018eae:	8a1b      	ldrh	r3, [r3, #16]
 8018eb0:	68ba      	ldr	r2, [r7, #8]
 8018eb2:	f7fb fa12 	bl	80142da <lv_draw_px>
            }

            point_rb.x++;
 8018eb6:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8018eba:	b29b      	uxth	r3, r3
 8018ebc:	3301      	adds	r3, #1
 8018ebe:	b29b      	uxth	r3, r3
 8018ec0:	b21b      	sxth	r3, r3
 8018ec2:	85bb      	strh	r3, [r7, #44]	; 0x2c
            point_lb.x--;
 8018ec4:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8018ec8:	b29b      	uxth	r3, r3
 8018eca:	3b01      	subs	r3, #1
 8018ecc:	b29b      	uxth	r3, r3
 8018ece:	b21b      	sxth	r3, r3
 8018ed0:	84bb      	strh	r3, [r7, #36]	; 0x24

            point_rt.x++;
 8018ed2:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8018ed6:	b29b      	uxth	r3, r3
 8018ed8:	3301      	adds	r3, #1
 8018eda:	b29b      	uxth	r3, r3
 8018edc:	b21b      	sxth	r3, r3
 8018ede:	863b      	strh	r3, [r7, #48]	; 0x30
            point_lt.x--;
 8018ee0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8018ee4:	b29b      	uxth	r3, r3
 8018ee6:	3b01      	subs	r3, #1
 8018ee8:	b29b      	uxth	r3, r3
 8018eea:	b21b      	sxth	r3, r3
 8018eec:	853b      	strh	r3, [r7, #40]	; 0x28
        for(d = 1; d < col; d++) {
 8018eee:	f8b7 3068 	ldrh.w	r3, [r7, #104]	; 0x68
 8018ef2:	3301      	adds	r3, #1
 8018ef4:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
 8018ef8:	f8b7 2068 	ldrh.w	r2, [r7, #104]	; 0x68
 8018efc:	f8b7 3074 	ldrh.w	r3, [r7, #116]	; 0x74
 8018f00:	429a      	cmp	r2, r3
 8018f02:	f4ff af6c 	bcc.w	8018dde <lv_draw_shadow_full+0x4e8>
        }

        /* Put the first line to the edges too.
         * It is not correct because blur should be done below the corner too
         * but is is simple, fast and gives a good enough result*/
        if(line == 0) lv_draw_shadow_full_straight(coords, mask, style, line_2d_blur);
 8018f06:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018f0a:	2b00      	cmp	r3, #0
 8018f0c:	d105      	bne.n	8018f1a <lv_draw_shadow_full+0x624>
 8018f0e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8018f10:	687a      	ldr	r2, [r7, #4]
 8018f12:	68b9      	ldr	r1, [r7, #8]
 8018f14:	68f8      	ldr	r0, [r7, #12]
 8018f16:	f000 fa17 	bl	8019348 <lv_draw_shadow_full_straight>
    for(line = 0; line <= radius + swidth; line++) { /*Check all rows and make the 1D blur to 2D*/
 8018f1a:	f9b7 3076 	ldrsh.w	r3, [r7, #118]	; 0x76
 8018f1e:	b29b      	uxth	r3, r3
 8018f20:	3301      	adds	r3, #1
 8018f22:	b29b      	uxth	r3, r3
 8018f24:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
 8018f28:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8018f2c:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 8018f30:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8018f34:	440b      	add	r3, r1
 8018f36:	429a      	cmp	r2, r3
 8018f38:	f77f ae3b 	ble.w	8018bb2 <lv_draw_shadow_full+0x2bc>
    }
}
 8018f3c:	bf00      	nop
 8018f3e:	3778      	adds	r7, #120	; 0x78
 8018f40:	46bd      	mov	sp, r7
 8018f42:	bd80      	pop	{r7, pc}

08018f44 <lv_draw_shadow_bottom>:

static void lv_draw_shadow_bottom(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                  lv_opa_t opa_scale)
{
 8018f44:	b580      	push	{r7, lr}
 8018f46:	b09a      	sub	sp, #104	; 0x68
 8018f48:	af02      	add	r7, sp, #8
 8018f4a:	60f8      	str	r0, [r7, #12]
 8018f4c:	60b9      	str	r1, [r7, #8]
 8018f4e:	607a      	str	r2, [r7, #4]
 8018f50:	70fb      	strb	r3, [r7, #3]
    bool aa           = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8018f52:	f7f9 fda5 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 8018f56:	4603      	mov	r3, r0
 8018f58:	4618      	mov	r0, r3
 8018f5a:	f002 f907 	bl	801b16c <lv_disp_get_antialiasing>
 8018f5e:	4603      	mov	r3, r0
 8018f60:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    lv_coord_t radius = style->body.radius;
 8018f64:	687b      	ldr	r3, [r7, #4]
 8018f66:	88db      	ldrh	r3, [r3, #6]
 8018f68:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    lv_coord_t swidth = style->body.shadow.width;
 8018f6c:	687b      	ldr	r3, [r7, #4]
 8018f6e:	8a5b      	ldrh	r3, [r3, #18]
 8018f70:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
    lv_coord_t width  = lv_area_get_width(coords);
 8018f74:	68f8      	ldr	r0, [r7, #12]
 8018f76:	f7fc fc96 	bl	80158a6 <lv_area_get_width>
 8018f7a:	4603      	mov	r3, r0
 8018f7c:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
    lv_coord_t height = lv_area_get_height(coords);
 8018f80:	68f8      	ldr	r0, [r7, #12]
 8018f82:	f7fc fca7 	bl	80158d4 <lv_area_get_height>
 8018f86:	4603      	mov	r3, r0
 8018f88:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8018f8c:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8018f90:	f9b7 204e 	ldrsh.w	r2, [r7, #78]	; 0x4e
 8018f94:	f9b7 1050 	ldrsh.w	r1, [r7, #80]	; 0x50
 8018f98:	4618      	mov	r0, r3
 8018f9a:	f000 fb2c 	bl	80195f6 <lv_draw_cont_radius_corr>
 8018f9e:	4603      	mov	r3, r0
 8018fa0:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    radius += aa * SHADOW_BOTTOM_AA_EXTRA_RADIUS;
 8018fa4:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8018fa8:	b29b      	uxth	r3, r3
 8018faa:	461a      	mov	r2, r3
 8018fac:	0052      	lsls	r2, r2, #1
 8018fae:	4413      	add	r3, r2
 8018fb0:	b29a      	uxth	r2, r3
 8018fb2:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8018fb6:	4413      	add	r3, r2
 8018fb8:	b29b      	uxth	r3, r3
 8018fba:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
    swidth += aa;
 8018fbe:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8018fc2:	b29a      	uxth	r2, r3
 8018fc4:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8018fc8:	4413      	add	r3, r2
 8018fca:	b29b      	uxth	r3, r3
 8018fcc:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

    uint32_t curve_x_size = ((radius + 1) + 3) & ~0x3; /*Round to 4*/
 8018fd0:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 8018fd4:	3304      	adds	r3, #4
 8018fd6:	f023 0303 	bic.w	r3, r3, #3
 8018fda:	64bb      	str	r3, [r7, #72]	; 0x48
    curve_x_size *= sizeof(lv_coord_t);
 8018fdc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018fde:	005b      	lsls	r3, r3, #1
 8018fe0:	64bb      	str	r3, [r7, #72]	; 0x48
    lv_opa_t line_1d_blur_size = (swidth + 3) & ~0x3;     /*Round to 4*/
 8018fe2:	f8b7 3052 	ldrh.w	r3, [r7, #82]	; 0x52
 8018fe6:	b2db      	uxtb	r3, r3
 8018fe8:	3303      	adds	r3, #3
 8018fea:	b2db      	uxtb	r3, r3
 8018fec:	f023 0303 	bic.w	r3, r3, #3
 8018ff0:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    line_1d_blur_size *= sizeof(lv_opa_t);

    uint8_t * draw_buf = lv_draw_get_buf(curve_x_size + line_1d_blur_size);
 8018ff4:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 8018ff8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8018ffa:	4413      	add	r3, r2
 8018ffc:	4618      	mov	r0, r3
 8018ffe:	f7fb f831 	bl	8014064 <lv_draw_get_buf>
 8019002:	6438      	str	r0, [r7, #64]	; 0x40

    /*Divide the draw buffer*/
    lv_coord_t  * curve_x = (lv_coord_t *)&draw_buf[0]; /*Stores the 'x' coordinates of a quarter circle.*/
 8019004:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8019006:	63fb      	str	r3, [r7, #60]	; 0x3c
    lv_opa_t * line_1d_blur = (lv_opa_t *)&draw_buf[curve_x_size];
 8019008:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801900a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801900c:	4413      	add	r3, r2
 801900e:	63bb      	str	r3, [r7, #56]	; 0x38

    lv_point_t circ;
    lv_coord_t circ_tmp;
    lv_circ_init(&circ, &circ_tmp, radius);
 8019010:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 8019014:	f107 012e 	add.w	r1, r7, #46	; 0x2e
 8019018:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801901c:	4618      	mov	r0, r3
 801901e:	f002 fe76 	bl	801bd0e <lv_circ_init>
    while(lv_circ_cont(&circ)) {
 8019022:	e017      	b.n	8019054 <lv_draw_shadow_bottom+0x110>
        curve_x[LV_CIRC_OCT1_Y(circ)] = LV_CIRC_OCT1_X(circ);
 8019024:	f9b7 3032 	ldrsh.w	r3, [r7, #50]	; 0x32
 8019028:	005b      	lsls	r3, r3, #1
 801902a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801902c:	4413      	add	r3, r2
 801902e:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 8019032:	801a      	strh	r2, [r3, #0]
        curve_x[LV_CIRC_OCT2_Y(circ)] = LV_CIRC_OCT2_X(circ);
 8019034:	f9b7 3030 	ldrsh.w	r3, [r7, #48]	; 0x30
 8019038:	005b      	lsls	r3, r3, #1
 801903a:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 801903c:	4413      	add	r3, r2
 801903e:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 8019042:	801a      	strh	r2, [r3, #0]
        lv_circ_next(&circ, &circ_tmp);
 8019044:	f107 022e 	add.w	r2, r7, #46	; 0x2e
 8019048:	f107 0330 	add.w	r3, r7, #48	; 0x30
 801904c:	4611      	mov	r1, r2
 801904e:	4618      	mov	r0, r3
 8019050:	f002 fe8c 	bl	801bd6c <lv_circ_next>
    while(lv_circ_cont(&circ)) {
 8019054:	f107 0330 	add.w	r3, r7, #48	; 0x30
 8019058:	4618      	mov	r0, r3
 801905a:	f002 fe72 	bl	801bd42 <lv_circ_cont>
 801905e:	4603      	mov	r3, r0
 8019060:	2b00      	cmp	r3, #0
 8019062:	d1df      	bne.n	8019024 <lv_draw_shadow_bottom+0xe0>
    }

    int16_t col;

    lv_opa_t opa = opa_scale == LV_OPA_COVER ? style->body.opa : (uint16_t)((uint16_t)style->body.opa * opa_scale) >> 8;
 8019064:	78fb      	ldrb	r3, [r7, #3]
 8019066:	2bff      	cmp	r3, #255	; 0xff
 8019068:	d102      	bne.n	8019070 <lv_draw_shadow_bottom+0x12c>
 801906a:	687b      	ldr	r3, [r7, #4]
 801906c:	7a1b      	ldrb	r3, [r3, #8]
 801906e:	e00a      	b.n	8019086 <lv_draw_shadow_bottom+0x142>
 8019070:	687b      	ldr	r3, [r7, #4]
 8019072:	7a1b      	ldrb	r3, [r3, #8]
 8019074:	b29a      	uxth	r2, r3
 8019076:	78fb      	ldrb	r3, [r7, #3]
 8019078:	b29b      	uxth	r3, r3
 801907a:	fb12 f303 	smulbb	r3, r2, r3
 801907e:	b29b      	uxth	r3, r3
 8019080:	0a1b      	lsrs	r3, r3, #8
 8019082:	b29b      	uxth	r3, r3
 8019084:	b2db      	uxtb	r3, r3
 8019086:	f887 3037 	strb.w	r3, [r7, #55]	; 0x37
    for(col = 0; col < swidth; col++) {
 801908a:	2300      	movs	r3, #0
 801908c:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8019090:	e01b      	b.n	80190ca <lv_draw_shadow_bottom+0x186>
        line_1d_blur[col] = (uint32_t)((uint32_t)(swidth - col) * opa / 2) / (swidth);
 8019092:	f9b7 2052 	ldrsh.w	r2, [r7, #82]	; 0x52
 8019096:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801909a:	1ad3      	subs	r3, r2, r3
 801909c:	461a      	mov	r2, r3
 801909e:	f897 3037 	ldrb.w	r3, [r7, #55]	; 0x37
 80190a2:	fb03 f302 	mul.w	r3, r3, r2
 80190a6:	085a      	lsrs	r2, r3, #1
 80190a8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80190ac:	fbb2 f1f3 	udiv	r1, r2, r3
 80190b0:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80190b4:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80190b6:	4413      	add	r3, r2
 80190b8:	b2ca      	uxtb	r2, r1
 80190ba:	701a      	strb	r2, [r3, #0]
    for(col = 0; col < swidth; col++) {
 80190bc:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80190c0:	b29b      	uxth	r3, r3
 80190c2:	3301      	adds	r3, #1
 80190c4:	b29b      	uxth	r3, r3
 80190c6:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80190ca:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80190ce:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 80190d2:	429a      	cmp	r2, r3
 80190d4:	dbdd      	blt.n	8019092 <lv_draw_shadow_bottom+0x14e>
    lv_point_t point_r;
    lv_area_t area_mid;
    lv_point_t ofs_l;
    lv_point_t ofs_r;

    ofs_l.x = coords->x1 + radius;
 80190d6:	68fb      	ldr	r3, [r7, #12]
 80190d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80190dc:	b29a      	uxth	r2, r3
 80190de:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80190e2:	4413      	add	r3, r2
 80190e4:	b29b      	uxth	r3, r3
 80190e6:	b21b      	sxth	r3, r3
 80190e8:	833b      	strh	r3, [r7, #24]
    ofs_l.y = coords->y2 - radius + 1 - aa;
 80190ea:	68fb      	ldr	r3, [r7, #12]
 80190ec:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80190f0:	b29a      	uxth	r2, r3
 80190f2:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80190f6:	1ad3      	subs	r3, r2, r3
 80190f8:	b29a      	uxth	r2, r3
 80190fa:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 80190fe:	b29b      	uxth	r3, r3
 8019100:	1ad3      	subs	r3, r2, r3
 8019102:	b29b      	uxth	r3, r3
 8019104:	3301      	adds	r3, #1
 8019106:	b29b      	uxth	r3, r3
 8019108:	b21b      	sxth	r3, r3
 801910a:	837b      	strh	r3, [r7, #26]

    ofs_r.x = coords->x2 - radius;
 801910c:	68fb      	ldr	r3, [r7, #12]
 801910e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8019112:	b29a      	uxth	r2, r3
 8019114:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 8019118:	1ad3      	subs	r3, r2, r3
 801911a:	b29b      	uxth	r3, r3
 801911c:	b21b      	sxth	r3, r3
 801911e:	82bb      	strh	r3, [r7, #20]
    ofs_r.y = coords->y2 - radius + 1 - aa;
 8019120:	68fb      	ldr	r3, [r7, #12]
 8019122:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019126:	b29a      	uxth	r2, r3
 8019128:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 801912c:	1ad3      	subs	r3, r2, r3
 801912e:	b29a      	uxth	r2, r3
 8019130:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 8019134:	b29b      	uxth	r3, r3
 8019136:	1ad3      	subs	r3, r2, r3
 8019138:	b29b      	uxth	r3, r3
 801913a:	3301      	adds	r3, #1
 801913c:	b29b      	uxth	r3, r3
 801913e:	b21b      	sxth	r3, r3
 8019140:	82fb      	strh	r3, [r7, #22]

    for(col = 0; col <= radius; col++) {
 8019142:	2300      	movs	r3, #0
 8019144:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 8019148:	e0b0      	b.n	80192ac <lv_draw_shadow_bottom+0x368>
        point_l.x = ofs_l.x - col;
 801914a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801914e:	b29a      	uxth	r2, r3
 8019150:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8019154:	1ad3      	subs	r3, r2, r3
 8019156:	b29b      	uxth	r3, r3
 8019158:	b21b      	sxth	r3, r3
 801915a:	853b      	strh	r3, [r7, #40]	; 0x28
        point_l.y = ofs_l.y + curve_x[col];
 801915c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8019160:	b29a      	uxth	r2, r3
 8019162:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8019166:	005b      	lsls	r3, r3, #1
 8019168:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801916a:	440b      	add	r3, r1
 801916c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019170:	b29b      	uxth	r3, r3
 8019172:	4413      	add	r3, r2
 8019174:	b29b      	uxth	r3, r3
 8019176:	b21b      	sxth	r3, r3
 8019178:	857b      	strh	r3, [r7, #42]	; 0x2a

        point_r.x = ofs_r.x + col;
 801917a:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801917e:	b29a      	uxth	r2, r3
 8019180:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 8019184:	4413      	add	r3, r2
 8019186:	b29b      	uxth	r3, r3
 8019188:	b21b      	sxth	r3, r3
 801918a:	84bb      	strh	r3, [r7, #36]	; 0x24
        point_r.y = ofs_r.y + curve_x[col];
 801918c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8019190:	b29a      	uxth	r2, r3
 8019192:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8019196:	005b      	lsls	r3, r3, #1
 8019198:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801919a:	440b      	add	r3, r1
 801919c:	f9b3 3000 	ldrsh.w	r3, [r3]
 80191a0:	b29b      	uxth	r3, r3
 80191a2:	4413      	add	r3, r2
 80191a4:	b29b      	uxth	r3, r3
 80191a6:	b21b      	sxth	r3, r3
 80191a8:	84fb      	strh	r3, [r7, #38]	; 0x26

        lv_opa_t px_opa;
        int16_t diff = col == 0 ? 0 : curve_x[col - 1] - curve_x[col];
 80191aa:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80191ae:	2b00      	cmp	r3, #0
 80191b0:	d016      	beq.n	80191e0 <lv_draw_shadow_bottom+0x29c>
 80191b2:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80191b6:	f06f 4300 	mvn.w	r3, #2147483648	; 0x80000000
 80191ba:	4413      	add	r3, r2
 80191bc:	005b      	lsls	r3, r3, #1
 80191be:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80191c0:	4413      	add	r3, r2
 80191c2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80191c6:	b29a      	uxth	r2, r3
 80191c8:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80191cc:	005b      	lsls	r3, r3, #1
 80191ce:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 80191d0:	440b      	add	r3, r1
 80191d2:	f9b3 3000 	ldrsh.w	r3, [r3]
 80191d6:	b29b      	uxth	r3, r3
 80191d8:	1ad3      	subs	r3, r2, r3
 80191da:	b29b      	uxth	r3, r3
 80191dc:	b21b      	sxth	r3, r3
 80191de:	e000      	b.n	80191e2 <lv_draw_shadow_bottom+0x29e>
 80191e0:	2300      	movs	r3, #0
 80191e2:	86bb      	strh	r3, [r7, #52]	; 0x34
        uint16_t d;
        for(d = 0; d < swidth; d++) {
 80191e4:	2300      	movs	r3, #0
 80191e6:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 80191ea:	e052      	b.n	8019292 <lv_draw_shadow_bottom+0x34e>
            /*When stepping a pixel in y calculate the average with the pixel from the prev. column
             * to make a blur */
            if(diff == 0) {
 80191ec:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 80191f0:	2b00      	cmp	r3, #0
 80191f2:	d107      	bne.n	8019204 <lv_draw_shadow_bottom+0x2c0>
                px_opa = line_1d_blur[d];
 80191f4:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 80191f8:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80191fa:	4413      	add	r3, r2
 80191fc:	781b      	ldrb	r3, [r3, #0]
 80191fe:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
 8019202:	e015      	b.n	8019230 <lv_draw_shadow_bottom+0x2ec>
            } else {
                px_opa = (uint16_t)((uint16_t)line_1d_blur[d] + line_1d_blur[d - diff]) >> 1;
 8019204:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 8019208:	6bba      	ldr	r2, [r7, #56]	; 0x38
 801920a:	4413      	add	r3, r2
 801920c:	781b      	ldrb	r3, [r3, #0]
 801920e:	b29a      	uxth	r2, r3
 8019210:	f8b7 105a 	ldrh.w	r1, [r7, #90]	; 0x5a
 8019214:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8019218:	1acb      	subs	r3, r1, r3
 801921a:	4619      	mov	r1, r3
 801921c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801921e:	440b      	add	r3, r1
 8019220:	781b      	ldrb	r3, [r3, #0]
 8019222:	b29b      	uxth	r3, r3
 8019224:	4413      	add	r3, r2
 8019226:	b29b      	uxth	r3, r3
 8019228:	085b      	lsrs	r3, r3, #1
 801922a:	b29b      	uxth	r3, r3
 801922c:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
            }
            lv_draw_px(point_l.x, point_l.y, mask, style->body.shadow.color, px_opa);
 8019230:	f9b7 0028 	ldrsh.w	r0, [r7, #40]	; 0x28
 8019234:	f9b7 102a 	ldrsh.w	r1, [r7, #42]	; 0x2a
 8019238:	687b      	ldr	r3, [r7, #4]
 801923a:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 801923e:	9200      	str	r2, [sp, #0]
 8019240:	8a1b      	ldrh	r3, [r3, #16]
 8019242:	68ba      	ldr	r2, [r7, #8]
 8019244:	f7fb f849 	bl	80142da <lv_draw_px>
            point_l.y++;
 8019248:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801924c:	b29b      	uxth	r3, r3
 801924e:	3301      	adds	r3, #1
 8019250:	b29b      	uxth	r3, r3
 8019252:	b21b      	sxth	r3, r3
 8019254:	857b      	strh	r3, [r7, #42]	; 0x2a

            /*Don't overdraw the pixel on the middle*/
            if(point_r.x > ofs_l.x) {
 8019256:	f9b7 2024 	ldrsh.w	r2, [r7, #36]	; 0x24
 801925a:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 801925e:	429a      	cmp	r2, r3
 8019260:	dd0b      	ble.n	801927a <lv_draw_shadow_bottom+0x336>
                lv_draw_px(point_r.x, point_r.y, mask, style->body.shadow.color, px_opa);
 8019262:	f9b7 0024 	ldrsh.w	r0, [r7, #36]	; 0x24
 8019266:	f9b7 1026 	ldrsh.w	r1, [r7, #38]	; 0x26
 801926a:	687b      	ldr	r3, [r7, #4]
 801926c:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 8019270:	9200      	str	r2, [sp, #0]
 8019272:	8a1b      	ldrh	r3, [r3, #16]
 8019274:	68ba      	ldr	r2, [r7, #8]
 8019276:	f7fb f830 	bl	80142da <lv_draw_px>
            }
            point_r.y++;
 801927a:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801927e:	b29b      	uxth	r3, r3
 8019280:	3301      	adds	r3, #1
 8019282:	b29b      	uxth	r3, r3
 8019284:	b21b      	sxth	r3, r3
 8019286:	84fb      	strh	r3, [r7, #38]	; 0x26
        for(d = 0; d < swidth; d++) {
 8019288:	f8b7 305a 	ldrh.w	r3, [r7, #90]	; 0x5a
 801928c:	3301      	adds	r3, #1
 801928e:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 8019292:	f8b7 205a 	ldrh.w	r2, [r7, #90]	; 0x5a
 8019296:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801929a:	429a      	cmp	r2, r3
 801929c:	dba6      	blt.n	80191ec <lv_draw_shadow_bottom+0x2a8>
    for(col = 0; col <= radius; col++) {
 801929e:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 80192a2:	b29b      	uxth	r3, r3
 80192a4:	3301      	adds	r3, #1
 80192a6:	b29b      	uxth	r3, r3
 80192a8:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
 80192ac:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80192b0:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80192b4:	429a      	cmp	r2, r3
 80192b6:	f77f af48 	ble.w	801914a <lv_draw_shadow_bottom+0x206>
        }
    }

    area_mid.x1 = ofs_l.x + 1;
 80192ba:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80192be:	b29b      	uxth	r3, r3
 80192c0:	3301      	adds	r3, #1
 80192c2:	b29b      	uxth	r3, r3
 80192c4:	b21b      	sxth	r3, r3
 80192c6:	83bb      	strh	r3, [r7, #28]
    area_mid.y1 = ofs_l.y + radius;
 80192c8:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80192cc:	b29a      	uxth	r2, r3
 80192ce:	f8b7 3054 	ldrh.w	r3, [r7, #84]	; 0x54
 80192d2:	4413      	add	r3, r2
 80192d4:	b29b      	uxth	r3, r3
 80192d6:	b21b      	sxth	r3, r3
 80192d8:	83fb      	strh	r3, [r7, #30]
    area_mid.x2 = ofs_r.x - 1;
 80192da:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80192de:	b29b      	uxth	r3, r3
 80192e0:	3b01      	subs	r3, #1
 80192e2:	b29b      	uxth	r3, r3
 80192e4:	b21b      	sxth	r3, r3
 80192e6:	843b      	strh	r3, [r7, #32]
    area_mid.y2 = area_mid.y1;
 80192e8:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80192ec:	847b      	strh	r3, [r7, #34]	; 0x22

    uint16_t d;
    for(d = 0; d < swidth; d++) {
 80192ee:	2300      	movs	r3, #0
 80192f0:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 80192f4:	e01e      	b.n	8019334 <lv_draw_shadow_bottom+0x3f0>
        lv_draw_fill(&area_mid, mask, style->body.shadow.color, line_1d_blur[d]);
 80192f6:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 80192fa:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80192fc:	4413      	add	r3, r2
 80192fe:	781b      	ldrb	r3, [r3, #0]
 8019300:	687a      	ldr	r2, [r7, #4]
 8019302:	f107 001c 	add.w	r0, r7, #28
 8019306:	8a12      	ldrh	r2, [r2, #16]
 8019308:	68b9      	ldr	r1, [r7, #8]
 801930a:	f7fb f87f 	bl	801440c <lv_draw_fill>
        area_mid.y1++;
 801930e:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8019312:	b29b      	uxth	r3, r3
 8019314:	3301      	adds	r3, #1
 8019316:	b29b      	uxth	r3, r3
 8019318:	b21b      	sxth	r3, r3
 801931a:	83fb      	strh	r3, [r7, #30]
        area_mid.y2++;
 801931c:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8019320:	b29b      	uxth	r3, r3
 8019322:	3301      	adds	r3, #1
 8019324:	b29b      	uxth	r3, r3
 8019326:	b21b      	sxth	r3, r3
 8019328:	847b      	strh	r3, [r7, #34]	; 0x22
    for(d = 0; d < swidth; d++) {
 801932a:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 801932e:	3301      	adds	r3, #1
 8019330:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
 8019334:	f8b7 2058 	ldrh.w	r2, [r7, #88]	; 0x58
 8019338:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801933c:	429a      	cmp	r2, r3
 801933e:	dbda      	blt.n	80192f6 <lv_draw_shadow_bottom+0x3b2>
    }
}
 8019340:	bf00      	nop
 8019342:	3760      	adds	r7, #96	; 0x60
 8019344:	46bd      	mov	sp, r7
 8019346:	bd80      	pop	{r7, pc}

08019348 <lv_draw_shadow_full_straight>:

static void lv_draw_shadow_full_straight(const lv_area_t * coords, const lv_area_t * mask, const lv_style_t * style,
                                         const lv_opa_t * map)
{
 8019348:	b580      	push	{r7, lr}
 801934a:	b090      	sub	sp, #64	; 0x40
 801934c:	af00      	add	r7, sp, #0
 801934e:	60f8      	str	r0, [r7, #12]
 8019350:	60b9      	str	r1, [r7, #8]
 8019352:	607a      	str	r2, [r7, #4]
 8019354:	603b      	str	r3, [r7, #0]
    bool aa           = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8019356:	f7f9 fba3 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 801935a:	4603      	mov	r3, r0
 801935c:	4618      	mov	r0, r3
 801935e:	f001 ff05 	bl	801b16c <lv_disp_get_antialiasing>
 8019362:	4603      	mov	r3, r0
 8019364:	f887 303d 	strb.w	r3, [r7, #61]	; 0x3d
    lv_coord_t radius = style->body.radius;
 8019368:	687b      	ldr	r3, [r7, #4]
 801936a:	88db      	ldrh	r3, [r3, #6]
 801936c:	877b      	strh	r3, [r7, #58]	; 0x3a
    lv_coord_t swidth = style->body.shadow.width;
 801936e:	687b      	ldr	r3, [r7, #4]
 8019370:	8a5b      	ldrh	r3, [r3, #18]
 8019372:	873b      	strh	r3, [r7, #56]	; 0x38
    lv_coord_t width  = lv_area_get_width(coords);
 8019374:	68f8      	ldr	r0, [r7, #12]
 8019376:	f7fc fa96 	bl	80158a6 <lv_area_get_width>
 801937a:	4603      	mov	r3, r0
 801937c:	86fb      	strh	r3, [r7, #54]	; 0x36
    lv_coord_t height = lv_area_get_height(coords);
 801937e:	68f8      	ldr	r0, [r7, #12]
 8019380:	f7fc faa8 	bl	80158d4 <lv_area_get_height>
 8019384:	4603      	mov	r3, r0
 8019386:	86bb      	strh	r3, [r7, #52]	; 0x34

    radius = lv_draw_cont_radius_corr(radius, width, height);
 8019388:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801938a:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 801938e:	f9b7 1036 	ldrsh.w	r1, [r7, #54]	; 0x36
 8019392:	4618      	mov	r0, r3
 8019394:	f000 f92f 	bl	80195f6 <lv_draw_cont_radius_corr>
 8019398:	4603      	mov	r3, r0
 801939a:	877b      	strh	r3, [r7, #58]	; 0x3a
    radius += aa;
 801939c:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80193a0:	b29a      	uxth	r2, r3
 80193a2:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80193a4:	4413      	add	r3, r2
 80193a6:	b29b      	uxth	r3, r3
 80193a8:	877b      	strh	r3, [r7, #58]	; 0x3a

    lv_area_t right_area;
    right_area.x1 = coords->x2 + 1 - aa;
 80193aa:	68fb      	ldr	r3, [r7, #12]
 80193ac:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80193b0:	b29a      	uxth	r2, r3
 80193b2:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80193b6:	b29b      	uxth	r3, r3
 80193b8:	1ad3      	subs	r3, r2, r3
 80193ba:	b29b      	uxth	r3, r3
 80193bc:	3301      	adds	r3, #1
 80193be:	b29b      	uxth	r3, r3
 80193c0:	b21b      	sxth	r3, r3
 80193c2:	853b      	strh	r3, [r7, #40]	; 0x28
    right_area.y1 = coords->y1 + radius + aa;
 80193c4:	68fb      	ldr	r3, [r7, #12]
 80193c6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80193ca:	b29a      	uxth	r2, r3
 80193cc:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80193ce:	4413      	add	r3, r2
 80193d0:	b29a      	uxth	r2, r3
 80193d2:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80193d6:	b29b      	uxth	r3, r3
 80193d8:	4413      	add	r3, r2
 80193da:	b29b      	uxth	r3, r3
 80193dc:	b21b      	sxth	r3, r3
 80193de:	857b      	strh	r3, [r7, #42]	; 0x2a
    right_area.x2 = right_area.x1;
 80193e0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 80193e4:	85bb      	strh	r3, [r7, #44]	; 0x2c
    right_area.y2 = coords->y2 - radius - aa;
 80193e6:	68fb      	ldr	r3, [r7, #12]
 80193e8:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80193ec:	b29a      	uxth	r2, r3
 80193ee:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80193f0:	1ad3      	subs	r3, r2, r3
 80193f2:	b29a      	uxth	r2, r3
 80193f4:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80193f8:	b29b      	uxth	r3, r3
 80193fa:	1ad3      	subs	r3, r2, r3
 80193fc:	b29b      	uxth	r3, r3
 80193fe:	b21b      	sxth	r3, r3
 8019400:	85fb      	strh	r3, [r7, #46]	; 0x2e

    lv_area_t left_area;
    left_area.x1 = coords->x1 - 1 + aa;
 8019402:	68fb      	ldr	r3, [r7, #12]
 8019404:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019408:	b29a      	uxth	r2, r3
 801940a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801940e:	b29b      	uxth	r3, r3
 8019410:	4413      	add	r3, r2
 8019412:	b29b      	uxth	r3, r3
 8019414:	3b01      	subs	r3, #1
 8019416:	b29b      	uxth	r3, r3
 8019418:	b21b      	sxth	r3, r3
 801941a:	843b      	strh	r3, [r7, #32]
    left_area.y1 = coords->y1 + radius + aa;
 801941c:	68fb      	ldr	r3, [r7, #12]
 801941e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8019422:	b29a      	uxth	r2, r3
 8019424:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8019426:	4413      	add	r3, r2
 8019428:	b29a      	uxth	r2, r3
 801942a:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801942e:	b29b      	uxth	r3, r3
 8019430:	4413      	add	r3, r2
 8019432:	b29b      	uxth	r3, r3
 8019434:	b21b      	sxth	r3, r3
 8019436:	847b      	strh	r3, [r7, #34]	; 0x22
    left_area.x2 = left_area.x1;
 8019438:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801943c:	84bb      	strh	r3, [r7, #36]	; 0x24
    left_area.y2 = coords->y2 - radius - aa;
 801943e:	68fb      	ldr	r3, [r7, #12]
 8019440:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8019444:	b29a      	uxth	r2, r3
 8019446:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8019448:	1ad3      	subs	r3, r2, r3
 801944a:	b29a      	uxth	r2, r3
 801944c:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 8019450:	b29b      	uxth	r3, r3
 8019452:	1ad3      	subs	r3, r2, r3
 8019454:	b29b      	uxth	r3, r3
 8019456:	b21b      	sxth	r3, r3
 8019458:	84fb      	strh	r3, [r7, #38]	; 0x26

    lv_area_t top_area;
    top_area.x1 = coords->x1 + radius + aa;
 801945a:	68fb      	ldr	r3, [r7, #12]
 801945c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8019460:	b29a      	uxth	r2, r3
 8019462:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 8019464:	4413      	add	r3, r2
 8019466:	b29a      	uxth	r2, r3
 8019468:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 801946c:	b29b      	uxth	r3, r3
 801946e:	4413      	add	r3, r2
 8019470:	b29b      	uxth	r3, r3
 8019472:	b21b      	sxth	r3, r3
 8019474:	833b      	strh	r3, [r7, #24]
    top_area.y1 = coords->y1 - 1 + aa;
 8019476:	68fb      	ldr	r3, [r7, #12]
 8019478:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801947c:	b29a      	uxth	r2, r3
 801947e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 8019482:	b29b      	uxth	r3, r3
 8019484:	4413      	add	r3, r2
 8019486:	b29b      	uxth	r3, r3
 8019488:	3b01      	subs	r3, #1
 801948a:	b29b      	uxth	r3, r3
 801948c:	b21b      	sxth	r3, r3
 801948e:	837b      	strh	r3, [r7, #26]
    top_area.x2 = coords->x2 - radius - aa;
 8019490:	68fb      	ldr	r3, [r7, #12]
 8019492:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8019496:	b29a      	uxth	r2, r3
 8019498:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 801949a:	1ad3      	subs	r3, r2, r3
 801949c:	b29a      	uxth	r2, r3
 801949e:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80194a2:	b29b      	uxth	r3, r3
 80194a4:	1ad3      	subs	r3, r2, r3
 80194a6:	b29b      	uxth	r3, r3
 80194a8:	b21b      	sxth	r3, r3
 80194aa:	83bb      	strh	r3, [r7, #28]
    top_area.y2 = top_area.y1;
 80194ac:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80194b0:	83fb      	strh	r3, [r7, #30]

    lv_area_t bottom_area;
    bottom_area.x1 = coords->x1 + radius + aa;
 80194b2:	68fb      	ldr	r3, [r7, #12]
 80194b4:	f9b3 3000 	ldrsh.w	r3, [r3]
 80194b8:	b29a      	uxth	r2, r3
 80194ba:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80194bc:	4413      	add	r3, r2
 80194be:	b29a      	uxth	r2, r3
 80194c0:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80194c4:	b29b      	uxth	r3, r3
 80194c6:	4413      	add	r3, r2
 80194c8:	b29b      	uxth	r3, r3
 80194ca:	b21b      	sxth	r3, r3
 80194cc:	823b      	strh	r3, [r7, #16]
    bottom_area.y1 = coords->y2 + 1 - aa;
 80194ce:	68fb      	ldr	r3, [r7, #12]
 80194d0:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 80194d4:	b29a      	uxth	r2, r3
 80194d6:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80194da:	b29b      	uxth	r3, r3
 80194dc:	1ad3      	subs	r3, r2, r3
 80194de:	b29b      	uxth	r3, r3
 80194e0:	3301      	adds	r3, #1
 80194e2:	b29b      	uxth	r3, r3
 80194e4:	b21b      	sxth	r3, r3
 80194e6:	827b      	strh	r3, [r7, #18]
    bottom_area.x2 = coords->x2 - radius - aa;
 80194e8:	68fb      	ldr	r3, [r7, #12]
 80194ea:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80194ee:	b29a      	uxth	r2, r3
 80194f0:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80194f2:	1ad3      	subs	r3, r2, r3
 80194f4:	b29a      	uxth	r2, r3
 80194f6:	f897 303d 	ldrb.w	r3, [r7, #61]	; 0x3d
 80194fa:	b29b      	uxth	r3, r3
 80194fc:	1ad3      	subs	r3, r2, r3
 80194fe:	b29b      	uxth	r3, r3
 8019500:	b21b      	sxth	r3, r3
 8019502:	82bb      	strh	r3, [r7, #20]
    bottom_area.y2 = bottom_area.y1;
 8019504:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8019508:	82fb      	strh	r3, [r7, #22]

    lv_opa_t opa_act;
    int16_t d;
    for(d = 1 /*+ LV_ANTIALIAS*/; d <= swidth /* - LV_ANTIALIAS*/; d++) {
 801950a:	2301      	movs	r3, #1
 801950c:	87fb      	strh	r3, [r7, #62]	; 0x3e
 801950e:	e068      	b.n	80195e2 <lv_draw_shadow_full_straight+0x29a>
        opa_act = map[d];
 8019510:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 8019514:	683a      	ldr	r2, [r7, #0]
 8019516:	4413      	add	r3, r2
 8019518:	781b      	ldrb	r3, [r3, #0]
 801951a:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

        lv_draw_fill(&right_area, mask, style->body.shadow.color, opa_act);
 801951e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8019522:	687a      	ldr	r2, [r7, #4]
 8019524:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8019528:	8a12      	ldrh	r2, [r2, #16]
 801952a:	68b9      	ldr	r1, [r7, #8]
 801952c:	f7fa ff6e 	bl	801440c <lv_draw_fill>
        right_area.x1++;
 8019530:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8019534:	b29b      	uxth	r3, r3
 8019536:	3301      	adds	r3, #1
 8019538:	b29b      	uxth	r3, r3
 801953a:	b21b      	sxth	r3, r3
 801953c:	853b      	strh	r3, [r7, #40]	; 0x28
        right_area.x2++;
 801953e:	f9b7 302c 	ldrsh.w	r3, [r7, #44]	; 0x2c
 8019542:	b29b      	uxth	r3, r3
 8019544:	3301      	adds	r3, #1
 8019546:	b29b      	uxth	r3, r3
 8019548:	b21b      	sxth	r3, r3
 801954a:	85bb      	strh	r3, [r7, #44]	; 0x2c

        lv_draw_fill(&left_area, mask, style->body.shadow.color, opa_act);
 801954c:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8019550:	687a      	ldr	r2, [r7, #4]
 8019552:	f107 0020 	add.w	r0, r7, #32
 8019556:	8a12      	ldrh	r2, [r2, #16]
 8019558:	68b9      	ldr	r1, [r7, #8]
 801955a:	f7fa ff57 	bl	801440c <lv_draw_fill>
        left_area.x1--;
 801955e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8019562:	b29b      	uxth	r3, r3
 8019564:	3b01      	subs	r3, #1
 8019566:	b29b      	uxth	r3, r3
 8019568:	b21b      	sxth	r3, r3
 801956a:	843b      	strh	r3, [r7, #32]
        left_area.x2--;
 801956c:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8019570:	b29b      	uxth	r3, r3
 8019572:	3b01      	subs	r3, #1
 8019574:	b29b      	uxth	r3, r3
 8019576:	b21b      	sxth	r3, r3
 8019578:	84bb      	strh	r3, [r7, #36]	; 0x24

        lv_draw_fill(&top_area, mask, style->body.shadow.color, opa_act);
 801957a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801957e:	687a      	ldr	r2, [r7, #4]
 8019580:	f107 0018 	add.w	r0, r7, #24
 8019584:	8a12      	ldrh	r2, [r2, #16]
 8019586:	68b9      	ldr	r1, [r7, #8]
 8019588:	f7fa ff40 	bl	801440c <lv_draw_fill>
        top_area.y1--;
 801958c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8019590:	b29b      	uxth	r3, r3
 8019592:	3b01      	subs	r3, #1
 8019594:	b29b      	uxth	r3, r3
 8019596:	b21b      	sxth	r3, r3
 8019598:	837b      	strh	r3, [r7, #26]
        top_area.y2--;
 801959a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 801959e:	b29b      	uxth	r3, r3
 80195a0:	3b01      	subs	r3, #1
 80195a2:	b29b      	uxth	r3, r3
 80195a4:	b21b      	sxth	r3, r3
 80195a6:	83fb      	strh	r3, [r7, #30]

        lv_draw_fill(&bottom_area, mask, style->body.shadow.color, opa_act);
 80195a8:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 80195ac:	687a      	ldr	r2, [r7, #4]
 80195ae:	f107 0010 	add.w	r0, r7, #16
 80195b2:	8a12      	ldrh	r2, [r2, #16]
 80195b4:	68b9      	ldr	r1, [r7, #8]
 80195b6:	f7fa ff29 	bl	801440c <lv_draw_fill>
        bottom_area.y1++;
 80195ba:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80195be:	b29b      	uxth	r3, r3
 80195c0:	3301      	adds	r3, #1
 80195c2:	b29b      	uxth	r3, r3
 80195c4:	b21b      	sxth	r3, r3
 80195c6:	827b      	strh	r3, [r7, #18]
        bottom_area.y2++;
 80195c8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80195cc:	b29b      	uxth	r3, r3
 80195ce:	3301      	adds	r3, #1
 80195d0:	b29b      	uxth	r3, r3
 80195d2:	b21b      	sxth	r3, r3
 80195d4:	82fb      	strh	r3, [r7, #22]
    for(d = 1 /*+ LV_ANTIALIAS*/; d <= swidth /* - LV_ANTIALIAS*/; d++) {
 80195d6:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 80195da:	b29b      	uxth	r3, r3
 80195dc:	3301      	adds	r3, #1
 80195de:	b29b      	uxth	r3, r3
 80195e0:	87fb      	strh	r3, [r7, #62]	; 0x3e
 80195e2:	f9b7 203e 	ldrsh.w	r2, [r7, #62]	; 0x3e
 80195e6:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80195ea:	429a      	cmp	r2, r3
 80195ec:	dd90      	ble.n	8019510 <lv_draw_shadow_full_straight+0x1c8>
    }
}
 80195ee:	bf00      	nop
 80195f0:	3740      	adds	r7, #64	; 0x40
 80195f2:	46bd      	mov	sp, r7
 80195f4:	bd80      	pop	{r7, pc}

080195f6 <lv_draw_cont_radius_corr>:

#endif

static uint16_t lv_draw_cont_radius_corr(uint16_t r, lv_coord_t w, lv_coord_t h)
{
 80195f6:	b580      	push	{r7, lr}
 80195f8:	b084      	sub	sp, #16
 80195fa:	af00      	add	r7, sp, #0
 80195fc:	4603      	mov	r3, r0
 80195fe:	80fb      	strh	r3, [r7, #6]
 8019600:	460b      	mov	r3, r1
 8019602:	80bb      	strh	r3, [r7, #4]
 8019604:	4613      	mov	r3, r2
 8019606:	807b      	strh	r3, [r7, #2]
    bool aa = lv_disp_get_antialiasing(lv_refr_get_disp_refreshing());
 8019608:	f7f9 fa4a 	bl	8012aa0 <lv_refr_get_disp_refreshing>
 801960c:	4603      	mov	r3, r0
 801960e:	4618      	mov	r0, r3
 8019610:	f001 fdac 	bl	801b16c <lv_disp_get_antialiasing>
 8019614:	4603      	mov	r3, r0
 8019616:	73fb      	strb	r3, [r7, #15]

    if(r >= (w >> 1)) {
 8019618:	88fb      	ldrh	r3, [r7, #6]
 801961a:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801961e:	1052      	asrs	r2, r2, #1
 8019620:	b212      	sxth	r2, r2
 8019622:	4293      	cmp	r3, r2
 8019624:	db0a      	blt.n	801963c <lv_draw_cont_radius_corr+0x46>
        r = (w >> 1);
 8019626:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801962a:	105b      	asrs	r3, r3, #1
 801962c:	b21b      	sxth	r3, r3
 801962e:	80fb      	strh	r3, [r7, #6]
        if(r != 0) r--;
 8019630:	88fb      	ldrh	r3, [r7, #6]
 8019632:	2b00      	cmp	r3, #0
 8019634:	d002      	beq.n	801963c <lv_draw_cont_radius_corr+0x46>
 8019636:	88fb      	ldrh	r3, [r7, #6]
 8019638:	3b01      	subs	r3, #1
 801963a:	80fb      	strh	r3, [r7, #6]
    }
    if(r >= (h >> 1)) {
 801963c:	88fb      	ldrh	r3, [r7, #6]
 801963e:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 8019642:	1052      	asrs	r2, r2, #1
 8019644:	b212      	sxth	r2, r2
 8019646:	4293      	cmp	r3, r2
 8019648:	db0a      	blt.n	8019660 <lv_draw_cont_radius_corr+0x6a>
        r = (h >> 1);
 801964a:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801964e:	105b      	asrs	r3, r3, #1
 8019650:	b21b      	sxth	r3, r3
 8019652:	80fb      	strh	r3, [r7, #6]
        if(r != 0) r--;
 8019654:	88fb      	ldrh	r3, [r7, #6]
 8019656:	2b00      	cmp	r3, #0
 8019658:	d002      	beq.n	8019660 <lv_draw_cont_radius_corr+0x6a>
 801965a:	88fb      	ldrh	r3, [r7, #6]
 801965c:	3b01      	subs	r3, #1
 801965e:	80fb      	strh	r3, [r7, #6]
    }

    if(r > 0) r -= aa;
 8019660:	88fb      	ldrh	r3, [r7, #6]
 8019662:	2b00      	cmp	r3, #0
 8019664:	d004      	beq.n	8019670 <lv_draw_cont_radius_corr+0x7a>
 8019666:	7bfb      	ldrb	r3, [r7, #15]
 8019668:	b29b      	uxth	r3, r3
 801966a:	88fa      	ldrh	r2, [r7, #6]
 801966c:	1ad3      	subs	r3, r2, r3
 801966e:	80fb      	strh	r3, [r7, #6]

    return r;
 8019670:	88fb      	ldrh	r3, [r7, #6]
}
 8019672:	4618      	mov	r0, r3
 8019674:	3710      	adds	r7, #16
 8019676:	46bd      	mov	sp, r7
 8019678:	bd80      	pop	{r7, pc}
	...

0801967c <antialias_get_opa_circ>:
 * @param px_id index of pixel on the line segment
 * @param line_opa opacity of the lien (it will be the max opacity)
 * @return the desired opacity of the pixel
 */
static lv_opa_t antialias_get_opa_circ(lv_coord_t seg, lv_coord_t px_id, lv_opa_t opa)
{
 801967c:	b480      	push	{r7}
 801967e:	b085      	sub	sp, #20
 8019680:	af00      	add	r7, sp, #0
 8019682:	4603      	mov	r3, r0
 8019684:	80fb      	strh	r3, [r7, #6]
 8019686:	460b      	mov	r3, r1
 8019688:	80bb      	strh	r3, [r7, #4]
 801968a:	4613      	mov	r3, r2
 801968c:	70fb      	strb	r3, [r7, #3]
#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 1
    if(seg == 1) return 170;
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 2
    if(seg == 2) return (opa_map2[px_id] * opa) >> 8;
 801968e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8019692:	2b02      	cmp	r3, #2
 8019694:	d10a      	bne.n	80196ac <antialias_get_opa_circ+0x30>
 8019696:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801969a:	4a20      	ldr	r2, [pc, #128]	; (801971c <antialias_get_opa_circ+0xa0>)
 801969c:	5cd3      	ldrb	r3, [r2, r3]
 801969e:	461a      	mov	r2, r3
 80196a0:	78fb      	ldrb	r3, [r7, #3]
 80196a2:	fb03 f302 	mul.w	r3, r3, r2
 80196a6:	121b      	asrs	r3, r3, #8
 80196a8:	b2db      	uxtb	r3, r3
 80196aa:	e031      	b.n	8019710 <antialias_get_opa_circ+0x94>
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 3
    if(seg == 3) return (opa_map3[px_id] * opa) >> 8;
 80196ac:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80196b0:	2b03      	cmp	r3, #3
 80196b2:	d10a      	bne.n	80196ca <antialias_get_opa_circ+0x4e>
 80196b4:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80196b8:	4a19      	ldr	r2, [pc, #100]	; (8019720 <antialias_get_opa_circ+0xa4>)
 80196ba:	5cd3      	ldrb	r3, [r2, r3]
 80196bc:	461a      	mov	r2, r3
 80196be:	78fb      	ldrb	r3, [r7, #3]
 80196c0:	fb03 f302 	mul.w	r3, r3, r2
 80196c4:	121b      	asrs	r3, r3, #8
 80196c6:	b2db      	uxtb	r3, r3
 80196c8:	e022      	b.n	8019710 <antialias_get_opa_circ+0x94>
#endif

#if CIRCLE_AA_NON_LINEAR_OPA_THRESHOLD < 4
    if(seg == 4) return (opa_map4[px_id] * opa) >> 8;
 80196ca:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 80196ce:	2b04      	cmp	r3, #4
 80196d0:	d10a      	bne.n	80196e8 <antialias_get_opa_circ+0x6c>
 80196d2:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 80196d6:	4a13      	ldr	r2, [pc, #76]	; (8019724 <antialias_get_opa_circ+0xa8>)
 80196d8:	5cd3      	ldrb	r3, [r2, r3]
 80196da:	461a      	mov	r2, r3
 80196dc:	78fb      	ldrb	r3, [r7, #3]
 80196de:	fb03 f302 	mul.w	r3, r3, r2
 80196e2:	121b      	asrs	r3, r3, #8
 80196e4:	b2db      	uxtb	r3, r3
 80196e6:	e013      	b.n	8019710 <antialias_get_opa_circ+0x94>
#endif

    uint8_t id = (uint32_t)((uint32_t)px_id * (sizeof(opa_map8) - 1)) / (seg - 1);
 80196e8:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 80196ec:	4613      	mov	r3, r2
 80196ee:	00db      	lsls	r3, r3, #3
 80196f0:	1a9b      	subs	r3, r3, r2
 80196f2:	f9b7 2006 	ldrsh.w	r2, [r7, #6]
 80196f6:	3a01      	subs	r2, #1
 80196f8:	fbb3 f3f2 	udiv	r3, r3, r2
 80196fc:	73fb      	strb	r3, [r7, #15]
    return (uint32_t)((uint32_t)opa_map8[id] * opa) >> 8;
 80196fe:	7bfb      	ldrb	r3, [r7, #15]
 8019700:	4a09      	ldr	r2, [pc, #36]	; (8019728 <antialias_get_opa_circ+0xac>)
 8019702:	5cd3      	ldrb	r3, [r2, r3]
 8019704:	461a      	mov	r2, r3
 8019706:	78fb      	ldrb	r3, [r7, #3]
 8019708:	fb03 f302 	mul.w	r3, r3, r2
 801970c:	0a1b      	lsrs	r3, r3, #8
 801970e:	b2db      	uxtb	r3, r3
}
 8019710:	4618      	mov	r0, r3
 8019712:	3714      	adds	r7, #20
 8019714:	46bd      	mov	sp, r7
 8019716:	f85d 7b04 	ldr.w	r7, [sp], #4
 801971a:	4770      	bx	lr
 801971c:	08029194 	.word	0x08029194
 8019720:	08029198 	.word	0x08029198
 8019724:	0802919c 	.word	0x0802919c
 8019728:	080291a0 	.word	0x080291a0

0801972c <lv_img_cache_set_size>:
 * More cached images mean more opened image at same time which might mean more memory usage.
 * E.g. if 20 PNG or JPG images are open in the RAM they consume memory while opened in the cache.
 * @param new_entry_cnt number of image to cache
 */
void lv_img_cache_set_size(uint16_t new_entry_cnt)
{
 801972c:	b580      	push	{r7, lr}
 801972e:	b084      	sub	sp, #16
 8019730:	af00      	add	r7, sp, #0
 8019732:	4603      	mov	r3, r0
 8019734:	80fb      	strh	r3, [r7, #6]
    if(LV_GC_ROOT(_lv_img_cache_array) != NULL) {
 8019736:	4b2a      	ldr	r3, [pc, #168]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 8019738:	681b      	ldr	r3, [r3, #0]
 801973a:	2b00      	cmp	r3, #0
 801973c:	d007      	beq.n	801974e <lv_img_cache_set_size+0x22>
        /*Clean the cache before free it*/
        lv_img_cache_invalidate_src(NULL);
 801973e:	2000      	movs	r0, #0
 8019740:	f000 f856 	bl	80197f0 <lv_img_cache_invalidate_src>
        lv_mem_free(LV_GC_ROOT(_lv_img_cache_array));
 8019744:	4b26      	ldr	r3, [pc, #152]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 8019746:	681b      	ldr	r3, [r3, #0]
 8019748:	4618      	mov	r0, r3
 801974a:	f003 f8eb 	bl	801c924 <lv_mem_free>
    }

    /*Reallocate the cache*/
    LV_GC_ROOT(_lv_img_cache_array) = lv_mem_alloc(sizeof(lv_img_cache_entry_t) * new_entry_cnt);
 801974e:	88fa      	ldrh	r2, [r7, #6]
 8019750:	4613      	mov	r3, r2
 8019752:	009b      	lsls	r3, r3, #2
 8019754:	4413      	add	r3, r2
 8019756:	00db      	lsls	r3, r3, #3
 8019758:	4618      	mov	r0, r3
 801975a:	f003 f89b 	bl	801c894 <lv_mem_alloc>
 801975e:	4602      	mov	r2, r0
 8019760:	4b1f      	ldr	r3, [pc, #124]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 8019762:	601a      	str	r2, [r3, #0]
    lv_mem_assert(LV_GC_ROOT(_lv_img_cache_array));
 8019764:	4b1e      	ldr	r3, [pc, #120]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 8019766:	681b      	ldr	r3, [r3, #0]
 8019768:	2b00      	cmp	r3, #0
 801976a:	d106      	bne.n	801977a <lv_img_cache_set_size+0x4e>
 801976c:	4b1d      	ldr	r3, [pc, #116]	; (80197e4 <lv_img_cache_set_size+0xb8>)
 801976e:	229b      	movs	r2, #155	; 0x9b
 8019770:	491d      	ldr	r1, [pc, #116]	; (80197e8 <lv_img_cache_set_size+0xbc>)
 8019772:	2003      	movs	r0, #3
 8019774:	f003 f84a 	bl	801c80c <lv_log_add>
 8019778:	e7fe      	b.n	8019778 <lv_img_cache_set_size+0x4c>
    if(LV_GC_ROOT(_lv_img_cache_array) == NULL) {
 801977a:	4b19      	ldr	r3, [pc, #100]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 801977c:	681b      	ldr	r3, [r3, #0]
 801977e:	2b00      	cmp	r3, #0
 8019780:	d103      	bne.n	801978a <lv_img_cache_set_size+0x5e>
        entry_cnt = 0;
 8019782:	4b1a      	ldr	r3, [pc, #104]	; (80197ec <lv_img_cache_set_size+0xc0>)
 8019784:	2200      	movs	r2, #0
 8019786:	801a      	strh	r2, [r3, #0]
        return;
 8019788:	e027      	b.n	80197da <lv_img_cache_set_size+0xae>
    }
    entry_cnt = new_entry_cnt;
 801978a:	4a18      	ldr	r2, [pc, #96]	; (80197ec <lv_img_cache_set_size+0xc0>)
 801978c:	88fb      	ldrh	r3, [r7, #6]
 801978e:	8013      	strh	r3, [r2, #0]

    /*Clean the cache*/
    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 8019790:	2300      	movs	r3, #0
 8019792:	81fb      	strh	r3, [r7, #14]
 8019794:	e01c      	b.n	80197d0 <lv_img_cache_set_size+0xa4>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 8019796:	4b12      	ldr	r3, [pc, #72]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 8019798:	6819      	ldr	r1, [r3, #0]
 801979a:	89fa      	ldrh	r2, [r7, #14]
 801979c:	4613      	mov	r3, r2
 801979e:	009b      	lsls	r3, r3, #2
 80197a0:	4413      	add	r3, r2
 80197a2:	00db      	lsls	r3, r3, #3
 80197a4:	440b      	add	r3, r1
 80197a6:	2224      	movs	r2, #36	; 0x24
 80197a8:	2100      	movs	r1, #0
 80197aa:	4618      	mov	r0, r3
 80197ac:	f00d fd11 	bl	80271d2 <memset>
        memset(&LV_GC_ROOT(_lv_img_cache_array)[i], 0, sizeof(lv_img_cache_entry_t));
 80197b0:	4b0b      	ldr	r3, [pc, #44]	; (80197e0 <lv_img_cache_set_size+0xb4>)
 80197b2:	6819      	ldr	r1, [r3, #0]
 80197b4:	89fa      	ldrh	r2, [r7, #14]
 80197b6:	4613      	mov	r3, r2
 80197b8:	009b      	lsls	r3, r3, #2
 80197ba:	4413      	add	r3, r2
 80197bc:	00db      	lsls	r3, r3, #3
 80197be:	440b      	add	r3, r1
 80197c0:	2228      	movs	r2, #40	; 0x28
 80197c2:	2100      	movs	r1, #0
 80197c4:	4618      	mov	r0, r3
 80197c6:	f00d fd04 	bl	80271d2 <memset>
    for(i = 0; i < entry_cnt; i++) {
 80197ca:	89fb      	ldrh	r3, [r7, #14]
 80197cc:	3301      	adds	r3, #1
 80197ce:	81fb      	strh	r3, [r7, #14]
 80197d0:	4b06      	ldr	r3, [pc, #24]	; (80197ec <lv_img_cache_set_size+0xc0>)
 80197d2:	881b      	ldrh	r3, [r3, #0]
 80197d4:	89fa      	ldrh	r2, [r7, #14]
 80197d6:	429a      	cmp	r2, r3
 80197d8:	d3dd      	bcc.n	8019796 <lv_img_cache_set_size+0x6a>
    }
}
 80197da:	3710      	adds	r7, #16
 80197dc:	46bd      	mov	sp, r7
 80197de:	bd80      	pop	{r7, pc}
 80197e0:	2000df88 	.word	0x2000df88
 80197e4:	08028bb4 	.word	0x08028bb4
 80197e8:	08028b64 	.word	0x08028b64
 80197ec:	20004374 	.word	0x20004374

080197f0 <lv_img_cache_invalidate_src>:
 * Invalidate an image source in the cache.
 * Useful if the image source is updated therefore it needs to be cached again.
 * @param src an image source path to a file or pointer to an `lv_img_dsc_t` variable.
 */
void lv_img_cache_invalidate_src(const void * src)
{
 80197f0:	b580      	push	{r7, lr}
 80197f2:	b084      	sub	sp, #16
 80197f4:	af00      	add	r7, sp, #0
 80197f6:	6078      	str	r0, [r7, #4]

    lv_img_cache_entry_t * cache = LV_GC_ROOT(_lv_img_cache_array);
 80197f8:	4b28      	ldr	r3, [pc, #160]	; (801989c <lv_img_cache_invalidate_src+0xac>)
 80197fa:	681b      	ldr	r3, [r3, #0]
 80197fc:	60bb      	str	r3, [r7, #8]

    uint16_t i;
    for(i = 0; i < entry_cnt; i++) {
 80197fe:	2300      	movs	r3, #0
 8019800:	81fb      	strh	r3, [r7, #14]
 8019802:	e041      	b.n	8019888 <lv_img_cache_invalidate_src+0x98>
        if(cache[i].dec_dsc.src == src || src == NULL) {
 8019804:	89fa      	ldrh	r2, [r7, #14]
 8019806:	4613      	mov	r3, r2
 8019808:	009b      	lsls	r3, r3, #2
 801980a:	4413      	add	r3, r2
 801980c:	00db      	lsls	r3, r3, #3
 801980e:	461a      	mov	r2, r3
 8019810:	68bb      	ldr	r3, [r7, #8]
 8019812:	4413      	add	r3, r2
 8019814:	685b      	ldr	r3, [r3, #4]
 8019816:	687a      	ldr	r2, [r7, #4]
 8019818:	429a      	cmp	r2, r3
 801981a:	d002      	beq.n	8019822 <lv_img_cache_invalidate_src+0x32>
 801981c:	687b      	ldr	r3, [r7, #4]
 801981e:	2b00      	cmp	r3, #0
 8019820:	d12f      	bne.n	8019882 <lv_img_cache_invalidate_src+0x92>
            if(cache[i].dec_dsc.src != NULL) {
 8019822:	89fa      	ldrh	r2, [r7, #14]
 8019824:	4613      	mov	r3, r2
 8019826:	009b      	lsls	r3, r3, #2
 8019828:	4413      	add	r3, r2
 801982a:	00db      	lsls	r3, r3, #3
 801982c:	461a      	mov	r2, r3
 801982e:	68bb      	ldr	r3, [r7, #8]
 8019830:	4413      	add	r3, r2
 8019832:	685b      	ldr	r3, [r3, #4]
 8019834:	2b00      	cmp	r3, #0
 8019836:	d00a      	beq.n	801984e <lv_img_cache_invalidate_src+0x5e>
                lv_img_decoder_close(&cache[i].dec_dsc);
 8019838:	89fa      	ldrh	r2, [r7, #14]
 801983a:	4613      	mov	r3, r2
 801983c:	009b      	lsls	r3, r3, #2
 801983e:	4413      	add	r3, r2
 8019840:	00db      	lsls	r3, r3, #3
 8019842:	461a      	mov	r2, r3
 8019844:	68bb      	ldr	r3, [r7, #8]
 8019846:	4413      	add	r3, r2
 8019848:	4618      	mov	r0, r3
 801984a:	f000 f89b 	bl	8019984 <lv_img_decoder_close>
            }

            memset(&cache[i].dec_dsc, 0, sizeof(lv_img_decoder_dsc_t));
 801984e:	89fa      	ldrh	r2, [r7, #14]
 8019850:	4613      	mov	r3, r2
 8019852:	009b      	lsls	r3, r3, #2
 8019854:	4413      	add	r3, r2
 8019856:	00db      	lsls	r3, r3, #3
 8019858:	461a      	mov	r2, r3
 801985a:	68bb      	ldr	r3, [r7, #8]
 801985c:	4413      	add	r3, r2
 801985e:	2224      	movs	r2, #36	; 0x24
 8019860:	2100      	movs	r1, #0
 8019862:	4618      	mov	r0, r3
 8019864:	f00d fcb5 	bl	80271d2 <memset>
            memset(&cache[i], 0, sizeof(lv_img_cache_entry_t));
 8019868:	89fa      	ldrh	r2, [r7, #14]
 801986a:	4613      	mov	r3, r2
 801986c:	009b      	lsls	r3, r3, #2
 801986e:	4413      	add	r3, r2
 8019870:	00db      	lsls	r3, r3, #3
 8019872:	461a      	mov	r2, r3
 8019874:	68bb      	ldr	r3, [r7, #8]
 8019876:	4413      	add	r3, r2
 8019878:	2228      	movs	r2, #40	; 0x28
 801987a:	2100      	movs	r1, #0
 801987c:	4618      	mov	r0, r3
 801987e:	f00d fca8 	bl	80271d2 <memset>
    for(i = 0; i < entry_cnt; i++) {
 8019882:	89fb      	ldrh	r3, [r7, #14]
 8019884:	3301      	adds	r3, #1
 8019886:	81fb      	strh	r3, [r7, #14]
 8019888:	4b05      	ldr	r3, [pc, #20]	; (80198a0 <lv_img_cache_invalidate_src+0xb0>)
 801988a:	881b      	ldrh	r3, [r3, #0]
 801988c:	89fa      	ldrh	r2, [r7, #14]
 801988e:	429a      	cmp	r2, r3
 8019890:	d3b8      	bcc.n	8019804 <lv_img_cache_invalidate_src+0x14>
        }
    }
}
 8019892:	bf00      	nop
 8019894:	3710      	adds	r7, #16
 8019896:	46bd      	mov	sp, r7
 8019898:	bd80      	pop	{r7, pc}
 801989a:	bf00      	nop
 801989c:	2000df88 	.word	0x2000df88
 80198a0:	20004374 	.word	0x20004374

080198a4 <lv_color_make>:
{
 80198a4:	b480      	push	{r7}
 80198a6:	b085      	sub	sp, #20
 80198a8:	af00      	add	r7, sp, #0
 80198aa:	4603      	mov	r3, r0
 80198ac:	71fb      	strb	r3, [r7, #7]
 80198ae:	460b      	mov	r3, r1
 80198b0:	71bb      	strb	r3, [r7, #6]
 80198b2:	4613      	mov	r3, r2
 80198b4:	717b      	strb	r3, [r7, #5]
    color.ch.blue  = (uint16_t)(b8 >> 3);
 80198b6:	797b      	ldrb	r3, [r7, #5]
 80198b8:	08db      	lsrs	r3, r3, #3
 80198ba:	b2db      	uxtb	r3, r3
 80198bc:	f003 031f 	and.w	r3, r3, #31
 80198c0:	b2da      	uxtb	r2, r3
 80198c2:	7b3b      	ldrb	r3, [r7, #12]
 80198c4:	f362 0304 	bfi	r3, r2, #0, #5
 80198c8:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 80198ca:	79bb      	ldrb	r3, [r7, #6]
 80198cc:	089b      	lsrs	r3, r3, #2
 80198ce:	b2db      	uxtb	r3, r3
 80198d0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 80198d4:	b2da      	uxtb	r2, r3
 80198d6:	89bb      	ldrh	r3, [r7, #12]
 80198d8:	f362 134a 	bfi	r3, r2, #5, #6
 80198dc:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 80198de:	79fb      	ldrb	r3, [r7, #7]
 80198e0:	08db      	lsrs	r3, r3, #3
 80198e2:	b2db      	uxtb	r3, r3
 80198e4:	f003 031f 	and.w	r3, r3, #31
 80198e8:	b2da      	uxtb	r2, r3
 80198ea:	7b7b      	ldrb	r3, [r7, #13]
 80198ec:	f362 03c7 	bfi	r3, r2, #3, #5
 80198f0:	737b      	strb	r3, [r7, #13]
    return color;
 80198f2:	89bb      	ldrh	r3, [r7, #12]
}
 80198f4:	4618      	mov	r0, r3
 80198f6:	3714      	adds	r7, #20
 80198f8:	46bd      	mov	sp, r7
 80198fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 80198fe:	4770      	bx	lr

08019900 <lv_img_decoder_init>:

/**
 * Initialize the image decoder module
 * */
void lv_img_decoder_init(void)
{
 8019900:	b580      	push	{r7, lr}
 8019902:	b082      	sub	sp, #8
 8019904:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_img_defoder_ll), sizeof(lv_img_decoder_t));
 8019906:	2114      	movs	r1, #20
 8019908:	4816      	ldr	r0, [pc, #88]	; (8019964 <lv_img_decoder_init+0x64>)
 801990a:	f002 fcf5 	bl	801c2f8 <lv_ll_init>

    lv_img_decoder_t * decoder;

    /*Create a decoder for the built in color format*/
    decoder = lv_img_decoder_create();
 801990e:	f000 f84f 	bl	80199b0 <lv_img_decoder_create>
 8019912:	6078      	str	r0, [r7, #4]
    if(decoder == NULL) {
 8019914:	687b      	ldr	r3, [r7, #4]
 8019916:	2b00      	cmp	r3, #0
 8019918:	d10f      	bne.n	801993a <lv_img_decoder_init+0x3a>
        LV_LOG_WARN("lv_img_decoder_init: out of memory");
 801991a:	4b13      	ldr	r3, [pc, #76]	; (8019968 <lv_img_decoder_init+0x68>)
 801991c:	224a      	movs	r2, #74	; 0x4a
 801991e:	4913      	ldr	r1, [pc, #76]	; (801996c <lv_img_decoder_init+0x6c>)
 8019920:	2002      	movs	r0, #2
 8019922:	f002 ff73 	bl	801c80c <lv_log_add>
        lv_mem_assert(decoder);
 8019926:	687b      	ldr	r3, [r7, #4]
 8019928:	2b00      	cmp	r3, #0
 801992a:	d117      	bne.n	801995c <lv_img_decoder_init+0x5c>
 801992c:	4b10      	ldr	r3, [pc, #64]	; (8019970 <lv_img_decoder_init+0x70>)
 801992e:	224b      	movs	r2, #75	; 0x4b
 8019930:	490e      	ldr	r1, [pc, #56]	; (801996c <lv_img_decoder_init+0x6c>)
 8019932:	2003      	movs	r0, #3
 8019934:	f002 ff6a 	bl	801c80c <lv_log_add>
 8019938:	e7fe      	b.n	8019938 <lv_img_decoder_init+0x38>
        return;
    }

    lv_img_decoder_set_info_cb(decoder, lv_img_decoder_built_in_info);
 801993a:	490e      	ldr	r1, [pc, #56]	; (8019974 <lv_img_decoder_init+0x74>)
 801993c:	6878      	ldr	r0, [r7, #4]
 801993e:	f000 f85d 	bl	80199fc <lv_img_decoder_set_info_cb>
    lv_img_decoder_set_open_cb(decoder, lv_img_decoder_built_in_open);
 8019942:	490d      	ldr	r1, [pc, #52]	; (8019978 <lv_img_decoder_init+0x78>)
 8019944:	6878      	ldr	r0, [r7, #4]
 8019946:	f000 f867 	bl	8019a18 <lv_img_decoder_set_open_cb>
    lv_img_decoder_set_read_line_cb(decoder, lv_img_decoder_built_in_read_line);
 801994a:	490c      	ldr	r1, [pc, #48]	; (801997c <lv_img_decoder_init+0x7c>)
 801994c:	6878      	ldr	r0, [r7, #4]
 801994e:	f000 f871 	bl	8019a34 <lv_img_decoder_set_read_line_cb>
    lv_img_decoder_set_close_cb(decoder, lv_img_decoder_built_in_close);
 8019952:	490b      	ldr	r1, [pc, #44]	; (8019980 <lv_img_decoder_init+0x80>)
 8019954:	6878      	ldr	r0, [r7, #4]
 8019956:	f000 f87b 	bl	8019a50 <lv_img_decoder_set_close_cb>
 801995a:	e000      	b.n	801995e <lv_img_decoder_init+0x5e>
        return;
 801995c:	bf00      	nop
}
 801995e:	3708      	adds	r7, #8
 8019960:	46bd      	mov	sp, r7
 8019962:	bd80      	pop	{r7, pc}
 8019964:	2000df6c 	.word	0x2000df6c
 8019968:	08028bc4 	.word	0x08028bc4
 801996c:	08028be8 	.word	0x08028be8
 8019970:	08028c10 	.word	0x08028c10
 8019974:	08019a6d 	.word	0x08019a6d
 8019978:	08019b85 	.word	0x08019b85
 801997c:	08019e81 	.word	0x08019e81
 8019980:	08019fbd 	.word	0x08019fbd

08019984 <lv_img_decoder_close>:
/**
 * Close a decoding session
 * @param dsc pointer to `lv_img_decoder_dsc_t` used in `lv_img_decoder_open`
 */
void lv_img_decoder_close(lv_img_decoder_dsc_t * dsc)
{
 8019984:	b580      	push	{r7, lr}
 8019986:	b082      	sub	sp, #8
 8019988:	af00      	add	r7, sp, #0
 801998a:	6078      	str	r0, [r7, #4]
    if(dsc->decoder->close_cb) dsc->decoder->close_cb(dsc->decoder, dsc);
 801998c:	687b      	ldr	r3, [r7, #4]
 801998e:	681b      	ldr	r3, [r3, #0]
 8019990:	68db      	ldr	r3, [r3, #12]
 8019992:	2b00      	cmp	r3, #0
 8019994:	d007      	beq.n	80199a6 <lv_img_decoder_close+0x22>
 8019996:	687b      	ldr	r3, [r7, #4]
 8019998:	681b      	ldr	r3, [r3, #0]
 801999a:	68db      	ldr	r3, [r3, #12]
 801999c:	687a      	ldr	r2, [r7, #4]
 801999e:	6812      	ldr	r2, [r2, #0]
 80199a0:	6879      	ldr	r1, [r7, #4]
 80199a2:	4610      	mov	r0, r2
 80199a4:	4798      	blx	r3
}
 80199a6:	bf00      	nop
 80199a8:	3708      	adds	r7, #8
 80199aa:	46bd      	mov	sp, r7
 80199ac:	bd80      	pop	{r7, pc}
	...

080199b0 <lv_img_decoder_create>:
/**
 * Create a new image decoder
 * @return pointer to the new image decoder
 */
lv_img_decoder_t * lv_img_decoder_create(void)
{
 80199b0:	b580      	push	{r7, lr}
 80199b2:	b082      	sub	sp, #8
 80199b4:	af00      	add	r7, sp, #0
    lv_img_decoder_t * decoder;
    decoder = lv_ll_ins_head(&LV_GC_ROOT(_lv_img_defoder_ll));
 80199b6:	480e      	ldr	r0, [pc, #56]	; (80199f0 <lv_img_decoder_create+0x40>)
 80199b8:	f002 fcbe 	bl	801c338 <lv_ll_ins_head>
 80199bc:	6078      	str	r0, [r7, #4]
    lv_mem_assert(decoder);
 80199be:	687b      	ldr	r3, [r7, #4]
 80199c0:	2b00      	cmp	r3, #0
 80199c2:	d106      	bne.n	80199d2 <lv_img_decoder_create+0x22>
 80199c4:	4b0b      	ldr	r3, [pc, #44]	; (80199f4 <lv_img_decoder_create+0x44>)
 80199c6:	22bf      	movs	r2, #191	; 0xbf
 80199c8:	490b      	ldr	r1, [pc, #44]	; (80199f8 <lv_img_decoder_create+0x48>)
 80199ca:	2003      	movs	r0, #3
 80199cc:	f002 ff1e 	bl	801c80c <lv_log_add>
 80199d0:	e7fe      	b.n	80199d0 <lv_img_decoder_create+0x20>
    if(decoder == NULL) return NULL;
 80199d2:	687b      	ldr	r3, [r7, #4]
 80199d4:	2b00      	cmp	r3, #0
 80199d6:	d101      	bne.n	80199dc <lv_img_decoder_create+0x2c>
 80199d8:	2300      	movs	r3, #0
 80199da:	e005      	b.n	80199e8 <lv_img_decoder_create+0x38>

    memset(decoder, 0, sizeof(lv_img_decoder_t));
 80199dc:	2214      	movs	r2, #20
 80199de:	2100      	movs	r1, #0
 80199e0:	6878      	ldr	r0, [r7, #4]
 80199e2:	f00d fbf6 	bl	80271d2 <memset>

    return decoder;
 80199e6:	687b      	ldr	r3, [r7, #4]
}
 80199e8:	4618      	mov	r0, r3
 80199ea:	3708      	adds	r7, #8
 80199ec:	46bd      	mov	sp, r7
 80199ee:	bd80      	pop	{r7, pc}
 80199f0:	2000df6c 	.word	0x2000df6c
 80199f4:	08028c10 	.word	0x08028c10
 80199f8:	08028be8 	.word	0x08028be8

080199fc <lv_img_decoder_set_info_cb>:
 * Set a callback to get information about the image
 * @param decoder pointer to an image decoder
 * @param info_cb a function to collect info about an image (fill an `lv_img_header_t` struct)
 */
void lv_img_decoder_set_info_cb(lv_img_decoder_t * decoder, lv_img_decoder_info_f_t info_cb)
{
 80199fc:	b480      	push	{r7}
 80199fe:	b083      	sub	sp, #12
 8019a00:	af00      	add	r7, sp, #0
 8019a02:	6078      	str	r0, [r7, #4]
 8019a04:	6039      	str	r1, [r7, #0]
    decoder->info_cb = info_cb;
 8019a06:	687b      	ldr	r3, [r7, #4]
 8019a08:	683a      	ldr	r2, [r7, #0]
 8019a0a:	601a      	str	r2, [r3, #0]
}
 8019a0c:	bf00      	nop
 8019a0e:	370c      	adds	r7, #12
 8019a10:	46bd      	mov	sp, r7
 8019a12:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019a16:	4770      	bx	lr

08019a18 <lv_img_decoder_set_open_cb>:
 * Set a callback to open an image
 * @param decoder pointer to an image decoder
 * @param open_cb a function to open an image
 */
void lv_img_decoder_set_open_cb(lv_img_decoder_t * decoder, lv_img_decoder_open_f_t open_cb)
{
 8019a18:	b480      	push	{r7}
 8019a1a:	b083      	sub	sp, #12
 8019a1c:	af00      	add	r7, sp, #0
 8019a1e:	6078      	str	r0, [r7, #4]
 8019a20:	6039      	str	r1, [r7, #0]
    decoder->open_cb = open_cb;
 8019a22:	687b      	ldr	r3, [r7, #4]
 8019a24:	683a      	ldr	r2, [r7, #0]
 8019a26:	605a      	str	r2, [r3, #4]
}
 8019a28:	bf00      	nop
 8019a2a:	370c      	adds	r7, #12
 8019a2c:	46bd      	mov	sp, r7
 8019a2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019a32:	4770      	bx	lr

08019a34 <lv_img_decoder_set_read_line_cb>:
 * Set a callback to a decoded line of an image
 * @param decoder pointer to an image decoder
 * @param read_line_cb a function to read a line of an image
 */
void lv_img_decoder_set_read_line_cb(lv_img_decoder_t * decoder, lv_img_decoder_read_line_f_t read_line_cb)
{
 8019a34:	b480      	push	{r7}
 8019a36:	b083      	sub	sp, #12
 8019a38:	af00      	add	r7, sp, #0
 8019a3a:	6078      	str	r0, [r7, #4]
 8019a3c:	6039      	str	r1, [r7, #0]
    decoder->read_line_cb = read_line_cb;
 8019a3e:	687b      	ldr	r3, [r7, #4]
 8019a40:	683a      	ldr	r2, [r7, #0]
 8019a42:	609a      	str	r2, [r3, #8]
}
 8019a44:	bf00      	nop
 8019a46:	370c      	adds	r7, #12
 8019a48:	46bd      	mov	sp, r7
 8019a4a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019a4e:	4770      	bx	lr

08019a50 <lv_img_decoder_set_close_cb>:
 * Set a callback to close a decoding session. E.g. close files and free other resources.
 * @param decoder pointer to an image decoder
 * @param close_cb a function to close a decoding session
 */
void lv_img_decoder_set_close_cb(lv_img_decoder_t * decoder, lv_img_decoder_close_f_t close_cb)
{
 8019a50:	b480      	push	{r7}
 8019a52:	b083      	sub	sp, #12
 8019a54:	af00      	add	r7, sp, #0
 8019a56:	6078      	str	r0, [r7, #4]
 8019a58:	6039      	str	r1, [r7, #0]
    decoder->close_cb = close_cb;
 8019a5a:	687b      	ldr	r3, [r7, #4]
 8019a5c:	683a      	ldr	r2, [r7, #0]
 8019a5e:	60da      	str	r2, [r3, #12]
}
 8019a60:	bf00      	nop
 8019a62:	370c      	adds	r7, #12
 8019a64:	46bd      	mov	sp, r7
 8019a66:	f85d 7b04 	ldr.w	r7, [sp], #4
 8019a6a:	4770      	bx	lr

08019a6c <lv_img_decoder_built_in_info>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static lv_res_t lv_img_decoder_built_in_info(lv_img_decoder_t * decoder, const void * src, lv_img_header_t * header)
{
 8019a6c:	b580      	push	{r7, lr}
 8019a6e:	b088      	sub	sp, #32
 8019a70:	af00      	add	r7, sp, #0
 8019a72:	60f8      	str	r0, [r7, #12]
 8019a74:	60b9      	str	r1, [r7, #8]
 8019a76:	607a      	str	r2, [r7, #4]
    (void)decoder; /*Unused*/

    lv_img_src_t src_type = lv_img_src_get_type(src);
 8019a78:	68b8      	ldr	r0, [r7, #8]
 8019a7a:	f7fb fa27 	bl	8014ecc <lv_img_src_get_type>
 8019a7e:	4603      	mov	r3, r0
 8019a80:	77bb      	strb	r3, [r7, #30]
    if(src_type == LV_IMG_SRC_VARIABLE) {
 8019a82:	7fbb      	ldrb	r3, [r7, #30]
 8019a84:	2b00      	cmp	r3, #0
 8019a86:	d11e      	bne.n	8019ac6 <lv_img_decoder_built_in_info+0x5a>
        header->w  = ((lv_img_dsc_t *)src)->header.w;
 8019a88:	68bb      	ldr	r3, [r7, #8]
 8019a8a:	681b      	ldr	r3, [r3, #0]
 8019a8c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 8019a90:	b299      	uxth	r1, r3
 8019a92:	687a      	ldr	r2, [r7, #4]
 8019a94:	6813      	ldr	r3, [r2, #0]
 8019a96:	f361 2394 	bfi	r3, r1, #10, #11
 8019a9a:	6013      	str	r3, [r2, #0]
        header->h  = ((lv_img_dsc_t *)src)->header.h;
 8019a9c:	68bb      	ldr	r3, [r7, #8]
 8019a9e:	885b      	ldrh	r3, [r3, #2]
 8019aa0:	f3c3 134a 	ubfx	r3, r3, #5, #11
 8019aa4:	b299      	uxth	r1, r3
 8019aa6:	687a      	ldr	r2, [r7, #4]
 8019aa8:	8853      	ldrh	r3, [r2, #2]
 8019aaa:	f361 134f 	bfi	r3, r1, #5, #11
 8019aae:	8053      	strh	r3, [r2, #2]
        header->cf = ((lv_img_dsc_t *)src)->header.cf;
 8019ab0:	68bb      	ldr	r3, [r7, #8]
 8019ab2:	781b      	ldrb	r3, [r3, #0]
 8019ab4:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8019ab8:	b2d9      	uxtb	r1, r3
 8019aba:	687a      	ldr	r2, [r7, #4]
 8019abc:	7813      	ldrb	r3, [r2, #0]
 8019abe:	f361 0304 	bfi	r3, r1, #0, #5
 8019ac2:	7013      	strb	r3, [r2, #0]
 8019ac4:	e055      	b.n	8019b72 <lv_img_decoder_built_in_info+0x106>
    }
#if LV_USE_FILESYSTEM
    else if(src_type == LV_IMG_SRC_FILE) {
 8019ac6:	7fbb      	ldrb	r3, [r7, #30]
 8019ac8:	2b01      	cmp	r3, #1
 8019aca:	d133      	bne.n	8019b34 <lv_img_decoder_built_in_info+0xc8>
        lv_fs_file_t file;
        lv_fs_res_t res;
        uint32_t rn;
        res = lv_fs_open(&file, src, LV_FS_MODE_RD);
 8019acc:	f107 0314 	add.w	r3, r7, #20
 8019ad0:	2202      	movs	r2, #2
 8019ad2:	68b9      	ldr	r1, [r7, #8]
 8019ad4:	4618      	mov	r0, r3
 8019ad6:	f002 fa8b 	bl	801bff0 <lv_fs_open>
 8019ada:	4603      	mov	r3, r0
 8019adc:	77fb      	strb	r3, [r7, #31]
        if(res == LV_FS_RES_OK) {
 8019ade:	7ffb      	ldrb	r3, [r7, #31]
 8019ae0:	2b00      	cmp	r3, #0
 8019ae2:	d10e      	bne.n	8019b02 <lv_img_decoder_built_in_info+0x96>
            res = lv_fs_read(&file, header, sizeof(lv_img_header_t), &rn);
 8019ae4:	f107 0310 	add.w	r3, r7, #16
 8019ae8:	f107 0014 	add.w	r0, r7, #20
 8019aec:	2204      	movs	r2, #4
 8019aee:	6879      	ldr	r1, [r7, #4]
 8019af0:	f002 fb37 	bl	801c162 <lv_fs_read>
 8019af4:	4603      	mov	r3, r0
 8019af6:	77fb      	strb	r3, [r7, #31]
            lv_fs_close(&file);
 8019af8:	f107 0314 	add.w	r3, r7, #20
 8019afc:	4618      	mov	r0, r3
 8019afe:	f002 fb01 	bl	801c104 <lv_fs_close>
        }

        /*Create a dummy header on fs error*/
        if(res != LV_FS_RES_OK || rn != sizeof(lv_img_header_t)) {
 8019b02:	7ffb      	ldrb	r3, [r7, #31]
 8019b04:	2b00      	cmp	r3, #0
 8019b06:	d102      	bne.n	8019b0e <lv_img_decoder_built_in_info+0xa2>
 8019b08:	693b      	ldr	r3, [r7, #16]
 8019b0a:	2b04      	cmp	r3, #4
 8019b0c:	d031      	beq.n	8019b72 <lv_img_decoder_built_in_info+0x106>
            header->w  = LV_DPI;
 8019b0e:	687a      	ldr	r2, [r7, #4]
 8019b10:	6813      	ldr	r3, [r2, #0]
 8019b12:	2164      	movs	r1, #100	; 0x64
 8019b14:	f361 2394 	bfi	r3, r1, #10, #11
 8019b18:	6013      	str	r3, [r2, #0]
            header->h  = LV_DPI;
 8019b1a:	687a      	ldr	r2, [r7, #4]
 8019b1c:	8853      	ldrh	r3, [r2, #2]
 8019b1e:	2164      	movs	r1, #100	; 0x64
 8019b20:	f361 134f 	bfi	r3, r1, #5, #11
 8019b24:	8053      	strh	r3, [r2, #2]
            header->cf = LV_IMG_CF_UNKNOWN;
 8019b26:	687a      	ldr	r2, [r7, #4]
 8019b28:	7813      	ldrb	r3, [r2, #0]
 8019b2a:	f36f 0304 	bfc	r3, #0, #5
 8019b2e:	7013      	strb	r3, [r2, #0]
            return LV_RES_INV;
 8019b30:	2300      	movs	r3, #0
 8019b32:	e01f      	b.n	8019b74 <lv_img_decoder_built_in_info+0x108>
        }
    }
#endif
    else if(src_type == LV_IMG_SRC_SYMBOL) {
 8019b34:	7fbb      	ldrb	r3, [r7, #30]
 8019b36:	2b02      	cmp	r3, #2
 8019b38:	d112      	bne.n	8019b60 <lv_img_decoder_built_in_info+0xf4>
        /*The size depend on the font but it is unknown here. It should be handled outside of the
         * function*/
        header->w = 1;
 8019b3a:	687a      	ldr	r2, [r7, #4]
 8019b3c:	6813      	ldr	r3, [r2, #0]
 8019b3e:	2101      	movs	r1, #1
 8019b40:	f361 2394 	bfi	r3, r1, #10, #11
 8019b44:	6013      	str	r3, [r2, #0]
        header->h = 1;
 8019b46:	687a      	ldr	r2, [r7, #4]
 8019b48:	8853      	ldrh	r3, [r2, #2]
 8019b4a:	2101      	movs	r1, #1
 8019b4c:	f361 134f 	bfi	r3, r1, #5, #11
 8019b50:	8053      	strh	r3, [r2, #2]
        /* Symbols always have transparent parts. Important because of cover check in the design
         * function. The actual value doesn't matter because lv_draw_label will draw it*/
        header->cf = LV_IMG_CF_ALPHA_1BIT;
 8019b52:	687a      	ldr	r2, [r7, #4]
 8019b54:	7813      	ldrb	r3, [r2, #0]
 8019b56:	210b      	movs	r1, #11
 8019b58:	f361 0304 	bfi	r3, r1, #0, #5
 8019b5c:	7013      	strb	r3, [r2, #0]
 8019b5e:	e008      	b.n	8019b72 <lv_img_decoder_built_in_info+0x106>
    } else {
        LV_LOG_WARN("Image get info found unknown src type");
 8019b60:	4b06      	ldr	r3, [pc, #24]	; (8019b7c <lv_img_decoder_built_in_info+0x110>)
 8019b62:	f44f 7292 	mov.w	r2, #292	; 0x124
 8019b66:	4906      	ldr	r1, [pc, #24]	; (8019b80 <lv_img_decoder_built_in_info+0x114>)
 8019b68:	2002      	movs	r0, #2
 8019b6a:	f002 fe4f 	bl	801c80c <lv_log_add>
        return LV_RES_INV;
 8019b6e:	2300      	movs	r3, #0
 8019b70:	e000      	b.n	8019b74 <lv_img_decoder_built_in_info+0x108>
    }
    return LV_RES_OK;
 8019b72:	2301      	movs	r3, #1
}
 8019b74:	4618      	mov	r0, r3
 8019b76:	3720      	adds	r7, #32
 8019b78:	46bd      	mov	sp, r7
 8019b7a:	bd80      	pop	{r7, pc}
 8019b7c:	08028c20 	.word	0x08028c20
 8019b80:	08028be8 	.word	0x08028be8

08019b84 <lv_img_decoder_built_in_open>:

static lv_res_t lv_img_decoder_built_in_open(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 8019b84:	b5b0      	push	{r4, r5, r7, lr}
 8019b86:	b08c      	sub	sp, #48	; 0x30
 8019b88:	af00      	add	r7, sp, #0
 8019b8a:	6078      	str	r0, [r7, #4]
 8019b8c:	6039      	str	r1, [r7, #0]
    /*Open the file if it's a file*/
    if(dsc->src_type == LV_IMG_SRC_FILE) {
 8019b8e:	683b      	ldr	r3, [r7, #0]
 8019b90:	7b1b      	ldrb	r3, [r3, #12]
 8019b92:	2b01      	cmp	r3, #1
 8019b94:	d176      	bne.n	8019c84 <lv_img_decoder_built_in_open+0x100>
#if LV_USE_FILESYSTEM

        /*Support only "*.bin" files*/
        if(strcmp(lv_fs_get_ext(dsc->src), "bin")) return LV_RES_INV;
 8019b96:	683b      	ldr	r3, [r7, #0]
 8019b98:	685b      	ldr	r3, [r3, #4]
 8019b9a:	4618      	mov	r0, r3
 8019b9c:	f002 fb3a 	bl	801c214 <lv_fs_get_ext>
 8019ba0:	4603      	mov	r3, r0
 8019ba2:	49b1      	ldr	r1, [pc, #708]	; (8019e68 <lv_img_decoder_built_in_open+0x2e4>)
 8019ba4:	4618      	mov	r0, r3
 8019ba6:	f7e6 fb33 	bl	8000210 <strcmp>
 8019baa:	4603      	mov	r3, r0
 8019bac:	2b00      	cmp	r3, #0
 8019bae:	d001      	beq.n	8019bb4 <lv_img_decoder_built_in_open+0x30>
 8019bb0:	2300      	movs	r3, #0
 8019bb2:	e154      	b.n	8019e5e <lv_img_decoder_built_in_open+0x2da>

        lv_fs_file_t f;
        lv_fs_res_t res = lv_fs_open(&f, dsc->src, LV_FS_MODE_RD);
 8019bb4:	683b      	ldr	r3, [r7, #0]
 8019bb6:	6859      	ldr	r1, [r3, #4]
 8019bb8:	f107 030c 	add.w	r3, r7, #12
 8019bbc:	2202      	movs	r2, #2
 8019bbe:	4618      	mov	r0, r3
 8019bc0:	f002 fa16 	bl	801bff0 <lv_fs_open>
 8019bc4:	4603      	mov	r3, r0
 8019bc6:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
        if(res != LV_FS_RES_OK) {
 8019bca:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8019bce:	2b00      	cmp	r3, #0
 8019bd0:	d008      	beq.n	8019be4 <lv_img_decoder_built_in_open+0x60>
            LV_LOG_WARN("Built-in image decoder can't open the file");
 8019bd2:	4ba6      	ldr	r3, [pc, #664]	; (8019e6c <lv_img_decoder_built_in_open+0x2e8>)
 8019bd4:	f44f 729b 	mov.w	r2, #310	; 0x136
 8019bd8:	49a5      	ldr	r1, [pc, #660]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019bda:	2002      	movs	r0, #2
 8019bdc:	f002 fe16 	bl	801c80c <lv_log_add>
            return LV_RES_INV;
 8019be0:	2300      	movs	r3, #0
 8019be2:	e13c      	b.n	8019e5e <lv_img_decoder_built_in_open+0x2da>
        }

        /*If the file was open successfully save the file descriptor*/
        if(dsc->user_data == NULL) {
 8019be4:	683b      	ldr	r3, [r7, #0]
 8019be6:	6a1b      	ldr	r3, [r3, #32]
 8019be8:	2b00      	cmp	r3, #0
 8019bea:	d123      	bne.n	8019c34 <lv_img_decoder_built_in_open+0xb0>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 8019bec:	2008      	movs	r0, #8
 8019bee:	f002 fe51 	bl	801c894 <lv_mem_alloc>
 8019bf2:	4602      	mov	r2, r0
 8019bf4:	683b      	ldr	r3, [r7, #0]
 8019bf6:	621a      	str	r2, [r3, #32]
            if(dsc->user_data == NULL) {
 8019bf8:	683b      	ldr	r3, [r7, #0]
 8019bfa:	6a1b      	ldr	r3, [r3, #32]
 8019bfc:	2b00      	cmp	r3, #0
 8019bfe:	d112      	bne.n	8019c26 <lv_img_decoder_built_in_open+0xa2>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
 8019c00:	4b9c      	ldr	r3, [pc, #624]	; (8019e74 <lv_img_decoder_built_in_open+0x2f0>)
 8019c02:	f44f 729f 	mov.w	r2, #318	; 0x13e
 8019c06:	499a      	ldr	r1, [pc, #616]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019c08:	2003      	movs	r0, #3
 8019c0a:	f002 fdff 	bl	801c80c <lv_log_add>
                lv_mem_assert(dsc->user_data);
 8019c0e:	683b      	ldr	r3, [r7, #0]
 8019c10:	6a1b      	ldr	r3, [r3, #32]
 8019c12:	2b00      	cmp	r3, #0
 8019c14:	d107      	bne.n	8019c26 <lv_img_decoder_built_in_open+0xa2>
 8019c16:	4b98      	ldr	r3, [pc, #608]	; (8019e78 <lv_img_decoder_built_in_open+0x2f4>)
 8019c18:	f240 123f 	movw	r2, #319	; 0x13f
 8019c1c:	4994      	ldr	r1, [pc, #592]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019c1e:	2003      	movs	r0, #3
 8019c20:	f002 fdf4 	bl	801c80c <lv_log_add>
 8019c24:	e7fe      	b.n	8019c24 <lv_img_decoder_built_in_open+0xa0>
            }
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
 8019c26:	683b      	ldr	r3, [r7, #0]
 8019c28:	6a1b      	ldr	r3, [r3, #32]
 8019c2a:	2208      	movs	r2, #8
 8019c2c:	2100      	movs	r1, #0
 8019c2e:	4618      	mov	r0, r3
 8019c30:	f00d facf 	bl	80271d2 <memset>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 8019c34:	683b      	ldr	r3, [r7, #0]
 8019c36:	6a1b      	ldr	r3, [r3, #32]
 8019c38:	627b      	str	r3, [r7, #36]	; 0x24
        user_data->f                               = lv_mem_alloc(sizeof(f));
 8019c3a:	2008      	movs	r0, #8
 8019c3c:	f002 fe2a 	bl	801c894 <lv_mem_alloc>
 8019c40:	4602      	mov	r2, r0
 8019c42:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c44:	601a      	str	r2, [r3, #0]
        if(user_data->f == NULL) {
 8019c46:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c48:	681b      	ldr	r3, [r3, #0]
 8019c4a:	2b00      	cmp	r3, #0
 8019c4c:	d112      	bne.n	8019c74 <lv_img_decoder_built_in_open+0xf0>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
 8019c4e:	4b89      	ldr	r3, [pc, #548]	; (8019e74 <lv_img_decoder_built_in_open+0x2f0>)
 8019c50:	f240 1247 	movw	r2, #327	; 0x147
 8019c54:	4986      	ldr	r1, [pc, #536]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019c56:	2003      	movs	r0, #3
 8019c58:	f002 fdd8 	bl	801c80c <lv_log_add>
            lv_mem_assert(user_data->f);
 8019c5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c5e:	681b      	ldr	r3, [r3, #0]
 8019c60:	2b00      	cmp	r3, #0
 8019c62:	d107      	bne.n	8019c74 <lv_img_decoder_built_in_open+0xf0>
 8019c64:	4b84      	ldr	r3, [pc, #528]	; (8019e78 <lv_img_decoder_built_in_open+0x2f4>)
 8019c66:	f44f 72a4 	mov.w	r2, #328	; 0x148
 8019c6a:	4981      	ldr	r1, [pc, #516]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019c6c:	2003      	movs	r0, #3
 8019c6e:	f002 fdcd 	bl	801c80c <lv_log_add>
 8019c72:	e7fe      	b.n	8019c72 <lv_img_decoder_built_in_open+0xee>
        }

        memcpy(user_data->f, &f, sizeof(f));
 8019c74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019c76:	681b      	ldr	r3, [r3, #0]
 8019c78:	f107 010c 	add.w	r1, r7, #12
 8019c7c:	2208      	movs	r2, #8
 8019c7e:	4618      	mov	r0, r3
 8019c80:	f00d fa9c 	bl	80271bc <memcpy>
        LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
        return LV_RES_INV;
#endif
    }

    lv_img_cf_t cf = dsc->header.cf;
 8019c84:	683b      	ldr	r3, [r7, #0]
 8019c86:	7c1b      	ldrb	r3, [r3, #16]
 8019c88:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8019c8c:	b2db      	uxtb	r3, r3
 8019c8e:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    /*Process true color formats*/
    if(cf == LV_IMG_CF_TRUE_COLOR || cf == LV_IMG_CF_TRUE_COLOR_ALPHA || cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 8019c92:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019c96:	2b04      	cmp	r3, #4
 8019c98:	d007      	beq.n	8019caa <lv_img_decoder_built_in_open+0x126>
 8019c9a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019c9e:	2b05      	cmp	r3, #5
 8019ca0:	d003      	beq.n	8019caa <lv_img_decoder_built_in_open+0x126>
 8019ca2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019ca6:	2b06      	cmp	r3, #6
 8019ca8:	d10f      	bne.n	8019cca <lv_img_decoder_built_in_open+0x146>
        if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 8019caa:	683b      	ldr	r3, [r7, #0]
 8019cac:	7b1b      	ldrb	r3, [r3, #12]
 8019cae:	2b00      	cmp	r3, #0
 8019cb0:	d106      	bne.n	8019cc0 <lv_img_decoder_built_in_open+0x13c>
            /* In case of uncompressed formats the image stored in the ROM/RAM.
             * So simply give its pointer*/
            dsc->img_data = ((lv_img_dsc_t *)dsc->src)->data;
 8019cb2:	683b      	ldr	r3, [r7, #0]
 8019cb4:	685b      	ldr	r3, [r3, #4]
 8019cb6:	689a      	ldr	r2, [r3, #8]
 8019cb8:	683b      	ldr	r3, [r7, #0]
 8019cba:	615a      	str	r2, [r3, #20]
            return LV_RES_OK;
 8019cbc:	2301      	movs	r3, #1
 8019cbe:	e0ce      	b.n	8019e5e <lv_img_decoder_built_in_open+0x2da>
        } else {
            /*If it's a file it need to be read line by line later*/
            dsc->img_data = NULL;
 8019cc0:	683b      	ldr	r3, [r7, #0]
 8019cc2:	2200      	movs	r2, #0
 8019cc4:	615a      	str	r2, [r3, #20]
            return LV_RES_OK;
 8019cc6:	2301      	movs	r3, #1
 8019cc8:	e0c9      	b.n	8019e5e <lv_img_decoder_built_in_open+0x2da>
        }
    }
    /*Process indexed images. Build a palette*/
    else if(cf == LV_IMG_CF_INDEXED_1BIT || cf == LV_IMG_CF_INDEXED_2BIT || cf == LV_IMG_CF_INDEXED_4BIT ||
 8019cca:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019cce:	2b07      	cmp	r3, #7
 8019cd0:	d00c      	beq.n	8019cec <lv_img_decoder_built_in_open+0x168>
 8019cd2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019cd6:	2b08      	cmp	r3, #8
 8019cd8:	d008      	beq.n	8019cec <lv_img_decoder_built_in_open+0x168>
 8019cda:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019cde:	2b09      	cmp	r3, #9
 8019ce0:	d004      	beq.n	8019cec <lv_img_decoder_built_in_open+0x168>
 8019ce2:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019ce6:	2b0a      	cmp	r3, #10
 8019ce8:	f040 8098 	bne.w	8019e1c <lv_img_decoder_built_in_open+0x298>
            cf == LV_IMG_CF_INDEXED_8BIT) {

#if LV_IMG_CF_INDEXED
        uint8_t px_size       = lv_img_color_format_get_px_size(cf);
 8019cec:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019cf0:	4618      	mov	r0, r3
 8019cf2:	f7fb f89f 	bl	8014e34 <lv_img_color_format_get_px_size>
 8019cf6:	4603      	mov	r3, r0
 8019cf8:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
        uint32_t palette_size = 1 << px_size;
 8019cfc:	f897 3022 	ldrb.w	r3, [r7, #34]	; 0x22
 8019d00:	2201      	movs	r2, #1
 8019d02:	fa02 f303 	lsl.w	r3, r2, r3
 8019d06:	61fb      	str	r3, [r7, #28]

        /*Allocate the palette*/
        if(dsc->user_data == NULL) {
 8019d08:	683b      	ldr	r3, [r7, #0]
 8019d0a:	6a1b      	ldr	r3, [r3, #32]
 8019d0c:	2b00      	cmp	r3, #0
 8019d0e:	d123      	bne.n	8019d58 <lv_img_decoder_built_in_open+0x1d4>
            dsc->user_data = lv_mem_alloc(sizeof(lv_img_decoder_built_in_data_t));
 8019d10:	2008      	movs	r0, #8
 8019d12:	f002 fdbf 	bl	801c894 <lv_mem_alloc>
 8019d16:	4602      	mov	r2, r0
 8019d18:	683b      	ldr	r3, [r7, #0]
 8019d1a:	621a      	str	r2, [r3, #32]
            if(dsc->user_data == NULL) {
 8019d1c:	683b      	ldr	r3, [r7, #0]
 8019d1e:	6a1b      	ldr	r3, [r3, #32]
 8019d20:	2b00      	cmp	r3, #0
 8019d22:	d112      	bne.n	8019d4a <lv_img_decoder_built_in_open+0x1c6>
                LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
 8019d24:	4b53      	ldr	r3, [pc, #332]	; (8019e74 <lv_img_decoder_built_in_open+0x2f0>)
 8019d26:	f240 126d 	movw	r2, #365	; 0x16d
 8019d2a:	4951      	ldr	r1, [pc, #324]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019d2c:	2003      	movs	r0, #3
 8019d2e:	f002 fd6d 	bl	801c80c <lv_log_add>
                lv_mem_assert(dsc->user_data);
 8019d32:	683b      	ldr	r3, [r7, #0]
 8019d34:	6a1b      	ldr	r3, [r3, #32]
 8019d36:	2b00      	cmp	r3, #0
 8019d38:	d107      	bne.n	8019d4a <lv_img_decoder_built_in_open+0x1c6>
 8019d3a:	4b4f      	ldr	r3, [pc, #316]	; (8019e78 <lv_img_decoder_built_in_open+0x2f4>)
 8019d3c:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 8019d40:	494b      	ldr	r1, [pc, #300]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019d42:	2003      	movs	r0, #3
 8019d44:	f002 fd62 	bl	801c80c <lv_log_add>
 8019d48:	e7fe      	b.n	8019d48 <lv_img_decoder_built_in_open+0x1c4>
            }
            memset(dsc->user_data, 0, sizeof(lv_img_decoder_built_in_data_t));
 8019d4a:	683b      	ldr	r3, [r7, #0]
 8019d4c:	6a1b      	ldr	r3, [r3, #32]
 8019d4e:	2208      	movs	r2, #8
 8019d50:	2100      	movs	r1, #0
 8019d52:	4618      	mov	r0, r3
 8019d54:	f00d fa3d 	bl	80271d2 <memset>
        }

        lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 8019d58:	683b      	ldr	r3, [r7, #0]
 8019d5a:	6a1b      	ldr	r3, [r3, #32]
 8019d5c:	61bb      	str	r3, [r7, #24]
        user_data->palette                         = lv_mem_alloc(palette_size * sizeof(lv_color_t));
 8019d5e:	69fb      	ldr	r3, [r7, #28]
 8019d60:	005b      	lsls	r3, r3, #1
 8019d62:	4618      	mov	r0, r3
 8019d64:	f002 fd96 	bl	801c894 <lv_mem_alloc>
 8019d68:	4602      	mov	r2, r0
 8019d6a:	69bb      	ldr	r3, [r7, #24]
 8019d6c:	605a      	str	r2, [r3, #4]
        if(user_data->palette == NULL) {
 8019d6e:	69bb      	ldr	r3, [r7, #24]
 8019d70:	685b      	ldr	r3, [r3, #4]
 8019d72:	2b00      	cmp	r3, #0
 8019d74:	d112      	bne.n	8019d9c <lv_img_decoder_built_in_open+0x218>
            LV_LOG_ERROR("img_decoder_built_in_open: out of memory");
 8019d76:	4b3f      	ldr	r3, [pc, #252]	; (8019e74 <lv_img_decoder_built_in_open+0x2f0>)
 8019d78:	f44f 72bb 	mov.w	r2, #374	; 0x176
 8019d7c:	493c      	ldr	r1, [pc, #240]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019d7e:	2003      	movs	r0, #3
 8019d80:	f002 fd44 	bl	801c80c <lv_log_add>
#if LV_USE_FILESYSTEM
            lv_mem_assert(user_data->f);
 8019d84:	69bb      	ldr	r3, [r7, #24]
 8019d86:	681b      	ldr	r3, [r3, #0]
 8019d88:	2b00      	cmp	r3, #0
 8019d8a:	d107      	bne.n	8019d9c <lv_img_decoder_built_in_open+0x218>
 8019d8c:	4b3a      	ldr	r3, [pc, #232]	; (8019e78 <lv_img_decoder_built_in_open+0x2f4>)
 8019d8e:	f44f 72bc 	mov.w	r2, #376	; 0x178
 8019d92:	4937      	ldr	r1, [pc, #220]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019d94:	2003      	movs	r0, #3
 8019d96:	f002 fd39 	bl	801c80c <lv_log_add>
 8019d9a:	e7fe      	b.n	8019d9a <lv_img_decoder_built_in_open+0x216>
#endif
        }

        if(dsc->src_type == LV_IMG_SRC_FILE) {
 8019d9c:	683b      	ldr	r3, [r7, #0]
 8019d9e:	7b1b      	ldrb	r3, [r3, #12]
 8019da0:	2b01      	cmp	r3, #1
 8019da2:	d10f      	bne.n	8019dc4 <lv_img_decoder_built_in_open+0x240>
            /*Read the palette from file*/
#if LV_USE_FILESYSTEM
            lv_fs_seek(user_data->f, 4); /*Skip the header*/
 8019da4:	69bb      	ldr	r3, [r7, #24]
 8019da6:	681b      	ldr	r3, [r3, #0]
 8019da8:	2104      	movs	r1, #4
 8019daa:	4618      	mov	r0, r3
 8019dac:	f002 fa0f 	bl	801c1ce <lv_fs_seek>
            lv_fs_read(user_data->f, user_data->palette, palette_size * sizeof(lv_color_t), NULL);
 8019db0:	69bb      	ldr	r3, [r7, #24]
 8019db2:	6818      	ldr	r0, [r3, #0]
 8019db4:	69bb      	ldr	r3, [r7, #24]
 8019db6:	6859      	ldr	r1, [r3, #4]
 8019db8:	69fb      	ldr	r3, [r7, #28]
 8019dba:	005a      	lsls	r2, r3, #1
 8019dbc:	2300      	movs	r3, #0
 8019dbe:	f002 f9d0 	bl	801c162 <lv_fs_read>
 8019dc2:	e026      	b.n	8019e12 <lv_img_decoder_built_in_open+0x28e>
            LV_LOG_WARN("Image built-in decoder can read the palette because LV_USE_FILESYSTEM = 0");
            return LV_RES_INV;
#endif
        } else {
            /*The palette begins in the beginning of the image data. Just point to it.*/
            lv_color32_t * palette_p = (lv_color32_t *)((lv_img_dsc_t *)dsc->src)->data;
 8019dc4:	683b      	ldr	r3, [r7, #0]
 8019dc6:	685b      	ldr	r3, [r3, #4]
 8019dc8:	689b      	ldr	r3, [r3, #8]
 8019dca:	617b      	str	r3, [r7, #20]

            uint32_t i;
            for(i = 0; i < palette_size; i++) {
 8019dcc:	2300      	movs	r3, #0
 8019dce:	62fb      	str	r3, [r7, #44]	; 0x2c
 8019dd0:	e01b      	b.n	8019e0a <lv_img_decoder_built_in_open+0x286>
                user_data->palette[i] = lv_color_make(palette_p[i].ch.red, palette_p[i].ch.green, palette_p[i].ch.blue);
 8019dd2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019dd4:	009b      	lsls	r3, r3, #2
 8019dd6:	697a      	ldr	r2, [r7, #20]
 8019dd8:	4413      	add	r3, r2
 8019dda:	7898      	ldrb	r0, [r3, #2]
 8019ddc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019dde:	009b      	lsls	r3, r3, #2
 8019de0:	697a      	ldr	r2, [r7, #20]
 8019de2:	4413      	add	r3, r2
 8019de4:	7859      	ldrb	r1, [r3, #1]
 8019de6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019de8:	009b      	lsls	r3, r3, #2
 8019dea:	697a      	ldr	r2, [r7, #20]
 8019dec:	4413      	add	r3, r2
 8019dee:	781d      	ldrb	r5, [r3, #0]
 8019df0:	69bb      	ldr	r3, [r7, #24]
 8019df2:	685a      	ldr	r2, [r3, #4]
 8019df4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019df6:	005b      	lsls	r3, r3, #1
 8019df8:	18d4      	adds	r4, r2, r3
 8019dfa:	462a      	mov	r2, r5
 8019dfc:	f7ff fd52 	bl	80198a4 <lv_color_make>
 8019e00:	4603      	mov	r3, r0
 8019e02:	8023      	strh	r3, [r4, #0]
            for(i = 0; i < palette_size; i++) {
 8019e04:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8019e06:	3301      	adds	r3, #1
 8019e08:	62fb      	str	r3, [r7, #44]	; 0x2c
 8019e0a:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8019e0c:	69fb      	ldr	r3, [r7, #28]
 8019e0e:	429a      	cmp	r2, r3
 8019e10:	d3df      	bcc.n	8019dd2 <lv_img_decoder_built_in_open+0x24e>
            }
        }

        dsc->img_data = NULL;
 8019e12:	683b      	ldr	r3, [r7, #0]
 8019e14:	2200      	movs	r2, #0
 8019e16:	615a      	str	r2, [r3, #20]
        return LV_RES_OK;
 8019e18:	2301      	movs	r3, #1
 8019e1a:	e020      	b.n	8019e5e <lv_img_decoder_built_in_open+0x2da>
        LV_LOG_WARN("Indexed (palette) images are not enabled in lv_conf.h. See LV_IMG_CF_INDEXED");
        return LV_RES_INV;
#endif
    }
    /*Alpha indexed images. */
    else if(cf == LV_IMG_CF_ALPHA_1BIT || cf == LV_IMG_CF_ALPHA_2BIT || cf == LV_IMG_CF_ALPHA_4BIT ||
 8019e1c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019e20:	2b0b      	cmp	r3, #11
 8019e22:	d00b      	beq.n	8019e3c <lv_img_decoder_built_in_open+0x2b8>
 8019e24:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019e28:	2b0c      	cmp	r3, #12
 8019e2a:	d007      	beq.n	8019e3c <lv_img_decoder_built_in_open+0x2b8>
 8019e2c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019e30:	2b0d      	cmp	r3, #13
 8019e32:	d003      	beq.n	8019e3c <lv_img_decoder_built_in_open+0x2b8>
 8019e34:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8019e38:	2b0e      	cmp	r3, #14
 8019e3a:	d104      	bne.n	8019e46 <lv_img_decoder_built_in_open+0x2c2>
            cf == LV_IMG_CF_ALPHA_8BIT) {
#if LV_IMG_CF_ALPHA
        dsc->img_data = NULL;
 8019e3c:	683b      	ldr	r3, [r7, #0]
 8019e3e:	2200      	movs	r2, #0
 8019e40:	615a      	str	r2, [r3, #20]
        return LV_RES_OK; /*Nothing to process*/
 8019e42:	2301      	movs	r3, #1
 8019e44:	e00b      	b.n	8019e5e <lv_img_decoder_built_in_open+0x2da>
#endif
    }
    /*Unknown format. Can't decode it.*/
    else {
        /*Free the potentially allocated memories*/
        lv_img_decoder_built_in_close(decoder, dsc);
 8019e46:	6839      	ldr	r1, [r7, #0]
 8019e48:	6878      	ldr	r0, [r7, #4]
 8019e4a:	f000 f8b7 	bl	8019fbc <lv_img_decoder_built_in_close>

        LV_LOG_WARN("Image decoder open: unknown color format")
 8019e4e:	4b0b      	ldr	r3, [pc, #44]	; (8019e7c <lv_img_decoder_built_in_open+0x2f8>)
 8019e50:	f44f 72d3 	mov.w	r2, #422	; 0x1a6
 8019e54:	4906      	ldr	r1, [pc, #24]	; (8019e70 <lv_img_decoder_built_in_open+0x2ec>)
 8019e56:	2002      	movs	r0, #2
 8019e58:	f002 fcd8 	bl	801c80c <lv_log_add>
        return LV_RES_INV;
 8019e5c:	2300      	movs	r3, #0
    }
}
 8019e5e:	4618      	mov	r0, r3
 8019e60:	3730      	adds	r7, #48	; 0x30
 8019e62:	46bd      	mov	sp, r7
 8019e64:	bdb0      	pop	{r4, r5, r7, pc}
 8019e66:	bf00      	nop
 8019e68:	08028c48 	.word	0x08028c48
 8019e6c:	08028c4c 	.word	0x08028c4c
 8019e70:	08028be8 	.word	0x08028be8
 8019e74:	08028c78 	.word	0x08028c78
 8019e78:	08028c10 	.word	0x08028c10
 8019e7c:	08028ca4 	.word	0x08028ca4

08019e80 <lv_img_decoder_built_in_read_line>:

static lv_res_t lv_img_decoder_built_in_read_line(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc, lv_coord_t x,
                                                  lv_coord_t y, lv_coord_t len, uint8_t * buf)
{
 8019e80:	b580      	push	{r7, lr}
 8019e82:	b088      	sub	sp, #32
 8019e84:	af02      	add	r7, sp, #8
 8019e86:	60f8      	str	r0, [r7, #12]
 8019e88:	60b9      	str	r1, [r7, #8]
 8019e8a:	4611      	mov	r1, r2
 8019e8c:	461a      	mov	r2, r3
 8019e8e:	460b      	mov	r3, r1
 8019e90:	80fb      	strh	r3, [r7, #6]
 8019e92:	4613      	mov	r3, r2
 8019e94:	80bb      	strh	r3, [r7, #4]
    (void)decoder; /*Unused*/

    lv_res_t res = LV_RES_INV;
 8019e96:	2300      	movs	r3, #0
 8019e98:	75fb      	strb	r3, [r7, #23]

    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 8019e9a:	68bb      	ldr	r3, [r7, #8]
 8019e9c:	7c1b      	ldrb	r3, [r3, #16]
 8019e9e:	f003 031f 	and.w	r3, r3, #31
 8019ea2:	b2db      	uxtb	r3, r3
 8019ea4:	2b04      	cmp	r3, #4
 8019ea6:	d00d      	beq.n	8019ec4 <lv_img_decoder_built_in_read_line+0x44>
 8019ea8:	68bb      	ldr	r3, [r7, #8]
 8019eaa:	7c1b      	ldrb	r3, [r3, #16]
 8019eac:	f003 031f 	and.w	r3, r3, #31
 8019eb0:	b2db      	uxtb	r3, r3
 8019eb2:	2b05      	cmp	r3, #5
 8019eb4:	d006      	beq.n	8019ec4 <lv_img_decoder_built_in_read_line+0x44>
       dsc->header.cf == LV_IMG_CF_TRUE_COLOR_CHROMA_KEYED) {
 8019eb6:	68bb      	ldr	r3, [r7, #8]
 8019eb8:	7c1b      	ldrb	r3, [r3, #16]
 8019eba:	f003 031f 	and.w	r3, r3, #31
 8019ebe:	b2db      	uxtb	r3, r3
    if(dsc->header.cf == LV_IMG_CF_TRUE_COLOR || dsc->header.cf == LV_IMG_CF_TRUE_COLOR_ALPHA ||
 8019ec0:	2b06      	cmp	r3, #6
 8019ec2:	d112      	bne.n	8019eea <lv_img_decoder_built_in_read_line+0x6a>
        /* For TRUE_COLOR images read line required only for files.
         * For variables the image data was returned in `open`*/
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 8019ec4:	68bb      	ldr	r3, [r7, #8]
 8019ec6:	7b1b      	ldrb	r3, [r3, #12]
 8019ec8:	2b01      	cmp	r3, #1
 8019eca:	d16d      	bne.n	8019fa8 <lv_img_decoder_built_in_read_line+0x128>
            res = lv_img_decoder_built_in_line_true_color(dsc, x, y, len, buf);
 8019ecc:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 8019ed0:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8019ed4:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 8019ed8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019eda:	9300      	str	r3, [sp, #0]
 8019edc:	4603      	mov	r3, r0
 8019ede:	68b8      	ldr	r0, [r7, #8]
 8019ee0:	f000 f898 	bl	801a014 <lv_img_decoder_built_in_line_true_color>
 8019ee4:	4603      	mov	r3, r0
 8019ee6:	75fb      	strb	r3, [r7, #23]
        if(dsc->src_type == LV_IMG_SRC_FILE) {
 8019ee8:	e05e      	b.n	8019fa8 <lv_img_decoder_built_in_read_line+0x128>
        }
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 8019eea:	68bb      	ldr	r3, [r7, #8]
 8019eec:	7c1b      	ldrb	r3, [r3, #16]
 8019eee:	f003 031f 	and.w	r3, r3, #31
 8019ef2:	b2db      	uxtb	r3, r3
 8019ef4:	2b0b      	cmp	r3, #11
 8019ef6:	d014      	beq.n	8019f22 <lv_img_decoder_built_in_read_line+0xa2>
 8019ef8:	68bb      	ldr	r3, [r7, #8]
 8019efa:	7c1b      	ldrb	r3, [r3, #16]
 8019efc:	f003 031f 	and.w	r3, r3, #31
 8019f00:	b2db      	uxtb	r3, r3
 8019f02:	2b0c      	cmp	r3, #12
 8019f04:	d00d      	beq.n	8019f22 <lv_img_decoder_built_in_read_line+0xa2>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 8019f06:	68bb      	ldr	r3, [r7, #8]
 8019f08:	7c1b      	ldrb	r3, [r3, #16]
 8019f0a:	f003 031f 	and.w	r3, r3, #31
 8019f0e:	b2db      	uxtb	r3, r3
    } else if(dsc->header.cf == LV_IMG_CF_ALPHA_1BIT || dsc->header.cf == LV_IMG_CF_ALPHA_2BIT ||
 8019f10:	2b0d      	cmp	r3, #13
 8019f12:	d006      	beq.n	8019f22 <lv_img_decoder_built_in_read_line+0xa2>
              dsc->header.cf == LV_IMG_CF_ALPHA_4BIT || dsc->header.cf == LV_IMG_CF_ALPHA_8BIT) {
 8019f14:	68bb      	ldr	r3, [r7, #8]
 8019f16:	7c1b      	ldrb	r3, [r3, #16]
 8019f18:	f003 031f 	and.w	r3, r3, #31
 8019f1c:	b2db      	uxtb	r3, r3
 8019f1e:	2b0e      	cmp	r3, #14
 8019f20:	d10e      	bne.n	8019f40 <lv_img_decoder_built_in_read_line+0xc0>

        res = lv_img_decoder_built_in_line_alpha(dsc, x, y, len, buf);
 8019f22:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 8019f26:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8019f2a:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 8019f2e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f30:	9300      	str	r3, [sp, #0]
 8019f32:	4603      	mov	r3, r0
 8019f34:	68b8      	ldr	r0, [r7, #8]
 8019f36:	f000 f8df 	bl	801a0f8 <lv_img_decoder_built_in_line_alpha>
 8019f3a:	4603      	mov	r3, r0
 8019f3c:	75fb      	strb	r3, [r7, #23]
 8019f3e:	e033      	b.n	8019fa8 <lv_img_decoder_built_in_read_line+0x128>
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 8019f40:	68bb      	ldr	r3, [r7, #8]
 8019f42:	7c1b      	ldrb	r3, [r3, #16]
 8019f44:	f003 031f 	and.w	r3, r3, #31
 8019f48:	b2db      	uxtb	r3, r3
 8019f4a:	2b07      	cmp	r3, #7
 8019f4c:	d014      	beq.n	8019f78 <lv_img_decoder_built_in_read_line+0xf8>
 8019f4e:	68bb      	ldr	r3, [r7, #8]
 8019f50:	7c1b      	ldrb	r3, [r3, #16]
 8019f52:	f003 031f 	and.w	r3, r3, #31
 8019f56:	b2db      	uxtb	r3, r3
 8019f58:	2b08      	cmp	r3, #8
 8019f5a:	d00d      	beq.n	8019f78 <lv_img_decoder_built_in_read_line+0xf8>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 8019f5c:	68bb      	ldr	r3, [r7, #8]
 8019f5e:	7c1b      	ldrb	r3, [r3, #16]
 8019f60:	f003 031f 	and.w	r3, r3, #31
 8019f64:	b2db      	uxtb	r3, r3
    } else if(dsc->header.cf == LV_IMG_CF_INDEXED_1BIT || dsc->header.cf == LV_IMG_CF_INDEXED_2BIT ||
 8019f66:	2b09      	cmp	r3, #9
 8019f68:	d006      	beq.n	8019f78 <lv_img_decoder_built_in_read_line+0xf8>
              dsc->header.cf == LV_IMG_CF_INDEXED_4BIT || dsc->header.cf == LV_IMG_CF_INDEXED_8BIT) {
 8019f6a:	68bb      	ldr	r3, [r7, #8]
 8019f6c:	7c1b      	ldrb	r3, [r3, #16]
 8019f6e:	f003 031f 	and.w	r3, r3, #31
 8019f72:	b2db      	uxtb	r3, r3
 8019f74:	2b0a      	cmp	r3, #10
 8019f76:	d10e      	bne.n	8019f96 <lv_img_decoder_built_in_read_line+0x116>
        res = lv_img_decoder_built_in_line_indexed(dsc, x, y, len, buf);
 8019f78:	f9b7 0020 	ldrsh.w	r0, [r7, #32]
 8019f7c:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 8019f80:	f9b7 1006 	ldrsh.w	r1, [r7, #6]
 8019f84:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8019f86:	9300      	str	r3, [sp, #0]
 8019f88:	4603      	mov	r3, r0
 8019f8a:	68b8      	ldr	r0, [r7, #8]
 8019f8c:	f000 faca 	bl	801a524 <lv_img_decoder_built_in_line_indexed>
 8019f90:	4603      	mov	r3, r0
 8019f92:	75fb      	strb	r3, [r7, #23]
 8019f94:	e008      	b.n	8019fa8 <lv_img_decoder_built_in_read_line+0x128>
    } else {
        LV_LOG_WARN("Built-in image decoder read not supports the color format");
 8019f96:	4b07      	ldr	r3, [pc, #28]	; (8019fb4 <lv_img_decoder_built_in_read_line+0x134>)
 8019f98:	f240 12c1 	movw	r2, #449	; 0x1c1
 8019f9c:	4906      	ldr	r1, [pc, #24]	; (8019fb8 <lv_img_decoder_built_in_read_line+0x138>)
 8019f9e:	2002      	movs	r0, #2
 8019fa0:	f002 fc34 	bl	801c80c <lv_log_add>
        return LV_RES_INV;
 8019fa4:	2300      	movs	r3, #0
 8019fa6:	e000      	b.n	8019faa <lv_img_decoder_built_in_read_line+0x12a>
    }

    return res;
 8019fa8:	7dfb      	ldrb	r3, [r7, #23]
}
 8019faa:	4618      	mov	r0, r3
 8019fac:	3718      	adds	r7, #24
 8019fae:	46bd      	mov	sp, r7
 8019fb0:	bd80      	pop	{r7, pc}
 8019fb2:	bf00      	nop
 8019fb4:	08028cd0 	.word	0x08028cd0
 8019fb8:	08028be8 	.word	0x08028be8

08019fbc <lv_img_decoder_built_in_close>:

static void lv_img_decoder_built_in_close(lv_img_decoder_t * decoder, lv_img_decoder_dsc_t * dsc)
{
 8019fbc:	b580      	push	{r7, lr}
 8019fbe:	b084      	sub	sp, #16
 8019fc0:	af00      	add	r7, sp, #0
 8019fc2:	6078      	str	r0, [r7, #4]
 8019fc4:	6039      	str	r1, [r7, #0]
    (void)decoder; /*Unused*/

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 8019fc6:	683b      	ldr	r3, [r7, #0]
 8019fc8:	6a1b      	ldr	r3, [r3, #32]
 8019fca:	60fb      	str	r3, [r7, #12]
    if(user_data) {
 8019fcc:	68fb      	ldr	r3, [r7, #12]
 8019fce:	2b00      	cmp	r3, #0
 8019fd0:	d01c      	beq.n	801a00c <lv_img_decoder_built_in_close+0x50>
#if LV_USE_FILESYSTEM
        if(user_data->f) {
 8019fd2:	68fb      	ldr	r3, [r7, #12]
 8019fd4:	681b      	ldr	r3, [r3, #0]
 8019fd6:	2b00      	cmp	r3, #0
 8019fd8:	d009      	beq.n	8019fee <lv_img_decoder_built_in_close+0x32>
            lv_fs_close(user_data->f);
 8019fda:	68fb      	ldr	r3, [r7, #12]
 8019fdc:	681b      	ldr	r3, [r3, #0]
 8019fde:	4618      	mov	r0, r3
 8019fe0:	f002 f890 	bl	801c104 <lv_fs_close>
            lv_mem_free(user_data->f);
 8019fe4:	68fb      	ldr	r3, [r7, #12]
 8019fe6:	681b      	ldr	r3, [r3, #0]
 8019fe8:	4618      	mov	r0, r3
 8019fea:	f002 fc9b 	bl	801c924 <lv_mem_free>
        }
#endif
        if(user_data->palette) lv_mem_free(user_data->palette);
 8019fee:	68fb      	ldr	r3, [r7, #12]
 8019ff0:	685b      	ldr	r3, [r3, #4]
 8019ff2:	2b00      	cmp	r3, #0
 8019ff4:	d004      	beq.n	801a000 <lv_img_decoder_built_in_close+0x44>
 8019ff6:	68fb      	ldr	r3, [r7, #12]
 8019ff8:	685b      	ldr	r3, [r3, #4]
 8019ffa:	4618      	mov	r0, r3
 8019ffc:	f002 fc92 	bl	801c924 <lv_mem_free>

        lv_mem_free(user_data);
 801a000:	68f8      	ldr	r0, [r7, #12]
 801a002:	f002 fc8f 	bl	801c924 <lv_mem_free>

        dsc->user_data = NULL;
 801a006:	683b      	ldr	r3, [r7, #0]
 801a008:	2200      	movs	r2, #0
 801a00a:	621a      	str	r2, [r3, #32]
    }
}
 801a00c:	bf00      	nop
 801a00e:	3710      	adds	r7, #16
 801a010:	46bd      	mov	sp, r7
 801a012:	bd80      	pop	{r7, pc}

0801a014 <lv_img_decoder_built_in_line_true_color>:

static lv_res_t lv_img_decoder_built_in_line_true_color(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                        lv_coord_t len, uint8_t * buf)
{
 801a014:	b580      	push	{r7, lr}
 801a016:	b08a      	sub	sp, #40	; 0x28
 801a018:	af00      	add	r7, sp, #0
 801a01a:	60f8      	str	r0, [r7, #12]
 801a01c:	4608      	mov	r0, r1
 801a01e:	4611      	mov	r1, r2
 801a020:	461a      	mov	r2, r3
 801a022:	4603      	mov	r3, r0
 801a024:	817b      	strh	r3, [r7, #10]
 801a026:	460b      	mov	r3, r1
 801a028:	813b      	strh	r3, [r7, #8]
 801a02a:	4613      	mov	r3, r2
 801a02c:	80fb      	strh	r3, [r7, #6]
#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801a02e:	68fb      	ldr	r3, [r7, #12]
 801a030:	6a1b      	ldr	r3, [r3, #32]
 801a032:	627b      	str	r3, [r7, #36]	; 0x24
    lv_fs_res_t res;
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
 801a034:	68fb      	ldr	r3, [r7, #12]
 801a036:	7c1b      	ldrb	r3, [r3, #16]
 801a038:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801a03c:	b2db      	uxtb	r3, r3
 801a03e:	4618      	mov	r0, r3
 801a040:	f7fa fef8 	bl	8014e34 <lv_img_color_format_get_px_size>
 801a044:	4603      	mov	r3, r0
 801a046:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

    uint32_t pos = ((y * dsc->header.w + x) * px_size) >> 3;
 801a04a:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 801a04e:	68fa      	ldr	r2, [r7, #12]
 801a050:	6912      	ldr	r2, [r2, #16]
 801a052:	f3c2 228a 	ubfx	r2, r2, #10, #11
 801a056:	b292      	uxth	r2, r2
 801a058:	fb02 f203 	mul.w	r2, r2, r3
 801a05c:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 801a060:	4413      	add	r3, r2
 801a062:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 801a066:	fb02 f303 	mul.w	r3, r2, r3
 801a06a:	10db      	asrs	r3, r3, #3
 801a06c:	61fb      	str	r3, [r7, #28]
    pos += 4; /*Skip the header*/
 801a06e:	69fb      	ldr	r3, [r7, #28]
 801a070:	3304      	adds	r3, #4
 801a072:	61fb      	str	r3, [r7, #28]
    res = lv_fs_seek(user_data->f, pos);
 801a074:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a076:	681b      	ldr	r3, [r3, #0]
 801a078:	69f9      	ldr	r1, [r7, #28]
 801a07a:	4618      	mov	r0, r3
 801a07c:	f002 f8a7 	bl	801c1ce <lv_fs_seek>
 801a080:	4603      	mov	r3, r0
 801a082:	76fb      	strb	r3, [r7, #27]
    if(res != LV_FS_RES_OK) {
 801a084:	7efb      	ldrb	r3, [r7, #27]
 801a086:	2b00      	cmp	r3, #0
 801a088:	d008      	beq.n	801a09c <lv_img_decoder_built_in_line_true_color+0x88>
        LV_LOG_WARN("Built-in image decoder seek failed");
 801a08a:	4b18      	ldr	r3, [pc, #96]	; (801a0ec <lv_img_decoder_built_in_line_true_color+0xd8>)
 801a08c:	f44f 72f4 	mov.w	r2, #488	; 0x1e8
 801a090:	4917      	ldr	r1, [pc, #92]	; (801a0f0 <lv_img_decoder_built_in_line_true_color+0xdc>)
 801a092:	2002      	movs	r0, #2
 801a094:	f002 fbba 	bl	801c80c <lv_log_add>
        return LV_RES_INV;
 801a098:	2300      	movs	r3, #0
 801a09a:	e023      	b.n	801a0e4 <lv_img_decoder_built_in_line_true_color+0xd0>
    }
    uint32_t btr = len * (px_size >> 3);
 801a09c:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 801a0a0:	f897 2023 	ldrb.w	r2, [r7, #35]	; 0x23
 801a0a4:	08d2      	lsrs	r2, r2, #3
 801a0a6:	b2d2      	uxtb	r2, r2
 801a0a8:	fb02 f303 	mul.w	r3, r2, r3
 801a0ac:	617b      	str	r3, [r7, #20]
    uint32_t br  = 0;
 801a0ae:	2300      	movs	r3, #0
 801a0b0:	613b      	str	r3, [r7, #16]
    lv_fs_read(user_data->f, buf, btr, &br);
 801a0b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801a0b4:	6818      	ldr	r0, [r3, #0]
 801a0b6:	f107 0310 	add.w	r3, r7, #16
 801a0ba:	697a      	ldr	r2, [r7, #20]
 801a0bc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801a0be:	f002 f850 	bl	801c162 <lv_fs_read>
    if(res != LV_FS_RES_OK || btr != br) {
 801a0c2:	7efb      	ldrb	r3, [r7, #27]
 801a0c4:	2b00      	cmp	r3, #0
 801a0c6:	d103      	bne.n	801a0d0 <lv_img_decoder_built_in_line_true_color+0xbc>
 801a0c8:	693b      	ldr	r3, [r7, #16]
 801a0ca:	697a      	ldr	r2, [r7, #20]
 801a0cc:	429a      	cmp	r2, r3
 801a0ce:	d008      	beq.n	801a0e2 <lv_img_decoder_built_in_line_true_color+0xce>
        LV_LOG_WARN("Built-in image decoder read failed");
 801a0d0:	4b08      	ldr	r3, [pc, #32]	; (801a0f4 <lv_img_decoder_built_in_line_true_color+0xe0>)
 801a0d2:	f240 12ef 	movw	r2, #495	; 0x1ef
 801a0d6:	4906      	ldr	r1, [pc, #24]	; (801a0f0 <lv_img_decoder_built_in_line_true_color+0xdc>)
 801a0d8:	2002      	movs	r0, #2
 801a0da:	f002 fb97 	bl	801c80c <lv_log_add>
        return LV_RES_INV;
 801a0de:	2300      	movs	r3, #0
 801a0e0:	e000      	b.n	801a0e4 <lv_img_decoder_built_in_line_true_color+0xd0>
    }

    return LV_RES_OK;
 801a0e2:	2301      	movs	r3, #1
#else
    LV_LOG_WARN("Image built-in decoder cannot read file because LV_USE_FILESYSTEM = 0");
    return LV_RES_INV;
#endif
}
 801a0e4:	4618      	mov	r0, r3
 801a0e6:	3728      	adds	r7, #40	; 0x28
 801a0e8:	46bd      	mov	sp, r7
 801a0ea:	bd80      	pop	{r7, pc}
 801a0ec:	08028d0c 	.word	0x08028d0c
 801a0f0:	08028be8 	.word	0x08028be8
 801a0f4:	08028d30 	.word	0x08028d30

0801a0f8 <lv_img_decoder_built_in_line_alpha>:

static lv_res_t lv_img_decoder_built_in_line_alpha(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                   lv_coord_t len, uint8_t * buf)
{
 801a0f8:	b590      	push	{r4, r7, lr}
 801a0fa:	f5ad 7d0d 	sub.w	sp, sp, #564	; 0x234
 801a0fe:	af00      	add	r7, sp, #0
 801a100:	f107 040c 	add.w	r4, r7, #12
 801a104:	6020      	str	r0, [r4, #0]
 801a106:	460c      	mov	r4, r1
 801a108:	4610      	mov	r0, r2
 801a10a:	4619      	mov	r1, r3
 801a10c:	f107 030a 	add.w	r3, r7, #10
 801a110:	4622      	mov	r2, r4
 801a112:	801a      	strh	r2, [r3, #0]
 801a114:	f107 0308 	add.w	r3, r7, #8
 801a118:	4602      	mov	r2, r0
 801a11a:	801a      	strh	r2, [r3, #0]
 801a11c:	1dbb      	adds	r3, r7, #6
 801a11e:	460a      	mov	r2, r1
 801a120:	801a      	strh	r2, [r3, #0]

#if LV_IMG_CF_ALPHA
    const lv_opa_t alpha1_opa_table[2]  = {0, 255};          /*Opacity mapping with bpp = 1 (Just for compatibility)*/
 801a122:	2300      	movs	r3, #0
 801a124:	f887 3208 	strb.w	r3, [r7, #520]	; 0x208
 801a128:	23ff      	movs	r3, #255	; 0xff
 801a12a:	f887 3209 	strb.w	r3, [r7, #521]	; 0x209
    const lv_opa_t alpha2_opa_table[4]  = {0, 85, 170, 255}; /*Opacity mapping with bpp = 2*/
 801a12e:	4bcc      	ldr	r3, [pc, #816]	; (801a460 <lv_img_decoder_built_in_line_alpha+0x368>)
 801a130:	681b      	ldr	r3, [r3, #0]
 801a132:	f8c7 3204 	str.w	r3, [r7, #516]	; 0x204
    const lv_opa_t alpha4_opa_table[16] = {0,  17, 34,  51,  /*Opacity mapping with bpp = 4*/
 801a136:	4bcb      	ldr	r3, [pc, #812]	; (801a464 <lv_img_decoder_built_in_line_alpha+0x36c>)
 801a138:	f507 74fa 	add.w	r4, r7, #500	; 0x1f4
 801a13c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801a13e:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
                                           68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255};

    /*Simply fill the buffer with the color. Later only the alpha value will be modified.*/
    lv_color_t bg_color = dsc->style->image.color;
 801a142:	f107 030c 	add.w	r3, r7, #12
 801a146:	681b      	ldr	r3, [r3, #0]
 801a148:	689b      	ldr	r3, [r3, #8]
 801a14a:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 801a14c:	f8a7 31f0 	strh.w	r3, [r7, #496]	; 0x1f0
    lv_coord_t i;
    for(i = 0; i < len; i++) {
 801a150:	2300      	movs	r3, #0
 801a152:	f8a7 322e 	strh.w	r3, [r7, #558]	; 0x22e
 801a156:	e022      	b.n	801a19e <lv_img_decoder_built_in_line_alpha+0xa6>
#if LV_COLOR_DEPTH == 8 || LV_COLOR_DEPTH == 1
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full;
#elif LV_COLOR_DEPTH == 16
        /*Because of Alpha byte 16 bit color can start on odd address which can cause crash*/
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE] = bg_color.full & 0xFF;
 801a158:	f8b7 11f0 	ldrh.w	r1, [r7, #496]	; 0x1f0
 801a15c:	f9b7 222e 	ldrsh.w	r2, [r7, #558]	; 0x22e
 801a160:	4613      	mov	r3, r2
 801a162:	005b      	lsls	r3, r3, #1
 801a164:	4413      	add	r3, r2
 801a166:	461a      	mov	r2, r3
 801a168:	f8d7 3240 	ldr.w	r3, [r7, #576]	; 0x240
 801a16c:	4413      	add	r3, r2
 801a16e:	b2ca      	uxtb	r2, r1
 801a170:	701a      	strb	r2, [r3, #0]
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + 1] = (bg_color.full >> 8) & 0xFF;
 801a172:	f8b7 31f0 	ldrh.w	r3, [r7, #496]	; 0x1f0
 801a176:	0a1b      	lsrs	r3, r3, #8
 801a178:	b299      	uxth	r1, r3
 801a17a:	f9b7 222e 	ldrsh.w	r2, [r7, #558]	; 0x22e
 801a17e:	4613      	mov	r3, r2
 801a180:	005b      	lsls	r3, r3, #1
 801a182:	4413      	add	r3, r2
 801a184:	3301      	adds	r3, #1
 801a186:	f8d7 2240 	ldr.w	r2, [r7, #576]	; 0x240
 801a18a:	4413      	add	r3, r2
 801a18c:	b2ca      	uxtb	r2, r1
 801a18e:	701a      	strb	r2, [r3, #0]
    for(i = 0; i < len; i++) {
 801a190:	f9b7 322e 	ldrsh.w	r3, [r7, #558]	; 0x22e
 801a194:	b29b      	uxth	r3, r3
 801a196:	3301      	adds	r3, #1
 801a198:	b29b      	uxth	r3, r3
 801a19a:	f8a7 322e 	strh.w	r3, [r7, #558]	; 0x22e
 801a19e:	1dbb      	adds	r3, r7, #6
 801a1a0:	f9b7 222e 	ldrsh.w	r2, [r7, #558]	; 0x22e
 801a1a4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a1a8:	429a      	cmp	r2, r3
 801a1aa:	dbd5      	blt.n	801a158 <lv_img_decoder_built_in_line_alpha+0x60>
#else
#error "Invalid LV_COLOR_DEPTH. Check it in lv_conf.h"
#endif
    }

    const lv_opa_t * opa_table = NULL;
 801a1ac:	2300      	movs	r3, #0
 801a1ae:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
    uint8_t px_size            = lv_img_color_format_get_px_size(dsc->header.cf);
 801a1b2:	f107 030c 	add.w	r3, r7, #12
 801a1b6:	681b      	ldr	r3, [r3, #0]
 801a1b8:	7c1b      	ldrb	r3, [r3, #16]
 801a1ba:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801a1be:	b2db      	uxtb	r3, r3
 801a1c0:	4618      	mov	r0, r3
 801a1c2:	f7fa fe37 	bl	8014e34 <lv_img_color_format_get_px_size>
 801a1c6:	4603      	mov	r3, r0
 801a1c8:	f887 3217 	strb.w	r3, [r7, #535]	; 0x217
    uint16_t mask              = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 801a1cc:	f897 3217 	ldrb.w	r3, [r7, #535]	; 0x217
 801a1d0:	2201      	movs	r2, #1
 801a1d2:	fa02 f303 	lsl.w	r3, r2, r3
 801a1d6:	b29b      	uxth	r3, r3
 801a1d8:	3b01      	subs	r3, #1
 801a1da:	f8a7 3214 	strh.w	r3, [r7, #532]	; 0x214

    lv_coord_t w = 0;
 801a1de:	2300      	movs	r3, #0
 801a1e0:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
    uint32_t ofs = 0;
 801a1e4:	2300      	movs	r3, #0
 801a1e6:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
    int8_t pos   = 0;
 801a1ea:	2300      	movs	r3, #0
 801a1ec:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
    switch(dsc->header.cf) {
 801a1f0:	f107 030c 	add.w	r3, r7, #12
 801a1f4:	681b      	ldr	r3, [r3, #0]
 801a1f6:	7c1b      	ldrb	r3, [r3, #16]
 801a1f8:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801a1fc:	b2db      	uxtb	r3, r3
 801a1fe:	3b0b      	subs	r3, #11
 801a200:	2b03      	cmp	r3, #3
 801a202:	f200 80ef 	bhi.w	801a3e4 <lv_img_decoder_built_in_line_alpha+0x2ec>
 801a206:	a201      	add	r2, pc, #4	; (adr r2, 801a20c <lv_img_decoder_built_in_line_alpha+0x114>)
 801a208:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a20c:	0801a21d 	.word	0x0801a21d
 801a210:	0801a29d 	.word	0x0801a29d
 801a214:	0801a321 	.word	0x0801a321
 801a218:	0801a3a5 	.word	0x0801a3a5
        case LV_IMG_CF_ALPHA_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 801a21c:	f107 030c 	add.w	r3, r7, #12
 801a220:	681b      	ldr	r3, [r3, #0]
 801a222:	691b      	ldr	r3, [r3, #16]
 801a224:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a228:	b29b      	uxth	r3, r3
 801a22a:	10db      	asrs	r3, r3, #3
 801a22c:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            if(dsc->header.w & 0x7) w++;
 801a230:	f107 030c 	add.w	r3, r7, #12
 801a234:	681b      	ldr	r3, [r3, #0]
 801a236:	691b      	ldr	r3, [r3, #16]
 801a238:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a23c:	b29b      	uxth	r3, r3
 801a23e:	f003 0307 	and.w	r3, r3, #7
 801a242:	2b00      	cmp	r3, #0
 801a244:	d006      	beq.n	801a254 <lv_img_decoder_built_in_line_alpha+0x15c>
 801a246:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a24a:	b29b      	uxth	r3, r3
 801a24c:	3301      	adds	r3, #1
 801a24e:	b29b      	uxth	r3, r3
 801a250:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            ofs += w * y + (x >> 3); /*First pixel*/
 801a254:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a258:	f107 0208 	add.w	r2, r7, #8
 801a25c:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a260:	fb02 f303 	mul.w	r3, r2, r3
 801a264:	f107 020a 	add.w	r2, r7, #10
 801a268:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a26c:	10d2      	asrs	r2, r2, #3
 801a26e:	b212      	sxth	r2, r2
 801a270:	4413      	add	r3, r2
 801a272:	461a      	mov	r2, r3
 801a274:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801a278:	4413      	add	r3, r2
 801a27a:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
            pos       = 7 - (x & 0x7);
 801a27e:	f107 030a 	add.w	r3, r7, #10
 801a282:	881b      	ldrh	r3, [r3, #0]
 801a284:	b25b      	sxtb	r3, r3
 801a286:	43db      	mvns	r3, r3
 801a288:	b25b      	sxtb	r3, r3
 801a28a:	f003 0307 	and.w	r3, r3, #7
 801a28e:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
            opa_table = alpha1_opa_table;
 801a292:	f507 7302 	add.w	r3, r7, #520	; 0x208
 801a296:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
            break;
 801a29a:	e0a3      	b.n	801a3e4 <lv_img_decoder_built_in_line_alpha+0x2ec>
        case LV_IMG_CF_ALPHA_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 801a29c:	f107 030c 	add.w	r3, r7, #12
 801a2a0:	681b      	ldr	r3, [r3, #0]
 801a2a2:	691b      	ldr	r3, [r3, #16]
 801a2a4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a2a8:	b29b      	uxth	r3, r3
 801a2aa:	109b      	asrs	r3, r3, #2
 801a2ac:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            if(dsc->header.w & 0x3) w++;
 801a2b0:	f107 030c 	add.w	r3, r7, #12
 801a2b4:	681b      	ldr	r3, [r3, #0]
 801a2b6:	691b      	ldr	r3, [r3, #16]
 801a2b8:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a2bc:	b29b      	uxth	r3, r3
 801a2be:	f003 0303 	and.w	r3, r3, #3
 801a2c2:	2b00      	cmp	r3, #0
 801a2c4:	d006      	beq.n	801a2d4 <lv_img_decoder_built_in_line_alpha+0x1dc>
 801a2c6:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a2ca:	b29b      	uxth	r3, r3
 801a2cc:	3301      	adds	r3, #1
 801a2ce:	b29b      	uxth	r3, r3
 801a2d0:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            ofs += w * y + (x >> 2); /*First pixel*/
 801a2d4:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a2d8:	f107 0208 	add.w	r2, r7, #8
 801a2dc:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a2e0:	fb02 f303 	mul.w	r3, r2, r3
 801a2e4:	f107 020a 	add.w	r2, r7, #10
 801a2e8:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a2ec:	1092      	asrs	r2, r2, #2
 801a2ee:	b212      	sxth	r2, r2
 801a2f0:	4413      	add	r3, r2
 801a2f2:	461a      	mov	r2, r3
 801a2f4:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801a2f8:	4413      	add	r3, r2
 801a2fa:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
            pos       = 6 - ((x & 0x3) * 2);
 801a2fe:	f107 030a 	add.w	r3, r7, #10
 801a302:	881b      	ldrh	r3, [r3, #0]
 801a304:	43db      	mvns	r3, r3
 801a306:	b2db      	uxtb	r3, r3
 801a308:	f003 0303 	and.w	r3, r3, #3
 801a30c:	b2db      	uxtb	r3, r3
 801a30e:	005b      	lsls	r3, r3, #1
 801a310:	b2db      	uxtb	r3, r3
 801a312:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
            opa_table = alpha2_opa_table;
 801a316:	f507 7301 	add.w	r3, r7, #516	; 0x204
 801a31a:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
            break;
 801a31e:	e061      	b.n	801a3e4 <lv_img_decoder_built_in_line_alpha+0x2ec>
        case LV_IMG_CF_ALPHA_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 801a320:	f107 030c 	add.w	r3, r7, #12
 801a324:	681b      	ldr	r3, [r3, #0]
 801a326:	691b      	ldr	r3, [r3, #16]
 801a328:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a32c:	b29b      	uxth	r3, r3
 801a32e:	105b      	asrs	r3, r3, #1
 801a330:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            if(dsc->header.w & 0x1) w++;
 801a334:	f107 030c 	add.w	r3, r7, #12
 801a338:	681b      	ldr	r3, [r3, #0]
 801a33a:	691b      	ldr	r3, [r3, #16]
 801a33c:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a340:	b29b      	uxth	r3, r3
 801a342:	f003 0301 	and.w	r3, r3, #1
 801a346:	2b00      	cmp	r3, #0
 801a348:	d006      	beq.n	801a358 <lv_img_decoder_built_in_line_alpha+0x260>
 801a34a:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a34e:	b29b      	uxth	r3, r3
 801a350:	3301      	adds	r3, #1
 801a352:	b29b      	uxth	r3, r3
 801a354:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            ofs += w * y + (x >> 1); /*First pixel*/
 801a358:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a35c:	f107 0208 	add.w	r2, r7, #8
 801a360:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a364:	fb02 f303 	mul.w	r3, r2, r3
 801a368:	f107 020a 	add.w	r2, r7, #10
 801a36c:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a370:	1052      	asrs	r2, r2, #1
 801a372:	b212      	sxth	r2, r2
 801a374:	4413      	add	r3, r2
 801a376:	461a      	mov	r2, r3
 801a378:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801a37c:	4413      	add	r3, r2
 801a37e:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
            pos       = 4 - ((x & 0x1) * 4);
 801a382:	f107 030a 	add.w	r3, r7, #10
 801a386:	881b      	ldrh	r3, [r3, #0]
 801a388:	f003 0301 	and.w	r3, r3, #1
 801a38c:	2b00      	cmp	r3, #0
 801a38e:	d101      	bne.n	801a394 <lv_img_decoder_built_in_line_alpha+0x29c>
 801a390:	2304      	movs	r3, #4
 801a392:	e000      	b.n	801a396 <lv_img_decoder_built_in_line_alpha+0x29e>
 801a394:	2300      	movs	r3, #0
 801a396:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
            opa_table = alpha4_opa_table;
 801a39a:	f507 73fa 	add.w	r3, r7, #500	; 0x1f4
 801a39e:	f8c7 3228 	str.w	r3, [r7, #552]	; 0x228
            break;
 801a3a2:	e01f      	b.n	801a3e4 <lv_img_decoder_built_in_line_alpha+0x2ec>
        case LV_IMG_CF_ALPHA_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 801a3a4:	f107 030c 	add.w	r3, r7, #12
 801a3a8:	681b      	ldr	r3, [r3, #0]
 801a3aa:	691b      	ldr	r3, [r3, #16]
 801a3ac:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a3b0:	b29b      	uxth	r3, r3
 801a3b2:	f8a7 3226 	strh.w	r3, [r7, #550]	; 0x226
            ofs += w * y + x;  /*First pixel*/
 801a3b6:	f9b7 3226 	ldrsh.w	r3, [r7, #550]	; 0x226
 801a3ba:	f107 0208 	add.w	r2, r7, #8
 801a3be:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a3c2:	fb02 f203 	mul.w	r2, r2, r3
 801a3c6:	f107 030a 	add.w	r3, r7, #10
 801a3ca:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a3ce:	4413      	add	r3, r2
 801a3d0:	461a      	mov	r2, r3
 801a3d2:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801a3d6:	4413      	add	r3, r2
 801a3d8:	f8c7 3220 	str.w	r3, [r7, #544]	; 0x220
            pos = 0;
 801a3dc:	2300      	movs	r3, #0
 801a3de:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
            break;
 801a3e2:	bf00      	nop
    }

#if LV_USE_FILESYSTEM
    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801a3e4:	f107 030c 	add.w	r3, r7, #12
 801a3e8:	681b      	ldr	r3, [r3, #0]
 801a3ea:	6a1b      	ldr	r3, [r3, #32]
 801a3ec:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif

    const uint8_t * data_tmp = NULL;
 801a3f0:	2300      	movs	r3, #0
 801a3f2:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801a3f6:	f107 030c 	add.w	r3, r7, #12
 801a3fa:	681b      	ldr	r3, [r3, #0]
 801a3fc:	7b1b      	ldrb	r3, [r3, #12]
 801a3fe:	2b00      	cmp	r3, #0
 801a400:	d10e      	bne.n	801a420 <lv_img_decoder_built_in_line_alpha+0x328>
        const lv_img_dsc_t * img_dsc = dsc->src;
 801a402:	f107 030c 	add.w	r3, r7, #12
 801a406:	681b      	ldr	r3, [r3, #0]
 801a408:	685b      	ldr	r3, [r3, #4]
 801a40a:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c

        data_tmp = img_dsc->data + ofs;
 801a40e:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801a412:	689a      	ldr	r2, [r3, #8]
 801a414:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801a418:	4413      	add	r3, r2
 801a41a:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
 801a41e:	e017      	b.n	801a450 <lv_img_decoder_built_in_line_alpha+0x358>
    } else {
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
 801a420:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a424:	681a      	ldr	r2, [r3, #0]
 801a426:	f8d7 3220 	ldr.w	r3, [r7, #544]	; 0x220
 801a42a:	3304      	adds	r3, #4
 801a42c:	4619      	mov	r1, r3
 801a42e:	4610      	mov	r0, r2
 801a430:	f001 fecd 	bl	801c1ce <lv_fs_seek>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
 801a434:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a438:	6818      	ldr	r0, [r3, #0]
 801a43a:	f9b7 2226 	ldrsh.w	r2, [r7, #550]	; 0x226
 801a43e:	f107 0110 	add.w	r1, r7, #16
 801a442:	2300      	movs	r3, #0
 801a444:	f001 fe8d 	bl	801c162 <lv_fs_read>
        data_tmp = fs_buf;
 801a448:	f107 0310 	add.w	r3, r7, #16
 801a44c:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
#endif
    }

    uint8_t byte_act = 0;
 801a450:	2300      	movs	r3, #0
 801a452:	f887 320b 	strb.w	r3, [r7, #523]	; 0x20b
    uint8_t val_act;
    for(i = 0; i < len; i++) {
 801a456:	2300      	movs	r3, #0
 801a458:	f8a7 322e 	strh.w	r3, [r7, #558]	; 0x22e
 801a45c:	e054      	b.n	801a508 <lv_img_decoder_built_in_line_alpha+0x410>
 801a45e:	bf00      	nop
 801a460:	08028d54 	.word	0x08028d54
 801a464:	08028d58 	.word	0x08028d58
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
 801a468:	f897 320b 	ldrb.w	r3, [r7, #523]	; 0x20b
 801a46c:	f8d7 2218 	ldr.w	r2, [r7, #536]	; 0x218
 801a470:	4413      	add	r3, r2
 801a472:	781b      	ldrb	r3, [r3, #0]
 801a474:	4619      	mov	r1, r3
 801a476:	f8b7 2214 	ldrh.w	r2, [r7, #532]	; 0x214
 801a47a:	f997 321f 	ldrsb.w	r3, [r7, #543]	; 0x21f
 801a47e:	fa02 f303 	lsl.w	r3, r2, r3
 801a482:	ea01 0203 	and.w	r2, r1, r3
 801a486:	f997 321f 	ldrsb.w	r3, [r7, #543]	; 0x21f
 801a48a:	fa42 f303 	asr.w	r3, r2, r3
 801a48e:	f887 320a 	strb.w	r3, [r7, #522]	; 0x20a

        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 801a492:	f107 030c 	add.w	r3, r7, #12
 801a496:	681b      	ldr	r3, [r3, #0]
 801a498:	7c1b      	ldrb	r3, [r3, #16]
 801a49a:	f003 031f 	and.w	r3, r3, #31
 801a49e:	b2db      	uxtb	r3, r3
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 801a4a0:	2b0e      	cmp	r3, #14
 801a4a2:	d006      	beq.n	801a4b2 <lv_img_decoder_built_in_line_alpha+0x3ba>
            dsc->header.cf == LV_IMG_CF_ALPHA_8BIT ? val_act : opa_table[val_act];
 801a4a4:	f897 320a 	ldrb.w	r3, [r7, #522]	; 0x20a
 801a4a8:	f8d7 2228 	ldr.w	r2, [r7, #552]	; 0x228
 801a4ac:	4413      	add	r3, r2
        buf[i * LV_IMG_PX_SIZE_ALPHA_BYTE + LV_IMG_PX_SIZE_ALPHA_BYTE - 1] =
 801a4ae:	781a      	ldrb	r2, [r3, #0]
 801a4b0:	e001      	b.n	801a4b6 <lv_img_decoder_built_in_line_alpha+0x3be>
 801a4b2:	f897 220a 	ldrb.w	r2, [r7, #522]	; 0x20a
 801a4b6:	f9b7 122e 	ldrsh.w	r1, [r7, #558]	; 0x22e
 801a4ba:	460b      	mov	r3, r1
 801a4bc:	005b      	lsls	r3, r3, #1
 801a4be:	440b      	add	r3, r1
 801a4c0:	3302      	adds	r3, #2
 801a4c2:	f8d7 1240 	ldr.w	r1, [r7, #576]	; 0x240
 801a4c6:	440b      	add	r3, r1
 801a4c8:	701a      	strb	r2, [r3, #0]

        pos -= px_size;
 801a4ca:	f897 221f 	ldrb.w	r2, [r7, #543]	; 0x21f
 801a4ce:	f897 3217 	ldrb.w	r3, [r7, #535]	; 0x217
 801a4d2:	1ad3      	subs	r3, r2, r3
 801a4d4:	b2db      	uxtb	r3, r3
 801a4d6:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
        if(pos < 0) {
 801a4da:	f997 321f 	ldrsb.w	r3, [r7, #543]	; 0x21f
 801a4de:	2b00      	cmp	r3, #0
 801a4e0:	da0b      	bge.n	801a4fa <lv_img_decoder_built_in_line_alpha+0x402>
            pos = 8 - px_size;
 801a4e2:	f897 3217 	ldrb.w	r3, [r7, #535]	; 0x217
 801a4e6:	f1c3 0308 	rsb	r3, r3, #8
 801a4ea:	b2db      	uxtb	r3, r3
 801a4ec:	f887 321f 	strb.w	r3, [r7, #543]	; 0x21f
            data_tmp++;
 801a4f0:	f8d7 3218 	ldr.w	r3, [r7, #536]	; 0x218
 801a4f4:	3301      	adds	r3, #1
 801a4f6:	f8c7 3218 	str.w	r3, [r7, #536]	; 0x218
    for(i = 0; i < len; i++) {
 801a4fa:	f9b7 322e 	ldrsh.w	r3, [r7, #558]	; 0x22e
 801a4fe:	b29b      	uxth	r3, r3
 801a500:	3301      	adds	r3, #1
 801a502:	b29b      	uxth	r3, r3
 801a504:	f8a7 322e 	strh.w	r3, [r7, #558]	; 0x22e
 801a508:	1dbb      	adds	r3, r7, #6
 801a50a:	f9b7 222e 	ldrsh.w	r2, [r7, #558]	; 0x22e
 801a50e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a512:	429a      	cmp	r2, r3
 801a514:	dba8      	blt.n	801a468 <lv_img_decoder_built_in_line_alpha+0x370>
        }
    }

    return LV_RES_OK;
 801a516:	2301      	movs	r3, #1

#else
    LV_LOG_WARN("Image built-in alpha line reader failed because LV_IMG_CF_ALPHA is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 801a518:	4618      	mov	r0, r3
 801a51a:	f507 770d 	add.w	r7, r7, #564	; 0x234
 801a51e:	46bd      	mov	sp, r7
 801a520:	bd90      	pop	{r4, r7, pc}
 801a522:	bf00      	nop

0801a524 <lv_img_decoder_built_in_line_indexed>:

static lv_res_t lv_img_decoder_built_in_line_indexed(lv_img_decoder_dsc_t * dsc, lv_coord_t x, lv_coord_t y,
                                                     lv_coord_t len, uint8_t * buf)
{
 801a524:	b590      	push	{r4, r7, lr}
 801a526:	f5ad 7d07 	sub.w	sp, sp, #540	; 0x21c
 801a52a:	af00      	add	r7, sp, #0
 801a52c:	f107 040c 	add.w	r4, r7, #12
 801a530:	6020      	str	r0, [r4, #0]
 801a532:	460c      	mov	r4, r1
 801a534:	4610      	mov	r0, r2
 801a536:	4619      	mov	r1, r3
 801a538:	f107 030a 	add.w	r3, r7, #10
 801a53c:	4622      	mov	r2, r4
 801a53e:	801a      	strh	r2, [r3, #0]
 801a540:	f107 0308 	add.w	r3, r7, #8
 801a544:	4602      	mov	r2, r0
 801a546:	801a      	strh	r2, [r3, #0]
 801a548:	1dbb      	adds	r3, r7, #6
 801a54a:	460a      	mov	r2, r1
 801a54c:	801a      	strh	r2, [r3, #0]

#if LV_IMG_CF_INDEXED
    uint8_t px_size = lv_img_color_format_get_px_size(dsc->header.cf);
 801a54e:	f107 030c 	add.w	r3, r7, #12
 801a552:	681b      	ldr	r3, [r3, #0]
 801a554:	7c1b      	ldrb	r3, [r3, #16]
 801a556:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801a55a:	b2db      	uxtb	r3, r3
 801a55c:	4618      	mov	r0, r3
 801a55e:	f7fa fc69 	bl	8014e34 <lv_img_color_format_get_px_size>
 801a562:	4603      	mov	r3, r0
 801a564:	f887 3209 	strb.w	r3, [r7, #521]	; 0x209
    uint16_t mask   = (1 << px_size) - 1; /*E.g. px_size = 2; mask = 0x03*/
 801a568:	f897 3209 	ldrb.w	r3, [r7, #521]	; 0x209
 801a56c:	2201      	movs	r2, #1
 801a56e:	fa02 f303 	lsl.w	r3, r2, r3
 801a572:	b29b      	uxth	r3, r3
 801a574:	3b01      	subs	r3, #1
 801a576:	f8a7 3206 	strh.w	r3, [r7, #518]	; 0x206

    lv_coord_t w = 0;
 801a57a:	2300      	movs	r3, #0
 801a57c:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
    int8_t pos   = 0;
 801a580:	2300      	movs	r3, #0
 801a582:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
    uint32_t ofs = 0;
 801a586:	2300      	movs	r3, #0
 801a588:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
    switch(dsc->header.cf) {
 801a58c:	f107 030c 	add.w	r3, r7, #12
 801a590:	681b      	ldr	r3, [r3, #0]
 801a592:	7c1b      	ldrb	r3, [r3, #16]
 801a594:	f3c3 0304 	ubfx	r3, r3, #0, #5
 801a598:	b2db      	uxtb	r3, r3
 801a59a:	3b07      	subs	r3, #7
 801a59c:	2b03      	cmp	r3, #3
 801a59e:	f200 80f8 	bhi.w	801a792 <lv_img_decoder_built_in_line_indexed+0x26e>
 801a5a2:	a201      	add	r2, pc, #4	; (adr r2, 801a5a8 <lv_img_decoder_built_in_line_indexed+0x84>)
 801a5a4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801a5a8:	0801a5b9 	.word	0x0801a5b9
 801a5ac:	0801a63b 	.word	0x0801a63b
 801a5b0:	0801a6c1 	.word	0x0801a6c1
 801a5b4:	0801a747 	.word	0x0801a747
        case LV_IMG_CF_INDEXED_1BIT:
            w = (dsc->header.w >> 3); /*E.g. w = 20 -> w = 2 + 1*/
 801a5b8:	f107 030c 	add.w	r3, r7, #12
 801a5bc:	681b      	ldr	r3, [r3, #0]
 801a5be:	691b      	ldr	r3, [r3, #16]
 801a5c0:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a5c4:	b29b      	uxth	r3, r3
 801a5c6:	10db      	asrs	r3, r3, #3
 801a5c8:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            if(dsc->header.w & 0x7) w++;
 801a5cc:	f107 030c 	add.w	r3, r7, #12
 801a5d0:	681b      	ldr	r3, [r3, #0]
 801a5d2:	691b      	ldr	r3, [r3, #16]
 801a5d4:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a5d8:	b29b      	uxth	r3, r3
 801a5da:	f003 0307 	and.w	r3, r3, #7
 801a5de:	2b00      	cmp	r3, #0
 801a5e0:	d006      	beq.n	801a5f0 <lv_img_decoder_built_in_line_indexed+0xcc>
 801a5e2:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a5e6:	b29b      	uxth	r3, r3
 801a5e8:	3301      	adds	r3, #1
 801a5ea:	b29b      	uxth	r3, r3
 801a5ec:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            ofs += w * y + (x >> 3); /*First pixel*/
 801a5f0:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a5f4:	f107 0208 	add.w	r2, r7, #8
 801a5f8:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a5fc:	fb02 f303 	mul.w	r3, r2, r3
 801a600:	f107 020a 	add.w	r2, r7, #10
 801a604:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a608:	10d2      	asrs	r2, r2, #3
 801a60a:	b212      	sxth	r2, r2
 801a60c:	4413      	add	r3, r2
 801a60e:	461a      	mov	r2, r3
 801a610:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a614:	4413      	add	r3, r2
 801a616:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            ofs += 8;                /*Skip the palette*/
 801a61a:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a61e:	3308      	adds	r3, #8
 801a620:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            pos = 7 - (x & 0x7);
 801a624:	f107 030a 	add.w	r3, r7, #10
 801a628:	881b      	ldrh	r3, [r3, #0]
 801a62a:	b25b      	sxtb	r3, r3
 801a62c:	43db      	mvns	r3, r3
 801a62e:	b25b      	sxtb	r3, r3
 801a630:	f003 0307 	and.w	r3, r3, #7
 801a634:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
            break;
 801a638:	e0ab      	b.n	801a792 <lv_img_decoder_built_in_line_indexed+0x26e>
        case LV_IMG_CF_INDEXED_2BIT:
            w = (dsc->header.w >> 2); /*E.g. w = 13 -> w = 3 + 1 (bytes)*/
 801a63a:	f107 030c 	add.w	r3, r7, #12
 801a63e:	681b      	ldr	r3, [r3, #0]
 801a640:	691b      	ldr	r3, [r3, #16]
 801a642:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a646:	b29b      	uxth	r3, r3
 801a648:	109b      	asrs	r3, r3, #2
 801a64a:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            if(dsc->header.w & 0x3) w++;
 801a64e:	f107 030c 	add.w	r3, r7, #12
 801a652:	681b      	ldr	r3, [r3, #0]
 801a654:	691b      	ldr	r3, [r3, #16]
 801a656:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a65a:	b29b      	uxth	r3, r3
 801a65c:	f003 0303 	and.w	r3, r3, #3
 801a660:	2b00      	cmp	r3, #0
 801a662:	d006      	beq.n	801a672 <lv_img_decoder_built_in_line_indexed+0x14e>
 801a664:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a668:	b29b      	uxth	r3, r3
 801a66a:	3301      	adds	r3, #1
 801a66c:	b29b      	uxth	r3, r3
 801a66e:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            ofs += w * y + (x >> 2); /*First pixel*/
 801a672:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a676:	f107 0208 	add.w	r2, r7, #8
 801a67a:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a67e:	fb02 f303 	mul.w	r3, r2, r3
 801a682:	f107 020a 	add.w	r2, r7, #10
 801a686:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a68a:	1092      	asrs	r2, r2, #2
 801a68c:	b212      	sxth	r2, r2
 801a68e:	4413      	add	r3, r2
 801a690:	461a      	mov	r2, r3
 801a692:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a696:	4413      	add	r3, r2
 801a698:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            ofs += 16;               /*Skip the palette*/
 801a69c:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a6a0:	3310      	adds	r3, #16
 801a6a2:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            pos = 6 - ((x & 0x3) * 2);
 801a6a6:	f107 030a 	add.w	r3, r7, #10
 801a6aa:	881b      	ldrh	r3, [r3, #0]
 801a6ac:	43db      	mvns	r3, r3
 801a6ae:	b2db      	uxtb	r3, r3
 801a6b0:	f003 0303 	and.w	r3, r3, #3
 801a6b4:	b2db      	uxtb	r3, r3
 801a6b6:	005b      	lsls	r3, r3, #1
 801a6b8:	b2db      	uxtb	r3, r3
 801a6ba:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
            break;
 801a6be:	e068      	b.n	801a792 <lv_img_decoder_built_in_line_indexed+0x26e>
        case LV_IMG_CF_INDEXED_4BIT:
            w = (dsc->header.w >> 1); /*E.g. w = 13 -> w = 6 + 1 (bytes)*/
 801a6c0:	f107 030c 	add.w	r3, r7, #12
 801a6c4:	681b      	ldr	r3, [r3, #0]
 801a6c6:	691b      	ldr	r3, [r3, #16]
 801a6c8:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a6cc:	b29b      	uxth	r3, r3
 801a6ce:	105b      	asrs	r3, r3, #1
 801a6d0:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            if(dsc->header.w & 0x1) w++;
 801a6d4:	f107 030c 	add.w	r3, r7, #12
 801a6d8:	681b      	ldr	r3, [r3, #0]
 801a6da:	691b      	ldr	r3, [r3, #16]
 801a6dc:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a6e0:	b29b      	uxth	r3, r3
 801a6e2:	f003 0301 	and.w	r3, r3, #1
 801a6e6:	2b00      	cmp	r3, #0
 801a6e8:	d006      	beq.n	801a6f8 <lv_img_decoder_built_in_line_indexed+0x1d4>
 801a6ea:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a6ee:	b29b      	uxth	r3, r3
 801a6f0:	3301      	adds	r3, #1
 801a6f2:	b29b      	uxth	r3, r3
 801a6f4:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            ofs += w * y + (x >> 1); /*First pixel*/
 801a6f8:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a6fc:	f107 0208 	add.w	r2, r7, #8
 801a700:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a704:	fb02 f303 	mul.w	r3, r2, r3
 801a708:	f107 020a 	add.w	r2, r7, #10
 801a70c:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a710:	1052      	asrs	r2, r2, #1
 801a712:	b212      	sxth	r2, r2
 801a714:	4413      	add	r3, r2
 801a716:	461a      	mov	r2, r3
 801a718:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a71c:	4413      	add	r3, r2
 801a71e:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            ofs += 64;               /*Skip the palette*/
 801a722:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a726:	3340      	adds	r3, #64	; 0x40
 801a728:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            pos = 4 - ((x & 0x1) * 4);
 801a72c:	f107 030a 	add.w	r3, r7, #10
 801a730:	881b      	ldrh	r3, [r3, #0]
 801a732:	f003 0301 	and.w	r3, r3, #1
 801a736:	2b00      	cmp	r3, #0
 801a738:	d101      	bne.n	801a73e <lv_img_decoder_built_in_line_indexed+0x21a>
 801a73a:	2304      	movs	r3, #4
 801a73c:	e000      	b.n	801a740 <lv_img_decoder_built_in_line_indexed+0x21c>
 801a73e:	2300      	movs	r3, #0
 801a740:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
            break;
 801a744:	e025      	b.n	801a792 <lv_img_decoder_built_in_line_indexed+0x26e>
        case LV_IMG_CF_INDEXED_8BIT:
            w = dsc->header.w; /*E.g. x = 7 -> w = 7 (bytes)*/
 801a746:	f107 030c 	add.w	r3, r7, #12
 801a74a:	681b      	ldr	r3, [r3, #0]
 801a74c:	691b      	ldr	r3, [r3, #16]
 801a74e:	f3c3 238a 	ubfx	r3, r3, #10, #11
 801a752:	b29b      	uxth	r3, r3
 801a754:	f8a7 3216 	strh.w	r3, [r7, #534]	; 0x216
            ofs += w * y + x;  /*First pixel*/
 801a758:	f9b7 3216 	ldrsh.w	r3, [r7, #534]	; 0x216
 801a75c:	f107 0208 	add.w	r2, r7, #8
 801a760:	f9b2 2000 	ldrsh.w	r2, [r2]
 801a764:	fb02 f203 	mul.w	r2, r2, r3
 801a768:	f107 030a 	add.w	r3, r7, #10
 801a76c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a770:	4413      	add	r3, r2
 801a772:	461a      	mov	r2, r3
 801a774:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a778:	4413      	add	r3, r2
 801a77a:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            ofs += 1024;       /*Skip the palette*/
 801a77e:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a782:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801a786:	f8c7 3210 	str.w	r3, [r7, #528]	; 0x210
            pos = 0;
 801a78a:	2300      	movs	r3, #0
 801a78c:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
            break;
 801a790:	bf00      	nop
    }

    lv_img_decoder_built_in_data_t * user_data = dsc->user_data;
 801a792:	f107 030c 	add.w	r3, r7, #12
 801a796:	681b      	ldr	r3, [r3, #0]
 801a798:	6a1b      	ldr	r3, [r3, #32]
 801a79a:	f8c7 3200 	str.w	r3, [r7, #512]	; 0x200

#if LV_USE_FILESYSTEM
    uint8_t fs_buf[LV_HOR_RES_MAX];
#endif
    const uint8_t * data_tmp = NULL;
 801a79e:	2300      	movs	r3, #0
 801a7a0:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    if(dsc->src_type == LV_IMG_SRC_VARIABLE) {
 801a7a4:	f107 030c 	add.w	r3, r7, #12
 801a7a8:	681b      	ldr	r3, [r3, #0]
 801a7aa:	7b1b      	ldrb	r3, [r3, #12]
 801a7ac:	2b00      	cmp	r3, #0
 801a7ae:	d10e      	bne.n	801a7ce <lv_img_decoder_built_in_line_indexed+0x2aa>
        const lv_img_dsc_t * img_dsc = dsc->src;
 801a7b0:	f107 030c 	add.w	r3, r7, #12
 801a7b4:	681b      	ldr	r3, [r3, #0]
 801a7b6:	685b      	ldr	r3, [r3, #4]
 801a7b8:	f8c7 31fc 	str.w	r3, [r7, #508]	; 0x1fc
        data_tmp                     = img_dsc->data + ofs;
 801a7bc:	f8d7 31fc 	ldr.w	r3, [r7, #508]	; 0x1fc
 801a7c0:	689a      	ldr	r2, [r3, #8]
 801a7c2:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a7c6:	4413      	add	r3, r2
 801a7c8:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
 801a7cc:	e017      	b.n	801a7fe <lv_img_decoder_built_in_line_indexed+0x2da>
    } else {
#if LV_USE_FILESYSTEM
        lv_fs_seek(user_data->f, ofs + 4); /*+4 to skip the header*/
 801a7ce:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801a7d2:	681a      	ldr	r2, [r3, #0]
 801a7d4:	f8d7 3210 	ldr.w	r3, [r7, #528]	; 0x210
 801a7d8:	3304      	adds	r3, #4
 801a7da:	4619      	mov	r1, r3
 801a7dc:	4610      	mov	r0, r2
 801a7de:	f001 fcf6 	bl	801c1ce <lv_fs_seek>
        lv_fs_read(user_data->f, fs_buf, w, NULL);
 801a7e2:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801a7e6:	6818      	ldr	r0, [r3, #0]
 801a7e8:	f9b7 2216 	ldrsh.w	r2, [r7, #534]	; 0x216
 801a7ec:	f107 0110 	add.w	r1, r7, #16
 801a7f0:	2300      	movs	r3, #0
 801a7f2:	f001 fcb6 	bl	801c162 <lv_fs_read>
        data_tmp = fs_buf;
 801a7f6:	f107 0310 	add.w	r3, r7, #16
 801a7fa:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
        data_tmp = NULL; /*To avoid warnings*/
        return LV_RES_INV;
#endif
    }

    uint8_t byte_act = 0;
 801a7fe:	2300      	movs	r3, #0
 801a800:	f887 31fb 	strb.w	r3, [r7, #507]	; 0x1fb
    uint8_t val_act;
    lv_coord_t i;
    lv_color_t * cbuf = (lv_color_t *)buf;
 801a804:	f8d7 3228 	ldr.w	r3, [r7, #552]	; 0x228
 801a808:	f8c7 31f4 	str.w	r3, [r7, #500]	; 0x1f4
    for(i = 0; i < len; i++) {
 801a80c:	2300      	movs	r3, #0
 801a80e:	f8a7 320a 	strh.w	r3, [r7, #522]	; 0x20a
 801a812:	e042      	b.n	801a89a <lv_img_decoder_built_in_line_indexed+0x376>
        val_act = (data_tmp[byte_act] & (mask << pos)) >> pos;
 801a814:	f897 31fb 	ldrb.w	r3, [r7, #507]	; 0x1fb
 801a818:	f8d7 220c 	ldr.w	r2, [r7, #524]	; 0x20c
 801a81c:	4413      	add	r3, r2
 801a81e:	781b      	ldrb	r3, [r3, #0]
 801a820:	4619      	mov	r1, r3
 801a822:	f8b7 2206 	ldrh.w	r2, [r7, #518]	; 0x206
 801a826:	f997 3215 	ldrsb.w	r3, [r7, #533]	; 0x215
 801a82a:	fa02 f303 	lsl.w	r3, r2, r3
 801a82e:	ea01 0203 	and.w	r2, r1, r3
 801a832:	f997 3215 	ldrsb.w	r3, [r7, #533]	; 0x215
 801a836:	fa42 f303 	asr.w	r3, r2, r3
 801a83a:	f887 31f3 	strb.w	r3, [r7, #499]	; 0x1f3
        cbuf[i] = user_data->palette[val_act];
 801a83e:	f8d7 3200 	ldr.w	r3, [r7, #512]	; 0x200
 801a842:	685a      	ldr	r2, [r3, #4]
 801a844:	f897 31f3 	ldrb.w	r3, [r7, #499]	; 0x1f3
 801a848:	005b      	lsls	r3, r3, #1
 801a84a:	441a      	add	r2, r3
 801a84c:	f9b7 320a 	ldrsh.w	r3, [r7, #522]	; 0x20a
 801a850:	005b      	lsls	r3, r3, #1
 801a852:	f8d7 11f4 	ldr.w	r1, [r7, #500]	; 0x1f4
 801a856:	440b      	add	r3, r1
 801a858:	8812      	ldrh	r2, [r2, #0]
 801a85a:	801a      	strh	r2, [r3, #0]

        pos -= px_size;
 801a85c:	f897 2215 	ldrb.w	r2, [r7, #533]	; 0x215
 801a860:	f897 3209 	ldrb.w	r3, [r7, #521]	; 0x209
 801a864:	1ad3      	subs	r3, r2, r3
 801a866:	b2db      	uxtb	r3, r3
 801a868:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
        if(pos < 0) {
 801a86c:	f997 3215 	ldrsb.w	r3, [r7, #533]	; 0x215
 801a870:	2b00      	cmp	r3, #0
 801a872:	da0b      	bge.n	801a88c <lv_img_decoder_built_in_line_indexed+0x368>
            pos = 8 - px_size;
 801a874:	f897 3209 	ldrb.w	r3, [r7, #521]	; 0x209
 801a878:	f1c3 0308 	rsb	r3, r3, #8
 801a87c:	b2db      	uxtb	r3, r3
 801a87e:	f887 3215 	strb.w	r3, [r7, #533]	; 0x215
            data_tmp++;
 801a882:	f8d7 320c 	ldr.w	r3, [r7, #524]	; 0x20c
 801a886:	3301      	adds	r3, #1
 801a888:	f8c7 320c 	str.w	r3, [r7, #524]	; 0x20c
    for(i = 0; i < len; i++) {
 801a88c:	f9b7 320a 	ldrsh.w	r3, [r7, #522]	; 0x20a
 801a890:	b29b      	uxth	r3, r3
 801a892:	3301      	adds	r3, #1
 801a894:	b29b      	uxth	r3, r3
 801a896:	f8a7 320a 	strh.w	r3, [r7, #522]	; 0x20a
 801a89a:	1dbb      	adds	r3, r7, #6
 801a89c:	f9b7 220a 	ldrsh.w	r2, [r7, #522]	; 0x20a
 801a8a0:	f9b3 3000 	ldrsh.w	r3, [r3]
 801a8a4:	429a      	cmp	r2, r3
 801a8a6:	dbb5      	blt.n	801a814 <lv_img_decoder_built_in_line_indexed+0x2f0>
        }
    }

    return LV_RES_OK;
 801a8a8:	2301      	movs	r3, #1
#else
    LV_LOG_WARN("Image built-in indexed line reader failed because LV_IMG_CF_INDEXED is 0 in lv_conf.h");
    return LV_RES_INV;
#endif
}
 801a8aa:	4618      	mov	r0, r3
 801a8ac:	f507 7707 	add.w	r7, r7, #540	; 0x21c
 801a8b0:	46bd      	mov	sp, r7
 801a8b2:	bd90      	pop	{r4, r7, pc}

0801a8b4 <lv_font_get_glyph_bitmap>:
 * @param font_p pointer to a font
 * @param letter an UNICODE character code
 * @return  pointer to the bitmap of the letter
 */
const uint8_t * lv_font_get_glyph_bitmap(const lv_font_t * font_p, uint32_t letter)
{
 801a8b4:	b580      	push	{r7, lr}
 801a8b6:	b082      	sub	sp, #8
 801a8b8:	af00      	add	r7, sp, #0
 801a8ba:	6078      	str	r0, [r7, #4]
 801a8bc:	6039      	str	r1, [r7, #0]
    return font_p->get_glyph_bitmap(font_p, letter);
 801a8be:	687b      	ldr	r3, [r7, #4]
 801a8c0:	685b      	ldr	r3, [r3, #4]
 801a8c2:	6839      	ldr	r1, [r7, #0]
 801a8c4:	6878      	ldr	r0, [r7, #4]
 801a8c6:	4798      	blx	r3
 801a8c8:	4603      	mov	r3, r0
}
 801a8ca:	4618      	mov	r0, r3
 801a8cc:	3708      	adds	r7, #8
 801a8ce:	46bd      	mov	sp, r7
 801a8d0:	bd80      	pop	{r7, pc}

0801a8d2 <lv_font_get_glyph_dsc>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc(const lv_font_t * font_p, lv_font_glyph_dsc_t * dsc_out, uint32_t letter, uint32_t letter_next)
{
 801a8d2:	b590      	push	{r4, r7, lr}
 801a8d4:	b085      	sub	sp, #20
 801a8d6:	af00      	add	r7, sp, #0
 801a8d8:	60f8      	str	r0, [r7, #12]
 801a8da:	60b9      	str	r1, [r7, #8]
 801a8dc:	607a      	str	r2, [r7, #4]
 801a8de:	603b      	str	r3, [r7, #0]
    return font_p->get_glyph_dsc(font_p, dsc_out, letter, letter_next);
 801a8e0:	68fb      	ldr	r3, [r7, #12]
 801a8e2:	681c      	ldr	r4, [r3, #0]
 801a8e4:	683b      	ldr	r3, [r7, #0]
 801a8e6:	687a      	ldr	r2, [r7, #4]
 801a8e8:	68b9      	ldr	r1, [r7, #8]
 801a8ea:	68f8      	ldr	r0, [r7, #12]
 801a8ec:	47a0      	blx	r4
 801a8ee:	4603      	mov	r3, r0
}
 801a8f0:	4618      	mov	r0, r3
 801a8f2:	3714      	adds	r7, #20
 801a8f4:	46bd      	mov	sp, r7
 801a8f6:	bd90      	pop	{r4, r7, pc}

0801a8f8 <lv_font_get_glyph_width>:
 * @param letter an UNICODE letter
 * @param letter_next the next letter after `letter`. Used for kerning
 * @return the width of the glyph
 */
uint16_t lv_font_get_glyph_width(const lv_font_t * font, uint32_t letter, uint32_t letter_next)
{
 801a8f8:	b580      	push	{r7, lr}
 801a8fa:	b088      	sub	sp, #32
 801a8fc:	af00      	add	r7, sp, #0
 801a8fe:	60f8      	str	r0, [r7, #12]
 801a900:	60b9      	str	r1, [r7, #8]
 801a902:	607a      	str	r2, [r7, #4]
    lv_font_glyph_dsc_t g;
    bool ret;
    ret = lv_font_get_glyph_dsc(font, &g, letter, letter_next);
 801a904:	f107 0114 	add.w	r1, r7, #20
 801a908:	687b      	ldr	r3, [r7, #4]
 801a90a:	68ba      	ldr	r2, [r7, #8]
 801a90c:	68f8      	ldr	r0, [r7, #12]
 801a90e:	f7ff ffe0 	bl	801a8d2 <lv_font_get_glyph_dsc>
 801a912:	4603      	mov	r3, r0
 801a914:	77fb      	strb	r3, [r7, #31]
    if(ret) return g.adv_w;
 801a916:	7ffb      	ldrb	r3, [r7, #31]
 801a918:	2b00      	cmp	r3, #0
 801a91a:	d001      	beq.n	801a920 <lv_font_get_glyph_width+0x28>
 801a91c:	8abb      	ldrh	r3, [r7, #20]
 801a91e:	e000      	b.n	801a922 <lv_font_get_glyph_width+0x2a>
    else return 0;
 801a920:	2300      	movs	r3, #0
}
 801a922:	4618      	mov	r0, r3
 801a924:	3720      	adds	r7, #32
 801a926:	46bd      	mov	sp, r7
 801a928:	bd80      	pop	{r7, pc}

0801a92a <lv_font_get_bitmap_fmt_txt>:
 * @param font pointer to font
 * @param unicode_letter an unicode letter which bitmap should be get
 * @return pointer to the bitmap or NULL if not found
 */
const uint8_t * lv_font_get_bitmap_fmt_txt(const lv_font_t * font, uint32_t unicode_letter)
{
 801a92a:	b580      	push	{r7, lr}
 801a92c:	b086      	sub	sp, #24
 801a92e:	af00      	add	r7, sp, #0
 801a930:	6078      	str	r0, [r7, #4]
 801a932:	6039      	str	r1, [r7, #0]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801a934:	687b      	ldr	r3, [r7, #4]
 801a936:	68db      	ldr	r3, [r3, #12]
 801a938:	617b      	str	r3, [r7, #20]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801a93a:	6839      	ldr	r1, [r7, #0]
 801a93c:	6878      	ldr	r0, [r7, #4]
 801a93e:	f000 f883 	bl	801aa48 <get_glyph_dsc_id>
 801a942:	6138      	str	r0, [r7, #16]
    if(!gid) return false;
 801a944:	693b      	ldr	r3, [r7, #16]
 801a946:	2b00      	cmp	r3, #0
 801a948:	d101      	bne.n	801a94e <lv_font_get_bitmap_fmt_txt+0x24>
 801a94a:	2300      	movs	r3, #0
 801a94c:	e011      	b.n	801a972 <lv_font_get_bitmap_fmt_txt+0x48>

    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801a94e:	697b      	ldr	r3, [r7, #20]
 801a950:	685a      	ldr	r2, [r3, #4]
 801a952:	693b      	ldr	r3, [r7, #16]
 801a954:	00db      	lsls	r3, r3, #3
 801a956:	4413      	add	r3, r2
 801a958:	60fb      	str	r3, [r7, #12]

    if(gdsc) return &fdsc->glyph_bitmap[gdsc->bitmap_index];
 801a95a:	68fb      	ldr	r3, [r7, #12]
 801a95c:	2b00      	cmp	r3, #0
 801a95e:	d007      	beq.n	801a970 <lv_font_get_bitmap_fmt_txt+0x46>
 801a960:	697b      	ldr	r3, [r7, #20]
 801a962:	681b      	ldr	r3, [r3, #0]
 801a964:	68fa      	ldr	r2, [r7, #12]
 801a966:	6812      	ldr	r2, [r2, #0]
 801a968:	f3c2 0213 	ubfx	r2, r2, #0, #20
 801a96c:	4413      	add	r3, r2
 801a96e:	e000      	b.n	801a972 <lv_font_get_bitmap_fmt_txt+0x48>

    /*If not returned earlier then the letter is not found in this font*/
    return NULL;
 801a970:	2300      	movs	r3, #0
}
 801a972:	4618      	mov	r0, r3
 801a974:	3718      	adds	r7, #24
 801a976:	46bd      	mov	sp, r7
 801a978:	bd80      	pop	{r7, pc}

0801a97a <lv_font_get_glyph_dsc_fmt_txt>:
 * @param letter an UNICODE letter code
 * @return true: descriptor is successfully loaded into `dsc_out`.
 *         false: the letter was not found, no data is loaded to `dsc_out`
 */
bool lv_font_get_glyph_dsc_fmt_txt(const lv_font_t * font, lv_font_glyph_dsc_t * dsc_out, uint32_t unicode_letter, uint32_t unicode_letter_next)
{
 801a97a:	b580      	push	{r7, lr}
 801a97c:	b08a      	sub	sp, #40	; 0x28
 801a97e:	af00      	add	r7, sp, #0
 801a980:	60f8      	str	r0, [r7, #12]
 801a982:	60b9      	str	r1, [r7, #8]
 801a984:	607a      	str	r2, [r7, #4]
 801a986:	603b      	str	r3, [r7, #0]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801a988:	68fb      	ldr	r3, [r7, #12]
 801a98a:	68db      	ldr	r3, [r3, #12]
 801a98c:	623b      	str	r3, [r7, #32]
    uint32_t gid = get_glyph_dsc_id(font, unicode_letter);
 801a98e:	6879      	ldr	r1, [r7, #4]
 801a990:	68f8      	ldr	r0, [r7, #12]
 801a992:	f000 f859 	bl	801aa48 <get_glyph_dsc_id>
 801a996:	61f8      	str	r0, [r7, #28]
    if(!gid) return false;
 801a998:	69fb      	ldr	r3, [r7, #28]
 801a99a:	2b00      	cmp	r3, #0
 801a99c:	d101      	bne.n	801a9a2 <lv_font_get_glyph_dsc_fmt_txt+0x28>
 801a99e:	2300      	movs	r3, #0
 801a9a0:	e04e      	b.n	801aa40 <lv_font_get_glyph_dsc_fmt_txt+0xc6>

    int8_t kvalue = 0;
 801a9a2:	2300      	movs	r3, #0
 801a9a4:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if(fdsc->kern_dsc) {
 801a9a8:	6a3b      	ldr	r3, [r7, #32]
 801a9aa:	68db      	ldr	r3, [r3, #12]
 801a9ac:	2b00      	cmp	r3, #0
 801a9ae:	d00f      	beq.n	801a9d0 <lv_font_get_glyph_dsc_fmt_txt+0x56>
        uint32_t gid_next = get_glyph_dsc_id(font, unicode_letter_next);
 801a9b0:	6839      	ldr	r1, [r7, #0]
 801a9b2:	68f8      	ldr	r0, [r7, #12]
 801a9b4:	f000 f848 	bl	801aa48 <get_glyph_dsc_id>
 801a9b8:	61b8      	str	r0, [r7, #24]
        if(gid_next) {
 801a9ba:	69bb      	ldr	r3, [r7, #24]
 801a9bc:	2b00      	cmp	r3, #0
 801a9be:	d007      	beq.n	801a9d0 <lv_font_get_glyph_dsc_fmt_txt+0x56>
            kvalue = get_kern_value(font, gid, gid_next);
 801a9c0:	69ba      	ldr	r2, [r7, #24]
 801a9c2:	69f9      	ldr	r1, [r7, #28]
 801a9c4:	68f8      	ldr	r0, [r7, #12]
 801a9c6:	f000 f97b 	bl	801acc0 <get_kern_value>
 801a9ca:	4603      	mov	r3, r0
 801a9cc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
        }
    }

    /*Put together a glyph dsc*/
    const lv_font_fmt_txt_glyph_dsc_t * gdsc = &fdsc->glyph_dsc[gid];
 801a9d0:	6a3b      	ldr	r3, [r7, #32]
 801a9d2:	685a      	ldr	r2, [r3, #4]
 801a9d4:	69fb      	ldr	r3, [r7, #28]
 801a9d6:	00db      	lsls	r3, r3, #3
 801a9d8:	4413      	add	r3, r2
 801a9da:	617b      	str	r3, [r7, #20]

    uint32_t adv_w = gdsc->adv_w + ((int32_t)((int32_t)kvalue * fdsc->kern_scale) >> 4);
 801a9dc:	697b      	ldr	r3, [r7, #20]
 801a9de:	885b      	ldrh	r3, [r3, #2]
 801a9e0:	f3c3 130b 	ubfx	r3, r3, #4, #12
 801a9e4:	b29b      	uxth	r3, r3
 801a9e6:	4619      	mov	r1, r3
 801a9e8:	f997 3027 	ldrsb.w	r3, [r7, #39]	; 0x27
 801a9ec:	6a3a      	ldr	r2, [r7, #32]
 801a9ee:	8a12      	ldrh	r2, [r2, #16]
 801a9f0:	fb02 f303 	mul.w	r3, r2, r3
 801a9f4:	111b      	asrs	r3, r3, #4
 801a9f6:	440b      	add	r3, r1
 801a9f8:	613b      	str	r3, [r7, #16]
    adv_w  = (adv_w + (1 << 3)) >> 4;
 801a9fa:	693b      	ldr	r3, [r7, #16]
 801a9fc:	3308      	adds	r3, #8
 801a9fe:	091b      	lsrs	r3, r3, #4
 801aa00:	613b      	str	r3, [r7, #16]

    dsc_out->adv_w = adv_w;
 801aa02:	693b      	ldr	r3, [r7, #16]
 801aa04:	b29a      	uxth	r2, r3
 801aa06:	68bb      	ldr	r3, [r7, #8]
 801aa08:	801a      	strh	r2, [r3, #0]
    dsc_out->box_h = gdsc->box_h;
 801aa0a:	697b      	ldr	r3, [r7, #20]
 801aa0c:	795a      	ldrb	r2, [r3, #5]
 801aa0e:	68bb      	ldr	r3, [r7, #8]
 801aa10:	70da      	strb	r2, [r3, #3]
    dsc_out->box_w = gdsc->box_w;
 801aa12:	697b      	ldr	r3, [r7, #20]
 801aa14:	791a      	ldrb	r2, [r3, #4]
 801aa16:	68bb      	ldr	r3, [r7, #8]
 801aa18:	709a      	strb	r2, [r3, #2]
    dsc_out->ofs_x = gdsc->ofs_x;
 801aa1a:	697b      	ldr	r3, [r7, #20]
 801aa1c:	f993 2006 	ldrsb.w	r2, [r3, #6]
 801aa20:	68bb      	ldr	r3, [r7, #8]
 801aa22:	711a      	strb	r2, [r3, #4]
    dsc_out->ofs_y = gdsc->ofs_y;
 801aa24:	697b      	ldr	r3, [r7, #20]
 801aa26:	79db      	ldrb	r3, [r3, #7]
 801aa28:	b25a      	sxtb	r2, r3
 801aa2a:	68bb      	ldr	r3, [r7, #8]
 801aa2c:	715a      	strb	r2, [r3, #5]
    dsc_out->bpp   = fdsc->bpp;
 801aa2e:	6a3b      	ldr	r3, [r7, #32]
 801aa30:	7cdb      	ldrb	r3, [r3, #19]
 801aa32:	f3c3 0382 	ubfx	r3, r3, #2, #3
 801aa36:	b2db      	uxtb	r3, r3
 801aa38:	461a      	mov	r2, r3
 801aa3a:	68bb      	ldr	r3, [r7, #8]
 801aa3c:	719a      	strb	r2, [r3, #6]

    return true;
 801aa3e:	2301      	movs	r3, #1
}
 801aa40:	4618      	mov	r0, r3
 801aa42:	3728      	adds	r7, #40	; 0x28
 801aa44:	46bd      	mov	sp, r7
 801aa46:	bd80      	pop	{r7, pc}

0801aa48 <get_glyph_dsc_id>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static uint32_t get_glyph_dsc_id(const lv_font_t * font, uint32_t letter)
{
 801aa48:	b590      	push	{r4, r7, lr}
 801aa4a:	b08f      	sub	sp, #60	; 0x3c
 801aa4c:	af02      	add	r7, sp, #8
 801aa4e:	6078      	str	r0, [r7, #4]
 801aa50:	6039      	str	r1, [r7, #0]
    if(letter == '\0') return 0;
 801aa52:	683b      	ldr	r3, [r7, #0]
 801aa54:	2b00      	cmp	r3, #0
 801aa56:	d101      	bne.n	801aa5c <get_glyph_dsc_id+0x14>
 801aa58:	2300      	movs	r3, #0
 801aa5a:	e12a      	b.n	801acb2 <get_glyph_dsc_id+0x26a>

    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801aa5c:	687b      	ldr	r3, [r7, #4]
 801aa5e:	68db      	ldr	r3, [r3, #12]
 801aa60:	627b      	str	r3, [r7, #36]	; 0x24

    /*Check the chacge first*/
    if(letter == fdsc->last_letter) return fdsc->last_glyph_id;
 801aa62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aa64:	695b      	ldr	r3, [r3, #20]
 801aa66:	683a      	ldr	r2, [r7, #0]
 801aa68:	429a      	cmp	r2, r3
 801aa6a:	d102      	bne.n	801aa72 <get_glyph_dsc_id+0x2a>
 801aa6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aa6e:	699b      	ldr	r3, [r3, #24]
 801aa70:	e11f      	b.n	801acb2 <get_glyph_dsc_id+0x26a>

    uint16_t i;
    for(i = 0; i < fdsc->cmap_num; i++) {
 801aa72:	2300      	movs	r3, #0
 801aa74:	85fb      	strh	r3, [r7, #46]	; 0x2e
 801aa76:	e10b      	b.n	801ac90 <get_glyph_dsc_id+0x248>

        /*Relative code point*/
        uint32_t rcp = letter - fdsc->cmaps[i].range_start;
 801aa78:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aa7a:	6899      	ldr	r1, [r3, #8]
 801aa7c:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801aa7e:	4613      	mov	r3, r2
 801aa80:	009b      	lsls	r3, r3, #2
 801aa82:	4413      	add	r3, r2
 801aa84:	009b      	lsls	r3, r3, #2
 801aa86:	440b      	add	r3, r1
 801aa88:	681b      	ldr	r3, [r3, #0]
 801aa8a:	683a      	ldr	r2, [r7, #0]
 801aa8c:	1ad3      	subs	r3, r2, r3
 801aa8e:	60bb      	str	r3, [r7, #8]
        if(rcp > fdsc->cmaps[i].range_length) continue;
 801aa90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aa92:	6899      	ldr	r1, [r3, #8]
 801aa94:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801aa96:	4613      	mov	r3, r2
 801aa98:	009b      	lsls	r3, r3, #2
 801aa9a:	4413      	add	r3, r2
 801aa9c:	009b      	lsls	r3, r3, #2
 801aa9e:	440b      	add	r3, r1
 801aaa0:	889b      	ldrh	r3, [r3, #4]
 801aaa2:	461a      	mov	r2, r3
 801aaa4:	68bb      	ldr	r3, [r7, #8]
 801aaa6:	429a      	cmp	r2, r3
 801aaa8:	d203      	bcs.n	801aab2 <get_glyph_dsc_id+0x6a>
    for(i = 0; i < fdsc->cmap_num; i++) {
 801aaaa:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801aaac:	3301      	adds	r3, #1
 801aaae:	85fb      	strh	r3, [r7, #46]	; 0x2e
 801aab0:	e0ee      	b.n	801ac90 <get_glyph_dsc_id+0x248>
        uint32_t glyph_id = 0;
 801aab2:	2300      	movs	r3, #0
 801aab4:	62bb      	str	r3, [r7, #40]	; 0x28
        if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY) {
 801aab6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aab8:	6899      	ldr	r1, [r3, #8]
 801aaba:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801aabc:	4613      	mov	r3, r2
 801aabe:	009b      	lsls	r3, r3, #2
 801aac0:	4413      	add	r3, r2
 801aac2:	009b      	lsls	r3, r3, #2
 801aac4:	440b      	add	r3, r1
 801aac6:	7c9b      	ldrb	r3, [r3, #18]
 801aac8:	f003 0303 	and.w	r3, r3, #3
 801aacc:	b2db      	uxtb	r3, r3
 801aace:	2b00      	cmp	r3, #0
 801aad0:	d10d      	bne.n	801aaee <get_glyph_dsc_id+0xa6>
            glyph_id = fdsc->cmaps[i].glyph_id_start + rcp;
 801aad2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aad4:	6899      	ldr	r1, [r3, #8]
 801aad6:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801aad8:	4613      	mov	r3, r2
 801aada:	009b      	lsls	r3, r3, #2
 801aadc:	4413      	add	r3, r2
 801aade:	009b      	lsls	r3, r3, #2
 801aae0:	440b      	add	r3, r1
 801aae2:	88db      	ldrh	r3, [r3, #6]
 801aae4:	461a      	mov	r2, r3
 801aae6:	68bb      	ldr	r3, [r7, #8]
 801aae8:	4413      	add	r3, r2
 801aaea:	62bb      	str	r3, [r7, #40]	; 0x28
 801aaec:	e0c8      	b.n	801ac80 <get_glyph_dsc_id+0x238>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL) {
 801aaee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aaf0:	6899      	ldr	r1, [r3, #8]
 801aaf2:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801aaf4:	4613      	mov	r3, r2
 801aaf6:	009b      	lsls	r3, r3, #2
 801aaf8:	4413      	add	r3, r2
 801aafa:	009b      	lsls	r3, r3, #2
 801aafc:	440b      	add	r3, r1
 801aafe:	7c9b      	ldrb	r3, [r3, #18]
 801ab00:	f003 0303 	and.w	r3, r3, #3
 801ab04:	b2db      	uxtb	r3, r3
 801ab06:	2b01      	cmp	r3, #1
 801ab08:	d11a      	bne.n	801ab40 <get_glyph_dsc_id+0xf8>
            const uint8_t * gid_ofs_8 = fdsc->cmaps[i].glyph_id_ofs_list;
 801ab0a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ab0c:	6899      	ldr	r1, [r3, #8]
 801ab0e:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ab10:	4613      	mov	r3, r2
 801ab12:	009b      	lsls	r3, r3, #2
 801ab14:	4413      	add	r3, r2
 801ab16:	009b      	lsls	r3, r3, #2
 801ab18:	440b      	add	r3, r1
 801ab1a:	68db      	ldr	r3, [r3, #12]
 801ab1c:	60fb      	str	r3, [r7, #12]
            glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_8[rcp];
 801ab1e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ab20:	6899      	ldr	r1, [r3, #8]
 801ab22:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ab24:	4613      	mov	r3, r2
 801ab26:	009b      	lsls	r3, r3, #2
 801ab28:	4413      	add	r3, r2
 801ab2a:	009b      	lsls	r3, r3, #2
 801ab2c:	440b      	add	r3, r1
 801ab2e:	88db      	ldrh	r3, [r3, #6]
 801ab30:	4619      	mov	r1, r3
 801ab32:	68bb      	ldr	r3, [r7, #8]
 801ab34:	68fa      	ldr	r2, [r7, #12]
 801ab36:	4413      	add	r3, r2
 801ab38:	781b      	ldrb	r3, [r3, #0]
 801ab3a:	440b      	add	r3, r1
 801ab3c:	62bb      	str	r3, [r7, #40]	; 0x28
 801ab3e:	e09f      	b.n	801ac80 <get_glyph_dsc_id+0x238>
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_TINY) {
 801ab40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ab42:	6899      	ldr	r1, [r3, #8]
 801ab44:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ab46:	4613      	mov	r3, r2
 801ab48:	009b      	lsls	r3, r3, #2
 801ab4a:	4413      	add	r3, r2
 801ab4c:	009b      	lsls	r3, r3, #2
 801ab4e:	440b      	add	r3, r1
 801ab50:	7c9b      	ldrb	r3, [r3, #18]
 801ab52:	f003 0303 	and.w	r3, r3, #3
 801ab56:	b2db      	uxtb	r3, r3
 801ab58:	2b02      	cmp	r3, #2
 801ab5a:	d13b      	bne.n	801abd4 <get_glyph_dsc_id+0x18c>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
 801ab5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ab5e:	6899      	ldr	r1, [r3, #8]
 801ab60:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ab62:	4613      	mov	r3, r2
 801ab64:	009b      	lsls	r3, r3, #2
 801ab66:	4413      	add	r3, r2
 801ab68:	009b      	lsls	r3, r3, #2
 801ab6a:	440b      	add	r3, r1
 801ab6c:	689c      	ldr	r4, [r3, #8]
 801ab6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ab70:	6899      	ldr	r1, [r3, #8]
 801ab72:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ab74:	4613      	mov	r3, r2
 801ab76:	009b      	lsls	r3, r3, #2
 801ab78:	4413      	add	r3, r2
 801ab7a:	009b      	lsls	r3, r3, #2
 801ab7c:	440b      	add	r3, r1
 801ab7e:	8a1b      	ldrh	r3, [r3, #16]
 801ab80:	461a      	mov	r2, r3
 801ab82:	f107 0008 	add.w	r0, r7, #8
 801ab86:	4b4d      	ldr	r3, [pc, #308]	; (801acbc <get_glyph_dsc_id+0x274>)
 801ab88:	9300      	str	r3, [sp, #0]
 801ab8a:	2302      	movs	r3, #2
 801ab8c:	4621      	mov	r1, r4
 801ab8e:	f002 feed 	bl	801d96c <lv_utils_bsearch>
 801ab92:	6178      	str	r0, [r7, #20]

            if(p) {
 801ab94:	697b      	ldr	r3, [r7, #20]
 801ab96:	2b00      	cmp	r3, #0
 801ab98:	d072      	beq.n	801ac80 <get_glyph_dsc_id+0x238>
                uint32_t ofs = (lv_uintptr_t)p - (lv_uintptr_t) fdsc->cmaps[i].unicode_list;
 801ab9a:	6979      	ldr	r1, [r7, #20]
 801ab9c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ab9e:	6898      	ldr	r0, [r3, #8]
 801aba0:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801aba2:	4613      	mov	r3, r2
 801aba4:	009b      	lsls	r3, r3, #2
 801aba6:	4413      	add	r3, r2
 801aba8:	009b      	lsls	r3, r3, #2
 801abaa:	4403      	add	r3, r0
 801abac:	689b      	ldr	r3, [r3, #8]
 801abae:	1acb      	subs	r3, r1, r3
 801abb0:	613b      	str	r3, [r7, #16]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 801abb2:	693b      	ldr	r3, [r7, #16]
 801abb4:	085b      	lsrs	r3, r3, #1
 801abb6:	613b      	str	r3, [r7, #16]
                glyph_id = fdsc->cmaps[i].glyph_id_start + ofs;
 801abb8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801abba:	6899      	ldr	r1, [r3, #8]
 801abbc:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801abbe:	4613      	mov	r3, r2
 801abc0:	009b      	lsls	r3, r3, #2
 801abc2:	4413      	add	r3, r2
 801abc4:	009b      	lsls	r3, r3, #2
 801abc6:	440b      	add	r3, r1
 801abc8:	88db      	ldrh	r3, [r3, #6]
 801abca:	461a      	mov	r2, r3
 801abcc:	693b      	ldr	r3, [r7, #16]
 801abce:	4413      	add	r3, r2
 801abd0:	62bb      	str	r3, [r7, #40]	; 0x28
 801abd2:	e055      	b.n	801ac80 <get_glyph_dsc_id+0x238>
            }
        }
        else if(fdsc->cmaps[i].type == LV_FONT_FMT_TXT_CMAP_SPARSE_FULL) {
 801abd4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801abd6:	6899      	ldr	r1, [r3, #8]
 801abd8:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801abda:	4613      	mov	r3, r2
 801abdc:	009b      	lsls	r3, r3, #2
 801abde:	4413      	add	r3, r2
 801abe0:	009b      	lsls	r3, r3, #2
 801abe2:	440b      	add	r3, r1
 801abe4:	7c9b      	ldrb	r3, [r3, #18]
 801abe6:	f003 0303 	and.w	r3, r3, #3
 801abea:	b2db      	uxtb	r3, r3
 801abec:	2b03      	cmp	r3, #3
 801abee:	d147      	bne.n	801ac80 <get_glyph_dsc_id+0x238>
            uint8_t * p = lv_utils_bsearch(&rcp, fdsc->cmaps[i].unicode_list, fdsc->cmaps[i].list_length, sizeof(fdsc->cmaps[i].unicode_list[0]), unicode_list_compare);
 801abf0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801abf2:	6899      	ldr	r1, [r3, #8]
 801abf4:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801abf6:	4613      	mov	r3, r2
 801abf8:	009b      	lsls	r3, r3, #2
 801abfa:	4413      	add	r3, r2
 801abfc:	009b      	lsls	r3, r3, #2
 801abfe:	440b      	add	r3, r1
 801ac00:	689c      	ldr	r4, [r3, #8]
 801ac02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac04:	6899      	ldr	r1, [r3, #8]
 801ac06:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ac08:	4613      	mov	r3, r2
 801ac0a:	009b      	lsls	r3, r3, #2
 801ac0c:	4413      	add	r3, r2
 801ac0e:	009b      	lsls	r3, r3, #2
 801ac10:	440b      	add	r3, r1
 801ac12:	8a1b      	ldrh	r3, [r3, #16]
 801ac14:	461a      	mov	r2, r3
 801ac16:	f107 0008 	add.w	r0, r7, #8
 801ac1a:	4b28      	ldr	r3, [pc, #160]	; (801acbc <get_glyph_dsc_id+0x274>)
 801ac1c:	9300      	str	r3, [sp, #0]
 801ac1e:	2302      	movs	r3, #2
 801ac20:	4621      	mov	r1, r4
 801ac22:	f002 fea3 	bl	801d96c <lv_utils_bsearch>
 801ac26:	6238      	str	r0, [r7, #32]

            if(p) {
 801ac28:	6a3b      	ldr	r3, [r7, #32]
 801ac2a:	2b00      	cmp	r3, #0
 801ac2c:	d028      	beq.n	801ac80 <get_glyph_dsc_id+0x238>
                uint32_t ofs = (lv_uintptr_t)p - (lv_uintptr_t) fdsc->cmaps[i].unicode_list;
 801ac2e:	6a39      	ldr	r1, [r7, #32]
 801ac30:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac32:	6898      	ldr	r0, [r3, #8]
 801ac34:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ac36:	4613      	mov	r3, r2
 801ac38:	009b      	lsls	r3, r3, #2
 801ac3a:	4413      	add	r3, r2
 801ac3c:	009b      	lsls	r3, r3, #2
 801ac3e:	4403      	add	r3, r0
 801ac40:	689b      	ldr	r3, [r3, #8]
 801ac42:	1acb      	subs	r3, r1, r3
 801ac44:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*The list stores `uint16_t` so the get the index divide by 2*/
 801ac46:	69fb      	ldr	r3, [r7, #28]
 801ac48:	085b      	lsrs	r3, r3, #1
 801ac4a:	61fb      	str	r3, [r7, #28]
                const uint8_t * gid_ofs_16 = fdsc->cmaps[i].glyph_id_ofs_list;
 801ac4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac4e:	6899      	ldr	r1, [r3, #8]
 801ac50:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ac52:	4613      	mov	r3, r2
 801ac54:	009b      	lsls	r3, r3, #2
 801ac56:	4413      	add	r3, r2
 801ac58:	009b      	lsls	r3, r3, #2
 801ac5a:	440b      	add	r3, r1
 801ac5c:	68db      	ldr	r3, [r3, #12]
 801ac5e:	61bb      	str	r3, [r7, #24]
                glyph_id = fdsc->cmaps[i].glyph_id_start + gid_ofs_16[ofs];
 801ac60:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac62:	6899      	ldr	r1, [r3, #8]
 801ac64:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801ac66:	4613      	mov	r3, r2
 801ac68:	009b      	lsls	r3, r3, #2
 801ac6a:	4413      	add	r3, r2
 801ac6c:	009b      	lsls	r3, r3, #2
 801ac6e:	440b      	add	r3, r1
 801ac70:	88db      	ldrh	r3, [r3, #6]
 801ac72:	4619      	mov	r1, r3
 801ac74:	69ba      	ldr	r2, [r7, #24]
 801ac76:	69fb      	ldr	r3, [r7, #28]
 801ac78:	4413      	add	r3, r2
 801ac7a:	781b      	ldrb	r3, [r3, #0]
 801ac7c:	440b      	add	r3, r1
 801ac7e:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        /*Update the cache*/
        fdsc->last_letter = letter;
 801ac80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac82:	683a      	ldr	r2, [r7, #0]
 801ac84:	615a      	str	r2, [r3, #20]
        fdsc->last_glyph_id = glyph_id;
 801ac86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac88:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801ac8a:	619a      	str	r2, [r3, #24]
        return glyph_id;
 801ac8c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ac8e:	e010      	b.n	801acb2 <get_glyph_dsc_id+0x26a>
    for(i = 0; i < fdsc->cmap_num; i++) {
 801ac90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ac92:	8a5b      	ldrh	r3, [r3, #18]
 801ac94:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801ac98:	b29b      	uxth	r3, r3
 801ac9a:	461a      	mov	r2, r3
 801ac9c:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801ac9e:	4293      	cmp	r3, r2
 801aca0:	f4ff aeea 	bcc.w	801aa78 <get_glyph_dsc_id+0x30>
    }

    fdsc->last_letter = letter;
 801aca4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801aca6:	683a      	ldr	r2, [r7, #0]
 801aca8:	615a      	str	r2, [r3, #20]
    fdsc->last_glyph_id = 0;
 801acaa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801acac:	2200      	movs	r2, #0
 801acae:	619a      	str	r2, [r3, #24]
    return 0;
 801acb0:	2300      	movs	r3, #0

}
 801acb2:	4618      	mov	r0, r3
 801acb4:	3734      	adds	r7, #52	; 0x34
 801acb6:	46bd      	mov	sp, r7
 801acb8:	bd90      	pop	{r4, r7, pc}
 801acba:	bf00      	nop
 801acbc:	0801aea9 	.word	0x0801aea9

0801acc0 <get_kern_value>:

static int8_t get_kern_value(const lv_font_t * font, uint32_t gid_left, uint32_t gid_right)
{
 801acc0:	b580      	push	{r7, lr}
 801acc2:	b094      	sub	sp, #80	; 0x50
 801acc4:	af02      	add	r7, sp, #8
 801acc6:	60f8      	str	r0, [r7, #12]
 801acc8:	60b9      	str	r1, [r7, #8]
 801acca:	607a      	str	r2, [r7, #4]
    lv_font_fmt_txt_dsc_t * fdsc = (lv_font_fmt_txt_dsc_t *) font->dsc;
 801accc:	68fb      	ldr	r3, [r7, #12]
 801acce:	68db      	ldr	r3, [r3, #12]
 801acd0:	643b      	str	r3, [r7, #64]	; 0x40

    int8_t value = 0;
 801acd2:	2300      	movs	r3, #0
 801acd4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

    if(fdsc->kern_classes == 0) {
 801acd8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801acda:	7cdb      	ldrb	r3, [r3, #19]
 801acdc:	f003 0320 	and.w	r3, r3, #32
 801ace0:	b2db      	uxtb	r3, r3
 801ace2:	2b00      	cmp	r3, #0
 801ace4:	d164      	bne.n	801adb0 <get_kern_value+0xf0>
        /*Kern pairs*/
        const lv_font_fmt_txt_kern_pair_t * kdsc = fdsc->kern_dsc;
 801ace6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801ace8:	68db      	ldr	r3, [r3, #12]
 801acea:	637b      	str	r3, [r7, #52]	; 0x34
        if(kdsc->glyph_ids_size == 0) {
 801acec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801acee:	7adb      	ldrb	r3, [r3, #11]
 801acf0:	f003 0303 	and.w	r3, r3, #3
 801acf4:	b2db      	uxtb	r3, r3
 801acf6:	2b00      	cmp	r3, #0
 801acf8:	d12b      	bne.n	801ad52 <get_kern_value+0x92>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint8_t * g_ids = kdsc->glyph_ids;
 801acfa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801acfc:	681b      	ldr	r3, [r3, #0]
 801acfe:	627b      	str	r3, [r7, #36]	; 0x24
            uint16_t g_id_both = (gid_right << 8) + gid_left; /*Create one number from the ids*/
 801ad00:	687b      	ldr	r3, [r7, #4]
 801ad02:	b29b      	uxth	r3, r3
 801ad04:	021b      	lsls	r3, r3, #8
 801ad06:	b29a      	uxth	r2, r3
 801ad08:	68bb      	ldr	r3, [r7, #8]
 801ad0a:	b29b      	uxth	r3, r3
 801ad0c:	4413      	add	r3, r2
 801ad0e:	b29b      	uxth	r3, r3
 801ad10:	837b      	strh	r3, [r7, #26]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 2, kern_pair_8_compare);
 801ad12:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ad14:	689b      	ldr	r3, [r3, #8]
 801ad16:	f3c3 0317 	ubfx	r3, r3, #0, #24
 801ad1a:	461a      	mov	r2, r3
 801ad1c:	f107 001a 	add.w	r0, r7, #26
 801ad20:	4b3b      	ldr	r3, [pc, #236]	; (801ae10 <get_kern_value+0x150>)
 801ad22:	9300      	str	r3, [sp, #0]
 801ad24:	2302      	movs	r3, #2
 801ad26:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801ad28:	f002 fe20 	bl	801d96c <lv_utils_bsearch>
 801ad2c:	6238      	str	r0, [r7, #32]

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801ad2e:	6a3b      	ldr	r3, [r7, #32]
 801ad30:	2b00      	cmp	r3, #0
 801ad32:	d067      	beq.n	801ae04 <get_kern_value+0x144>
                uint32_t ofs = (lv_uintptr_t)kid_p - (lv_uintptr_t)g_ids;
 801ad34:	6a3a      	ldr	r2, [r7, #32]
 801ad36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801ad38:	1ad3      	subs	r3, r2, r3
 801ad3a:	61fb      	str	r3, [r7, #28]
                ofs = ofs >> 1;     /*ofs is for pair, divide by 2 to refer as a single value*/
 801ad3c:	69fb      	ldr	r3, [r7, #28]
 801ad3e:	085b      	lsrs	r3, r3, #1
 801ad40:	61fb      	str	r3, [r7, #28]
                value = kdsc->values[ofs];
 801ad42:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ad44:	685a      	ldr	r2, [r3, #4]
 801ad46:	69fb      	ldr	r3, [r7, #28]
 801ad48:	4413      	add	r3, r2
 801ad4a:	781b      	ldrb	r3, [r3, #0]
 801ad4c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801ad50:	e058      	b.n	801ae04 <get_kern_value+0x144>
            }
        } else if(kdsc->glyph_ids_size == 1) {
 801ad52:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ad54:	7adb      	ldrb	r3, [r3, #11]
 801ad56:	f003 0303 	and.w	r3, r3, #3
 801ad5a:	b2db      	uxtb	r3, r3
 801ad5c:	2b01      	cmp	r3, #1
 801ad5e:	d151      	bne.n	801ae04 <get_kern_value+0x144>
            /* Use binary search to find the kern value.
             * The pairs are ordered left_id first, then right_id secondly. */
            const uint16_t * g_ids = kdsc->glyph_ids;
 801ad60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ad62:	681b      	ldr	r3, [r3, #0]
 801ad64:	633b      	str	r3, [r7, #48]	; 0x30
            uint32_t g_id_both = (uint32_t)((uint32_t)gid_right << 8) + gid_left; /*Create one number from the ids*/
 801ad66:	687b      	ldr	r3, [r7, #4]
 801ad68:	021a      	lsls	r2, r3, #8
 801ad6a:	68bb      	ldr	r3, [r7, #8]
 801ad6c:	4413      	add	r3, r2
 801ad6e:	617b      	str	r3, [r7, #20]
            uint8_t * kid_p = lv_utils_bsearch(&g_id_both, g_ids, kdsc->pair_cnt, 4, kern_pair_16_compare);
 801ad70:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ad72:	689b      	ldr	r3, [r3, #8]
 801ad74:	f3c3 0317 	ubfx	r3, r3, #0, #24
 801ad78:	461a      	mov	r2, r3
 801ad7a:	f107 0014 	add.w	r0, r7, #20
 801ad7e:	4b25      	ldr	r3, [pc, #148]	; (801ae14 <get_kern_value+0x154>)
 801ad80:	9300      	str	r3, [sp, #0]
 801ad82:	2304      	movs	r3, #4
 801ad84:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801ad86:	f002 fdf1 	bl	801d96c <lv_utils_bsearch>
 801ad8a:	62f8      	str	r0, [r7, #44]	; 0x2c

            /*If the `g_id_both` were found get its index from the pointer*/
            if(kid_p) {
 801ad8c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801ad8e:	2b00      	cmp	r3, #0
 801ad90:	d038      	beq.n	801ae04 <get_kern_value+0x144>
                uint32_t ofs = (lv_uintptr_t)kid_p - (lv_uintptr_t)g_ids;
 801ad92:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801ad94:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801ad96:	1ad3      	subs	r3, r2, r3
 801ad98:	62bb      	str	r3, [r7, #40]	; 0x28
                ofs = ofs >> 4;     /*ofs is 4 byte pairs, divide by 4 to refer as a single value*/
 801ad9a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ad9c:	091b      	lsrs	r3, r3, #4
 801ad9e:	62bb      	str	r3, [r7, #40]	; 0x28
                value = kdsc->values[ofs];
 801ada0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ada2:	685a      	ldr	r2, [r3, #4]
 801ada4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801ada6:	4413      	add	r3, r2
 801ada8:	781b      	ldrb	r3, [r3, #0]
 801adaa:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
 801adae:	e029      	b.n	801ae04 <get_kern_value+0x144>
        } else {
            /*Invalid value*/
        }
    } else {
        /*Kern classes*/
        const lv_font_fmt_txt_kern_classes_t * kdsc = fdsc->kern_dsc;
 801adb0:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801adb2:	68db      	ldr	r3, [r3, #12]
 801adb4:	63fb      	str	r3, [r7, #60]	; 0x3c
        uint8_t left_class = kdsc->left_class_mapping[gid_left];
 801adb6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801adb8:	685a      	ldr	r2, [r3, #4]
 801adba:	68bb      	ldr	r3, [r7, #8]
 801adbc:	4413      	add	r3, r2
 801adbe:	781b      	ldrb	r3, [r3, #0]
 801adc0:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        uint8_t right_class = kdsc->left_class_mapping[gid_right];
 801adc4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801adc6:	685a      	ldr	r2, [r3, #4]
 801adc8:	687b      	ldr	r3, [r7, #4]
 801adca:	4413      	add	r3, r2
 801adcc:	781b      	ldrb	r3, [r3, #0]
 801adce:	f887 303a 	strb.w	r3, [r7, #58]	; 0x3a

        /* If class = 0, kerning not exist for that glyph
         * else got the value form `class_pair_values` 2D array*/
        if(left_class > 0 && right_class > 0) {
 801add2:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 801add6:	2b00      	cmp	r3, #0
 801add8:	d014      	beq.n	801ae04 <get_kern_value+0x144>
 801adda:	f897 303a 	ldrb.w	r3, [r7, #58]	; 0x3a
 801adde:	2b00      	cmp	r3, #0
 801ade0:	d010      	beq.n	801ae04 <get_kern_value+0x144>
            value = kdsc->class_pair_values[(left_class-1)* kdsc->right_class_cnt + (right_class-1)];
 801ade2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ade4:	681b      	ldr	r3, [r3, #0]
 801ade6:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 801adea:	3a01      	subs	r2, #1
 801adec:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801adee:	7b49      	ldrb	r1, [r1, #13]
 801adf0:	fb01 f102 	mul.w	r1, r1, r2
 801adf4:	f897 203a 	ldrb.w	r2, [r7, #58]	; 0x3a
 801adf8:	3a01      	subs	r2, #1
 801adfa:	440a      	add	r2, r1
 801adfc:	4413      	add	r3, r2
 801adfe:	781b      	ldrb	r3, [r3, #0]
 801ae00:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        }

    }
    return value;
 801ae04:	f997 3047 	ldrsb.w	r3, [r7, #71]	; 0x47
}
 801ae08:	4618      	mov	r0, r3
 801ae0a:	3748      	adds	r7, #72	; 0x48
 801ae0c:	46bd      	mov	sp, r7
 801ae0e:	bd80      	pop	{r7, pc}
 801ae10:	0801ae19 	.word	0x0801ae19
 801ae14:	0801ae61 	.word	0x0801ae61

0801ae18 <kern_pair_8_compare>:

static int32_t kern_pair_8_compare(const void * ref, const void * element)
{
 801ae18:	b480      	push	{r7}
 801ae1a:	b085      	sub	sp, #20
 801ae1c:	af00      	add	r7, sp, #0
 801ae1e:	6078      	str	r0, [r7, #4]
 801ae20:	6039      	str	r1, [r7, #0]
    const uint8_t * ref8_p = ref;
 801ae22:	687b      	ldr	r3, [r7, #4]
 801ae24:	60fb      	str	r3, [r7, #12]
    const uint8_t * element8_p = element;
 801ae26:	683b      	ldr	r3, [r7, #0]
 801ae28:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref8_p[0] != element8_p[0]) return (int32_t)ref8_p[0] - element8_p[0];
 801ae2a:	68fb      	ldr	r3, [r7, #12]
 801ae2c:	781a      	ldrb	r2, [r3, #0]
 801ae2e:	68bb      	ldr	r3, [r7, #8]
 801ae30:	781b      	ldrb	r3, [r3, #0]
 801ae32:	429a      	cmp	r2, r3
 801ae34:	d006      	beq.n	801ae44 <kern_pair_8_compare+0x2c>
 801ae36:	68fb      	ldr	r3, [r7, #12]
 801ae38:	781b      	ldrb	r3, [r3, #0]
 801ae3a:	461a      	mov	r2, r3
 801ae3c:	68bb      	ldr	r3, [r7, #8]
 801ae3e:	781b      	ldrb	r3, [r3, #0]
 801ae40:	1ad3      	subs	r3, r2, r3
 801ae42:	e007      	b.n	801ae54 <kern_pair_8_compare+0x3c>
    else return (int32_t) ref8_p[1] - element8_p[1];
 801ae44:	68fb      	ldr	r3, [r7, #12]
 801ae46:	3301      	adds	r3, #1
 801ae48:	781b      	ldrb	r3, [r3, #0]
 801ae4a:	461a      	mov	r2, r3
 801ae4c:	68bb      	ldr	r3, [r7, #8]
 801ae4e:	3301      	adds	r3, #1
 801ae50:	781b      	ldrb	r3, [r3, #0]
 801ae52:	1ad3      	subs	r3, r2, r3

}
 801ae54:	4618      	mov	r0, r3
 801ae56:	3714      	adds	r7, #20
 801ae58:	46bd      	mov	sp, r7
 801ae5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ae5e:	4770      	bx	lr

0801ae60 <kern_pair_16_compare>:

static int32_t kern_pair_16_compare(const void * ref, const void * element)
{
 801ae60:	b480      	push	{r7}
 801ae62:	b085      	sub	sp, #20
 801ae64:	af00      	add	r7, sp, #0
 801ae66:	6078      	str	r0, [r7, #4]
 801ae68:	6039      	str	r1, [r7, #0]
    const uint16_t * ref16_p = ref;
 801ae6a:	687b      	ldr	r3, [r7, #4]
 801ae6c:	60fb      	str	r3, [r7, #12]
    const uint16_t * element16_p = element;
 801ae6e:	683b      	ldr	r3, [r7, #0]
 801ae70:	60bb      	str	r3, [r7, #8]

    /*If the MSB is different it will matter. If not return the diff. of the LSB*/
    if(ref16_p[0] != element16_p[0]) return (int32_t)ref16_p[0] - element16_p[0];
 801ae72:	68fb      	ldr	r3, [r7, #12]
 801ae74:	881a      	ldrh	r2, [r3, #0]
 801ae76:	68bb      	ldr	r3, [r7, #8]
 801ae78:	881b      	ldrh	r3, [r3, #0]
 801ae7a:	429a      	cmp	r2, r3
 801ae7c:	d006      	beq.n	801ae8c <kern_pair_16_compare+0x2c>
 801ae7e:	68fb      	ldr	r3, [r7, #12]
 801ae80:	881b      	ldrh	r3, [r3, #0]
 801ae82:	461a      	mov	r2, r3
 801ae84:	68bb      	ldr	r3, [r7, #8]
 801ae86:	881b      	ldrh	r3, [r3, #0]
 801ae88:	1ad3      	subs	r3, r2, r3
 801ae8a:	e007      	b.n	801ae9c <kern_pair_16_compare+0x3c>
    else return (int32_t) ref16_p[1] - element16_p[1];
 801ae8c:	68fb      	ldr	r3, [r7, #12]
 801ae8e:	3302      	adds	r3, #2
 801ae90:	881b      	ldrh	r3, [r3, #0]
 801ae92:	461a      	mov	r2, r3
 801ae94:	68bb      	ldr	r3, [r7, #8]
 801ae96:	3302      	adds	r3, #2
 801ae98:	881b      	ldrh	r3, [r3, #0]
 801ae9a:	1ad3      	subs	r3, r2, r3
}
 801ae9c:	4618      	mov	r0, r3
 801ae9e:	3714      	adds	r7, #20
 801aea0:	46bd      	mov	sp, r7
 801aea2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aea6:	4770      	bx	lr

0801aea8 <unicode_list_compare>:
 *  @retval = 0   Reference is equal to element.
 *  @retval > 0   Reference is less than element.
 *
 */
static int32_t unicode_list_compare(const void * ref, const void * element)
{
 801aea8:	b480      	push	{r7}
 801aeaa:	b083      	sub	sp, #12
 801aeac:	af00      	add	r7, sp, #0
 801aeae:	6078      	str	r0, [r7, #4]
 801aeb0:	6039      	str	r1, [r7, #0]
    return (*(uint16_t *)ref) - (*(uint16_t *)element);
 801aeb2:	687b      	ldr	r3, [r7, #4]
 801aeb4:	881b      	ldrh	r3, [r3, #0]
 801aeb6:	461a      	mov	r2, r3
 801aeb8:	683b      	ldr	r3, [r7, #0]
 801aeba:	881b      	ldrh	r3, [r3, #0]
 801aebc:	1ad3      	subs	r3, r2, r3
}
 801aebe:	4618      	mov	r0, r3
 801aec0:	370c      	adds	r7, #12
 801aec2:	46bd      	mov	sp, r7
 801aec4:	f85d 7b04 	ldr.w	r7, [sp], #4
 801aec8:	4770      	bx	lr

0801aeca <lv_disp_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_disp_drv_init(lv_disp_drv_t * driver)
{
 801aeca:	b580      	push	{r7, lr}
 801aecc:	b082      	sub	sp, #8
 801aece:	af00      	add	r7, sp, #0
 801aed0:	6078      	str	r0, [r7, #4]
    memset(driver, 0, sizeof(lv_disp_drv_t));
 801aed2:	222c      	movs	r2, #44	; 0x2c
 801aed4:	2100      	movs	r1, #0
 801aed6:	6878      	ldr	r0, [r7, #4]
 801aed8:	f00c f97b 	bl	80271d2 <memset>

    driver->flush_cb         = NULL;
 801aedc:	687b      	ldr	r3, [r7, #4]
 801aede:	2200      	movs	r2, #0
 801aee0:	60da      	str	r2, [r3, #12]
    driver->hor_res          = LV_HOR_RES_MAX;
 801aee2:	687b      	ldr	r3, [r7, #4]
 801aee4:	f44f 72f0 	mov.w	r2, #480	; 0x1e0
 801aee8:	801a      	strh	r2, [r3, #0]
    driver->ver_res          = LV_VER_RES_MAX;
 801aeea:	687b      	ldr	r3, [r7, #4]
 801aeec:	f44f 72a0 	mov.w	r2, #320	; 0x140
 801aef0:	805a      	strh	r2, [r3, #2]
    driver->buffer           = NULL;
 801aef2:	687b      	ldr	r3, [r7, #4]
 801aef4:	2200      	movs	r2, #0
 801aef6:	605a      	str	r2, [r3, #4]
    driver->rotated          = 0;
 801aef8:	687a      	ldr	r2, [r7, #4]
 801aefa:	7a13      	ldrb	r3, [r2, #8]
 801aefc:	f36f 0341 	bfc	r3, #1, #1
 801af00:	7213      	strb	r3, [r2, #8]
    driver->color_chroma_key = LV_COLOR_TRANSP;
 801af02:	687a      	ldr	r2, [r7, #4]
 801af04:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801af08:	f36f 0304 	bfc	r3, #0, #5
 801af0c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
 801af10:	687a      	ldr	r2, [r7, #4]
 801af12:	8c93      	ldrh	r3, [r2, #36]	; 0x24
 801af14:	f443 63fc 	orr.w	r3, r3, #2016	; 0x7e0
 801af18:	8493      	strh	r3, [r2, #36]	; 0x24
 801af1a:	687a      	ldr	r2, [r7, #4]
 801af1c:	f892 3025 	ldrb.w	r3, [r2, #37]	; 0x25
 801af20:	f36f 03c7 	bfc	r3, #3, #5
 801af24:	f882 3025 	strb.w	r3, [r2, #37]	; 0x25

#if LV_ANTIALIAS
    driver->antialiasing = true;
 801af28:	687a      	ldr	r2, [r7, #4]
 801af2a:	7a13      	ldrb	r3, [r2, #8]
 801af2c:	f043 0301 	orr.w	r3, r3, #1
 801af30:	7213      	strb	r3, [r2, #8]
#if LV_COLOR_SCREEN_TRANSP
    driver->screen_transp = 1;
#endif

#if LV_USE_GPU
    driver->gpu_blend_cb = NULL;
 801af32:	687b      	ldr	r3, [r7, #4]
 801af34:	2200      	movs	r2, #0
 801af36:	61da      	str	r2, [r3, #28]
    driver->gpu_fill_cb  = NULL;
 801af38:	687b      	ldr	r3, [r7, #4]
 801af3a:	2200      	movs	r2, #0
 801af3c:	621a      	str	r2, [r3, #32]
#endif

#if LV_USE_USER_DATA
    driver->user_data = NULL;
 801af3e:	687b      	ldr	r3, [r7, #4]
 801af40:	2200      	movs	r2, #0
 801af42:	629a      	str	r2, [r3, #40]	; 0x28
#endif

    driver->set_px_cb = NULL;
 801af44:	687b      	ldr	r3, [r7, #4]
 801af46:	2200      	movs	r2, #0
 801af48:	615a      	str	r2, [r3, #20]
}
 801af4a:	bf00      	nop
 801af4c:	3708      	adds	r7, #8
 801af4e:	46bd      	mov	sp, r7
 801af50:	bd80      	pop	{r7, pc}

0801af52 <lv_disp_buf_init>:
 *             It lets LittlevGL to render next frame into the other buffer while previous is being
 * sent. Set to `NULL` if unused.
 * @param size_in_px_cnt size of the `buf1` and `buf2` in pixel count.
 */
void lv_disp_buf_init(lv_disp_buf_t * disp_buf, void * buf1, void * buf2, uint32_t size_in_px_cnt)
{
 801af52:	b580      	push	{r7, lr}
 801af54:	b084      	sub	sp, #16
 801af56:	af00      	add	r7, sp, #0
 801af58:	60f8      	str	r0, [r7, #12]
 801af5a:	60b9      	str	r1, [r7, #8]
 801af5c:	607a      	str	r2, [r7, #4]
 801af5e:	603b      	str	r3, [r7, #0]
    memset(disp_buf, 0, sizeof(lv_disp_buf_t));
 801af60:	221c      	movs	r2, #28
 801af62:	2100      	movs	r1, #0
 801af64:	68f8      	ldr	r0, [r7, #12]
 801af66:	f00c f934 	bl	80271d2 <memset>

    disp_buf->buf1    = buf1;
 801af6a:	68fb      	ldr	r3, [r7, #12]
 801af6c:	68ba      	ldr	r2, [r7, #8]
 801af6e:	601a      	str	r2, [r3, #0]
    disp_buf->buf2    = buf2;
 801af70:	68fb      	ldr	r3, [r7, #12]
 801af72:	687a      	ldr	r2, [r7, #4]
 801af74:	605a      	str	r2, [r3, #4]
    disp_buf->buf_act = disp_buf->buf1;
 801af76:	68fb      	ldr	r3, [r7, #12]
 801af78:	681a      	ldr	r2, [r3, #0]
 801af7a:	68fb      	ldr	r3, [r7, #12]
 801af7c:	609a      	str	r2, [r3, #8]
    disp_buf->size    = size_in_px_cnt;
 801af7e:	68fb      	ldr	r3, [r7, #12]
 801af80:	683a      	ldr	r2, [r7, #0]
 801af82:	60da      	str	r2, [r3, #12]
}
 801af84:	bf00      	nop
 801af86:	3710      	adds	r7, #16
 801af88:	46bd      	mov	sp, r7
 801af8a:	bd80      	pop	{r7, pc}

0801af8c <lv_disp_drv_register>:
 * Automatically set the first display as active.
 * @param driver pointer to an initialized 'lv_disp_drv_t' variable (can be local variable)
 * @return pointer to the new display or NULL on error
 */
lv_disp_t * lv_disp_drv_register(lv_disp_drv_t * driver)
{
 801af8c:	b580      	push	{r7, lr}
 801af8e:	b084      	sub	sp, #16
 801af90:	af00      	add	r7, sp, #0
 801af92:	6078      	str	r0, [r7, #4]
    lv_disp_t * disp = lv_ll_ins_head(&LV_GC_ROOT(_lv_disp_ll));
 801af94:	4847      	ldr	r0, [pc, #284]	; (801b0b4 <lv_disp_drv_register+0x128>)
 801af96:	f001 f9cf 	bl	801c338 <lv_ll_ins_head>
 801af9a:	60f8      	str	r0, [r7, #12]
    if(!disp) {
 801af9c:	68fb      	ldr	r3, [r7, #12]
 801af9e:	2b00      	cmp	r3, #0
 801afa0:	d10b      	bne.n	801afba <lv_disp_drv_register+0x2e>
        lv_mem_assert(disp);
 801afa2:	68fb      	ldr	r3, [r7, #12]
 801afa4:	2b00      	cmp	r3, #0
 801afa6:	d106      	bne.n	801afb6 <lv_disp_drv_register+0x2a>
 801afa8:	4b43      	ldr	r3, [pc, #268]	; (801b0b8 <lv_disp_drv_register+0x12c>)
 801afaa:	2279      	movs	r2, #121	; 0x79
 801afac:	4943      	ldr	r1, [pc, #268]	; (801b0bc <lv_disp_drv_register+0x130>)
 801afae:	2003      	movs	r0, #3
 801afb0:	f001 fc2c 	bl	801c80c <lv_log_add>
 801afb4:	e7fe      	b.n	801afb4 <lv_disp_drv_register+0x28>
        return NULL;
 801afb6:	2300      	movs	r3, #0
 801afb8:	e078      	b.n	801b0ac <lv_disp_drv_register+0x120>
    }

    memcpy(&disp->driver, driver, sizeof(lv_disp_drv_t));
 801afba:	68fb      	ldr	r3, [r7, #12]
 801afbc:	222c      	movs	r2, #44	; 0x2c
 801afbe:	6879      	ldr	r1, [r7, #4]
 801afc0:	4618      	mov	r0, r3
 801afc2:	f00c f8fb 	bl	80271bc <memcpy>
    memset(&disp->inv_area_joined, 0, sizeof(disp->inv_area_joined));
 801afc6:	68fb      	ldr	r3, [r7, #12]
 801afc8:	f503 73a4 	add.w	r3, r3, #328	; 0x148
 801afcc:	2220      	movs	r2, #32
 801afce:	2100      	movs	r1, #0
 801afd0:	4618      	mov	r0, r3
 801afd2:	f00c f8fe 	bl	80271d2 <memset>
    memset(&disp->inv_areas, 0, sizeof(disp->inv_areas));
 801afd6:	68fb      	ldr	r3, [r7, #12]
 801afd8:	3348      	adds	r3, #72	; 0x48
 801afda:	f44f 7280 	mov.w	r2, #256	; 0x100
 801afde:	2100      	movs	r1, #0
 801afe0:	4618      	mov	r0, r3
 801afe2:	f00c f8f6 	bl	80271d2 <memset>
    lv_ll_init(&disp->scr_ll, sizeof(lv_obj_t));
 801afe6:	68fb      	ldr	r3, [r7, #12]
 801afe8:	3330      	adds	r3, #48	; 0x30
 801afea:	2148      	movs	r1, #72	; 0x48
 801afec:	4618      	mov	r0, r3
 801afee:	f001 f983 	bl	801c2f8 <lv_ll_init>

    if(disp_def == NULL) disp_def = disp;
 801aff2:	4b33      	ldr	r3, [pc, #204]	; (801b0c0 <lv_disp_drv_register+0x134>)
 801aff4:	681b      	ldr	r3, [r3, #0]
 801aff6:	2b00      	cmp	r3, #0
 801aff8:	d102      	bne.n	801b000 <lv_disp_drv_register+0x74>
 801affa:	4a31      	ldr	r2, [pc, #196]	; (801b0c0 <lv_disp_drv_register+0x134>)
 801affc:	68fb      	ldr	r3, [r7, #12]
 801affe:	6013      	str	r3, [r2, #0]

    lv_disp_t * disp_def_tmp = disp_def;
 801b000:	4b2f      	ldr	r3, [pc, #188]	; (801b0c0 <lv_disp_drv_register+0x134>)
 801b002:	681b      	ldr	r3, [r3, #0]
 801b004:	60bb      	str	r3, [r7, #8]
    disp_def                 = disp; /*Temporarily change the default screen to create the default screens on the
 801b006:	4a2e      	ldr	r2, [pc, #184]	; (801b0c0 <lv_disp_drv_register+0x134>)
 801b008:	68fb      	ldr	r3, [r7, #12]
 801b00a:	6013      	str	r3, [r2, #0]
                                        new display*/

    disp->inv_p = 0;
 801b00c:	68fa      	ldr	r2, [r7, #12]
 801b00e:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 801b012:	f36f 0309 	bfc	r3, #0, #10
 801b016:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168

    disp->act_scr   = lv_obj_create(NULL, NULL); /*Create a default screen on the display*/
 801b01a:	2100      	movs	r1, #0
 801b01c:	2000      	movs	r0, #0
 801b01e:	f7f5 fbb1 	bl	8010784 <lv_obj_create>
 801b022:	4602      	mov	r2, r0
 801b024:	68fb      	ldr	r3, [r7, #12]
 801b026:	63da      	str	r2, [r3, #60]	; 0x3c
    disp->top_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
 801b028:	2100      	movs	r1, #0
 801b02a:	2000      	movs	r0, #0
 801b02c:	f7f5 fbaa 	bl	8010784 <lv_obj_create>
 801b030:	4602      	mov	r2, r0
 801b032:	68fb      	ldr	r3, [r7, #12]
 801b034:	641a      	str	r2, [r3, #64]	; 0x40
    disp->sys_layer = lv_obj_create(NULL, NULL); /*Create top layer on the display*/
 801b036:	2100      	movs	r1, #0
 801b038:	2000      	movs	r0, #0
 801b03a:	f7f5 fba3 	bl	8010784 <lv_obj_create>
 801b03e:	4602      	mov	r2, r0
 801b040:	68fb      	ldr	r3, [r7, #12]
 801b042:	645a      	str	r2, [r3, #68]	; 0x44
    lv_obj_set_style(disp->top_layer, &lv_style_transp);
 801b044:	68fb      	ldr	r3, [r7, #12]
 801b046:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801b048:	491e      	ldr	r1, [pc, #120]	; (801b0c4 <lv_disp_drv_register+0x138>)
 801b04a:	4618      	mov	r0, r3
 801b04c:	f7f6 fe31 	bl	8011cb2 <lv_obj_set_style>
    lv_obj_set_style(disp->sys_layer, &lv_style_transp);
 801b050:	68fb      	ldr	r3, [r7, #12]
 801b052:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 801b054:	491b      	ldr	r1, [pc, #108]	; (801b0c4 <lv_disp_drv_register+0x138>)
 801b056:	4618      	mov	r0, r3
 801b058:	f7f6 fe2b 	bl	8011cb2 <lv_obj_set_style>

    lv_obj_invalidate(disp->act_scr);
 801b05c:	68fb      	ldr	r3, [r7, #12]
 801b05e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 801b060:	4618      	mov	r0, r3
 801b062:	f7f5 fee4 	bl	8010e2e <lv_obj_invalidate>

    disp_def = disp_def_tmp; /*Revert the default display*/
 801b066:	4a16      	ldr	r2, [pc, #88]	; (801b0c0 <lv_disp_drv_register+0x134>)
 801b068:	68bb      	ldr	r3, [r7, #8]
 801b06a:	6013      	str	r3, [r2, #0]

    /*Create a refresh task*/
    disp->refr_task = lv_task_create(lv_disp_refr_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, disp);
 801b06c:	68fb      	ldr	r3, [r7, #12]
 801b06e:	2203      	movs	r2, #3
 801b070:	211e      	movs	r1, #30
 801b072:	4815      	ldr	r0, [pc, #84]	; (801b0c8 <lv_disp_drv_register+0x13c>)
 801b074:	f001 ff40 	bl	801cef8 <lv_task_create>
 801b078:	4602      	mov	r2, r0
 801b07a:	68fb      	ldr	r3, [r7, #12]
 801b07c:	62da      	str	r2, [r3, #44]	; 0x2c
    lv_mem_assert(disp->refr_task);
 801b07e:	68fb      	ldr	r3, [r7, #12]
 801b080:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b082:	2b00      	cmp	r3, #0
 801b084:	d106      	bne.n	801b094 <lv_disp_drv_register+0x108>
 801b086:	4b0c      	ldr	r3, [pc, #48]	; (801b0b8 <lv_disp_drv_register+0x12c>)
 801b088:	2296      	movs	r2, #150	; 0x96
 801b08a:	490c      	ldr	r1, [pc, #48]	; (801b0bc <lv_disp_drv_register+0x130>)
 801b08c:	2003      	movs	r0, #3
 801b08e:	f001 fbbd 	bl	801c80c <lv_log_add>
 801b092:	e7fe      	b.n	801b092 <lv_disp_drv_register+0x106>
    if(disp->refr_task == NULL) return NULL;
 801b094:	68fb      	ldr	r3, [r7, #12]
 801b096:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b098:	2b00      	cmp	r3, #0
 801b09a:	d101      	bne.n	801b0a0 <lv_disp_drv_register+0x114>
 801b09c:	2300      	movs	r3, #0
 801b09e:	e005      	b.n	801b0ac <lv_disp_drv_register+0x120>

    lv_task_ready(disp->refr_task); /*Be sure the screen will be refreshed immediately on start up*/
 801b0a0:	68fb      	ldr	r3, [r7, #12]
 801b0a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 801b0a4:	4618      	mov	r0, r3
 801b0a6:	f001 ffdf 	bl	801d068 <lv_task_ready>

    return disp;
 801b0aa:	68fb      	ldr	r3, [r7, #12]
}
 801b0ac:	4618      	mov	r0, r3
 801b0ae:	3710      	adds	r7, #16
 801b0b0:	46bd      	mov	sp, r7
 801b0b2:	bd80      	pop	{r7, pc}
 801b0b4:	2000df60 	.word	0x2000df60
 801b0b8:	08028d68 	.word	0x08028d68
 801b0bc:	08028d78 	.word	0x08028d78
 801b0c0:	20004378 	.word	0x20004378
 801b0c4:	2000dc74 	.word	0x2000dc74
 801b0c8:	08012ab9 	.word	0x08012ab9

0801b0cc <lv_disp_get_default>:
/**
 * Get the default display
 * @return pointer to the default display
 */
lv_disp_t * lv_disp_get_default(void)
{
 801b0cc:	b480      	push	{r7}
 801b0ce:	af00      	add	r7, sp, #0
    return disp_def;
 801b0d0:	4b03      	ldr	r3, [pc, #12]	; (801b0e0 <lv_disp_get_default+0x14>)
 801b0d2:	681b      	ldr	r3, [r3, #0]
}
 801b0d4:	4618      	mov	r0, r3
 801b0d6:	46bd      	mov	sp, r7
 801b0d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b0dc:	4770      	bx	lr
 801b0de:	bf00      	nop
 801b0e0:	20004378 	.word	0x20004378

0801b0e4 <lv_disp_get_hor_res>:
 * Get the horizontal resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the horizontal resolution of the display
 */
lv_coord_t lv_disp_get_hor_res(lv_disp_t * disp)
{
 801b0e4:	b580      	push	{r7, lr}
 801b0e6:	b082      	sub	sp, #8
 801b0e8:	af00      	add	r7, sp, #0
 801b0ea:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801b0ec:	687b      	ldr	r3, [r7, #4]
 801b0ee:	2b00      	cmp	r3, #0
 801b0f0:	d102      	bne.n	801b0f8 <lv_disp_get_hor_res+0x14>
 801b0f2:	f7ff ffeb 	bl	801b0cc <lv_disp_get_default>
 801b0f6:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 801b0f8:	687b      	ldr	r3, [r7, #4]
 801b0fa:	2b00      	cmp	r3, #0
 801b0fc:	d102      	bne.n	801b104 <lv_disp_get_hor_res+0x20>
        return LV_HOR_RES_MAX;
 801b0fe:	f44f 73f0 	mov.w	r3, #480	; 0x1e0
 801b102:	e00d      	b.n	801b120 <lv_disp_get_hor_res+0x3c>
    else
        return disp->driver.rotated == 0 ? disp->driver.hor_res : disp->driver.ver_res;
 801b104:	687b      	ldr	r3, [r7, #4]
 801b106:	7a1b      	ldrb	r3, [r3, #8]
 801b108:	f003 0302 	and.w	r3, r3, #2
 801b10c:	b2db      	uxtb	r3, r3
 801b10e:	2b00      	cmp	r3, #0
 801b110:	d103      	bne.n	801b11a <lv_disp_get_hor_res+0x36>
 801b112:	687b      	ldr	r3, [r7, #4]
 801b114:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b118:	e002      	b.n	801b120 <lv_disp_get_hor_res+0x3c>
 801b11a:	687b      	ldr	r3, [r7, #4]
 801b11c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
}
 801b120:	4618      	mov	r0, r3
 801b122:	3708      	adds	r7, #8
 801b124:	46bd      	mov	sp, r7
 801b126:	bd80      	pop	{r7, pc}

0801b128 <lv_disp_get_ver_res>:
 * Get the vertical resolution of a display
 * @param disp pointer to a display (NULL to use the default display)
 * @return the vertical resolution of the display
 */
lv_coord_t lv_disp_get_ver_res(lv_disp_t * disp)
{
 801b128:	b580      	push	{r7, lr}
 801b12a:	b082      	sub	sp, #8
 801b12c:	af00      	add	r7, sp, #0
 801b12e:	6078      	str	r0, [r7, #4]
    if(disp == NULL) disp = lv_disp_get_default();
 801b130:	687b      	ldr	r3, [r7, #4]
 801b132:	2b00      	cmp	r3, #0
 801b134:	d102      	bne.n	801b13c <lv_disp_get_ver_res+0x14>
 801b136:	f7ff ffc9 	bl	801b0cc <lv_disp_get_default>
 801b13a:	6078      	str	r0, [r7, #4]

    if(disp == NULL)
 801b13c:	687b      	ldr	r3, [r7, #4]
 801b13e:	2b00      	cmp	r3, #0
 801b140:	d102      	bne.n	801b148 <lv_disp_get_ver_res+0x20>
        return LV_VER_RES_MAX;
 801b142:	f44f 73a0 	mov.w	r3, #320	; 0x140
 801b146:	e00d      	b.n	801b164 <lv_disp_get_ver_res+0x3c>
    else
        return disp->driver.rotated == 0 ? disp->driver.ver_res : disp->driver.hor_res;
 801b148:	687b      	ldr	r3, [r7, #4]
 801b14a:	7a1b      	ldrb	r3, [r3, #8]
 801b14c:	f003 0302 	and.w	r3, r3, #2
 801b150:	b2db      	uxtb	r3, r3
 801b152:	2b00      	cmp	r3, #0
 801b154:	d103      	bne.n	801b15e <lv_disp_get_ver_res+0x36>
 801b156:	687b      	ldr	r3, [r7, #4]
 801b158:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b15c:	e002      	b.n	801b164 <lv_disp_get_ver_res+0x3c>
 801b15e:	687b      	ldr	r3, [r7, #4]
 801b160:	f9b3 3000 	ldrsh.w	r3, [r3]
}
 801b164:	4618      	mov	r0, r3
 801b166:	3708      	adds	r7, #8
 801b168:	46bd      	mov	sp, r7
 801b16a:	bd80      	pop	{r7, pc}

0801b16c <lv_disp_get_antialiasing>:
 * Get if anti-aliasing is enabled for a display or not
 * @param disp pointer to a display (NULL to use the default display)
 * @return true: anti-aliasing is enabled; false: disabled
 */
bool lv_disp_get_antialiasing(lv_disp_t * disp)
{
 801b16c:	b580      	push	{r7, lr}
 801b16e:	b082      	sub	sp, #8
 801b170:	af00      	add	r7, sp, #0
 801b172:	6078      	str	r0, [r7, #4]
#if LV_ANTIALIAS == 0
    return false;
#else
    if(disp == NULL) disp = lv_disp_get_default();
 801b174:	687b      	ldr	r3, [r7, #4]
 801b176:	2b00      	cmp	r3, #0
 801b178:	d102      	bne.n	801b180 <lv_disp_get_antialiasing+0x14>
 801b17a:	f7ff ffa7 	bl	801b0cc <lv_disp_get_default>
 801b17e:	6078      	str	r0, [r7, #4]
    if(disp == NULL) return false;
 801b180:	687b      	ldr	r3, [r7, #4]
 801b182:	2b00      	cmp	r3, #0
 801b184:	d101      	bne.n	801b18a <lv_disp_get_antialiasing+0x1e>
 801b186:	2300      	movs	r3, #0
 801b188:	e008      	b.n	801b19c <lv_disp_get_antialiasing+0x30>

    return disp->driver.antialiasing ? true : false;
 801b18a:	687b      	ldr	r3, [r7, #4]
 801b18c:	7a1b      	ldrb	r3, [r3, #8]
 801b18e:	f003 0301 	and.w	r3, r3, #1
 801b192:	2b00      	cmp	r3, #0
 801b194:	bf14      	ite	ne
 801b196:	2301      	movne	r3, #1
 801b198:	2300      	moveq	r3, #0
 801b19a:	b2db      	uxtb	r3, r3
#endif
}
 801b19c:	4618      	mov	r0, r3
 801b19e:	3708      	adds	r7, #8
 801b1a0:	46bd      	mov	sp, r7
 801b1a2:	bd80      	pop	{r7, pc}

0801b1a4 <lv_disp_flush_ready>:
/**
 * Call in the display driver's `flush_cb` function when the flushing is finished
 * @param disp_drv pointer to display driver in `flush_cb` where this function is called
 */
LV_ATTRIBUTE_FLUSH_READY void lv_disp_flush_ready(lv_disp_drv_t * disp_drv)
{
 801b1a4:	b480      	push	{r7}
 801b1a6:	b083      	sub	sp, #12
 801b1a8:	af00      	add	r7, sp, #0
 801b1aa:	6078      	str	r0, [r7, #4]
    disp_drv->buffer->flushing = 0;
 801b1ac:	687b      	ldr	r3, [r7, #4]
 801b1ae:	685a      	ldr	r2, [r3, #4]
 801b1b0:	7e13      	ldrb	r3, [r2, #24]
 801b1b2:	f36f 0300 	bfc	r3, #0, #1
 801b1b6:	7613      	strb	r3, [r2, #24]
#if LV_COLOR_SCREEN_TRANSP
    if(disp_drv->screen_transp) {
        memset(disp_drv->buffer->buf_act, 0x00, disp_drv->buffer->size * sizeof(lv_color32_t));
    }
#endif
}
 801b1b8:	bf00      	nop
 801b1ba:	370c      	adds	r7, #12
 801b1bc:	46bd      	mov	sp, r7
 801b1be:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b1c2:	4770      	bx	lr

0801b1c4 <lv_disp_get_next>:
 * Get the next display.
 * @param disp pointer to the current display. NULL to initialize.
 * @return the next display or NULL if no more. Give the first display when the parameter is NULL
 */
lv_disp_t * lv_disp_get_next(lv_disp_t * disp)
{
 801b1c4:	b580      	push	{r7, lr}
 801b1c6:	b082      	sub	sp, #8
 801b1c8:	af00      	add	r7, sp, #0
 801b1ca:	6078      	str	r0, [r7, #4]
    if(disp == NULL)
 801b1cc:	687b      	ldr	r3, [r7, #4]
 801b1ce:	2b00      	cmp	r3, #0
 801b1d0:	d104      	bne.n	801b1dc <lv_disp_get_next+0x18>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_disp_ll));
 801b1d2:	4807      	ldr	r0, [pc, #28]	; (801b1f0 <lv_disp_get_next+0x2c>)
 801b1d4:	f001 fa12 	bl	801c5fc <lv_ll_get_head>
 801b1d8:	4603      	mov	r3, r0
 801b1da:	e004      	b.n	801b1e6 <lv_disp_get_next+0x22>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_disp_ll), disp);
 801b1dc:	6879      	ldr	r1, [r7, #4]
 801b1de:	4804      	ldr	r0, [pc, #16]	; (801b1f0 <lv_disp_get_next+0x2c>)
 801b1e0:	f001 fa32 	bl	801c648 <lv_ll_get_next>
 801b1e4:	4603      	mov	r3, r0
}
 801b1e6:	4618      	mov	r0, r3
 801b1e8:	3708      	adds	r7, #8
 801b1ea:	46bd      	mov	sp, r7
 801b1ec:	bd80      	pop	{r7, pc}
 801b1ee:	bf00      	nop
 801b1f0:	2000df60 	.word	0x2000df60

0801b1f4 <lv_disp_get_buf>:
 * Get the internal buffer of a display
 * @param disp pointer to a display
 * @return pointer to the internal buffers
 */
lv_disp_buf_t * lv_disp_get_buf(lv_disp_t * disp)
{
 801b1f4:	b480      	push	{r7}
 801b1f6:	b083      	sub	sp, #12
 801b1f8:	af00      	add	r7, sp, #0
 801b1fa:	6078      	str	r0, [r7, #4]
    return disp->driver.buffer;
 801b1fc:	687b      	ldr	r3, [r7, #4]
 801b1fe:	685b      	ldr	r3, [r3, #4]
}
 801b200:	4618      	mov	r0, r3
 801b202:	370c      	adds	r7, #12
 801b204:	46bd      	mov	sp, r7
 801b206:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b20a:	4770      	bx	lr

0801b20c <lv_disp_get_inv_buf_size>:
/**
 * Get the number of areas in the buffer
 * @return number of invalid areas
 */
uint16_t lv_disp_get_inv_buf_size(lv_disp_t * disp)
{
 801b20c:	b480      	push	{r7}
 801b20e:	b083      	sub	sp, #12
 801b210:	af00      	add	r7, sp, #0
 801b212:	6078      	str	r0, [r7, #4]
    return disp->inv_p;
 801b214:	687b      	ldr	r3, [r7, #4]
 801b216:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 801b21a:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801b21e:	b29b      	uxth	r3, r3
}
 801b220:	4618      	mov	r0, r3
 801b222:	370c      	adds	r7, #12
 801b224:	46bd      	mov	sp, r7
 801b226:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b22a:	4770      	bx	lr

0801b22c <lv_disp_pop_from_inv_buf>:
/**
 * Pop (delete) the last 'num' invalidated areas from the buffer
 * @param num number of areas to delete
 */
void lv_disp_pop_from_inv_buf(lv_disp_t * disp, uint16_t num)
{
 801b22c:	b480      	push	{r7}
 801b22e:	b083      	sub	sp, #12
 801b230:	af00      	add	r7, sp, #0
 801b232:	6078      	str	r0, [r7, #4]
 801b234:	460b      	mov	r3, r1
 801b236:	807b      	strh	r3, [r7, #2]

    if(disp->inv_p < num)
 801b238:	687b      	ldr	r3, [r7, #4]
 801b23a:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 801b23e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801b242:	b29b      	uxth	r3, r3
 801b244:	461a      	mov	r2, r3
 801b246:	887b      	ldrh	r3, [r7, #2]
 801b248:	429a      	cmp	r2, r3
 801b24a:	da07      	bge.n	801b25c <lv_disp_pop_from_inv_buf+0x30>
        disp->inv_p = 0;
 801b24c:	687a      	ldr	r2, [r7, #4]
 801b24e:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 801b252:	f36f 0309 	bfc	r3, #0, #10
 801b256:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168
    else
        disp->inv_p -= num;
}
 801b25a:	e013      	b.n	801b284 <lv_disp_pop_from_inv_buf+0x58>
        disp->inv_p -= num;
 801b25c:	687b      	ldr	r3, [r7, #4]
 801b25e:	f8b3 3168 	ldrh.w	r3, [r3, #360]	; 0x168
 801b262:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801b266:	b29b      	uxth	r3, r3
 801b268:	461a      	mov	r2, r3
 801b26a:	887b      	ldrh	r3, [r7, #2]
 801b26c:	1ad3      	subs	r3, r2, r3
 801b26e:	b29b      	uxth	r3, r3
 801b270:	f3c3 0309 	ubfx	r3, r3, #0, #10
 801b274:	b299      	uxth	r1, r3
 801b276:	687a      	ldr	r2, [r7, #4]
 801b278:	f8b2 3168 	ldrh.w	r3, [r2, #360]	; 0x168
 801b27c:	f361 0309 	bfi	r3, r1, #0, #10
 801b280:	f8a2 3168 	strh.w	r3, [r2, #360]	; 0x168
}
 801b284:	bf00      	nop
 801b286:	370c      	adds	r7, #12
 801b288:	46bd      	mov	sp, r7
 801b28a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b28e:	4770      	bx	lr

0801b290 <lv_disp_is_double_buf>:
 * Check the driver configuration if it's double buffered (both `buf1` and `buf2` are set)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_double_buf(lv_disp_t * disp)
{
 801b290:	b480      	push	{r7}
 801b292:	b083      	sub	sp, #12
 801b294:	af00      	add	r7, sp, #0
 801b296:	6078      	str	r0, [r7, #4]
    if(disp->driver.buffer->buf1 && disp->driver.buffer->buf2)
 801b298:	687b      	ldr	r3, [r7, #4]
 801b29a:	685b      	ldr	r3, [r3, #4]
 801b29c:	681b      	ldr	r3, [r3, #0]
 801b29e:	2b00      	cmp	r3, #0
 801b2a0:	d006      	beq.n	801b2b0 <lv_disp_is_double_buf+0x20>
 801b2a2:	687b      	ldr	r3, [r7, #4]
 801b2a4:	685b      	ldr	r3, [r3, #4]
 801b2a6:	685b      	ldr	r3, [r3, #4]
 801b2a8:	2b00      	cmp	r3, #0
 801b2aa:	d001      	beq.n	801b2b0 <lv_disp_is_double_buf+0x20>
        return true;
 801b2ac:	2301      	movs	r3, #1
 801b2ae:	e000      	b.n	801b2b2 <lv_disp_is_double_buf+0x22>
    else
        return false;
 801b2b0:	2300      	movs	r3, #0
}
 801b2b2:	4618      	mov	r0, r3
 801b2b4:	370c      	adds	r7, #12
 801b2b6:	46bd      	mov	sp, r7
 801b2b8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b2bc:	4770      	bx	lr

0801b2be <lv_disp_is_true_double_buf>:
 * `size` is screen sized)
 * @param disp pointer to to display to check
 * @return true: double buffered; false: not double buffered
 */
bool lv_disp_is_true_double_buf(lv_disp_t * disp)
{
 801b2be:	b580      	push	{r7, lr}
 801b2c0:	b084      	sub	sp, #16
 801b2c2:	af00      	add	r7, sp, #0
 801b2c4:	6078      	str	r0, [r7, #4]
    uint32_t scr_size = disp->driver.hor_res * disp->driver.ver_res;
 801b2c6:	687b      	ldr	r3, [r7, #4]
 801b2c8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b2cc:	461a      	mov	r2, r3
 801b2ce:	687b      	ldr	r3, [r7, #4]
 801b2d0:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b2d4:	fb03 f302 	mul.w	r3, r3, r2
 801b2d8:	60fb      	str	r3, [r7, #12]

    if(lv_disp_is_double_buf(disp) && disp->driver.buffer->size == scr_size) {
 801b2da:	6878      	ldr	r0, [r7, #4]
 801b2dc:	f7ff ffd8 	bl	801b290 <lv_disp_is_double_buf>
 801b2e0:	4603      	mov	r3, r0
 801b2e2:	2b00      	cmp	r3, #0
 801b2e4:	d007      	beq.n	801b2f6 <lv_disp_is_true_double_buf+0x38>
 801b2e6:	687b      	ldr	r3, [r7, #4]
 801b2e8:	685b      	ldr	r3, [r3, #4]
 801b2ea:	68db      	ldr	r3, [r3, #12]
 801b2ec:	68fa      	ldr	r2, [r7, #12]
 801b2ee:	429a      	cmp	r2, r3
 801b2f0:	d101      	bne.n	801b2f6 <lv_disp_is_true_double_buf+0x38>
        return true;
 801b2f2:	2301      	movs	r3, #1
 801b2f4:	e000      	b.n	801b2f8 <lv_disp_is_true_double_buf+0x3a>
    } else {
        return false;
 801b2f6:	2300      	movs	r3, #0
    }
}
 801b2f8:	4618      	mov	r0, r3
 801b2fa:	3710      	adds	r7, #16
 801b2fc:	46bd      	mov	sp, r7
 801b2fe:	bd80      	pop	{r7, pc}

0801b300 <lv_indev_drv_init>:
 * It is used to surly have known values in the fields ant not memory junk.
 * After it you can set the fields.
 * @param driver pointer to driver variable to initialize
 */
void lv_indev_drv_init(lv_indev_drv_t * driver)
{
 801b300:	b580      	push	{r7, lr}
 801b302:	b082      	sub	sp, #8
 801b304:	af00      	add	r7, sp, #0
 801b306:	6078      	str	r0, [r7, #4]
    memset(driver, 0, sizeof(lv_indev_drv_t));
 801b308:	2220      	movs	r2, #32
 801b30a:	2100      	movs	r1, #0
 801b30c:	6878      	ldr	r0, [r7, #4]
 801b30e:	f00b ff60 	bl	80271d2 <memset>

    driver->type                = LV_INDEV_TYPE_NONE;
 801b312:	687b      	ldr	r3, [r7, #4]
 801b314:	2200      	movs	r2, #0
 801b316:	701a      	strb	r2, [r3, #0]
    driver->drag_limit          = LV_INDEV_DEF_DRAG_LIMIT;
 801b318:	687b      	ldr	r3, [r7, #4]
 801b31a:	220a      	movs	r2, #10
 801b31c:	761a      	strb	r2, [r3, #24]
    driver->drag_throw          = LV_INDEV_DEF_DRAG_THROW;
 801b31e:	687b      	ldr	r3, [r7, #4]
 801b320:	2214      	movs	r2, #20
 801b322:	765a      	strb	r2, [r3, #25]
    driver->long_press_time     = LV_INDEV_DEF_LONG_PRESS_TIME;
 801b324:	687b      	ldr	r3, [r7, #4]
 801b326:	f44f 72c8 	mov.w	r2, #400	; 0x190
 801b32a:	835a      	strh	r2, [r3, #26]
    driver->long_press_rep_time = LV_INDEV_DEF_LONG_PRESS_REP_TIME;
 801b32c:	687b      	ldr	r3, [r7, #4]
 801b32e:	2264      	movs	r2, #100	; 0x64
 801b330:	839a      	strh	r2, [r3, #28]
}
 801b332:	bf00      	nop
 801b334:	3708      	adds	r7, #8
 801b336:	46bd      	mov	sp, r7
 801b338:	bd80      	pop	{r7, pc}
	...

0801b33c <lv_indev_drv_register>:
 * Register an initialized input device driver.
 * @param driver pointer to an initialized 'lv_indev_drv_t' variable (can be local variable)
 * @return pointer to the new input device or NULL on error
 */
lv_indev_t * lv_indev_drv_register(lv_indev_drv_t * driver)
{
 801b33c:	b580      	push	{r7, lr}
 801b33e:	b084      	sub	sp, #16
 801b340:	af00      	add	r7, sp, #0
 801b342:	6078      	str	r0, [r7, #4]

    if(driver->disp == NULL) driver->disp = lv_disp_get_default();
 801b344:	687b      	ldr	r3, [r7, #4]
 801b346:	691b      	ldr	r3, [r3, #16]
 801b348:	2b00      	cmp	r3, #0
 801b34a:	d104      	bne.n	801b356 <lv_indev_drv_register+0x1a>
 801b34c:	f7ff febe 	bl	801b0cc <lv_disp_get_default>
 801b350:	4602      	mov	r2, r0
 801b352:	687b      	ldr	r3, [r7, #4]
 801b354:	611a      	str	r2, [r3, #16]

    if(driver->disp == NULL) {
 801b356:	687b      	ldr	r3, [r7, #4]
 801b358:	691b      	ldr	r3, [r3, #16]
 801b35a:	2b00      	cmp	r3, #0
 801b35c:	d107      	bne.n	801b36e <lv_indev_drv_register+0x32>
        LV_LOG_WARN("lv_indev_drv_register: no display registered hence can't attache the indev to "
 801b35e:	4b22      	ldr	r3, [pc, #136]	; (801b3e8 <lv_indev_drv_register+0xac>)
 801b360:	224a      	movs	r2, #74	; 0x4a
 801b362:	4922      	ldr	r1, [pc, #136]	; (801b3ec <lv_indev_drv_register+0xb0>)
 801b364:	2002      	movs	r0, #2
 801b366:	f001 fa51 	bl	801c80c <lv_log_add>
                    "a display");
        return NULL;
 801b36a:	2300      	movs	r3, #0
 801b36c:	e037      	b.n	801b3de <lv_indev_drv_register+0xa2>
    }

    lv_indev_t * indev = lv_ll_ins_head(&LV_GC_ROOT(_lv_indev_ll));
 801b36e:	4820      	ldr	r0, [pc, #128]	; (801b3f0 <lv_indev_drv_register+0xb4>)
 801b370:	f000 ffe2 	bl	801c338 <lv_ll_ins_head>
 801b374:	60f8      	str	r0, [r7, #12]
    if(!indev) {
 801b376:	68fb      	ldr	r3, [r7, #12]
 801b378:	2b00      	cmp	r3, #0
 801b37a:	d10b      	bne.n	801b394 <lv_indev_drv_register+0x58>
        lv_mem_assert(indev);
 801b37c:	68fb      	ldr	r3, [r7, #12]
 801b37e:	2b00      	cmp	r3, #0
 801b380:	d106      	bne.n	801b390 <lv_indev_drv_register+0x54>
 801b382:	4b1c      	ldr	r3, [pc, #112]	; (801b3f4 <lv_indev_drv_register+0xb8>)
 801b384:	2250      	movs	r2, #80	; 0x50
 801b386:	4919      	ldr	r1, [pc, #100]	; (801b3ec <lv_indev_drv_register+0xb0>)
 801b388:	2003      	movs	r0, #3
 801b38a:	f001 fa3f 	bl	801c80c <lv_log_add>
 801b38e:	e7fe      	b.n	801b38e <lv_indev_drv_register+0x52>
        return NULL;
 801b390:	2300      	movs	r3, #0
 801b392:	e024      	b.n	801b3de <lv_indev_drv_register+0xa2>
    }

    memset(indev, 0, sizeof(lv_indev_t));
 801b394:	2260      	movs	r2, #96	; 0x60
 801b396:	2100      	movs	r1, #0
 801b398:	68f8      	ldr	r0, [r7, #12]
 801b39a:	f00b ff1a 	bl	80271d2 <memset>
    memcpy(&indev->driver, driver, sizeof(lv_indev_drv_t));
 801b39e:	68fb      	ldr	r3, [r7, #12]
 801b3a0:	2220      	movs	r2, #32
 801b3a2:	6879      	ldr	r1, [r7, #4]
 801b3a4:	4618      	mov	r0, r3
 801b3a6:	f00b ff09 	bl	80271bc <memcpy>

    indev->proc.reset_query = 1;
 801b3aa:	68fa      	ldr	r2, [r7, #12]
 801b3ac:	f892 3050 	ldrb.w	r3, [r2, #80]	; 0x50
 801b3b0:	f043 0302 	orr.w	r3, r3, #2
 801b3b4:	f882 3050 	strb.w	r3, [r2, #80]	; 0x50
    indev->cursor           = NULL;
 801b3b8:	68fb      	ldr	r3, [r7, #12]
 801b3ba:	2200      	movs	r2, #0
 801b3bc:	655a      	str	r2, [r3, #84]	; 0x54
    indev->group            = NULL;
 801b3be:	68fb      	ldr	r3, [r7, #12]
 801b3c0:	2200      	movs	r2, #0
 801b3c2:	659a      	str	r2, [r3, #88]	; 0x58
    indev->btn_points       = NULL;
 801b3c4:	68fb      	ldr	r3, [r7, #12]
 801b3c6:	2200      	movs	r2, #0
 801b3c8:	65da      	str	r2, [r3, #92]	; 0x5c

    indev->driver.read_task = lv_task_create(lv_indev_read_task, LV_INDEV_DEF_READ_PERIOD, LV_TASK_PRIO_MID, indev);
 801b3ca:	68fb      	ldr	r3, [r7, #12]
 801b3cc:	2203      	movs	r2, #3
 801b3ce:	211e      	movs	r1, #30
 801b3d0:	4809      	ldr	r0, [pc, #36]	; (801b3f8 <lv_indev_drv_register+0xbc>)
 801b3d2:	f001 fd91 	bl	801cef8 <lv_task_create>
 801b3d6:	4602      	mov	r2, r0
 801b3d8:	68fb      	ldr	r3, [r7, #12]
 801b3da:	615a      	str	r2, [r3, #20]

    return indev;
 801b3dc:	68fb      	ldr	r3, [r7, #12]
}
 801b3de:	4618      	mov	r0, r3
 801b3e0:	3710      	adds	r7, #16
 801b3e2:	46bd      	mov	sp, r7
 801b3e4:	bd80      	pop	{r7, pc}
 801b3e6:	bf00      	nop
 801b3e8:	08028d9c 	.word	0x08028d9c
 801b3ec:	08028df4 	.word	0x08028df4
 801b3f0:	2000df50 	.word	0x2000df50
 801b3f4:	08028e18 	.word	0x08028e18
 801b3f8:	0800ea11 	.word	0x0800ea11

0801b3fc <lv_indev_get_next>:
 * @param indev pointer to the current input device. NULL to initialize.
 * @return the next input devise or NULL if no more. Give the first input device when the parameter
 * is NULL
 */
lv_indev_t * lv_indev_get_next(lv_indev_t * indev)
{
 801b3fc:	b580      	push	{r7, lr}
 801b3fe:	b082      	sub	sp, #8
 801b400:	af00      	add	r7, sp, #0
 801b402:	6078      	str	r0, [r7, #4]
    if(indev == NULL)
 801b404:	687b      	ldr	r3, [r7, #4]
 801b406:	2b00      	cmp	r3, #0
 801b408:	d104      	bne.n	801b414 <lv_indev_get_next+0x18>
        return lv_ll_get_head(&LV_GC_ROOT(_lv_indev_ll));
 801b40a:	4807      	ldr	r0, [pc, #28]	; (801b428 <lv_indev_get_next+0x2c>)
 801b40c:	f001 f8f6 	bl	801c5fc <lv_ll_get_head>
 801b410:	4603      	mov	r3, r0
 801b412:	e004      	b.n	801b41e <lv_indev_get_next+0x22>
    else
        return lv_ll_get_next(&LV_GC_ROOT(_lv_indev_ll), indev);
 801b414:	6879      	ldr	r1, [r7, #4]
 801b416:	4804      	ldr	r0, [pc, #16]	; (801b428 <lv_indev_get_next+0x2c>)
 801b418:	f001 f916 	bl	801c648 <lv_ll_get_next>
 801b41c:	4603      	mov	r3, r0
}
 801b41e:	4618      	mov	r0, r3
 801b420:	3708      	adds	r7, #8
 801b422:	46bd      	mov	sp, r7
 801b424:	bd80      	pop	{r7, pc}
 801b426:	bf00      	nop
 801b428:	2000df50 	.word	0x2000df50

0801b42c <lv_indev_read>:
 * @param indev pointer to an input device
 * @param data input device will write its data here
 * @return false: no more data; true: there more data to read (buffered)
 */
bool lv_indev_read(lv_indev_t * indev, lv_indev_data_t * data)
{
 801b42c:	b580      	push	{r7, lr}
 801b42e:	b084      	sub	sp, #16
 801b430:	af00      	add	r7, sp, #0
 801b432:	6078      	str	r0, [r7, #4]
 801b434:	6039      	str	r1, [r7, #0]
    bool cont = false;
 801b436:	2300      	movs	r3, #0
 801b438:	73fb      	strb	r3, [r7, #15]

    memset(data, 0, sizeof(lv_indev_data_t));
 801b43a:	2210      	movs	r2, #16
 801b43c:	2100      	movs	r1, #0
 801b43e:	6838      	ldr	r0, [r7, #0]
 801b440:	f00b fec7 	bl	80271d2 <memset>

    /* For touchpad sometimes users don't the last pressed coordinate on release.
     * So be sure a coordinates are initialized to the last point */
    if(indev->driver.type == LV_INDEV_TYPE_POINTER) {
 801b444:	687b      	ldr	r3, [r7, #4]
 801b446:	781b      	ldrb	r3, [r3, #0]
 801b448:	2b01      	cmp	r3, #1
 801b44a:	d10a      	bne.n	801b462 <lv_indev_read+0x36>
        data->point.x = indev->proc.types.pointer.act_point.x;
 801b44c:	687b      	ldr	r3, [r7, #4]
 801b44e:	f9b3 2024 	ldrsh.w	r2, [r3, #36]	; 0x24
 801b452:	683b      	ldr	r3, [r7, #0]
 801b454:	801a      	strh	r2, [r3, #0]
        data->point.y = indev->proc.types.pointer.act_point.y;
 801b456:	687b      	ldr	r3, [r7, #4]
 801b458:	f9b3 2026 	ldrsh.w	r2, [r3, #38]	; 0x26
 801b45c:	683b      	ldr	r3, [r7, #0]
 801b45e:	805a      	strh	r2, [r3, #2]
 801b460:	e007      	b.n	801b472 <lv_indev_read+0x46>
    }
    /*Similarly set at least the last key in case of the  the user doesn't set it  on release*/
    else if(indev->driver.type == LV_INDEV_TYPE_KEYPAD) {
 801b462:	687b      	ldr	r3, [r7, #4]
 801b464:	781b      	ldrb	r3, [r3, #0]
 801b466:	2b02      	cmp	r3, #2
 801b468:	d103      	bne.n	801b472 <lv_indev_read+0x46>
        data->key = indev->proc.types.keypad.last_key;
 801b46a:	687b      	ldr	r3, [r7, #4]
 801b46c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 801b46e:	683b      	ldr	r3, [r7, #0]
 801b470:	605a      	str	r2, [r3, #4]
    }

    if(indev->driver.read_cb) {
 801b472:	687b      	ldr	r3, [r7, #4]
 801b474:	685b      	ldr	r3, [r3, #4]
 801b476:	2b00      	cmp	r3, #0
 801b478:	d008      	beq.n	801b48c <lv_indev_read+0x60>
        LV_LOG_TRACE("idnev read started");
        cont = indev->driver.read_cb(&indev->driver, data);
 801b47a:	687b      	ldr	r3, [r7, #4]
 801b47c:	685b      	ldr	r3, [r3, #4]
 801b47e:	687a      	ldr	r2, [r7, #4]
 801b480:	6839      	ldr	r1, [r7, #0]
 801b482:	4610      	mov	r0, r2
 801b484:	4798      	blx	r3
 801b486:	4603      	mov	r3, r0
 801b488:	73fb      	strb	r3, [r7, #15]
 801b48a:	e005      	b.n	801b498 <lv_indev_read+0x6c>
        LV_LOG_TRACE("idnev read finished");
    } else {
        LV_LOG_WARN("indev function registered");
 801b48c:	4b05      	ldr	r3, [pc, #20]	; (801b4a4 <lv_indev_read+0x78>)
 801b48e:	2295      	movs	r2, #149	; 0x95
 801b490:	4905      	ldr	r1, [pc, #20]	; (801b4a8 <lv_indev_read+0x7c>)
 801b492:	2002      	movs	r0, #2
 801b494:	f001 f9ba 	bl	801c80c <lv_log_add>
    }

    return cont;
 801b498:	7bfb      	ldrb	r3, [r7, #15]
}
 801b49a:	4618      	mov	r0, r3
 801b49c:	3710      	adds	r7, #16
 801b49e:	46bd      	mov	sp, r7
 801b4a0:	bd80      	pop	{r7, pc}
 801b4a2:	bf00      	nop
 801b4a4:	08028e28 	.word	0x08028e28
 801b4a8:	08028df4 	.word	0x08028df4

0801b4ac <lv_tick_get>:
/**
 * Get the elapsed milliseconds since start up
 * @return the elapsed milliseconds
 */
uint32_t lv_tick_get(void)
{
 801b4ac:	b480      	push	{r7}
 801b4ae:	b083      	sub	sp, #12
 801b4b0:	af00      	add	r7, sp, #0
#if LV_TICK_CUSTOM == 0
    uint32_t result;
    do {
        tick_irq_flag = 1;
 801b4b2:	4b09      	ldr	r3, [pc, #36]	; (801b4d8 <lv_tick_get+0x2c>)
 801b4b4:	2201      	movs	r2, #1
 801b4b6:	701a      	strb	r2, [r3, #0]
        result        = sys_time;
 801b4b8:	4b08      	ldr	r3, [pc, #32]	; (801b4dc <lv_tick_get+0x30>)
 801b4ba:	681b      	ldr	r3, [r3, #0]
 801b4bc:	607b      	str	r3, [r7, #4]
    } while(!tick_irq_flag); /*'lv_tick_inc()' clears this flag which can be in an interrupt.
 801b4be:	4b06      	ldr	r3, [pc, #24]	; (801b4d8 <lv_tick_get+0x2c>)
 801b4c0:	781b      	ldrb	r3, [r3, #0]
 801b4c2:	b2db      	uxtb	r3, r3
 801b4c4:	2b00      	cmp	r3, #0
 801b4c6:	d0f4      	beq.n	801b4b2 <lv_tick_get+0x6>
                                Continue until make a non interrupted cycle */

    return result;
 801b4c8:	687b      	ldr	r3, [r7, #4]
#else
    return LV_TICK_CUSTOM_SYS_TIME_EXPR;
#endif
}
 801b4ca:	4618      	mov	r0, r3
 801b4cc:	370c      	adds	r7, #12
 801b4ce:	46bd      	mov	sp, r7
 801b4d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b4d4:	4770      	bx	lr
 801b4d6:	bf00      	nop
 801b4d8:	20004380 	.word	0x20004380
 801b4dc:	2000437c 	.word	0x2000437c

0801b4e0 <lv_tick_elaps>:
 * Get the elapsed milliseconds since a previous time stamp
 * @param prev_tick a previous time stamp (return value of systick_get() )
 * @return the elapsed milliseconds since 'prev_tick'
 */
uint32_t lv_tick_elaps(uint32_t prev_tick)
{
 801b4e0:	b580      	push	{r7, lr}
 801b4e2:	b084      	sub	sp, #16
 801b4e4:	af00      	add	r7, sp, #0
 801b4e6:	6078      	str	r0, [r7, #4]
    uint32_t act_time = lv_tick_get();
 801b4e8:	f7ff ffe0 	bl	801b4ac <lv_tick_get>
 801b4ec:	60f8      	str	r0, [r7, #12]

    /*If there is no overflow in sys_time simple subtract*/
    if(act_time >= prev_tick) {
 801b4ee:	68fa      	ldr	r2, [r7, #12]
 801b4f0:	687b      	ldr	r3, [r7, #4]
 801b4f2:	429a      	cmp	r2, r3
 801b4f4:	d304      	bcc.n	801b500 <lv_tick_elaps+0x20>
        prev_tick = act_time - prev_tick;
 801b4f6:	68fa      	ldr	r2, [r7, #12]
 801b4f8:	687b      	ldr	r3, [r7, #4]
 801b4fa:	1ad3      	subs	r3, r2, r3
 801b4fc:	607b      	str	r3, [r7, #4]
 801b4fe:	e006      	b.n	801b50e <lv_tick_elaps+0x2e>
    } else {
        prev_tick = UINT32_MAX - prev_tick + 1;
 801b500:	687b      	ldr	r3, [r7, #4]
 801b502:	425b      	negs	r3, r3
 801b504:	607b      	str	r3, [r7, #4]
        prev_tick += act_time;
 801b506:	687a      	ldr	r2, [r7, #4]
 801b508:	68fb      	ldr	r3, [r7, #12]
 801b50a:	4413      	add	r3, r2
 801b50c:	607b      	str	r3, [r7, #4]
    }

    return prev_tick;
 801b50e:	687b      	ldr	r3, [r7, #4]
}
 801b510:	4618      	mov	r0, r3
 801b512:	3710      	adds	r7, #16
 801b514:	46bd      	mov	sp, r7
 801b516:	bd80      	pop	{r7, pc}

0801b518 <lv_anim_core_init>:

/**
 * Init. the animation module
 */
void lv_anim_core_init(void)
{
 801b518:	b580      	push	{r7, lr}
 801b51a:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_anim_ll), sizeof(lv_anim_t));
 801b51c:	2128      	movs	r1, #40	; 0x28
 801b51e:	4808      	ldr	r0, [pc, #32]	; (801b540 <lv_anim_core_init+0x28>)
 801b520:	f000 feea 	bl	801c2f8 <lv_ll_init>
    last_task_run = lv_tick_get();
 801b524:	f7ff ffc2 	bl	801b4ac <lv_tick_get>
 801b528:	4602      	mov	r2, r0
 801b52a:	4b06      	ldr	r3, [pc, #24]	; (801b544 <lv_anim_core_init+0x2c>)
 801b52c:	601a      	str	r2, [r3, #0]
    lv_task_create(anim_task, LV_DISP_DEF_REFR_PERIOD, LV_TASK_PRIO_MID, NULL);
 801b52e:	2300      	movs	r3, #0
 801b530:	2203      	movs	r2, #3
 801b532:	211e      	movs	r1, #30
 801b534:	4804      	ldr	r0, [pc, #16]	; (801b548 <lv_anim_core_init+0x30>)
 801b536:	f001 fcdf 	bl	801cef8 <lv_task_create>
}
 801b53a:	bf00      	nop
 801b53c:	bd80      	pop	{r7, pc}
 801b53e:	bf00      	nop
 801b540:	2000df8c 	.word	0x2000df8c
 801b544:	20004384 	.word	0x20004384
 801b548:	0801b715 	.word	0x0801b715

0801b54c <lv_anim_create>:
/**
 * Create an animation
 * @param a an initialized 'anim_t' variable. Not required after call.
 */
void lv_anim_create(lv_anim_t * a)
{
 801b54c:	b580      	push	{r7, lr}
 801b54e:	b084      	sub	sp, #16
 801b550:	af00      	add	r7, sp, #0
 801b552:	6078      	str	r0, [r7, #4]
    LV_LOG_TRACE("animation create started")
    /* Do not let two animations for the  same 'var' with the same 'fp'*/
    if(a->exec_cb != NULL) lv_anim_del(a->var, a->exec_cb); /*fp == NULL would delete all animations of var*/
 801b554:	687b      	ldr	r3, [r7, #4]
 801b556:	685b      	ldr	r3, [r3, #4]
 801b558:	2b00      	cmp	r3, #0
 801b55a:	d007      	beq.n	801b56c <lv_anim_create+0x20>
 801b55c:	687b      	ldr	r3, [r7, #4]
 801b55e:	681a      	ldr	r2, [r3, #0]
 801b560:	687b      	ldr	r3, [r7, #4]
 801b562:	685b      	ldr	r3, [r3, #4]
 801b564:	4619      	mov	r1, r3
 801b566:	4610      	mov	r0, r2
 801b568:	f000 f83a 	bl	801b5e0 <lv_anim_del>

    /*Add the new animation to the animation linked list*/
    lv_anim_t * new_anim = lv_ll_ins_head(&LV_GC_ROOT(_lv_anim_ll));
 801b56c:	4818      	ldr	r0, [pc, #96]	; (801b5d0 <lv_anim_create+0x84>)
 801b56e:	f000 fee3 	bl	801c338 <lv_ll_ins_head>
 801b572:	60f8      	str	r0, [r7, #12]
    lv_mem_assert(new_anim);
 801b574:	68fb      	ldr	r3, [r7, #12]
 801b576:	2b00      	cmp	r3, #0
 801b578:	d106      	bne.n	801b588 <lv_anim_create+0x3c>
 801b57a:	4b16      	ldr	r3, [pc, #88]	; (801b5d4 <lv_anim_create+0x88>)
 801b57c:	225c      	movs	r2, #92	; 0x5c
 801b57e:	4916      	ldr	r1, [pc, #88]	; (801b5d8 <lv_anim_create+0x8c>)
 801b580:	2003      	movs	r0, #3
 801b582:	f001 f943 	bl	801c80c <lv_log_add>
 801b586:	e7fe      	b.n	801b586 <lv_anim_create+0x3a>
    if(new_anim == NULL) return;
 801b588:	68fb      	ldr	r3, [r7, #12]
 801b58a:	2b00      	cmp	r3, #0
 801b58c:	d01c      	beq.n	801b5c8 <lv_anim_create+0x7c>

    /*Initialize the animation descriptor*/
    a->playback_now = 0;
 801b58e:	687a      	ldr	r2, [r7, #4]
 801b590:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801b594:	f36f 0382 	bfc	r3, #2, #1
 801b598:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    memcpy(new_anim, a, sizeof(lv_anim_t));
 801b59c:	2228      	movs	r2, #40	; 0x28
 801b59e:	6879      	ldr	r1, [r7, #4]
 801b5a0:	68f8      	ldr	r0, [r7, #12]
 801b5a2:	f00b fe0b 	bl	80271bc <memcpy>

    /*Set the start value*/
    if(new_anim->exec_cb) new_anim->exec_cb(new_anim->var, new_anim->start);
 801b5a6:	68fb      	ldr	r3, [r7, #12]
 801b5a8:	685b      	ldr	r3, [r3, #4]
 801b5aa:	2b00      	cmp	r3, #0
 801b5ac:	d008      	beq.n	801b5c0 <lv_anim_create+0x74>
 801b5ae:	68fb      	ldr	r3, [r7, #12]
 801b5b0:	685b      	ldr	r3, [r3, #4]
 801b5b2:	68fa      	ldr	r2, [r7, #12]
 801b5b4:	6810      	ldr	r0, [r2, #0]
 801b5b6:	68fa      	ldr	r2, [r7, #12]
 801b5b8:	6912      	ldr	r2, [r2, #16]
 801b5ba:	b212      	sxth	r2, r2
 801b5bc:	4611      	mov	r1, r2
 801b5be:	4798      	blx	r3

    /* Creating an animation changed the linked list.
     * It's important if it happens in a ready callback. (see `anim_task`)*/
    anim_list_changed = true;
 801b5c0:	4b06      	ldr	r3, [pc, #24]	; (801b5dc <lv_anim_create+0x90>)
 801b5c2:	2201      	movs	r2, #1
 801b5c4:	701a      	strb	r2, [r3, #0]
 801b5c6:	e000      	b.n	801b5ca <lv_anim_create+0x7e>
    if(new_anim == NULL) return;
 801b5c8:	bf00      	nop

    LV_LOG_TRACE("animation created")
}
 801b5ca:	3710      	adds	r7, #16
 801b5cc:	46bd      	mov	sp, r7
 801b5ce:	bd80      	pop	{r7, pc}
 801b5d0:	2000df8c 	.word	0x2000df8c
 801b5d4:	08028e44 	.word	0x08028e44
 801b5d8:	08028e54 	.word	0x08028e54
 801b5dc:	20004388 	.word	0x20004388

0801b5e0 <lv_anim_del>:
 * @param exec_cb a function pointer which is animating 'var',
 *           or NULL to delete all the animations of 'var'
 * @return true: at least 1 animation is deleted, false: no animation is deleted
 */
bool lv_anim_del(void * var, lv_anim_exec_xcb_t exec_cb)
{
 801b5e0:	b580      	push	{r7, lr}
 801b5e2:	b086      	sub	sp, #24
 801b5e4:	af00      	add	r7, sp, #0
 801b5e6:	6078      	str	r0, [r7, #4]
 801b5e8:	6039      	str	r1, [r7, #0]
    lv_anim_t * a;
    lv_anim_t * a_next;
    bool del = false;
 801b5ea:	2300      	movs	r3, #0
 801b5ec:	74fb      	strb	r3, [r7, #19]
    a        = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801b5ee:	4816      	ldr	r0, [pc, #88]	; (801b648 <lv_anim_del+0x68>)
 801b5f0:	f001 f804 	bl	801c5fc <lv_ll_get_head>
 801b5f4:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 801b5f6:	e01f      	b.n	801b638 <lv_anim_del+0x58>
        /*'a' might be deleted, so get the next object while 'a' is valid*/
        a_next = lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 801b5f8:	6979      	ldr	r1, [r7, #20]
 801b5fa:	4813      	ldr	r0, [pc, #76]	; (801b648 <lv_anim_del+0x68>)
 801b5fc:	f001 f824 	bl	801c648 <lv_ll_get_next>
 801b600:	60f8      	str	r0, [r7, #12]

        if(a->var == var && (a->exec_cb == exec_cb || exec_cb == NULL)) {
 801b602:	697b      	ldr	r3, [r7, #20]
 801b604:	681b      	ldr	r3, [r3, #0]
 801b606:	687a      	ldr	r2, [r7, #4]
 801b608:	429a      	cmp	r2, r3
 801b60a:	d113      	bne.n	801b634 <lv_anim_del+0x54>
 801b60c:	697b      	ldr	r3, [r7, #20]
 801b60e:	685b      	ldr	r3, [r3, #4]
 801b610:	683a      	ldr	r2, [r7, #0]
 801b612:	429a      	cmp	r2, r3
 801b614:	d002      	beq.n	801b61c <lv_anim_del+0x3c>
 801b616:	683b      	ldr	r3, [r7, #0]
 801b618:	2b00      	cmp	r3, #0
 801b61a:	d10b      	bne.n	801b634 <lv_anim_del+0x54>
            lv_ll_rem(&LV_GC_ROOT(_lv_anim_ll), a);
 801b61c:	6979      	ldr	r1, [r7, #20]
 801b61e:	480a      	ldr	r0, [pc, #40]	; (801b648 <lv_anim_del+0x68>)
 801b620:	f000 ff3e 	bl	801c4a0 <lv_ll_rem>
            lv_mem_free(a);
 801b624:	6978      	ldr	r0, [r7, #20]
 801b626:	f001 f97d 	bl	801c924 <lv_mem_free>
            anim_list_changed = true; /*Read by `anim_task`. It need to know if a delete occurred in
 801b62a:	4b08      	ldr	r3, [pc, #32]	; (801b64c <lv_anim_del+0x6c>)
 801b62c:	2201      	movs	r2, #1
 801b62e:	701a      	strb	r2, [r3, #0]
                                         the linked list*/
            del = true;
 801b630:	2301      	movs	r3, #1
 801b632:	74fb      	strb	r3, [r7, #19]
        }

        a = a_next;
 801b634:	68fb      	ldr	r3, [r7, #12]
 801b636:	617b      	str	r3, [r7, #20]
    while(a != NULL) {
 801b638:	697b      	ldr	r3, [r7, #20]
 801b63a:	2b00      	cmp	r3, #0
 801b63c:	d1dc      	bne.n	801b5f8 <lv_anim_del+0x18>
    }

    return del;
 801b63e:	7cfb      	ldrb	r3, [r7, #19]
}
 801b640:	4618      	mov	r0, r3
 801b642:	3718      	adds	r7, #24
 801b644:	46bd      	mov	sp, r7
 801b646:	bd80      	pop	{r7, pc}
 801b648:	2000df8c 	.word	0x2000df8c
 801b64c:	20004388 	.word	0x20004388

0801b650 <lv_anim_speed_to_time>:
 * @param start start value of the animation
 * @param end end value of the animation
 * @return the required time [ms] for the animation with the given parameters
 */
uint16_t lv_anim_speed_to_time(uint16_t speed, lv_anim_value_t start, lv_anim_value_t end)
{
 801b650:	b480      	push	{r7}
 801b652:	b085      	sub	sp, #20
 801b654:	af00      	add	r7, sp, #0
 801b656:	4603      	mov	r3, r0
 801b658:	80fb      	strh	r3, [r7, #6]
 801b65a:	460b      	mov	r3, r1
 801b65c:	80bb      	strh	r3, [r7, #4]
 801b65e:	4613      	mov	r3, r2
 801b660:	807b      	strh	r3, [r7, #2]
    int32_t d     = LV_MATH_ABS((int32_t)start - end);
 801b662:	f9b7 2004 	ldrsh.w	r2, [r7, #4]
 801b666:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 801b66a:	1ad3      	subs	r3, r2, r3
 801b66c:	2b00      	cmp	r3, #0
 801b66e:	bfb8      	it	lt
 801b670:	425b      	neglt	r3, r3
 801b672:	60bb      	str	r3, [r7, #8]
    uint32_t time = (int32_t)((int32_t)(d * 1000) / speed);
 801b674:	68bb      	ldr	r3, [r7, #8]
 801b676:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801b67a:	fb02 f203 	mul.w	r2, r2, r3
 801b67e:	88fb      	ldrh	r3, [r7, #6]
 801b680:	fb92 f3f3 	sdiv	r3, r2, r3
 801b684:	60fb      	str	r3, [r7, #12]

    if(time > UINT16_MAX) time = UINT16_MAX;
 801b686:	68fb      	ldr	r3, [r7, #12]
 801b688:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 801b68c:	d302      	bcc.n	801b694 <lv_anim_speed_to_time+0x44>
 801b68e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 801b692:	60fb      	str	r3, [r7, #12]

    if(time == 0) {
 801b694:	68fb      	ldr	r3, [r7, #12]
 801b696:	2b00      	cmp	r3, #0
 801b698:	d102      	bne.n	801b6a0 <lv_anim_speed_to_time+0x50>
        time++;
 801b69a:	68fb      	ldr	r3, [r7, #12]
 801b69c:	3301      	adds	r3, #1
 801b69e:	60fb      	str	r3, [r7, #12]
    }

    return time;
 801b6a0:	68fb      	ldr	r3, [r7, #12]
 801b6a2:	b29b      	uxth	r3, r3
}
 801b6a4:	4618      	mov	r0, r3
 801b6a6:	3714      	adds	r7, #20
 801b6a8:	46bd      	mov	sp, r7
 801b6aa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b6ae:	4770      	bx	lr

0801b6b0 <lv_anim_path_linear>:
 * Calculate the current value of an animation applying linear characteristic
 * @param a pointer to an animation
 * @return the current value to set
 */
lv_anim_value_t lv_anim_path_linear(const lv_anim_t * a)
{
 801b6b0:	b480      	push	{r7}
 801b6b2:	b085      	sub	sp, #20
 801b6b4:	af00      	add	r7, sp, #0
 801b6b6:	6078      	str	r0, [r7, #4]
    /*Calculate the current step*/
    uint32_t step;
    if(a->time == a->act_time) {
 801b6b8:	687b      	ldr	r3, [r7, #4]
 801b6ba:	8b1b      	ldrh	r3, [r3, #24]
 801b6bc:	461a      	mov	r2, r3
 801b6be:	687b      	ldr	r3, [r7, #4]
 801b6c0:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801b6c4:	429a      	cmp	r2, r3
 801b6c6:	d103      	bne.n	801b6d0 <lv_anim_path_linear+0x20>
        step = LV_ANIM_RESOLUTION; /*Use the last value if the time fully elapsed*/
 801b6c8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801b6cc:	60fb      	str	r3, [r7, #12]
 801b6ce:	e008      	b.n	801b6e2 <lv_anim_path_linear+0x32>
    } else {
        step = ((int32_t)a->act_time * LV_ANIM_RESOLUTION) / a->time;
 801b6d0:	687b      	ldr	r3, [r7, #4]
 801b6d2:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801b6d6:	029b      	lsls	r3, r3, #10
 801b6d8:	687a      	ldr	r2, [r7, #4]
 801b6da:	8b12      	ldrh	r2, [r2, #24]
 801b6dc:	fb93 f3f2 	sdiv	r3, r3, r2
 801b6e0:	60fb      	str	r3, [r7, #12]
    }

    /* Get the new value which will be proportional to `step`
     * and the `start` and `end` values*/
    int32_t new_value;
    new_value = (int32_t)step * (a->end - a->start);
 801b6e2:	687b      	ldr	r3, [r7, #4]
 801b6e4:	695a      	ldr	r2, [r3, #20]
 801b6e6:	687b      	ldr	r3, [r7, #4]
 801b6e8:	691b      	ldr	r3, [r3, #16]
 801b6ea:	1ad3      	subs	r3, r2, r3
 801b6ec:	68fa      	ldr	r2, [r7, #12]
 801b6ee:	fb02 f303 	mul.w	r3, r2, r3
 801b6f2:	60bb      	str	r3, [r7, #8]
    new_value = new_value >> LV_ANIM_RES_SHIFT;
 801b6f4:	68bb      	ldr	r3, [r7, #8]
 801b6f6:	129b      	asrs	r3, r3, #10
 801b6f8:	60bb      	str	r3, [r7, #8]
    new_value += a->start;
 801b6fa:	687b      	ldr	r3, [r7, #4]
 801b6fc:	691b      	ldr	r3, [r3, #16]
 801b6fe:	68ba      	ldr	r2, [r7, #8]
 801b700:	4413      	add	r3, r2
 801b702:	60bb      	str	r3, [r7, #8]

    return (lv_anim_value_t)new_value;
 801b704:	68bb      	ldr	r3, [r7, #8]
 801b706:	b21b      	sxth	r3, r3
}
 801b708:	4618      	mov	r0, r3
 801b70a:	3714      	adds	r7, #20
 801b70c:	46bd      	mov	sp, r7
 801b70e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b712:	4770      	bx	lr

0801b714 <anim_task>:
/**
 * Periodically handle the animations.
 * @param param unused
 */
static void anim_task(lv_task_t * param)
{
 801b714:	b580      	push	{r7, lr}
 801b716:	b086      	sub	sp, #24
 801b718:	af00      	add	r7, sp, #0
 801b71a:	6078      	str	r0, [r7, #4]
    (void)param;

    lv_anim_t * a;
    LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a)
 801b71c:	4842      	ldr	r0, [pc, #264]	; (801b828 <anim_task+0x114>)
 801b71e:	f000 ff6d 	bl	801c5fc <lv_ll_get_head>
 801b722:	6178      	str	r0, [r7, #20]
 801b724:	e00b      	b.n	801b73e <anim_task+0x2a>
    {
        a->has_run = 0;
 801b726:	697a      	ldr	r2, [r7, #20]
 801b728:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801b72c:	f36f 03c3 	bfc	r3, #3, #1
 801b730:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
    LV_LL_READ(LV_GC_ROOT(_lv_anim_ll), a)
 801b734:	6979      	ldr	r1, [r7, #20]
 801b736:	483c      	ldr	r0, [pc, #240]	; (801b828 <anim_task+0x114>)
 801b738:	f000 ff86 	bl	801c648 <lv_ll_get_next>
 801b73c:	6178      	str	r0, [r7, #20]
 801b73e:	697b      	ldr	r3, [r7, #20]
 801b740:	2b00      	cmp	r3, #0
 801b742:	d1f0      	bne.n	801b726 <anim_task+0x12>
    }

    uint32_t elaps = lv_tick_elaps(last_task_run);
 801b744:	4b39      	ldr	r3, [pc, #228]	; (801b82c <anim_task+0x118>)
 801b746:	681b      	ldr	r3, [r3, #0]
 801b748:	4618      	mov	r0, r3
 801b74a:	f7ff fec9 	bl	801b4e0 <lv_tick_elaps>
 801b74e:	6138      	str	r0, [r7, #16]

    a = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801b750:	4835      	ldr	r0, [pc, #212]	; (801b828 <anim_task+0x114>)
 801b752:	f000 ff53 	bl	801c5fc <lv_ll_get_head>
 801b756:	6178      	str	r0, [r7, #20]

    while(a != NULL) {
 801b758:	e059      	b.n	801b80e <anim_task+0xfa>
        /*It can be set by `lv_anim_del()` typically in `end_cb`. If set then an animation delete
         * happened in `anim_ready_handler` which could make this linked list reading corrupt
         * because the list is changed meanwhile
         */
        anim_list_changed = false;
 801b75a:	4b35      	ldr	r3, [pc, #212]	; (801b830 <anim_task+0x11c>)
 801b75c:	2200      	movs	r2, #0
 801b75e:	701a      	strb	r2, [r3, #0]

        if(!a->has_run) {
 801b760:	697b      	ldr	r3, [r7, #20]
 801b762:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b766:	f003 0308 	and.w	r3, r3, #8
 801b76a:	b2db      	uxtb	r3, r3
 801b76c:	2b00      	cmp	r3, #0
 801b76e:	d140      	bne.n	801b7f2 <anim_task+0xde>
            a->has_run = 1; /*The list readying might be reseted so need to know which anim has run already*/
 801b770:	697a      	ldr	r2, [r7, #20]
 801b772:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801b776:	f043 0308 	orr.w	r3, r3, #8
 801b77a:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            a->act_time += elaps;
 801b77e:	697b      	ldr	r3, [r7, #20]
 801b780:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801b784:	b29a      	uxth	r2, r3
 801b786:	693b      	ldr	r3, [r7, #16]
 801b788:	b29b      	uxth	r3, r3
 801b78a:	4413      	add	r3, r2
 801b78c:	b29b      	uxth	r3, r3
 801b78e:	b21a      	sxth	r2, r3
 801b790:	697b      	ldr	r3, [r7, #20]
 801b792:	835a      	strh	r2, [r3, #26]
            if(a->act_time >= 0) {
 801b794:	697b      	ldr	r3, [r7, #20]
 801b796:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801b79a:	2b00      	cmp	r3, #0
 801b79c:	db29      	blt.n	801b7f2 <anim_task+0xde>
                if(a->act_time > a->time) a->act_time = a->time;
 801b79e:	697b      	ldr	r3, [r7, #20]
 801b7a0:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801b7a4:	461a      	mov	r2, r3
 801b7a6:	697b      	ldr	r3, [r7, #20]
 801b7a8:	8b1b      	ldrh	r3, [r3, #24]
 801b7aa:	429a      	cmp	r2, r3
 801b7ac:	dd04      	ble.n	801b7b8 <anim_task+0xa4>
 801b7ae:	697b      	ldr	r3, [r7, #20]
 801b7b0:	8b1b      	ldrh	r3, [r3, #24]
 801b7b2:	b21a      	sxth	r2, r3
 801b7b4:	697b      	ldr	r3, [r7, #20]
 801b7b6:	835a      	strh	r2, [r3, #26]

                int32_t new_value;
                new_value = a->path_cb(a);
 801b7b8:	697b      	ldr	r3, [r7, #20]
 801b7ba:	689b      	ldr	r3, [r3, #8]
 801b7bc:	6978      	ldr	r0, [r7, #20]
 801b7be:	4798      	blx	r3
 801b7c0:	4603      	mov	r3, r0
 801b7c2:	60fb      	str	r3, [r7, #12]

                /*Apply the calculated value*/
                if(a->exec_cb) a->exec_cb(a->var, new_value);
 801b7c4:	697b      	ldr	r3, [r7, #20]
 801b7c6:	685b      	ldr	r3, [r3, #4]
 801b7c8:	2b00      	cmp	r3, #0
 801b7ca:	d007      	beq.n	801b7dc <anim_task+0xc8>
 801b7cc:	697b      	ldr	r3, [r7, #20]
 801b7ce:	685b      	ldr	r3, [r3, #4]
 801b7d0:	697a      	ldr	r2, [r7, #20]
 801b7d2:	6812      	ldr	r2, [r2, #0]
 801b7d4:	68f9      	ldr	r1, [r7, #12]
 801b7d6:	b209      	sxth	r1, r1
 801b7d8:	4610      	mov	r0, r2
 801b7da:	4798      	blx	r3

                /*If the time is elapsed the animation is ready*/
                if(a->act_time >= a->time) {
 801b7dc:	697b      	ldr	r3, [r7, #20]
 801b7de:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801b7e2:	461a      	mov	r2, r3
 801b7e4:	697b      	ldr	r3, [r7, #20]
 801b7e6:	8b1b      	ldrh	r3, [r3, #24]
 801b7e8:	429a      	cmp	r2, r3
 801b7ea:	db02      	blt.n	801b7f2 <anim_task+0xde>
                    anim_ready_handler(a);
 801b7ec:	6978      	ldr	r0, [r7, #20]
 801b7ee:	f000 f821 	bl	801b834 <anim_ready_handler>
            }
        }

        /* If the linked list changed due to anim. delete then it's not safe to continue
         * the reading of the list from here -> start from the head*/
        if(anim_list_changed)
 801b7f2:	4b0f      	ldr	r3, [pc, #60]	; (801b830 <anim_task+0x11c>)
 801b7f4:	781b      	ldrb	r3, [r3, #0]
 801b7f6:	2b00      	cmp	r3, #0
 801b7f8:	d004      	beq.n	801b804 <anim_task+0xf0>
            a = lv_ll_get_head(&LV_GC_ROOT(_lv_anim_ll));
 801b7fa:	480b      	ldr	r0, [pc, #44]	; (801b828 <anim_task+0x114>)
 801b7fc:	f000 fefe 	bl	801c5fc <lv_ll_get_head>
 801b800:	6178      	str	r0, [r7, #20]
 801b802:	e004      	b.n	801b80e <anim_task+0xfa>
        else
            a = lv_ll_get_next(&LV_GC_ROOT(_lv_anim_ll), a);
 801b804:	6979      	ldr	r1, [r7, #20]
 801b806:	4808      	ldr	r0, [pc, #32]	; (801b828 <anim_task+0x114>)
 801b808:	f000 ff1e 	bl	801c648 <lv_ll_get_next>
 801b80c:	6178      	str	r0, [r7, #20]
    while(a != NULL) {
 801b80e:	697b      	ldr	r3, [r7, #20]
 801b810:	2b00      	cmp	r3, #0
 801b812:	d1a2      	bne.n	801b75a <anim_task+0x46>
    }

    last_task_run = lv_tick_get();
 801b814:	f7ff fe4a 	bl	801b4ac <lv_tick_get>
 801b818:	4602      	mov	r2, r0
 801b81a:	4b04      	ldr	r3, [pc, #16]	; (801b82c <anim_task+0x118>)
 801b81c:	601a      	str	r2, [r3, #0]
}
 801b81e:	bf00      	nop
 801b820:	3718      	adds	r7, #24
 801b822:	46bd      	mov	sp, r7
 801b824:	bd80      	pop	{r7, pc}
 801b826:	bf00      	nop
 801b828:	2000df8c 	.word	0x2000df8c
 801b82c:	20004384 	.word	0x20004384
 801b830:	20004388 	.word	0x20004388

0801b834 <anim_ready_handler>:
 * e.g. repeat, play back, delete etc.
 * @param a pointer to an animation descriptor
 * @return true: animation delete occurred nnd the `LV_GC_ROOT(_lv_anim_ll)` has changed
 * */
static bool anim_ready_handler(lv_anim_t * a)
{
 801b834:	b580      	push	{r7, lr}
 801b836:	b08e      	sub	sp, #56	; 0x38
 801b838:	af00      	add	r7, sp, #0
 801b83a:	6078      	str	r0, [r7, #4]

    /*Delete the animation if
     * - no repeat and no play back (simple one shot animation)
     * - no repeat, play back is enabled and play back is ready */
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 801b83c:	687b      	ldr	r3, [r7, #4]
 801b83e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b842:	f003 0302 	and.w	r3, r3, #2
 801b846:	b2db      	uxtb	r3, r3
 801b848:	2b00      	cmp	r3, #0
 801b84a:	d107      	bne.n	801b85c <anim_ready_handler+0x28>
 801b84c:	687b      	ldr	r3, [r7, #4]
 801b84e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b852:	f003 0301 	and.w	r3, r3, #1
 801b856:	b2db      	uxtb	r3, r3
 801b858:	2b00      	cmp	r3, #0
 801b85a:	d017      	beq.n	801b88c <anim_ready_handler+0x58>
 801b85c:	687b      	ldr	r3, [r7, #4]
 801b85e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b862:	f003 0302 	and.w	r3, r3, #2
 801b866:	b2db      	uxtb	r3, r3
 801b868:	2b00      	cmp	r3, #0
 801b86a:	d129      	bne.n	801b8c0 <anim_ready_handler+0x8c>
 801b86c:	687b      	ldr	r3, [r7, #4]
 801b86e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b872:	f003 0301 	and.w	r3, r3, #1
 801b876:	b2db      	uxtb	r3, r3
 801b878:	2b00      	cmp	r3, #0
 801b87a:	d021      	beq.n	801b8c0 <anim_ready_handler+0x8c>
 801b87c:	687b      	ldr	r3, [r7, #4]
 801b87e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b882:	f003 0304 	and.w	r3, r3, #4
 801b886:	b2db      	uxtb	r3, r3
 801b888:	2b00      	cmp	r3, #0
 801b88a:	d019      	beq.n	801b8c0 <anim_ready_handler+0x8c>

        /*Create copy from the animation and delete the animation from the list.
         * This way the `ready_cb` will see the animations like it's animation is ready deleted*/
        lv_anim_t a_tmp;
        memcpy(&a_tmp, a, sizeof(lv_anim_t));
 801b88c:	f107 030c 	add.w	r3, r7, #12
 801b890:	2228      	movs	r2, #40	; 0x28
 801b892:	6879      	ldr	r1, [r7, #4]
 801b894:	4618      	mov	r0, r3
 801b896:	f00b fc91 	bl	80271bc <memcpy>
        lv_ll_rem(&LV_GC_ROOT(_lv_anim_ll), a);
 801b89a:	6879      	ldr	r1, [r7, #4]
 801b89c:	4829      	ldr	r0, [pc, #164]	; (801b944 <anim_ready_handler+0x110>)
 801b89e:	f000 fdff 	bl	801c4a0 <lv_ll_rem>
        lv_mem_free(a);
 801b8a2:	6878      	ldr	r0, [r7, #4]
 801b8a4:	f001 f83e 	bl	801c924 <lv_mem_free>
        anim_list_changed = true;
 801b8a8:	4b27      	ldr	r3, [pc, #156]	; (801b948 <anim_ready_handler+0x114>)
 801b8aa:	2201      	movs	r2, #1
 801b8ac:	701a      	strb	r2, [r3, #0]

        /* Call the callback function at the end*/
        if(a_tmp.ready_cb != NULL) a_tmp.ready_cb(&a_tmp);
 801b8ae:	69bb      	ldr	r3, [r7, #24]
 801b8b0:	2b00      	cmp	r3, #0
 801b8b2:	d040      	beq.n	801b936 <anim_ready_handler+0x102>
 801b8b4:	69bb      	ldr	r3, [r7, #24]
 801b8b6:	f107 020c 	add.w	r2, r7, #12
 801b8ba:	4610      	mov	r0, r2
 801b8bc:	4798      	blx	r3
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 801b8be:	e03a      	b.n	801b936 <anim_ready_handler+0x102>
    }
    /*If the animation is not deleted then restart it*/
    else {
        a->act_time = -a->repeat_pause; /*Restart the animation*/
 801b8c0:	687b      	ldr	r3, [r7, #4]
 801b8c2:	8bdb      	ldrh	r3, [r3, #30]
 801b8c4:	425b      	negs	r3, r3
 801b8c6:	b29b      	uxth	r3, r3
 801b8c8:	b21a      	sxth	r2, r3
 801b8ca:	687b      	ldr	r3, [r7, #4]
 801b8cc:	835a      	strh	r2, [r3, #26]
        /*Swap the start and end values in play back mode*/
        if(a->playback != 0) {
 801b8ce:	687b      	ldr	r3, [r7, #4]
 801b8d0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b8d4:	f003 0301 	and.w	r3, r3, #1
 801b8d8:	b2db      	uxtb	r3, r3
 801b8da:	2b00      	cmp	r3, #0
 801b8dc:	d02c      	beq.n	801b938 <anim_ready_handler+0x104>
            /*If now turning back use the 'playback_pause*/
            if(a->playback_now == 0) a->act_time = -a->playback_pause;
 801b8de:	687b      	ldr	r3, [r7, #4]
 801b8e0:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b8e4:	f003 0304 	and.w	r3, r3, #4
 801b8e8:	b2db      	uxtb	r3, r3
 801b8ea:	2b00      	cmp	r3, #0
 801b8ec:	d106      	bne.n	801b8fc <anim_ready_handler+0xc8>
 801b8ee:	687b      	ldr	r3, [r7, #4]
 801b8f0:	8b9b      	ldrh	r3, [r3, #28]
 801b8f2:	425b      	negs	r3, r3
 801b8f4:	b29b      	uxth	r3, r3
 801b8f6:	b21a      	sxth	r2, r3
 801b8f8:	687b      	ldr	r3, [r7, #4]
 801b8fa:	835a      	strh	r2, [r3, #26]

            /*Toggle the play back state*/
            a->playback_now = a->playback_now == 0 ? 1 : 0;
 801b8fc:	687b      	ldr	r3, [r7, #4]
 801b8fe:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 801b902:	f003 0304 	and.w	r3, r3, #4
 801b906:	b2db      	uxtb	r3, r3
 801b908:	2b00      	cmp	r3, #0
 801b90a:	bf0c      	ite	eq
 801b90c:	2301      	moveq	r3, #1
 801b90e:	2300      	movne	r3, #0
 801b910:	b2d9      	uxtb	r1, r3
 801b912:	687a      	ldr	r2, [r7, #4]
 801b914:	f892 3024 	ldrb.w	r3, [r2, #36]	; 0x24
 801b918:	f361 0382 	bfi	r3, r1, #2, #1
 801b91c:	f882 3024 	strb.w	r3, [r2, #36]	; 0x24
            /*Swap the start and end values*/
            int32_t tmp;
            tmp      = a->start;
 801b920:	687b      	ldr	r3, [r7, #4]
 801b922:	691b      	ldr	r3, [r3, #16]
 801b924:	637b      	str	r3, [r7, #52]	; 0x34
            a->start = a->end;
 801b926:	687b      	ldr	r3, [r7, #4]
 801b928:	695a      	ldr	r2, [r3, #20]
 801b92a:	687b      	ldr	r3, [r7, #4]
 801b92c:	611a      	str	r2, [r3, #16]
            a->end   = tmp;
 801b92e:	687b      	ldr	r3, [r7, #4]
 801b930:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 801b932:	615a      	str	r2, [r3, #20]
 801b934:	e000      	b.n	801b938 <anim_ready_handler+0x104>
    if((a->repeat == 0 && a->playback == 0) || (a->repeat == 0 && a->playback == 1 && a->playback_now == 1)) {
 801b936:	bf00      	nop
        }
    }

    return anim_list_changed;
 801b938:	4b03      	ldr	r3, [pc, #12]	; (801b948 <anim_ready_handler+0x114>)
 801b93a:	781b      	ldrb	r3, [r3, #0]
}
 801b93c:	4618      	mov	r0, r3
 801b93e:	3738      	adds	r7, #56	; 0x38
 801b940:	46bd      	mov	sp, r7
 801b942:	bd80      	pop	{r7, pc}
 801b944:	2000df8c 	.word	0x2000df8c
 801b948:	20004388 	.word	0x20004388

0801b94c <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 801b94c:	b480      	push	{r7}
 801b94e:	b083      	sub	sp, #12
 801b950:	af00      	add	r7, sp, #0
 801b952:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 801b954:	687b      	ldr	r3, [r7, #4]
 801b956:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801b95a:	b29a      	uxth	r2, r3
 801b95c:	687b      	ldr	r3, [r7, #4]
 801b95e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b962:	b29b      	uxth	r3, r3
 801b964:	1ad3      	subs	r3, r2, r3
 801b966:	b29b      	uxth	r3, r3
 801b968:	3301      	adds	r3, #1
 801b96a:	b29b      	uxth	r3, r3
 801b96c:	b21b      	sxth	r3, r3
}
 801b96e:	4618      	mov	r0, r3
 801b970:	370c      	adds	r7, #12
 801b972:	46bd      	mov	sp, r7
 801b974:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b978:	4770      	bx	lr

0801b97a <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 801b97a:	b480      	push	{r7}
 801b97c:	b083      	sub	sp, #12
 801b97e:	af00      	add	r7, sp, #0
 801b980:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 801b982:	687b      	ldr	r3, [r7, #4]
 801b984:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801b988:	b29a      	uxth	r2, r3
 801b98a:	687b      	ldr	r3, [r7, #4]
 801b98c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801b990:	b29b      	uxth	r3, r3
 801b992:	1ad3      	subs	r3, r2, r3
 801b994:	b29b      	uxth	r3, r3
 801b996:	3301      	adds	r3, #1
 801b998:	b29b      	uxth	r3, r3
 801b99a:	b21b      	sxth	r3, r3
}
 801b99c:	4618      	mov	r0, r3
 801b99e:	370c      	adds	r7, #12
 801b9a0:	46bd      	mov	sp, r7
 801b9a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b9a6:	4770      	bx	lr

0801b9a8 <lv_area_set>:
 * @param y1 top coordinate of the area
 * @param x2 right coordinate of the area
 * @param y2 bottom coordinate of the area
 */
void lv_area_set(lv_area_t * area_p, lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2)
{
 801b9a8:	b480      	push	{r7}
 801b9aa:	b085      	sub	sp, #20
 801b9ac:	af00      	add	r7, sp, #0
 801b9ae:	60f8      	str	r0, [r7, #12]
 801b9b0:	4608      	mov	r0, r1
 801b9b2:	4611      	mov	r1, r2
 801b9b4:	461a      	mov	r2, r3
 801b9b6:	4603      	mov	r3, r0
 801b9b8:	817b      	strh	r3, [r7, #10]
 801b9ba:	460b      	mov	r3, r1
 801b9bc:	813b      	strh	r3, [r7, #8]
 801b9be:	4613      	mov	r3, r2
 801b9c0:	80fb      	strh	r3, [r7, #6]
    area_p->x1 = x1;
 801b9c2:	68fb      	ldr	r3, [r7, #12]
 801b9c4:	897a      	ldrh	r2, [r7, #10]
 801b9c6:	801a      	strh	r2, [r3, #0]
    area_p->y1 = y1;
 801b9c8:	68fb      	ldr	r3, [r7, #12]
 801b9ca:	893a      	ldrh	r2, [r7, #8]
 801b9cc:	805a      	strh	r2, [r3, #2]
    area_p->x2 = x2;
 801b9ce:	68fb      	ldr	r3, [r7, #12]
 801b9d0:	88fa      	ldrh	r2, [r7, #6]
 801b9d2:	809a      	strh	r2, [r3, #4]
    area_p->y2 = y2;
 801b9d4:	68fb      	ldr	r3, [r7, #12]
 801b9d6:	8b3a      	ldrh	r2, [r7, #24]
 801b9d8:	80da      	strh	r2, [r3, #6]
}
 801b9da:	bf00      	nop
 801b9dc:	3714      	adds	r7, #20
 801b9de:	46bd      	mov	sp, r7
 801b9e0:	f85d 7b04 	ldr.w	r7, [sp], #4
 801b9e4:	4770      	bx	lr

0801b9e6 <lv_area_set_width>:
 * Set the width of an area
 * @param area_p pointer to an area
 * @param w the new width of the area (w == 1 makes x1 == x2)
 */
void lv_area_set_width(lv_area_t * area_p, lv_coord_t w)
{
 801b9e6:	b480      	push	{r7}
 801b9e8:	b083      	sub	sp, #12
 801b9ea:	af00      	add	r7, sp, #0
 801b9ec:	6078      	str	r0, [r7, #4]
 801b9ee:	460b      	mov	r3, r1
 801b9f0:	807b      	strh	r3, [r7, #2]
    area_p->x2 = area_p->x1 + w - 1;
 801b9f2:	687b      	ldr	r3, [r7, #4]
 801b9f4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801b9f8:	b29a      	uxth	r2, r3
 801b9fa:	887b      	ldrh	r3, [r7, #2]
 801b9fc:	4413      	add	r3, r2
 801b9fe:	b29b      	uxth	r3, r3
 801ba00:	3b01      	subs	r3, #1
 801ba02:	b29b      	uxth	r3, r3
 801ba04:	b21a      	sxth	r2, r3
 801ba06:	687b      	ldr	r3, [r7, #4]
 801ba08:	809a      	strh	r2, [r3, #4]
}
 801ba0a:	bf00      	nop
 801ba0c:	370c      	adds	r7, #12
 801ba0e:	46bd      	mov	sp, r7
 801ba10:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ba14:	4770      	bx	lr

0801ba16 <lv_area_set_height>:
 * Set the height of an area
 * @param area_p pointer to an area
 * @param h the new height of the area (h == 1 makes y1 == y2)
 */
void lv_area_set_height(lv_area_t * area_p, lv_coord_t h)
{
 801ba16:	b480      	push	{r7}
 801ba18:	b083      	sub	sp, #12
 801ba1a:	af00      	add	r7, sp, #0
 801ba1c:	6078      	str	r0, [r7, #4]
 801ba1e:	460b      	mov	r3, r1
 801ba20:	807b      	strh	r3, [r7, #2]
    area_p->y2 = area_p->y1 + h - 1;
 801ba22:	687b      	ldr	r3, [r7, #4]
 801ba24:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801ba28:	b29a      	uxth	r2, r3
 801ba2a:	887b      	ldrh	r3, [r7, #2]
 801ba2c:	4413      	add	r3, r2
 801ba2e:	b29b      	uxth	r3, r3
 801ba30:	3b01      	subs	r3, #1
 801ba32:	b29b      	uxth	r3, r3
 801ba34:	b21a      	sxth	r2, r3
 801ba36:	687b      	ldr	r3, [r7, #4]
 801ba38:	80da      	strh	r2, [r3, #6]
}
 801ba3a:	bf00      	nop
 801ba3c:	370c      	adds	r7, #12
 801ba3e:	46bd      	mov	sp, r7
 801ba40:	f85d 7b04 	ldr.w	r7, [sp], #4
 801ba44:	4770      	bx	lr

0801ba46 <lv_area_set_pos>:
 * @param area_p pointer to an area
 * @param x the new x coordinate of the area
 * @param y the new y coordinate of the area
 */
void lv_area_set_pos(lv_area_t * area_p, lv_coord_t x, lv_coord_t y)
{
 801ba46:	b580      	push	{r7, lr}
 801ba48:	b084      	sub	sp, #16
 801ba4a:	af00      	add	r7, sp, #0
 801ba4c:	6078      	str	r0, [r7, #4]
 801ba4e:	460b      	mov	r3, r1
 801ba50:	807b      	strh	r3, [r7, #2]
 801ba52:	4613      	mov	r3, r2
 801ba54:	803b      	strh	r3, [r7, #0]
    lv_coord_t w = lv_area_get_width(area_p);
 801ba56:	6878      	ldr	r0, [r7, #4]
 801ba58:	f7ff ff78 	bl	801b94c <lv_area_get_width>
 801ba5c:	4603      	mov	r3, r0
 801ba5e:	81fb      	strh	r3, [r7, #14]
    lv_coord_t h = lv_area_get_height(area_p);
 801ba60:	6878      	ldr	r0, [r7, #4]
 801ba62:	f7ff ff8a 	bl	801b97a <lv_area_get_height>
 801ba66:	4603      	mov	r3, r0
 801ba68:	81bb      	strh	r3, [r7, #12]
    area_p->x1   = x;
 801ba6a:	687b      	ldr	r3, [r7, #4]
 801ba6c:	887a      	ldrh	r2, [r7, #2]
 801ba6e:	801a      	strh	r2, [r3, #0]
    area_p->y1   = y;
 801ba70:	687b      	ldr	r3, [r7, #4]
 801ba72:	883a      	ldrh	r2, [r7, #0]
 801ba74:	805a      	strh	r2, [r3, #2]
    lv_area_set_width(area_p, w);
 801ba76:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801ba7a:	4619      	mov	r1, r3
 801ba7c:	6878      	ldr	r0, [r7, #4]
 801ba7e:	f7ff ffb2 	bl	801b9e6 <lv_area_set_width>
    lv_area_set_height(area_p, h);
 801ba82:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 801ba86:	4619      	mov	r1, r3
 801ba88:	6878      	ldr	r0, [r7, #4]
 801ba8a:	f7ff ffc4 	bl	801ba16 <lv_area_set_height>
}
 801ba8e:	bf00      	nop
 801ba90:	3710      	adds	r7, #16
 801ba92:	46bd      	mov	sp, r7
 801ba94:	bd80      	pop	{r7, pc}

0801ba96 <lv_area_get_size>:
 * Return with area of an area (x * y)
 * @param area_p pointer to an area
 * @return size of area
 */
uint32_t lv_area_get_size(const lv_area_t * area_p)
{
 801ba96:	b480      	push	{r7}
 801ba98:	b085      	sub	sp, #20
 801ba9a:	af00      	add	r7, sp, #0
 801ba9c:	6078      	str	r0, [r7, #4]
    uint32_t size;

    size = (uint32_t)(area_p->x2 - area_p->x1 + 1) * (area_p->y2 - area_p->y1 + 1);
 801ba9e:	687b      	ldr	r3, [r7, #4]
 801baa0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801baa4:	461a      	mov	r2, r3
 801baa6:	687b      	ldr	r3, [r7, #4]
 801baa8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801baac:	1ad3      	subs	r3, r2, r3
 801baae:	3301      	adds	r3, #1
 801bab0:	461a      	mov	r2, r3
 801bab2:	687b      	ldr	r3, [r7, #4]
 801bab4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bab8:	4619      	mov	r1, r3
 801baba:	687b      	ldr	r3, [r7, #4]
 801babc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bac0:	1acb      	subs	r3, r1, r3
 801bac2:	3301      	adds	r3, #1
 801bac4:	fb03 f302 	mul.w	r3, r3, r2
 801bac8:	60fb      	str	r3, [r7, #12]

    return size;
 801baca:	68fb      	ldr	r3, [r7, #12]
}
 801bacc:	4618      	mov	r0, r3
 801bace:	3714      	adds	r7, #20
 801bad0:	46bd      	mov	sp, r7
 801bad2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bad6:	4770      	bx	lr

0801bad8 <lv_area_intersect>:
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 * @return false: the two area has NO common parts, res_p is invalid
 */
bool lv_area_intersect(lv_area_t * res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801bad8:	b480      	push	{r7}
 801bada:	b087      	sub	sp, #28
 801badc:	af00      	add	r7, sp, #0
 801bade:	60f8      	str	r0, [r7, #12]
 801bae0:	60b9      	str	r1, [r7, #8]
 801bae2:	607a      	str	r2, [r7, #4]
    /* Get the smaller area from 'a1_p' and 'a2_p' */
    res_p->x1 = LV_MATH_MAX(a1_p->x1, a2_p->x1);
 801bae4:	687b      	ldr	r3, [r7, #4]
 801bae6:	f9b3 2000 	ldrsh.w	r2, [r3]
 801baea:	68bb      	ldr	r3, [r7, #8]
 801baec:	f9b3 3000 	ldrsh.w	r3, [r3]
 801baf0:	4293      	cmp	r3, r2
 801baf2:	bfb8      	it	lt
 801baf4:	4613      	movlt	r3, r2
 801baf6:	b21a      	sxth	r2, r3
 801baf8:	68fb      	ldr	r3, [r7, #12]
 801bafa:	801a      	strh	r2, [r3, #0]
    res_p->y1 = LV_MATH_MAX(a1_p->y1, a2_p->y1);
 801bafc:	687b      	ldr	r3, [r7, #4]
 801bafe:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bb02:	68bb      	ldr	r3, [r7, #8]
 801bb04:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bb08:	4293      	cmp	r3, r2
 801bb0a:	bfb8      	it	lt
 801bb0c:	4613      	movlt	r3, r2
 801bb0e:	b21a      	sxth	r2, r3
 801bb10:	68fb      	ldr	r3, [r7, #12]
 801bb12:	805a      	strh	r2, [r3, #2]
    res_p->x2 = LV_MATH_MIN(a1_p->x2, a2_p->x2);
 801bb14:	687b      	ldr	r3, [r7, #4]
 801bb16:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801bb1a:	68bb      	ldr	r3, [r7, #8]
 801bb1c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bb20:	4293      	cmp	r3, r2
 801bb22:	bfa8      	it	ge
 801bb24:	4613      	movge	r3, r2
 801bb26:	b21a      	sxth	r2, r3
 801bb28:	68fb      	ldr	r3, [r7, #12]
 801bb2a:	809a      	strh	r2, [r3, #4]
    res_p->y2 = LV_MATH_MIN(a1_p->y2, a2_p->y2);
 801bb2c:	687b      	ldr	r3, [r7, #4]
 801bb2e:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801bb32:	68bb      	ldr	r3, [r7, #8]
 801bb34:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bb38:	4293      	cmp	r3, r2
 801bb3a:	bfa8      	it	ge
 801bb3c:	4613      	movge	r3, r2
 801bb3e:	b21a      	sxth	r2, r3
 801bb40:	68fb      	ldr	r3, [r7, #12]
 801bb42:	80da      	strh	r2, [r3, #6]

    /*If x1 or y1 greater then x2 or y2 then the areas union is empty*/
    bool union_ok = true;
 801bb44:	2301      	movs	r3, #1
 801bb46:	75fb      	strb	r3, [r7, #23]
    if((res_p->x1 > res_p->x2) || (res_p->y1 > res_p->y2)) {
 801bb48:	68fb      	ldr	r3, [r7, #12]
 801bb4a:	f9b3 2000 	ldrsh.w	r2, [r3]
 801bb4e:	68fb      	ldr	r3, [r7, #12]
 801bb50:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bb54:	429a      	cmp	r2, r3
 801bb56:	dc07      	bgt.n	801bb68 <lv_area_intersect+0x90>
 801bb58:	68fb      	ldr	r3, [r7, #12]
 801bb5a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bb5e:	68fb      	ldr	r3, [r7, #12]
 801bb60:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bb64:	429a      	cmp	r2, r3
 801bb66:	dd01      	ble.n	801bb6c <lv_area_intersect+0x94>
        union_ok = false;
 801bb68:	2300      	movs	r3, #0
 801bb6a:	75fb      	strb	r3, [r7, #23]
    }

    return union_ok;
 801bb6c:	7dfb      	ldrb	r3, [r7, #23]
}
 801bb6e:	4618      	mov	r0, r3
 801bb70:	371c      	adds	r7, #28
 801bb72:	46bd      	mov	sp, r7
 801bb74:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bb78:	4770      	bx	lr

0801bb7a <lv_area_join>:
 * @param res_p pointer to an area, the result will be stored here
 * @param a1_p pointer to the first area
 * @param a2_p pointer to the second area
 */
void lv_area_join(lv_area_t * a_res_p, const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801bb7a:	b480      	push	{r7}
 801bb7c:	b085      	sub	sp, #20
 801bb7e:	af00      	add	r7, sp, #0
 801bb80:	60f8      	str	r0, [r7, #12]
 801bb82:	60b9      	str	r1, [r7, #8]
 801bb84:	607a      	str	r2, [r7, #4]
    a_res_p->x1 = LV_MATH_MIN(a1_p->x1, a2_p->x1);
 801bb86:	687b      	ldr	r3, [r7, #4]
 801bb88:	f9b3 2000 	ldrsh.w	r2, [r3]
 801bb8c:	68bb      	ldr	r3, [r7, #8]
 801bb8e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bb92:	4293      	cmp	r3, r2
 801bb94:	bfa8      	it	ge
 801bb96:	4613      	movge	r3, r2
 801bb98:	b21a      	sxth	r2, r3
 801bb9a:	68fb      	ldr	r3, [r7, #12]
 801bb9c:	801a      	strh	r2, [r3, #0]
    a_res_p->y1 = LV_MATH_MIN(a1_p->y1, a2_p->y1);
 801bb9e:	687b      	ldr	r3, [r7, #4]
 801bba0:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bba4:	68bb      	ldr	r3, [r7, #8]
 801bba6:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bbaa:	4293      	cmp	r3, r2
 801bbac:	bfa8      	it	ge
 801bbae:	4613      	movge	r3, r2
 801bbb0:	b21a      	sxth	r2, r3
 801bbb2:	68fb      	ldr	r3, [r7, #12]
 801bbb4:	805a      	strh	r2, [r3, #2]
    a_res_p->x2 = LV_MATH_MAX(a1_p->x2, a2_p->x2);
 801bbb6:	687b      	ldr	r3, [r7, #4]
 801bbb8:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801bbbc:	68bb      	ldr	r3, [r7, #8]
 801bbbe:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bbc2:	4293      	cmp	r3, r2
 801bbc4:	bfb8      	it	lt
 801bbc6:	4613      	movlt	r3, r2
 801bbc8:	b21a      	sxth	r2, r3
 801bbca:	68fb      	ldr	r3, [r7, #12]
 801bbcc:	809a      	strh	r2, [r3, #4]
    a_res_p->y2 = LV_MATH_MAX(a1_p->y2, a2_p->y2);
 801bbce:	687b      	ldr	r3, [r7, #4]
 801bbd0:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801bbd4:	68bb      	ldr	r3, [r7, #8]
 801bbd6:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bbda:	4293      	cmp	r3, r2
 801bbdc:	bfb8      	it	lt
 801bbde:	4613      	movlt	r3, r2
 801bbe0:	b21a      	sxth	r2, r3
 801bbe2:	68fb      	ldr	r3, [r7, #12]
 801bbe4:	80da      	strh	r2, [r3, #6]
}
 801bbe6:	bf00      	nop
 801bbe8:	3714      	adds	r7, #20
 801bbea:	46bd      	mov	sp, r7
 801bbec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bbf0:	4770      	bx	lr

0801bbf2 <lv_area_is_point_on>:
 * @param a_p pointer to an area
 * @param p_p pointer to a point
 * @return false:the point is out of the area
 */
bool lv_area_is_point_on(const lv_area_t * a_p, const lv_point_t * p_p)
{
 801bbf2:	b480      	push	{r7}
 801bbf4:	b085      	sub	sp, #20
 801bbf6:	af00      	add	r7, sp, #0
 801bbf8:	6078      	str	r0, [r7, #4]
 801bbfa:	6039      	str	r1, [r7, #0]
    bool is_on = false;
 801bbfc:	2300      	movs	r3, #0
 801bbfe:	73fb      	strb	r3, [r7, #15]

    if((p_p->x >= a_p->x1 && p_p->x <= a_p->x2) && ((p_p->y >= a_p->y1 && p_p->y <= a_p->y2))) {
 801bc00:	683b      	ldr	r3, [r7, #0]
 801bc02:	f9b3 2000 	ldrsh.w	r2, [r3]
 801bc06:	687b      	ldr	r3, [r7, #4]
 801bc08:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc0c:	429a      	cmp	r2, r3
 801bc0e:	db19      	blt.n	801bc44 <lv_area_is_point_on+0x52>
 801bc10:	683b      	ldr	r3, [r7, #0]
 801bc12:	f9b3 2000 	ldrsh.w	r2, [r3]
 801bc16:	687b      	ldr	r3, [r7, #4]
 801bc18:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bc1c:	429a      	cmp	r2, r3
 801bc1e:	dc11      	bgt.n	801bc44 <lv_area_is_point_on+0x52>
 801bc20:	683b      	ldr	r3, [r7, #0]
 801bc22:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bc26:	687b      	ldr	r3, [r7, #4]
 801bc28:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bc2c:	429a      	cmp	r2, r3
 801bc2e:	db09      	blt.n	801bc44 <lv_area_is_point_on+0x52>
 801bc30:	683b      	ldr	r3, [r7, #0]
 801bc32:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bc36:	687b      	ldr	r3, [r7, #4]
 801bc38:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bc3c:	429a      	cmp	r2, r3
 801bc3e:	dc01      	bgt.n	801bc44 <lv_area_is_point_on+0x52>
        is_on = true;
 801bc40:	2301      	movs	r3, #1
 801bc42:	73fb      	strb	r3, [r7, #15]
    }

    return is_on;
 801bc44:	7bfb      	ldrb	r3, [r7, #15]
}
 801bc46:	4618      	mov	r0, r3
 801bc48:	3714      	adds	r7, #20
 801bc4a:	46bd      	mov	sp, r7
 801bc4c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bc50:	4770      	bx	lr

0801bc52 <lv_area_is_on>:
 * @param a1_p pointer to an area.
 * @param a2_p pointer to an other area
 * @return false: a1_p and a2_p has no common parts
 */
bool lv_area_is_on(const lv_area_t * a1_p, const lv_area_t * a2_p)
{
 801bc52:	b480      	push	{r7}
 801bc54:	b083      	sub	sp, #12
 801bc56:	af00      	add	r7, sp, #0
 801bc58:	6078      	str	r0, [r7, #4]
 801bc5a:	6039      	str	r1, [r7, #0]
    if((a1_p->x1 <= a2_p->x2) && (a1_p->x2 >= a2_p->x1) && (a1_p->y1 <= a2_p->y2) && (a1_p->y2 >= a2_p->y1)) {
 801bc5c:	687b      	ldr	r3, [r7, #4]
 801bc5e:	f9b3 2000 	ldrsh.w	r2, [r3]
 801bc62:	683b      	ldr	r3, [r7, #0]
 801bc64:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bc68:	429a      	cmp	r2, r3
 801bc6a:	dc19      	bgt.n	801bca0 <lv_area_is_on+0x4e>
 801bc6c:	687b      	ldr	r3, [r7, #4]
 801bc6e:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801bc72:	683b      	ldr	r3, [r7, #0]
 801bc74:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bc78:	429a      	cmp	r2, r3
 801bc7a:	db11      	blt.n	801bca0 <lv_area_is_on+0x4e>
 801bc7c:	687b      	ldr	r3, [r7, #4]
 801bc7e:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bc82:	683b      	ldr	r3, [r7, #0]
 801bc84:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801bc88:	429a      	cmp	r2, r3
 801bc8a:	dc09      	bgt.n	801bca0 <lv_area_is_on+0x4e>
 801bc8c:	687b      	ldr	r3, [r7, #4]
 801bc8e:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801bc92:	683b      	ldr	r3, [r7, #0]
 801bc94:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bc98:	429a      	cmp	r2, r3
 801bc9a:	db01      	blt.n	801bca0 <lv_area_is_on+0x4e>
        return true;
 801bc9c:	2301      	movs	r3, #1
 801bc9e:	e000      	b.n	801bca2 <lv_area_is_on+0x50>
    } else {
        return false;
 801bca0:	2300      	movs	r3, #0
    }
}
 801bca2:	4618      	mov	r0, r3
 801bca4:	370c      	adds	r7, #12
 801bca6:	46bd      	mov	sp, r7
 801bca8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bcac:	4770      	bx	lr

0801bcae <lv_area_is_in>:
 * @param ain_p pointer to an area which could be in 'aholder_p'
 * @param aholder pointer to an area which could involve 'ain_p'
 * @return
 */
bool lv_area_is_in(const lv_area_t * ain_p, const lv_area_t * aholder_p)
{
 801bcae:	b480      	push	{r7}
 801bcb0:	b085      	sub	sp, #20
 801bcb2:	af00      	add	r7, sp, #0
 801bcb4:	6078      	str	r0, [r7, #4]
 801bcb6:	6039      	str	r1, [r7, #0]
    bool is_in = false;
 801bcb8:	2300      	movs	r3, #0
 801bcba:	73fb      	strb	r3, [r7, #15]

    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 801bcbc:	687b      	ldr	r3, [r7, #4]
 801bcbe:	f9b3 2000 	ldrsh.w	r2, [r3]
 801bcc2:	683b      	ldr	r3, [r7, #0]
 801bcc4:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bcc8:	429a      	cmp	r2, r3
 801bcca:	db19      	blt.n	801bd00 <lv_area_is_in+0x52>
 801bccc:	687b      	ldr	r3, [r7, #4]
 801bcce:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bcd2:	683b      	ldr	r3, [r7, #0]
 801bcd4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bcd8:	429a      	cmp	r2, r3
 801bcda:	db11      	blt.n	801bd00 <lv_area_is_in+0x52>
 801bcdc:	687b      	ldr	r3, [r7, #4]
 801bcde:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801bce2:	683b      	ldr	r3, [r7, #0]
 801bce4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801bce8:	429a      	cmp	r2, r3
 801bcea:	dc09      	bgt.n	801bd00 <lv_area_is_in+0x52>
       ain_p->y2 <= aholder_p->y2) {
 801bcec:	687b      	ldr	r3, [r7, #4]
 801bcee:	f9b3 2006 	ldrsh.w	r2, [r3, #6]
 801bcf2:	683b      	ldr	r3, [r7, #0]
 801bcf4:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
    if(ain_p->x1 >= aholder_p->x1 && ain_p->y1 >= aholder_p->y1 && ain_p->x2 <= aholder_p->x2 &&
 801bcf8:	429a      	cmp	r2, r3
 801bcfa:	dc01      	bgt.n	801bd00 <lv_area_is_in+0x52>
        is_in = true;
 801bcfc:	2301      	movs	r3, #1
 801bcfe:	73fb      	strb	r3, [r7, #15]
    }

    return is_in;
 801bd00:	7bfb      	ldrb	r3, [r7, #15]
}
 801bd02:	4618      	mov	r0, r3
 801bd04:	3714      	adds	r7, #20
 801bd06:	46bd      	mov	sp, r7
 801bd08:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bd0c:	4770      	bx	lr

0801bd0e <lv_circ_init>:
 * @param c pointer to a point. The coordinates will be calculated here
 * @param tmp point to a variable. It will store temporary data
 * @param radius radius of the circle
 */
void lv_circ_init(lv_point_t * c, lv_coord_t * tmp, lv_coord_t radius)
{
 801bd0e:	b480      	push	{r7}
 801bd10:	b085      	sub	sp, #20
 801bd12:	af00      	add	r7, sp, #0
 801bd14:	60f8      	str	r0, [r7, #12]
 801bd16:	60b9      	str	r1, [r7, #8]
 801bd18:	4613      	mov	r3, r2
 801bd1a:	80fb      	strh	r3, [r7, #6]
    c->x = radius;
 801bd1c:	68fb      	ldr	r3, [r7, #12]
 801bd1e:	88fa      	ldrh	r2, [r7, #6]
 801bd20:	801a      	strh	r2, [r3, #0]
    c->y = 0;
 801bd22:	68fb      	ldr	r3, [r7, #12]
 801bd24:	2200      	movs	r2, #0
 801bd26:	805a      	strh	r2, [r3, #2]
    *tmp = 1 - radius;
 801bd28:	88fb      	ldrh	r3, [r7, #6]
 801bd2a:	f1c3 0301 	rsb	r3, r3, #1
 801bd2e:	b29b      	uxth	r3, r3
 801bd30:	b21a      	sxth	r2, r3
 801bd32:	68bb      	ldr	r3, [r7, #8]
 801bd34:	801a      	strh	r2, [r3, #0]
}
 801bd36:	bf00      	nop
 801bd38:	3714      	adds	r7, #20
 801bd3a:	46bd      	mov	sp, r7
 801bd3c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bd40:	4770      	bx	lr

0801bd42 <lv_circ_cont>:
 * Test the circle drawing is ready or not
 * @param c same as in circ_init
 * @return true if the circle is not ready yet
 */
bool lv_circ_cont(lv_point_t * c)
{
 801bd42:	b480      	push	{r7}
 801bd44:	b083      	sub	sp, #12
 801bd46:	af00      	add	r7, sp, #0
 801bd48:	6078      	str	r0, [r7, #4]
    return c->y <= c->x ? true : false;
 801bd4a:	687b      	ldr	r3, [r7, #4]
 801bd4c:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801bd50:	687b      	ldr	r3, [r7, #4]
 801bd52:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bd56:	429a      	cmp	r2, r3
 801bd58:	bfd4      	ite	le
 801bd5a:	2301      	movle	r3, #1
 801bd5c:	2300      	movgt	r3, #0
 801bd5e:	b2db      	uxtb	r3, r3
}
 801bd60:	4618      	mov	r0, r3
 801bd62:	370c      	adds	r7, #12
 801bd64:	46bd      	mov	sp, r7
 801bd66:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bd6a:	4770      	bx	lr

0801bd6c <lv_circ_next>:
 * Get the next point from the circle
 * @param c same as in circ_init. The next point stored here.
 * @param tmp same as in circ_init.
 */
void lv_circ_next(lv_point_t * c, lv_coord_t * tmp)
{
 801bd6c:	b480      	push	{r7}
 801bd6e:	b083      	sub	sp, #12
 801bd70:	af00      	add	r7, sp, #0
 801bd72:	6078      	str	r0, [r7, #4]
 801bd74:	6039      	str	r1, [r7, #0]
    c->y++;
 801bd76:	687b      	ldr	r3, [r7, #4]
 801bd78:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bd7c:	b29b      	uxth	r3, r3
 801bd7e:	3301      	adds	r3, #1
 801bd80:	b29b      	uxth	r3, r3
 801bd82:	b21a      	sxth	r2, r3
 801bd84:	687b      	ldr	r3, [r7, #4]
 801bd86:	805a      	strh	r2, [r3, #2]

    if(*tmp <= 0) {
 801bd88:	683b      	ldr	r3, [r7, #0]
 801bd8a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bd8e:	2b00      	cmp	r3, #0
 801bd90:	dc11      	bgt.n	801bdb6 <lv_circ_next+0x4a>
        (*tmp) += 2 * c->y + 1; // Change in decision criterion for y -> y+1
 801bd92:	683b      	ldr	r3, [r7, #0]
 801bd94:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bd98:	b29a      	uxth	r2, r3
 801bd9a:	687b      	ldr	r3, [r7, #4]
 801bd9c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bda0:	b29b      	uxth	r3, r3
 801bda2:	005b      	lsls	r3, r3, #1
 801bda4:	b29b      	uxth	r3, r3
 801bda6:	4413      	add	r3, r2
 801bda8:	b29b      	uxth	r3, r3
 801bdaa:	3301      	adds	r3, #1
 801bdac:	b29b      	uxth	r3, r3
 801bdae:	b21a      	sxth	r2, r3
 801bdb0:	683b      	ldr	r3, [r7, #0]
 801bdb2:	801a      	strh	r2, [r3, #0]
    } else {
        c->x--;
        (*tmp) += 2 * (c->y - c->x) + 1; // Change for y -> y+1, x -> x-1
    }
}
 801bdb4:	e01e      	b.n	801bdf4 <lv_circ_next+0x88>
        c->x--;
 801bdb6:	687b      	ldr	r3, [r7, #4]
 801bdb8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bdbc:	b29b      	uxth	r3, r3
 801bdbe:	3b01      	subs	r3, #1
 801bdc0:	b29b      	uxth	r3, r3
 801bdc2:	b21a      	sxth	r2, r3
 801bdc4:	687b      	ldr	r3, [r7, #4]
 801bdc6:	801a      	strh	r2, [r3, #0]
        (*tmp) += 2 * (c->y - c->x) + 1; // Change for y -> y+1, x -> x-1
 801bdc8:	683b      	ldr	r3, [r7, #0]
 801bdca:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bdce:	b29a      	uxth	r2, r3
 801bdd0:	687b      	ldr	r3, [r7, #4]
 801bdd2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801bdd6:	4619      	mov	r1, r3
 801bdd8:	687b      	ldr	r3, [r7, #4]
 801bdda:	f9b3 3000 	ldrsh.w	r3, [r3]
 801bdde:	1acb      	subs	r3, r1, r3
 801bde0:	b29b      	uxth	r3, r3
 801bde2:	005b      	lsls	r3, r3, #1
 801bde4:	b29b      	uxth	r3, r3
 801bde6:	4413      	add	r3, r2
 801bde8:	b29b      	uxth	r3, r3
 801bdea:	3301      	adds	r3, #1
 801bdec:	b29b      	uxth	r3, r3
 801bdee:	b21a      	sxth	r2, r3
 801bdf0:	683b      	ldr	r3, [r7, #0]
 801bdf2:	801a      	strh	r2, [r3, #0]
}
 801bdf4:	bf00      	nop
 801bdf6:	370c      	adds	r7, #12
 801bdf8:	46bd      	mov	sp, r7
 801bdfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801bdfe:	4770      	bx	lr

0801be00 <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 801be00:	b480      	push	{r7}
 801be02:	b085      	sub	sp, #20
 801be04:	af00      	add	r7, sp, #0
 801be06:	4603      	mov	r3, r0
 801be08:	71fb      	strb	r3, [r7, #7]
 801be0a:	460b      	mov	r3, r1
 801be0c:	71bb      	strb	r3, [r7, #6]
 801be0e:	4613      	mov	r3, r2
 801be10:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 801be12:	797b      	ldrb	r3, [r7, #5]
 801be14:	08db      	lsrs	r3, r3, #3
 801be16:	b2db      	uxtb	r3, r3
 801be18:	f003 031f 	and.w	r3, r3, #31
 801be1c:	b2da      	uxtb	r2, r3
 801be1e:	7b3b      	ldrb	r3, [r7, #12]
 801be20:	f362 0304 	bfi	r3, r2, #0, #5
 801be24:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 801be26:	79bb      	ldrb	r3, [r7, #6]
 801be28:	089b      	lsrs	r3, r3, #2
 801be2a:	b2db      	uxtb	r3, r3
 801be2c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801be30:	b2da      	uxtb	r2, r3
 801be32:	89bb      	ldrh	r3, [r7, #12]
 801be34:	f362 134a 	bfi	r3, r2, #5, #6
 801be38:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 801be3a:	79fb      	ldrb	r3, [r7, #7]
 801be3c:	08db      	lsrs	r3, r3, #3
 801be3e:	b2db      	uxtb	r3, r3
 801be40:	f003 031f 	and.w	r3, r3, #31
 801be44:	b2da      	uxtb	r2, r3
 801be46:	7b7b      	ldrb	r3, [r7, #13]
 801be48:	f362 03c7 	bfi	r3, r2, #3, #5
 801be4c:	737b      	strb	r3, [r7, #13]
    return color;
 801be4e:	89bb      	ldrh	r3, [r7, #12]
}
 801be50:	4618      	mov	r0, r3
 801be52:	3714      	adds	r7, #20
 801be54:	46bd      	mov	sp, r7
 801be56:	f85d 7b04 	ldr.w	r7, [sp], #4
 801be5a:	4770      	bx	lr

0801be5c <lv_color_hsv_to_rgb>:
 * @param s saturation [0..100]
 * @param v value [0..100]
 * @return the given RGB color in RGB (with LV_COLOR_DEPTH depth)
 */
lv_color_t lv_color_hsv_to_rgb(uint16_t h, uint8_t s, uint8_t v)
{
 801be5c:	b580      	push	{r7, lr}
 801be5e:	b086      	sub	sp, #24
 801be60:	af00      	add	r7, sp, #0
 801be62:	4603      	mov	r3, r0
 801be64:	80fb      	strh	r3, [r7, #6]
 801be66:	460b      	mov	r3, r1
 801be68:	717b      	strb	r3, [r7, #5]
 801be6a:	4613      	mov	r3, r2
 801be6c:	713b      	strb	r3, [r7, #4]
    h = (uint32_t)((uint32_t)h * 255) / 360;
 801be6e:	88fa      	ldrh	r2, [r7, #6]
 801be70:	4613      	mov	r3, r2
 801be72:	021b      	lsls	r3, r3, #8
 801be74:	1a9b      	subs	r3, r3, r2
 801be76:	08db      	lsrs	r3, r3, #3
 801be78:	4a55      	ldr	r2, [pc, #340]	; (801bfd0 <lv_color_hsv_to_rgb+0x174>)
 801be7a:	fba2 2303 	umull	r2, r3, r2, r3
 801be7e:	089b      	lsrs	r3, r3, #2
 801be80:	80fb      	strh	r3, [r7, #6]
    s = (uint16_t)((uint16_t)s * 255) / 100;
 801be82:	797b      	ldrb	r3, [r7, #5]
 801be84:	b29b      	uxth	r3, r3
 801be86:	461a      	mov	r2, r3
 801be88:	0212      	lsls	r2, r2, #8
 801be8a:	1ad3      	subs	r3, r2, r3
 801be8c:	b29b      	uxth	r3, r3
 801be8e:	4a51      	ldr	r2, [pc, #324]	; (801bfd4 <lv_color_hsv_to_rgb+0x178>)
 801be90:	fba2 2303 	umull	r2, r3, r2, r3
 801be94:	095b      	lsrs	r3, r3, #5
 801be96:	b29b      	uxth	r3, r3
 801be98:	717b      	strb	r3, [r7, #5]
    v = (uint16_t)((uint16_t)v * 255) / 100;
 801be9a:	793b      	ldrb	r3, [r7, #4]
 801be9c:	b29b      	uxth	r3, r3
 801be9e:	461a      	mov	r2, r3
 801bea0:	0212      	lsls	r2, r2, #8
 801bea2:	1ad3      	subs	r3, r2, r3
 801bea4:	b29b      	uxth	r3, r3
 801bea6:	4a4b      	ldr	r2, [pc, #300]	; (801bfd4 <lv_color_hsv_to_rgb+0x178>)
 801bea8:	fba2 2303 	umull	r2, r3, r2, r3
 801beac:	095b      	lsrs	r3, r3, #5
 801beae:	b29b      	uxth	r3, r3
 801beb0:	713b      	strb	r3, [r7, #4]

    uint8_t r, g, b;

    uint8_t region, remainder, p, q, t;

    if(s == 0) {
 801beb2:	797b      	ldrb	r3, [r7, #5]
 801beb4:	2b00      	cmp	r3, #0
 801beb6:	d10d      	bne.n	801bed4 <lv_color_hsv_to_rgb+0x78>
        r = v;
 801beb8:	793b      	ldrb	r3, [r7, #4]
 801beba:	75fb      	strb	r3, [r7, #23]
        g = v;
 801bebc:	793b      	ldrb	r3, [r7, #4]
 801bebe:	75bb      	strb	r3, [r7, #22]
        b = v;
 801bec0:	793b      	ldrb	r3, [r7, #4]
 801bec2:	757b      	strb	r3, [r7, #21]
        return lv_color_make(v, v, v);
 801bec4:	793a      	ldrb	r2, [r7, #4]
 801bec6:	7939      	ldrb	r1, [r7, #4]
 801bec8:	793b      	ldrb	r3, [r7, #4]
 801beca:	4618      	mov	r0, r3
 801becc:	f7ff ff98 	bl	801be00 <lv_color_make>
 801bed0:	4603      	mov	r3, r0
 801bed2:	e078      	b.n	801bfc6 <lv_color_hsv_to_rgb+0x16a>
    }

    region    = h / 43;
 801bed4:	88fb      	ldrh	r3, [r7, #6]
 801bed6:	4a40      	ldr	r2, [pc, #256]	; (801bfd8 <lv_color_hsv_to_rgb+0x17c>)
 801bed8:	fba2 2303 	umull	r2, r3, r2, r3
 801bedc:	08db      	lsrs	r3, r3, #3
 801bede:	b29b      	uxth	r3, r3
 801bee0:	753b      	strb	r3, [r7, #20]
    remainder = (h - (region * 43)) * 6;
 801bee2:	88fa      	ldrh	r2, [r7, #6]
 801bee4:	7d3b      	ldrb	r3, [r7, #20]
 801bee6:	f06f 012a 	mvn.w	r1, #42	; 0x2a
 801beea:	fb01 f303 	mul.w	r3, r1, r3
 801beee:	4413      	add	r3, r2
 801bef0:	b2db      	uxtb	r3, r3
 801bef2:	461a      	mov	r2, r3
 801bef4:	0052      	lsls	r2, r2, #1
 801bef6:	4413      	add	r3, r2
 801bef8:	005b      	lsls	r3, r3, #1
 801befa:	74fb      	strb	r3, [r7, #19]

    p = (v * (255 - s)) >> 8;
 801befc:	793b      	ldrb	r3, [r7, #4]
 801befe:	797a      	ldrb	r2, [r7, #5]
 801bf00:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 801bf04:	fb02 f303 	mul.w	r3, r2, r3
 801bf08:	121b      	asrs	r3, r3, #8
 801bf0a:	74bb      	strb	r3, [r7, #18]
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
 801bf0c:	793b      	ldrb	r3, [r7, #4]
 801bf0e:	797a      	ldrb	r2, [r7, #5]
 801bf10:	7cf9      	ldrb	r1, [r7, #19]
 801bf12:	fb01 f202 	mul.w	r2, r1, r2
 801bf16:	1212      	asrs	r2, r2, #8
 801bf18:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 801bf1c:	fb02 f303 	mul.w	r3, r2, r3
 801bf20:	121b      	asrs	r3, r3, #8
 801bf22:	747b      	strb	r3, [r7, #17]
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
 801bf24:	793b      	ldrb	r3, [r7, #4]
 801bf26:	797a      	ldrb	r2, [r7, #5]
 801bf28:	7cf9      	ldrb	r1, [r7, #19]
 801bf2a:	f1c1 01ff 	rsb	r1, r1, #255	; 0xff
 801bf2e:	fb01 f202 	mul.w	r2, r1, r2
 801bf32:	1212      	asrs	r2, r2, #8
 801bf34:	f1c2 02ff 	rsb	r2, r2, #255	; 0xff
 801bf38:	fb02 f303 	mul.w	r3, r2, r3
 801bf3c:	121b      	asrs	r3, r3, #8
 801bf3e:	743b      	strb	r3, [r7, #16]

    switch(region) {
 801bf40:	7d3b      	ldrb	r3, [r7, #20]
 801bf42:	2b04      	cmp	r3, #4
 801bf44:	d82f      	bhi.n	801bfa6 <lv_color_hsv_to_rgb+0x14a>
 801bf46:	a201      	add	r2, pc, #4	; (adr r2, 801bf4c <lv_color_hsv_to_rgb+0xf0>)
 801bf48:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801bf4c:	0801bf61 	.word	0x0801bf61
 801bf50:	0801bf6f 	.word	0x0801bf6f
 801bf54:	0801bf7d 	.word	0x0801bf7d
 801bf58:	0801bf8b 	.word	0x0801bf8b
 801bf5c:	0801bf99 	.word	0x0801bf99
        case 0:
            r = v;
 801bf60:	793b      	ldrb	r3, [r7, #4]
 801bf62:	75fb      	strb	r3, [r7, #23]
            g = t;
 801bf64:	7c3b      	ldrb	r3, [r7, #16]
 801bf66:	75bb      	strb	r3, [r7, #22]
            b = p;
 801bf68:	7cbb      	ldrb	r3, [r7, #18]
 801bf6a:	757b      	strb	r3, [r7, #21]
            break;
 801bf6c:	e022      	b.n	801bfb4 <lv_color_hsv_to_rgb+0x158>
        case 1:
            r = q;
 801bf6e:	7c7b      	ldrb	r3, [r7, #17]
 801bf70:	75fb      	strb	r3, [r7, #23]
            g = v;
 801bf72:	793b      	ldrb	r3, [r7, #4]
 801bf74:	75bb      	strb	r3, [r7, #22]
            b = p;
 801bf76:	7cbb      	ldrb	r3, [r7, #18]
 801bf78:	757b      	strb	r3, [r7, #21]
            break;
 801bf7a:	e01b      	b.n	801bfb4 <lv_color_hsv_to_rgb+0x158>
        case 2:
            r = p;
 801bf7c:	7cbb      	ldrb	r3, [r7, #18]
 801bf7e:	75fb      	strb	r3, [r7, #23]
            g = v;
 801bf80:	793b      	ldrb	r3, [r7, #4]
 801bf82:	75bb      	strb	r3, [r7, #22]
            b = t;
 801bf84:	7c3b      	ldrb	r3, [r7, #16]
 801bf86:	757b      	strb	r3, [r7, #21]
            break;
 801bf88:	e014      	b.n	801bfb4 <lv_color_hsv_to_rgb+0x158>
        case 3:
            r = p;
 801bf8a:	7cbb      	ldrb	r3, [r7, #18]
 801bf8c:	75fb      	strb	r3, [r7, #23]
            g = q;
 801bf8e:	7c7b      	ldrb	r3, [r7, #17]
 801bf90:	75bb      	strb	r3, [r7, #22]
            b = v;
 801bf92:	793b      	ldrb	r3, [r7, #4]
 801bf94:	757b      	strb	r3, [r7, #21]
            break;
 801bf96:	e00d      	b.n	801bfb4 <lv_color_hsv_to_rgb+0x158>
        case 4:
            r = t;
 801bf98:	7c3b      	ldrb	r3, [r7, #16]
 801bf9a:	75fb      	strb	r3, [r7, #23]
            g = p;
 801bf9c:	7cbb      	ldrb	r3, [r7, #18]
 801bf9e:	75bb      	strb	r3, [r7, #22]
            b = v;
 801bfa0:	793b      	ldrb	r3, [r7, #4]
 801bfa2:	757b      	strb	r3, [r7, #21]
            break;
 801bfa4:	e006      	b.n	801bfb4 <lv_color_hsv_to_rgb+0x158>
        default:
            r = v;
 801bfa6:	793b      	ldrb	r3, [r7, #4]
 801bfa8:	75fb      	strb	r3, [r7, #23]
            g = p;
 801bfaa:	7cbb      	ldrb	r3, [r7, #18]
 801bfac:	75bb      	strb	r3, [r7, #22]
            b = q;
 801bfae:	7c7b      	ldrb	r3, [r7, #17]
 801bfb0:	757b      	strb	r3, [r7, #21]
            break;
 801bfb2:	bf00      	nop
    }

    lv_color_t result = lv_color_make(r, g, b);
 801bfb4:	7d7a      	ldrb	r2, [r7, #21]
 801bfb6:	7db9      	ldrb	r1, [r7, #22]
 801bfb8:	7dfb      	ldrb	r3, [r7, #23]
 801bfba:	4618      	mov	r0, r3
 801bfbc:	f7ff ff20 	bl	801be00 <lv_color_make>
 801bfc0:	4603      	mov	r3, r0
 801bfc2:	81bb      	strh	r3, [r7, #12]
    return result;
 801bfc4:	89bb      	ldrh	r3, [r7, #12]
}
 801bfc6:	4618      	mov	r0, r3
 801bfc8:	3718      	adds	r7, #24
 801bfca:	46bd      	mov	sp, r7
 801bfcc:	bd80      	pop	{r7, pc}
 801bfce:	bf00      	nop
 801bfd0:	16c16c17 	.word	0x16c16c17
 801bfd4:	51eb851f 	.word	0x51eb851f
 801bfd8:	2fa0be83 	.word	0x2fa0be83

0801bfdc <lv_fs_init>:

/**
 * Initialize the File system interface
 */
void lv_fs_init(void)
{
 801bfdc:	b580      	push	{r7, lr}
 801bfde:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_drv_ll), sizeof(lv_fs_drv_t));
 801bfe0:	2148      	movs	r1, #72	; 0x48
 801bfe2:	4802      	ldr	r0, [pc, #8]	; (801bfec <lv_fs_init+0x10>)
 801bfe4:	f000 f988 	bl	801c2f8 <lv_ll_init>
}
 801bfe8:	bf00      	nop
 801bfea:	bd80      	pop	{r7, pc}
 801bfec:	2000df78 	.word	0x2000df78

0801bff0 <lv_fs_open>:
 * @param path path to the file beginning with the driver letter (e.g. S:/folder/file.txt)
 * @param mode read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_open(lv_fs_file_t * file_p, const char * path, lv_fs_mode_t mode)
{
 801bff0:	b590      	push	{r4, r7, lr}
 801bff2:	b089      	sub	sp, #36	; 0x24
 801bff4:	af00      	add	r7, sp, #0
 801bff6:	60f8      	str	r0, [r7, #12]
 801bff8:	60b9      	str	r1, [r7, #8]
 801bffa:	4613      	mov	r3, r2
 801bffc:	71fb      	strb	r3, [r7, #7]
    file_p->drv    = NULL;
 801bffe:	68fb      	ldr	r3, [r7, #12]
 801c000:	2200      	movs	r2, #0
 801c002:	605a      	str	r2, [r3, #4]
    file_p->file_d = NULL;
 801c004:	68fb      	ldr	r3, [r7, #12]
 801c006:	2200      	movs	r2, #0
 801c008:	601a      	str	r2, [r3, #0]

    if(path == NULL) return LV_FS_RES_INV_PARAM;
 801c00a:	68bb      	ldr	r3, [r7, #8]
 801c00c:	2b00      	cmp	r3, #0
 801c00e:	d101      	bne.n	801c014 <lv_fs_open+0x24>
 801c010:	230b      	movs	r3, #11
 801c012:	e06f      	b.n	801c0f4 <lv_fs_open+0x104>

    char letter = path[0];
 801c014:	68bb      	ldr	r3, [r7, #8]
 801c016:	781b      	ldrb	r3, [r3, #0]
 801c018:	77fb      	strb	r3, [r7, #31]

    file_p->drv = lv_fs_get_drv(letter);
 801c01a:	7ffb      	ldrb	r3, [r7, #31]
 801c01c:	4618      	mov	r0, r3
 801c01e:	f000 f94b 	bl	801c2b8 <lv_fs_get_drv>
 801c022:	4602      	mov	r2, r0
 801c024:	68fb      	ldr	r3, [r7, #12]
 801c026:	605a      	str	r2, [r3, #4]

    if(file_p->drv == NULL) {
 801c028:	68fb      	ldr	r3, [r7, #12]
 801c02a:	685b      	ldr	r3, [r3, #4]
 801c02c:	2b00      	cmp	r3, #0
 801c02e:	d104      	bne.n	801c03a <lv_fs_open+0x4a>
        file_p->file_d = NULL;
 801c030:	68fb      	ldr	r3, [r7, #12]
 801c032:	2200      	movs	r2, #0
 801c034:	601a      	str	r2, [r3, #0]
        return LV_FS_RES_NOT_EX;
 801c036:	2303      	movs	r3, #3
 801c038:	e05c      	b.n	801c0f4 <lv_fs_open+0x104>
    }

    if(file_p->drv->ready_cb != NULL) {
 801c03a:	68fb      	ldr	r3, [r7, #12]
 801c03c:	685b      	ldr	r3, [r3, #4]
 801c03e:	689b      	ldr	r3, [r3, #8]
 801c040:	2b00      	cmp	r3, #0
 801c042:	d014      	beq.n	801c06e <lv_fs_open+0x7e>
        if(file_p->drv->ready_cb(file_p->drv) == false) {
 801c044:	68fb      	ldr	r3, [r7, #12]
 801c046:	685b      	ldr	r3, [r3, #4]
 801c048:	689b      	ldr	r3, [r3, #8]
 801c04a:	68fa      	ldr	r2, [r7, #12]
 801c04c:	6852      	ldr	r2, [r2, #4]
 801c04e:	4610      	mov	r0, r2
 801c050:	4798      	blx	r3
 801c052:	4603      	mov	r3, r0
 801c054:	f083 0301 	eor.w	r3, r3, #1
 801c058:	b2db      	uxtb	r3, r3
 801c05a:	2b00      	cmp	r3, #0
 801c05c:	d007      	beq.n	801c06e <lv_fs_open+0x7e>
            file_p->drv    = NULL;
 801c05e:	68fb      	ldr	r3, [r7, #12]
 801c060:	2200      	movs	r2, #0
 801c062:	605a      	str	r2, [r3, #4]
            file_p->file_d = NULL;
 801c064:	68fb      	ldr	r3, [r7, #12]
 801c066:	2200      	movs	r2, #0
 801c068:	601a      	str	r2, [r3, #0]
            return LV_FS_RES_HW_ERR;
 801c06a:	2301      	movs	r3, #1
 801c06c:	e042      	b.n	801c0f4 <lv_fs_open+0x104>
        }
    }

    file_p->file_d = lv_mem_alloc(file_p->drv->file_size);
 801c06e:	68fb      	ldr	r3, [r7, #12]
 801c070:	685b      	ldr	r3, [r3, #4]
 801c072:	885b      	ldrh	r3, [r3, #2]
 801c074:	4618      	mov	r0, r3
 801c076:	f000 fc0d 	bl	801c894 <lv_mem_alloc>
 801c07a:	4602      	mov	r2, r0
 801c07c:	68fb      	ldr	r3, [r7, #12]
 801c07e:	601a      	str	r2, [r3, #0]
    lv_mem_assert(file_p->file_d);
 801c080:	68fb      	ldr	r3, [r7, #12]
 801c082:	681b      	ldr	r3, [r3, #0]
 801c084:	2b00      	cmp	r3, #0
 801c086:	d106      	bne.n	801c096 <lv_fs_open+0xa6>
 801c088:	4b1c      	ldr	r3, [pc, #112]	; (801c0fc <lv_fs_open+0x10c>)
 801c08a:	226f      	movs	r2, #111	; 0x6f
 801c08c:	491c      	ldr	r1, [pc, #112]	; (801c100 <lv_fs_open+0x110>)
 801c08e:	2003      	movs	r0, #3
 801c090:	f000 fbbc 	bl	801c80c <lv_log_add>
 801c094:	e7fe      	b.n	801c094 <lv_fs_open+0xa4>
    if(file_p->file_d == NULL) {
 801c096:	68fb      	ldr	r3, [r7, #12]
 801c098:	681b      	ldr	r3, [r3, #0]
 801c09a:	2b00      	cmp	r3, #0
 801c09c:	d104      	bne.n	801c0a8 <lv_fs_open+0xb8>
        file_p->drv = NULL;
 801c09e:	68fb      	ldr	r3, [r7, #12]
 801c0a0:	2200      	movs	r2, #0
 801c0a2:	605a      	str	r2, [r3, #4]
        return LV_FS_RES_OUT_OF_MEM; /* Out of memory */
 801c0a4:	230a      	movs	r3, #10
 801c0a6:	e025      	b.n	801c0f4 <lv_fs_open+0x104>
    }

    if(file_p->drv->open_cb == NULL) {
 801c0a8:	68fb      	ldr	r3, [r7, #12]
 801c0aa:	685b      	ldr	r3, [r3, #4]
 801c0ac:	68db      	ldr	r3, [r3, #12]
 801c0ae:	2b00      	cmp	r3, #0
 801c0b0:	d101      	bne.n	801c0b6 <lv_fs_open+0xc6>
        return LV_FS_RES_NOT_IMP;
 801c0b2:	2309      	movs	r3, #9
 801c0b4:	e01e      	b.n	801c0f4 <lv_fs_open+0x104>
    }

    const char * real_path = lv_fs_get_real_path(path);
 801c0b6:	68b8      	ldr	r0, [r7, #8]
 801c0b8:	f000 f8dc 	bl	801c274 <lv_fs_get_real_path>
 801c0bc:	61b8      	str	r0, [r7, #24]
    lv_fs_res_t res        = file_p->drv->open_cb(file_p->drv, file_p->file_d, real_path, mode);
 801c0be:	68fb      	ldr	r3, [r7, #12]
 801c0c0:	685b      	ldr	r3, [r3, #4]
 801c0c2:	68dc      	ldr	r4, [r3, #12]
 801c0c4:	68fb      	ldr	r3, [r7, #12]
 801c0c6:	6858      	ldr	r0, [r3, #4]
 801c0c8:	68fb      	ldr	r3, [r7, #12]
 801c0ca:	6819      	ldr	r1, [r3, #0]
 801c0cc:	79fb      	ldrb	r3, [r7, #7]
 801c0ce:	69ba      	ldr	r2, [r7, #24]
 801c0d0:	47a0      	blx	r4
 801c0d2:	4603      	mov	r3, r0
 801c0d4:	75fb      	strb	r3, [r7, #23]

    if(res != LV_FS_RES_OK) {
 801c0d6:	7dfb      	ldrb	r3, [r7, #23]
 801c0d8:	2b00      	cmp	r3, #0
 801c0da:	d00a      	beq.n	801c0f2 <lv_fs_open+0x102>
        lv_mem_free(file_p->file_d);
 801c0dc:	68fb      	ldr	r3, [r7, #12]
 801c0de:	681b      	ldr	r3, [r3, #0]
 801c0e0:	4618      	mov	r0, r3
 801c0e2:	f000 fc1f 	bl	801c924 <lv_mem_free>
        file_p->file_d = NULL;
 801c0e6:	68fb      	ldr	r3, [r7, #12]
 801c0e8:	2200      	movs	r2, #0
 801c0ea:	601a      	str	r2, [r3, #0]
        file_p->drv    = NULL;
 801c0ec:	68fb      	ldr	r3, [r7, #12]
 801c0ee:	2200      	movs	r2, #0
 801c0f0:	605a      	str	r2, [r3, #4]
    }

    return res;
 801c0f2:	7dfb      	ldrb	r3, [r7, #23]
}
 801c0f4:	4618      	mov	r0, r3
 801c0f6:	3724      	adds	r7, #36	; 0x24
 801c0f8:	46bd      	mov	sp, r7
 801c0fa:	bd90      	pop	{r4, r7, pc}
 801c0fc:	08028e74 	.word	0x08028e74
 801c100:	08028e84 	.word	0x08028e84

0801c104 <lv_fs_close>:
 * Close an already opened file
 * @param file_p pointer to a lv_fs_file_t variable
 * @return  LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_close(lv_fs_file_t * file_p)
{
 801c104:	b580      	push	{r7, lr}
 801c106:	b084      	sub	sp, #16
 801c108:	af00      	add	r7, sp, #0
 801c10a:	6078      	str	r0, [r7, #4]
    if(file_p->drv == NULL) {
 801c10c:	687b      	ldr	r3, [r7, #4]
 801c10e:	685b      	ldr	r3, [r3, #4]
 801c110:	2b00      	cmp	r3, #0
 801c112:	d101      	bne.n	801c118 <lv_fs_close+0x14>
        return LV_FS_RES_INV_PARAM;
 801c114:	230b      	movs	r3, #11
 801c116:	e020      	b.n	801c15a <lv_fs_close+0x56>
    }

    if(file_p->drv->close_cb == NULL) {
 801c118:	687b      	ldr	r3, [r7, #4]
 801c11a:	685b      	ldr	r3, [r3, #4]
 801c11c:	691b      	ldr	r3, [r3, #16]
 801c11e:	2b00      	cmp	r3, #0
 801c120:	d101      	bne.n	801c126 <lv_fs_close+0x22>
        return LV_FS_RES_NOT_IMP;
 801c122:	2309      	movs	r3, #9
 801c124:	e019      	b.n	801c15a <lv_fs_close+0x56>
    }

    lv_fs_res_t res = file_p->drv->close_cb(file_p->drv, file_p->file_d);
 801c126:	687b      	ldr	r3, [r7, #4]
 801c128:	685b      	ldr	r3, [r3, #4]
 801c12a:	691b      	ldr	r3, [r3, #16]
 801c12c:	687a      	ldr	r2, [r7, #4]
 801c12e:	6850      	ldr	r0, [r2, #4]
 801c130:	687a      	ldr	r2, [r7, #4]
 801c132:	6812      	ldr	r2, [r2, #0]
 801c134:	4611      	mov	r1, r2
 801c136:	4798      	blx	r3
 801c138:	4603      	mov	r3, r0
 801c13a:	73fb      	strb	r3, [r7, #15]

    lv_mem_free(file_p->file_d); /*Clean up*/
 801c13c:	687b      	ldr	r3, [r7, #4]
 801c13e:	681b      	ldr	r3, [r3, #0]
 801c140:	4618      	mov	r0, r3
 801c142:	f000 fbef 	bl	801c924 <lv_mem_free>
    file_p->file_d = NULL;
 801c146:	687b      	ldr	r3, [r7, #4]
 801c148:	2200      	movs	r2, #0
 801c14a:	601a      	str	r2, [r3, #0]
    file_p->drv    = NULL;
 801c14c:	687b      	ldr	r3, [r7, #4]
 801c14e:	2200      	movs	r2, #0
 801c150:	605a      	str	r2, [r3, #4]
    file_p->file_d = NULL;
 801c152:	687b      	ldr	r3, [r7, #4]
 801c154:	2200      	movs	r2, #0
 801c156:	601a      	str	r2, [r3, #0]

    return res;
 801c158:	7bfb      	ldrb	r3, [r7, #15]
}
 801c15a:	4618      	mov	r0, r3
 801c15c:	3710      	adds	r7, #16
 801c15e:	46bd      	mov	sp, r7
 801c160:	bd80      	pop	{r7, pc}

0801c162 <lv_fs_read>:
 * @param btr Bytes To Read
 * @param br the number of real read bytes (Bytes Read). NULL if unused.
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_read(lv_fs_file_t * file_p, void * buf, uint32_t btr, uint32_t * br)
{
 801c162:	b590      	push	{r4, r7, lr}
 801c164:	b089      	sub	sp, #36	; 0x24
 801c166:	af02      	add	r7, sp, #8
 801c168:	60f8      	str	r0, [r7, #12]
 801c16a:	60b9      	str	r1, [r7, #8]
 801c16c:	607a      	str	r2, [r7, #4]
 801c16e:	603b      	str	r3, [r7, #0]
    if(br != NULL) *br = 0;
 801c170:	683b      	ldr	r3, [r7, #0]
 801c172:	2b00      	cmp	r3, #0
 801c174:	d002      	beq.n	801c17c <lv_fs_read+0x1a>
 801c176:	683b      	ldr	r3, [r7, #0]
 801c178:	2200      	movs	r2, #0
 801c17a:	601a      	str	r2, [r3, #0]
    if(file_p->drv == NULL) return LV_FS_RES_INV_PARAM;
 801c17c:	68fb      	ldr	r3, [r7, #12]
 801c17e:	685b      	ldr	r3, [r3, #4]
 801c180:	2b00      	cmp	r3, #0
 801c182:	d101      	bne.n	801c188 <lv_fs_read+0x26>
 801c184:	230b      	movs	r3, #11
 801c186:	e01e      	b.n	801c1c6 <lv_fs_read+0x64>
    if(file_p->drv->read_cb == NULL) return LV_FS_RES_NOT_IMP;
 801c188:	68fb      	ldr	r3, [r7, #12]
 801c18a:	685b      	ldr	r3, [r3, #4]
 801c18c:	699b      	ldr	r3, [r3, #24]
 801c18e:	2b00      	cmp	r3, #0
 801c190:	d101      	bne.n	801c196 <lv_fs_read+0x34>
 801c192:	2309      	movs	r3, #9
 801c194:	e017      	b.n	801c1c6 <lv_fs_read+0x64>

    uint32_t br_tmp = 0;
 801c196:	2300      	movs	r3, #0
 801c198:	613b      	str	r3, [r7, #16]
    lv_fs_res_t res = file_p->drv->read_cb(file_p->drv, file_p->file_d, buf, btr, &br_tmp);
 801c19a:	68fb      	ldr	r3, [r7, #12]
 801c19c:	685b      	ldr	r3, [r3, #4]
 801c19e:	699c      	ldr	r4, [r3, #24]
 801c1a0:	68fb      	ldr	r3, [r7, #12]
 801c1a2:	6858      	ldr	r0, [r3, #4]
 801c1a4:	68fb      	ldr	r3, [r7, #12]
 801c1a6:	6819      	ldr	r1, [r3, #0]
 801c1a8:	f107 0310 	add.w	r3, r7, #16
 801c1ac:	9300      	str	r3, [sp, #0]
 801c1ae:	687b      	ldr	r3, [r7, #4]
 801c1b0:	68ba      	ldr	r2, [r7, #8]
 801c1b2:	47a0      	blx	r4
 801c1b4:	4603      	mov	r3, r0
 801c1b6:	75fb      	strb	r3, [r7, #23]
    if(br != NULL) *br = br_tmp;
 801c1b8:	683b      	ldr	r3, [r7, #0]
 801c1ba:	2b00      	cmp	r3, #0
 801c1bc:	d002      	beq.n	801c1c4 <lv_fs_read+0x62>
 801c1be:	693a      	ldr	r2, [r7, #16]
 801c1c0:	683b      	ldr	r3, [r7, #0]
 801c1c2:	601a      	str	r2, [r3, #0]

    return res;
 801c1c4:	7dfb      	ldrb	r3, [r7, #23]
}
 801c1c6:	4618      	mov	r0, r3
 801c1c8:	371c      	adds	r7, #28
 801c1ca:	46bd      	mov	sp, r7
 801c1cc:	bd90      	pop	{r4, r7, pc}

0801c1ce <lv_fs_seek>:
 * @param file_p pointer to a lv_fs_file_t variable
 * @param pos the new position expressed in bytes index (0: start of file)
 * @return LV_FS_RES_OK or any error from lv_fs_res_t enum
 */
lv_fs_res_t lv_fs_seek(lv_fs_file_t * file_p, uint32_t pos)
{
 801c1ce:	b580      	push	{r7, lr}
 801c1d0:	b084      	sub	sp, #16
 801c1d2:	af00      	add	r7, sp, #0
 801c1d4:	6078      	str	r0, [r7, #4]
 801c1d6:	6039      	str	r1, [r7, #0]
    if(file_p->drv == NULL) {
 801c1d8:	687b      	ldr	r3, [r7, #4]
 801c1da:	685b      	ldr	r3, [r3, #4]
 801c1dc:	2b00      	cmp	r3, #0
 801c1de:	d101      	bne.n	801c1e4 <lv_fs_seek+0x16>
        return LV_FS_RES_INV_PARAM;
 801c1e0:	230b      	movs	r3, #11
 801c1e2:	e012      	b.n	801c20a <lv_fs_seek+0x3c>
    }

    if(file_p->drv->seek_cb == NULL) {
 801c1e4:	687b      	ldr	r3, [r7, #4]
 801c1e6:	685b      	ldr	r3, [r3, #4]
 801c1e8:	6a1b      	ldr	r3, [r3, #32]
 801c1ea:	2b00      	cmp	r3, #0
 801c1ec:	d101      	bne.n	801c1f2 <lv_fs_seek+0x24>
        return LV_FS_RES_NOT_IMP;
 801c1ee:	2309      	movs	r3, #9
 801c1f0:	e00b      	b.n	801c20a <lv_fs_seek+0x3c>
    }

    lv_fs_res_t res = file_p->drv->seek_cb(file_p->drv, file_p->file_d, pos);
 801c1f2:	687b      	ldr	r3, [r7, #4]
 801c1f4:	685b      	ldr	r3, [r3, #4]
 801c1f6:	6a1b      	ldr	r3, [r3, #32]
 801c1f8:	687a      	ldr	r2, [r7, #4]
 801c1fa:	6850      	ldr	r0, [r2, #4]
 801c1fc:	687a      	ldr	r2, [r7, #4]
 801c1fe:	6811      	ldr	r1, [r2, #0]
 801c200:	683a      	ldr	r2, [r7, #0]
 801c202:	4798      	blx	r3
 801c204:	4603      	mov	r3, r0
 801c206:	73fb      	strb	r3, [r7, #15]

    return res;
 801c208:	7bfb      	ldrb	r3, [r7, #15]
}
 801c20a:	4618      	mov	r0, r3
 801c20c:	3710      	adds	r7, #16
 801c20e:	46bd      	mov	sp, r7
 801c210:	bd80      	pop	{r7, pc}
	...

0801c214 <lv_fs_get_ext>:
 * Return with the extension of the filename
 * @param fn string with a filename
 * @return pointer to the beginning extension or empty string if no extension
 */
const char * lv_fs_get_ext(const char * fn)
{
 801c214:	b580      	push	{r7, lr}
 801c216:	b084      	sub	sp, #16
 801c218:	af00      	add	r7, sp, #0
 801c21a:	6078      	str	r0, [r7, #4]
    uint16_t i;
    for(i = strlen(fn); i > 0; i--) {
 801c21c:	6878      	ldr	r0, [r7, #4]
 801c21e:	f7e4 f801 	bl	8000224 <strlen>
 801c222:	4603      	mov	r3, r0
 801c224:	81fb      	strh	r3, [r7, #14]
 801c226:	e01b      	b.n	801c260 <lv_fs_get_ext+0x4c>
        if(fn[i] == '.') {
 801c228:	89fb      	ldrh	r3, [r7, #14]
 801c22a:	687a      	ldr	r2, [r7, #4]
 801c22c:	4413      	add	r3, r2
 801c22e:	781b      	ldrb	r3, [r3, #0]
 801c230:	2b2e      	cmp	r3, #46	; 0x2e
 801c232:	d104      	bne.n	801c23e <lv_fs_get_ext+0x2a>
            return &fn[i + 1];
 801c234:	89fb      	ldrh	r3, [r7, #14]
 801c236:	3301      	adds	r3, #1
 801c238:	687a      	ldr	r2, [r7, #4]
 801c23a:	4413      	add	r3, r2
 801c23c:	e014      	b.n	801c268 <lv_fs_get_ext+0x54>
        } else if(fn[i] == '/' || fn[i] == '\\') {
 801c23e:	89fb      	ldrh	r3, [r7, #14]
 801c240:	687a      	ldr	r2, [r7, #4]
 801c242:	4413      	add	r3, r2
 801c244:	781b      	ldrb	r3, [r3, #0]
 801c246:	2b2f      	cmp	r3, #47	; 0x2f
 801c248:	d005      	beq.n	801c256 <lv_fs_get_ext+0x42>
 801c24a:	89fb      	ldrh	r3, [r7, #14]
 801c24c:	687a      	ldr	r2, [r7, #4]
 801c24e:	4413      	add	r3, r2
 801c250:	781b      	ldrb	r3, [r3, #0]
 801c252:	2b5c      	cmp	r3, #92	; 0x5c
 801c254:	d101      	bne.n	801c25a <lv_fs_get_ext+0x46>
            return ""; /*No extension if a '\' or '/' found*/
 801c256:	4b06      	ldr	r3, [pc, #24]	; (801c270 <lv_fs_get_ext+0x5c>)
 801c258:	e006      	b.n	801c268 <lv_fs_get_ext+0x54>
    for(i = strlen(fn); i > 0; i--) {
 801c25a:	89fb      	ldrh	r3, [r7, #14]
 801c25c:	3b01      	subs	r3, #1
 801c25e:	81fb      	strh	r3, [r7, #14]
 801c260:	89fb      	ldrh	r3, [r7, #14]
 801c262:	2b00      	cmp	r3, #0
 801c264:	d1e0      	bne.n	801c228 <lv_fs_get_ext+0x14>
        }
    }

    return ""; /*Empty string if no '.' in the file name. */
 801c266:	4b02      	ldr	r3, [pc, #8]	; (801c270 <lv_fs_get_ext+0x5c>)
}
 801c268:	4618      	mov	r0, r3
 801c26a:	3710      	adds	r7, #16
 801c26c:	46bd      	mov	sp, r7
 801c26e:	bd80      	pop	{r7, pc}
 801c270:	08028ea0 	.word	0x08028ea0

0801c274 <lv_fs_get_real_path>:
 * Leave the driver letters and / or \ letters from beginning of the path
 * @param path path string (E.g. S:/folder/file.txt)
 * @return pointer to the beginning of the real path (E.g. folder/file.txt)
 */
static const char * lv_fs_get_real_path(const char * path)
{
 801c274:	b480      	push	{r7}
 801c276:	b083      	sub	sp, #12
 801c278:	af00      	add	r7, sp, #0
 801c27a:	6078      	str	r0, [r7, #4]
    /* Example path: "S:/folder/file.txt"
     * Leave the letter and the : / \ characters*/

    path++; /*Ignore the driver letter*/
 801c27c:	687b      	ldr	r3, [r7, #4]
 801c27e:	3301      	adds	r3, #1
 801c280:	607b      	str	r3, [r7, #4]

    while(*path != '\0') {
 801c282:	e00e      	b.n	801c2a2 <lv_fs_get_real_path+0x2e>
        if(*path == ':' || *path == '\\' || *path == '/') {
 801c284:	687b      	ldr	r3, [r7, #4]
 801c286:	781b      	ldrb	r3, [r3, #0]
 801c288:	2b3a      	cmp	r3, #58	; 0x3a
 801c28a:	d007      	beq.n	801c29c <lv_fs_get_real_path+0x28>
 801c28c:	687b      	ldr	r3, [r7, #4]
 801c28e:	781b      	ldrb	r3, [r3, #0]
 801c290:	2b5c      	cmp	r3, #92	; 0x5c
 801c292:	d003      	beq.n	801c29c <lv_fs_get_real_path+0x28>
 801c294:	687b      	ldr	r3, [r7, #4]
 801c296:	781b      	ldrb	r3, [r3, #0]
 801c298:	2b2f      	cmp	r3, #47	; 0x2f
 801c29a:	d106      	bne.n	801c2aa <lv_fs_get_real_path+0x36>
            path++;
 801c29c:	687b      	ldr	r3, [r7, #4]
 801c29e:	3301      	adds	r3, #1
 801c2a0:	607b      	str	r3, [r7, #4]
    while(*path != '\0') {
 801c2a2:	687b      	ldr	r3, [r7, #4]
 801c2a4:	781b      	ldrb	r3, [r3, #0]
 801c2a6:	2b00      	cmp	r3, #0
 801c2a8:	d1ec      	bne.n	801c284 <lv_fs_get_real_path+0x10>
        } else {
            break;
        }
    }

    return path;
 801c2aa:	687b      	ldr	r3, [r7, #4]
}
 801c2ac:	4618      	mov	r0, r3
 801c2ae:	370c      	adds	r7, #12
 801c2b0:	46bd      	mov	sp, r7
 801c2b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c2b6:	4770      	bx	lr

0801c2b8 <lv_fs_get_drv>:
 * Give a pointer to a driver from its letter
 * @param letter the driver letter
 * @return pointer to a driver or NULL if not found
 */
static lv_fs_drv_t * lv_fs_get_drv(char letter)
{
 801c2b8:	b580      	push	{r7, lr}
 801c2ba:	b084      	sub	sp, #16
 801c2bc:	af00      	add	r7, sp, #0
 801c2be:	4603      	mov	r3, r0
 801c2c0:	71fb      	strb	r3, [r7, #7]
    lv_fs_drv_t * drv;

    LV_LL_READ(LV_GC_ROOT(_lv_drv_ll), drv)
 801c2c2:	480c      	ldr	r0, [pc, #48]	; (801c2f4 <lv_fs_get_drv+0x3c>)
 801c2c4:	f000 f99a 	bl	801c5fc <lv_ll_get_head>
 801c2c8:	60f8      	str	r0, [r7, #12]
 801c2ca:	e00b      	b.n	801c2e4 <lv_fs_get_drv+0x2c>
    {
        if(drv->letter == letter) {
 801c2cc:	68fb      	ldr	r3, [r7, #12]
 801c2ce:	781b      	ldrb	r3, [r3, #0]
 801c2d0:	79fa      	ldrb	r2, [r7, #7]
 801c2d2:	429a      	cmp	r2, r3
 801c2d4:	d101      	bne.n	801c2da <lv_fs_get_drv+0x22>
            return drv;
 801c2d6:	68fb      	ldr	r3, [r7, #12]
 801c2d8:	e008      	b.n	801c2ec <lv_fs_get_drv+0x34>
    LV_LL_READ(LV_GC_ROOT(_lv_drv_ll), drv)
 801c2da:	68f9      	ldr	r1, [r7, #12]
 801c2dc:	4805      	ldr	r0, [pc, #20]	; (801c2f4 <lv_fs_get_drv+0x3c>)
 801c2de:	f000 f9b3 	bl	801c648 <lv_ll_get_next>
 801c2e2:	60f8      	str	r0, [r7, #12]
 801c2e4:	68fb      	ldr	r3, [r7, #12]
 801c2e6:	2b00      	cmp	r3, #0
 801c2e8:	d1f0      	bne.n	801c2cc <lv_fs_get_drv+0x14>
        }
    }

    return NULL;
 801c2ea:	2300      	movs	r3, #0
}
 801c2ec:	4618      	mov	r0, r3
 801c2ee:	3710      	adds	r7, #16
 801c2f0:	46bd      	mov	sp, r7
 801c2f2:	bd80      	pop	{r7, pc}
 801c2f4:	2000df78 	.word	0x2000df78

0801c2f8 <lv_ll_init>:
 * Initialize linked list
 * @param ll_dsc pointer to ll_dsc variable
 * @param node_size the size of 1 node in bytes
 */
void lv_ll_init(lv_ll_t * ll_p, uint32_t node_size)
{
 801c2f8:	b480      	push	{r7}
 801c2fa:	b083      	sub	sp, #12
 801c2fc:	af00      	add	r7, sp, #0
 801c2fe:	6078      	str	r0, [r7, #4]
 801c300:	6039      	str	r1, [r7, #0]
    ll_p->head = NULL;
 801c302:	687b      	ldr	r3, [r7, #4]
 801c304:	2200      	movs	r2, #0
 801c306:	605a      	str	r2, [r3, #4]
    ll_p->tail = NULL;
 801c308:	687b      	ldr	r3, [r7, #4]
 801c30a:	2200      	movs	r2, #0
 801c30c:	609a      	str	r2, [r3, #8]
        node_size = node_size & (~0x7);
        node_size += 8;
    }
#else
    /*Round the size up to 4*/
    if(node_size & 0x3) {
 801c30e:	683b      	ldr	r3, [r7, #0]
 801c310:	f003 0303 	and.w	r3, r3, #3
 801c314:	2b00      	cmp	r3, #0
 801c316:	d006      	beq.n	801c326 <lv_ll_init+0x2e>
        node_size = node_size & (~0x3);
 801c318:	683b      	ldr	r3, [r7, #0]
 801c31a:	f023 0303 	bic.w	r3, r3, #3
 801c31e:	603b      	str	r3, [r7, #0]
        node_size += 4;
 801c320:	683b      	ldr	r3, [r7, #0]
 801c322:	3304      	adds	r3, #4
 801c324:	603b      	str	r3, [r7, #0]
    }
#endif

    ll_p->n_size = node_size;
 801c326:	687b      	ldr	r3, [r7, #4]
 801c328:	683a      	ldr	r2, [r7, #0]
 801c32a:	601a      	str	r2, [r3, #0]
}
 801c32c:	bf00      	nop
 801c32e:	370c      	adds	r7, #12
 801c330:	46bd      	mov	sp, r7
 801c332:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c336:	4770      	bx	lr

0801c338 <lv_ll_ins_head>:
 * Add a new head to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new head
 */
void * lv_ll_ins_head(lv_ll_t * ll_p)
{
 801c338:	b580      	push	{r7, lr}
 801c33a:	b084      	sub	sp, #16
 801c33c:	af00      	add	r7, sp, #0
 801c33e:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 801c340:	687b      	ldr	r3, [r7, #4]
 801c342:	681b      	ldr	r3, [r3, #0]
 801c344:	3308      	adds	r3, #8
 801c346:	4618      	mov	r0, r3
 801c348:	f000 faa4 	bl	801c894 <lv_mem_alloc>
 801c34c:	60f8      	str	r0, [r7, #12]

    if(n_new != NULL) {
 801c34e:	68fb      	ldr	r3, [r7, #12]
 801c350:	2b00      	cmp	r3, #0
 801c352:	d020      	beq.n	801c396 <lv_ll_ins_head+0x5e>
        node_set_prev(ll_p, n_new, NULL);       /*No prev. before the new head*/
 801c354:	2200      	movs	r2, #0
 801c356:	68f9      	ldr	r1, [r7, #12]
 801c358:	6878      	ldr	r0, [r7, #4]
 801c35a:	f000 fa08 	bl	801c76e <node_set_prev>
        node_set_next(ll_p, n_new, ll_p->head); /*After new comes the old head*/
 801c35e:	687b      	ldr	r3, [r7, #4]
 801c360:	685b      	ldr	r3, [r3, #4]
 801c362:	461a      	mov	r2, r3
 801c364:	68f9      	ldr	r1, [r7, #12]
 801c366:	6878      	ldr	r0, [r7, #4]
 801c368:	f000 fa27 	bl	801c7ba <node_set_next>

        if(ll_p->head != NULL) { /*If there is old head then before it goes the new*/
 801c36c:	687b      	ldr	r3, [r7, #4]
 801c36e:	685b      	ldr	r3, [r3, #4]
 801c370:	2b00      	cmp	r3, #0
 801c372:	d006      	beq.n	801c382 <lv_ll_ins_head+0x4a>
            node_set_prev(ll_p, ll_p->head, n_new);
 801c374:	687b      	ldr	r3, [r7, #4]
 801c376:	685b      	ldr	r3, [r3, #4]
 801c378:	68fa      	ldr	r2, [r7, #12]
 801c37a:	4619      	mov	r1, r3
 801c37c:	6878      	ldr	r0, [r7, #4]
 801c37e:	f000 f9f6 	bl	801c76e <node_set_prev>
        }

        ll_p->head = n_new;      /*Set the new head in the dsc.*/
 801c382:	687b      	ldr	r3, [r7, #4]
 801c384:	68fa      	ldr	r2, [r7, #12]
 801c386:	605a      	str	r2, [r3, #4]
        if(ll_p->tail == NULL) { /*If there is no tail (1. node) set the tail too*/
 801c388:	687b      	ldr	r3, [r7, #4]
 801c38a:	689b      	ldr	r3, [r3, #8]
 801c38c:	2b00      	cmp	r3, #0
 801c38e:	d102      	bne.n	801c396 <lv_ll_ins_head+0x5e>
            ll_p->tail = n_new;
 801c390:	687b      	ldr	r3, [r7, #4]
 801c392:	68fa      	ldr	r2, [r7, #12]
 801c394:	609a      	str	r2, [r3, #8]
        }
    }

    return n_new;
 801c396:	68fb      	ldr	r3, [r7, #12]
}
 801c398:	4618      	mov	r0, r3
 801c39a:	3710      	adds	r7, #16
 801c39c:	46bd      	mov	sp, r7
 801c39e:	bd80      	pop	{r7, pc}

0801c3a0 <lv_ll_ins_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the new head
 */
void * lv_ll_ins_prev(lv_ll_t * ll_p, void * n_act)
{
 801c3a0:	b580      	push	{r7, lr}
 801c3a2:	b084      	sub	sp, #16
 801c3a4:	af00      	add	r7, sp, #0
 801c3a6:	6078      	str	r0, [r7, #4]
 801c3a8:	6039      	str	r1, [r7, #0]
    lv_ll_node_t * n_new;
    lv_ll_node_t * n_prev;

    if(NULL == ll_p || NULL == n_act) return NULL;
 801c3aa:	687b      	ldr	r3, [r7, #4]
 801c3ac:	2b00      	cmp	r3, #0
 801c3ae:	d002      	beq.n	801c3b6 <lv_ll_ins_prev+0x16>
 801c3b0:	683b      	ldr	r3, [r7, #0]
 801c3b2:	2b00      	cmp	r3, #0
 801c3b4:	d101      	bne.n	801c3ba <lv_ll_ins_prev+0x1a>
 801c3b6:	2300      	movs	r3, #0
 801c3b8:	e035      	b.n	801c426 <lv_ll_ins_prev+0x86>

    if(lv_ll_get_head(ll_p) == n_act) {
 801c3ba:	6878      	ldr	r0, [r7, #4]
 801c3bc:	f000 f91e 	bl	801c5fc <lv_ll_get_head>
 801c3c0:	4602      	mov	r2, r0
 801c3c2:	683b      	ldr	r3, [r7, #0]
 801c3c4:	4293      	cmp	r3, r2
 801c3c6:	d108      	bne.n	801c3da <lv_ll_ins_prev+0x3a>
        n_new = lv_ll_ins_head(ll_p);
 801c3c8:	6878      	ldr	r0, [r7, #4]
 801c3ca:	f7ff ffb5 	bl	801c338 <lv_ll_ins_head>
 801c3ce:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 801c3d0:	68fb      	ldr	r3, [r7, #12]
 801c3d2:	2b00      	cmp	r3, #0
 801c3d4:	d126      	bne.n	801c424 <lv_ll_ins_prev+0x84>
 801c3d6:	2300      	movs	r3, #0
 801c3d8:	e025      	b.n	801c426 <lv_ll_ins_prev+0x86>
    } else {
        n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 801c3da:	687b      	ldr	r3, [r7, #4]
 801c3dc:	681b      	ldr	r3, [r3, #0]
 801c3de:	3308      	adds	r3, #8
 801c3e0:	4618      	mov	r0, r3
 801c3e2:	f000 fa57 	bl	801c894 <lv_mem_alloc>
 801c3e6:	60f8      	str	r0, [r7, #12]
        if(n_new == NULL) return NULL;
 801c3e8:	68fb      	ldr	r3, [r7, #12]
 801c3ea:	2b00      	cmp	r3, #0
 801c3ec:	d101      	bne.n	801c3f2 <lv_ll_ins_prev+0x52>
 801c3ee:	2300      	movs	r3, #0
 801c3f0:	e019      	b.n	801c426 <lv_ll_ins_prev+0x86>

        n_prev = lv_ll_get_prev(ll_p, n_act);
 801c3f2:	6839      	ldr	r1, [r7, #0]
 801c3f4:	6878      	ldr	r0, [r7, #4]
 801c3f6:	f000 f941 	bl	801c67c <lv_ll_get_prev>
 801c3fa:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_new);
 801c3fc:	68fa      	ldr	r2, [r7, #12]
 801c3fe:	68b9      	ldr	r1, [r7, #8]
 801c400:	6878      	ldr	r0, [r7, #4]
 801c402:	f000 f9da 	bl	801c7ba <node_set_next>
        node_set_prev(ll_p, n_new, n_prev);
 801c406:	68ba      	ldr	r2, [r7, #8]
 801c408:	68f9      	ldr	r1, [r7, #12]
 801c40a:	6878      	ldr	r0, [r7, #4]
 801c40c:	f000 f9af 	bl	801c76e <node_set_prev>
        node_set_prev(ll_p, n_act, n_new);
 801c410:	68fa      	ldr	r2, [r7, #12]
 801c412:	6839      	ldr	r1, [r7, #0]
 801c414:	6878      	ldr	r0, [r7, #4]
 801c416:	f000 f9aa 	bl	801c76e <node_set_prev>
        node_set_next(ll_p, n_new, n_act);
 801c41a:	683a      	ldr	r2, [r7, #0]
 801c41c:	68f9      	ldr	r1, [r7, #12]
 801c41e:	6878      	ldr	r0, [r7, #4]
 801c420:	f000 f9cb 	bl	801c7ba <node_set_next>
    }

    return n_new;
 801c424:	68fb      	ldr	r3, [r7, #12]
}
 801c426:	4618      	mov	r0, r3
 801c428:	3710      	adds	r7, #16
 801c42a:	46bd      	mov	sp, r7
 801c42c:	bd80      	pop	{r7, pc}

0801c42e <lv_ll_ins_tail>:
 * Add a new tail to a linked list
 * @param ll_p pointer to linked list
 * @return pointer to the new tail
 */
void * lv_ll_ins_tail(lv_ll_t * ll_p)
{
 801c42e:	b580      	push	{r7, lr}
 801c430:	b084      	sub	sp, #16
 801c432:	af00      	add	r7, sp, #0
 801c434:	6078      	str	r0, [r7, #4]
    lv_ll_node_t * n_new;

    n_new = lv_mem_alloc(ll_p->n_size + LL_NODE_META_SIZE);
 801c436:	687b      	ldr	r3, [r7, #4]
 801c438:	681b      	ldr	r3, [r3, #0]
 801c43a:	3308      	adds	r3, #8
 801c43c:	4618      	mov	r0, r3
 801c43e:	f000 fa29 	bl	801c894 <lv_mem_alloc>
 801c442:	60f8      	str	r0, [r7, #12]
    if(n_new == NULL) return NULL;
 801c444:	68fb      	ldr	r3, [r7, #12]
 801c446:	2b00      	cmp	r3, #0
 801c448:	d101      	bne.n	801c44e <lv_ll_ins_tail+0x20>
 801c44a:	2300      	movs	r3, #0
 801c44c:	e024      	b.n	801c498 <lv_ll_ins_tail+0x6a>

    if(n_new != NULL) {
 801c44e:	68fb      	ldr	r3, [r7, #12]
 801c450:	2b00      	cmp	r3, #0
 801c452:	d020      	beq.n	801c496 <lv_ll_ins_tail+0x68>
        node_set_next(ll_p, n_new, NULL);       /*No next after the new tail*/
 801c454:	2200      	movs	r2, #0
 801c456:	68f9      	ldr	r1, [r7, #12]
 801c458:	6878      	ldr	r0, [r7, #4]
 801c45a:	f000 f9ae 	bl	801c7ba <node_set_next>
        node_set_prev(ll_p, n_new, ll_p->tail); /*The prev. before new is tho old tail*/
 801c45e:	687b      	ldr	r3, [r7, #4]
 801c460:	689b      	ldr	r3, [r3, #8]
 801c462:	461a      	mov	r2, r3
 801c464:	68f9      	ldr	r1, [r7, #12]
 801c466:	6878      	ldr	r0, [r7, #4]
 801c468:	f000 f981 	bl	801c76e <node_set_prev>
        if(ll_p->tail != NULL) {                /*If there is old tail then the new comes after it*/
 801c46c:	687b      	ldr	r3, [r7, #4]
 801c46e:	689b      	ldr	r3, [r3, #8]
 801c470:	2b00      	cmp	r3, #0
 801c472:	d006      	beq.n	801c482 <lv_ll_ins_tail+0x54>
            node_set_next(ll_p, ll_p->tail, n_new);
 801c474:	687b      	ldr	r3, [r7, #4]
 801c476:	689b      	ldr	r3, [r3, #8]
 801c478:	68fa      	ldr	r2, [r7, #12]
 801c47a:	4619      	mov	r1, r3
 801c47c:	6878      	ldr	r0, [r7, #4]
 801c47e:	f000 f99c 	bl	801c7ba <node_set_next>
        }

        ll_p->tail = n_new;      /*Set the new tail in the dsc.*/
 801c482:	687b      	ldr	r3, [r7, #4]
 801c484:	68fa      	ldr	r2, [r7, #12]
 801c486:	609a      	str	r2, [r3, #8]
        if(ll_p->head == NULL) { /*If there is no head (1. node) set the head too*/
 801c488:	687b      	ldr	r3, [r7, #4]
 801c48a:	685b      	ldr	r3, [r3, #4]
 801c48c:	2b00      	cmp	r3, #0
 801c48e:	d102      	bne.n	801c496 <lv_ll_ins_tail+0x68>
            ll_p->head = n_new;
 801c490:	687b      	ldr	r3, [r7, #4]
 801c492:	68fa      	ldr	r2, [r7, #12]
 801c494:	605a      	str	r2, [r3, #4]
        }
    }

    return n_new;
 801c496:	68fb      	ldr	r3, [r7, #12]
}
 801c498:	4618      	mov	r0, r3
 801c49a:	3710      	adds	r7, #16
 801c49c:	46bd      	mov	sp, r7
 801c49e:	bd80      	pop	{r7, pc}

0801c4a0 <lv_ll_rem>:
 * It does not free the the memory of node.
 * @param ll_p pointer to the linked list of 'node_p'
 * @param node_p pointer to node in 'll_p' linked list
 */
void lv_ll_rem(lv_ll_t * ll_p, void * node_p)
{
 801c4a0:	b580      	push	{r7, lr}
 801c4a2:	b084      	sub	sp, #16
 801c4a4:	af00      	add	r7, sp, #0
 801c4a6:	6078      	str	r0, [r7, #4]
 801c4a8:	6039      	str	r1, [r7, #0]
    if(lv_ll_get_head(ll_p) == node_p) {
 801c4aa:	6878      	ldr	r0, [r7, #4]
 801c4ac:	f000 f8a6 	bl	801c5fc <lv_ll_get_head>
 801c4b0:	4602      	mov	r2, r0
 801c4b2:	683b      	ldr	r3, [r7, #0]
 801c4b4:	4293      	cmp	r3, r2
 801c4b6:	d116      	bne.n	801c4e6 <lv_ll_rem+0x46>
        /*The new head will be the node after 'n_act'*/
        ll_p->head = lv_ll_get_next(ll_p, node_p);
 801c4b8:	6839      	ldr	r1, [r7, #0]
 801c4ba:	6878      	ldr	r0, [r7, #4]
 801c4bc:	f000 f8c4 	bl	801c648 <lv_ll_get_next>
 801c4c0:	4602      	mov	r2, r0
 801c4c2:	687b      	ldr	r3, [r7, #4]
 801c4c4:	605a      	str	r2, [r3, #4]
        if(ll_p->head == NULL) {
 801c4c6:	687b      	ldr	r3, [r7, #4]
 801c4c8:	685b      	ldr	r3, [r3, #4]
 801c4ca:	2b00      	cmp	r3, #0
 801c4cc:	d103      	bne.n	801c4d6 <lv_ll_rem+0x36>
            ll_p->tail = NULL;
 801c4ce:	687b      	ldr	r3, [r7, #4]
 801c4d0:	2200      	movs	r2, #0
 801c4d2:	609a      	str	r2, [r3, #8]
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);

        node_set_next(ll_p, n_prev, n_next);
        node_set_prev(ll_p, n_next, n_prev);
    }
}
 801c4d4:	e039      	b.n	801c54a <lv_ll_rem+0xaa>
            node_set_prev(ll_p, ll_p->head, NULL);
 801c4d6:	687b      	ldr	r3, [r7, #4]
 801c4d8:	685b      	ldr	r3, [r3, #4]
 801c4da:	2200      	movs	r2, #0
 801c4dc:	4619      	mov	r1, r3
 801c4de:	6878      	ldr	r0, [r7, #4]
 801c4e0:	f000 f945 	bl	801c76e <node_set_prev>
}
 801c4e4:	e031      	b.n	801c54a <lv_ll_rem+0xaa>
    } else if(lv_ll_get_tail(ll_p) == node_p) {
 801c4e6:	6878      	ldr	r0, [r7, #4]
 801c4e8:	f000 f89b 	bl	801c622 <lv_ll_get_tail>
 801c4ec:	4602      	mov	r2, r0
 801c4ee:	683b      	ldr	r3, [r7, #0]
 801c4f0:	4293      	cmp	r3, r2
 801c4f2:	d116      	bne.n	801c522 <lv_ll_rem+0x82>
        ll_p->tail = lv_ll_get_prev(ll_p, node_p);
 801c4f4:	6839      	ldr	r1, [r7, #0]
 801c4f6:	6878      	ldr	r0, [r7, #4]
 801c4f8:	f000 f8c0 	bl	801c67c <lv_ll_get_prev>
 801c4fc:	4602      	mov	r2, r0
 801c4fe:	687b      	ldr	r3, [r7, #4]
 801c500:	609a      	str	r2, [r3, #8]
        if(ll_p->tail == NULL) {
 801c502:	687b      	ldr	r3, [r7, #4]
 801c504:	689b      	ldr	r3, [r3, #8]
 801c506:	2b00      	cmp	r3, #0
 801c508:	d103      	bne.n	801c512 <lv_ll_rem+0x72>
            ll_p->head = NULL;
 801c50a:	687b      	ldr	r3, [r7, #4]
 801c50c:	2200      	movs	r2, #0
 801c50e:	605a      	str	r2, [r3, #4]
}
 801c510:	e01b      	b.n	801c54a <lv_ll_rem+0xaa>
            node_set_next(ll_p, ll_p->tail, NULL);
 801c512:	687b      	ldr	r3, [r7, #4]
 801c514:	689b      	ldr	r3, [r3, #8]
 801c516:	2200      	movs	r2, #0
 801c518:	4619      	mov	r1, r3
 801c51a:	6878      	ldr	r0, [r7, #4]
 801c51c:	f000 f94d 	bl	801c7ba <node_set_next>
}
 801c520:	e013      	b.n	801c54a <lv_ll_rem+0xaa>
        lv_ll_node_t * n_prev = lv_ll_get_prev(ll_p, node_p);
 801c522:	6839      	ldr	r1, [r7, #0]
 801c524:	6878      	ldr	r0, [r7, #4]
 801c526:	f000 f8a9 	bl	801c67c <lv_ll_get_prev>
 801c52a:	60f8      	str	r0, [r7, #12]
        lv_ll_node_t * n_next = lv_ll_get_next(ll_p, node_p);
 801c52c:	6839      	ldr	r1, [r7, #0]
 801c52e:	6878      	ldr	r0, [r7, #4]
 801c530:	f000 f88a 	bl	801c648 <lv_ll_get_next>
 801c534:	60b8      	str	r0, [r7, #8]
        node_set_next(ll_p, n_prev, n_next);
 801c536:	68ba      	ldr	r2, [r7, #8]
 801c538:	68f9      	ldr	r1, [r7, #12]
 801c53a:	6878      	ldr	r0, [r7, #4]
 801c53c:	f000 f93d 	bl	801c7ba <node_set_next>
        node_set_prev(ll_p, n_next, n_prev);
 801c540:	68fa      	ldr	r2, [r7, #12]
 801c542:	68b9      	ldr	r1, [r7, #8]
 801c544:	6878      	ldr	r0, [r7, #4]
 801c546:	f000 f912 	bl	801c76e <node_set_prev>
}
 801c54a:	bf00      	nop
 801c54c:	3710      	adds	r7, #16
 801c54e:	46bd      	mov	sp, r7
 801c550:	bd80      	pop	{r7, pc}

0801c552 <lv_ll_chg_list>:
 * @param node pointer to a node
 * @param head true: be the head in the new list
 *             false be the head in the new list
 */
void lv_ll_chg_list(lv_ll_t * ll_ori_p, lv_ll_t * ll_new_p, void * node, bool head)
{
 801c552:	b580      	push	{r7, lr}
 801c554:	b084      	sub	sp, #16
 801c556:	af00      	add	r7, sp, #0
 801c558:	60f8      	str	r0, [r7, #12]
 801c55a:	60b9      	str	r1, [r7, #8]
 801c55c:	607a      	str	r2, [r7, #4]
 801c55e:	70fb      	strb	r3, [r7, #3]
    lv_ll_rem(ll_ori_p, node);
 801c560:	6879      	ldr	r1, [r7, #4]
 801c562:	68f8      	ldr	r0, [r7, #12]
 801c564:	f7ff ff9c 	bl	801c4a0 <lv_ll_rem>

    if(head) {
 801c568:	78fb      	ldrb	r3, [r7, #3]
 801c56a:	2b00      	cmp	r3, #0
 801c56c:	d021      	beq.n	801c5b2 <lv_ll_chg_list+0x60>
        /*Set node as head*/
        node_set_prev(ll_new_p, node, NULL);
 801c56e:	2200      	movs	r2, #0
 801c570:	6879      	ldr	r1, [r7, #4]
 801c572:	68b8      	ldr	r0, [r7, #8]
 801c574:	f000 f8fb 	bl	801c76e <node_set_prev>
        node_set_next(ll_new_p, node, ll_new_p->head);
 801c578:	68bb      	ldr	r3, [r7, #8]
 801c57a:	685b      	ldr	r3, [r3, #4]
 801c57c:	461a      	mov	r2, r3
 801c57e:	6879      	ldr	r1, [r7, #4]
 801c580:	68b8      	ldr	r0, [r7, #8]
 801c582:	f000 f91a 	bl	801c7ba <node_set_next>

        if(ll_new_p->head != NULL) { /*If there is old head then before it goes the new*/
 801c586:	68bb      	ldr	r3, [r7, #8]
 801c588:	685b      	ldr	r3, [r3, #4]
 801c58a:	2b00      	cmp	r3, #0
 801c58c:	d006      	beq.n	801c59c <lv_ll_chg_list+0x4a>
            node_set_prev(ll_new_p, ll_new_p->head, node);
 801c58e:	68bb      	ldr	r3, [r7, #8]
 801c590:	685b      	ldr	r3, [r3, #4]
 801c592:	687a      	ldr	r2, [r7, #4]
 801c594:	4619      	mov	r1, r3
 801c596:	68b8      	ldr	r0, [r7, #8]
 801c598:	f000 f8e9 	bl	801c76e <node_set_prev>
        }

        ll_new_p->head = node;       /*Set the new head in the dsc.*/
 801c59c:	68bb      	ldr	r3, [r7, #8]
 801c59e:	687a      	ldr	r2, [r7, #4]
 801c5a0:	605a      	str	r2, [r3, #4]
        if(ll_new_p->tail == NULL) { /*If there is no tail (first node) set the tail too*/
 801c5a2:	68bb      	ldr	r3, [r7, #8]
 801c5a4:	689b      	ldr	r3, [r3, #8]
 801c5a6:	2b00      	cmp	r3, #0
 801c5a8:	d124      	bne.n	801c5f4 <lv_ll_chg_list+0xa2>
            ll_new_p->tail = node;
 801c5aa:	68bb      	ldr	r3, [r7, #8]
 801c5ac:	687a      	ldr	r2, [r7, #4]
 801c5ae:	609a      	str	r2, [r3, #8]
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
            ll_new_p->head = node;
        }
    }
}
 801c5b0:	e020      	b.n	801c5f4 <lv_ll_chg_list+0xa2>
        node_set_prev(ll_new_p, node, ll_new_p->tail);
 801c5b2:	68bb      	ldr	r3, [r7, #8]
 801c5b4:	689b      	ldr	r3, [r3, #8]
 801c5b6:	461a      	mov	r2, r3
 801c5b8:	6879      	ldr	r1, [r7, #4]
 801c5ba:	68b8      	ldr	r0, [r7, #8]
 801c5bc:	f000 f8d7 	bl	801c76e <node_set_prev>
        node_set_next(ll_new_p, node, NULL);
 801c5c0:	2200      	movs	r2, #0
 801c5c2:	6879      	ldr	r1, [r7, #4]
 801c5c4:	68b8      	ldr	r0, [r7, #8]
 801c5c6:	f000 f8f8 	bl	801c7ba <node_set_next>
        if(ll_new_p->tail != NULL) { /*If there is old tail then after it goes the new*/
 801c5ca:	68bb      	ldr	r3, [r7, #8]
 801c5cc:	689b      	ldr	r3, [r3, #8]
 801c5ce:	2b00      	cmp	r3, #0
 801c5d0:	d006      	beq.n	801c5e0 <lv_ll_chg_list+0x8e>
            node_set_next(ll_new_p, ll_new_p->tail, node);
 801c5d2:	68bb      	ldr	r3, [r7, #8]
 801c5d4:	689b      	ldr	r3, [r3, #8]
 801c5d6:	687a      	ldr	r2, [r7, #4]
 801c5d8:	4619      	mov	r1, r3
 801c5da:	68b8      	ldr	r0, [r7, #8]
 801c5dc:	f000 f8ed 	bl	801c7ba <node_set_next>
        ll_new_p->tail = node;       /*Set the new tail in the dsc.*/
 801c5e0:	68bb      	ldr	r3, [r7, #8]
 801c5e2:	687a      	ldr	r2, [r7, #4]
 801c5e4:	609a      	str	r2, [r3, #8]
        if(ll_new_p->head == NULL) { /*If there is no head (first node) set the head too*/
 801c5e6:	68bb      	ldr	r3, [r7, #8]
 801c5e8:	685b      	ldr	r3, [r3, #4]
 801c5ea:	2b00      	cmp	r3, #0
 801c5ec:	d102      	bne.n	801c5f4 <lv_ll_chg_list+0xa2>
            ll_new_p->head = node;
 801c5ee:	68bb      	ldr	r3, [r7, #8]
 801c5f0:	687a      	ldr	r2, [r7, #4]
 801c5f2:	605a      	str	r2, [r3, #4]
}
 801c5f4:	bf00      	nop
 801c5f6:	3710      	adds	r7, #16
 801c5f8:	46bd      	mov	sp, r7
 801c5fa:	bd80      	pop	{r7, pc}

0801c5fc <lv_ll_get_head>:
 * Return with head node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * lv_ll_get_head(const lv_ll_t * ll_p)
{
 801c5fc:	b480      	push	{r7}
 801c5fe:	b085      	sub	sp, #20
 801c600:	af00      	add	r7, sp, #0
 801c602:	6078      	str	r0, [r7, #4]
    void * head = NULL;
 801c604:	2300      	movs	r3, #0
 801c606:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 801c608:	687b      	ldr	r3, [r7, #4]
 801c60a:	2b00      	cmp	r3, #0
 801c60c:	d002      	beq.n	801c614 <lv_ll_get_head+0x18>
        head = ll_p->head;
 801c60e:	687b      	ldr	r3, [r7, #4]
 801c610:	685b      	ldr	r3, [r3, #4]
 801c612:	60fb      	str	r3, [r7, #12]
    }

    return head;
 801c614:	68fb      	ldr	r3, [r7, #12]
}
 801c616:	4618      	mov	r0, r3
 801c618:	3714      	adds	r7, #20
 801c61a:	46bd      	mov	sp, r7
 801c61c:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c620:	4770      	bx	lr

0801c622 <lv_ll_get_tail>:
 * Return with tail node of the linked list
 * @param ll_p pointer to linked list
 * @return pointer to the head of 'll_p'
 */
void * lv_ll_get_tail(const lv_ll_t * ll_p)
{
 801c622:	b480      	push	{r7}
 801c624:	b085      	sub	sp, #20
 801c626:	af00      	add	r7, sp, #0
 801c628:	6078      	str	r0, [r7, #4]
    void * tail = NULL;
 801c62a:	2300      	movs	r3, #0
 801c62c:	60fb      	str	r3, [r7, #12]

    if(ll_p != NULL) {
 801c62e:	687b      	ldr	r3, [r7, #4]
 801c630:	2b00      	cmp	r3, #0
 801c632:	d002      	beq.n	801c63a <lv_ll_get_tail+0x18>
        tail = ll_p->tail;
 801c634:	687b      	ldr	r3, [r7, #4]
 801c636:	689b      	ldr	r3, [r3, #8]
 801c638:	60fb      	str	r3, [r7, #12]
    }

    return tail;
 801c63a:	68fb      	ldr	r3, [r7, #12]
}
 801c63c:	4618      	mov	r0, r3
 801c63e:	3714      	adds	r7, #20
 801c640:	46bd      	mov	sp, r7
 801c642:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c646:	4770      	bx	lr

0801c648 <lv_ll_get_next>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the next node
 */
void * lv_ll_get_next(const lv_ll_t * ll_p, const void * n_act)
{
 801c648:	b480      	push	{r7}
 801c64a:	b085      	sub	sp, #20
 801c64c:	af00      	add	r7, sp, #0
 801c64e:	6078      	str	r0, [r7, #4]
 801c650:	6039      	str	r1, [r7, #0]
    void * next = NULL;
 801c652:	2300      	movs	r3, #0
 801c654:	60bb      	str	r3, [r7, #8]

    if(ll_p != NULL) {
 801c656:	687b      	ldr	r3, [r7, #4]
 801c658:	2b00      	cmp	r3, #0
 801c65a:	d008      	beq.n	801c66e <lv_ll_get_next+0x26>
        const lv_ll_node_t * n_act_d = n_act;
 801c65c:	683b      	ldr	r3, [r7, #0]
 801c65e:	60fb      	str	r3, [r7, #12]
        memcpy(&next, n_act_d + LL_NEXT_P_OFFSET(ll_p), sizeof(void *));
 801c660:	687b      	ldr	r3, [r7, #4]
 801c662:	681b      	ldr	r3, [r3, #0]
 801c664:	3304      	adds	r3, #4
 801c666:	68fa      	ldr	r2, [r7, #12]
 801c668:	4413      	add	r3, r2
 801c66a:	681b      	ldr	r3, [r3, #0]
 801c66c:	60bb      	str	r3, [r7, #8]
    }

    return next;
 801c66e:	68bb      	ldr	r3, [r7, #8]
}
 801c670:	4618      	mov	r0, r3
 801c672:	3714      	adds	r7, #20
 801c674:	46bd      	mov	sp, r7
 801c676:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c67a:	4770      	bx	lr

0801c67c <lv_ll_get_prev>:
 * @param ll_p pointer to linked list
 * @param n_act pointer a node
 * @return pointer to the previous node
 */
void * lv_ll_get_prev(const lv_ll_t * ll_p, const void * n_act)
{
 801c67c:	b480      	push	{r7}
 801c67e:	b085      	sub	sp, #20
 801c680:	af00      	add	r7, sp, #0
 801c682:	6078      	str	r0, [r7, #4]
 801c684:	6039      	str	r1, [r7, #0]
    void * prev = NULL;
 801c686:	2300      	movs	r3, #0
 801c688:	60bb      	str	r3, [r7, #8]

    if(ll_p != NULL) {
 801c68a:	687b      	ldr	r3, [r7, #4]
 801c68c:	2b00      	cmp	r3, #0
 801c68e:	d007      	beq.n	801c6a0 <lv_ll_get_prev+0x24>
        const lv_ll_node_t * n_act_d = n_act;
 801c690:	683b      	ldr	r3, [r7, #0]
 801c692:	60fb      	str	r3, [r7, #12]
        memcpy(&prev, n_act_d + LL_PREV_P_OFFSET(ll_p), sizeof(void *));
 801c694:	687b      	ldr	r3, [r7, #4]
 801c696:	681b      	ldr	r3, [r3, #0]
 801c698:	68fa      	ldr	r2, [r7, #12]
 801c69a:	4413      	add	r3, r2
 801c69c:	681b      	ldr	r3, [r3, #0]
 801c69e:	60bb      	str	r3, [r7, #8]
    }

    return prev;
 801c6a0:	68bb      	ldr	r3, [r7, #8]
}
 801c6a2:	4618      	mov	r0, r3
 801c6a4:	3714      	adds	r7, #20
 801c6a6:	46bd      	mov	sp, r7
 801c6a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c6ac:	4770      	bx	lr

0801c6ae <lv_ll_move_before>:
 * @param ll_p pointer to a linked list
 * @param n_act pointer to node to move
 * @param n_after pointer to a node which should be after `n_act`
 */
void lv_ll_move_before(lv_ll_t * ll_p, void * n_act, void * n_after)
{
 801c6ae:	b580      	push	{r7, lr}
 801c6b0:	b086      	sub	sp, #24
 801c6b2:	af00      	add	r7, sp, #0
 801c6b4:	60f8      	str	r0, [r7, #12]
 801c6b6:	60b9      	str	r1, [r7, #8]
 801c6b8:	607a      	str	r2, [r7, #4]
    if(n_act == n_after) return; /*Can't move before itself*/
 801c6ba:	68ba      	ldr	r2, [r7, #8]
 801c6bc:	687b      	ldr	r3, [r7, #4]
 801c6be:	429a      	cmp	r2, r3
 801c6c0:	d035      	beq.n	801c72e <lv_ll_move_before+0x80>

    void * n_before;
    if(n_after != NULL)
 801c6c2:	687b      	ldr	r3, [r7, #4]
 801c6c4:	2b00      	cmp	r3, #0
 801c6c6:	d005      	beq.n	801c6d4 <lv_ll_move_before+0x26>
        n_before = lv_ll_get_prev(ll_p, n_after);
 801c6c8:	6879      	ldr	r1, [r7, #4]
 801c6ca:	68f8      	ldr	r0, [r7, #12]
 801c6cc:	f7ff ffd6 	bl	801c67c <lv_ll_get_prev>
 801c6d0:	6178      	str	r0, [r7, #20]
 801c6d2:	e003      	b.n	801c6dc <lv_ll_move_before+0x2e>
    else
        n_before = lv_ll_get_tail(ll_p); /*if `n_after` is NULL `n_act` should be the new tail*/
 801c6d4:	68f8      	ldr	r0, [r7, #12]
 801c6d6:	f7ff ffa4 	bl	801c622 <lv_ll_get_tail>
 801c6da:	6178      	str	r0, [r7, #20]

    if(n_act == n_before) return; /*Already before `n_after`*/
 801c6dc:	68ba      	ldr	r2, [r7, #8]
 801c6de:	697b      	ldr	r3, [r7, #20]
 801c6e0:	429a      	cmp	r2, r3
 801c6e2:	d026      	beq.n	801c732 <lv_ll_move_before+0x84>

    /*It's much easier to remove from the list and add again*/
    lv_ll_rem(ll_p, n_act);
 801c6e4:	68b9      	ldr	r1, [r7, #8]
 801c6e6:	68f8      	ldr	r0, [r7, #12]
 801c6e8:	f7ff feda 	bl	801c4a0 <lv_ll_rem>

    /*Add again by setting the prev. and next nodes*/
    node_set_next(ll_p, n_before, n_act);
 801c6ec:	68ba      	ldr	r2, [r7, #8]
 801c6ee:	6979      	ldr	r1, [r7, #20]
 801c6f0:	68f8      	ldr	r0, [r7, #12]
 801c6f2:	f000 f862 	bl	801c7ba <node_set_next>
    node_set_prev(ll_p, n_act, n_before);
 801c6f6:	697a      	ldr	r2, [r7, #20]
 801c6f8:	68b9      	ldr	r1, [r7, #8]
 801c6fa:	68f8      	ldr	r0, [r7, #12]
 801c6fc:	f000 f837 	bl	801c76e <node_set_prev>
    node_set_prev(ll_p, n_after, n_act);
 801c700:	68ba      	ldr	r2, [r7, #8]
 801c702:	6879      	ldr	r1, [r7, #4]
 801c704:	68f8      	ldr	r0, [r7, #12]
 801c706:	f000 f832 	bl	801c76e <node_set_prev>
    node_set_next(ll_p, n_act, n_after);
 801c70a:	687a      	ldr	r2, [r7, #4]
 801c70c:	68b9      	ldr	r1, [r7, #8]
 801c70e:	68f8      	ldr	r0, [r7, #12]
 801c710:	f000 f853 	bl	801c7ba <node_set_next>

    /*If `n_act` was moved before NULL then it become the new tail*/
    if(n_after == NULL) ll_p->tail = n_act;
 801c714:	687b      	ldr	r3, [r7, #4]
 801c716:	2b00      	cmp	r3, #0
 801c718:	d102      	bne.n	801c720 <lv_ll_move_before+0x72>
 801c71a:	68fb      	ldr	r3, [r7, #12]
 801c71c:	68ba      	ldr	r2, [r7, #8]
 801c71e:	609a      	str	r2, [r3, #8]

    /*If `n_act` was moved before `NULL` then it's the new head*/
    if(n_before == NULL) ll_p->head = n_act;
 801c720:	697b      	ldr	r3, [r7, #20]
 801c722:	2b00      	cmp	r3, #0
 801c724:	d106      	bne.n	801c734 <lv_ll_move_before+0x86>
 801c726:	68fb      	ldr	r3, [r7, #12]
 801c728:	68ba      	ldr	r2, [r7, #8]
 801c72a:	605a      	str	r2, [r3, #4]
 801c72c:	e002      	b.n	801c734 <lv_ll_move_before+0x86>
    if(n_act == n_after) return; /*Can't move before itself*/
 801c72e:	bf00      	nop
 801c730:	e000      	b.n	801c734 <lv_ll_move_before+0x86>
    if(n_act == n_before) return; /*Already before `n_after`*/
 801c732:	bf00      	nop
}
 801c734:	3718      	adds	r7, #24
 801c736:	46bd      	mov	sp, r7
 801c738:	bd80      	pop	{r7, pc}

0801c73a <lv_ll_is_empty>:
 * Check if a linked list is empty
 * @param ll_p pointer to a linked list
 * @return true: the linked list is empty; false: not empty
 */
bool lv_ll_is_empty(lv_ll_t * ll_p)
{
 801c73a:	b480      	push	{r7}
 801c73c:	b083      	sub	sp, #12
 801c73e:	af00      	add	r7, sp, #0
 801c740:	6078      	str	r0, [r7, #4]
    if(ll_p == NULL) return true;
 801c742:	687b      	ldr	r3, [r7, #4]
 801c744:	2b00      	cmp	r3, #0
 801c746:	d101      	bne.n	801c74c <lv_ll_is_empty+0x12>
 801c748:	2301      	movs	r3, #1
 801c74a:	e00a      	b.n	801c762 <lv_ll_is_empty+0x28>

    if(ll_p->head == NULL && ll_p->tail == NULL) return true;
 801c74c:	687b      	ldr	r3, [r7, #4]
 801c74e:	685b      	ldr	r3, [r3, #4]
 801c750:	2b00      	cmp	r3, #0
 801c752:	d105      	bne.n	801c760 <lv_ll_is_empty+0x26>
 801c754:	687b      	ldr	r3, [r7, #4]
 801c756:	689b      	ldr	r3, [r3, #8]
 801c758:	2b00      	cmp	r3, #0
 801c75a:	d101      	bne.n	801c760 <lv_ll_is_empty+0x26>
 801c75c:	2301      	movs	r3, #1
 801c75e:	e000      	b.n	801c762 <lv_ll_is_empty+0x28>

    return false;
 801c760:	2300      	movs	r3, #0
}
 801c762:	4618      	mov	r0, r3
 801c764:	370c      	adds	r7, #12
 801c766:	46bd      	mov	sp, r7
 801c768:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c76c:	4770      	bx	lr

0801c76e <node_set_prev>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which prev. node pointer should be set
 * @param prev pointer to a node which should be the previous node before 'act'
 */
static void node_set_prev(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * prev)
{
 801c76e:	b580      	push	{r7, lr}
 801c770:	b086      	sub	sp, #24
 801c772:	af00      	add	r7, sp, #0
 801c774:	60f8      	str	r0, [r7, #12]
 801c776:	60b9      	str	r1, [r7, #8]
 801c778:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 801c77a:	68bb      	ldr	r3, [r7, #8]
 801c77c:	2b00      	cmp	r3, #0
 801c77e:	d018      	beq.n	801c7b2 <node_set_prev+0x44>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
 801c780:	2304      	movs	r3, #4
 801c782:	617b      	str	r3, [r7, #20]
    if(prev)
 801c784:	687b      	ldr	r3, [r7, #4]
 801c786:	2b00      	cmp	r3, #0
 801c788:	d009      	beq.n	801c79e <node_set_prev+0x30>
        memcpy(act + LL_PREV_P_OFFSET(ll_p), &prev, node_p_size);
 801c78a:	68fb      	ldr	r3, [r7, #12]
 801c78c:	681b      	ldr	r3, [r3, #0]
 801c78e:	68ba      	ldr	r2, [r7, #8]
 801c790:	4413      	add	r3, r2
 801c792:	1d39      	adds	r1, r7, #4
 801c794:	697a      	ldr	r2, [r7, #20]
 801c796:	4618      	mov	r0, r3
 801c798:	f00a fd10 	bl	80271bc <memcpy>
 801c79c:	e00a      	b.n	801c7b4 <node_set_prev+0x46>
    else
        memset(act + LL_PREV_P_OFFSET(ll_p), 0, node_p_size);
 801c79e:	68fb      	ldr	r3, [r7, #12]
 801c7a0:	681b      	ldr	r3, [r3, #0]
 801c7a2:	68ba      	ldr	r2, [r7, #8]
 801c7a4:	4413      	add	r3, r2
 801c7a6:	697a      	ldr	r2, [r7, #20]
 801c7a8:	2100      	movs	r1, #0
 801c7aa:	4618      	mov	r0, r3
 801c7ac:	f00a fd11 	bl	80271d2 <memset>
 801c7b0:	e000      	b.n	801c7b4 <node_set_prev+0x46>
    if(act == NULL) return; /*Can't set the prev node of `NULL`*/
 801c7b2:	bf00      	nop
}
 801c7b4:	3718      	adds	r7, #24
 801c7b6:	46bd      	mov	sp, r7
 801c7b8:	bd80      	pop	{r7, pc}

0801c7ba <node_set_next>:
 * @param ll_p pointer to linked list
 * @param act pointer to a node which next node pointer should be set
 * @param next pointer to a node which should be the next node before 'act'
 */
static void node_set_next(lv_ll_t * ll_p, lv_ll_node_t * act, lv_ll_node_t * next)
{
 801c7ba:	b580      	push	{r7, lr}
 801c7bc:	b086      	sub	sp, #24
 801c7be:	af00      	add	r7, sp, #0
 801c7c0:	60f8      	str	r0, [r7, #12]
 801c7c2:	60b9      	str	r1, [r7, #8]
 801c7c4:	607a      	str	r2, [r7, #4]
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 801c7c6:	68bb      	ldr	r3, [r7, #8]
 801c7c8:	2b00      	cmp	r3, #0
 801c7ca:	d01a      	beq.n	801c802 <node_set_next+0x48>

    uint32_t node_p_size = sizeof(lv_ll_node_t *);
 801c7cc:	2304      	movs	r3, #4
 801c7ce:	617b      	str	r3, [r7, #20]
    if(next)
 801c7d0:	687b      	ldr	r3, [r7, #4]
 801c7d2:	2b00      	cmp	r3, #0
 801c7d4:	d00a      	beq.n	801c7ec <node_set_next+0x32>
        memcpy(act + LL_NEXT_P_OFFSET(ll_p), &next, node_p_size);
 801c7d6:	68fb      	ldr	r3, [r7, #12]
 801c7d8:	681b      	ldr	r3, [r3, #0]
 801c7da:	3304      	adds	r3, #4
 801c7dc:	68ba      	ldr	r2, [r7, #8]
 801c7de:	4413      	add	r3, r2
 801c7e0:	1d39      	adds	r1, r7, #4
 801c7e2:	697a      	ldr	r2, [r7, #20]
 801c7e4:	4618      	mov	r0, r3
 801c7e6:	f00a fce9 	bl	80271bc <memcpy>
 801c7ea:	e00b      	b.n	801c804 <node_set_next+0x4a>
    else
        memset(act + LL_NEXT_P_OFFSET(ll_p), 0, node_p_size);
 801c7ec:	68fb      	ldr	r3, [r7, #12]
 801c7ee:	681b      	ldr	r3, [r3, #0]
 801c7f0:	3304      	adds	r3, #4
 801c7f2:	68ba      	ldr	r2, [r7, #8]
 801c7f4:	4413      	add	r3, r2
 801c7f6:	697a      	ldr	r2, [r7, #20]
 801c7f8:	2100      	movs	r1, #0
 801c7fa:	4618      	mov	r0, r3
 801c7fc:	f00a fce9 	bl	80271d2 <memset>
 801c800:	e000      	b.n	801c804 <node_set_next+0x4a>
    if(act == NULL) return; /*Can't set the next node of `NULL`*/
 801c802:	bf00      	nop
}
 801c804:	3718      	adds	r7, #24
 801c806:	46bd      	mov	sp, r7
 801c808:	bd80      	pop	{r7, pc}
	...

0801c80c <lv_log_add>:
 * @param file name of the file when the log added
 * @param line line number in the source code where the log added
 * @param dsc description of the log
 */
void lv_log_add(lv_log_level_t level, const char * file, int line, const char * dsc)
{
 801c80c:	b590      	push	{r4, r7, lr}
 801c80e:	b085      	sub	sp, #20
 801c810:	af00      	add	r7, sp, #0
 801c812:	60b9      	str	r1, [r7, #8]
 801c814:	607a      	str	r2, [r7, #4]
 801c816:	603b      	str	r3, [r7, #0]
 801c818:	4603      	mov	r3, r0
 801c81a:	73fb      	strb	r3, [r7, #15]
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/
 801c81c:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801c820:	2b04      	cmp	r3, #4
 801c822:	dc10      	bgt.n	801c846 <lv_log_add+0x3a>

    if(level >= LV_LOG_LEVEL) {
 801c824:	f997 300f 	ldrsb.w	r3, [r7, #15]
 801c828:	2b01      	cmp	r3, #1
 801c82a:	dd0d      	ble.n	801c848 <lv_log_add+0x3c>

#if LV_LOG_PRINTF
        static const char * lvl_prefix[] = {"Trace", "Info", "Warn", "Error"};
        printf("%s: %s \t(%s #%d)\n", lvl_prefix[level], dsc, file, line);
#else
        if(custom_print_cb) custom_print_cb(level, file, line, dsc);
 801c82c:	4b08      	ldr	r3, [pc, #32]	; (801c850 <lv_log_add+0x44>)
 801c82e:	681b      	ldr	r3, [r3, #0]
 801c830:	2b00      	cmp	r3, #0
 801c832:	d009      	beq.n	801c848 <lv_log_add+0x3c>
 801c834:	4b06      	ldr	r3, [pc, #24]	; (801c850 <lv_log_add+0x44>)
 801c836:	681c      	ldr	r4, [r3, #0]
 801c838:	687a      	ldr	r2, [r7, #4]
 801c83a:	f997 000f 	ldrsb.w	r0, [r7, #15]
 801c83e:	683b      	ldr	r3, [r7, #0]
 801c840:	68b9      	ldr	r1, [r7, #8]
 801c842:	47a0      	blx	r4
 801c844:	e000      	b.n	801c848 <lv_log_add+0x3c>
    if(level >= _LV_LOG_LEVEL_NUM) return; /*Invalid level*/
 801c846:	bf00      	nop
#endif
    }
}
 801c848:	3714      	adds	r7, #20
 801c84a:	46bd      	mov	sp, r7
 801c84c:	bd90      	pop	{r4, r7, pc}
 801c84e:	bf00      	nop
 801c850:	2000438c 	.word	0x2000438c

0801c854 <lv_mem_init>:

/**
 * Initiaiize the dyn_mem module (work memory and other variables)
 */
void lv_mem_init(void)
{
 801c854:	b480      	push	{r7}
 801c856:	b083      	sub	sp, #12
 801c858:	af00      	add	r7, sp, #0
#if LV_MEM_CUSTOM == 0

#if LV_MEM_ADR == 0
    /*Allocate a large array to store the dynamically allocated data*/
    static LV_MEM_ATTR MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)];
    work_mem = (uint8_t *)work_mem_int;
 801c85a:	4b0c      	ldr	r3, [pc, #48]	; (801c88c <lv_mem_init+0x38>)
 801c85c:	4a0c      	ldr	r2, [pc, #48]	; (801c890 <lv_mem_init+0x3c>)
 801c85e:	601a      	str	r2, [r3, #0]
#else
    work_mem = (uint8_t *)LV_MEM_ADR;
#endif

    lv_mem_ent_t * full = (lv_mem_ent_t *)work_mem;
 801c860:	4b0a      	ldr	r3, [pc, #40]	; (801c88c <lv_mem_init+0x38>)
 801c862:	681b      	ldr	r3, [r3, #0]
 801c864:	607b      	str	r3, [r7, #4]
    full->header.s.used = 0;
 801c866:	687a      	ldr	r2, [r7, #4]
 801c868:	7813      	ldrb	r3, [r2, #0]
 801c86a:	f36f 0300 	bfc	r3, #0, #1
 801c86e:	7013      	strb	r3, [r2, #0]
    /*The total mem size id reduced by the first header and the close patterns */
    full->header.s.d_size = LV_MEM_SIZE - sizeof(lv_mem_header_t);
 801c870:	687a      	ldr	r2, [r7, #4]
 801c872:	6813      	ldr	r3, [r2, #0]
 801c874:	f647 71fc 	movw	r1, #32764	; 0x7ffc
 801c878:	f361 035f 	bfi	r3, r1, #1, #31
 801c87c:	6013      	str	r3, [r2, #0]
#endif
}
 801c87e:	bf00      	nop
 801c880:	370c      	adds	r7, #12
 801c882:	46bd      	mov	sp, r7
 801c884:	f85d 7b04 	ldr.w	r7, [sp], #4
 801c888:	4770      	bx	lr
 801c88a:	bf00      	nop
 801c88c:	20004390 	.word	0x20004390
 801c890:	20004398 	.word	0x20004398

0801c894 <lv_mem_alloc>:
 * Allocate a memory dynamically
 * @param size size of the memory to allocate in bytes
 * @return pointer to the allocated memory
 */
void * lv_mem_alloc(uint32_t size)
{
 801c894:	b580      	push	{r7, lr}
 801c896:	b084      	sub	sp, #16
 801c898:	af00      	add	r7, sp, #0
 801c89a:	6078      	str	r0, [r7, #4]
    if(size == 0) {
 801c89c:	687b      	ldr	r3, [r7, #4]
 801c89e:	2b00      	cmp	r3, #0
 801c8a0:	d101      	bne.n	801c8a6 <lv_mem_alloc+0x12>
        return &zero_mem;
 801c8a2:	4b1d      	ldr	r3, [pc, #116]	; (801c918 <lv_mem_alloc+0x84>)
 801c8a4:	e033      	b.n	801c90e <lv_mem_alloc+0x7a>
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
 801c8a6:	687b      	ldr	r3, [r7, #4]
 801c8a8:	f003 0303 	and.w	r3, r3, #3
 801c8ac:	2b00      	cmp	r3, #0
 801c8ae:	d006      	beq.n	801c8be <lv_mem_alloc+0x2a>
        size = size & (~0x3);
 801c8b0:	687b      	ldr	r3, [r7, #4]
 801c8b2:	f023 0303 	bic.w	r3, r3, #3
 801c8b6:	607b      	str	r3, [r7, #4]
        size += 4;
 801c8b8:	687b      	ldr	r3, [r7, #4]
 801c8ba:	3304      	adds	r3, #4
 801c8bc:	607b      	str	r3, [r7, #4]
    }
#endif
    void * alloc = NULL;
 801c8be:	2300      	movs	r3, #0
 801c8c0:	60fb      	str	r3, [r7, #12]

#if LV_MEM_CUSTOM == 0
    /*Use the built-in allocators*/
    lv_mem_ent_t * e = NULL;
 801c8c2:	2300      	movs	r3, #0
 801c8c4:	60bb      	str	r3, [r7, #8]

    // Search for a appropriate entry
    do {
        // Get the next entry
        e = ent_get_next(e);
 801c8c6:	68b8      	ldr	r0, [r7, #8]
 801c8c8:	f000 f8f0 	bl	801caac <ent_get_next>
 801c8cc:	60b8      	str	r0, [r7, #8]

        /*If there is next entry then try to allocate there*/
        if(e != NULL) {
 801c8ce:	68bb      	ldr	r3, [r7, #8]
 801c8d0:	2b00      	cmp	r3, #0
 801c8d2:	d004      	beq.n	801c8de <lv_mem_alloc+0x4a>
            alloc = ent_alloc(e, size);
 801c8d4:	6879      	ldr	r1, [r7, #4]
 801c8d6:	68b8      	ldr	r0, [r7, #8]
 801c8d8:	f000 f914 	bl	801cb04 <ent_alloc>
 801c8dc:	60f8      	str	r0, [r7, #12]
        }
        // End if there is not next entry OR the alloc. is successful
    } while(e != NULL && alloc == NULL);
 801c8de:	68bb      	ldr	r3, [r7, #8]
 801c8e0:	2b00      	cmp	r3, #0
 801c8e2:	d002      	beq.n	801c8ea <lv_mem_alloc+0x56>
 801c8e4:	68fb      	ldr	r3, [r7, #12]
 801c8e6:	2b00      	cmp	r3, #0
 801c8e8:	d0ed      	beq.n	801c8c6 <lv_mem_alloc+0x32>
    }
#endif                /* LV_ENABLE_GC */
#endif                /* LV_MEM_CUSTOM */

#if LV_MEM_ADD_JUNK
    if(alloc != NULL) memset(alloc, 0xaa, size);
 801c8ea:	68fb      	ldr	r3, [r7, #12]
 801c8ec:	2b00      	cmp	r3, #0
 801c8ee:	d004      	beq.n	801c8fa <lv_mem_alloc+0x66>
 801c8f0:	687a      	ldr	r2, [r7, #4]
 801c8f2:	21aa      	movs	r1, #170	; 0xaa
 801c8f4:	68f8      	ldr	r0, [r7, #12]
 801c8f6:	f00a fc6c 	bl	80271d2 <memset>
#endif

    if(alloc == NULL) LV_LOG_WARN("Couldn't allocate memory");
 801c8fa:	68fb      	ldr	r3, [r7, #12]
 801c8fc:	2b00      	cmp	r3, #0
 801c8fe:	d105      	bne.n	801c90c <lv_mem_alloc+0x78>
 801c900:	4b06      	ldr	r3, [pc, #24]	; (801c91c <lv_mem_alloc+0x88>)
 801c902:	22a5      	movs	r2, #165	; 0xa5
 801c904:	4906      	ldr	r1, [pc, #24]	; (801c920 <lv_mem_alloc+0x8c>)
 801c906:	2002      	movs	r0, #2
 801c908:	f7ff ff80 	bl	801c80c <lv_log_add>

    return alloc;
 801c90c:	68fb      	ldr	r3, [r7, #12]
}
 801c90e:	4618      	mov	r0, r3
 801c910:	3710      	adds	r7, #16
 801c912:	46bd      	mov	sp, r7
 801c914:	bd80      	pop	{r7, pc}
 801c916:	bf00      	nop
 801c918:	20004394 	.word	0x20004394
 801c91c:	08028ea4 	.word	0x08028ea4
 801c920:	08028ec0 	.word	0x08028ec0

0801c924 <lv_mem_free>:
/**
 * Free an allocated data
 * @param data pointer to an allocated memory
 */
void lv_mem_free(const void * data)
{
 801c924:	b580      	push	{r7, lr}
 801c926:	b084      	sub	sp, #16
 801c928:	af00      	add	r7, sp, #0
 801c92a:	6078      	str	r0, [r7, #4]
    if(data == &zero_mem) return;
 801c92c:	687b      	ldr	r3, [r7, #4]
 801c92e:	4a22      	ldr	r2, [pc, #136]	; (801c9b8 <lv_mem_free+0x94>)
 801c930:	4293      	cmp	r3, r2
 801c932:	d039      	beq.n	801c9a8 <lv_mem_free+0x84>
    if(data == NULL) return;
 801c934:	687b      	ldr	r3, [r7, #4]
 801c936:	2b00      	cmp	r3, #0
 801c938:	d038      	beq.n	801c9ac <lv_mem_free+0x88>

#if LV_MEM_ADD_JUNK
    memset((void *)data, 0xbb, lv_mem_get_size(data));
 801c93a:	6878      	ldr	r0, [r7, #4]
 801c93c:	f000 f898 	bl	801ca70 <lv_mem_get_size>
 801c940:	4603      	mov	r3, r0
 801c942:	461a      	mov	r2, r3
 801c944:	21bb      	movs	r1, #187	; 0xbb
 801c946:	6878      	ldr	r0, [r7, #4]
 801c948:	f00a fc43 	bl	80271d2 <memset>
#endif

#if LV_ENABLE_GC == 0
    /*e points to the header*/
    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 801c94c:	687b      	ldr	r3, [r7, #4]
 801c94e:	3b04      	subs	r3, #4
 801c950:	60bb      	str	r3, [r7, #8]
    e->header.s.used = 0;
 801c952:	68ba      	ldr	r2, [r7, #8]
 801c954:	7813      	ldrb	r3, [r2, #0]
 801c956:	f36f 0300 	bfc	r3, #0, #1
 801c95a:	7013      	strb	r3, [r2, #0]
#if LV_MEM_CUSTOM == 0
#if LV_MEM_AUTO_DEFRAG
    /* Make a simple defrag.
     * Join the following free entries after this*/
    lv_mem_ent_t * e_next;
    e_next = ent_get_next(e);
 801c95c:	68b8      	ldr	r0, [r7, #8]
 801c95e:	f000 f8a5 	bl	801caac <ent_get_next>
 801c962:	60f8      	str	r0, [r7, #12]
    while(e_next != NULL) {
 801c964:	e01c      	b.n	801c9a0 <lv_mem_free+0x7c>
        if(e_next->header.s.used == 0) {
 801c966:	68fb      	ldr	r3, [r7, #12]
 801c968:	781b      	ldrb	r3, [r3, #0]
 801c96a:	f003 0301 	and.w	r3, r3, #1
 801c96e:	b2db      	uxtb	r3, r3
 801c970:	2b00      	cmp	r3, #0
 801c972:	d11d      	bne.n	801c9b0 <lv_mem_free+0x8c>
            e->header.s.d_size += e_next->header.s.d_size + sizeof(e->header);
 801c974:	68bb      	ldr	r3, [r7, #8]
 801c976:	681b      	ldr	r3, [r3, #0]
 801c978:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801c97c:	461a      	mov	r2, r3
 801c97e:	68fb      	ldr	r3, [r7, #12]
 801c980:	681b      	ldr	r3, [r3, #0]
 801c982:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801c986:	4413      	add	r3, r2
 801c988:	3304      	adds	r3, #4
 801c98a:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 801c98e:	68ba      	ldr	r2, [r7, #8]
 801c990:	6813      	ldr	r3, [r2, #0]
 801c992:	f361 035f 	bfi	r3, r1, #1, #31
 801c996:	6013      	str	r3, [r2, #0]
        } else {
            break;
        }
        e_next = ent_get_next(e_next);
 801c998:	68f8      	ldr	r0, [r7, #12]
 801c99a:	f000 f887 	bl	801caac <ent_get_next>
 801c99e:	60f8      	str	r0, [r7, #12]
    while(e_next != NULL) {
 801c9a0:	68fb      	ldr	r3, [r7, #12]
 801c9a2:	2b00      	cmp	r3, #0
 801c9a4:	d1df      	bne.n	801c966 <lv_mem_free+0x42>
 801c9a6:	e004      	b.n	801c9b2 <lv_mem_free+0x8e>
    if(data == &zero_mem) return;
 801c9a8:	bf00      	nop
 801c9aa:	e002      	b.n	801c9b2 <lv_mem_free+0x8e>
    if(data == NULL) return;
 801c9ac:	bf00      	nop
 801c9ae:	e000      	b.n	801c9b2 <lv_mem_free+0x8e>
            break;
 801c9b0:	bf00      	nop
    LV_MEM_CUSTOM_FREE(e);
#else
    LV_MEM_CUSTOM_FREE((void *)data);
#endif /*LV_ENABLE_GC*/
#endif
}
 801c9b2:	3710      	adds	r7, #16
 801c9b4:	46bd      	mov	sp, r7
 801c9b6:	bd80      	pop	{r7, pc}
 801c9b8:	20004394 	.word	0x20004394

0801c9bc <lv_mem_realloc>:
 */

#if LV_ENABLE_GC == 0

void * lv_mem_realloc(void * data_p, uint32_t new_size)
{
 801c9bc:	b580      	push	{r7, lr}
 801c9be:	b086      	sub	sp, #24
 801c9c0:	af00      	add	r7, sp, #0
 801c9c2:	6078      	str	r0, [r7, #4]
 801c9c4:	6039      	str	r1, [r7, #0]
    /*data_p could be previously freed pointer (in this case it is invalid)*/
    if(data_p != NULL) {
 801c9c6:	687b      	ldr	r3, [r7, #4]
 801c9c8:	2b00      	cmp	r3, #0
 801c9ca:	d00b      	beq.n	801c9e4 <lv_mem_realloc+0x28>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 801c9cc:	687b      	ldr	r3, [r7, #4]
 801c9ce:	3b04      	subs	r3, #4
 801c9d0:	617b      	str	r3, [r7, #20]
        if(e->header.s.used == 0) {
 801c9d2:	697b      	ldr	r3, [r7, #20]
 801c9d4:	781b      	ldrb	r3, [r3, #0]
 801c9d6:	f003 0301 	and.w	r3, r3, #1
 801c9da:	b2db      	uxtb	r3, r3
 801c9dc:	2b00      	cmp	r3, #0
 801c9de:	d101      	bne.n	801c9e4 <lv_mem_realloc+0x28>
            data_p = NULL;
 801c9e0:	2300      	movs	r3, #0
 801c9e2:	607b      	str	r3, [r7, #4]
        }
    }

    uint32_t old_size = lv_mem_get_size(data_p);
 801c9e4:	6878      	ldr	r0, [r7, #4]
 801c9e6:	f000 f843 	bl	801ca70 <lv_mem_get_size>
 801c9ea:	6138      	str	r0, [r7, #16]
    if(old_size == new_size) return data_p; /*Also avoid reallocating the same memory*/
 801c9ec:	693a      	ldr	r2, [r7, #16]
 801c9ee:	683b      	ldr	r3, [r7, #0]
 801c9f0:	429a      	cmp	r2, r3
 801c9f2:	d101      	bne.n	801c9f8 <lv_mem_realloc+0x3c>
 801c9f4:	687b      	ldr	r3, [r7, #4]
 801c9f6:	e032      	b.n	801ca5e <lv_mem_realloc+0xa2>

#if LV_MEM_CUSTOM == 0
    /* Truncate the memory if the new size is smaller. */
    if(new_size < old_size) {
 801c9f8:	683a      	ldr	r2, [r7, #0]
 801c9fa:	693b      	ldr	r3, [r7, #16]
 801c9fc:	429a      	cmp	r2, r3
 801c9fe:	d209      	bcs.n	801ca14 <lv_mem_realloc+0x58>
        lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data_p - sizeof(lv_mem_header_t));
 801ca00:	687b      	ldr	r3, [r7, #4]
 801ca02:	3b04      	subs	r3, #4
 801ca04:	60bb      	str	r3, [r7, #8]
        ent_trunc(e, new_size);
 801ca06:	6839      	ldr	r1, [r7, #0]
 801ca08:	68b8      	ldr	r0, [r7, #8]
 801ca0a:	f000 f8a2 	bl	801cb52 <ent_trunc>
        return &e->first_data;
 801ca0e:	68bb      	ldr	r3, [r7, #8]
 801ca10:	3304      	adds	r3, #4
 801ca12:	e024      	b.n	801ca5e <lv_mem_realloc+0xa2>
    }
#endif

    void * new_p;
    new_p = lv_mem_alloc(new_size);
 801ca14:	6838      	ldr	r0, [r7, #0]
 801ca16:	f7ff ff3d 	bl	801c894 <lv_mem_alloc>
 801ca1a:	60f8      	str	r0, [r7, #12]

    if(new_p != NULL && data_p != NULL) {
 801ca1c:	68fb      	ldr	r3, [r7, #12]
 801ca1e:	2b00      	cmp	r3, #0
 801ca20:	d012      	beq.n	801ca48 <lv_mem_realloc+0x8c>
 801ca22:	687b      	ldr	r3, [r7, #4]
 801ca24:	2b00      	cmp	r3, #0
 801ca26:	d00f      	beq.n	801ca48 <lv_mem_realloc+0x8c>
        /*Copy the old data to the new. Use the smaller size*/
        if(old_size != 0) {
 801ca28:	693b      	ldr	r3, [r7, #16]
 801ca2a:	2b00      	cmp	r3, #0
 801ca2c:	d00c      	beq.n	801ca48 <lv_mem_realloc+0x8c>
            memcpy(new_p, data_p, LV_MATH_MIN(new_size, old_size));
 801ca2e:	693a      	ldr	r2, [r7, #16]
 801ca30:	683b      	ldr	r3, [r7, #0]
 801ca32:	4293      	cmp	r3, r2
 801ca34:	bf28      	it	cs
 801ca36:	4613      	movcs	r3, r2
 801ca38:	461a      	mov	r2, r3
 801ca3a:	6879      	ldr	r1, [r7, #4]
 801ca3c:	68f8      	ldr	r0, [r7, #12]
 801ca3e:	f00a fbbd 	bl	80271bc <memcpy>
            lv_mem_free(data_p);
 801ca42:	6878      	ldr	r0, [r7, #4]
 801ca44:	f7ff ff6e 	bl	801c924 <lv_mem_free>
        }
    }

    if(new_p == NULL) LV_LOG_WARN("Couldn't allocate memory");
 801ca48:	68fb      	ldr	r3, [r7, #12]
 801ca4a:	2b00      	cmp	r3, #0
 801ca4c:	d106      	bne.n	801ca5c <lv_mem_realloc+0xa0>
 801ca4e:	4b06      	ldr	r3, [pc, #24]	; (801ca68 <lv_mem_realloc+0xac>)
 801ca50:	f44f 7280 	mov.w	r2, #256	; 0x100
 801ca54:	4905      	ldr	r1, [pc, #20]	; (801ca6c <lv_mem_realloc+0xb0>)
 801ca56:	2002      	movs	r0, #2
 801ca58:	f7ff fed8 	bl	801c80c <lv_log_add>

    return new_p;
 801ca5c:	68fb      	ldr	r3, [r7, #12]
}
 801ca5e:	4618      	mov	r0, r3
 801ca60:	3718      	adds	r7, #24
 801ca62:	46bd      	mov	sp, r7
 801ca64:	bd80      	pop	{r7, pc}
 801ca66:	bf00      	nop
 801ca68:	08028ea4 	.word	0x08028ea4
 801ca6c:	08028ec0 	.word	0x08028ec0

0801ca70 <lv_mem_get_size>:
 */

#if LV_ENABLE_GC == 0

uint32_t lv_mem_get_size(const void * data)
{
 801ca70:	b480      	push	{r7}
 801ca72:	b085      	sub	sp, #20
 801ca74:	af00      	add	r7, sp, #0
 801ca76:	6078      	str	r0, [r7, #4]
    if(data == NULL) return 0;
 801ca78:	687b      	ldr	r3, [r7, #4]
 801ca7a:	2b00      	cmp	r3, #0
 801ca7c:	d101      	bne.n	801ca82 <lv_mem_get_size+0x12>
 801ca7e:	2300      	movs	r3, #0
 801ca80:	e00c      	b.n	801ca9c <lv_mem_get_size+0x2c>
    if(data == &zero_mem) return 0;
 801ca82:	687b      	ldr	r3, [r7, #4]
 801ca84:	4a08      	ldr	r2, [pc, #32]	; (801caa8 <lv_mem_get_size+0x38>)
 801ca86:	4293      	cmp	r3, r2
 801ca88:	d101      	bne.n	801ca8e <lv_mem_get_size+0x1e>
 801ca8a:	2300      	movs	r3, #0
 801ca8c:	e006      	b.n	801ca9c <lv_mem_get_size+0x2c>

    lv_mem_ent_t * e = (lv_mem_ent_t *)((uint8_t *)data - sizeof(lv_mem_header_t));
 801ca8e:	687b      	ldr	r3, [r7, #4]
 801ca90:	3b04      	subs	r3, #4
 801ca92:	60fb      	str	r3, [r7, #12]

    return e->header.s.d_size;
 801ca94:	68fb      	ldr	r3, [r7, #12]
 801ca96:	681b      	ldr	r3, [r3, #0]
 801ca98:	f3c3 035e 	ubfx	r3, r3, #1, #31
}
 801ca9c:	4618      	mov	r0, r3
 801ca9e:	3714      	adds	r7, #20
 801caa0:	46bd      	mov	sp, r7
 801caa2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801caa6:	4770      	bx	lr
 801caa8:	20004394 	.word	0x20004394

0801caac <ent_get_next>:
 * Give the next entry after 'act_e'
 * @param act_e pointer to an entry
 * @return pointer to an entry after 'act_e'
 */
static lv_mem_ent_t * ent_get_next(lv_mem_ent_t * act_e)
{
 801caac:	b480      	push	{r7}
 801caae:	b085      	sub	sp, #20
 801cab0:	af00      	add	r7, sp, #0
 801cab2:	6078      	str	r0, [r7, #4]
    lv_mem_ent_t * next_e = NULL;
 801cab4:	2300      	movs	r3, #0
 801cab6:	60fb      	str	r3, [r7, #12]

    if(act_e == NULL) { /*NULL means: get the first entry*/
 801cab8:	687b      	ldr	r3, [r7, #4]
 801caba:	2b00      	cmp	r3, #0
 801cabc:	d103      	bne.n	801cac6 <ent_get_next+0x1a>
        next_e = (lv_mem_ent_t *)work_mem;
 801cabe:	4b10      	ldr	r3, [pc, #64]	; (801cb00 <ent_get_next+0x54>)
 801cac0:	681b      	ldr	r3, [r3, #0]
 801cac2:	60fb      	str	r3, [r7, #12]
 801cac4:	e014      	b.n	801caf0 <ent_get_next+0x44>
    } else { /*Get the next entry */
        uint8_t * data = &act_e->first_data;
 801cac6:	687b      	ldr	r3, [r7, #4]
 801cac8:	3304      	adds	r3, #4
 801caca:	60bb      	str	r3, [r7, #8]
        next_e         = (lv_mem_ent_t *)&data[act_e->header.s.d_size];
 801cacc:	687b      	ldr	r3, [r7, #4]
 801cace:	681b      	ldr	r3, [r3, #0]
 801cad0:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801cad4:	461a      	mov	r2, r3
 801cad6:	68bb      	ldr	r3, [r7, #8]
 801cad8:	4413      	add	r3, r2
 801cada:	60fb      	str	r3, [r7, #12]

        if(&next_e->first_data >= &work_mem[LV_MEM_SIZE]) next_e = NULL;
 801cadc:	68fb      	ldr	r3, [r7, #12]
 801cade:	1d1a      	adds	r2, r3, #4
 801cae0:	4b07      	ldr	r3, [pc, #28]	; (801cb00 <ent_get_next+0x54>)
 801cae2:	681b      	ldr	r3, [r3, #0]
 801cae4:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 801cae8:	429a      	cmp	r2, r3
 801caea:	d301      	bcc.n	801caf0 <ent_get_next+0x44>
 801caec:	2300      	movs	r3, #0
 801caee:	60fb      	str	r3, [r7, #12]
    }

    return next_e;
 801caf0:	68fb      	ldr	r3, [r7, #12]
}
 801caf2:	4618      	mov	r0, r3
 801caf4:	3714      	adds	r7, #20
 801caf6:	46bd      	mov	sp, r7
 801caf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cafc:	4770      	bx	lr
 801cafe:	bf00      	nop
 801cb00:	20004390 	.word	0x20004390

0801cb04 <ent_alloc>:
 * @param e try to allocate to this entry
 * @param size size of the new memory in bytes
 * @return pointer to the allocated memory or NULL if not enough memory in the entry
 */
static void * ent_alloc(lv_mem_ent_t * e, uint32_t size)
{
 801cb04:	b580      	push	{r7, lr}
 801cb06:	b084      	sub	sp, #16
 801cb08:	af00      	add	r7, sp, #0
 801cb0a:	6078      	str	r0, [r7, #4]
 801cb0c:	6039      	str	r1, [r7, #0]
    void * alloc = NULL;
 801cb0e:	2300      	movs	r3, #0
 801cb10:	60fb      	str	r3, [r7, #12]

    /*If the memory is free and big enough then use it */
    if(e->header.s.used == 0 && e->header.s.d_size >= size) {
 801cb12:	687b      	ldr	r3, [r7, #4]
 801cb14:	781b      	ldrb	r3, [r3, #0]
 801cb16:	f003 0301 	and.w	r3, r3, #1
 801cb1a:	b2db      	uxtb	r3, r3
 801cb1c:	2b00      	cmp	r3, #0
 801cb1e:	d113      	bne.n	801cb48 <ent_alloc+0x44>
 801cb20:	687b      	ldr	r3, [r7, #4]
 801cb22:	681b      	ldr	r3, [r3, #0]
 801cb24:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801cb28:	461a      	mov	r2, r3
 801cb2a:	683b      	ldr	r3, [r7, #0]
 801cb2c:	4293      	cmp	r3, r2
 801cb2e:	d80b      	bhi.n	801cb48 <ent_alloc+0x44>
        /*Truncate the entry to the desired size */
        ent_trunc(e, size),
 801cb30:	6839      	ldr	r1, [r7, #0]
 801cb32:	6878      	ldr	r0, [r7, #4]
 801cb34:	f000 f80d 	bl	801cb52 <ent_trunc>

            e->header.s.used = 1;
 801cb38:	687a      	ldr	r2, [r7, #4]
 801cb3a:	7813      	ldrb	r3, [r2, #0]
 801cb3c:	f043 0301 	orr.w	r3, r3, #1
 801cb40:	7013      	strb	r3, [r2, #0]

        /*Save the allocated data*/
        alloc = &e->first_data;
 801cb42:	687b      	ldr	r3, [r7, #4]
 801cb44:	3304      	adds	r3, #4
 801cb46:	60fb      	str	r3, [r7, #12]
    }

    return alloc;
 801cb48:	68fb      	ldr	r3, [r7, #12]
}
 801cb4a:	4618      	mov	r0, r3
 801cb4c:	3710      	adds	r7, #16
 801cb4e:	46bd      	mov	sp, r7
 801cb50:	bd80      	pop	{r7, pc}

0801cb52 <ent_trunc>:
 * Truncate the data of entry to the given size
 * @param e Pointer to an entry
 * @param size new size in bytes
 */
static void ent_trunc(lv_mem_ent_t * e, uint32_t size)
{
 801cb52:	b480      	push	{r7}
 801cb54:	b085      	sub	sp, #20
 801cb56:	af00      	add	r7, sp, #0
 801cb58:	6078      	str	r0, [r7, #4]
 801cb5a:	6039      	str	r1, [r7, #0]
        size = size & (~0x7);
        size += 8;
    }
#else
    /*Round the size up to 4*/
    if(size & 0x3) {
 801cb5c:	683b      	ldr	r3, [r7, #0]
 801cb5e:	f003 0303 	and.w	r3, r3, #3
 801cb62:	2b00      	cmp	r3, #0
 801cb64:	d006      	beq.n	801cb74 <ent_trunc+0x22>
        size = size & (~0x3);
 801cb66:	683b      	ldr	r3, [r7, #0]
 801cb68:	f023 0303 	bic.w	r3, r3, #3
 801cb6c:	603b      	str	r3, [r7, #0]
        size += 4;
 801cb6e:	683b      	ldr	r3, [r7, #0]
 801cb70:	3304      	adds	r3, #4
 801cb72:	603b      	str	r3, [r7, #0]
    }
#endif

    /*Don't let empty space only for a header without data*/
    if(e->header.s.d_size == size + sizeof(lv_mem_header_t)) {
 801cb74:	687b      	ldr	r3, [r7, #4]
 801cb76:	681b      	ldr	r3, [r3, #0]
 801cb78:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801cb7c:	461a      	mov	r2, r3
 801cb7e:	683b      	ldr	r3, [r7, #0]
 801cb80:	3304      	adds	r3, #4
 801cb82:	429a      	cmp	r2, r3
 801cb84:	d104      	bne.n	801cb90 <ent_trunc+0x3e>
        size = e->header.s.d_size;
 801cb86:	687b      	ldr	r3, [r7, #4]
 801cb88:	681b      	ldr	r3, [r3, #0]
 801cb8a:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801cb8e:	603b      	str	r3, [r7, #0]
    }

    /* Create the new entry after the current if there is space for it */
    if(e->header.s.d_size != size) {
 801cb90:	687b      	ldr	r3, [r7, #4]
 801cb92:	681b      	ldr	r3, [r3, #0]
 801cb94:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801cb98:	461a      	mov	r2, r3
 801cb9a:	683b      	ldr	r3, [r7, #0]
 801cb9c:	4293      	cmp	r3, r2
 801cb9e:	d01a      	beq.n	801cbd6 <ent_trunc+0x84>
        uint8_t * e_data             = &e->first_data;
 801cba0:	687b      	ldr	r3, [r7, #4]
 801cba2:	3304      	adds	r3, #4
 801cba4:	60fb      	str	r3, [r7, #12]
        lv_mem_ent_t * after_new_e   = (lv_mem_ent_t *)&e_data[size];
 801cba6:	68fa      	ldr	r2, [r7, #12]
 801cba8:	683b      	ldr	r3, [r7, #0]
 801cbaa:	4413      	add	r3, r2
 801cbac:	60bb      	str	r3, [r7, #8]
        after_new_e->header.s.used   = 0;
 801cbae:	68ba      	ldr	r2, [r7, #8]
 801cbb0:	7813      	ldrb	r3, [r2, #0]
 801cbb2:	f36f 0300 	bfc	r3, #0, #1
 801cbb6:	7013      	strb	r3, [r2, #0]
        after_new_e->header.s.d_size = e->header.s.d_size - size - sizeof(lv_mem_header_t);
 801cbb8:	687b      	ldr	r3, [r7, #4]
 801cbba:	681b      	ldr	r3, [r3, #0]
 801cbbc:	f3c3 035e 	ubfx	r3, r3, #1, #31
 801cbc0:	461a      	mov	r2, r3
 801cbc2:	683b      	ldr	r3, [r7, #0]
 801cbc4:	1ad3      	subs	r3, r2, r3
 801cbc6:	3b04      	subs	r3, #4
 801cbc8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 801cbcc:	68ba      	ldr	r2, [r7, #8]
 801cbce:	6813      	ldr	r3, [r2, #0]
 801cbd0:	f361 035f 	bfi	r3, r1, #1, #31
 801cbd4:	6013      	str	r3, [r2, #0]
    }

    /* Set the new size for the original entry */
    e->header.s.d_size = size;
 801cbd6:	683b      	ldr	r3, [r7, #0]
 801cbd8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 801cbdc:	687a      	ldr	r2, [r7, #4]
 801cbde:	6813      	ldr	r3, [r2, #0]
 801cbe0:	f361 035f 	bfi	r3, r1, #1, #31
 801cbe4:	6013      	str	r3, [r2, #0]
}
 801cbe6:	bf00      	nop
 801cbe8:	3714      	adds	r7, #20
 801cbea:	46bd      	mov	sp, r7
 801cbec:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cbf0:	4770      	bx	lr
	...

0801cbf4 <lv_task_core_init>:

/**
 * Init the lv_task module
 */
void lv_task_core_init(void)
{
 801cbf4:	b580      	push	{r7, lr}
 801cbf6:	af00      	add	r7, sp, #0
    lv_ll_init(&LV_GC_ROOT(_lv_task_ll), sizeof(lv_task_t));
 801cbf8:	2114      	movs	r1, #20
 801cbfa:	4804      	ldr	r0, [pc, #16]	; (801cc0c <lv_task_core_init+0x18>)
 801cbfc:	f7ff fb7c 	bl	801c2f8 <lv_ll_init>

    /*Initially enable the lv_task handling*/
    lv_task_enable(true);
 801cc00:	2001      	movs	r0, #1
 801cc02:	f000 fa43 	bl	801d08c <lv_task_enable>
}
 801cc06:	bf00      	nop
 801cc08:	bd80      	pop	{r7, pc}
 801cc0a:	bf00      	nop
 801cc0c:	2000df44 	.word	0x2000df44

0801cc10 <lv_task_handler>:

/**
 * Call it  periodically to handle lv_tasks.
 */
LV_ATTRIBUTE_TASK_HANDLER void lv_task_handler(void)
{
 801cc10:	b580      	push	{r7, lr}
 801cc12:	b084      	sub	sp, #16
 801cc14:	af00      	add	r7, sp, #0
    LV_LOG_TRACE("lv_task_handler started");

    /*Avoid concurrent running of the task handler*/
    static bool task_handler_mutex = false;
    if(task_handler_mutex) return;
 801cc16:	4b6b      	ldr	r3, [pc, #428]	; (801cdc4 <lv_task_handler+0x1b4>)
 801cc18:	781b      	ldrb	r3, [r3, #0]
 801cc1a:	2b00      	cmp	r3, #0
 801cc1c:	f040 80cd 	bne.w	801cdba <lv_task_handler+0x1aa>
    task_handler_mutex = true;
 801cc20:	4b68      	ldr	r3, [pc, #416]	; (801cdc4 <lv_task_handler+0x1b4>)
 801cc22:	2201      	movs	r2, #1
 801cc24:	701a      	strb	r2, [r3, #0]

    static uint32_t idle_period_start = 0;
    static uint32_t handler_start     = 0;
    static uint32_t busy_time         = 0;

    if(lv_task_run == false) {
 801cc26:	4b68      	ldr	r3, [pc, #416]	; (801cdc8 <lv_task_handler+0x1b8>)
 801cc28:	781b      	ldrb	r3, [r3, #0]
 801cc2a:	f083 0301 	eor.w	r3, r3, #1
 801cc2e:	b2db      	uxtb	r3, r3
 801cc30:	2b00      	cmp	r3, #0
 801cc32:	d003      	beq.n	801cc3c <lv_task_handler+0x2c>
        task_handler_mutex = false; /*Release mutex*/
 801cc34:	4b63      	ldr	r3, [pc, #396]	; (801cdc4 <lv_task_handler+0x1b4>)
 801cc36:	2200      	movs	r2, #0
 801cc38:	701a      	strb	r2, [r3, #0]
        return;
 801cc3a:	e0bf      	b.n	801cdbc <lv_task_handler+0x1ac>
    }

    handler_start = lv_tick_get();
 801cc3c:	f7fe fc36 	bl	801b4ac <lv_tick_get>
 801cc40:	4602      	mov	r2, r0
 801cc42:	4b62      	ldr	r3, [pc, #392]	; (801cdcc <lv_task_handler+0x1bc>)
 801cc44:	601a      	str	r2, [r3, #0]

    /* Run all task from the highest to the lowest priority
     * If a lower priority task is executed check task again from the highest priority
     * but on the priority of executed tasks don't run tasks before the executed*/
    lv_task_t * task_interrupter = NULL;
 801cc46:	2300      	movs	r3, #0
 801cc48:	60fb      	str	r3, [r7, #12]
    lv_task_t * next;
    bool end_flag;
    do {
        end_flag                 = true;
 801cc4a:	2301      	movs	r3, #1
 801cc4c:	72fb      	strb	r3, [r7, #11]
        task_deleted             = false;
 801cc4e:	4b60      	ldr	r3, [pc, #384]	; (801cdd0 <lv_task_handler+0x1c0>)
 801cc50:	2200      	movs	r2, #0
 801cc52:	701a      	strb	r2, [r3, #0]
        task_created             = false;
 801cc54:	4b5f      	ldr	r3, [pc, #380]	; (801cdd4 <lv_task_handler+0x1c4>)
 801cc56:	2200      	movs	r2, #0
 801cc58:	701a      	strb	r2, [r3, #0]
        LV_GC_ROOT(_lv_task_act) = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 801cc5a:	485f      	ldr	r0, [pc, #380]	; (801cdd8 <lv_task_handler+0x1c8>)
 801cc5c:	f7ff fcce 	bl	801c5fc <lv_ll_get_head>
 801cc60:	4602      	mov	r2, r0
 801cc62:	4b5e      	ldr	r3, [pc, #376]	; (801cddc <lv_task_handler+0x1cc>)
 801cc64:	601a      	str	r2, [r3, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 801cc66:	e05e      	b.n	801cd26 <lv_task_handler+0x116>
            /* The task might be deleted if it runs only once ('once = 1')
             * So get next element until the current is surely valid*/
            next = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), LV_GC_ROOT(_lv_task_act));
 801cc68:	4b5c      	ldr	r3, [pc, #368]	; (801cddc <lv_task_handler+0x1cc>)
 801cc6a:	681b      	ldr	r3, [r3, #0]
 801cc6c:	4619      	mov	r1, r3
 801cc6e:	485a      	ldr	r0, [pc, #360]	; (801cdd8 <lv_task_handler+0x1c8>)
 801cc70:	f7ff fcea 	bl	801c648 <lv_ll_get_next>
 801cc74:	6078      	str	r0, [r7, #4]

            /*We reach priority of the turned off task. There is nothing more to do.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_OFF) {
 801cc76:	4b59      	ldr	r3, [pc, #356]	; (801cddc <lv_task_handler+0x1cc>)
 801cc78:	681b      	ldr	r3, [r3, #0]
 801cc7a:	7c1b      	ldrb	r3, [r3, #16]
 801cc7c:	f003 0307 	and.w	r3, r3, #7
 801cc80:	b2db      	uxtb	r3, r3
 801cc82:	2b00      	cmp	r3, #0
 801cc84:	d054      	beq.n	801cd30 <lv_task_handler+0x120>
                break;
            }

            /*Here is the interrupter task. Don't execute it again.*/
            if(LV_GC_ROOT(_lv_task_act) == task_interrupter) {
 801cc86:	4b55      	ldr	r3, [pc, #340]	; (801cddc <lv_task_handler+0x1cc>)
 801cc88:	681b      	ldr	r3, [r3, #0]
 801cc8a:	68fa      	ldr	r2, [r7, #12]
 801cc8c:	429a      	cmp	r2, r3
 801cc8e:	d105      	bne.n	801cc9c <lv_task_handler+0x8c>
                task_interrupter = NULL; /*From this point only task after the interrupter comes, so
 801cc90:	2300      	movs	r3, #0
 801cc92:	60fb      	str	r3, [r7, #12]
                                            the interrupter is not interesting anymore*/
                LV_GC_ROOT(_lv_task_act) = next;
 801cc94:	4a51      	ldr	r2, [pc, #324]	; (801cddc <lv_task_handler+0x1cc>)
 801cc96:	687b      	ldr	r3, [r7, #4]
 801cc98:	6013      	str	r3, [r2, #0]
                continue; /*Load the next task*/
 801cc9a:	e044      	b.n	801cd26 <lv_task_handler+0x116>
            }

            /*Just try to run the tasks with highest priority.*/
            if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio == LV_TASK_PRIO_HIGHEST) {
 801cc9c:	4b4f      	ldr	r3, [pc, #316]	; (801cddc <lv_task_handler+0x1cc>)
 801cc9e:	681b      	ldr	r3, [r3, #0]
 801cca0:	7c1b      	ldrb	r3, [r3, #16]
 801cca2:	f003 0307 	and.w	r3, r3, #7
 801cca6:	b2db      	uxtb	r3, r3
 801cca8:	2b05      	cmp	r3, #5
 801ccaa:	d105      	bne.n	801ccb8 <lv_task_handler+0xa8>
                lv_task_exec(LV_GC_ROOT(_lv_task_act));
 801ccac:	4b4b      	ldr	r3, [pc, #300]	; (801cddc <lv_task_handler+0x1cc>)
 801ccae:	681b      	ldr	r3, [r3, #0]
 801ccb0:	4618      	mov	r0, r3
 801ccb2:	f000 f9fb 	bl	801d0ac <lv_task_exec>
 801ccb6:	e02b      	b.n	801cd10 <lv_task_handler+0x100>
            }
            /*Tasks with higher priority then the interrupted shall be run in every case*/
            else if(task_interrupter) {
 801ccb8:	68fb      	ldr	r3, [r7, #12]
 801ccba:	2b00      	cmp	r3, #0
 801ccbc:	d01a      	beq.n	801ccf4 <lv_task_handler+0xe4>
                if(((lv_task_t *)LV_GC_ROOT(_lv_task_act))->prio > task_interrupter->prio) {
 801ccbe:	4b47      	ldr	r3, [pc, #284]	; (801cddc <lv_task_handler+0x1cc>)
 801ccc0:	681b      	ldr	r3, [r3, #0]
 801ccc2:	7c1b      	ldrb	r3, [r3, #16]
 801ccc4:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801ccc8:	b2da      	uxtb	r2, r3
 801ccca:	68fb      	ldr	r3, [r7, #12]
 801cccc:	7c1b      	ldrb	r3, [r3, #16]
 801ccce:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801ccd2:	b2db      	uxtb	r3, r3
 801ccd4:	429a      	cmp	r2, r3
 801ccd6:	d91b      	bls.n	801cd10 <lv_task_handler+0x100>
                    if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 801ccd8:	4b40      	ldr	r3, [pc, #256]	; (801cddc <lv_task_handler+0x1cc>)
 801ccda:	681b      	ldr	r3, [r3, #0]
 801ccdc:	4618      	mov	r0, r3
 801ccde:	f000 f9e5 	bl	801d0ac <lv_task_exec>
 801cce2:	4603      	mov	r3, r0
 801cce4:	2b00      	cmp	r3, #0
 801cce6:	d013      	beq.n	801cd10 <lv_task_handler+0x100>
                        task_interrupter =
 801cce8:	4b3c      	ldr	r3, [pc, #240]	; (801cddc <lv_task_handler+0x1cc>)
 801ccea:	681b      	ldr	r3, [r3, #0]
 801ccec:	60fb      	str	r3, [r7, #12]
                            LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
                        end_flag = false;
 801ccee:	2300      	movs	r3, #0
 801ccf0:	72fb      	strb	r3, [r7, #11]
                        break;
 801ccf2:	e022      	b.n	801cd3a <lv_task_handler+0x12a>
                }
            }
            /* It is no interrupter task or we already reached it earlier.
             * Just run the remaining tasks*/
            else {
                if(lv_task_exec(LV_GC_ROOT(_lv_task_act))) {
 801ccf4:	4b39      	ldr	r3, [pc, #228]	; (801cddc <lv_task_handler+0x1cc>)
 801ccf6:	681b      	ldr	r3, [r3, #0]
 801ccf8:	4618      	mov	r0, r3
 801ccfa:	f000 f9d7 	bl	801d0ac <lv_task_exec>
 801ccfe:	4603      	mov	r3, r0
 801cd00:	2b00      	cmp	r3, #0
 801cd02:	d005      	beq.n	801cd10 <lv_task_handler+0x100>
                    task_interrupter = LV_GC_ROOT(_lv_task_act); /*Check all tasks again from the highest priority */
 801cd04:	4b35      	ldr	r3, [pc, #212]	; (801cddc <lv_task_handler+0x1cc>)
 801cd06:	681b      	ldr	r3, [r3, #0]
 801cd08:	60fb      	str	r3, [r7, #12]
                    end_flag         = false;
 801cd0a:	2300      	movs	r3, #0
 801cd0c:	72fb      	strb	r3, [r7, #11]
                    break;
 801cd0e:	e014      	b.n	801cd3a <lv_task_handler+0x12a>
                }
            }

            if(task_deleted) break; /*If a task was deleted then this or the next item might be corrupted*/
 801cd10:	4b2f      	ldr	r3, [pc, #188]	; (801cdd0 <lv_task_handler+0x1c0>)
 801cd12:	781b      	ldrb	r3, [r3, #0]
 801cd14:	2b00      	cmp	r3, #0
 801cd16:	d10d      	bne.n	801cd34 <lv_task_handler+0x124>
            if(task_created) break; /*If a task was created then this or the next item might be corrupted*/
 801cd18:	4b2e      	ldr	r3, [pc, #184]	; (801cdd4 <lv_task_handler+0x1c4>)
 801cd1a:	781b      	ldrb	r3, [r3, #0]
 801cd1c:	2b00      	cmp	r3, #0
 801cd1e:	d10b      	bne.n	801cd38 <lv_task_handler+0x128>

            LV_GC_ROOT(_lv_task_act) = next; /*Load the next task*/
 801cd20:	4a2e      	ldr	r2, [pc, #184]	; (801cddc <lv_task_handler+0x1cc>)
 801cd22:	687b      	ldr	r3, [r7, #4]
 801cd24:	6013      	str	r3, [r2, #0]
        while(LV_GC_ROOT(_lv_task_act)) {
 801cd26:	4b2d      	ldr	r3, [pc, #180]	; (801cddc <lv_task_handler+0x1cc>)
 801cd28:	681b      	ldr	r3, [r3, #0]
 801cd2a:	2b00      	cmp	r3, #0
 801cd2c:	d19c      	bne.n	801cc68 <lv_task_handler+0x58>
 801cd2e:	e004      	b.n	801cd3a <lv_task_handler+0x12a>
                break;
 801cd30:	bf00      	nop
 801cd32:	e002      	b.n	801cd3a <lv_task_handler+0x12a>
            if(task_deleted) break; /*If a task was deleted then this or the next item might be corrupted*/
 801cd34:	bf00      	nop
 801cd36:	e000      	b.n	801cd3a <lv_task_handler+0x12a>
            if(task_created) break; /*If a task was created then this or the next item might be corrupted*/
 801cd38:	bf00      	nop
        }
    } while(!end_flag);
 801cd3a:	7afb      	ldrb	r3, [r7, #11]
 801cd3c:	f083 0301 	eor.w	r3, r3, #1
 801cd40:	b2db      	uxtb	r3, r3
 801cd42:	2b00      	cmp	r3, #0
 801cd44:	d181      	bne.n	801cc4a <lv_task_handler+0x3a>

    busy_time += lv_tick_elaps(handler_start);
 801cd46:	4b21      	ldr	r3, [pc, #132]	; (801cdcc <lv_task_handler+0x1bc>)
 801cd48:	681b      	ldr	r3, [r3, #0]
 801cd4a:	4618      	mov	r0, r3
 801cd4c:	f7fe fbc8 	bl	801b4e0 <lv_tick_elaps>
 801cd50:	4602      	mov	r2, r0
 801cd52:	4b23      	ldr	r3, [pc, #140]	; (801cde0 <lv_task_handler+0x1d0>)
 801cd54:	681b      	ldr	r3, [r3, #0]
 801cd56:	4413      	add	r3, r2
 801cd58:	4a21      	ldr	r2, [pc, #132]	; (801cde0 <lv_task_handler+0x1d0>)
 801cd5a:	6013      	str	r3, [r2, #0]
    uint32_t idle_period_time = lv_tick_elaps(idle_period_start);
 801cd5c:	4b21      	ldr	r3, [pc, #132]	; (801cde4 <lv_task_handler+0x1d4>)
 801cd5e:	681b      	ldr	r3, [r3, #0]
 801cd60:	4618      	mov	r0, r3
 801cd62:	f7fe fbbd 	bl	801b4e0 <lv_tick_elaps>
 801cd66:	6038      	str	r0, [r7, #0]
    if(idle_period_time >= IDLE_MEAS_PERIOD) {
 801cd68:	683b      	ldr	r3, [r7, #0]
 801cd6a:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 801cd6e:	d320      	bcc.n	801cdb2 <lv_task_handler+0x1a2>

        idle_last         = (uint32_t)((uint32_t)busy_time * 100) / IDLE_MEAS_PERIOD; /*Calculate the busy percentage*/
 801cd70:	4b1b      	ldr	r3, [pc, #108]	; (801cde0 <lv_task_handler+0x1d0>)
 801cd72:	681b      	ldr	r3, [r3, #0]
 801cd74:	2264      	movs	r2, #100	; 0x64
 801cd76:	fb02 f303 	mul.w	r3, r2, r3
 801cd7a:	4a1b      	ldr	r2, [pc, #108]	; (801cde8 <lv_task_handler+0x1d8>)
 801cd7c:	fba2 2303 	umull	r2, r3, r2, r3
 801cd80:	095b      	lsrs	r3, r3, #5
 801cd82:	b2da      	uxtb	r2, r3
 801cd84:	4b19      	ldr	r3, [pc, #100]	; (801cdec <lv_task_handler+0x1dc>)
 801cd86:	701a      	strb	r2, [r3, #0]
        idle_last         = idle_last > 100 ? 0 : 100 - idle_last;                    /*But we need idle time*/
 801cd88:	4b18      	ldr	r3, [pc, #96]	; (801cdec <lv_task_handler+0x1dc>)
 801cd8a:	781b      	ldrb	r3, [r3, #0]
 801cd8c:	2b64      	cmp	r3, #100	; 0x64
 801cd8e:	d805      	bhi.n	801cd9c <lv_task_handler+0x18c>
 801cd90:	4b16      	ldr	r3, [pc, #88]	; (801cdec <lv_task_handler+0x1dc>)
 801cd92:	781b      	ldrb	r3, [r3, #0]
 801cd94:	f1c3 0364 	rsb	r3, r3, #100	; 0x64
 801cd98:	b2db      	uxtb	r3, r3
 801cd9a:	e000      	b.n	801cd9e <lv_task_handler+0x18e>
 801cd9c:	2300      	movs	r3, #0
 801cd9e:	4a13      	ldr	r2, [pc, #76]	; (801cdec <lv_task_handler+0x1dc>)
 801cda0:	7013      	strb	r3, [r2, #0]
        busy_time         = 0;
 801cda2:	4b0f      	ldr	r3, [pc, #60]	; (801cde0 <lv_task_handler+0x1d0>)
 801cda4:	2200      	movs	r2, #0
 801cda6:	601a      	str	r2, [r3, #0]
        idle_period_start = lv_tick_get();
 801cda8:	f7fe fb80 	bl	801b4ac <lv_tick_get>
 801cdac:	4602      	mov	r2, r0
 801cdae:	4b0d      	ldr	r3, [pc, #52]	; (801cde4 <lv_task_handler+0x1d4>)
 801cdb0:	601a      	str	r2, [r3, #0]
    }

    task_handler_mutex = false; /*Release the mutex*/
 801cdb2:	4b04      	ldr	r3, [pc, #16]	; (801cdc4 <lv_task_handler+0x1b4>)
 801cdb4:	2200      	movs	r2, #0
 801cdb6:	701a      	strb	r2, [r3, #0]
 801cdb8:	e000      	b.n	801cdbc <lv_task_handler+0x1ac>
    if(task_handler_mutex) return;
 801cdba:	bf00      	nop

    LV_LOG_TRACE("lv_task_handler ready");
}
 801cdbc:	3710      	adds	r7, #16
 801cdbe:	46bd      	mov	sp, r7
 801cdc0:	bd80      	pop	{r7, pc}
 801cdc2:	bf00      	nop
 801cdc4:	2000c39c 	.word	0x2000c39c
 801cdc8:	2000c398 	.word	0x2000c398
 801cdcc:	2000c3a0 	.word	0x2000c3a0
 801cdd0:	2000c39a 	.word	0x2000c39a
 801cdd4:	2000c39b 	.word	0x2000c39b
 801cdd8:	2000df44 	.word	0x2000df44
 801cddc:	2000df84 	.word	0x2000df84
 801cde0:	2000c3a4 	.word	0x2000c3a4
 801cde4:	2000c3a8 	.word	0x2000c3a8
 801cde8:	10624dd3 	.word	0x10624dd3
 801cdec:	2000c399 	.word	0x2000c399

0801cdf0 <lv_task_create_basic>:
 * Create an "empty" task. It needs to initialzed with at least
 * `lv_task_set_cb` and `lv_task_set_period`
 * @return pointer to the craeted task
 */
lv_task_t * lv_task_create_basic(void)
{
 801cdf0:	b580      	push	{r7, lr}
 801cdf2:	b082      	sub	sp, #8
 801cdf4:	af00      	add	r7, sp, #0
    lv_task_t * new_task = NULL;
 801cdf6:	2300      	movs	r3, #0
 801cdf8:	607b      	str	r3, [r7, #4]
    lv_task_t * tmp;

    /*Create task lists in order of priority from high to low*/
    tmp = lv_ll_get_head(&LV_GC_ROOT(_lv_task_ll));
 801cdfa:	483b      	ldr	r0, [pc, #236]	; (801cee8 <lv_task_create_basic+0xf8>)
 801cdfc:	f7ff fbfe 	bl	801c5fc <lv_ll_get_head>
 801ce00:	6038      	str	r0, [r7, #0]

    /*It's the first task*/
    if(NULL == tmp) {
 801ce02:	683b      	ldr	r3, [r7, #0]
 801ce04:	2b00      	cmp	r3, #0
 801ce06:	d112      	bne.n	801ce2e <lv_task_create_basic+0x3e>
        new_task = lv_ll_ins_head(&LV_GC_ROOT(_lv_task_ll));
 801ce08:	4837      	ldr	r0, [pc, #220]	; (801cee8 <lv_task_create_basic+0xf8>)
 801ce0a:	f7ff fa95 	bl	801c338 <lv_ll_ins_head>
 801ce0e:	6078      	str	r0, [r7, #4]
        lv_mem_assert(new_task);
 801ce10:	687b      	ldr	r3, [r7, #4]
 801ce12:	2b00      	cmp	r3, #0
 801ce14:	d106      	bne.n	801ce24 <lv_task_create_basic+0x34>
 801ce16:	4b35      	ldr	r3, [pc, #212]	; (801ceec <lv_task_create_basic+0xfc>)
 801ce18:	22b0      	movs	r2, #176	; 0xb0
 801ce1a:	4935      	ldr	r1, [pc, #212]	; (801cef0 <lv_task_create_basic+0x100>)
 801ce1c:	2003      	movs	r0, #3
 801ce1e:	f7ff fcf5 	bl	801c80c <lv_log_add>
 801ce22:	e7fe      	b.n	801ce22 <lv_task_create_basic+0x32>
        if(new_task == NULL) return NULL;
 801ce24:	687b      	ldr	r3, [r7, #4]
 801ce26:	2b00      	cmp	r3, #0
 801ce28:	d13c      	bne.n	801cea4 <lv_task_create_basic+0xb4>
 801ce2a:	2300      	movs	r3, #0
 801ce2c:	e058      	b.n	801cee0 <lv_task_create_basic+0xf0>
    }
    /*Insert the new task to proper place according to its priority*/
    else {
        do {
            if(tmp->prio <= DEF_PRIO) {
 801ce2e:	683b      	ldr	r3, [r7, #0]
 801ce30:	7c1b      	ldrb	r3, [r3, #16]
 801ce32:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801ce36:	b2db      	uxtb	r3, r3
 801ce38:	2b03      	cmp	r3, #3
 801ce3a:	d813      	bhi.n	801ce64 <lv_task_create_basic+0x74>
                new_task = lv_ll_ins_prev(&LV_GC_ROOT(_lv_task_ll), tmp);
 801ce3c:	6839      	ldr	r1, [r7, #0]
 801ce3e:	482a      	ldr	r0, [pc, #168]	; (801cee8 <lv_task_create_basic+0xf8>)
 801ce40:	f7ff faae 	bl	801c3a0 <lv_ll_ins_prev>
 801ce44:	6078      	str	r0, [r7, #4]
                lv_mem_assert(new_task);
 801ce46:	687b      	ldr	r3, [r7, #4]
 801ce48:	2b00      	cmp	r3, #0
 801ce4a:	d106      	bne.n	801ce5a <lv_task_create_basic+0x6a>
 801ce4c:	4b27      	ldr	r3, [pc, #156]	; (801ceec <lv_task_create_basic+0xfc>)
 801ce4e:	22b8      	movs	r2, #184	; 0xb8
 801ce50:	4927      	ldr	r1, [pc, #156]	; (801cef0 <lv_task_create_basic+0x100>)
 801ce52:	2003      	movs	r0, #3
 801ce54:	f7ff fcda 	bl	801c80c <lv_log_add>
 801ce58:	e7fe      	b.n	801ce58 <lv_task_create_basic+0x68>
                if(new_task == NULL) return NULL;
 801ce5a:	687b      	ldr	r3, [r7, #4]
 801ce5c:	2b00      	cmp	r3, #0
 801ce5e:	d10a      	bne.n	801ce76 <lv_task_create_basic+0x86>
 801ce60:	2300      	movs	r3, #0
 801ce62:	e03d      	b.n	801cee0 <lv_task_create_basic+0xf0>
                break;
            }
            tmp = lv_ll_get_next(&LV_GC_ROOT(_lv_task_ll), tmp);
 801ce64:	6839      	ldr	r1, [r7, #0]
 801ce66:	4820      	ldr	r0, [pc, #128]	; (801cee8 <lv_task_create_basic+0xf8>)
 801ce68:	f7ff fbee 	bl	801c648 <lv_ll_get_next>
 801ce6c:	6038      	str	r0, [r7, #0]
        } while(tmp != NULL);
 801ce6e:	683b      	ldr	r3, [r7, #0]
 801ce70:	2b00      	cmp	r3, #0
 801ce72:	d1dc      	bne.n	801ce2e <lv_task_create_basic+0x3e>
 801ce74:	e000      	b.n	801ce78 <lv_task_create_basic+0x88>
                break;
 801ce76:	bf00      	nop

        /*Only too high priority tasks were found. Add the task to the end*/
        if(tmp == NULL) {
 801ce78:	683b      	ldr	r3, [r7, #0]
 801ce7a:	2b00      	cmp	r3, #0
 801ce7c:	d112      	bne.n	801cea4 <lv_task_create_basic+0xb4>
            new_task = lv_ll_ins_tail(&LV_GC_ROOT(_lv_task_ll));
 801ce7e:	481a      	ldr	r0, [pc, #104]	; (801cee8 <lv_task_create_basic+0xf8>)
 801ce80:	f7ff fad5 	bl	801c42e <lv_ll_ins_tail>
 801ce84:	6078      	str	r0, [r7, #4]
            lv_mem_assert(new_task);
 801ce86:	687b      	ldr	r3, [r7, #4]
 801ce88:	2b00      	cmp	r3, #0
 801ce8a:	d106      	bne.n	801ce9a <lv_task_create_basic+0xaa>
 801ce8c:	4b17      	ldr	r3, [pc, #92]	; (801ceec <lv_task_create_basic+0xfc>)
 801ce8e:	22c2      	movs	r2, #194	; 0xc2
 801ce90:	4917      	ldr	r1, [pc, #92]	; (801cef0 <lv_task_create_basic+0x100>)
 801ce92:	2003      	movs	r0, #3
 801ce94:	f7ff fcba 	bl	801c80c <lv_log_add>
 801ce98:	e7fe      	b.n	801ce98 <lv_task_create_basic+0xa8>
            if(new_task == NULL) return NULL;
 801ce9a:	687b      	ldr	r3, [r7, #4]
 801ce9c:	2b00      	cmp	r3, #0
 801ce9e:	d101      	bne.n	801cea4 <lv_task_create_basic+0xb4>
 801cea0:	2300      	movs	r3, #0
 801cea2:	e01d      	b.n	801cee0 <lv_task_create_basic+0xf0>
        }
    }

    new_task->period  = DEF_PERIOD;
 801cea4:	687b      	ldr	r3, [r7, #4]
 801cea6:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 801ceaa:	601a      	str	r2, [r3, #0]
    new_task->task_cb = NULL;
 801ceac:	687b      	ldr	r3, [r7, #4]
 801ceae:	2200      	movs	r2, #0
 801ceb0:	609a      	str	r2, [r3, #8]
    new_task->prio    = DEF_PRIO;
 801ceb2:	687a      	ldr	r2, [r7, #4]
 801ceb4:	7c13      	ldrb	r3, [r2, #16]
 801ceb6:	2103      	movs	r1, #3
 801ceb8:	f361 0302 	bfi	r3, r1, #0, #3
 801cebc:	7413      	strb	r3, [r2, #16]

    new_task->once     = 0;
 801cebe:	687a      	ldr	r2, [r7, #4]
 801cec0:	7c13      	ldrb	r3, [r2, #16]
 801cec2:	f36f 03c3 	bfc	r3, #3, #1
 801cec6:	7413      	strb	r3, [r2, #16]
    new_task->last_run = lv_tick_get();
 801cec8:	f7fe faf0 	bl	801b4ac <lv_tick_get>
 801cecc:	4602      	mov	r2, r0
 801cece:	687b      	ldr	r3, [r7, #4]
 801ced0:	605a      	str	r2, [r3, #4]

    new_task->user_data = NULL;
 801ced2:	687b      	ldr	r3, [r7, #4]
 801ced4:	2200      	movs	r2, #0
 801ced6:	60da      	str	r2, [r3, #12]

    task_created = true;
 801ced8:	4b06      	ldr	r3, [pc, #24]	; (801cef4 <lv_task_create_basic+0x104>)
 801ceda:	2201      	movs	r2, #1
 801cedc:	701a      	strb	r2, [r3, #0]

    return new_task;
 801cede:	687b      	ldr	r3, [r7, #4]
}
 801cee0:	4618      	mov	r0, r3
 801cee2:	3708      	adds	r7, #8
 801cee4:	46bd      	mov	sp, r7
 801cee6:	bd80      	pop	{r7, pc}
 801cee8:	2000df44 	.word	0x2000df44
 801ceec:	08028ee0 	.word	0x08028ee0
 801cef0:	08028ef0 	.word	0x08028ef0
 801cef4:	2000c39b 	.word	0x2000c39b

0801cef8 <lv_task_create>:
 * @param prio priority of the task (LV_TASK_PRIO_OFF means the task is stopped)
 * @param user_data custom parameter
 * @return pointer to the new task
 */
lv_task_t * lv_task_create(lv_task_cb_t task_cb, uint32_t period, lv_task_prio_t prio, void * user_data)
{
 801cef8:	b580      	push	{r7, lr}
 801cefa:	b086      	sub	sp, #24
 801cefc:	af00      	add	r7, sp, #0
 801cefe:	60f8      	str	r0, [r7, #12]
 801cf00:	60b9      	str	r1, [r7, #8]
 801cf02:	603b      	str	r3, [r7, #0]
 801cf04:	4613      	mov	r3, r2
 801cf06:	71fb      	strb	r3, [r7, #7]
    lv_task_t * new_task = lv_task_create_basic();
 801cf08:	f7ff ff72 	bl	801cdf0 <lv_task_create_basic>
 801cf0c:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_task);
 801cf0e:	697b      	ldr	r3, [r7, #20]
 801cf10:	2b00      	cmp	r3, #0
 801cf12:	d106      	bne.n	801cf22 <lv_task_create+0x2a>
 801cf14:	4b10      	ldr	r3, [pc, #64]	; (801cf58 <lv_task_create+0x60>)
 801cf16:	22e2      	movs	r2, #226	; 0xe2
 801cf18:	4910      	ldr	r1, [pc, #64]	; (801cf5c <lv_task_create+0x64>)
 801cf1a:	2003      	movs	r0, #3
 801cf1c:	f7ff fc76 	bl	801c80c <lv_log_add>
 801cf20:	e7fe      	b.n	801cf20 <lv_task_create+0x28>
    if(new_task == NULL) return NULL;
 801cf22:	697b      	ldr	r3, [r7, #20]
 801cf24:	2b00      	cmp	r3, #0
 801cf26:	d101      	bne.n	801cf2c <lv_task_create+0x34>
 801cf28:	2300      	movs	r3, #0
 801cf2a:	e010      	b.n	801cf4e <lv_task_create+0x56>

    lv_task_set_cb(new_task, task_cb);
 801cf2c:	68f9      	ldr	r1, [r7, #12]
 801cf2e:	6978      	ldr	r0, [r7, #20]
 801cf30:	f000 f816 	bl	801cf60 <lv_task_set_cb>
    lv_task_set_period(new_task, period);
 801cf34:	68b9      	ldr	r1, [r7, #8]
 801cf36:	6978      	ldr	r0, [r7, #20]
 801cf38:	f000 f888 	bl	801d04c <lv_task_set_period>
    lv_task_set_prio(new_task, prio);
 801cf3c:	79fb      	ldrb	r3, [r7, #7]
 801cf3e:	4619      	mov	r1, r3
 801cf40:	6978      	ldr	r0, [r7, #20]
 801cf42:	f000 f839 	bl	801cfb8 <lv_task_set_prio>
    new_task->user_data = user_data;
 801cf46:	697b      	ldr	r3, [r7, #20]
 801cf48:	683a      	ldr	r2, [r7, #0]
 801cf4a:	60da      	str	r2, [r3, #12]

    return new_task;
 801cf4c:	697b      	ldr	r3, [r7, #20]
}
 801cf4e:	4618      	mov	r0, r3
 801cf50:	3718      	adds	r7, #24
 801cf52:	46bd      	mov	sp, r7
 801cf54:	bd80      	pop	{r7, pc}
 801cf56:	bf00      	nop
 801cf58:	08028ee0 	.word	0x08028ee0
 801cf5c:	08028ef0 	.word	0x08028ef0

0801cf60 <lv_task_set_cb>:
 * Set the callback the task (the function to call periodically)
 * @param task pointer to a task
 * @param task_cb teh function to call periodically
 */
void lv_task_set_cb(lv_task_t * task, lv_task_cb_t task_cb)
{
 801cf60:	b480      	push	{r7}
 801cf62:	b083      	sub	sp, #12
 801cf64:	af00      	add	r7, sp, #0
 801cf66:	6078      	str	r0, [r7, #4]
 801cf68:	6039      	str	r1, [r7, #0]
    task->task_cb = task_cb;
 801cf6a:	687b      	ldr	r3, [r7, #4]
 801cf6c:	683a      	ldr	r2, [r7, #0]
 801cf6e:	609a      	str	r2, [r3, #8]
}
 801cf70:	bf00      	nop
 801cf72:	370c      	adds	r7, #12
 801cf74:	46bd      	mov	sp, r7
 801cf76:	f85d 7b04 	ldr.w	r7, [sp], #4
 801cf7a:	4770      	bx	lr

0801cf7c <lv_task_del>:
/**
 * Delete a lv_task
 * @param task pointer to task created by task
 */
void lv_task_del(lv_task_t * task)
{
 801cf7c:	b580      	push	{r7, lr}
 801cf7e:	b082      	sub	sp, #8
 801cf80:	af00      	add	r7, sp, #0
 801cf82:	6078      	str	r0, [r7, #4]
    lv_ll_rem(&LV_GC_ROOT(_lv_task_ll), task);
 801cf84:	6879      	ldr	r1, [r7, #4]
 801cf86:	4809      	ldr	r0, [pc, #36]	; (801cfac <lv_task_del+0x30>)
 801cf88:	f7ff fa8a 	bl	801c4a0 <lv_ll_rem>

    lv_mem_free(task);
 801cf8c:	6878      	ldr	r0, [r7, #4]
 801cf8e:	f7ff fcc9 	bl	801c924 <lv_mem_free>

    if(LV_GC_ROOT(_lv_task_act) == task) task_deleted = true; /*The active task was deleted*/
 801cf92:	4b07      	ldr	r3, [pc, #28]	; (801cfb0 <lv_task_del+0x34>)
 801cf94:	681b      	ldr	r3, [r3, #0]
 801cf96:	687a      	ldr	r2, [r7, #4]
 801cf98:	429a      	cmp	r2, r3
 801cf9a:	d102      	bne.n	801cfa2 <lv_task_del+0x26>
 801cf9c:	4b05      	ldr	r3, [pc, #20]	; (801cfb4 <lv_task_del+0x38>)
 801cf9e:	2201      	movs	r2, #1
 801cfa0:	701a      	strb	r2, [r3, #0]
}
 801cfa2:	bf00      	nop
 801cfa4:	3708      	adds	r7, #8
 801cfa6:	46bd      	mov	sp, r7
 801cfa8:	bd80      	pop	{r7, pc}
 801cfaa:	bf00      	nop
 801cfac:	2000df44 	.word	0x2000df44
 801cfb0:	2000df84 	.word	0x2000df84
 801cfb4:	2000c39a 	.word	0x2000c39a

0801cfb8 <lv_task_set_prio>:
 * Set new priority for a lv_task
 * @param task pointer to a lv_task
 * @param prio the new priority
 */
void lv_task_set_prio(lv_task_t * task, lv_task_prio_t prio)
{
 801cfb8:	b580      	push	{r7, lr}
 801cfba:	b084      	sub	sp, #16
 801cfbc:	af00      	add	r7, sp, #0
 801cfbe:	6078      	str	r0, [r7, #4]
 801cfc0:	460b      	mov	r3, r1
 801cfc2:	70fb      	strb	r3, [r7, #3]
    if(task->prio == prio) return;
 801cfc4:	687b      	ldr	r3, [r7, #4]
 801cfc6:	7c1b      	ldrb	r3, [r3, #16]
 801cfc8:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801cfcc:	b2db      	uxtb	r3, r3
 801cfce:	461a      	mov	r2, r3
 801cfd0:	78fb      	ldrb	r3, [r7, #3]
 801cfd2:	429a      	cmp	r2, r3
 801cfd4:	d033      	beq.n	801d03e <lv_task_set_prio+0x86>

    /*Find the tasks with new priority*/
    lv_task_t * i;
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
 801cfd6:	481c      	ldr	r0, [pc, #112]	; (801d048 <lv_task_set_prio+0x90>)
 801cfd8:	f7ff fb10 	bl	801c5fc <lv_ll_get_head>
 801cfdc:	60f8      	str	r0, [r7, #12]
 801cfde:	e017      	b.n	801d010 <lv_task_set_prio+0x58>
    {
        if(i->prio <= prio) {
 801cfe0:	68fb      	ldr	r3, [r7, #12]
 801cfe2:	7c1b      	ldrb	r3, [r3, #16]
 801cfe4:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801cfe8:	b2db      	uxtb	r3, r3
 801cfea:	461a      	mov	r2, r3
 801cfec:	78fb      	ldrb	r3, [r7, #3]
 801cfee:	429a      	cmp	r2, r3
 801cff0:	dc09      	bgt.n	801d006 <lv_task_set_prio+0x4e>
            if(i != task) lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, i);
 801cff2:	68fa      	ldr	r2, [r7, #12]
 801cff4:	687b      	ldr	r3, [r7, #4]
 801cff6:	429a      	cmp	r2, r3
 801cff8:	d00e      	beq.n	801d018 <lv_task_set_prio+0x60>
 801cffa:	68fa      	ldr	r2, [r7, #12]
 801cffc:	6879      	ldr	r1, [r7, #4]
 801cffe:	4812      	ldr	r0, [pc, #72]	; (801d048 <lv_task_set_prio+0x90>)
 801d000:	f7ff fb55 	bl	801c6ae <lv_ll_move_before>
            break;
 801d004:	e008      	b.n	801d018 <lv_task_set_prio+0x60>
    LV_LL_READ(LV_GC_ROOT(_lv_task_ll), i)
 801d006:	68f9      	ldr	r1, [r7, #12]
 801d008:	480f      	ldr	r0, [pc, #60]	; (801d048 <lv_task_set_prio+0x90>)
 801d00a:	f7ff fb1d 	bl	801c648 <lv_ll_get_next>
 801d00e:	60f8      	str	r0, [r7, #12]
 801d010:	68fb      	ldr	r3, [r7, #12]
 801d012:	2b00      	cmp	r3, #0
 801d014:	d1e4      	bne.n	801cfe0 <lv_task_set_prio+0x28>
 801d016:	e000      	b.n	801d01a <lv_task_set_prio+0x62>
            break;
 801d018:	bf00      	nop
        }
    }

    /*There was no such a low priority so far then add the node to the tail*/
    if(i == NULL) {
 801d01a:	68fb      	ldr	r3, [r7, #12]
 801d01c:	2b00      	cmp	r3, #0
 801d01e:	d104      	bne.n	801d02a <lv_task_set_prio+0x72>
        lv_ll_move_before(&LV_GC_ROOT(_lv_task_ll), task, NULL);
 801d020:	2200      	movs	r2, #0
 801d022:	6879      	ldr	r1, [r7, #4]
 801d024:	4808      	ldr	r0, [pc, #32]	; (801d048 <lv_task_set_prio+0x90>)
 801d026:	f7ff fb42 	bl	801c6ae <lv_ll_move_before>
    }

    task->prio = prio;
 801d02a:	78fb      	ldrb	r3, [r7, #3]
 801d02c:	f003 0307 	and.w	r3, r3, #7
 801d030:	b2d9      	uxtb	r1, r3
 801d032:	687a      	ldr	r2, [r7, #4]
 801d034:	7c13      	ldrb	r3, [r2, #16]
 801d036:	f361 0302 	bfi	r3, r1, #0, #3
 801d03a:	7413      	strb	r3, [r2, #16]
 801d03c:	e000      	b.n	801d040 <lv_task_set_prio+0x88>
    if(task->prio == prio) return;
 801d03e:	bf00      	nop
}
 801d040:	3710      	adds	r7, #16
 801d042:	46bd      	mov	sp, r7
 801d044:	bd80      	pop	{r7, pc}
 801d046:	bf00      	nop
 801d048:	2000df44 	.word	0x2000df44

0801d04c <lv_task_set_period>:
 * Set new period for a lv_task
 * @param task pointer to a lv_task
 * @param period the new period
 */
void lv_task_set_period(lv_task_t * task, uint32_t period)
{
 801d04c:	b480      	push	{r7}
 801d04e:	b083      	sub	sp, #12
 801d050:	af00      	add	r7, sp, #0
 801d052:	6078      	str	r0, [r7, #4]
 801d054:	6039      	str	r1, [r7, #0]
    task->period = period;
 801d056:	687b      	ldr	r3, [r7, #4]
 801d058:	683a      	ldr	r2, [r7, #0]
 801d05a:	601a      	str	r2, [r3, #0]
}
 801d05c:	bf00      	nop
 801d05e:	370c      	adds	r7, #12
 801d060:	46bd      	mov	sp, r7
 801d062:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d066:	4770      	bx	lr

0801d068 <lv_task_ready>:
/**
 * Make a lv_task ready. It will not wait its period.
 * @param task pointer to a lv_task.
 */
void lv_task_ready(lv_task_t * task)
{
 801d068:	b580      	push	{r7, lr}
 801d06a:	b082      	sub	sp, #8
 801d06c:	af00      	add	r7, sp, #0
 801d06e:	6078      	str	r0, [r7, #4]
    task->last_run = lv_tick_get() - task->period - 1;
 801d070:	f7fe fa1c 	bl	801b4ac <lv_tick_get>
 801d074:	4602      	mov	r2, r0
 801d076:	687b      	ldr	r3, [r7, #4]
 801d078:	681b      	ldr	r3, [r3, #0]
 801d07a:	1ad3      	subs	r3, r2, r3
 801d07c:	1e5a      	subs	r2, r3, #1
 801d07e:	687b      	ldr	r3, [r7, #4]
 801d080:	605a      	str	r2, [r3, #4]
}
 801d082:	bf00      	nop
 801d084:	3708      	adds	r7, #8
 801d086:	46bd      	mov	sp, r7
 801d088:	bd80      	pop	{r7, pc}
	...

0801d08c <lv_task_enable>:
/**
 * Enable or disable the whole lv_task handling
 * @param en: true: lv_task handling is running, false: lv_task handling is suspended
 */
void lv_task_enable(bool en)
{
 801d08c:	b480      	push	{r7}
 801d08e:	b083      	sub	sp, #12
 801d090:	af00      	add	r7, sp, #0
 801d092:	4603      	mov	r3, r0
 801d094:	71fb      	strb	r3, [r7, #7]
    lv_task_run = en;
 801d096:	4a04      	ldr	r2, [pc, #16]	; (801d0a8 <lv_task_enable+0x1c>)
 801d098:	79fb      	ldrb	r3, [r7, #7]
 801d09a:	7013      	strb	r3, [r2, #0]
}
 801d09c:	bf00      	nop
 801d09e:	370c      	adds	r7, #12
 801d0a0:	46bd      	mov	sp, r7
 801d0a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d0a6:	4770      	bx	lr
 801d0a8:	2000c398 	.word	0x2000c398

0801d0ac <lv_task_exec>:
 * Execute task if its the priority is appropriate
 * @param task pointer to lv_task
 * @return true: execute, false: not executed
 */
static bool lv_task_exec(lv_task_t * task)
{
 801d0ac:	b580      	push	{r7, lr}
 801d0ae:	b084      	sub	sp, #16
 801d0b0:	af00      	add	r7, sp, #0
 801d0b2:	6078      	str	r0, [r7, #4]
    bool exec = false;
 801d0b4:	2300      	movs	r3, #0
 801d0b6:	73fb      	strb	r3, [r7, #15]

    /*Execute if at least 'period' time elapsed*/
    uint32_t elp = lv_tick_elaps(task->last_run);
 801d0b8:	687b      	ldr	r3, [r7, #4]
 801d0ba:	685b      	ldr	r3, [r3, #4]
 801d0bc:	4618      	mov	r0, r3
 801d0be:	f7fe fa0f 	bl	801b4e0 <lv_tick_elaps>
 801d0c2:	60b8      	str	r0, [r7, #8]
    if(elp >= task->period) {
 801d0c4:	687b      	ldr	r3, [r7, #4]
 801d0c6:	681b      	ldr	r3, [r3, #0]
 801d0c8:	68ba      	ldr	r2, [r7, #8]
 801d0ca:	429a      	cmp	r2, r3
 801d0cc:	d325      	bcc.n	801d11a <lv_task_exec+0x6e>
        task->last_run = lv_tick_get();
 801d0ce:	f7fe f9ed 	bl	801b4ac <lv_tick_get>
 801d0d2:	4602      	mov	r2, r0
 801d0d4:	687b      	ldr	r3, [r7, #4]
 801d0d6:	605a      	str	r2, [r3, #4]
        task_deleted   = false;
 801d0d8:	4b12      	ldr	r3, [pc, #72]	; (801d124 <lv_task_exec+0x78>)
 801d0da:	2200      	movs	r2, #0
 801d0dc:	701a      	strb	r2, [r3, #0]
        task_created   = false;
 801d0de:	4b12      	ldr	r3, [pc, #72]	; (801d128 <lv_task_exec+0x7c>)
 801d0e0:	2200      	movs	r2, #0
 801d0e2:	701a      	strb	r2, [r3, #0]
        if(task->task_cb) task->task_cb(task);
 801d0e4:	687b      	ldr	r3, [r7, #4]
 801d0e6:	689b      	ldr	r3, [r3, #8]
 801d0e8:	2b00      	cmp	r3, #0
 801d0ea:	d003      	beq.n	801d0f4 <lv_task_exec+0x48>
 801d0ec:	687b      	ldr	r3, [r7, #4]
 801d0ee:	689b      	ldr	r3, [r3, #8]
 801d0f0:	6878      	ldr	r0, [r7, #4]
 801d0f2:	4798      	blx	r3

        /*Delete if it was a one shot lv_task*/
        if(task_deleted == false) { /*The task might be deleted by itself as well*/
 801d0f4:	4b0b      	ldr	r3, [pc, #44]	; (801d124 <lv_task_exec+0x78>)
 801d0f6:	781b      	ldrb	r3, [r3, #0]
 801d0f8:	f083 0301 	eor.w	r3, r3, #1
 801d0fc:	b2db      	uxtb	r3, r3
 801d0fe:	2b00      	cmp	r3, #0
 801d100:	d009      	beq.n	801d116 <lv_task_exec+0x6a>
            if(task->once != 0) {
 801d102:	687b      	ldr	r3, [r7, #4]
 801d104:	7c1b      	ldrb	r3, [r3, #16]
 801d106:	f003 0308 	and.w	r3, r3, #8
 801d10a:	b2db      	uxtb	r3, r3
 801d10c:	2b00      	cmp	r3, #0
 801d10e:	d002      	beq.n	801d116 <lv_task_exec+0x6a>
                lv_task_del(task);
 801d110:	6878      	ldr	r0, [r7, #4]
 801d112:	f7ff ff33 	bl	801cf7c <lv_task_del>
            }
        }
        exec = true;
 801d116:	2301      	movs	r3, #1
 801d118:	73fb      	strb	r3, [r7, #15]
    }

    return exec;
 801d11a:	7bfb      	ldrb	r3, [r7, #15]
}
 801d11c:	4618      	mov	r0, r3
 801d11e:	3710      	adds	r7, #16
 801d120:	46bd      	mov	sp, r7
 801d122:	bd80      	pop	{r7, pc}
 801d124:	2000c39a 	.word	0x2000c39a
 801d128:	2000c39b 	.word	0x2000c39b

0801d12c <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 801d12c:	b480      	push	{r7}
 801d12e:	b083      	sub	sp, #12
 801d130:	af00      	add	r7, sp, #0
 801d132:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 801d134:	687b      	ldr	r3, [r7, #4]
 801d136:	7a1b      	ldrb	r3, [r3, #8]
}
 801d138:	4618      	mov	r0, r3
 801d13a:	370c      	adds	r7, #12
 801d13c:	46bd      	mov	sp, r7
 801d13e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d142:	4770      	bx	lr

0801d144 <lv_txt_get_size>:
 * @param max_width max with of the text (break the lines to fit this size) Set CORD_MAX to avoid
 * line breaks
 */
void lv_txt_get_size(lv_point_t * size_res, const char * text, const lv_font_t * font, lv_coord_t letter_space,
                     lv_coord_t line_space, lv_coord_t max_width, lv_txt_flag_t flag)
{
 801d144:	b580      	push	{r7, lr}
 801d146:	b08a      	sub	sp, #40	; 0x28
 801d148:	af02      	add	r7, sp, #8
 801d14a:	60f8      	str	r0, [r7, #12]
 801d14c:	60b9      	str	r1, [r7, #8]
 801d14e:	607a      	str	r2, [r7, #4]
 801d150:	807b      	strh	r3, [r7, #2]
    size_res->x = 0;
 801d152:	68fb      	ldr	r3, [r7, #12]
 801d154:	2200      	movs	r2, #0
 801d156:	801a      	strh	r2, [r3, #0]
    size_res->y = 0;
 801d158:	68fb      	ldr	r3, [r7, #12]
 801d15a:	2200      	movs	r2, #0
 801d15c:	805a      	strh	r2, [r3, #2]

    if(text == NULL) return;
 801d15e:	68bb      	ldr	r3, [r7, #8]
 801d160:	2b00      	cmp	r3, #0
 801d162:	f000 809a 	beq.w	801d29a <lv_txt_get_size+0x156>
    if(font == NULL) return;
 801d166:	687b      	ldr	r3, [r7, #4]
 801d168:	2b00      	cmp	r3, #0
 801d16a:	f000 8098 	beq.w	801d29e <lv_txt_get_size+0x15a>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 801d16e:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801d172:	f003 0302 	and.w	r3, r3, #2
 801d176:	2b00      	cmp	r3, #0
 801d178:	d002      	beq.n	801d180 <lv_txt_get_size+0x3c>
 801d17a:	f647 4318 	movw	r3, #31768	; 0x7c18
 801d17e:	85bb      	strh	r3, [r7, #44]	; 0x2c

    uint32_t line_start     = 0;
 801d180:	2300      	movs	r3, #0
 801d182:	61fb      	str	r3, [r7, #28]
    uint32_t new_line_start = 0;
 801d184:	2300      	movs	r3, #0
 801d186:	61bb      	str	r3, [r7, #24]
    lv_coord_t act_line_length;
    uint8_t letter_height = lv_font_get_line_height(font);
 801d188:	6878      	ldr	r0, [r7, #4]
 801d18a:	f7ff ffcf 	bl	801d12c <lv_font_get_line_height>
 801d18e:	4603      	mov	r3, r0
 801d190:	75fb      	strb	r3, [r7, #23]

    /*Calc. the height and longest line*/
    while(text[line_start] != '\0') {
 801d192:	e048      	b.n	801d226 <lv_txt_get_size+0xe2>
        new_line_start += lv_txt_get_next_line(&text[line_start], font, letter_space, max_width, flag);
 801d194:	68ba      	ldr	r2, [r7, #8]
 801d196:	69fb      	ldr	r3, [r7, #28]
 801d198:	18d0      	adds	r0, r2, r3
 801d19a:	f9b7 102c 	ldrsh.w	r1, [r7, #44]	; 0x2c
 801d19e:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801d1a2:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801d1a6:	9300      	str	r3, [sp, #0]
 801d1a8:	460b      	mov	r3, r1
 801d1aa:	6879      	ldr	r1, [r7, #4]
 801d1ac:	f000 f87c 	bl	801d2a8 <lv_txt_get_next_line>
 801d1b0:	4603      	mov	r3, r0
 801d1b2:	461a      	mov	r2, r3
 801d1b4:	69bb      	ldr	r3, [r7, #24]
 801d1b6:	4413      	add	r3, r2
 801d1b8:	61bb      	str	r3, [r7, #24]
        size_res->y += letter_height;
 801d1ba:	68fb      	ldr	r3, [r7, #12]
 801d1bc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d1c0:	b29a      	uxth	r2, r3
 801d1c2:	7dfb      	ldrb	r3, [r7, #23]
 801d1c4:	b29b      	uxth	r3, r3
 801d1c6:	4413      	add	r3, r2
 801d1c8:	b29b      	uxth	r3, r3
 801d1ca:	b21a      	sxth	r2, r3
 801d1cc:	68fb      	ldr	r3, [r7, #12]
 801d1ce:	805a      	strh	r2, [r3, #2]
        size_res->y += line_space;
 801d1d0:	68fb      	ldr	r3, [r7, #12]
 801d1d2:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d1d6:	b29a      	uxth	r2, r3
 801d1d8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801d1da:	4413      	add	r3, r2
 801d1dc:	b29b      	uxth	r3, r3
 801d1de:	b21a      	sxth	r2, r3
 801d1e0:	68fb      	ldr	r3, [r7, #12]
 801d1e2:	805a      	strh	r2, [r3, #2]

        /*Calculate the the longest line*/
        act_line_length = lv_txt_get_width(&text[line_start], new_line_start - line_start, font, letter_space, flag);
 801d1e4:	68ba      	ldr	r2, [r7, #8]
 801d1e6:	69fb      	ldr	r3, [r7, #28]
 801d1e8:	18d0      	adds	r0, r2, r3
 801d1ea:	69bb      	ldr	r3, [r7, #24]
 801d1ec:	b29a      	uxth	r2, r3
 801d1ee:	69fb      	ldr	r3, [r7, #28]
 801d1f0:	b29b      	uxth	r3, r3
 801d1f2:	1ad3      	subs	r3, r2, r3
 801d1f4:	b299      	uxth	r1, r3
 801d1f6:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801d1fa:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801d1fe:	9300      	str	r3, [sp, #0]
 801d200:	4613      	mov	r3, r2
 801d202:	687a      	ldr	r2, [r7, #4]
 801d204:	f000 f902 	bl	801d40c <lv_txt_get_width>
 801d208:	4603      	mov	r3, r0
 801d20a:	82bb      	strh	r3, [r7, #20]

        size_res->x = LV_MATH_MAX(act_line_length, size_res->x);
 801d20c:	68fb      	ldr	r3, [r7, #12]
 801d20e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801d212:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 801d216:	4293      	cmp	r3, r2
 801d218:	bfb8      	it	lt
 801d21a:	4613      	movlt	r3, r2
 801d21c:	b21a      	sxth	r2, r3
 801d21e:	68fb      	ldr	r3, [r7, #12]
 801d220:	801a      	strh	r2, [r3, #0]
        line_start  = new_line_start;
 801d222:	69bb      	ldr	r3, [r7, #24]
 801d224:	61fb      	str	r3, [r7, #28]
    while(text[line_start] != '\0') {
 801d226:	68ba      	ldr	r2, [r7, #8]
 801d228:	69fb      	ldr	r3, [r7, #28]
 801d22a:	4413      	add	r3, r2
 801d22c:	781b      	ldrb	r3, [r3, #0]
 801d22e:	2b00      	cmp	r3, #0
 801d230:	d1b0      	bne.n	801d194 <lv_txt_get_size+0x50>
    }

    /*Ma ke the text one line taller if the last character is '\n' or '\r'*/
    if((line_start != 0) && (text[line_start - 1] == '\n' || text[line_start - 1] == '\r')) {
 801d232:	69fb      	ldr	r3, [r7, #28]
 801d234:	2b00      	cmp	r3, #0
 801d236:	d01b      	beq.n	801d270 <lv_txt_get_size+0x12c>
 801d238:	69fb      	ldr	r3, [r7, #28]
 801d23a:	3b01      	subs	r3, #1
 801d23c:	68ba      	ldr	r2, [r7, #8]
 801d23e:	4413      	add	r3, r2
 801d240:	781b      	ldrb	r3, [r3, #0]
 801d242:	2b0a      	cmp	r3, #10
 801d244:	d006      	beq.n	801d254 <lv_txt_get_size+0x110>
 801d246:	69fb      	ldr	r3, [r7, #28]
 801d248:	3b01      	subs	r3, #1
 801d24a:	68ba      	ldr	r2, [r7, #8]
 801d24c:	4413      	add	r3, r2
 801d24e:	781b      	ldrb	r3, [r3, #0]
 801d250:	2b0d      	cmp	r3, #13
 801d252:	d10d      	bne.n	801d270 <lv_txt_get_size+0x12c>
        size_res->y += letter_height + line_space;
 801d254:	68fb      	ldr	r3, [r7, #12]
 801d256:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d25a:	b29a      	uxth	r2, r3
 801d25c:	7dfb      	ldrb	r3, [r7, #23]
 801d25e:	b299      	uxth	r1, r3
 801d260:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801d262:	440b      	add	r3, r1
 801d264:	b29b      	uxth	r3, r3
 801d266:	4413      	add	r3, r2
 801d268:	b29b      	uxth	r3, r3
 801d26a:	b21a      	sxth	r2, r3
 801d26c:	68fb      	ldr	r3, [r7, #12]
 801d26e:	805a      	strh	r2, [r3, #2]
    }

    /*Correction with the last line space or set the height manually if the text is empty*/
    if(size_res->y == 0)
 801d270:	68fb      	ldr	r3, [r7, #12]
 801d272:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d276:	2b00      	cmp	r3, #0
 801d278:	d104      	bne.n	801d284 <lv_txt_get_size+0x140>
        size_res->y = letter_height;
 801d27a:	7dfb      	ldrb	r3, [r7, #23]
 801d27c:	b21a      	sxth	r2, r3
 801d27e:	68fb      	ldr	r3, [r7, #12]
 801d280:	805a      	strh	r2, [r3, #2]
 801d282:	e00d      	b.n	801d2a0 <lv_txt_get_size+0x15c>
    else
        size_res->y -= line_space;
 801d284:	68fb      	ldr	r3, [r7, #12]
 801d286:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801d28a:	b29a      	uxth	r2, r3
 801d28c:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801d28e:	1ad3      	subs	r3, r2, r3
 801d290:	b29b      	uxth	r3, r3
 801d292:	b21a      	sxth	r2, r3
 801d294:	68fb      	ldr	r3, [r7, #12]
 801d296:	805a      	strh	r2, [r3, #2]
 801d298:	e002      	b.n	801d2a0 <lv_txt_get_size+0x15c>
    if(text == NULL) return;
 801d29a:	bf00      	nop
 801d29c:	e000      	b.n	801d2a0 <lv_txt_get_size+0x15c>
    if(font == NULL) return;
 801d29e:	bf00      	nop
}
 801d2a0:	3720      	adds	r7, #32
 801d2a2:	46bd      	mov	sp, r7
 801d2a4:	bd80      	pop	{r7, pc}
	...

0801d2a8 <lv_txt_get_next_line>:
 * @param flags settings for the text from 'txt_flag_type' enum
 * @return the index of the first char of the new line (in byte index not letter index. With UTF-8 they are different)
 */
uint16_t lv_txt_get_next_line(const char * txt, const lv_font_t * font, lv_coord_t letter_space, lv_coord_t max_width,
                              lv_txt_flag_t flag)
{
 801d2a8:	b580      	push	{r7, lr}
 801d2aa:	b08c      	sub	sp, #48	; 0x30
 801d2ac:	af00      	add	r7, sp, #0
 801d2ae:	60f8      	str	r0, [r7, #12]
 801d2b0:	60b9      	str	r1, [r7, #8]
 801d2b2:	4611      	mov	r1, r2
 801d2b4:	461a      	mov	r2, r3
 801d2b6:	460b      	mov	r3, r1
 801d2b8:	80fb      	strh	r3, [r7, #6]
 801d2ba:	4613      	mov	r3, r2
 801d2bc:	80bb      	strh	r3, [r7, #4]
    if(txt == NULL) return 0;
 801d2be:	68fb      	ldr	r3, [r7, #12]
 801d2c0:	2b00      	cmp	r3, #0
 801d2c2:	d101      	bne.n	801d2c8 <lv_txt_get_next_line+0x20>
 801d2c4:	2300      	movs	r3, #0
 801d2c6:	e099      	b.n	801d3fc <lv_txt_get_next_line+0x154>
    if(font == NULL) return 0;
 801d2c8:	68bb      	ldr	r3, [r7, #8]
 801d2ca:	2b00      	cmp	r3, #0
 801d2cc:	d101      	bne.n	801d2d2 <lv_txt_get_next_line+0x2a>
 801d2ce:	2300      	movs	r3, #0
 801d2d0:	e094      	b.n	801d3fc <lv_txt_get_next_line+0x154>

    if(flag & LV_TXT_FLAG_EXPAND) max_width = LV_COORD_MAX;
 801d2d2:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801d2d6:	f003 0302 	and.w	r3, r3, #2
 801d2da:	2b00      	cmp	r3, #0
 801d2dc:	d002      	beq.n	801d2e4 <lv_txt_get_next_line+0x3c>
 801d2de:	f647 4318 	movw	r3, #31768	; 0x7c18
 801d2e2:	80bb      	strh	r3, [r7, #4]

    uint32_t i                   = 0;
 801d2e4:	2300      	movs	r3, #0
 801d2e6:	61bb      	str	r3, [r7, #24]
    uint32_t i_next              = 0;
 801d2e8:	2300      	movs	r3, #0
 801d2ea:	617b      	str	r3, [r7, #20]
    lv_coord_t cur_w             = 0;
 801d2ec:	2300      	movs	r3, #0
 801d2ee:	85fb      	strh	r3, [r7, #46]	; 0x2e
    uint32_t last_break          = NO_BREAK_FOUND;
 801d2f0:	f04f 33ff 	mov.w	r3, #4294967295
 801d2f4:	62bb      	str	r3, [r7, #40]	; 0x28
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 801d2f6:	2300      	movs	r3, #0
 801d2f8:	74fb      	strb	r3, [r7, #19]
    uint32_t letter_w;
    uint32_t letter      = 0;
 801d2fa:	2300      	movs	r3, #0
 801d2fc:	623b      	str	r3, [r7, #32]
    uint32_t letter_next = 0;
 801d2fe:	2300      	movs	r3, #0
 801d300:	627b      	str	r3, [r7, #36]	; 0x24

    letter_next = lv_txt_encoded_next(txt, &i_next);
 801d302:	4b40      	ldr	r3, [pc, #256]	; (801d404 <lv_txt_get_next_line+0x15c>)
 801d304:	681b      	ldr	r3, [r3, #0]
 801d306:	f107 0214 	add.w	r2, r7, #20
 801d30a:	4611      	mov	r1, r2
 801d30c:	68f8      	ldr	r0, [r7, #12]
 801d30e:	4798      	blx	r3
 801d310:	6278      	str	r0, [r7, #36]	; 0x24

    while(txt[i] != '\0') {
 801d312:	e06b      	b.n	801d3ec <lv_txt_get_next_line+0x144>
        letter      = letter_next;
 801d314:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d316:	623b      	str	r3, [r7, #32]
        i           = i_next;
 801d318:	697b      	ldr	r3, [r7, #20]
 801d31a:	61bb      	str	r3, [r7, #24]
        letter_next = lv_txt_encoded_next(txt, &i_next);
 801d31c:	4b39      	ldr	r3, [pc, #228]	; (801d404 <lv_txt_get_next_line+0x15c>)
 801d31e:	681b      	ldr	r3, [r3, #0]
 801d320:	f107 0214 	add.w	r2, r7, #20
 801d324:	4611      	mov	r1, r2
 801d326:	68f8      	ldr	r0, [r7, #12]
 801d328:	4798      	blx	r3
 801d32a:	6278      	str	r0, [r7, #36]	; 0x24

        /*Handle the recolor command*/
        if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 801d32c:	f897 3038 	ldrb.w	r3, [r7, #56]	; 0x38
 801d330:	f003 0301 	and.w	r3, r3, #1
 801d334:	2b00      	cmp	r3, #0
 801d336:	d009      	beq.n	801d34c <lv_txt_get_next_line+0xa4>
            if(lv_txt_is_cmd(&cmd_state, letter) != false) {
 801d338:	f107 0313 	add.w	r3, r7, #19
 801d33c:	6a39      	ldr	r1, [r7, #32]
 801d33e:	4618      	mov	r0, r3
 801d340:	f000 f8ce 	bl	801d4e0 <lv_txt_is_cmd>
 801d344:	4603      	mov	r3, r0
 801d346:	2b00      	cmp	r3, #0
 801d348:	d000      	beq.n	801d34c <lv_txt_get_next_line+0xa4>
                continue; /*Skip the letter is it is part of a command*/
 801d34a:	e04f      	b.n	801d3ec <lv_txt_get_next_line+0x144>
            }
        }

        /*Check for new line chars*/
        if(letter == '\n' || letter == '\r') {
 801d34c:	6a3b      	ldr	r3, [r7, #32]
 801d34e:	2b0a      	cmp	r3, #10
 801d350:	d002      	beq.n	801d358 <lv_txt_get_next_line+0xb0>
 801d352:	6a3b      	ldr	r3, [r7, #32]
 801d354:	2b0d      	cmp	r3, #13
 801d356:	d10b      	bne.n	801d370 <lv_txt_get_next_line+0xc8>
            /*Return with the first letter of the next line*/
            if(letter == '\r' && letter_next == '\n')
 801d358:	6a3b      	ldr	r3, [r7, #32]
 801d35a:	2b0d      	cmp	r3, #13
 801d35c:	d105      	bne.n	801d36a <lv_txt_get_next_line+0xc2>
 801d35e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801d360:	2b0a      	cmp	r3, #10
 801d362:	d102      	bne.n	801d36a <lv_txt_get_next_line+0xc2>
                return i_next;
 801d364:	697b      	ldr	r3, [r7, #20]
 801d366:	b29b      	uxth	r3, r3
 801d368:	e048      	b.n	801d3fc <lv_txt_get_next_line+0x154>
            else
                return i;
 801d36a:	69bb      	ldr	r3, [r7, #24]
 801d36c:	b29b      	uxth	r3, r3
 801d36e:	e045      	b.n	801d3fc <lv_txt_get_next_line+0x154>
        } else { /*Check the actual length*/
            letter_w = lv_font_get_glyph_width(font, letter, letter_next);
 801d370:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 801d372:	6a39      	ldr	r1, [r7, #32]
 801d374:	68b8      	ldr	r0, [r7, #8]
 801d376:	f7fd fabf 	bl	801a8f8 <lv_font_get_glyph_width>
 801d37a:	4603      	mov	r3, r0
 801d37c:	61fb      	str	r3, [r7, #28]
            cur_w += letter_w;
 801d37e:	69fb      	ldr	r3, [r7, #28]
 801d380:	b29a      	uxth	r2, r3
 801d382:	8dfb      	ldrh	r3, [r7, #46]	; 0x2e
 801d384:	4413      	add	r3, r2
 801d386:	b29b      	uxth	r3, r3
 801d388:	85fb      	strh	r3, [r7, #46]	; 0x2e

            /*If the txt is too long then finish, this is the line end*/
            if(cur_w > max_width) {
 801d38a:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 801d38e:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801d392:	429a      	cmp	r2, r3
 801d394:	dd1a      	ble.n	801d3cc <lv_txt_get_next_line+0x124>
                /*If a break character was already found break there*/
                if(last_break != NO_BREAK_FOUND) {
 801d396:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d398:	f1b3 3fff 	cmp.w	r3, #4294967295
 801d39c:	d002      	beq.n	801d3a4 <lv_txt_get_next_line+0xfc>
                    i = last_break;
 801d39e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801d3a0:	61bb      	str	r3, [r7, #24]
 801d3a2:	e006      	b.n	801d3b2 <lv_txt_get_next_line+0x10a>
                } else {
                    /* Now this character is out of the area so it will be first character of the next line*/
                    /* But 'i' already points to the next character (because of lv_txt_utf8_next) step beck one*/
                    lv_txt_encoded_prev(txt, &i);
 801d3a4:	4b18      	ldr	r3, [pc, #96]	; (801d408 <lv_txt_get_next_line+0x160>)
 801d3a6:	681b      	ldr	r3, [r3, #0]
 801d3a8:	f107 0218 	add.w	r2, r7, #24
 801d3ac:	4611      	mov	r1, r2
 801d3ae:	68f8      	ldr	r0, [r7, #12]
 801d3b0:	4798      	blx	r3
                }

                /* Do not let to return without doing nothing.
                 * Find at least one character (Avoid infinite loop )*/
                if(i == 0) lv_txt_encoded_next(txt, &i);
 801d3b2:	69bb      	ldr	r3, [r7, #24]
 801d3b4:	2b00      	cmp	r3, #0
 801d3b6:	d106      	bne.n	801d3c6 <lv_txt_get_next_line+0x11e>
 801d3b8:	4b12      	ldr	r3, [pc, #72]	; (801d404 <lv_txt_get_next_line+0x15c>)
 801d3ba:	681b      	ldr	r3, [r3, #0]
 801d3bc:	f107 0218 	add.w	r2, r7, #24
 801d3c0:	4611      	mov	r1, r2
 801d3c2:	68f8      	ldr	r0, [r7, #12]
 801d3c4:	4798      	blx	r3

                return i;
 801d3c6:	69bb      	ldr	r3, [r7, #24]
 801d3c8:	b29b      	uxth	r3, r3
 801d3ca:	e017      	b.n	801d3fc <lv_txt_get_next_line+0x154>
            }
            /*If this char still can fit to this line then check if
             * txt can be broken here later */
            else if(is_break_char(letter)) {
 801d3cc:	6a38      	ldr	r0, [r7, #32]
 801d3ce:	f000 faa9 	bl	801d924 <is_break_char>
 801d3d2:	4603      	mov	r3, r0
 801d3d4:	2b00      	cmp	r3, #0
 801d3d6:	d001      	beq.n	801d3dc <lv_txt_get_next_line+0x134>
                last_break = i; /*Save the first char index after break*/
 801d3d8:	69bb      	ldr	r3, [r7, #24]
 801d3da:	62bb      	str	r3, [r7, #40]	; 0x28
            }
        }

        if(letter_w > 0) {
 801d3dc:	69fb      	ldr	r3, [r7, #28]
 801d3de:	2b00      	cmp	r3, #0
 801d3e0:	d004      	beq.n	801d3ec <lv_txt_get_next_line+0x144>
            cur_w += letter_space;
 801d3e2:	8dfa      	ldrh	r2, [r7, #46]	; 0x2e
 801d3e4:	88fb      	ldrh	r3, [r7, #6]
 801d3e6:	4413      	add	r3, r2
 801d3e8:	b29b      	uxth	r3, r3
 801d3ea:	85fb      	strh	r3, [r7, #46]	; 0x2e
    while(txt[i] != '\0') {
 801d3ec:	69bb      	ldr	r3, [r7, #24]
 801d3ee:	68fa      	ldr	r2, [r7, #12]
 801d3f0:	4413      	add	r3, r2
 801d3f2:	781b      	ldrb	r3, [r3, #0]
 801d3f4:	2b00      	cmp	r3, #0
 801d3f6:	d18d      	bne.n	801d314 <lv_txt_get_next_line+0x6c>
        }
    }

    return i;
 801d3f8:	69bb      	ldr	r3, [r7, #24]
 801d3fa:	b29b      	uxth	r3, r3
}
 801d3fc:	4618      	mov	r0, r3
 801d3fe:	3730      	adds	r7, #48	; 0x30
 801d400:	46bd      	mov	sp, r7
 801d402:	bd80      	pop	{r7, pc}
 801d404:	20000c34 	.word	0x20000c34
 801d408:	20000c38 	.word	0x20000c38

0801d40c <lv_txt_get_width>:
 * @param flags settings for the text from 'txt_flag_t' enum
 * @return length of a char_num long text
 */
lv_coord_t lv_txt_get_width(const char * txt, uint16_t length, const lv_font_t * font, lv_coord_t letter_space,
                            lv_txt_flag_t flag)
{
 801d40c:	b580      	push	{r7, lr}
 801d40e:	b08a      	sub	sp, #40	; 0x28
 801d410:	af00      	add	r7, sp, #0
 801d412:	60f8      	str	r0, [r7, #12]
 801d414:	607a      	str	r2, [r7, #4]
 801d416:	461a      	mov	r2, r3
 801d418:	460b      	mov	r3, r1
 801d41a:	817b      	strh	r3, [r7, #10]
 801d41c:	4613      	mov	r3, r2
 801d41e:	813b      	strh	r3, [r7, #8]
    if(txt == NULL) return 0;
 801d420:	68fb      	ldr	r3, [r7, #12]
 801d422:	2b00      	cmp	r3, #0
 801d424:	d101      	bne.n	801d42a <lv_txt_get_width+0x1e>
 801d426:	2300      	movs	r3, #0
 801d428:	e053      	b.n	801d4d2 <lv_txt_get_width+0xc6>
    if(font == NULL) return 0;
 801d42a:	687b      	ldr	r3, [r7, #4]
 801d42c:	2b00      	cmp	r3, #0
 801d42e:	d101      	bne.n	801d434 <lv_txt_get_width+0x28>
 801d430:	2300      	movs	r3, #0
 801d432:	e04e      	b.n	801d4d2 <lv_txt_get_width+0xc6>

    uint32_t i                   = 0;
 801d434:	2300      	movs	r3, #0
 801d436:	617b      	str	r3, [r7, #20]
    lv_coord_t width             = 0;
 801d438:	2300      	movs	r3, #0
 801d43a:	84fb      	strh	r3, [r7, #38]	; 0x26
    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 801d43c:	2300      	movs	r3, #0
 801d43e:	74fb      	strb	r3, [r7, #19]
    uint32_t letter;
    uint32_t letter_next;

    if(length != 0) {
 801d440:	897b      	ldrh	r3, [r7, #10]
 801d442:	2b00      	cmp	r3, #0
 801d444:	d043      	beq.n	801d4ce <lv_txt_get_width+0xc2>
        while(i < length) {
 801d446:	e035      	b.n	801d4b4 <lv_txt_get_width+0xa8>
            letter      = lv_txt_encoded_next(txt, &i);
 801d448:	4b24      	ldr	r3, [pc, #144]	; (801d4dc <lv_txt_get_width+0xd0>)
 801d44a:	681b      	ldr	r3, [r3, #0]
 801d44c:	f107 0214 	add.w	r2, r7, #20
 801d450:	4611      	mov	r1, r2
 801d452:	68f8      	ldr	r0, [r7, #12]
 801d454:	4798      	blx	r3
 801d456:	6238      	str	r0, [r7, #32]
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 801d458:	4b20      	ldr	r3, [pc, #128]	; (801d4dc <lv_txt_get_width+0xd0>)
 801d45a:	681b      	ldr	r3, [r3, #0]
 801d45c:	697a      	ldr	r2, [r7, #20]
 801d45e:	68f9      	ldr	r1, [r7, #12]
 801d460:	440a      	add	r2, r1
 801d462:	2100      	movs	r1, #0
 801d464:	4610      	mov	r0, r2
 801d466:	4798      	blx	r3
 801d468:	61f8      	str	r0, [r7, #28]
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 801d46a:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 801d46e:	f003 0301 	and.w	r3, r3, #1
 801d472:	2b00      	cmp	r3, #0
 801d474:	d009      	beq.n	801d48a <lv_txt_get_width+0x7e>
                if(lv_txt_is_cmd(&cmd_state, letter) != false) {
 801d476:	f107 0313 	add.w	r3, r7, #19
 801d47a:	6a39      	ldr	r1, [r7, #32]
 801d47c:	4618      	mov	r0, r3
 801d47e:	f000 f82f 	bl	801d4e0 <lv_txt_is_cmd>
 801d482:	4603      	mov	r3, r0
 801d484:	2b00      	cmp	r3, #0
 801d486:	d000      	beq.n	801d48a <lv_txt_get_width+0x7e>
                    continue;
 801d488:	e014      	b.n	801d4b4 <lv_txt_get_width+0xa8>
                }
            }

            lv_coord_t char_width = lv_font_get_glyph_width(font, letter, letter_next);
 801d48a:	69fa      	ldr	r2, [r7, #28]
 801d48c:	6a39      	ldr	r1, [r7, #32]
 801d48e:	6878      	ldr	r0, [r7, #4]
 801d490:	f7fd fa32 	bl	801a8f8 <lv_font_get_glyph_width>
 801d494:	4603      	mov	r3, r0
 801d496:	837b      	strh	r3, [r7, #26]
            if(char_width > 0) {
 801d498:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 801d49c:	2b00      	cmp	r3, #0
 801d49e:	dd09      	ble.n	801d4b4 <lv_txt_get_width+0xa8>
                width += char_width;
 801d4a0:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801d4a2:	8b7b      	ldrh	r3, [r7, #26]
 801d4a4:	4413      	add	r3, r2
 801d4a6:	b29b      	uxth	r3, r3
 801d4a8:	84fb      	strh	r3, [r7, #38]	; 0x26
                width += letter_space;
 801d4aa:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801d4ac:	893b      	ldrh	r3, [r7, #8]
 801d4ae:	4413      	add	r3, r2
 801d4b0:	b29b      	uxth	r3, r3
 801d4b2:	84fb      	strh	r3, [r7, #38]	; 0x26
        while(i < length) {
 801d4b4:	897a      	ldrh	r2, [r7, #10]
 801d4b6:	697b      	ldr	r3, [r7, #20]
 801d4b8:	429a      	cmp	r2, r3
 801d4ba:	d8c5      	bhi.n	801d448 <lv_txt_get_width+0x3c>
            }
        }

        if(width > 0) {
 801d4bc:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801d4c0:	2b00      	cmp	r3, #0
 801d4c2:	dd04      	ble.n	801d4ce <lv_txt_get_width+0xc2>
            width -= letter_space; /*Trim the last letter space. Important if the text is center
 801d4c4:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801d4c6:	893b      	ldrh	r3, [r7, #8]
 801d4c8:	1ad3      	subs	r3, r2, r3
 801d4ca:	b29b      	uxth	r3, r3
 801d4cc:	84fb      	strh	r3, [r7, #38]	; 0x26
                                      aligned */
        }
    }

    return width;
 801d4ce:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
}
 801d4d2:	4618      	mov	r0, r3
 801d4d4:	3728      	adds	r7, #40	; 0x28
 801d4d6:	46bd      	mov	sp, r7
 801d4d8:	bd80      	pop	{r7, pc}
 801d4da:	bf00      	nop
 801d4dc:	20000c34 	.word	0x20000c34

0801d4e0 <lv_txt_is_cmd>:
 * @param c the current character
 * @return true: the character is part of a command and should not be written,
 *         false: the character should be written
 */
bool lv_txt_is_cmd(lv_txt_cmd_state_t * state, uint32_t c)
{
 801d4e0:	b480      	push	{r7}
 801d4e2:	b085      	sub	sp, #20
 801d4e4:	af00      	add	r7, sp, #0
 801d4e6:	6078      	str	r0, [r7, #4]
 801d4e8:	6039      	str	r1, [r7, #0]
    bool ret = false;
 801d4ea:	2300      	movs	r3, #0
 801d4ec:	73fb      	strb	r3, [r7, #15]

    if(c == (uint32_t)LV_TXT_COLOR_CMD[0]) {
 801d4ee:	2323      	movs	r3, #35	; 0x23
 801d4f0:	461a      	mov	r2, r3
 801d4f2:	683b      	ldr	r3, [r7, #0]
 801d4f4:	4293      	cmp	r3, r2
 801d4f6:	d11a      	bne.n	801d52e <lv_txt_is_cmd+0x4e>
        if(*state == LV_TXT_CMD_STATE_WAIT) { /*Start char*/
 801d4f8:	687b      	ldr	r3, [r7, #4]
 801d4fa:	781b      	ldrb	r3, [r3, #0]
 801d4fc:	2b00      	cmp	r3, #0
 801d4fe:	d105      	bne.n	801d50c <lv_txt_is_cmd+0x2c>
            *state = LV_TXT_CMD_STATE_PAR;
 801d500:	687b      	ldr	r3, [r7, #4]
 801d502:	2201      	movs	r2, #1
 801d504:	701a      	strb	r2, [r3, #0]
            ret    = true;
 801d506:	2301      	movs	r3, #1
 801d508:	73fb      	strb	r3, [r7, #15]
 801d50a:	e010      	b.n	801d52e <lv_txt_is_cmd+0x4e>
        }
        /*Other start char in parameter is escaped cmd. char */
        else if(*state == LV_TXT_CMD_STATE_PAR) {
 801d50c:	687b      	ldr	r3, [r7, #4]
 801d50e:	781b      	ldrb	r3, [r3, #0]
 801d510:	2b01      	cmp	r3, #1
 801d512:	d103      	bne.n	801d51c <lv_txt_is_cmd+0x3c>
            *state = LV_TXT_CMD_STATE_WAIT;
 801d514:	687b      	ldr	r3, [r7, #4]
 801d516:	2200      	movs	r2, #0
 801d518:	701a      	strb	r2, [r3, #0]
 801d51a:	e008      	b.n	801d52e <lv_txt_is_cmd+0x4e>
        }
        /*Command end */
        else if(*state == LV_TXT_CMD_STATE_IN) {
 801d51c:	687b      	ldr	r3, [r7, #4]
 801d51e:	781b      	ldrb	r3, [r3, #0]
 801d520:	2b02      	cmp	r3, #2
 801d522:	d104      	bne.n	801d52e <lv_txt_is_cmd+0x4e>
            *state = LV_TXT_CMD_STATE_WAIT;
 801d524:	687b      	ldr	r3, [r7, #4]
 801d526:	2200      	movs	r2, #0
 801d528:	701a      	strb	r2, [r3, #0]
            ret    = true;
 801d52a:	2301      	movs	r3, #1
 801d52c:	73fb      	strb	r3, [r7, #15]
        }
    }

    /*Skip the color parameter and wait the space after it*/
    if(*state == LV_TXT_CMD_STATE_PAR) {
 801d52e:	687b      	ldr	r3, [r7, #4]
 801d530:	781b      	ldrb	r3, [r3, #0]
 801d532:	2b01      	cmp	r3, #1
 801d534:	d107      	bne.n	801d546 <lv_txt_is_cmd+0x66>
        if(c == ' ') {
 801d536:	683b      	ldr	r3, [r7, #0]
 801d538:	2b20      	cmp	r3, #32
 801d53a:	d102      	bne.n	801d542 <lv_txt_is_cmd+0x62>
            *state = LV_TXT_CMD_STATE_IN; /*After the parameter the text is in the command*/
 801d53c:	687b      	ldr	r3, [r7, #4]
 801d53e:	2202      	movs	r2, #2
 801d540:	701a      	strb	r2, [r3, #0]
        }
        ret = true;
 801d542:	2301      	movs	r3, #1
 801d544:	73fb      	strb	r3, [r7, #15]
    }

    return ret;
 801d546:	7bfb      	ldrb	r3, [r7, #15]
}
 801d548:	4618      	mov	r0, r3
 801d54a:	3714      	adds	r7, #20
 801d54c:	46bd      	mov	sp, r7
 801d54e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d552:	4770      	bx	lr

0801d554 <lv_txt_utf8_size>:
 * Give the size of an UTF-8 coded character
 * @param str pointer to a character in a string
 * @return length of the UTF-8 character (1,2,3 or 4). O on invalid code
 */
static uint8_t lv_txt_utf8_size(const char * str)
{
 801d554:	b480      	push	{r7}
 801d556:	b083      	sub	sp, #12
 801d558:	af00      	add	r7, sp, #0
 801d55a:	6078      	str	r0, [r7, #4]
    if((str[0] & 0x80) == 0)
 801d55c:	687b      	ldr	r3, [r7, #4]
 801d55e:	781b      	ldrb	r3, [r3, #0]
 801d560:	b25b      	sxtb	r3, r3
 801d562:	2b00      	cmp	r3, #0
 801d564:	db01      	blt.n	801d56a <lv_txt_utf8_size+0x16>
        return 1;
 801d566:	2301      	movs	r3, #1
 801d568:	e018      	b.n	801d59c <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xE0) == 0xC0)
 801d56a:	687b      	ldr	r3, [r7, #4]
 801d56c:	781b      	ldrb	r3, [r3, #0]
 801d56e:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 801d572:	2bc0      	cmp	r3, #192	; 0xc0
 801d574:	d101      	bne.n	801d57a <lv_txt_utf8_size+0x26>
        return 2;
 801d576:	2302      	movs	r3, #2
 801d578:	e010      	b.n	801d59c <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF0) == 0xE0)
 801d57a:	687b      	ldr	r3, [r7, #4]
 801d57c:	781b      	ldrb	r3, [r3, #0]
 801d57e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801d582:	2be0      	cmp	r3, #224	; 0xe0
 801d584:	d101      	bne.n	801d58a <lv_txt_utf8_size+0x36>
        return 3;
 801d586:	2303      	movs	r3, #3
 801d588:	e008      	b.n	801d59c <lv_txt_utf8_size+0x48>
    else if((str[0] & 0xF8) == 0xF0)
 801d58a:	687b      	ldr	r3, [r7, #4]
 801d58c:	781b      	ldrb	r3, [r3, #0]
 801d58e:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 801d592:	2bf0      	cmp	r3, #240	; 0xf0
 801d594:	d101      	bne.n	801d59a <lv_txt_utf8_size+0x46>
        return 4;
 801d596:	2304      	movs	r3, #4
 801d598:	e000      	b.n	801d59c <lv_txt_utf8_size+0x48>
    return 1; /*If the char was invalid step tell it's 1 byte long*/
 801d59a:	2301      	movs	r3, #1
}
 801d59c:	4618      	mov	r0, r3
 801d59e:	370c      	adds	r7, #12
 801d5a0:	46bd      	mov	sp, r7
 801d5a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d5a6:	4770      	bx	lr

0801d5a8 <lv_txt_utf8_next>:
 *          After call it will point to the next UTF-8 char in 'txt'.
 *          NULL to use txt[0] as index
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_next(const char * txt, uint32_t * i)
{
 801d5a8:	b480      	push	{r7}
 801d5aa:	b085      	sub	sp, #20
 801d5ac:	af00      	add	r7, sp, #0
 801d5ae:	6078      	str	r0, [r7, #4]
 801d5b0:	6039      	str	r1, [r7, #0]
     * 00000000 00000000 00000yyy yyxxxxxx -> 110yyyyy 10xxxxxx
     * 00000000 00000000 zzzzyyyy yyxxxxxx -> 1110zzzz 10yyyyyy 10xxxxxx
     * 00000000 000wwwzz zzzzyyyy yyxxxxxx -> 11110www 10zzzzzz 10yyyyyy 10xxxxxx
     * */

    uint32_t result = 0;
 801d5b2:	2300      	movs	r3, #0
 801d5b4:	60fb      	str	r3, [r7, #12]

    /*Dummy 'i' pointer is required*/
    uint32_t i_tmp = 0;
 801d5b6:	2300      	movs	r3, #0
 801d5b8:	60bb      	str	r3, [r7, #8]
    if(i == NULL) i = &i_tmp;
 801d5ba:	683b      	ldr	r3, [r7, #0]
 801d5bc:	2b00      	cmp	r3, #0
 801d5be:	d102      	bne.n	801d5c6 <lv_txt_utf8_next+0x1e>
 801d5c0:	f107 0308 	add.w	r3, r7, #8
 801d5c4:	603b      	str	r3, [r7, #0]

    /*Normal ASCII*/
    if((txt[*i] & 0x80) == 0) {
 801d5c6:	683b      	ldr	r3, [r7, #0]
 801d5c8:	681b      	ldr	r3, [r3, #0]
 801d5ca:	687a      	ldr	r2, [r7, #4]
 801d5cc:	4413      	add	r3, r2
 801d5ce:	781b      	ldrb	r3, [r3, #0]
 801d5d0:	b25b      	sxtb	r3, r3
 801d5d2:	2b00      	cmp	r3, #0
 801d5d4:	db0b      	blt.n	801d5ee <lv_txt_utf8_next+0x46>
        result = txt[*i];
 801d5d6:	683b      	ldr	r3, [r7, #0]
 801d5d8:	681b      	ldr	r3, [r3, #0]
 801d5da:	687a      	ldr	r2, [r7, #4]
 801d5dc:	4413      	add	r3, r2
 801d5de:	781b      	ldrb	r3, [r3, #0]
 801d5e0:	60fb      	str	r3, [r7, #12]
        (*i)++;
 801d5e2:	683b      	ldr	r3, [r7, #0]
 801d5e4:	681b      	ldr	r3, [r3, #0]
 801d5e6:	1c5a      	adds	r2, r3, #1
 801d5e8:	683b      	ldr	r3, [r7, #0]
 801d5ea:	601a      	str	r2, [r3, #0]
 801d5ec:	e0ea      	b.n	801d7c4 <lv_txt_utf8_next+0x21c>
    }
    /*Real UTF-8 decode*/
    else {
        /*2 bytes UTF-8 code*/
        if((txt[*i] & 0xE0) == 0xC0) {
 801d5ee:	683b      	ldr	r3, [r7, #0]
 801d5f0:	681b      	ldr	r3, [r3, #0]
 801d5f2:	687a      	ldr	r2, [r7, #4]
 801d5f4:	4413      	add	r3, r2
 801d5f6:	781b      	ldrb	r3, [r3, #0]
 801d5f8:	f003 03e0 	and.w	r3, r3, #224	; 0xe0
 801d5fc:	2bc0      	cmp	r3, #192	; 0xc0
 801d5fe:	d128      	bne.n	801d652 <lv_txt_utf8_next+0xaa>
            result = (uint32_t)(txt[*i] & 0x1F) << 6;
 801d600:	683b      	ldr	r3, [r7, #0]
 801d602:	681b      	ldr	r3, [r3, #0]
 801d604:	687a      	ldr	r2, [r7, #4]
 801d606:	4413      	add	r3, r2
 801d608:	781b      	ldrb	r3, [r3, #0]
 801d60a:	019b      	lsls	r3, r3, #6
 801d60c:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 801d610:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d612:	683b      	ldr	r3, [r7, #0]
 801d614:	681b      	ldr	r3, [r3, #0]
 801d616:	1c5a      	adds	r2, r3, #1
 801d618:	683b      	ldr	r3, [r7, #0]
 801d61a:	601a      	str	r2, [r3, #0]
            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801d61c:	683b      	ldr	r3, [r7, #0]
 801d61e:	681b      	ldr	r3, [r3, #0]
 801d620:	687a      	ldr	r2, [r7, #4]
 801d622:	4413      	add	r3, r2
 801d624:	781b      	ldrb	r3, [r3, #0]
 801d626:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801d62a:	2b80      	cmp	r3, #128	; 0x80
 801d62c:	d001      	beq.n	801d632 <lv_txt_utf8_next+0x8a>
 801d62e:	2300      	movs	r3, #0
 801d630:	e0c9      	b.n	801d7c6 <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 801d632:	683b      	ldr	r3, [r7, #0]
 801d634:	681b      	ldr	r3, [r3, #0]
 801d636:	687a      	ldr	r2, [r7, #4]
 801d638:	4413      	add	r3, r2
 801d63a:	781b      	ldrb	r3, [r3, #0]
 801d63c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801d640:	68fa      	ldr	r2, [r7, #12]
 801d642:	4413      	add	r3, r2
 801d644:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d646:	683b      	ldr	r3, [r7, #0]
 801d648:	681b      	ldr	r3, [r3, #0]
 801d64a:	1c5a      	adds	r2, r3, #1
 801d64c:	683b      	ldr	r3, [r7, #0]
 801d64e:	601a      	str	r2, [r3, #0]
 801d650:	e0b8      	b.n	801d7c4 <lv_txt_utf8_next+0x21c>
        }
        /*3 bytes UTF-8 code*/
        else if((txt[*i] & 0xF0) == 0xE0) {
 801d652:	683b      	ldr	r3, [r7, #0]
 801d654:	681b      	ldr	r3, [r3, #0]
 801d656:	687a      	ldr	r2, [r7, #4]
 801d658:	4413      	add	r3, r2
 801d65a:	781b      	ldrb	r3, [r3, #0]
 801d65c:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 801d660:	2be0      	cmp	r3, #224	; 0xe0
 801d662:	d142      	bne.n	801d6ea <lv_txt_utf8_next+0x142>
            result = (uint32_t)(txt[*i] & 0x0F) << 12;
 801d664:	683b      	ldr	r3, [r7, #0]
 801d666:	681b      	ldr	r3, [r3, #0]
 801d668:	687a      	ldr	r2, [r7, #4]
 801d66a:	4413      	add	r3, r2
 801d66c:	781b      	ldrb	r3, [r3, #0]
 801d66e:	031b      	lsls	r3, r3, #12
 801d670:	b29b      	uxth	r3, r3
 801d672:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d674:	683b      	ldr	r3, [r7, #0]
 801d676:	681b      	ldr	r3, [r3, #0]
 801d678:	1c5a      	adds	r2, r3, #1
 801d67a:	683b      	ldr	r3, [r7, #0]
 801d67c:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801d67e:	683b      	ldr	r3, [r7, #0]
 801d680:	681b      	ldr	r3, [r3, #0]
 801d682:	687a      	ldr	r2, [r7, #4]
 801d684:	4413      	add	r3, r2
 801d686:	781b      	ldrb	r3, [r3, #0]
 801d688:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801d68c:	2b80      	cmp	r3, #128	; 0x80
 801d68e:	d001      	beq.n	801d694 <lv_txt_utf8_next+0xec>
 801d690:	2300      	movs	r3, #0
 801d692:	e098      	b.n	801d7c6 <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 801d694:	683b      	ldr	r3, [r7, #0]
 801d696:	681b      	ldr	r3, [r3, #0]
 801d698:	687a      	ldr	r2, [r7, #4]
 801d69a:	4413      	add	r3, r2
 801d69c:	781b      	ldrb	r3, [r3, #0]
 801d69e:	019b      	lsls	r3, r3, #6
 801d6a0:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 801d6a4:	68fa      	ldr	r2, [r7, #12]
 801d6a6:	4413      	add	r3, r2
 801d6a8:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d6aa:	683b      	ldr	r3, [r7, #0]
 801d6ac:	681b      	ldr	r3, [r3, #0]
 801d6ae:	1c5a      	adds	r2, r3, #1
 801d6b0:	683b      	ldr	r3, [r7, #0]
 801d6b2:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801d6b4:	683b      	ldr	r3, [r7, #0]
 801d6b6:	681b      	ldr	r3, [r3, #0]
 801d6b8:	687a      	ldr	r2, [r7, #4]
 801d6ba:	4413      	add	r3, r2
 801d6bc:	781b      	ldrb	r3, [r3, #0]
 801d6be:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801d6c2:	2b80      	cmp	r3, #128	; 0x80
 801d6c4:	d001      	beq.n	801d6ca <lv_txt_utf8_next+0x122>
 801d6c6:	2300      	movs	r3, #0
 801d6c8:	e07d      	b.n	801d7c6 <lv_txt_utf8_next+0x21e>
            result += (txt[*i] & 0x3F);
 801d6ca:	683b      	ldr	r3, [r7, #0]
 801d6cc:	681b      	ldr	r3, [r3, #0]
 801d6ce:	687a      	ldr	r2, [r7, #4]
 801d6d0:	4413      	add	r3, r2
 801d6d2:	781b      	ldrb	r3, [r3, #0]
 801d6d4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801d6d8:	68fa      	ldr	r2, [r7, #12]
 801d6da:	4413      	add	r3, r2
 801d6dc:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d6de:	683b      	ldr	r3, [r7, #0]
 801d6e0:	681b      	ldr	r3, [r3, #0]
 801d6e2:	1c5a      	adds	r2, r3, #1
 801d6e4:	683b      	ldr	r3, [r7, #0]
 801d6e6:	601a      	str	r2, [r3, #0]
 801d6e8:	e06c      	b.n	801d7c4 <lv_txt_utf8_next+0x21c>
        }
        /*4 bytes UTF-8 code*/
        else if((txt[*i] & 0xF8) == 0xF0) {
 801d6ea:	683b      	ldr	r3, [r7, #0]
 801d6ec:	681b      	ldr	r3, [r3, #0]
 801d6ee:	687a      	ldr	r2, [r7, #4]
 801d6f0:	4413      	add	r3, r2
 801d6f2:	781b      	ldrb	r3, [r3, #0]
 801d6f4:	f003 03f8 	and.w	r3, r3, #248	; 0xf8
 801d6f8:	2bf0      	cmp	r3, #240	; 0xf0
 801d6fa:	d15e      	bne.n	801d7ba <lv_txt_utf8_next+0x212>
            result = (uint32_t)(txt[*i] & 0x07) << 18;
 801d6fc:	683b      	ldr	r3, [r7, #0]
 801d6fe:	681b      	ldr	r3, [r3, #0]
 801d700:	687a      	ldr	r2, [r7, #4]
 801d702:	4413      	add	r3, r2
 801d704:	781b      	ldrb	r3, [r3, #0]
 801d706:	049b      	lsls	r3, r3, #18
 801d708:	f403 13e0 	and.w	r3, r3, #1835008	; 0x1c0000
 801d70c:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d70e:	683b      	ldr	r3, [r7, #0]
 801d710:	681b      	ldr	r3, [r3, #0]
 801d712:	1c5a      	adds	r2, r3, #1
 801d714:	683b      	ldr	r3, [r7, #0]
 801d716:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801d718:	683b      	ldr	r3, [r7, #0]
 801d71a:	681b      	ldr	r3, [r3, #0]
 801d71c:	687a      	ldr	r2, [r7, #4]
 801d71e:	4413      	add	r3, r2
 801d720:	781b      	ldrb	r3, [r3, #0]
 801d722:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801d726:	2b80      	cmp	r3, #128	; 0x80
 801d728:	d001      	beq.n	801d72e <lv_txt_utf8_next+0x186>
 801d72a:	2300      	movs	r3, #0
 801d72c:	e04b      	b.n	801d7c6 <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 12;
 801d72e:	683b      	ldr	r3, [r7, #0]
 801d730:	681b      	ldr	r3, [r3, #0]
 801d732:	687a      	ldr	r2, [r7, #4]
 801d734:	4413      	add	r3, r2
 801d736:	781b      	ldrb	r3, [r3, #0]
 801d738:	031b      	lsls	r3, r3, #12
 801d73a:	f403 337c 	and.w	r3, r3, #258048	; 0x3f000
 801d73e:	68fa      	ldr	r2, [r7, #12]
 801d740:	4413      	add	r3, r2
 801d742:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d744:	683b      	ldr	r3, [r7, #0]
 801d746:	681b      	ldr	r3, [r3, #0]
 801d748:	1c5a      	adds	r2, r3, #1
 801d74a:	683b      	ldr	r3, [r7, #0]
 801d74c:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801d74e:	683b      	ldr	r3, [r7, #0]
 801d750:	681b      	ldr	r3, [r3, #0]
 801d752:	687a      	ldr	r2, [r7, #4]
 801d754:	4413      	add	r3, r2
 801d756:	781b      	ldrb	r3, [r3, #0]
 801d758:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801d75c:	2b80      	cmp	r3, #128	; 0x80
 801d75e:	d001      	beq.n	801d764 <lv_txt_utf8_next+0x1bc>
 801d760:	2300      	movs	r3, #0
 801d762:	e030      	b.n	801d7c6 <lv_txt_utf8_next+0x21e>
            result += (uint32_t)(txt[*i] & 0x3F) << 6;
 801d764:	683b      	ldr	r3, [r7, #0]
 801d766:	681b      	ldr	r3, [r3, #0]
 801d768:	687a      	ldr	r2, [r7, #4]
 801d76a:	4413      	add	r3, r2
 801d76c:	781b      	ldrb	r3, [r3, #0]
 801d76e:	019b      	lsls	r3, r3, #6
 801d770:	f403 637c 	and.w	r3, r3, #4032	; 0xfc0
 801d774:	68fa      	ldr	r2, [r7, #12]
 801d776:	4413      	add	r3, r2
 801d778:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d77a:	683b      	ldr	r3, [r7, #0]
 801d77c:	681b      	ldr	r3, [r3, #0]
 801d77e:	1c5a      	adds	r2, r3, #1
 801d780:	683b      	ldr	r3, [r7, #0]
 801d782:	601a      	str	r2, [r3, #0]

            if((txt[*i] & 0xC0) != 0x80) return 0; /*Invalid UTF-8 code*/
 801d784:	683b      	ldr	r3, [r7, #0]
 801d786:	681b      	ldr	r3, [r3, #0]
 801d788:	687a      	ldr	r2, [r7, #4]
 801d78a:	4413      	add	r3, r2
 801d78c:	781b      	ldrb	r3, [r3, #0]
 801d78e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 801d792:	2b80      	cmp	r3, #128	; 0x80
 801d794:	d001      	beq.n	801d79a <lv_txt_utf8_next+0x1f2>
 801d796:	2300      	movs	r3, #0
 801d798:	e015      	b.n	801d7c6 <lv_txt_utf8_next+0x21e>
            result += txt[*i] & 0x3F;
 801d79a:	683b      	ldr	r3, [r7, #0]
 801d79c:	681b      	ldr	r3, [r3, #0]
 801d79e:	687a      	ldr	r2, [r7, #4]
 801d7a0:	4413      	add	r3, r2
 801d7a2:	781b      	ldrb	r3, [r3, #0]
 801d7a4:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801d7a8:	68fa      	ldr	r2, [r7, #12]
 801d7aa:	4413      	add	r3, r2
 801d7ac:	60fb      	str	r3, [r7, #12]
            (*i)++;
 801d7ae:	683b      	ldr	r3, [r7, #0]
 801d7b0:	681b      	ldr	r3, [r3, #0]
 801d7b2:	1c5a      	adds	r2, r3, #1
 801d7b4:	683b      	ldr	r3, [r7, #0]
 801d7b6:	601a      	str	r2, [r3, #0]
 801d7b8:	e004      	b.n	801d7c4 <lv_txt_utf8_next+0x21c>
        } else {
            (*i)++; /*Not UTF-8 char. Go the next.*/
 801d7ba:	683b      	ldr	r3, [r7, #0]
 801d7bc:	681b      	ldr	r3, [r3, #0]
 801d7be:	1c5a      	adds	r2, r3, #1
 801d7c0:	683b      	ldr	r3, [r7, #0]
 801d7c2:	601a      	str	r2, [r3, #0]
        }
    }
    return result;
 801d7c4:	68fb      	ldr	r3, [r7, #12]
}
 801d7c6:	4618      	mov	r0, r3
 801d7c8:	3714      	adds	r7, #20
 801d7ca:	46bd      	mov	sp, r7
 801d7cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d7d0:	4770      	bx	lr
	...

0801d7d4 <lv_txt_utf8_prev>:
 * @param i start byte index in 'txt' where to start. After the call it will point to the previous
 * UTF-8 char in 'txt'.
 * @return the decoded Unicode character or 0 on invalid UTF-8 code
 */
static uint32_t lv_txt_utf8_prev(const char * txt, uint32_t * i)
{
 801d7d4:	b580      	push	{r7, lr}
 801d7d6:	b086      	sub	sp, #24
 801d7d8:	af00      	add	r7, sp, #0
 801d7da:	6078      	str	r0, [r7, #4]
 801d7dc:	6039      	str	r1, [r7, #0]
    uint8_t c_size;
    uint8_t cnt = 0;
 801d7de:	2300      	movs	r3, #0
 801d7e0:	75fb      	strb	r3, [r7, #23]

    /*Try to find a !0 long UTF-8 char by stepping one character back*/
    (*i)--;
 801d7e2:	683b      	ldr	r3, [r7, #0]
 801d7e4:	681b      	ldr	r3, [r3, #0]
 801d7e6:	1e5a      	subs	r2, r3, #1
 801d7e8:	683b      	ldr	r3, [r7, #0]
 801d7ea:	601a      	str	r2, [r3, #0]
    do {
        if(cnt >= 4) return 0; /*No UTF-8 char found before the initial*/
 801d7ec:	7dfb      	ldrb	r3, [r7, #23]
 801d7ee:	2b03      	cmp	r3, #3
 801d7f0:	d901      	bls.n	801d7f6 <lv_txt_utf8_prev+0x22>
 801d7f2:	2300      	movs	r3, #0
 801d7f4:	e02a      	b.n	801d84c <lv_txt_utf8_prev+0x78>

        c_size = lv_txt_encoded_size(&txt[*i]);
 801d7f6:	4b17      	ldr	r3, [pc, #92]	; (801d854 <lv_txt_utf8_prev+0x80>)
 801d7f8:	681b      	ldr	r3, [r3, #0]
 801d7fa:	683a      	ldr	r2, [r7, #0]
 801d7fc:	6812      	ldr	r2, [r2, #0]
 801d7fe:	6879      	ldr	r1, [r7, #4]
 801d800:	440a      	add	r2, r1
 801d802:	4610      	mov	r0, r2
 801d804:	4798      	blx	r3
 801d806:	4603      	mov	r3, r0
 801d808:	75bb      	strb	r3, [r7, #22]
        if(c_size == 0) {
 801d80a:	7dbb      	ldrb	r3, [r7, #22]
 801d80c:	2b00      	cmp	r3, #0
 801d80e:	d10b      	bne.n	801d828 <lv_txt_utf8_prev+0x54>
            if(*i != 0)
 801d810:	683b      	ldr	r3, [r7, #0]
 801d812:	681b      	ldr	r3, [r3, #0]
 801d814:	2b00      	cmp	r3, #0
 801d816:	d005      	beq.n	801d824 <lv_txt_utf8_prev+0x50>
                (*i)--;
 801d818:	683b      	ldr	r3, [r7, #0]
 801d81a:	681b      	ldr	r3, [r3, #0]
 801d81c:	1e5a      	subs	r2, r3, #1
 801d81e:	683b      	ldr	r3, [r7, #0]
 801d820:	601a      	str	r2, [r3, #0]
 801d822:	e001      	b.n	801d828 <lv_txt_utf8_prev+0x54>
            else
                return 0;
 801d824:	2300      	movs	r3, #0
 801d826:	e011      	b.n	801d84c <lv_txt_utf8_prev+0x78>
        }
        cnt++;
 801d828:	7dfb      	ldrb	r3, [r7, #23]
 801d82a:	3301      	adds	r3, #1
 801d82c:	75fb      	strb	r3, [r7, #23]
    } while(c_size == 0);
 801d82e:	7dbb      	ldrb	r3, [r7, #22]
 801d830:	2b00      	cmp	r3, #0
 801d832:	d0db      	beq.n	801d7ec <lv_txt_utf8_prev+0x18>

    uint32_t i_tmp  = *i;
 801d834:	683b      	ldr	r3, [r7, #0]
 801d836:	681b      	ldr	r3, [r3, #0]
 801d838:	60fb      	str	r3, [r7, #12]
    uint32_t letter = lv_txt_encoded_next(txt, &i_tmp); /*Character found, get it*/
 801d83a:	4b07      	ldr	r3, [pc, #28]	; (801d858 <lv_txt_utf8_prev+0x84>)
 801d83c:	681b      	ldr	r3, [r3, #0]
 801d83e:	f107 020c 	add.w	r2, r7, #12
 801d842:	4611      	mov	r1, r2
 801d844:	6878      	ldr	r0, [r7, #4]
 801d846:	4798      	blx	r3
 801d848:	6138      	str	r0, [r7, #16]

    return letter;
 801d84a:	693b      	ldr	r3, [r7, #16]
}
 801d84c:	4618      	mov	r0, r3
 801d84e:	3718      	adds	r7, #24
 801d850:	46bd      	mov	sp, r7
 801d852:	bd80      	pop	{r7, pc}
 801d854:	20000c30 	.word	0x20000c30
 801d858:	20000c34 	.word	0x20000c34

0801d85c <lv_txt_utf8_get_byte_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param utf8_id character index
 * @return byte index of the 'utf8_id'th letter
 */
static uint32_t lv_txt_utf8_get_byte_id(const char * txt, uint32_t utf8_id)
{
 801d85c:	b580      	push	{r7, lr}
 801d85e:	b084      	sub	sp, #16
 801d860:	af00      	add	r7, sp, #0
 801d862:	6078      	str	r0, [r7, #4]
 801d864:	6039      	str	r1, [r7, #0]
    uint32_t i;
    uint32_t byte_cnt = 0;
 801d866:	2300      	movs	r3, #0
 801d868:	60bb      	str	r3, [r7, #8]
    for(i = 0; i < utf8_id; i++) {
 801d86a:	2300      	movs	r3, #0
 801d86c:	60fb      	str	r3, [r7, #12]
 801d86e:	e00e      	b.n	801d88e <lv_txt_utf8_get_byte_id+0x32>
        byte_cnt += lv_txt_encoded_size(&txt[byte_cnt]);
 801d870:	4b0b      	ldr	r3, [pc, #44]	; (801d8a0 <lv_txt_utf8_get_byte_id+0x44>)
 801d872:	681b      	ldr	r3, [r3, #0]
 801d874:	6879      	ldr	r1, [r7, #4]
 801d876:	68ba      	ldr	r2, [r7, #8]
 801d878:	440a      	add	r2, r1
 801d87a:	4610      	mov	r0, r2
 801d87c:	4798      	blx	r3
 801d87e:	4603      	mov	r3, r0
 801d880:	461a      	mov	r2, r3
 801d882:	68bb      	ldr	r3, [r7, #8]
 801d884:	4413      	add	r3, r2
 801d886:	60bb      	str	r3, [r7, #8]
    for(i = 0; i < utf8_id; i++) {
 801d888:	68fb      	ldr	r3, [r7, #12]
 801d88a:	3301      	adds	r3, #1
 801d88c:	60fb      	str	r3, [r7, #12]
 801d88e:	68fa      	ldr	r2, [r7, #12]
 801d890:	683b      	ldr	r3, [r7, #0]
 801d892:	429a      	cmp	r2, r3
 801d894:	d3ec      	bcc.n	801d870 <lv_txt_utf8_get_byte_id+0x14>
    }

    return byte_cnt;
 801d896:	68bb      	ldr	r3, [r7, #8]
}
 801d898:	4618      	mov	r0, r3
 801d89a:	3710      	adds	r7, #16
 801d89c:	46bd      	mov	sp, r7
 801d89e:	bd80      	pop	{r7, pc}
 801d8a0:	20000c30 	.word	0x20000c30

0801d8a4 <lv_txt_utf8_get_char_id>:
 * @param txt a '\0' terminated UTF-8 string
 * @param byte_id byte index
 * @return character index of the letter at 'byte_id'th position
 */
static uint32_t lv_txt_utf8_get_char_id(const char * txt, uint32_t byte_id)
{
 801d8a4:	b580      	push	{r7, lr}
 801d8a6:	b084      	sub	sp, #16
 801d8a8:	af00      	add	r7, sp, #0
 801d8aa:	6078      	str	r0, [r7, #4]
 801d8ac:	6039      	str	r1, [r7, #0]
    uint32_t i        = 0;
 801d8ae:	2300      	movs	r3, #0
 801d8b0:	60bb      	str	r3, [r7, #8]
    uint32_t char_cnt = 0;
 801d8b2:	2300      	movs	r3, #0
 801d8b4:	60fb      	str	r3, [r7, #12]

    while(i < byte_id) {
 801d8b6:	e009      	b.n	801d8cc <lv_txt_utf8_get_char_id+0x28>
        lv_txt_encoded_next(txt, &i); /*'i' points to the next letter so use the prev. value*/
 801d8b8:	4b09      	ldr	r3, [pc, #36]	; (801d8e0 <lv_txt_utf8_get_char_id+0x3c>)
 801d8ba:	681b      	ldr	r3, [r3, #0]
 801d8bc:	f107 0208 	add.w	r2, r7, #8
 801d8c0:	4611      	mov	r1, r2
 801d8c2:	6878      	ldr	r0, [r7, #4]
 801d8c4:	4798      	blx	r3
        char_cnt++;
 801d8c6:	68fb      	ldr	r3, [r7, #12]
 801d8c8:	3301      	adds	r3, #1
 801d8ca:	60fb      	str	r3, [r7, #12]
    while(i < byte_id) {
 801d8cc:	68bb      	ldr	r3, [r7, #8]
 801d8ce:	683a      	ldr	r2, [r7, #0]
 801d8d0:	429a      	cmp	r2, r3
 801d8d2:	d8f1      	bhi.n	801d8b8 <lv_txt_utf8_get_char_id+0x14>
    }

    return char_cnt;
 801d8d4:	68fb      	ldr	r3, [r7, #12]
}
 801d8d6:	4618      	mov	r0, r3
 801d8d8:	3710      	adds	r7, #16
 801d8da:	46bd      	mov	sp, r7
 801d8dc:	bd80      	pop	{r7, pc}
 801d8de:	bf00      	nop
 801d8e0:	20000c34 	.word	0x20000c34

0801d8e4 <lv_txt_utf8_get_length>:
 * E.g.: "BC" is 3 characters (but 4 bytes)
 * @param txt a '\0' terminated char string
 * @return number of characters
 */
static uint32_t lv_txt_utf8_get_length(const char * txt)
{
 801d8e4:	b580      	push	{r7, lr}
 801d8e6:	b084      	sub	sp, #16
 801d8e8:	af00      	add	r7, sp, #0
 801d8ea:	6078      	str	r0, [r7, #4]
    uint32_t len = 0;
 801d8ec:	2300      	movs	r3, #0
 801d8ee:	60fb      	str	r3, [r7, #12]
    uint32_t i   = 0;
 801d8f0:	2300      	movs	r3, #0
 801d8f2:	60bb      	str	r3, [r7, #8]

    while(txt[i] != '\0') {
 801d8f4:	e009      	b.n	801d90a <lv_txt_utf8_get_length+0x26>
        lv_txt_encoded_next(txt, &i);
 801d8f6:	4b0a      	ldr	r3, [pc, #40]	; (801d920 <lv_txt_utf8_get_length+0x3c>)
 801d8f8:	681b      	ldr	r3, [r3, #0]
 801d8fa:	f107 0208 	add.w	r2, r7, #8
 801d8fe:	4611      	mov	r1, r2
 801d900:	6878      	ldr	r0, [r7, #4]
 801d902:	4798      	blx	r3
        len++;
 801d904:	68fb      	ldr	r3, [r7, #12]
 801d906:	3301      	adds	r3, #1
 801d908:	60fb      	str	r3, [r7, #12]
    while(txt[i] != '\0') {
 801d90a:	68bb      	ldr	r3, [r7, #8]
 801d90c:	687a      	ldr	r2, [r7, #4]
 801d90e:	4413      	add	r3, r2
 801d910:	781b      	ldrb	r3, [r3, #0]
 801d912:	2b00      	cmp	r3, #0
 801d914:	d1ef      	bne.n	801d8f6 <lv_txt_utf8_get_length+0x12>
    }

    return len;
 801d916:	68fb      	ldr	r3, [r7, #12]
}
 801d918:	4618      	mov	r0, r3
 801d91a:	3710      	adds	r7, #16
 801d91c:	46bd      	mov	sp, r7
 801d91e:	bd80      	pop	{r7, pc}
 801d920:	20000c34 	.word	0x20000c34

0801d924 <is_break_char>:
 * Test if char is break char or not (a text can broken here or not)
 * @param letter a letter
 * @return false: 'letter' is not break char
 */
static inline bool is_break_char(uint32_t letter)
{
 801d924:	b480      	push	{r7}
 801d926:	b085      	sub	sp, #20
 801d928:	af00      	add	r7, sp, #0
 801d92a:	6078      	str	r0, [r7, #4]
    uint8_t i;
    bool ret = false;
 801d92c:	2300      	movs	r3, #0
 801d92e:	73bb      	strb	r3, [r7, #14]

    /*Compare the letter to TXT_BREAK_CHARS*/
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 801d930:	2300      	movs	r3, #0
 801d932:	73fb      	strb	r3, [r7, #15]
 801d934:	e00c      	b.n	801d950 <is_break_char+0x2c>
        if(letter == (uint32_t)LV_TXT_BREAK_CHARS[i]) {
 801d936:	7bfb      	ldrb	r3, [r7, #15]
 801d938:	4a0b      	ldr	r2, [pc, #44]	; (801d968 <is_break_char+0x44>)
 801d93a:	5cd3      	ldrb	r3, [r2, r3]
 801d93c:	461a      	mov	r2, r3
 801d93e:	687b      	ldr	r3, [r7, #4]
 801d940:	4293      	cmp	r3, r2
 801d942:	d102      	bne.n	801d94a <is_break_char+0x26>
            ret = true; /*If match then it is break char*/
 801d944:	2301      	movs	r3, #1
 801d946:	73bb      	strb	r3, [r7, #14]
            break;
 801d948:	e007      	b.n	801d95a <is_break_char+0x36>
    for(i = 0; LV_TXT_BREAK_CHARS[i] != '\0'; i++) {
 801d94a:	7bfb      	ldrb	r3, [r7, #15]
 801d94c:	3301      	adds	r3, #1
 801d94e:	73fb      	strb	r3, [r7, #15]
 801d950:	7bfb      	ldrb	r3, [r7, #15]
 801d952:	4a05      	ldr	r2, [pc, #20]	; (801d968 <is_break_char+0x44>)
 801d954:	5cd3      	ldrb	r3, [r2, r3]
 801d956:	2b00      	cmp	r3, #0
 801d958:	d1ed      	bne.n	801d936 <is_break_char+0x12>
        }
    }

    return ret;
 801d95a:	7bbb      	ldrb	r3, [r7, #14]
}
 801d95c:	4618      	mov	r0, r3
 801d95e:	3714      	adds	r7, #20
 801d960:	46bd      	mov	sp, r7
 801d962:	f85d 7b04 	ldr.w	r7, [sp], #4
 801d966:	4770      	bx	lr
 801d968:	08028f10 	.word	0x08028f10

0801d96c <lv_utils_bsearch>:
 *
 * @return a pointer to a matching item, or NULL if none exists.
 */
void * lv_utils_bsearch(const void * key, const void * base, uint32_t n, uint32_t size,
                        int32_t (*cmp)(const void * pRef, const void * pElement))
{
 801d96c:	b580      	push	{r7, lr}
 801d96e:	b086      	sub	sp, #24
 801d970:	af00      	add	r7, sp, #0
 801d972:	60f8      	str	r0, [r7, #12]
 801d974:	60b9      	str	r1, [r7, #8]
 801d976:	607a      	str	r2, [r7, #4]
 801d978:	603b      	str	r3, [r7, #0]
    const char * middle;
    int32_t c;

    for(middle = base; n != 0;) {
 801d97a:	68bb      	ldr	r3, [r7, #8]
 801d97c:	617b      	str	r3, [r7, #20]
 801d97e:	e02d      	b.n	801d9dc <lv_utils_bsearch+0x70>
        middle += (n / 2) * size;
 801d980:	687b      	ldr	r3, [r7, #4]
 801d982:	085b      	lsrs	r3, r3, #1
 801d984:	683a      	ldr	r2, [r7, #0]
 801d986:	fb02 f303 	mul.w	r3, r2, r3
 801d98a:	697a      	ldr	r2, [r7, #20]
 801d98c:	4413      	add	r3, r2
 801d98e:	617b      	str	r3, [r7, #20]
        if((c = (*cmp)(key, middle)) > 0) {
 801d990:	6a3b      	ldr	r3, [r7, #32]
 801d992:	6979      	ldr	r1, [r7, #20]
 801d994:	68f8      	ldr	r0, [r7, #12]
 801d996:	4798      	blx	r3
 801d998:	6138      	str	r0, [r7, #16]
 801d99a:	693b      	ldr	r3, [r7, #16]
 801d99c:	2b00      	cmp	r3, #0
 801d99e:	dd12      	ble.n	801d9c6 <lv_utils_bsearch+0x5a>
            n    = (n / 2) - ((n & 1) == 0);
 801d9a0:	687b      	ldr	r3, [r7, #4]
 801d9a2:	085b      	lsrs	r3, r3, #1
 801d9a4:	687a      	ldr	r2, [r7, #4]
 801d9a6:	f002 0201 	and.w	r2, r2, #1
 801d9aa:	2a00      	cmp	r2, #0
 801d9ac:	bf0c      	ite	eq
 801d9ae:	2201      	moveq	r2, #1
 801d9b0:	2200      	movne	r2, #0
 801d9b2:	b2d2      	uxtb	r2, r2
 801d9b4:	1a9b      	subs	r3, r3, r2
 801d9b6:	607b      	str	r3, [r7, #4]
            base = (middle += size);
 801d9b8:	697a      	ldr	r2, [r7, #20]
 801d9ba:	683b      	ldr	r3, [r7, #0]
 801d9bc:	4413      	add	r3, r2
 801d9be:	617b      	str	r3, [r7, #20]
 801d9c0:	697b      	ldr	r3, [r7, #20]
 801d9c2:	60bb      	str	r3, [r7, #8]
 801d9c4:	e00a      	b.n	801d9dc <lv_utils_bsearch+0x70>
        } else if(c < 0) {
 801d9c6:	693b      	ldr	r3, [r7, #16]
 801d9c8:	2b00      	cmp	r3, #0
 801d9ca:	da05      	bge.n	801d9d8 <lv_utils_bsearch+0x6c>
            n /= 2;
 801d9cc:	687b      	ldr	r3, [r7, #4]
 801d9ce:	085b      	lsrs	r3, r3, #1
 801d9d0:	607b      	str	r3, [r7, #4]
            middle = base;
 801d9d2:	68bb      	ldr	r3, [r7, #8]
 801d9d4:	617b      	str	r3, [r7, #20]
 801d9d6:	e001      	b.n	801d9dc <lv_utils_bsearch+0x70>
        } else {
            return (char *)middle;
 801d9d8:	697b      	ldr	r3, [r7, #20]
 801d9da:	e003      	b.n	801d9e4 <lv_utils_bsearch+0x78>
    for(middle = base; n != 0;) {
 801d9dc:	687b      	ldr	r3, [r7, #4]
 801d9de:	2b00      	cmp	r3, #0
 801d9e0:	d1ce      	bne.n	801d980 <lv_utils_bsearch+0x14>
        }
    }
    return NULL;
 801d9e2:	2300      	movs	r3, #0
}
 801d9e4:	4618      	mov	r0, r3
 801d9e6:	3718      	adds	r7, #24
 801d9e8:	46bd      	mov	sp, r7
 801d9ea:	bd80      	pop	{r7, pc}

0801d9ec <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 801d9ec:	b580      	push	{r7, lr}
 801d9ee:	b082      	sub	sp, #8
 801d9f0:	af00      	add	r7, sp, #0
 801d9f2:	6078      	str	r0, [r7, #4]
 801d9f4:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 801d9f6:	2208      	movs	r2, #8
 801d9f8:	6839      	ldr	r1, [r7, #0]
 801d9fa:	6878      	ldr	r0, [r7, #4]
 801d9fc:	f009 fbde 	bl	80271bc <memcpy>
}
 801da00:	bf00      	nop
 801da02:	3708      	adds	r7, #8
 801da04:	46bd      	mov	sp, r7
 801da06:	bd80      	pop	{r7, pc}

0801da08 <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 801da08:	b480      	push	{r7}
 801da0a:	b083      	sub	sp, #12
 801da0c:	af00      	add	r7, sp, #0
 801da0e:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 801da10:	687b      	ldr	r3, [r7, #4]
 801da12:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801da16:	b29a      	uxth	r2, r3
 801da18:	687b      	ldr	r3, [r7, #4]
 801da1a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801da1e:	b29b      	uxth	r3, r3
 801da20:	1ad3      	subs	r3, r2, r3
 801da22:	b29b      	uxth	r3, r3
 801da24:	3301      	adds	r3, #1
 801da26:	b29b      	uxth	r3, r3
 801da28:	b21b      	sxth	r3, r3
}
 801da2a:	4618      	mov	r0, r3
 801da2c:	370c      	adds	r7, #12
 801da2e:	46bd      	mov	sp, r7
 801da30:	f85d 7b04 	ldr.w	r7, [sp], #4
 801da34:	4770      	bx	lr

0801da36 <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 801da36:	b480      	push	{r7}
 801da38:	b083      	sub	sp, #12
 801da3a:	af00      	add	r7, sp, #0
 801da3c:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 801da3e:	687b      	ldr	r3, [r7, #4]
 801da40:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801da44:	b29a      	uxth	r2, r3
 801da46:	687b      	ldr	r3, [r7, #4]
 801da48:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801da4c:	b29b      	uxth	r3, r3
 801da4e:	1ad3      	subs	r3, r2, r3
 801da50:	b29b      	uxth	r3, r3
 801da52:	3301      	adds	r3, #1
 801da54:	b29b      	uxth	r3, r3
 801da56:	b21b      	sxth	r3, r3
}
 801da58:	4618      	mov	r0, r3
 801da5a:	370c      	adds	r7, #12
 801da5c:	46bd      	mov	sp, r7
 801da5e:	f85d 7b04 	ldr.w	r7, [sp], #4
 801da62:	4770      	bx	lr

0801da64 <lv_bar_create>:
 * @param par pointer to an object, it will be the parent of the new bar
 * @param copy pointer to a bar object, if not NULL then the new object will be copied from it
 * @return pointer to the created bar
 */
lv_obj_t * lv_bar_create(lv_obj_t * par, const lv_obj_t * copy)
{
 801da64:	b580      	push	{r7, lr}
 801da66:	b086      	sub	sp, #24
 801da68:	af00      	add	r7, sp, #0
 801da6a:	6078      	str	r0, [r7, #4]
 801da6c:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("lv_bar create started");

    /*Create the ancestor basic object*/
    lv_obj_t * new_bar = lv_obj_create(par, copy);
 801da6e:	6839      	ldr	r1, [r7, #0]
 801da70:	6878      	ldr	r0, [r7, #4]
 801da72:	f7f2 fe87 	bl	8010784 <lv_obj_create>
 801da76:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_bar);
 801da78:	697b      	ldr	r3, [r7, #20]
 801da7a:	2b00      	cmp	r3, #0
 801da7c:	d106      	bne.n	801da8c <lv_bar_create+0x28>
 801da7e:	4b5c      	ldr	r3, [pc, #368]	; (801dbf0 <lv_bar_create+0x18c>)
 801da80:	2240      	movs	r2, #64	; 0x40
 801da82:	495c      	ldr	r1, [pc, #368]	; (801dbf4 <lv_bar_create+0x190>)
 801da84:	2003      	movs	r0, #3
 801da86:	f7fe fec1 	bl	801c80c <lv_log_add>
 801da8a:	e7fe      	b.n	801da8a <lv_bar_create+0x26>
    if(new_bar == NULL) return NULL;
 801da8c:	697b      	ldr	r3, [r7, #20]
 801da8e:	2b00      	cmp	r3, #0
 801da90:	d101      	bne.n	801da96 <lv_bar_create+0x32>
 801da92:	2300      	movs	r3, #0
 801da94:	e0a8      	b.n	801dbe8 <lv_bar_create+0x184>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_bar);
 801da96:	4b58      	ldr	r3, [pc, #352]	; (801dbf8 <lv_bar_create+0x194>)
 801da98:	681b      	ldr	r3, [r3, #0]
 801da9a:	2b00      	cmp	r3, #0
 801da9c:	d105      	bne.n	801daaa <lv_bar_create+0x46>
 801da9e:	6978      	ldr	r0, [r7, #20]
 801daa0:	f7f4 fcaf 	bl	8012402 <lv_obj_get_signal_cb>
 801daa4:	4602      	mov	r2, r0
 801daa6:	4b54      	ldr	r3, [pc, #336]	; (801dbf8 <lv_bar_create+0x194>)
 801daa8:	601a      	str	r2, [r3, #0]
    if(ancestor_design_f == NULL) ancestor_design_f = lv_obj_get_design_cb(new_bar);
 801daaa:	4b54      	ldr	r3, [pc, #336]	; (801dbfc <lv_bar_create+0x198>)
 801daac:	681b      	ldr	r3, [r3, #0]
 801daae:	2b00      	cmp	r3, #0
 801dab0:	d105      	bne.n	801dabe <lv_bar_create+0x5a>
 801dab2:	6978      	ldr	r0, [r7, #20]
 801dab4:	f7f4 fcb1 	bl	801241a <lv_obj_get_design_cb>
 801dab8:	4602      	mov	r2, r0
 801daba:	4b50      	ldr	r3, [pc, #320]	; (801dbfc <lv_bar_create+0x198>)
 801dabc:	601a      	str	r2, [r3, #0]

    /*Allocate the object type specific extended data*/
    lv_bar_ext_t * ext = lv_obj_allocate_ext_attr(new_bar, sizeof(lv_bar_ext_t));
 801dabe:	2114      	movs	r1, #20
 801dac0:	6978      	ldr	r0, [r7, #20]
 801dac2:	f7f4 fa79 	bl	8011fb8 <lv_obj_allocate_ext_attr>
 801dac6:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 801dac8:	693b      	ldr	r3, [r7, #16]
 801daca:	2b00      	cmp	r3, #0
 801dacc:	d106      	bne.n	801dadc <lv_bar_create+0x78>
 801dace:	4b48      	ldr	r3, [pc, #288]	; (801dbf0 <lv_bar_create+0x18c>)
 801dad0:	2248      	movs	r2, #72	; 0x48
 801dad2:	4948      	ldr	r1, [pc, #288]	; (801dbf4 <lv_bar_create+0x190>)
 801dad4:	2003      	movs	r0, #3
 801dad6:	f7fe fe99 	bl	801c80c <lv_log_add>
 801dada:	e7fe      	b.n	801dada <lv_bar_create+0x76>
    if(ext == NULL) return NULL;
 801dadc:	693b      	ldr	r3, [r7, #16]
 801dade:	2b00      	cmp	r3, #0
 801dae0:	d101      	bne.n	801dae6 <lv_bar_create+0x82>
 801dae2:	2300      	movs	r3, #0
 801dae4:	e080      	b.n	801dbe8 <lv_bar_create+0x184>

    ext->min_value = 0;
 801dae6:	693b      	ldr	r3, [r7, #16]
 801dae8:	2200      	movs	r2, #0
 801daea:	805a      	strh	r2, [r3, #2]
    ext->max_value = 100;
 801daec:	693b      	ldr	r3, [r7, #16]
 801daee:	2264      	movs	r2, #100	; 0x64
 801daf0:	809a      	strh	r2, [r3, #4]
    ext->cur_value = 0;
 801daf2:	693b      	ldr	r3, [r7, #16]
 801daf4:	2200      	movs	r2, #0
 801daf6:	801a      	strh	r2, [r3, #0]
#if LV_USE_ANIMATION
    ext->anim_time  = 200;
 801daf8:	693b      	ldr	r3, [r7, #16]
 801dafa:	22c8      	movs	r2, #200	; 0xc8
 801dafc:	819a      	strh	r2, [r3, #12]
    ext->anim_start = 0;
 801dafe:	693b      	ldr	r3, [r7, #16]
 801db00:	2200      	movs	r2, #0
 801db02:	80da      	strh	r2, [r3, #6]
    ext->anim_end   = 0;
 801db04:	693b      	ldr	r3, [r7, #16]
 801db06:	2200      	movs	r2, #0
 801db08:	811a      	strh	r2, [r3, #8]
    ext->anim_state = LV_BAR_ANIM_STATE_INV;
 801db0a:	693b      	ldr	r3, [r7, #16]
 801db0c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801db10:	815a      	strh	r2, [r3, #10]
#endif
    ext->sym         = 0;
 801db12:	693a      	ldr	r2, [r7, #16]
 801db14:	7b93      	ldrb	r3, [r2, #14]
 801db16:	f36f 0300 	bfc	r3, #0, #1
 801db1a:	7393      	strb	r3, [r2, #14]
    ext->style_indic = &lv_style_pretty_color;
 801db1c:	693b      	ldr	r3, [r7, #16]
 801db1e:	4a38      	ldr	r2, [pc, #224]	; (801dc00 <lv_bar_create+0x19c>)
 801db20:	611a      	str	r2, [r3, #16]

    lv_obj_set_signal_cb(new_bar, lv_bar_signal);
 801db22:	4938      	ldr	r1, [pc, #224]	; (801dc04 <lv_bar_create+0x1a0>)
 801db24:	6978      	ldr	r0, [r7, #20]
 801db26:	f7f4 fa2b 	bl	8011f80 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_bar, lv_bar_design);
 801db2a:	4937      	ldr	r1, [pc, #220]	; (801dc08 <lv_bar_create+0x1a4>)
 801db2c:	6978      	ldr	r0, [r7, #20]
 801db2e:	f7f4 fa35 	bl	8011f9c <lv_obj_set_design_cb>

    /*Init the new  bar object*/
    if(copy == NULL) {
 801db32:	683b      	ldr	r3, [r7, #0]
 801db34:	2b00      	cmp	r3, #0
 801db36:	d12a      	bne.n	801db8e <lv_bar_create+0x12a>
        lv_obj_set_click(new_bar, false);
 801db38:	2100      	movs	r1, #0
 801db3a:	6978      	ldr	r0, [r7, #20]
 801db3c:	f7f4 f913 	bl	8011d66 <lv_obj_set_click>
        lv_obj_set_size(new_bar, LV_DPI * 2, LV_DPI / 3);
 801db40:	2221      	movs	r2, #33	; 0x21
 801db42:	21c8      	movs	r1, #200	; 0xc8
 801db44:	6978      	ldr	r0, [r7, #20]
 801db46:	f7f3 fb38 	bl	80111ba <lv_obj_set_size>
        lv_bar_set_value(new_bar, ext->cur_value, false);
 801db4a:	693b      	ldr	r3, [r7, #16]
 801db4c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801db50:	2200      	movs	r2, #0
 801db52:	4619      	mov	r1, r3
 801db54:	6978      	ldr	r0, [r7, #20]
 801db56:	f000 f85b 	bl	801dc10 <lv_bar_set_value>

        lv_theme_t * th = lv_theme_get_current();
 801db5a:	f007 ff19 	bl	8025990 <lv_theme_get_current>
 801db5e:	60b8      	str	r0, [r7, #8]
        if(th) {
 801db60:	68bb      	ldr	r3, [r7, #8]
 801db62:	2b00      	cmp	r3, #0
 801db64:	d00e      	beq.n	801db84 <lv_bar_create+0x120>
            lv_bar_set_style(new_bar, LV_BAR_STYLE_BG, th->style.bar.bg);
 801db66:	68bb      	ldr	r3, [r7, #8]
 801db68:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 801db6a:	461a      	mov	r2, r3
 801db6c:	2100      	movs	r1, #0
 801db6e:	6978      	ldr	r0, [r7, #20]
 801db70:	f000 f91e 	bl	801ddb0 <lv_bar_set_style>
            lv_bar_set_style(new_bar, LV_BAR_STYLE_INDIC, th->style.bar.indic);
 801db74:	68bb      	ldr	r3, [r7, #8]
 801db76:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 801db78:	461a      	mov	r2, r3
 801db7a:	2101      	movs	r1, #1
 801db7c:	6978      	ldr	r0, [r7, #20]
 801db7e:	f000 f917 	bl	801ddb0 <lv_bar_set_style>
 801db82:	e030      	b.n	801dbe6 <lv_bar_create+0x182>
        } else {
            lv_obj_set_style(new_bar, &lv_style_pretty);
 801db84:	4921      	ldr	r1, [pc, #132]	; (801dc0c <lv_bar_create+0x1a8>)
 801db86:	6978      	ldr	r0, [r7, #20]
 801db88:	f7f4 f893 	bl	8011cb2 <lv_obj_set_style>
 801db8c:	e02b      	b.n	801dbe6 <lv_bar_create+0x182>
        }
    } else {
        lv_bar_ext_t * ext_copy = lv_obj_get_ext_attr(copy);
 801db8e:	6838      	ldr	r0, [r7, #0]
 801db90:	f7f4 fc4f 	bl	8012432 <lv_obj_get_ext_attr>
 801db94:	60f8      	str	r0, [r7, #12]
        ext->min_value          = ext_copy->min_value;
 801db96:	68fb      	ldr	r3, [r7, #12]
 801db98:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 801db9c:	693b      	ldr	r3, [r7, #16]
 801db9e:	805a      	strh	r2, [r3, #2]
        ext->max_value          = ext_copy->max_value;
 801dba0:	68fb      	ldr	r3, [r7, #12]
 801dba2:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 801dba6:	693b      	ldr	r3, [r7, #16]
 801dba8:	809a      	strh	r2, [r3, #4]
        ext->cur_value          = ext_copy->cur_value;
 801dbaa:	68fb      	ldr	r3, [r7, #12]
 801dbac:	f9b3 2000 	ldrsh.w	r2, [r3]
 801dbb0:	693b      	ldr	r3, [r7, #16]
 801dbb2:	801a      	strh	r2, [r3, #0]
        ext->style_indic        = ext_copy->style_indic;
 801dbb4:	68fb      	ldr	r3, [r7, #12]
 801dbb6:	691a      	ldr	r2, [r3, #16]
 801dbb8:	693b      	ldr	r3, [r7, #16]
 801dbba:	611a      	str	r2, [r3, #16]
        ext->sym                = ext_copy->sym;
 801dbbc:	68fb      	ldr	r3, [r7, #12]
 801dbbe:	7b9b      	ldrb	r3, [r3, #14]
 801dbc0:	f3c3 0300 	ubfx	r3, r3, #0, #1
 801dbc4:	b2d9      	uxtb	r1, r3
 801dbc6:	693a      	ldr	r2, [r7, #16]
 801dbc8:	7b93      	ldrb	r3, [r2, #14]
 801dbca:	f361 0300 	bfi	r3, r1, #0, #1
 801dbce:	7393      	strb	r3, [r2, #14]
        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_bar);
 801dbd0:	6978      	ldr	r0, [r7, #20]
 801dbd2:	f7f4 f880 	bl	8011cd6 <lv_obj_refresh_style>

        lv_bar_set_value(new_bar, ext->cur_value, false);
 801dbd6:	693b      	ldr	r3, [r7, #16]
 801dbd8:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dbdc:	2200      	movs	r2, #0
 801dbde:	4619      	mov	r1, r3
 801dbe0:	6978      	ldr	r0, [r7, #20]
 801dbe2:	f000 f815 	bl	801dc10 <lv_bar_set_value>
    }

    LV_LOG_INFO("bar created");

    return new_bar;
 801dbe6:	697b      	ldr	r3, [r7, #20]
}
 801dbe8:	4618      	mov	r0, r3
 801dbea:	3718      	adds	r7, #24
 801dbec:	46bd      	mov	sp, r7
 801dbee:	bd80      	pop	{r7, pc}
 801dbf0:	08028f18 	.word	0x08028f18
 801dbf4:	08028f28 	.word	0x08028f28
 801dbf8:	2000c3b0 	.word	0x2000c3b0
 801dbfc:	2000c3ac 	.word	0x2000c3ac
 801dc00:	2000dc38 	.word	0x2000dc38
 801dc04:	0801e339 	.word	0x0801e339
 801dc08:	0801dea9 	.word	0x0801dea9
 801dc0c:	2000dd28 	.word	0x2000dd28

0801dc10 <lv_bar_set_value>:
 * @param bar pointer to a bar object
 * @param value new value
 * @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediatelly
 */
void lv_bar_set_value(lv_obj_t * bar, int16_t value, lv_anim_enable_t anim)
{
 801dc10:	b580      	push	{r7, lr}
 801dc12:	b08e      	sub	sp, #56	; 0x38
 801dc14:	af00      	add	r7, sp, #0
 801dc16:	6078      	str	r0, [r7, #4]
 801dc18:	460b      	mov	r3, r1
 801dc1a:	807b      	strh	r3, [r7, #2]
 801dc1c:	4613      	mov	r3, r2
 801dc1e:	707b      	strb	r3, [r7, #1]
#if LV_USE_ANIMATION == 0
    anim = false;
#endif
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801dc20:	6878      	ldr	r0, [r7, #4]
 801dc22:	f7f4 fc06 	bl	8012432 <lv_obj_get_ext_attr>
 801dc26:	6378      	str	r0, [r7, #52]	; 0x34
    if(ext->cur_value == value) return;
 801dc28:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc2a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dc2e:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801dc32:	429a      	cmp	r2, r3
 801dc34:	d063      	beq.n	801dcfe <lv_bar_set_value+0xee>

    int16_t new_value;
    new_value = value > ext->max_value ? ext->max_value : value;
 801dc36:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc38:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801dc3c:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801dc40:	4293      	cmp	r3, r2
 801dc42:	bfa8      	it	ge
 801dc44:	4613      	movge	r3, r2
 801dc46:	867b      	strh	r3, [r7, #50]	; 0x32
    new_value = new_value < ext->min_value ? ext->min_value : new_value;
 801dc48:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc4a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801dc4e:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801dc52:	4293      	cmp	r3, r2
 801dc54:	bfb8      	it	lt
 801dc56:	4613      	movlt	r3, r2
 801dc58:	867b      	strh	r3, [r7, #50]	; 0x32

    if(ext->cur_value == new_value) return;
 801dc5a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dc60:	f9b7 2032 	ldrsh.w	r2, [r7, #50]	; 0x32
 801dc64:	429a      	cmp	r2, r3
 801dc66:	d04c      	beq.n	801dd02 <lv_bar_set_value+0xf2>

    if(anim == LV_ANIM_OFF) {
 801dc68:	787b      	ldrb	r3, [r7, #1]
 801dc6a:	2b00      	cmp	r3, #0
 801dc6c:	d106      	bne.n	801dc7c <lv_bar_set_value+0x6c>
        ext->cur_value = new_value;
 801dc6e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc70:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 801dc72:	801a      	strh	r2, [r3, #0]
        lv_obj_invalidate(bar);
 801dc74:	6878      	ldr	r0, [r7, #4]
 801dc76:	f7f3 f8da 	bl	8010e2e <lv_obj_invalidate>
 801dc7a:	e043      	b.n	801dd04 <lv_bar_set_value+0xf4>
    } else {
#if LV_USE_ANIMATION
        /*No animation in progress -> simply set the values*/
        if(ext->anim_state == LV_BAR_ANIM_STATE_INV) {
 801dc7c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc7e:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801dc82:	f1b3 3fff 	cmp.w	r3, #4294967295
 801dc86:	d108      	bne.n	801dc9a <lv_bar_set_value+0x8a>
            ext->anim_start = ext->cur_value;
 801dc88:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc8a:	f9b3 2000 	ldrsh.w	r2, [r3]
 801dc8e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc90:	80da      	strh	r2, [r3, #6]
            ext->anim_end   = new_value;
 801dc92:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc94:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 801dc96:	811a      	strh	r2, [r3, #8]
 801dc98:	e007      	b.n	801dcaa <lv_bar_set_value+0x9a>
        }
        /*Animation in progress. Start from the animation end value*/
        else {
            ext->anim_start = ext->anim_end;
 801dc9a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dc9c:	f9b3 2008 	ldrsh.w	r2, [r3, #8]
 801dca0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dca2:	80da      	strh	r2, [r3, #6]
            ext->anim_end   = new_value;
 801dca4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dca6:	8e7a      	ldrh	r2, [r7, #50]	; 0x32
 801dca8:	811a      	strh	r2, [r3, #8]
        }

        lv_anim_t a;
        a.var            = bar;
 801dcaa:	687b      	ldr	r3, [r7, #4]
 801dcac:	60bb      	str	r3, [r7, #8]
        a.start          = LV_BAR_ANIM_STATE_START;
 801dcae:	2300      	movs	r3, #0
 801dcb0:	61bb      	str	r3, [r7, #24]
        a.end            = LV_BAR_ANIM_STATE_END;
 801dcb2:	f44f 7380 	mov.w	r3, #256	; 0x100
 801dcb6:	61fb      	str	r3, [r7, #28]
        a.exec_cb        = (lv_anim_exec_xcb_t)lv_bar_anim;
 801dcb8:	4b14      	ldr	r3, [pc, #80]	; (801dd0c <lv_bar_set_value+0xfc>)
 801dcba:	60fb      	str	r3, [r7, #12]
        a.path_cb        = lv_anim_path_linear;
 801dcbc:	4b14      	ldr	r3, [pc, #80]	; (801dd10 <lv_bar_set_value+0x100>)
 801dcbe:	613b      	str	r3, [r7, #16]
        a.ready_cb       = lv_bar_anim_ready;
 801dcc0:	4b14      	ldr	r3, [pc, #80]	; (801dd14 <lv_bar_set_value+0x104>)
 801dcc2:	617b      	str	r3, [r7, #20]
        a.act_time       = 0;
 801dcc4:	2300      	movs	r3, #0
 801dcc6:	847b      	strh	r3, [r7, #34]	; 0x22
        a.time           = ext->anim_time;
 801dcc8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801dcca:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 801dcce:	b29b      	uxth	r3, r3
 801dcd0:	843b      	strh	r3, [r7, #32]
        a.playback       = 0;
 801dcd2:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801dcd6:	f36f 0300 	bfc	r3, #0, #1
 801dcda:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        a.playback_pause = 0;
 801dcde:	2300      	movs	r3, #0
 801dce0:	84bb      	strh	r3, [r7, #36]	; 0x24
        a.repeat         = 0;
 801dce2:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801dce6:	f36f 0341 	bfc	r3, #1, #1
 801dcea:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        a.repeat_pause   = 0;
 801dcee:	2300      	movs	r3, #0
 801dcf0:	84fb      	strh	r3, [r7, #38]	; 0x26

        lv_anim_create(&a);
 801dcf2:	f107 0308 	add.w	r3, r7, #8
 801dcf6:	4618      	mov	r0, r3
 801dcf8:	f7fd fc28 	bl	801b54c <lv_anim_create>
 801dcfc:	e002      	b.n	801dd04 <lv_bar_set_value+0xf4>
    if(ext->cur_value == value) return;
 801dcfe:	bf00      	nop
 801dd00:	e000      	b.n	801dd04 <lv_bar_set_value+0xf4>
    if(ext->cur_value == new_value) return;
 801dd02:	bf00      	nop
#endif
    }
}
 801dd04:	3738      	adds	r7, #56	; 0x38
 801dd06:	46bd      	mov	sp, r7
 801dd08:	bd80      	pop	{r7, pc}
 801dd0a:	bf00      	nop
 801dd0c:	0801e3d5 	.word	0x0801e3d5
 801dd10:	0801b6b1 	.word	0x0801b6b1
 801dd14:	0801e3fd 	.word	0x0801e3fd

0801dd18 <lv_bar_set_range>:
 * @param bar pointer to the bar object
 * @param min minimum value
 * @param max maximum value
 */
void lv_bar_set_range(lv_obj_t * bar, int16_t min, int16_t max)
{
 801dd18:	b580      	push	{r7, lr}
 801dd1a:	b084      	sub	sp, #16
 801dd1c:	af00      	add	r7, sp, #0
 801dd1e:	6078      	str	r0, [r7, #4]
 801dd20:	460b      	mov	r3, r1
 801dd22:	807b      	strh	r3, [r7, #2]
 801dd24:	4613      	mov	r3, r2
 801dd26:	803b      	strh	r3, [r7, #0]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801dd28:	6878      	ldr	r0, [r7, #4]
 801dd2a:	f7f4 fb82 	bl	8012432 <lv_obj_get_ext_attr>
 801dd2e:	60f8      	str	r0, [r7, #12]
    if(ext->min_value == min && ext->max_value == max) return;
 801dd30:	68fb      	ldr	r3, [r7, #12]
 801dd32:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801dd36:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801dd3a:	429a      	cmp	r2, r3
 801dd3c:	d106      	bne.n	801dd4c <lv_bar_set_range+0x34>
 801dd3e:	68fb      	ldr	r3, [r7, #12]
 801dd40:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801dd44:	f9b7 2000 	ldrsh.w	r2, [r7]
 801dd48:	429a      	cmp	r2, r3
 801dd4a:	d02d      	beq.n	801dda8 <lv_bar_set_range+0x90>

    ext->max_value = max;
 801dd4c:	68fb      	ldr	r3, [r7, #12]
 801dd4e:	883a      	ldrh	r2, [r7, #0]
 801dd50:	809a      	strh	r2, [r3, #4]
    ext->min_value = min;
 801dd52:	68fb      	ldr	r3, [r7, #12]
 801dd54:	887a      	ldrh	r2, [r7, #2]
 801dd56:	805a      	strh	r2, [r3, #2]
    if(ext->cur_value > max) {
 801dd58:	68fb      	ldr	r3, [r7, #12]
 801dd5a:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd5e:	f9b7 2000 	ldrsh.w	r2, [r7]
 801dd62:	429a      	cmp	r2, r3
 801dd64:	da0a      	bge.n	801dd7c <lv_bar_set_range+0x64>
        ext->cur_value = max;
 801dd66:	68fb      	ldr	r3, [r7, #12]
 801dd68:	883a      	ldrh	r2, [r7, #0]
 801dd6a:	801a      	strh	r2, [r3, #0]
        lv_bar_set_value(bar, ext->cur_value, false);
 801dd6c:	68fb      	ldr	r3, [r7, #12]
 801dd6e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd72:	2200      	movs	r2, #0
 801dd74:	4619      	mov	r1, r3
 801dd76:	6878      	ldr	r0, [r7, #4]
 801dd78:	f7ff ff4a 	bl	801dc10 <lv_bar_set_value>
    }
    if(ext->cur_value < min) {
 801dd7c:	68fb      	ldr	r3, [r7, #12]
 801dd7e:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd82:	f9b7 2002 	ldrsh.w	r2, [r7, #2]
 801dd86:	429a      	cmp	r2, r3
 801dd88:	dd0a      	ble.n	801dda0 <lv_bar_set_range+0x88>
        ext->cur_value = min;
 801dd8a:	68fb      	ldr	r3, [r7, #12]
 801dd8c:	887a      	ldrh	r2, [r7, #2]
 801dd8e:	801a      	strh	r2, [r3, #0]
        lv_bar_set_value(bar, ext->cur_value, false);
 801dd90:	68fb      	ldr	r3, [r7, #12]
 801dd92:	f9b3 3000 	ldrsh.w	r3, [r3]
 801dd96:	2200      	movs	r2, #0
 801dd98:	4619      	mov	r1, r3
 801dd9a:	6878      	ldr	r0, [r7, #4]
 801dd9c:	f7ff ff38 	bl	801dc10 <lv_bar_set_value>
    }
    lv_obj_invalidate(bar);
 801dda0:	6878      	ldr	r0, [r7, #4]
 801dda2:	f7f3 f844 	bl	8010e2e <lv_obj_invalidate>
 801dda6:	e000      	b.n	801ddaa <lv_bar_set_range+0x92>
    if(ext->min_value == min && ext->max_value == max) return;
 801dda8:	bf00      	nop
}
 801ddaa:	3710      	adds	r7, #16
 801ddac:	46bd      	mov	sp, r7
 801ddae:	bd80      	pop	{r7, pc}

0801ddb0 <lv_bar_set_style>:
 * @param bar pointer to a bar object
 * @param type which style should be set
 * @param style pointer to a style
 */
void lv_bar_set_style(lv_obj_t * bar, lv_bar_style_t type, const lv_style_t * style)
{
 801ddb0:	b580      	push	{r7, lr}
 801ddb2:	b086      	sub	sp, #24
 801ddb4:	af00      	add	r7, sp, #0
 801ddb6:	60f8      	str	r0, [r7, #12]
 801ddb8:	460b      	mov	r3, r1
 801ddba:	607a      	str	r2, [r7, #4]
 801ddbc:	72fb      	strb	r3, [r7, #11]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801ddbe:	68f8      	ldr	r0, [r7, #12]
 801ddc0:	f7f4 fb37 	bl	8012432 <lv_obj_get_ext_attr>
 801ddc4:	6178      	str	r0, [r7, #20]

    switch(type) {
 801ddc6:	7afb      	ldrb	r3, [r7, #11]
 801ddc8:	2b00      	cmp	r3, #0
 801ddca:	d002      	beq.n	801ddd2 <lv_bar_set_style+0x22>
 801ddcc:	2b01      	cmp	r3, #1
 801ddce:	d005      	beq.n	801dddc <lv_bar_set_style+0x2c>
        case LV_BAR_STYLE_INDIC:
            ext->style_indic = style;
            lv_obj_refresh_ext_draw_pad(bar);
            break;
    }
}
 801ddd0:	e00b      	b.n	801ddea <lv_bar_set_style+0x3a>
        case LV_BAR_STYLE_BG: lv_obj_set_style(bar, style); break;
 801ddd2:	6879      	ldr	r1, [r7, #4]
 801ddd4:	68f8      	ldr	r0, [r7, #12]
 801ddd6:	f7f3 ff6c 	bl	8011cb2 <lv_obj_set_style>
 801ddda:	e006      	b.n	801ddea <lv_bar_set_style+0x3a>
            ext->style_indic = style;
 801dddc:	697b      	ldr	r3, [r7, #20]
 801ddde:	687a      	ldr	r2, [r7, #4]
 801dde0:	611a      	str	r2, [r3, #16]
            lv_obj_refresh_ext_draw_pad(bar);
 801dde2:	68f8      	ldr	r0, [r7, #12]
 801dde4:	f7f4 f8fe 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>
            break;
 801dde8:	bf00      	nop
}
 801ddea:	bf00      	nop
 801ddec:	3718      	adds	r7, #24
 801ddee:	46bd      	mov	sp, r7
 801ddf0:	bd80      	pop	{r7, pc}

0801ddf2 <lv_bar_get_value>:
 * Get the value of a bar
 * @param bar pointer to a bar object
 * @return the value of the bar
 */
int16_t lv_bar_get_value(const lv_obj_t * bar)
{
 801ddf2:	b580      	push	{r7, lr}
 801ddf4:	b084      	sub	sp, #16
 801ddf6:	af00      	add	r7, sp, #0
 801ddf8:	6078      	str	r0, [r7, #4]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801ddfa:	6878      	ldr	r0, [r7, #4]
 801ddfc:	f7f4 fb19 	bl	8012432 <lv_obj_get_ext_attr>
 801de00:	60f8      	str	r0, [r7, #12]
    /*If animated tell that it's already at the end value*/
#if LV_USE_ANIMATION
    if(ext->anim_state != LV_BAR_ANIM_STATE_INV) return ext->anim_end;
 801de02:	68fb      	ldr	r3, [r7, #12]
 801de04:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801de08:	f1b3 3fff 	cmp.w	r3, #4294967295
 801de0c:	d003      	beq.n	801de16 <lv_bar_get_value+0x24>
 801de0e:	68fb      	ldr	r3, [r7, #12]
 801de10:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801de14:	e002      	b.n	801de1c <lv_bar_get_value+0x2a>
#endif
    /*No animation, simple return the current value*/
    return ext->cur_value;
 801de16:	68fb      	ldr	r3, [r7, #12]
 801de18:	f9b3 3000 	ldrsh.w	r3, [r3]
}
 801de1c:	4618      	mov	r0, r3
 801de1e:	3710      	adds	r7, #16
 801de20:	46bd      	mov	sp, r7
 801de22:	bd80      	pop	{r7, pc}

0801de24 <lv_bar_get_min_value>:
 * Get the minimum value of a bar
 * @param bar pointer to a bar object
 * @return the minimum value of the bar
 */
int16_t lv_bar_get_min_value(const lv_obj_t * bar)
{
 801de24:	b580      	push	{r7, lr}
 801de26:	b084      	sub	sp, #16
 801de28:	af00      	add	r7, sp, #0
 801de2a:	6078      	str	r0, [r7, #4]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801de2c:	6878      	ldr	r0, [r7, #4]
 801de2e:	f7f4 fb00 	bl	8012432 <lv_obj_get_ext_attr>
 801de32:	60f8      	str	r0, [r7, #12]
    return ext->min_value;
 801de34:	68fb      	ldr	r3, [r7, #12]
 801de36:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
}
 801de3a:	4618      	mov	r0, r3
 801de3c:	3710      	adds	r7, #16
 801de3e:	46bd      	mov	sp, r7
 801de40:	bd80      	pop	{r7, pc}

0801de42 <lv_bar_get_max_value>:
 * Get the maximum value of a bar
 * @param bar pointer to a bar object
 * @return the maximum value of the bar
 */
int16_t lv_bar_get_max_value(const lv_obj_t * bar)
{
 801de42:	b580      	push	{r7, lr}
 801de44:	b084      	sub	sp, #16
 801de46:	af00      	add	r7, sp, #0
 801de48:	6078      	str	r0, [r7, #4]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801de4a:	6878      	ldr	r0, [r7, #4]
 801de4c:	f7f4 faf1 	bl	8012432 <lv_obj_get_ext_attr>
 801de50:	60f8      	str	r0, [r7, #12]
    return ext->max_value;
 801de52:	68fb      	ldr	r3, [r7, #12]
 801de54:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
}
 801de58:	4618      	mov	r0, r3
 801de5a:	3710      	adds	r7, #16
 801de5c:	46bd      	mov	sp, r7
 801de5e:	bd80      	pop	{r7, pc}

0801de60 <lv_bar_get_style>:
 * @param bar pointer to a bar object
 * @param type which style should be get
 * @return style pointer to a style
 */
const lv_style_t * lv_bar_get_style(const lv_obj_t * bar, lv_bar_style_t type)
{
 801de60:	b580      	push	{r7, lr}
 801de62:	b084      	sub	sp, #16
 801de64:	af00      	add	r7, sp, #0
 801de66:	6078      	str	r0, [r7, #4]
 801de68:	460b      	mov	r3, r1
 801de6a:	70fb      	strb	r3, [r7, #3]
    const lv_style_t * style = NULL;
 801de6c:	2300      	movs	r3, #0
 801de6e:	60fb      	str	r3, [r7, #12]
    lv_bar_ext_t * ext       = lv_obj_get_ext_attr(bar);
 801de70:	6878      	ldr	r0, [r7, #4]
 801de72:	f7f4 fade 	bl	8012432 <lv_obj_get_ext_attr>
 801de76:	60b8      	str	r0, [r7, #8]

    switch(type) {
 801de78:	78fb      	ldrb	r3, [r7, #3]
 801de7a:	2b00      	cmp	r3, #0
 801de7c:	d002      	beq.n	801de84 <lv_bar_get_style+0x24>
 801de7e:	2b01      	cmp	r3, #1
 801de80:	d005      	beq.n	801de8e <lv_bar_get_style+0x2e>
 801de82:	e008      	b.n	801de96 <lv_bar_get_style+0x36>
        case LV_BAR_STYLE_BG: style = lv_obj_get_style(bar); break;
 801de84:	6878      	ldr	r0, [r7, #4]
 801de86:	f7f4 f9b5 	bl	80121f4 <lv_obj_get_style>
 801de8a:	60f8      	str	r0, [r7, #12]
 801de8c:	e006      	b.n	801de9c <lv_bar_get_style+0x3c>
        case LV_BAR_STYLE_INDIC: style = ext->style_indic; break;
 801de8e:	68bb      	ldr	r3, [r7, #8]
 801de90:	691b      	ldr	r3, [r3, #16]
 801de92:	60fb      	str	r3, [r7, #12]
 801de94:	e002      	b.n	801de9c <lv_bar_get_style+0x3c>
        default: style = NULL; break;
 801de96:	2300      	movs	r3, #0
 801de98:	60fb      	str	r3, [r7, #12]
 801de9a:	bf00      	nop
    }

    return style;
 801de9c:	68fb      	ldr	r3, [r7, #12]
}
 801de9e:	4618      	mov	r0, r3
 801dea0:	3710      	adds	r7, #16
 801dea2:	46bd      	mov	sp, r7
 801dea4:	bd80      	pop	{r7, pc}
	...

0801dea8 <lv_bar_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_bar_design(lv_obj_t * bar, const lv_area_t * mask, lv_design_mode_t mode)
{
 801dea8:	b580      	push	{r7, lr}
 801deaa:	b0a0      	sub	sp, #128	; 0x80
 801deac:	af00      	add	r7, sp, #0
 801deae:	60f8      	str	r0, [r7, #12]
 801deb0:	60b9      	str	r1, [r7, #8]
 801deb2:	4613      	mov	r3, r2
 801deb4:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 801deb6:	79fb      	ldrb	r3, [r7, #7]
 801deb8:	2b02      	cmp	r3, #2
 801deba:	d107      	bne.n	801decc <lv_bar_design+0x24>
        /*Return false if the object is not covers the mask area*/
        return ancestor_design_f(bar, mask, mode);
 801debc:	4bab      	ldr	r3, [pc, #684]	; (801e16c <lv_bar_design+0x2c4>)
 801debe:	681b      	ldr	r3, [r3, #0]
 801dec0:	79fa      	ldrb	r2, [r7, #7]
 801dec2:	68b9      	ldr	r1, [r7, #8]
 801dec4:	68f8      	ldr	r0, [r7, #12]
 801dec6:	4798      	blx	r3
 801dec8:	4603      	mov	r3, r0
 801deca:	e231      	b.n	801e330 <lv_bar_design+0x488>
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 801decc:	79fb      	ldrb	r3, [r7, #7]
 801dece:	2b00      	cmp	r3, #0
 801ded0:	f040 8205 	bne.w	801e2de <lv_bar_design+0x436>
        lv_opa_t opa_scale = lv_obj_get_opa_scale(bar);
 801ded4:	68f8      	ldr	r0, [r7, #12]
 801ded6:	f7f4 fa5e 	bl	8012396 <lv_obj_get_opa_scale>
 801deda:	4603      	mov	r3, r0
 801dedc:	f887 3077 	strb.w	r3, [r7, #119]	; 0x77
        ancestor_design_f(bar, mask, mode);
#else
        /* Draw the borders later if the bar is focused.
         * At value = 100% the indicator can cover to whole background and the focused style won't
         * be visible*/
        if(lv_obj_is_focused(bar)) {
 801dee0:	68f8      	ldr	r0, [r7, #12]
 801dee2:	f7f4 fabe 	bl	8012462 <lv_obj_is_focused>
 801dee6:	4603      	mov	r3, r0
 801dee8:	2b00      	cmp	r3, #0
 801deea:	d017      	beq.n	801df1c <lv_bar_design+0x74>
            const lv_style_t * style_bg = lv_bar_get_style(bar, LV_BAR_STYLE_BG);
 801deec:	2100      	movs	r1, #0
 801deee:	68f8      	ldr	r0, [r7, #12]
 801def0:	f7ff ffb6 	bl	801de60 <lv_bar_get_style>
 801def4:	6738      	str	r0, [r7, #112]	; 0x70
            lv_style_t style_tmp;
            lv_style_copy(&style_tmp, style_bg);
 801def6:	f107 0314 	add.w	r3, r7, #20
 801defa:	6f39      	ldr	r1, [r7, #112]	; 0x70
 801defc:	4618      	mov	r0, r3
 801defe:	f7f5 fdb1 	bl	8013a64 <lv_style_copy>
            style_tmp.body.border.width = 0;
 801df02:	2300      	movs	r3, #0
 801df04:	843b      	strh	r3, [r7, #32]
            lv_draw_rect(&bar->coords, mask, &style_tmp, opa_scale);
 801df06:	68fb      	ldr	r3, [r7, #12]
 801df08:	f103 0010 	add.w	r0, r3, #16
 801df0c:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 801df10:	f107 0214 	add.w	r2, r7, #20
 801df14:	68b9      	ldr	r1, [r7, #8]
 801df16:	f7f7 fcf4 	bl	8015902 <lv_draw_rect>
 801df1a:	e005      	b.n	801df28 <lv_bar_design+0x80>
        } else {
            ancestor_design_f(bar, mask, mode);
 801df1c:	4b93      	ldr	r3, [pc, #588]	; (801e16c <lv_bar_design+0x2c4>)
 801df1e:	681b      	ldr	r3, [r3, #0]
 801df20:	79fa      	ldrb	r2, [r7, #7]
 801df22:	68b9      	ldr	r1, [r7, #8]
 801df24:	68f8      	ldr	r0, [r7, #12]
 801df26:	4798      	blx	r3
        }
#endif
        lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801df28:	68f8      	ldr	r0, [r7, #12]
 801df2a:	f7f4 fa82 	bl	8012432 <lv_obj_get_ext_attr>
 801df2e:	66f8      	str	r0, [r7, #108]	; 0x6c

        if(ext->cur_value != ext->min_value || ext->sym
 801df30:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801df32:	f9b3 2000 	ldrsh.w	r2, [r3]
 801df36:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801df38:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801df3c:	429a      	cmp	r2, r3
 801df3e:	d10d      	bne.n	801df5c <lv_bar_design+0xb4>
 801df40:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801df42:	7b9b      	ldrb	r3, [r3, #14]
 801df44:	f003 0301 	and.w	r3, r3, #1
 801df48:	b2db      	uxtb	r3, r3
 801df4a:	2b00      	cmp	r3, #0
 801df4c:	d106      	bne.n	801df5c <lv_bar_design+0xb4>
#if LV_USE_ANIMATION
           || ext->anim_start != LV_BAR_ANIM_STATE_INV
 801df4e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801df50:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801df54:	f1b3 3fff 	cmp.w	r3, #4294967295
 801df58:	f000 81e9 	beq.w	801e32e <lv_bar_design+0x486>
#endif
        ) {
            const lv_style_t * style_indic = lv_bar_get_style(bar, LV_BAR_STYLE_INDIC);
 801df5c:	2101      	movs	r1, #1
 801df5e:	68f8      	ldr	r0, [r7, #12]
 801df60:	f7ff ff7e 	bl	801de60 <lv_bar_get_style>
 801df64:	66b8      	str	r0, [r7, #104]	; 0x68
            lv_area_t indic_area;
            lv_area_copy(&indic_area, &bar->coords);
 801df66:	68fb      	ldr	r3, [r7, #12]
 801df68:	f103 0210 	add.w	r2, r3, #16
 801df6c:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801df70:	4611      	mov	r1, r2
 801df72:	4618      	mov	r0, r3
 801df74:	f7ff fd3a 	bl	801d9ec <lv_area_copy>
            indic_area.x1 += style_indic->body.padding.left;
 801df78:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 801df7c:	b29a      	uxth	r2, r3
 801df7e:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801df80:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801df84:	b29b      	uxth	r3, r3
 801df86:	4413      	add	r3, r2
 801df88:	b29b      	uxth	r3, r3
 801df8a:	b21b      	sxth	r3, r3
 801df8c:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
            indic_area.x2 -= style_indic->body.padding.right;
 801df90:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801df94:	b29a      	uxth	r2, r3
 801df96:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801df98:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801df9c:	b29b      	uxth	r3, r3
 801df9e:	1ad3      	subs	r3, r2, r3
 801dfa0:	b29b      	uxth	r3, r3
 801dfa2:	b21b      	sxth	r3, r3
 801dfa4:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            indic_area.y1 += style_indic->body.padding.top;
 801dfa8:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801dfac:	b29a      	uxth	r2, r3
 801dfae:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801dfb0:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 801dfb4:	b29b      	uxth	r3, r3
 801dfb6:	4413      	add	r3, r2
 801dfb8:	b29b      	uxth	r3, r3
 801dfba:	b21b      	sxth	r3, r3
 801dfbc:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            indic_area.y2 -= style_indic->body.padding.bottom;
 801dfc0:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801dfc4:	b29a      	uxth	r2, r3
 801dfc6:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 801dfc8:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 801dfcc:	b29b      	uxth	r3, r3
 801dfce:	1ad3      	subs	r3, r2, r3
 801dfd0:	b29b      	uxth	r3, r3
 801dfd2:	b21b      	sxth	r3, r3
 801dfd4:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

            lv_coord_t w = lv_area_get_width(&indic_area);
 801dfd8:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801dfdc:	4618      	mov	r0, r3
 801dfde:	f7ff fd13 	bl	801da08 <lv_area_get_width>
 801dfe2:	4603      	mov	r3, r0
 801dfe4:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
            lv_coord_t h = lv_area_get_height(&indic_area);
 801dfe8:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801dfec:	4618      	mov	r0, r3
 801dfee:	f7ff fd22 	bl	801da36 <lv_area_get_height>
 801dff2:	4603      	mov	r3, r0
 801dff4:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64

            if(w >= h) {
 801dff8:	f9b7 2066 	ldrsh.w	r2, [r7, #102]	; 0x66
 801dffc:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801e000:	429a      	cmp	r2, r3
 801e002:	f2c0 80b5 	blt.w	801e170 <lv_bar_design+0x2c8>
                /*Horizontal*/
#if LV_USE_ANIMATION
                if(ext->anim_state != LV_BAR_ANIM_STATE_INV) {
 801e006:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e008:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801e00c:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e010:	d043      	beq.n	801e09a <lv_bar_design+0x1f2>
                    /*Calculate the coordinates of anim. start and end*/
                    lv_coord_t anim_start_x =
                        (int32_t)((int32_t)w * (ext->anim_start - ext->min_value)) / (ext->max_value - ext->min_value);
 801e012:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801e016:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e018:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 801e01c:	4611      	mov	r1, r2
 801e01e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e020:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801e024:	1a8a      	subs	r2, r1, r2
 801e026:	fb02 f203 	mul.w	r2, r2, r3
 801e02a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e02c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e030:	4619      	mov	r1, r3
 801e032:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e034:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e038:	1acb      	subs	r3, r1, r3
 801e03a:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_start_x =
 801e03e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
                    lv_coord_t anim_end_x =
                        (int32_t)((int32_t)w * (ext->anim_end - ext->min_value)) / (ext->max_value - ext->min_value);
 801e042:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801e046:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e048:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 801e04c:	4611      	mov	r1, r2
 801e04e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e050:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801e054:	1a8a      	subs	r2, r1, r2
 801e056:	fb02 f203 	mul.w	r2, r2, r3
 801e05a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e05c:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e060:	4619      	mov	r1, r3
 801e062:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e064:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e068:	1acb      	subs	r3, r1, r3
 801e06a:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_end_x =
 801e06e:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

                    /*Calculate the real position based on `anim_state` (between `anim_start` and
                     * `anim_end`)*/
                    indic_area.x2 =
                        anim_start_x + (((anim_end_x - anim_start_x) * ext->anim_state) >> LV_BAR_ANIM_STATE_NORM);
 801e072:	f9b7 205a 	ldrsh.w	r2, [r7, #90]	; 0x5a
 801e076:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801e07a:	1ad3      	subs	r3, r2, r3
 801e07c:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e07e:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 801e082:	fb02 f303 	mul.w	r3, r2, r3
 801e086:	121b      	asrs	r3, r3, #8
 801e088:	b29a      	uxth	r2, r3
 801e08a:	f8b7 305c 	ldrh.w	r3, [r7, #92]	; 0x5c
 801e08e:	4413      	add	r3, r2
 801e090:	b29b      	uxth	r3, r3
 801e092:	b21b      	sxth	r3, r3
                    indic_area.x2 =
 801e094:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
 801e098:	e018      	b.n	801e0cc <lv_bar_design+0x224>
                } else
#endif
                {
                    indic_area.x2 =
                        (int32_t)((int32_t)w * (ext->cur_value - ext->min_value)) / (ext->max_value - ext->min_value);
 801e09a:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801e09e:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e0a0:	f9b2 2000 	ldrsh.w	r2, [r2]
 801e0a4:	4611      	mov	r1, r2
 801e0a6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e0a8:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801e0ac:	1a8a      	subs	r2, r1, r2
 801e0ae:	fb02 f203 	mul.w	r2, r2, r3
 801e0b2:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e0b4:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e0b8:	4619      	mov	r1, r3
 801e0ba:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e0bc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e0c0:	1acb      	subs	r3, r1, r3
 801e0c2:	fb92 f3f3 	sdiv	r3, r2, r3
                    indic_area.x2 =
 801e0c6:	b21b      	sxth	r3, r3
 801e0c8:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                }

                indic_area.x2 = indic_area.x1 + indic_area.x2 - 1;
 801e0cc:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 801e0d0:	b29a      	uxth	r2, r3
 801e0d2:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801e0d6:	b29b      	uxth	r3, r3
 801e0d8:	4413      	add	r3, r2
 801e0da:	b29b      	uxth	r3, r3
 801e0dc:	3b01      	subs	r3, #1
 801e0de:	b29b      	uxth	r3, r3
 801e0e0:	b21b      	sxth	r3, r3
 801e0e2:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                if(ext->sym && ext->min_value < 0 && ext->max_value > 0) {
 801e0e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e0e8:	7b9b      	ldrb	r3, [r3, #14]
 801e0ea:	f003 0301 	and.w	r3, r3, #1
 801e0ee:	b2db      	uxtb	r3, r3
 801e0f0:	2b00      	cmp	r3, #0
 801e0f2:	f000 80eb 	beq.w	801e2cc <lv_bar_design+0x424>
 801e0f6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e0f8:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e0fc:	2b00      	cmp	r3, #0
 801e0fe:	f280 80e5 	bge.w	801e2cc <lv_bar_design+0x424>
 801e102:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e104:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e108:	2b00      	cmp	r3, #0
 801e10a:	f340 80df 	ble.w	801e2cc <lv_bar_design+0x424>
                    /*Calculate the coordinate of the zero point*/
                    lv_coord_t zero;
                    zero = indic_area.x1 + (-ext->min_value * w) / (ext->max_value - ext->min_value);
 801e10e:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 801e112:	b29a      	uxth	r2, r3
 801e114:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e116:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e11a:	425b      	negs	r3, r3
 801e11c:	f9b7 1066 	ldrsh.w	r1, [r7, #102]	; 0x66
 801e120:	fb01 f103 	mul.w	r1, r1, r3
 801e124:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e126:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e12a:	4618      	mov	r0, r3
 801e12c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e12e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e132:	1ac3      	subs	r3, r0, r3
 801e134:	fb91 f3f3 	sdiv	r3, r1, r3
 801e138:	b29b      	uxth	r3, r3
 801e13a:	4413      	add	r3, r2
 801e13c:	b29b      	uxth	r3, r3
 801e13e:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
                    if(indic_area.x2 > zero)
 801e142:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801e146:	f9b7 2058 	ldrsh.w	r2, [r7, #88]	; 0x58
 801e14a:	429a      	cmp	r2, r3
 801e14c:	da04      	bge.n	801e158 <lv_bar_design+0x2b0>
                        indic_area.x1 = zero;
 801e14e:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 801e152:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
 801e156:	e0b9      	b.n	801e2cc <lv_bar_design+0x424>
                    else {
                        indic_area.x1 = indic_area.x2;
 801e158:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 801e15c:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                        indic_area.x2 = zero;
 801e160:	f8b7 3058 	ldrh.w	r3, [r7, #88]	; 0x58
 801e164:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
 801e168:	e0b0      	b.n	801e2cc <lv_bar_design+0x424>
 801e16a:	bf00      	nop
 801e16c:	2000c3ac 	.word	0x2000c3ac
                    }
                }
            } else {
#if LV_USE_ANIMATION
                if(ext->anim_state != LV_BAR_ANIM_STATE_INV) {
 801e170:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e172:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 801e176:	f1b3 3fff 	cmp.w	r3, #4294967295
 801e17a:	d043      	beq.n	801e204 <lv_bar_design+0x35c>
                    /*Calculate the coordinates of anim. start and end*/
                    lv_coord_t anim_start_y =
                        (int32_t)((int32_t)h * (ext->anim_start - ext->min_value)) / (ext->max_value - ext->min_value);
 801e17c:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801e180:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e182:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 801e186:	4611      	mov	r1, r2
 801e188:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e18a:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801e18e:	1a8a      	subs	r2, r1, r2
 801e190:	fb02 f203 	mul.w	r2, r2, r3
 801e194:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e196:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e19a:	4619      	mov	r1, r3
 801e19c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e19e:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e1a2:	1acb      	subs	r3, r1, r3
 801e1a4:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_start_y =
 801e1a8:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
                    lv_coord_t anim_end_y =
                        (int32_t)((int32_t)h * (ext->anim_end - ext->min_value)) / (ext->max_value - ext->min_value);
 801e1ac:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801e1b0:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e1b2:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 801e1b6:	4611      	mov	r1, r2
 801e1b8:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e1ba:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801e1be:	1a8a      	subs	r2, r1, r2
 801e1c0:	fb02 f203 	mul.w	r2, r2, r3
 801e1c4:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e1c6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e1ca:	4619      	mov	r1, r3
 801e1cc:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e1ce:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e1d2:	1acb      	subs	r3, r1, r3
 801e1d4:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_end_y =
 801e1d8:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60

                    /*Calculate the real position based on `anim_state` (between `anim_start` and
                     * `anim_end`)*/
                    indic_area.y1 =
                        anim_start_y + (((anim_end_y - anim_start_y) * ext->anim_state) >> LV_BAR_ANIM_STATE_NORM);
 801e1dc:	f9b7 2060 	ldrsh.w	r2, [r7, #96]	; 0x60
 801e1e0:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801e1e4:	1ad3      	subs	r3, r2, r3
 801e1e6:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e1e8:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 801e1ec:	fb02 f303 	mul.w	r3, r2, r3
 801e1f0:	121b      	asrs	r3, r3, #8
 801e1f2:	b29a      	uxth	r2, r3
 801e1f4:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801e1f8:	4413      	add	r3, r2
 801e1fa:	b29b      	uxth	r3, r3
 801e1fc:	b21b      	sxth	r3, r3
                    indic_area.y1 =
 801e1fe:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
 801e202:	e018      	b.n	801e236 <lv_bar_design+0x38e>
                } else
#endif
                {
                    indic_area.y1 =
                        (int32_t)((int32_t)h * (ext->cur_value - ext->min_value)) / (ext->max_value - ext->min_value);
 801e204:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801e208:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e20a:	f9b2 2000 	ldrsh.w	r2, [r2]
 801e20e:	4611      	mov	r1, r2
 801e210:	6efa      	ldr	r2, [r7, #108]	; 0x6c
 801e212:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 801e216:	1a8a      	subs	r2, r1, r2
 801e218:	fb02 f203 	mul.w	r2, r2, r3
 801e21c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e21e:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e222:	4619      	mov	r1, r3
 801e224:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e226:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e22a:	1acb      	subs	r3, r1, r3
 801e22c:	fb92 f3f3 	sdiv	r3, r2, r3
                    indic_area.y1 =
 801e230:	b21b      	sxth	r3, r3
 801e232:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                }

                indic_area.y1 = indic_area.y2 - indic_area.y1 + 1;
 801e236:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801e23a:	b29a      	uxth	r2, r3
 801e23c:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801e240:	b29b      	uxth	r3, r3
 801e242:	1ad3      	subs	r3, r2, r3
 801e244:	b29b      	uxth	r3, r3
 801e246:	3301      	adds	r3, #1
 801e248:	b29b      	uxth	r3, r3
 801e24a:	b21b      	sxth	r3, r3
 801e24c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52

                if(ext->sym && ext->min_value < 0 && ext->max_value > 0) {
 801e250:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e252:	7b9b      	ldrb	r3, [r3, #14]
 801e254:	f003 0301 	and.w	r3, r3, #1
 801e258:	b2db      	uxtb	r3, r3
 801e25a:	2b00      	cmp	r3, #0
 801e25c:	d036      	beq.n	801e2cc <lv_bar_design+0x424>
 801e25e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e260:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e264:	2b00      	cmp	r3, #0
 801e266:	da31      	bge.n	801e2cc <lv_bar_design+0x424>
 801e268:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e26a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e26e:	2b00      	cmp	r3, #0
 801e270:	dd2c      	ble.n	801e2cc <lv_bar_design+0x424>
                    /*Calculate the coordinate of the zero point*/
                    lv_coord_t zero;
                    zero = indic_area.y2 - (-ext->min_value * h) / (ext->max_value - ext->min_value);
 801e272:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 801e276:	b29a      	uxth	r2, r3
 801e278:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e27a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e27e:	425b      	negs	r3, r3
 801e280:	f9b7 1064 	ldrsh.w	r1, [r7, #100]	; 0x64
 801e284:	fb01 f103 	mul.w	r1, r1, r3
 801e288:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e28a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801e28e:	4618      	mov	r0, r3
 801e290:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 801e292:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e296:	1ac3      	subs	r3, r0, r3
 801e298:	fb91 f3f3 	sdiv	r3, r1, r3
 801e29c:	b29b      	uxth	r3, r3
 801e29e:	1ad3      	subs	r3, r2, r3
 801e2a0:	b29b      	uxth	r3, r3
 801e2a2:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
                    if(indic_area.y1 < zero)
 801e2a6:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801e2aa:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 801e2ae:	429a      	cmp	r2, r3
 801e2b0:	dd04      	ble.n	801e2bc <lv_bar_design+0x414>
                        indic_area.y2 = zero;
 801e2b2:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801e2b6:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 801e2ba:	e007      	b.n	801e2cc <lv_bar_design+0x424>
                    else {
                        indic_area.y2 = indic_area.y1;
 801e2bc:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 801e2c0:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                        indic_area.y1 = zero;
 801e2c4:	f8b7 305e 	ldrh.w	r3, [r7, #94]	; 0x5e
 801e2c8:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                    }
                }
            }

            /*Draw the indicator*/
            lv_draw_rect(&indic_area, mask, style_indic, opa_scale);
 801e2cc:	f897 3077 	ldrb.w	r3, [r7, #119]	; 0x77
 801e2d0:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801e2d4:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801e2d6:	68b9      	ldr	r1, [r7, #8]
 801e2d8:	f7f7 fb13 	bl	8015902 <lv_draw_rect>
 801e2dc:	e027      	b.n	801e32e <lv_bar_design+0x486>
        }
    } else if(mode == LV_DESIGN_DRAW_POST) {
 801e2de:	79fb      	ldrb	r3, [r7, #7]
 801e2e0:	2b01      	cmp	r3, #1
 801e2e2:	d124      	bne.n	801e32e <lv_bar_design+0x486>
#if LV_USE_GROUP
        /*Draw the border*/
        if(lv_obj_is_focused(bar)) {
 801e2e4:	68f8      	ldr	r0, [r7, #12]
 801e2e6:	f7f4 f8bc 	bl	8012462 <lv_obj_is_focused>
 801e2ea:	4603      	mov	r3, r0
 801e2ec:	2b00      	cmp	r3, #0
 801e2ee:	d01e      	beq.n	801e32e <lv_bar_design+0x486>
            lv_opa_t opa_scale          = lv_obj_get_opa_scale(bar);
 801e2f0:	68f8      	ldr	r0, [r7, #12]
 801e2f2:	f7f4 f850 	bl	8012396 <lv_obj_get_opa_scale>
 801e2f6:	4603      	mov	r3, r0
 801e2f8:	f887 307f 	strb.w	r3, [r7, #127]	; 0x7f
            const lv_style_t * style_bg = lv_bar_get_style(bar, LV_BAR_STYLE_BG);
 801e2fc:	2100      	movs	r1, #0
 801e2fe:	68f8      	ldr	r0, [r7, #12]
 801e300:	f7ff fdae 	bl	801de60 <lv_bar_get_style>
 801e304:	67b8      	str	r0, [r7, #120]	; 0x78
            lv_style_t style_tmp;
            lv_style_copy(&style_tmp, style_bg);
 801e306:	f107 0314 	add.w	r3, r7, #20
 801e30a:	6fb9      	ldr	r1, [r7, #120]	; 0x78
 801e30c:	4618      	mov	r0, r3
 801e30e:	f7f5 fba9 	bl	8013a64 <lv_style_copy>
            style_tmp.body.opa          = LV_OPA_TRANSP;
 801e312:	2300      	movs	r3, #0
 801e314:	773b      	strb	r3, [r7, #28]
            style_tmp.body.shadow.width = 0;
 801e316:	2300      	movs	r3, #0
 801e318:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_draw_rect(&bar->coords, mask, &style_tmp, opa_scale);
 801e31a:	68fb      	ldr	r3, [r7, #12]
 801e31c:	f103 0010 	add.w	r0, r3, #16
 801e320:	f897 307f 	ldrb.w	r3, [r7, #127]	; 0x7f
 801e324:	f107 0214 	add.w	r2, r7, #20
 801e328:	68b9      	ldr	r1, [r7, #8]
 801e32a:	f7f7 faea 	bl	8015902 <lv_draw_rect>
        }
#endif
    }
    return true;
 801e32e:	2301      	movs	r3, #1
}
 801e330:	4618      	mov	r0, r3
 801e332:	3780      	adds	r7, #128	; 0x80
 801e334:	46bd      	mov	sp, r7
 801e336:	bd80      	pop	{r7, pc}

0801e338 <lv_bar_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_bar_signal(lv_obj_t * bar, lv_signal_t sign, void * param)
{
 801e338:	b580      	push	{r7, lr}
 801e33a:	b088      	sub	sp, #32
 801e33c:	af00      	add	r7, sp, #0
 801e33e:	60f8      	str	r0, [r7, #12]
 801e340:	460b      	mov	r3, r1
 801e342:	607a      	str	r2, [r7, #4]
 801e344:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(bar, sign, param);
 801e346:	4b21      	ldr	r3, [pc, #132]	; (801e3cc <lv_bar_signal+0x94>)
 801e348:	681b      	ldr	r3, [r3, #0]
 801e34a:	7af9      	ldrb	r1, [r7, #11]
 801e34c:	687a      	ldr	r2, [r7, #4]
 801e34e:	68f8      	ldr	r0, [r7, #12]
 801e350:	4798      	blx	r3
 801e352:	4603      	mov	r3, r0
 801e354:	77bb      	strb	r3, [r7, #30]
    if(res != LV_RES_OK) return res;
 801e356:	7fbb      	ldrb	r3, [r7, #30]
 801e358:	2b01      	cmp	r3, #1
 801e35a:	d001      	beq.n	801e360 <lv_bar_signal+0x28>
 801e35c:	7fbb      	ldrb	r3, [r7, #30]
 801e35e:	e031      	b.n	801e3c4 <lv_bar_signal+0x8c>

    if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 801e360:	7afb      	ldrb	r3, [r7, #11]
 801e362:	2b05      	cmp	r3, #5
 801e364:	d112      	bne.n	801e38c <lv_bar_signal+0x54>
        const lv_style_t * style_indic = lv_bar_get_style(bar, LV_BAR_STYLE_INDIC);
 801e366:	2101      	movs	r1, #1
 801e368:	68f8      	ldr	r0, [r7, #12]
 801e36a:	f7ff fd79 	bl	801de60 <lv_bar_get_style>
 801e36e:	6178      	str	r0, [r7, #20]
        if(style_indic->body.shadow.width > bar->ext_draw_pad) bar->ext_draw_pad = style_indic->body.shadow.width;
 801e370:	697b      	ldr	r3, [r7, #20]
 801e372:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 801e376:	68fb      	ldr	r3, [r7, #12]
 801e378:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 801e37c:	429a      	cmp	r2, r3
 801e37e:	dd20      	ble.n	801e3c2 <lv_bar_signal+0x8a>
 801e380:	697b      	ldr	r3, [r7, #20]
 801e382:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 801e386:	68fb      	ldr	r3, [r7, #12]
 801e388:	869a      	strh	r2, [r3, #52]	; 0x34
 801e38a:	e01a      	b.n	801e3c2 <lv_bar_signal+0x8a>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 801e38c:	7afb      	ldrb	r3, [r7, #11]
 801e38e:	2b06      	cmp	r3, #6
 801e390:	d117      	bne.n	801e3c2 <lv_bar_signal+0x8a>
        lv_obj_type_t * buf = param;
 801e392:	687b      	ldr	r3, [r7, #4]
 801e394:	61bb      	str	r3, [r7, #24]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801e396:	2300      	movs	r3, #0
 801e398:	77fb      	strb	r3, [r7, #31]
 801e39a:	e008      	b.n	801e3ae <lv_bar_signal+0x76>
            if(buf->type[i] == NULL) break;
 801e39c:	7ffa      	ldrb	r2, [r7, #31]
 801e39e:	69bb      	ldr	r3, [r7, #24]
 801e3a0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801e3a4:	2b00      	cmp	r3, #0
 801e3a6:	d006      	beq.n	801e3b6 <lv_bar_signal+0x7e>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801e3a8:	7ffb      	ldrb	r3, [r7, #31]
 801e3aa:	3301      	adds	r3, #1
 801e3ac:	77fb      	strb	r3, [r7, #31]
 801e3ae:	7ffb      	ldrb	r3, [r7, #31]
 801e3b0:	2b06      	cmp	r3, #6
 801e3b2:	d9f3      	bls.n	801e39c <lv_bar_signal+0x64>
 801e3b4:	e000      	b.n	801e3b8 <lv_bar_signal+0x80>
            if(buf->type[i] == NULL) break;
 801e3b6:	bf00      	nop
        }
        buf->type[i] = "lv_bar";
 801e3b8:	7ffa      	ldrb	r2, [r7, #31]
 801e3ba:	69bb      	ldr	r3, [r7, #24]
 801e3bc:	4904      	ldr	r1, [pc, #16]	; (801e3d0 <lv_bar_signal+0x98>)
 801e3be:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 801e3c2:	7fbb      	ldrb	r3, [r7, #30]
}
 801e3c4:	4618      	mov	r0, r3
 801e3c6:	3720      	adds	r7, #32
 801e3c8:	46bd      	mov	sp, r7
 801e3ca:	bd80      	pop	{r7, pc}
 801e3cc:	2000c3b0 	.word	0x2000c3b0
 801e3d0:	08028f48 	.word	0x08028f48

0801e3d4 <lv_bar_anim>:

#if LV_USE_ANIMATION
static void lv_bar_anim(void * bar, lv_anim_value_t value)
{
 801e3d4:	b580      	push	{r7, lr}
 801e3d6:	b084      	sub	sp, #16
 801e3d8:	af00      	add	r7, sp, #0
 801e3da:	6078      	str	r0, [r7, #4]
 801e3dc:	460b      	mov	r3, r1
 801e3de:	807b      	strh	r3, [r7, #2]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(bar);
 801e3e0:	6878      	ldr	r0, [r7, #4]
 801e3e2:	f7f4 f826 	bl	8012432 <lv_obj_get_ext_attr>
 801e3e6:	60f8      	str	r0, [r7, #12]
    ext->anim_state    = value;
 801e3e8:	68fb      	ldr	r3, [r7, #12]
 801e3ea:	887a      	ldrh	r2, [r7, #2]
 801e3ec:	815a      	strh	r2, [r3, #10]
    lv_obj_invalidate(bar);
 801e3ee:	6878      	ldr	r0, [r7, #4]
 801e3f0:	f7f2 fd1d 	bl	8010e2e <lv_obj_invalidate>
}
 801e3f4:	bf00      	nop
 801e3f6:	3710      	adds	r7, #16
 801e3f8:	46bd      	mov	sp, r7
 801e3fa:	bd80      	pop	{r7, pc}

0801e3fc <lv_bar_anim_ready>:

static void lv_bar_anim_ready(lv_anim_t * a)
{
 801e3fc:	b580      	push	{r7, lr}
 801e3fe:	b084      	sub	sp, #16
 801e400:	af00      	add	r7, sp, #0
 801e402:	6078      	str	r0, [r7, #4]
    lv_bar_ext_t * ext = lv_obj_get_ext_attr(a->var);
 801e404:	687b      	ldr	r3, [r7, #4]
 801e406:	681b      	ldr	r3, [r3, #0]
 801e408:	4618      	mov	r0, r3
 801e40a:	f7f4 f812 	bl	8012432 <lv_obj_get_ext_attr>
 801e40e:	60f8      	str	r0, [r7, #12]
    ext->anim_state    = LV_BAR_ANIM_STATE_INV;
 801e410:	68fb      	ldr	r3, [r7, #12]
 801e412:	f64f 72ff 	movw	r2, #65535	; 0xffff
 801e416:	815a      	strh	r2, [r3, #10]
    lv_bar_set_value(a->var, ext->anim_end, false);
 801e418:	687b      	ldr	r3, [r7, #4]
 801e41a:	6818      	ldr	r0, [r3, #0]
 801e41c:	68fb      	ldr	r3, [r7, #12]
 801e41e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 801e422:	2200      	movs	r2, #0
 801e424:	4619      	mov	r1, r3
 801e426:	f7ff fbf3 	bl	801dc10 <lv_bar_set_value>
}
 801e42a:	bf00      	nop
 801e42c:	3710      	adds	r7, #16
 801e42e:	46bd      	mov	sp, r7
 801e430:	bd80      	pop	{r7, pc}

0801e432 <lv_btn_set_layout>:
 * Set the layout on a button
 * @param btn pointer to a button object
 * @param layout a layout from 'lv_cont_layout_t'
 */
static inline void lv_btn_set_layout(lv_obj_t * btn, lv_layout_t layout)
{
 801e432:	b580      	push	{r7, lr}
 801e434:	b082      	sub	sp, #8
 801e436:	af00      	add	r7, sp, #0
 801e438:	6078      	str	r0, [r7, #4]
 801e43a:	460b      	mov	r3, r1
 801e43c:	70fb      	strb	r3, [r7, #3]
    lv_cont_set_layout(btn, layout);
 801e43e:	78fb      	ldrb	r3, [r7, #3]
 801e440:	4619      	mov	r1, r3
 801e442:	6878      	ldr	r0, [r7, #4]
 801e444:	f000 ff26 	bl	801f294 <lv_cont_set_layout>
}
 801e448:	bf00      	nop
 801e44a:	3708      	adds	r7, #8
 801e44c:	46bd      	mov	sp, r7
 801e44e:	bd80      	pop	{r7, pc}

0801e450 <lv_btn_create>:
 * @param par pointer to an object, it will be the parent of the new button
 * @param copy pointer to a button object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_btn_create(lv_obj_t * par, const lv_obj_t * copy)
{
 801e450:	b580      	push	{r7, lr}
 801e452:	b086      	sub	sp, #24
 801e454:	af00      	add	r7, sp, #0
 801e456:	6078      	str	r0, [r7, #4]
 801e458:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("button create started");

    lv_obj_t * new_btn;

    new_btn = lv_cont_create(par, copy);
 801e45a:	6839      	ldr	r1, [r7, #0]
 801e45c:	6878      	ldr	r0, [r7, #4]
 801e45e:	f000 fe5f 	bl	801f120 <lv_cont_create>
 801e462:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_btn);
 801e464:	697b      	ldr	r3, [r7, #20]
 801e466:	2b00      	cmp	r3, #0
 801e468:	d106      	bne.n	801e478 <lv_btn_create+0x28>
 801e46a:	4b68      	ldr	r3, [pc, #416]	; (801e60c <lv_btn_create+0x1bc>)
 801e46c:	224f      	movs	r2, #79	; 0x4f
 801e46e:	4968      	ldr	r1, [pc, #416]	; (801e610 <lv_btn_create+0x1c0>)
 801e470:	2003      	movs	r0, #3
 801e472:	f7fe f9cb 	bl	801c80c <lv_log_add>
 801e476:	e7fe      	b.n	801e476 <lv_btn_create+0x26>
    if(new_btn == NULL) return NULL;
 801e478:	697b      	ldr	r3, [r7, #20]
 801e47a:	2b00      	cmp	r3, #0
 801e47c:	d101      	bne.n	801e482 <lv_btn_create+0x32>
 801e47e:	2300      	movs	r3, #0
 801e480:	e0c0      	b.n	801e604 <lv_btn_create+0x1b4>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_btn);
 801e482:	4b64      	ldr	r3, [pc, #400]	; (801e614 <lv_btn_create+0x1c4>)
 801e484:	681b      	ldr	r3, [r3, #0]
 801e486:	2b00      	cmp	r3, #0
 801e488:	d105      	bne.n	801e496 <lv_btn_create+0x46>
 801e48a:	6978      	ldr	r0, [r7, #20]
 801e48c:	f7f3 ffb9 	bl	8012402 <lv_obj_get_signal_cb>
 801e490:	4602      	mov	r2, r0
 801e492:	4b60      	ldr	r3, [pc, #384]	; (801e614 <lv_btn_create+0x1c4>)
 801e494:	601a      	str	r2, [r3, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(new_btn);
 801e496:	4b60      	ldr	r3, [pc, #384]	; (801e618 <lv_btn_create+0x1c8>)
 801e498:	681b      	ldr	r3, [r3, #0]
 801e49a:	2b00      	cmp	r3, #0
 801e49c:	d105      	bne.n	801e4aa <lv_btn_create+0x5a>
 801e49e:	6978      	ldr	r0, [r7, #20]
 801e4a0:	f7f3 ffbb 	bl	801241a <lv_obj_get_design_cb>
 801e4a4:	4602      	mov	r2, r0
 801e4a6:	4b5c      	ldr	r3, [pc, #368]	; (801e618 <lv_btn_create+0x1c8>)
 801e4a8:	601a      	str	r2, [r3, #0]

    /*Allocate the extended data*/
    lv_btn_ext_t * ext = lv_obj_allocate_ext_attr(new_btn, sizeof(lv_btn_ext_t));
 801e4aa:	2120      	movs	r1, #32
 801e4ac:	6978      	ldr	r0, [r7, #20]
 801e4ae:	f7f3 fd83 	bl	8011fb8 <lv_obj_allocate_ext_attr>
 801e4b2:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 801e4b4:	693b      	ldr	r3, [r7, #16]
 801e4b6:	2b00      	cmp	r3, #0
 801e4b8:	d106      	bne.n	801e4c8 <lv_btn_create+0x78>
 801e4ba:	4b54      	ldr	r3, [pc, #336]	; (801e60c <lv_btn_create+0x1bc>)
 801e4bc:	2257      	movs	r2, #87	; 0x57
 801e4be:	4954      	ldr	r1, [pc, #336]	; (801e610 <lv_btn_create+0x1c0>)
 801e4c0:	2003      	movs	r0, #3
 801e4c2:	f7fe f9a3 	bl	801c80c <lv_log_add>
 801e4c6:	e7fe      	b.n	801e4c6 <lv_btn_create+0x76>
    if(ext == NULL) return NULL;
 801e4c8:	693b      	ldr	r3, [r7, #16]
 801e4ca:	2b00      	cmp	r3, #0
 801e4cc:	d101      	bne.n	801e4d2 <lv_btn_create+0x82>
 801e4ce:	2300      	movs	r3, #0
 801e4d0:	e098      	b.n	801e604 <lv_btn_create+0x1b4>

    ext->state = LV_BTN_STATE_REL;
 801e4d2:	693a      	ldr	r2, [r7, #16]
 801e4d4:	7f93      	ldrb	r3, [r2, #30]
 801e4d6:	f36f 0302 	bfc	r3, #0, #3
 801e4da:	7793      	strb	r3, [r2, #30]

    ext->styles[LV_BTN_STATE_REL]     = &lv_style_btn_rel;
 801e4dc:	693b      	ldr	r3, [r7, #16]
 801e4de:	4a4f      	ldr	r2, [pc, #316]	; (801e61c <lv_btn_create+0x1cc>)
 801e4e0:	605a      	str	r2, [r3, #4]
    ext->styles[LV_BTN_STATE_PR]      = &lv_style_btn_pr;
 801e4e2:	693b      	ldr	r3, [r7, #16]
 801e4e4:	4a4e      	ldr	r2, [pc, #312]	; (801e620 <lv_btn_create+0x1d0>)
 801e4e6:	609a      	str	r2, [r3, #8]
    ext->styles[LV_BTN_STATE_TGL_REL] = &lv_style_btn_tgl_rel;
 801e4e8:	693b      	ldr	r3, [r7, #16]
 801e4ea:	4a4e      	ldr	r2, [pc, #312]	; (801e624 <lv_btn_create+0x1d4>)
 801e4ec:	60da      	str	r2, [r3, #12]
    ext->styles[LV_BTN_STATE_TGL_PR]  = &lv_style_btn_tgl_pr;
 801e4ee:	693b      	ldr	r3, [r7, #16]
 801e4f0:	4a4d      	ldr	r2, [pc, #308]	; (801e628 <lv_btn_create+0x1d8>)
 801e4f2:	611a      	str	r2, [r3, #16]
    ext->styles[LV_BTN_STATE_INA]     = &lv_style_btn_ina;
 801e4f4:	693b      	ldr	r3, [r7, #16]
 801e4f6:	4a4d      	ldr	r2, [pc, #308]	; (801e62c <lv_btn_create+0x1dc>)
 801e4f8:	615a      	str	r2, [r3, #20]

    ext->toggle = 0;
 801e4fa:	693a      	ldr	r2, [r7, #16]
 801e4fc:	7f93      	ldrb	r3, [r2, #30]
 801e4fe:	f36f 03c3 	bfc	r3, #3, #1
 801e502:	7793      	strb	r3, [r2, #30]
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
    ext->ink_in_time   = 0;
 801e504:	693b      	ldr	r3, [r7, #16]
 801e506:	2200      	movs	r2, #0
 801e508:	831a      	strh	r2, [r3, #24]
    ext->ink_wait_time = 0;
 801e50a:	693b      	ldr	r3, [r7, #16]
 801e50c:	2200      	movs	r2, #0
 801e50e:	835a      	strh	r2, [r3, #26]
    ext->ink_out_time  = 0;
 801e510:	693b      	ldr	r3, [r7, #16]
 801e512:	2200      	movs	r2, #0
 801e514:	839a      	strh	r2, [r3, #28]
#endif

    lv_obj_set_signal_cb(new_btn, lv_btn_signal);
 801e516:	4946      	ldr	r1, [pc, #280]	; (801e630 <lv_btn_create+0x1e0>)
 801e518:	6978      	ldr	r0, [r7, #20]
 801e51a:	f7f3 fd31 	bl	8011f80 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_btn, lv_btn_design);
 801e51e:	4945      	ldr	r1, [pc, #276]	; (801e634 <lv_btn_create+0x1e4>)
 801e520:	6978      	ldr	r0, [r7, #20]
 801e522:	f7f3 fd3b 	bl	8011f9c <lv_obj_set_design_cb>

    /*If no copy do the basic initialization*/
    if(copy == NULL) {
 801e526:	683b      	ldr	r3, [r7, #0]
 801e528:	2b00      	cmp	r3, #0
 801e52a:	d13b      	bne.n	801e5a4 <lv_btn_create+0x154>
        /*Set layout if the button is not a screen*/
        if(par != NULL) {
 801e52c:	687b      	ldr	r3, [r7, #4]
 801e52e:	2b00      	cmp	r3, #0
 801e530:	d003      	beq.n	801e53a <lv_btn_create+0xea>
            lv_btn_set_layout(new_btn, LV_LAYOUT_CENTER);
 801e532:	2101      	movs	r1, #1
 801e534:	6978      	ldr	r0, [r7, #20]
 801e536:	f7ff ff7c 	bl	801e432 <lv_btn_set_layout>
        }

        lv_obj_set_click(new_btn, true); /*Be sure the button is clickable*/
 801e53a:	2101      	movs	r1, #1
 801e53c:	6978      	ldr	r0, [r7, #20]
 801e53e:	f7f3 fc12 	bl	8011d66 <lv_obj_set_click>

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 801e542:	f007 fa25 	bl	8025990 <lv_theme_get_current>
 801e546:	60b8      	str	r0, [r7, #8]
        if(th) {
 801e548:	68bb      	ldr	r3, [r7, #8]
 801e54a:	2b00      	cmp	r3, #0
 801e54c:	d023      	beq.n	801e596 <lv_btn_create+0x146>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_REL, th->style.btn.rel);
 801e54e:	68bb      	ldr	r3, [r7, #8]
 801e550:	691b      	ldr	r3, [r3, #16]
 801e552:	461a      	mov	r2, r3
 801e554:	2100      	movs	r1, #0
 801e556:	6978      	ldr	r0, [r7, #20]
 801e558:	f000 f898 	bl	801e68c <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_PR, th->style.btn.pr);
 801e55c:	68bb      	ldr	r3, [r7, #8]
 801e55e:	695b      	ldr	r3, [r3, #20]
 801e560:	461a      	mov	r2, r3
 801e562:	2101      	movs	r1, #1
 801e564:	6978      	ldr	r0, [r7, #20]
 801e566:	f000 f891 	bl	801e68c <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_TGL_REL, th->style.btn.tgl_rel);
 801e56a:	68bb      	ldr	r3, [r7, #8]
 801e56c:	699b      	ldr	r3, [r3, #24]
 801e56e:	461a      	mov	r2, r3
 801e570:	2102      	movs	r1, #2
 801e572:	6978      	ldr	r0, [r7, #20]
 801e574:	f000 f88a 	bl	801e68c <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_TGL_PR, th->style.btn.tgl_pr);
 801e578:	68bb      	ldr	r3, [r7, #8]
 801e57a:	69db      	ldr	r3, [r3, #28]
 801e57c:	461a      	mov	r2, r3
 801e57e:	2103      	movs	r1, #3
 801e580:	6978      	ldr	r0, [r7, #20]
 801e582:	f000 f883 	bl	801e68c <lv_btn_set_style>
            lv_btn_set_style(new_btn, LV_BTN_STYLE_INA, th->style.btn.ina);
 801e586:	68bb      	ldr	r3, [r7, #8]
 801e588:	6a1b      	ldr	r3, [r3, #32]
 801e58a:	461a      	mov	r2, r3
 801e58c:	2104      	movs	r1, #4
 801e58e:	6978      	ldr	r0, [r7, #20]
 801e590:	f000 f87c 	bl	801e68c <lv_btn_set_style>
 801e594:	e035      	b.n	801e602 <lv_btn_create+0x1b2>
        } else {
            lv_obj_set_style(new_btn, ext->styles[LV_BTN_STATE_REL]);
 801e596:	693b      	ldr	r3, [r7, #16]
 801e598:	685b      	ldr	r3, [r3, #4]
 801e59a:	4619      	mov	r1, r3
 801e59c:	6978      	ldr	r0, [r7, #20]
 801e59e:	f7f3 fb88 	bl	8011cb2 <lv_obj_set_style>
 801e5a2:	e02e      	b.n	801e602 <lv_btn_create+0x1b2>
        }
    }
    /*Copy 'copy'*/
    else {
        lv_btn_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 801e5a4:	6838      	ldr	r0, [r7, #0]
 801e5a6:	f7f3 ff44 	bl	8012432 <lv_obj_get_ext_attr>
 801e5aa:	60f8      	str	r0, [r7, #12]
        ext->state              = copy_ext->state;
 801e5ac:	68fb      	ldr	r3, [r7, #12]
 801e5ae:	7f9b      	ldrb	r3, [r3, #30]
 801e5b0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e5b4:	b2d9      	uxtb	r1, r3
 801e5b6:	693a      	ldr	r2, [r7, #16]
 801e5b8:	7f93      	ldrb	r3, [r2, #30]
 801e5ba:	f361 0302 	bfi	r3, r1, #0, #3
 801e5be:	7793      	strb	r3, [r2, #30]
        ext->toggle             = copy_ext->toggle;
 801e5c0:	68fb      	ldr	r3, [r7, #12]
 801e5c2:	7f9b      	ldrb	r3, [r3, #30]
 801e5c4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801e5c8:	b2d9      	uxtb	r1, r3
 801e5ca:	693a      	ldr	r2, [r7, #16]
 801e5cc:	7f93      	ldrb	r3, [r2, #30]
 801e5ce:	f361 03c3 	bfi	r3, r1, #3, #1
 801e5d2:	7793      	strb	r3, [r2, #30]
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
        ext->ink_in_time   = copy_ext->ink_in_time;
 801e5d4:	68fb      	ldr	r3, [r7, #12]
 801e5d6:	8b1a      	ldrh	r2, [r3, #24]
 801e5d8:	693b      	ldr	r3, [r7, #16]
 801e5da:	831a      	strh	r2, [r3, #24]
        ext->ink_wait_time = copy_ext->ink_wait_time;
 801e5dc:	68fb      	ldr	r3, [r7, #12]
 801e5de:	8b5a      	ldrh	r2, [r3, #26]
 801e5e0:	693b      	ldr	r3, [r7, #16]
 801e5e2:	835a      	strh	r2, [r3, #26]
        ext->ink_out_time  = copy_ext->ink_out_time;
 801e5e4:	68fb      	ldr	r3, [r7, #12]
 801e5e6:	8b9a      	ldrh	r2, [r3, #28]
 801e5e8:	693b      	ldr	r3, [r7, #16]
 801e5ea:	839a      	strh	r2, [r3, #28]
#endif
        memcpy(ext->styles, copy_ext->styles, sizeof(ext->styles));
 801e5ec:	693b      	ldr	r3, [r7, #16]
 801e5ee:	1d18      	adds	r0, r3, #4
 801e5f0:	68fb      	ldr	r3, [r7, #12]
 801e5f2:	3304      	adds	r3, #4
 801e5f4:	2214      	movs	r2, #20
 801e5f6:	4619      	mov	r1, r3
 801e5f8:	f008 fde0 	bl	80271bc <memcpy>

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_btn);
 801e5fc:	6978      	ldr	r0, [r7, #20]
 801e5fe:	f7f3 fb6a 	bl	8011cd6 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("button created");

    return new_btn;
 801e602:	697b      	ldr	r3, [r7, #20]
}
 801e604:	4618      	mov	r0, r3
 801e606:	3718      	adds	r7, #24
 801e608:	46bd      	mov	sp, r7
 801e60a:	bd80      	pop	{r7, pc}
 801e60c:	08028f50 	.word	0x08028f50
 801e610:	08028f60 	.word	0x08028f60
 801e614:	2000c3b4 	.word	0x2000c3b4
 801e618:	2000c3b8 	.word	0x2000c3b8
 801e61c:	2000dcb0 	.word	0x2000dcb0
 801e620:	2000dcec 	.word	0x2000dcec
 801e624:	2000de54 	.word	0x2000de54
 801e628:	2000decc 	.word	0x2000decc
 801e62c:	2000dda0 	.word	0x2000dda0
 801e630:	0801eaa9 	.word	0x0801eaa9
 801e634:	0801e761 	.word	0x0801e761

0801e638 <lv_btn_set_state>:
 * Set the state of the button
 * @param btn pointer to a button object
 * @param state the new state of the button (from lv_btn_state_t enum)
 */
void lv_btn_set_state(lv_obj_t * btn, lv_btn_state_t state)
{
 801e638:	b580      	push	{r7, lr}
 801e63a:	b084      	sub	sp, #16
 801e63c:	af00      	add	r7, sp, #0
 801e63e:	6078      	str	r0, [r7, #4]
 801e640:	460b      	mov	r3, r1
 801e642:	70fb      	strb	r3, [r7, #3]
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 801e644:	6878      	ldr	r0, [r7, #4]
 801e646:	f7f3 fef4 	bl	8012432 <lv_obj_get_ext_attr>
 801e64a:	60f8      	str	r0, [r7, #12]
    if(ext->state != state) {
 801e64c:	68fb      	ldr	r3, [r7, #12]
 801e64e:	7f9b      	ldrb	r3, [r3, #30]
 801e650:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e654:	b2db      	uxtb	r3, r3
 801e656:	461a      	mov	r2, r3
 801e658:	78fb      	ldrb	r3, [r7, #3]
 801e65a:	429a      	cmp	r2, r3
 801e65c:	d011      	beq.n	801e682 <lv_btn_set_state+0x4a>
        ext->state = state;
 801e65e:	78fb      	ldrb	r3, [r7, #3]
 801e660:	f003 0307 	and.w	r3, r3, #7
 801e664:	b2d9      	uxtb	r1, r3
 801e666:	68fa      	ldr	r2, [r7, #12]
 801e668:	7f93      	ldrb	r3, [r2, #30]
 801e66a:	f361 0302 	bfi	r3, r1, #0, #3
 801e66e:	7793      	strb	r3, [r2, #30]
        lv_obj_set_style(btn, ext->styles[state]);
 801e670:	78fb      	ldrb	r3, [r7, #3]
 801e672:	68fa      	ldr	r2, [r7, #12]
 801e674:	009b      	lsls	r3, r3, #2
 801e676:	4413      	add	r3, r2
 801e678:	685b      	ldr	r3, [r3, #4]
 801e67a:	4619      	mov	r1, r3
 801e67c:	6878      	ldr	r0, [r7, #4]
 801e67e:	f7f3 fb18 	bl	8011cb2 <lv_obj_set_style>
    }
}
 801e682:	bf00      	nop
 801e684:	3710      	adds	r7, #16
 801e686:	46bd      	mov	sp, r7
 801e688:	bd80      	pop	{r7, pc}
	...

0801e68c <lv_btn_set_style>:
 * @param btn pointer to a button object
 * @param type which style should be set
 * @param style pointer to a style
 */
void lv_btn_set_style(lv_obj_t * btn, lv_btn_style_t type, const lv_style_t * style)
{
 801e68c:	b580      	push	{r7, lr}
 801e68e:	b086      	sub	sp, #24
 801e690:	af00      	add	r7, sp, #0
 801e692:	60f8      	str	r0, [r7, #12]
 801e694:	460b      	mov	r3, r1
 801e696:	607a      	str	r2, [r7, #4]
 801e698:	72fb      	strb	r3, [r7, #11]
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 801e69a:	68f8      	ldr	r0, [r7, #12]
 801e69c:	f7f3 fec9 	bl	8012432 <lv_obj_get_ext_attr>
 801e6a0:	6178      	str	r0, [r7, #20]

    switch(type) {
 801e6a2:	7afb      	ldrb	r3, [r7, #11]
 801e6a4:	2b04      	cmp	r3, #4
 801e6a6:	d821      	bhi.n	801e6ec <lv_btn_set_style+0x60>
 801e6a8:	a201      	add	r2, pc, #4	; (adr r2, 801e6b0 <lv_btn_set_style+0x24>)
 801e6aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 801e6ae:	bf00      	nop
 801e6b0:	0801e6c5 	.word	0x0801e6c5
 801e6b4:	0801e6cd 	.word	0x0801e6cd
 801e6b8:	0801e6d5 	.word	0x0801e6d5
 801e6bc:	0801e6dd 	.word	0x0801e6dd
 801e6c0:	0801e6e5 	.word	0x0801e6e5
        case LV_BTN_STYLE_REL: ext->styles[LV_BTN_STATE_REL] = style; break;
 801e6c4:	697b      	ldr	r3, [r7, #20]
 801e6c6:	687a      	ldr	r2, [r7, #4]
 801e6c8:	605a      	str	r2, [r3, #4]
 801e6ca:	e00f      	b.n	801e6ec <lv_btn_set_style+0x60>
        case LV_BTN_STYLE_PR: ext->styles[LV_BTN_STATE_PR] = style; break;
 801e6cc:	697b      	ldr	r3, [r7, #20]
 801e6ce:	687a      	ldr	r2, [r7, #4]
 801e6d0:	609a      	str	r2, [r3, #8]
 801e6d2:	e00b      	b.n	801e6ec <lv_btn_set_style+0x60>
        case LV_BTN_STYLE_TGL_REL: ext->styles[LV_BTN_STATE_TGL_REL] = style; break;
 801e6d4:	697b      	ldr	r3, [r7, #20]
 801e6d6:	687a      	ldr	r2, [r7, #4]
 801e6d8:	60da      	str	r2, [r3, #12]
 801e6da:	e007      	b.n	801e6ec <lv_btn_set_style+0x60>
        case LV_BTN_STYLE_TGL_PR: ext->styles[LV_BTN_STATE_TGL_PR] = style; break;
 801e6dc:	697b      	ldr	r3, [r7, #20]
 801e6de:	687a      	ldr	r2, [r7, #4]
 801e6e0:	611a      	str	r2, [r3, #16]
 801e6e2:	e003      	b.n	801e6ec <lv_btn_set_style+0x60>
        case LV_BTN_STYLE_INA: ext->styles[LV_BTN_STATE_INA] = style; break;
 801e6e4:	697b      	ldr	r3, [r7, #20]
 801e6e6:	687a      	ldr	r2, [r7, #4]
 801e6e8:	615a      	str	r2, [r3, #20]
 801e6ea:	bf00      	nop
    }

    /*Refresh the object with the new style*/
    lv_obj_set_style(btn, ext->styles[ext->state]);
 801e6ec:	697b      	ldr	r3, [r7, #20]
 801e6ee:	7f9b      	ldrb	r3, [r3, #30]
 801e6f0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e6f4:	b2db      	uxtb	r3, r3
 801e6f6:	697a      	ldr	r2, [r7, #20]
 801e6f8:	009b      	lsls	r3, r3, #2
 801e6fa:	4413      	add	r3, r2
 801e6fc:	685b      	ldr	r3, [r3, #4]
 801e6fe:	4619      	mov	r1, r3
 801e700:	68f8      	ldr	r0, [r7, #12]
 801e702:	f7f3 fad6 	bl	8011cb2 <lv_obj_set_style>
}
 801e706:	bf00      	nop
 801e708:	3718      	adds	r7, #24
 801e70a:	46bd      	mov	sp, r7
 801e70c:	bd80      	pop	{r7, pc}
 801e70e:	bf00      	nop

0801e710 <lv_btn_get_state>:
 * Get the current state of the button
 * @param btn pointer to a button object
 * @return the state of the button (from lv_btn_state_t enum)
 */
lv_btn_state_t lv_btn_get_state(const lv_obj_t * btn)
{
 801e710:	b580      	push	{r7, lr}
 801e712:	b084      	sub	sp, #16
 801e714:	af00      	add	r7, sp, #0
 801e716:	6078      	str	r0, [r7, #4]
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 801e718:	6878      	ldr	r0, [r7, #4]
 801e71a:	f7f3 fe8a 	bl	8012432 <lv_obj_get_ext_attr>
 801e71e:	60f8      	str	r0, [r7, #12]
    return ext->state;
 801e720:	68fb      	ldr	r3, [r7, #12]
 801e722:	7f9b      	ldrb	r3, [r3, #30]
 801e724:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801e728:	b2db      	uxtb	r3, r3
}
 801e72a:	4618      	mov	r0, r3
 801e72c:	3710      	adds	r7, #16
 801e72e:	46bd      	mov	sp, r7
 801e730:	bd80      	pop	{r7, pc}

0801e732 <lv_btn_get_toggle>:
 * Get the toggle enable attribute of the button
 * @param btn pointer to a button object
 * @return ture: toggle enabled, false: disabled
 */
bool lv_btn_get_toggle(const lv_obj_t * btn)
{
 801e732:	b580      	push	{r7, lr}
 801e734:	b084      	sub	sp, #16
 801e736:	af00      	add	r7, sp, #0
 801e738:	6078      	str	r0, [r7, #4]
    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 801e73a:	6878      	ldr	r0, [r7, #4]
 801e73c:	f7f3 fe79 	bl	8012432 <lv_obj_get_ext_attr>
 801e740:	60f8      	str	r0, [r7, #12]

    return ext->toggle != 0 ? true : false;
 801e742:	68fb      	ldr	r3, [r7, #12]
 801e744:	7f9b      	ldrb	r3, [r3, #30]
 801e746:	08db      	lsrs	r3, r3, #3
 801e748:	b2db      	uxtb	r3, r3
 801e74a:	f003 0301 	and.w	r3, r3, #1
 801e74e:	2b00      	cmp	r3, #0
 801e750:	bf14      	ite	ne
 801e752:	2301      	movne	r3, #1
 801e754:	2300      	moveq	r3, #0
 801e756:	b2db      	uxtb	r3, r3
}
 801e758:	4618      	mov	r0, r3
 801e75a:	3710      	adds	r7, #16
 801e75c:	46bd      	mov	sp, r7
 801e75e:	bd80      	pop	{r7, pc}

0801e760 <lv_btn_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_btn_design(lv_obj_t * btn, const lv_area_t * mask, lv_design_mode_t mode)
{
 801e760:	b580      	push	{r7, lr}
 801e762:	b09c      	sub	sp, #112	; 0x70
 801e764:	af00      	add	r7, sp, #0
 801e766:	60f8      	str	r0, [r7, #12]
 801e768:	60b9      	str	r1, [r7, #8]
 801e76a:	4613      	mov	r3, r2
 801e76c:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 801e76e:	79fb      	ldrb	r3, [r7, #7]
 801e770:	2b02      	cmp	r3, #2
 801e772:	d101      	bne.n	801e778 <lv_btn_design+0x18>
        return false;
 801e774:	2300      	movs	r3, #0
 801e776:	e191      	b.n	801ea9c <lv_btn_design+0x33c>
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 801e778:	79fb      	ldrb	r3, [r7, #7]
 801e77a:	2b00      	cmp	r3, #0
 801e77c:	f040 8184 	bne.w	801ea88 <lv_btn_design+0x328>

#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
        if(btn != ink_obj) {
 801e780:	4bba      	ldr	r3, [pc, #744]	; (801ea6c <lv_btn_design+0x30c>)
 801e782:	681b      	ldr	r3, [r3, #0]
 801e784:	68fa      	ldr	r2, [r7, #12]
 801e786:	429a      	cmp	r2, r3
 801e788:	d006      	beq.n	801e798 <lv_btn_design+0x38>
            ancestor_design(btn, mask, mode);
 801e78a:	4bb9      	ldr	r3, [pc, #740]	; (801ea70 <lv_btn_design+0x310>)
 801e78c:	681b      	ldr	r3, [r3, #0]
 801e78e:	79fa      	ldrb	r2, [r7, #7]
 801e790:	68b9      	ldr	r1, [r7, #8]
 801e792:	68f8      	ldr	r0, [r7, #12]
 801e794:	4798      	blx	r3
 801e796:	e180      	b.n	801ea9a <lv_btn_design+0x33a>
        } else {
            lv_opa_t opa_scale = lv_obj_get_opa_scale(btn);
 801e798:	68f8      	ldr	r0, [r7, #12]
 801e79a:	f7f3 fdfc 	bl	8012396 <lv_obj_get_opa_scale>
 801e79e:	4603      	mov	r3, r0
 801e7a0:	f887 306f 	strb.w	r3, [r7, #111]	; 0x6f
            lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 801e7a4:	68f8      	ldr	r0, [r7, #12]
 801e7a6:	f7f3 fe44 	bl	8012432 <lv_obj_get_ext_attr>
 801e7aa:	66b8      	str	r0, [r7, #104]	; 0x68

            /*Draw the normal button*/
            if(ink_playback == false) {
 801e7ac:	4bb1      	ldr	r3, [pc, #708]	; (801ea74 <lv_btn_design+0x314>)
 801e7ae:	781b      	ldrb	r3, [r3, #0]
 801e7b0:	f083 0301 	eor.w	r3, r3, #1
 801e7b4:	b2db      	uxtb	r3, r3
 801e7b6:	2b00      	cmp	r3, #0
 801e7b8:	f000 812d 	beq.w	801ea16 <lv_btn_design+0x2b6>
                lv_style_t style_tmp;
                lv_style_copy(&style_tmp, ext->styles[ink_bg_state]);
 801e7bc:	4bae      	ldr	r3, [pc, #696]	; (801ea78 <lv_btn_design+0x318>)
 801e7be:	781b      	ldrb	r3, [r3, #0]
 801e7c0:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801e7c2:	009b      	lsls	r3, r3, #2
 801e7c4:	4413      	add	r3, r2
 801e7c6:	685a      	ldr	r2, [r3, #4]
 801e7c8:	f107 0310 	add.w	r3, r7, #16
 801e7cc:	4611      	mov	r1, r2
 801e7ce:	4618      	mov	r0, r3
 801e7d0:	f7f5 f948 	bl	8013a64 <lv_style_copy>
                style_tmp.body.shadow.width = ext->styles[ink_top_state]->body.shadow.width;
 801e7d4:	4ba9      	ldr	r3, [pc, #676]	; (801ea7c <lv_btn_design+0x31c>)
 801e7d6:	781b      	ldrb	r3, [r3, #0]
 801e7d8:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801e7da:	009b      	lsls	r3, r3, #2
 801e7dc:	4413      	add	r3, r2
 801e7de:	685b      	ldr	r3, [r3, #4]
 801e7e0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801e7e4:	847b      	strh	r3, [r7, #34]	; 0x22
                lv_draw_rect(&btn->coords, mask, &style_tmp, opa_scale);
 801e7e6:	68fb      	ldr	r3, [r7, #12]
 801e7e8:	f103 0010 	add.w	r0, r3, #16
 801e7ec:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801e7f0:	f107 0210 	add.w	r2, r7, #16
 801e7f4:	68b9      	ldr	r1, [r7, #8]
 801e7f6:	f7f7 f884 	bl	8015902 <lv_draw_rect>

                lv_coord_t w     = lv_obj_get_width(btn);
 801e7fa:	68f8      	ldr	r0, [r7, #12]
 801e7fc:	f7f3 fcca 	bl	8012194 <lv_obj_get_width>
 801e800:	4603      	mov	r3, r0
 801e802:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
                lv_coord_t h     = lv_obj_get_height(btn);
 801e806:	68f8      	ldr	r0, [r7, #12]
 801e808:	f7f3 fcd2 	bl	80121b0 <lv_obj_get_height>
 801e80c:	4603      	mov	r3, r0
 801e80e:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
                lv_coord_t r_max = LV_MATH_MIN(w, h) / 2;
 801e812:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 801e816:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801e81a:	4293      	cmp	r3, r2
 801e81c:	bfa8      	it	ge
 801e81e:	4613      	movge	r3, r2
 801e820:	b21b      	sxth	r3, r3
 801e822:	2b00      	cmp	r3, #0
 801e824:	da00      	bge.n	801e828 <lv_btn_design+0xc8>
 801e826:	3301      	adds	r3, #1
 801e828:	105b      	asrs	r3, r3, #1
 801e82a:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62

                /*In the first part of the animation increase the size of the circle (ink effect) */
                lv_area_t cir_area;

                lv_coord_t coord_state =
                    ink_act_value < LV_BTN_INK_VALUE_MAX / 2 ? ink_act_value : LV_BTN_INK_VALUE_MAX / 2;
 801e82e:	4b94      	ldr	r3, [pc, #592]	; (801ea80 <lv_btn_design+0x320>)
 801e830:	f9b3 3000 	ldrsh.w	r3, [r3]
                lv_coord_t coord_state =
 801e834:	2b80      	cmp	r3, #128	; 0x80
 801e836:	bfa8      	it	ge
 801e838:	2380      	movge	r3, #128	; 0x80
 801e83a:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
                lv_point_t p_act;
                p_act.x          = ink_point.x;
 801e83e:	4b91      	ldr	r3, [pc, #580]	; (801ea84 <lv_btn_design+0x324>)
 801e840:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e844:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                p_act.y          = ink_point.y;
 801e848:	4b8e      	ldr	r3, [pc, #568]	; (801ea84 <lv_btn_design+0x324>)
 801e84a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801e84e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                lv_coord_t x_err = (btn->coords.x1 + w / 2) - p_act.x;
 801e852:	68fb      	ldr	r3, [r7, #12]
 801e854:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 801e858:	b29a      	uxth	r2, r3
 801e85a:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801e85e:	2b00      	cmp	r3, #0
 801e860:	da00      	bge.n	801e864 <lv_btn_design+0x104>
 801e862:	3301      	adds	r3, #1
 801e864:	105b      	asrs	r3, r3, #1
 801e866:	b21b      	sxth	r3, r3
 801e868:	b29b      	uxth	r3, r3
 801e86a:	4413      	add	r3, r2
 801e86c:	b29a      	uxth	r2, r3
 801e86e:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801e872:	b29b      	uxth	r3, r3
 801e874:	1ad3      	subs	r3, r2, r3
 801e876:	b29b      	uxth	r3, r3
 801e878:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
                lv_coord_t y_err = (btn->coords.y1 + h / 2) - p_act.y;
 801e87c:	68fb      	ldr	r3, [r7, #12]
 801e87e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 801e882:	b29a      	uxth	r2, r3
 801e884:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 801e888:	2b00      	cmp	r3, #0
 801e88a:	da00      	bge.n	801e88e <lv_btn_design+0x12e>
 801e88c:	3301      	adds	r3, #1
 801e88e:	105b      	asrs	r3, r3, #1
 801e890:	b21b      	sxth	r3, r3
 801e892:	b29b      	uxth	r3, r3
 801e894:	4413      	add	r3, r2
 801e896:	b29a      	uxth	r2, r3
 801e898:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801e89c:	b29b      	uxth	r3, r3
 801e89e:	1ad3      	subs	r3, r2, r3
 801e8a0:	b29b      	uxth	r3, r3
 801e8a2:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c

                p_act.x += (x_err * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1);
 801e8a6:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801e8aa:	b29a      	uxth	r2, r3
 801e8ac:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 801e8b0:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801e8b4:	fb01 f303 	mul.w	r3, r1, r3
 801e8b8:	11db      	asrs	r3, r3, #7
 801e8ba:	b29b      	uxth	r3, r3
 801e8bc:	4413      	add	r3, r2
 801e8be:	b29b      	uxth	r3, r3
 801e8c0:	b21b      	sxth	r3, r3
 801e8c2:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                p_act.y += (y_err * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1);
 801e8c6:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801e8ca:	b29a      	uxth	r2, r3
 801e8cc:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 801e8d0:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801e8d4:	fb01 f303 	mul.w	r3, r1, r3
 801e8d8:	11db      	asrs	r3, r3, #7
 801e8da:	b29b      	uxth	r3, r3
 801e8dc:	4413      	add	r3, r2
 801e8de:	b29b      	uxth	r3, r3
 801e8e0:	b21b      	sxth	r3, r3
 801e8e2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

                lv_coord_t half_side = LV_MATH_MAX(w, h) / 2;
 801e8e6:	f9b7 2064 	ldrsh.w	r2, [r7, #100]	; 0x64
 801e8ea:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 801e8ee:	4293      	cmp	r3, r2
 801e8f0:	bfb8      	it	lt
 801e8f2:	4613      	movlt	r3, r2
 801e8f4:	b21b      	sxth	r3, r3
 801e8f6:	2b00      	cmp	r3, #0
 801e8f8:	da00      	bge.n	801e8fc <lv_btn_design+0x19c>
 801e8fa:	3301      	adds	r3, #1
 801e8fc:	105b      	asrs	r3, r3, #1
 801e8fe:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
                cir_area.x1          = p_act.x - ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));
 801e902:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801e906:	b29a      	uxth	r2, r3
 801e908:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801e90c:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801e910:	fb01 f303 	mul.w	r3, r1, r3
 801e914:	11db      	asrs	r3, r3, #7
 801e916:	b29b      	uxth	r3, r3
 801e918:	1ad3      	subs	r3, r2, r3
 801e91a:	b29b      	uxth	r3, r3
 801e91c:	b21b      	sxth	r3, r3
 801e91e:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                cir_area.y1          = p_act.y - ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));
 801e922:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801e926:	b29a      	uxth	r2, r3
 801e928:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801e92c:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801e930:	fb01 f303 	mul.w	r3, r1, r3
 801e934:	11db      	asrs	r3, r3, #7
 801e936:	b29b      	uxth	r3, r3
 801e938:	1ad3      	subs	r3, r2, r3
 801e93a:	b29b      	uxth	r3, r3
 801e93c:	b21b      	sxth	r3, r3
 801e93e:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                cir_area.x2          = p_act.x + ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));
 801e942:	f9b7 304c 	ldrsh.w	r3, [r7, #76]	; 0x4c
 801e946:	b29a      	uxth	r2, r3
 801e948:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801e94c:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801e950:	fb01 f303 	mul.w	r3, r1, r3
 801e954:	11db      	asrs	r3, r3, #7
 801e956:	b29b      	uxth	r3, r3
 801e958:	4413      	add	r3, r2
 801e95a:	b29b      	uxth	r3, r3
 801e95c:	b21b      	sxth	r3, r3
 801e95e:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                cir_area.y2          = p_act.y + ((half_side * coord_state) >> (LV_BTN_INK_VALUE_MAX_SHIFT - 1));
 801e962:	f9b7 304e 	ldrsh.w	r3, [r7, #78]	; 0x4e
 801e966:	b29a      	uxth	r2, r3
 801e968:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 801e96c:	f9b7 1060 	ldrsh.w	r1, [r7, #96]	; 0x60
 801e970:	fb01 f303 	mul.w	r3, r1, r3
 801e974:	11db      	asrs	r3, r3, #7
 801e976:	b29b      	uxth	r3, r3
 801e978:	4413      	add	r3, r2
 801e97a:	b29b      	uxth	r3, r3
 801e97c:	b21b      	sxth	r3, r3
 801e97e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56

                lv_area_intersect(&cir_area, &btn->coords,
 801e982:	68fb      	ldr	r3, [r7, #12]
 801e984:	f103 0110 	add.w	r1, r3, #16
 801e988:	f107 0250 	add.w	r2, r7, #80	; 0x50
 801e98c:	f107 0350 	add.w	r3, r7, #80	; 0x50
 801e990:	4618      	mov	r0, r3
 801e992:	f7fd f8a1 	bl	801bad8 <lv_area_intersect>
                                  &cir_area); /*Limit the area. (It might be too big on the smaller side)*/

                /*In the second part animate the radius. Circle -> body.radius*/
                lv_coord_t r_state =
                    ink_act_value > LV_BTN_INK_VALUE_MAX / 2 ? ink_act_value - LV_BTN_INK_VALUE_MAX / 2 : 0;
 801e996:	4b3a      	ldr	r3, [pc, #232]	; (801ea80 <lv_btn_design+0x320>)
 801e998:	f9b3 3000 	ldrsh.w	r3, [r3]
                lv_coord_t r_state =
 801e99c:	2b80      	cmp	r3, #128	; 0x80
 801e99e:	dd07      	ble.n	801e9b0 <lv_btn_design+0x250>
                    ink_act_value > LV_BTN_INK_VALUE_MAX / 2 ? ink_act_value - LV_BTN_INK_VALUE_MAX / 2 : 0;
 801e9a0:	4b37      	ldr	r3, [pc, #220]	; (801ea80 <lv_btn_design+0x320>)
 801e9a2:	f9b3 3000 	ldrsh.w	r3, [r3]
 801e9a6:	b29b      	uxth	r3, r3
 801e9a8:	3b80      	subs	r3, #128	; 0x80
 801e9aa:	b29b      	uxth	r3, r3
                lv_coord_t r_state =
 801e9ac:	b21b      	sxth	r3, r3
 801e9ae:	e000      	b.n	801e9b2 <lv_btn_design+0x252>
 801e9b0:	2300      	movs	r3, #0
 801e9b2:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

                lv_style_copy(&style_tmp, ext->styles[ink_top_state]);
 801e9b6:	4b31      	ldr	r3, [pc, #196]	; (801ea7c <lv_btn_design+0x31c>)
 801e9b8:	781b      	ldrb	r3, [r3, #0]
 801e9ba:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801e9bc:	009b      	lsls	r3, r3, #2
 801e9be:	4413      	add	r3, r2
 801e9c0:	685a      	ldr	r2, [r3, #4]
 801e9c2:	f107 0310 	add.w	r3, r7, #16
 801e9c6:	4611      	mov	r1, r2
 801e9c8:	4618      	mov	r0, r3
 801e9ca:	f7f5 f84b 	bl	8013a64 <lv_style_copy>
                style_tmp.body.radius       = r_max + (((ext->styles[ink_bg_state]->body.radius - r_max) * r_state) >>
 801e9ce:	4b2a      	ldr	r3, [pc, #168]	; (801ea78 <lv_btn_design+0x318>)
 801e9d0:	781b      	ldrb	r3, [r3, #0]
 801e9d2:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801e9d4:	009b      	lsls	r3, r3, #2
 801e9d6:	4413      	add	r3, r2
 801e9d8:	685b      	ldr	r3, [r3, #4]
 801e9da:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801e9de:	461a      	mov	r2, r3
 801e9e0:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 801e9e4:	1ad3      	subs	r3, r2, r3
 801e9e6:	f9b7 2058 	ldrsh.w	r2, [r7, #88]	; 0x58
 801e9ea:	fb02 f303 	mul.w	r3, r2, r3
 801e9ee:	11db      	asrs	r3, r3, #7
 801e9f0:	b29a      	uxth	r2, r3
 801e9f2:	f8b7 3062 	ldrh.w	r3, [r7, #98]	; 0x62
 801e9f6:	4413      	add	r3, r2
 801e9f8:	b29b      	uxth	r3, r3
 801e9fa:	b21b      	sxth	r3, r3
 801e9fc:	82fb      	strh	r3, [r7, #22]
                                                 (LV_BTN_INK_VALUE_MAX_SHIFT - 1));
                style_tmp.body.border.width = 0;
 801e9fe:	2300      	movs	r3, #0
 801ea00:	83bb      	strh	r3, [r7, #28]

                /*Draw the circle*/
                lv_draw_rect(&cir_area, mask, &style_tmp, opa_scale);
 801ea02:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801ea06:	f107 0210 	add.w	r2, r7, #16
 801ea0a:	f107 0050 	add.w	r0, r7, #80	; 0x50
 801ea0e:	68b9      	ldr	r1, [r7, #8]
 801ea10:	f7f6 ff77 	bl	8015902 <lv_draw_rect>
 801ea14:	e041      	b.n	801ea9a <lv_btn_design+0x33a>
            } else {
                lv_style_t res;
                lv_style_copy(&res, ext->styles[ink_bg_state]);
 801ea16:	4b18      	ldr	r3, [pc, #96]	; (801ea78 <lv_btn_design+0x318>)
 801ea18:	781b      	ldrb	r3, [r3, #0]
 801ea1a:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801ea1c:	009b      	lsls	r3, r3, #2
 801ea1e:	4413      	add	r3, r2
 801ea20:	685a      	ldr	r2, [r3, #4]
 801ea22:	f107 0310 	add.w	r3, r7, #16
 801ea26:	4611      	mov	r1, r2
 801ea28:	4618      	mov	r0, r3
 801ea2a:	f7f5 f81b 	bl	8013a64 <lv_style_copy>
                lv_style_mix(ext->styles[ink_bg_state], ext->styles[ink_top_state], &res, ink_act_value);
 801ea2e:	4b12      	ldr	r3, [pc, #72]	; (801ea78 <lv_btn_design+0x318>)
 801ea30:	781b      	ldrb	r3, [r3, #0]
 801ea32:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801ea34:	009b      	lsls	r3, r3, #2
 801ea36:	4413      	add	r3, r2
 801ea38:	6858      	ldr	r0, [r3, #4]
 801ea3a:	4b10      	ldr	r3, [pc, #64]	; (801ea7c <lv_btn_design+0x31c>)
 801ea3c:	781b      	ldrb	r3, [r3, #0]
 801ea3e:	6eba      	ldr	r2, [r7, #104]	; 0x68
 801ea40:	009b      	lsls	r3, r3, #2
 801ea42:	4413      	add	r3, r2
 801ea44:	6859      	ldr	r1, [r3, #4]
 801ea46:	4b0e      	ldr	r3, [pc, #56]	; (801ea80 <lv_btn_design+0x320>)
 801ea48:	f9b3 3000 	ldrsh.w	r3, [r3]
 801ea4c:	b29b      	uxth	r3, r3
 801ea4e:	f107 0210 	add.w	r2, r7, #16
 801ea52:	f7f5 f815 	bl	8013a80 <lv_style_mix>
                lv_draw_rect(&btn->coords, mask, &res, opa_scale);
 801ea56:	68fb      	ldr	r3, [r7, #12]
 801ea58:	f103 0010 	add.w	r0, r3, #16
 801ea5c:	f897 306f 	ldrb.w	r3, [r7, #111]	; 0x6f
 801ea60:	f107 0210 	add.w	r2, r7, #16
 801ea64:	68b9      	ldr	r1, [r7, #8]
 801ea66:	f7f6 ff4c 	bl	8015902 <lv_draw_rect>
 801ea6a:	e016      	b.n	801ea9a <lv_btn_design+0x33a>
 801ea6c:	2000c3c0 	.word	0x2000c3c0
 801ea70:	2000c3b8 	.word	0x2000c3b8
 801ea74:	2000c3c7 	.word	0x2000c3c7
 801ea78:	2000c3c4 	.word	0x2000c3c4
 801ea7c:	2000c3c5 	.word	0x2000c3c5
 801ea80:	2000c3bc 	.word	0x2000c3bc
 801ea84:	2000c3c8 	.word	0x2000c3c8
            }
        }
#else
        ancestor_design(btn, mask, mode);
#endif
    } else if(mode == LV_DESIGN_DRAW_POST) {
 801ea88:	79fb      	ldrb	r3, [r7, #7]
 801ea8a:	2b01      	cmp	r3, #1
 801ea8c:	d105      	bne.n	801ea9a <lv_btn_design+0x33a>
        ancestor_design(btn, mask, mode);
 801ea8e:	4b05      	ldr	r3, [pc, #20]	; (801eaa4 <lv_btn_design+0x344>)
 801ea90:	681b      	ldr	r3, [r3, #0]
 801ea92:	79fa      	ldrb	r2, [r7, #7]
 801ea94:	68b9      	ldr	r1, [r7, #8]
 801ea96:	68f8      	ldr	r0, [r7, #12]
 801ea98:	4798      	blx	r3
    }

    return true;
 801ea9a:	2301      	movs	r3, #1
}
 801ea9c:	4618      	mov	r0, r3
 801ea9e:	3770      	adds	r7, #112	; 0x70
 801eaa0:	46bd      	mov	sp, r7
 801eaa2:	bd80      	pop	{r7, pc}
 801eaa4:	2000c3b8 	.word	0x2000c3b8

0801eaa8 <lv_btn_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_btn_signal(lv_obj_t * btn, lv_signal_t sign, void * param)
{
 801eaa8:	b580      	push	{r7, lr}
 801eaaa:	b096      	sub	sp, #88	; 0x58
 801eaac:	af00      	add	r7, sp, #0
 801eaae:	60f8      	str	r0, [r7, #12]
 801eab0:	460b      	mov	r3, r1
 801eab2:	607a      	str	r2, [r7, #4]
 801eab4:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(btn, sign, param);
 801eab6:	4ba8      	ldr	r3, [pc, #672]	; (801ed58 <lv_btn_signal+0x2b0>)
 801eab8:	681b      	ldr	r3, [r3, #0]
 801eaba:	7af9      	ldrb	r1, [r7, #11]
 801eabc:	687a      	ldr	r2, [r7, #4]
 801eabe:	68f8      	ldr	r0, [r7, #12]
 801eac0:	4798      	blx	r3
 801eac2:	4603      	mov	r3, r0
 801eac4:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
    if(res != LV_RES_OK) return res;
 801eac8:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801eacc:	2b01      	cmp	r3, #1
 801eace:	d002      	beq.n	801ead6 <lv_btn_signal+0x2e>
 801ead0:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801ead4:	e237      	b.n	801ef46 <lv_btn_signal+0x49e>

    lv_btn_ext_t * ext = lv_obj_get_ext_attr(btn);
 801ead6:	68f8      	ldr	r0, [r7, #12]
 801ead8:	f7f3 fcab 	bl	8012432 <lv_obj_get_ext_attr>
 801eadc:	6538      	str	r0, [r7, #80]	; 0x50
    bool tgl           = lv_btn_get_toggle(btn);
 801eade:	68f8      	ldr	r0, [r7, #12]
 801eae0:	f7ff fe27 	bl	801e732 <lv_btn_get_toggle>
 801eae4:	4603      	mov	r3, r0
 801eae6:	f887 304f 	strb.w	r3, [r7, #79]	; 0x4f

    if(sign == LV_SIGNAL_PRESSED) {
 801eaea:	7afb      	ldrb	r3, [r7, #11]
 801eaec:	2b07      	cmp	r3, #7
 801eaee:	d176      	bne.n	801ebde <lv_btn_signal+0x136>
        /*Refresh the state*/
        if(ext->state == LV_BTN_STATE_REL) {
 801eaf0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801eaf2:	7f9b      	ldrb	r3, [r3, #30]
 801eaf4:	f003 0307 	and.w	r3, r3, #7
 801eaf8:	b2db      	uxtb	r3, r3
 801eafa:	2b00      	cmp	r3, #0
 801eafc:	d10a      	bne.n	801eb14 <lv_btn_signal+0x6c>
            lv_btn_set_state(btn, LV_BTN_STATE_PR);
 801eafe:	2101      	movs	r1, #1
 801eb00:	68f8      	ldr	r0, [r7, #12]
 801eb02:	f7ff fd99 	bl	801e638 <lv_btn_set_state>
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
            ink_bg_state  = LV_BTN_STATE_REL;
 801eb06:	4b95      	ldr	r3, [pc, #596]	; (801ed5c <lv_btn_signal+0x2b4>)
 801eb08:	2200      	movs	r2, #0
 801eb0a:	701a      	strb	r2, [r3, #0]
            ink_top_state = LV_BTN_STATE_PR;
 801eb0c:	4b94      	ldr	r3, [pc, #592]	; (801ed60 <lv_btn_signal+0x2b8>)
 801eb0e:	2201      	movs	r2, #1
 801eb10:	701a      	strb	r2, [r3, #0]
 801eb12:	e010      	b.n	801eb36 <lv_btn_signal+0x8e>
#endif
        } else if(ext->state == LV_BTN_STATE_TGL_REL) {
 801eb14:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801eb16:	7f9b      	ldrb	r3, [r3, #30]
 801eb18:	f003 0307 	and.w	r3, r3, #7
 801eb1c:	b2db      	uxtb	r3, r3
 801eb1e:	2b02      	cmp	r3, #2
 801eb20:	d109      	bne.n	801eb36 <lv_btn_signal+0x8e>
            lv_btn_set_state(btn, LV_BTN_STATE_TGL_PR);
 801eb22:	2103      	movs	r1, #3
 801eb24:	68f8      	ldr	r0, [r7, #12]
 801eb26:	f7ff fd87 	bl	801e638 <lv_btn_set_state>
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
            ink_bg_state  = LV_BTN_STATE_TGL_REL;
 801eb2a:	4b8c      	ldr	r3, [pc, #560]	; (801ed5c <lv_btn_signal+0x2b4>)
 801eb2c:	2202      	movs	r2, #2
 801eb2e:	701a      	strb	r2, [r3, #0]
            ink_top_state = LV_BTN_STATE_TGL_PR;
 801eb30:	4b8b      	ldr	r3, [pc, #556]	; (801ed60 <lv_btn_signal+0x2b8>)
 801eb32:	2203      	movs	r2, #3
 801eb34:	701a      	strb	r2, [r3, #0]
#endif
        }

#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
        /*Forget the old inked button*/
        if(ink_obj != NULL && ink_obj != btn) {
 801eb36:	4b8b      	ldr	r3, [pc, #556]	; (801ed64 <lv_btn_signal+0x2bc>)
 801eb38:	681b      	ldr	r3, [r3, #0]
 801eb3a:	2b00      	cmp	r3, #0
 801eb3c:	d012      	beq.n	801eb64 <lv_btn_signal+0xbc>
 801eb3e:	4b89      	ldr	r3, [pc, #548]	; (801ed64 <lv_btn_signal+0x2bc>)
 801eb40:	681b      	ldr	r3, [r3, #0]
 801eb42:	68fa      	ldr	r2, [r7, #12]
 801eb44:	429a      	cmp	r2, r3
 801eb46:	d00d      	beq.n	801eb64 <lv_btn_signal+0xbc>
            lv_anim_del(ink_obj, (lv_anim_exec_xcb_t)lv_btn_ink_effect_anim);
 801eb48:	4b86      	ldr	r3, [pc, #536]	; (801ed64 <lv_btn_signal+0x2bc>)
 801eb4a:	681b      	ldr	r3, [r3, #0]
 801eb4c:	4986      	ldr	r1, [pc, #536]	; (801ed68 <lv_btn_signal+0x2c0>)
 801eb4e:	4618      	mov	r0, r3
 801eb50:	f7fc fd46 	bl	801b5e0 <lv_anim_del>
            lv_obj_invalidate(ink_obj);
 801eb54:	4b83      	ldr	r3, [pc, #524]	; (801ed64 <lv_btn_signal+0x2bc>)
 801eb56:	681b      	ldr	r3, [r3, #0]
 801eb58:	4618      	mov	r0, r3
 801eb5a:	f7f2 f968 	bl	8010e2e <lv_obj_invalidate>
            ink_obj = NULL;
 801eb5e:	4b81      	ldr	r3, [pc, #516]	; (801ed64 <lv_btn_signal+0x2bc>)
 801eb60:	2200      	movs	r2, #0
 801eb62:	601a      	str	r2, [r3, #0]
        }
        /*Save the new data for inking and start it's animation if enabled*/
        if(ext->ink_in_time > 0) {
 801eb64:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801eb66:	8b1b      	ldrh	r3, [r3, #24]
 801eb68:	2b00      	cmp	r3, #0
 801eb6a:	f000 81ea 	beq.w	801ef42 <lv_btn_signal+0x49a>
            ink_obj      = btn;
 801eb6e:	4a7d      	ldr	r2, [pc, #500]	; (801ed64 <lv_btn_signal+0x2bc>)
 801eb70:	68fb      	ldr	r3, [r7, #12]
 801eb72:	6013      	str	r3, [r2, #0]
            ink_playback = false;
 801eb74:	4b7d      	ldr	r3, [pc, #500]	; (801ed6c <lv_btn_signal+0x2c4>)
 801eb76:	2200      	movs	r2, #0
 801eb78:	701a      	strb	r2, [r3, #0]
            ink_ready    = false;
 801eb7a:	4b7d      	ldr	r3, [pc, #500]	; (801ed70 <lv_btn_signal+0x2c8>)
 801eb7c:	2200      	movs	r2, #0
 801eb7e:	701a      	strb	r2, [r3, #0]
            lv_indev_get_point(lv_indev_get_act(), &ink_point);
 801eb80:	f7ef ffea 	bl	800eb58 <lv_indev_get_act>
 801eb84:	4603      	mov	r3, r0
 801eb86:	497b      	ldr	r1, [pc, #492]	; (801ed74 <lv_btn_signal+0x2cc>)
 801eb88:	4618      	mov	r0, r3
 801eb8a:	f7f0 f828 	bl	800ebde <lv_indev_get_point>

            lv_anim_t a;
            a.var            = btn;
 801eb8e:	68fb      	ldr	r3, [r7, #12]
 801eb90:	613b      	str	r3, [r7, #16]
            a.start          = 0;
 801eb92:	2300      	movs	r3, #0
 801eb94:	623b      	str	r3, [r7, #32]
            a.end            = LV_BTN_INK_VALUE_MAX;
 801eb96:	f44f 7380 	mov.w	r3, #256	; 0x100
 801eb9a:	627b      	str	r3, [r7, #36]	; 0x24
            a.exec_cb        = (lv_anim_exec_xcb_t)lv_btn_ink_effect_anim;
 801eb9c:	4b72      	ldr	r3, [pc, #456]	; (801ed68 <lv_btn_signal+0x2c0>)
 801eb9e:	617b      	str	r3, [r7, #20]
            a.path_cb        = lv_anim_path_linear;
 801eba0:	4b75      	ldr	r3, [pc, #468]	; (801ed78 <lv_btn_signal+0x2d0>)
 801eba2:	61bb      	str	r3, [r7, #24]
            a.ready_cb       = lv_btn_ink_effect_anim_ready;
 801eba4:	4b75      	ldr	r3, [pc, #468]	; (801ed7c <lv_btn_signal+0x2d4>)
 801eba6:	61fb      	str	r3, [r7, #28]
            a.act_time       = 0;
 801eba8:	2300      	movs	r3, #0
 801ebaa:	857b      	strh	r3, [r7, #42]	; 0x2a
            a.time           = ext->ink_in_time;
 801ebac:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ebae:	8b1b      	ldrh	r3, [r3, #24]
 801ebb0:	853b      	strh	r3, [r7, #40]	; 0x28
            a.playback       = 0;
 801ebb2:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801ebb6:	f36f 0300 	bfc	r3, #0, #1
 801ebba:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
            a.playback_pause = 0;
 801ebbe:	2300      	movs	r3, #0
 801ebc0:	85bb      	strh	r3, [r7, #44]	; 0x2c
            a.repeat         = 0;
 801ebc2:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801ebc6:	f36f 0341 	bfc	r3, #1, #1
 801ebca:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
            a.repeat_pause   = 0;
 801ebce:	2300      	movs	r3, #0
 801ebd0:	85fb      	strh	r3, [r7, #46]	; 0x2e
            lv_anim_create(&a);
 801ebd2:	f107 0310 	add.w	r3, r7, #16
 801ebd6:	4618      	mov	r0, r3
 801ebd8:	f7fc fcb8 	bl	801b54c <lv_anim_create>
 801ebdc:	e1b1      	b.n	801ef42 <lv_btn_signal+0x49a>
        }
#endif
    } else if(sign == LV_SIGNAL_PRESS_LOST) {
 801ebde:	7afb      	ldrb	r3, [r7, #11]
 801ebe0:	2b09      	cmp	r3, #9
 801ebe2:	d118      	bne.n	801ec16 <lv_btn_signal+0x16e>
        /*Refresh the state*/
        if(ext->state == LV_BTN_STATE_PR)
 801ebe4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ebe6:	7f9b      	ldrb	r3, [r3, #30]
 801ebe8:	f003 0307 	and.w	r3, r3, #7
 801ebec:	b2db      	uxtb	r3, r3
 801ebee:	2b01      	cmp	r3, #1
 801ebf0:	d104      	bne.n	801ebfc <lv_btn_signal+0x154>
            lv_btn_set_state(btn, LV_BTN_STATE_REL);
 801ebf2:	2100      	movs	r1, #0
 801ebf4:	68f8      	ldr	r0, [r7, #12]
 801ebf6:	f7ff fd1f 	bl	801e638 <lv_btn_set_state>
 801ebfa:	e1a2      	b.n	801ef42 <lv_btn_signal+0x49a>
        else if(ext->state == LV_BTN_STATE_TGL_PR)
 801ebfc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ebfe:	7f9b      	ldrb	r3, [r3, #30]
 801ec00:	f003 0307 	and.w	r3, r3, #7
 801ec04:	b2db      	uxtb	r3, r3
 801ec06:	2b03      	cmp	r3, #3
 801ec08:	f040 819b 	bne.w	801ef42 <lv_btn_signal+0x49a>
            lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 801ec0c:	2102      	movs	r1, #2
 801ec0e:	68f8      	ldr	r0, [r7, #12]
 801ec10:	f7ff fd12 	bl	801e638 <lv_btn_set_state>
 801ec14:	e195      	b.n	801ef42 <lv_btn_signal+0x49a>
    } else if(sign == LV_SIGNAL_PRESSING) {
 801ec16:	7afb      	ldrb	r3, [r7, #11]
 801ec18:	2b08      	cmp	r3, #8
 801ec1a:	d11f      	bne.n	801ec5c <lv_btn_signal+0x1b4>
        /*When the button begins to drag revert pressed states to released*/
        if(lv_indev_is_dragging(param) != false) {
 801ec1c:	6878      	ldr	r0, [r7, #4]
 801ec1e:	f7f0 f804 	bl	800ec2a <lv_indev_is_dragging>
 801ec22:	4603      	mov	r3, r0
 801ec24:	2b00      	cmp	r3, #0
 801ec26:	f000 818c 	beq.w	801ef42 <lv_btn_signal+0x49a>
            if(ext->state == LV_BTN_STATE_PR)
 801ec2a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ec2c:	7f9b      	ldrb	r3, [r3, #30]
 801ec2e:	f003 0307 	and.w	r3, r3, #7
 801ec32:	b2db      	uxtb	r3, r3
 801ec34:	2b01      	cmp	r3, #1
 801ec36:	d104      	bne.n	801ec42 <lv_btn_signal+0x19a>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 801ec38:	2100      	movs	r1, #0
 801ec3a:	68f8      	ldr	r0, [r7, #12]
 801ec3c:	f7ff fcfc 	bl	801e638 <lv_btn_set_state>
 801ec40:	e17f      	b.n	801ef42 <lv_btn_signal+0x49a>
            else if(ext->state == LV_BTN_STATE_TGL_PR)
 801ec42:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ec44:	7f9b      	ldrb	r3, [r3, #30]
 801ec46:	f003 0307 	and.w	r3, r3, #7
 801ec4a:	b2db      	uxtb	r3, r3
 801ec4c:	2b03      	cmp	r3, #3
 801ec4e:	f040 8178 	bne.w	801ef42 <lv_btn_signal+0x49a>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 801ec52:	2102      	movs	r1, #2
 801ec54:	68f8      	ldr	r0, [r7, #12]
 801ec56:	f7ff fcef 	bl	801e638 <lv_btn_set_state>
 801ec5a:	e172      	b.n	801ef42 <lv_btn_signal+0x49a>
        }
    } else if(sign == LV_SIGNAL_RELEASED) {
 801ec5c:	7afb      	ldrb	r3, [r7, #11]
 801ec5e:	2b0a      	cmp	r3, #10
 801ec60:	f040 80e9 	bne.w	801ee36 <lv_btn_signal+0x38e>
        /*If not dragged and it was not long press action then
         *change state and run the action*/
        if(lv_indev_is_dragging(param) == false) {
 801ec64:	6878      	ldr	r0, [r7, #4]
 801ec66:	f7ef ffe0 	bl	800ec2a <lv_indev_is_dragging>
 801ec6a:	4603      	mov	r3, r0
 801ec6c:	f083 0301 	eor.w	r3, r3, #1
 801ec70:	b2db      	uxtb	r3, r3
 801ec72:	2b00      	cmp	r3, #0
 801ec74:	d063      	beq.n	801ed3e <lv_btn_signal+0x296>
            uint32_t toggled = 0;
 801ec76:	2300      	movs	r3, #0
 801ec78:	643b      	str	r3, [r7, #64]	; 0x40
            if(ext->state == LV_BTN_STATE_PR && tgl == false) {
 801ec7a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ec7c:	7f9b      	ldrb	r3, [r3, #30]
 801ec7e:	f003 0307 	and.w	r3, r3, #7
 801ec82:	b2db      	uxtb	r3, r3
 801ec84:	2b01      	cmp	r3, #1
 801ec86:	d10d      	bne.n	801eca4 <lv_btn_signal+0x1fc>
 801ec88:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801ec8c:	f083 0301 	eor.w	r3, r3, #1
 801ec90:	b2db      	uxtb	r3, r3
 801ec92:	2b00      	cmp	r3, #0
 801ec94:	d006      	beq.n	801eca4 <lv_btn_signal+0x1fc>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 801ec96:	2100      	movs	r1, #0
 801ec98:	68f8      	ldr	r0, [r7, #12]
 801ec9a:	f7ff fccd 	bl	801e638 <lv_btn_set_state>
                toggled = 0;
 801ec9e:	2300      	movs	r3, #0
 801eca0:	643b      	str	r3, [r7, #64]	; 0x40
 801eca2:	e037      	b.n	801ed14 <lv_btn_signal+0x26c>
            } else if(ext->state == LV_BTN_STATE_TGL_PR && tgl == false) {
 801eca4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801eca6:	7f9b      	ldrb	r3, [r3, #30]
 801eca8:	f003 0307 	and.w	r3, r3, #7
 801ecac:	b2db      	uxtb	r3, r3
 801ecae:	2b03      	cmp	r3, #3
 801ecb0:	d10d      	bne.n	801ecce <lv_btn_signal+0x226>
 801ecb2:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801ecb6:	f083 0301 	eor.w	r3, r3, #1
 801ecba:	b2db      	uxtb	r3, r3
 801ecbc:	2b00      	cmp	r3, #0
 801ecbe:	d006      	beq.n	801ecce <lv_btn_signal+0x226>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 801ecc0:	2102      	movs	r1, #2
 801ecc2:	68f8      	ldr	r0, [r7, #12]
 801ecc4:	f7ff fcb8 	bl	801e638 <lv_btn_set_state>
                toggled = 1;
 801ecc8:	2301      	movs	r3, #1
 801ecca:	643b      	str	r3, [r7, #64]	; 0x40
 801eccc:	e022      	b.n	801ed14 <lv_btn_signal+0x26c>
            } else if(ext->state == LV_BTN_STATE_PR && tgl == true) {
 801ecce:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ecd0:	7f9b      	ldrb	r3, [r3, #30]
 801ecd2:	f003 0307 	and.w	r3, r3, #7
 801ecd6:	b2db      	uxtb	r3, r3
 801ecd8:	2b01      	cmp	r3, #1
 801ecda:	d10a      	bne.n	801ecf2 <lv_btn_signal+0x24a>
 801ecdc:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801ece0:	2b00      	cmp	r3, #0
 801ece2:	d006      	beq.n	801ecf2 <lv_btn_signal+0x24a>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 801ece4:	2102      	movs	r1, #2
 801ece6:	68f8      	ldr	r0, [r7, #12]
 801ece8:	f7ff fca6 	bl	801e638 <lv_btn_set_state>
                toggled = 1;
 801ecec:	2301      	movs	r3, #1
 801ecee:	643b      	str	r3, [r7, #64]	; 0x40
 801ecf0:	e010      	b.n	801ed14 <lv_btn_signal+0x26c>
            } else if(ext->state == LV_BTN_STATE_TGL_PR && tgl == true) {
 801ecf2:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ecf4:	7f9b      	ldrb	r3, [r3, #30]
 801ecf6:	f003 0307 	and.w	r3, r3, #7
 801ecfa:	b2db      	uxtb	r3, r3
 801ecfc:	2b03      	cmp	r3, #3
 801ecfe:	d109      	bne.n	801ed14 <lv_btn_signal+0x26c>
 801ed00:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801ed04:	2b00      	cmp	r3, #0
 801ed06:	d005      	beq.n	801ed14 <lv_btn_signal+0x26c>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 801ed08:	2100      	movs	r1, #0
 801ed0a:	68f8      	ldr	r0, [r7, #12]
 801ed0c:	f7ff fc94 	bl	801e638 <lv_btn_set_state>
                toggled = 0;
 801ed10:	2300      	movs	r3, #0
 801ed12:	643b      	str	r3, [r7, #64]	; 0x40
            }

            if(tgl) {
 801ed14:	f897 304f 	ldrb.w	r3, [r7, #79]	; 0x4f
 801ed18:	2b00      	cmp	r3, #0
 801ed1a:	d03c      	beq.n	801ed96 <lv_btn_signal+0x2ee>
                res = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &toggled);
 801ed1c:	f107 0340 	add.w	r3, r7, #64	; 0x40
 801ed20:	461a      	mov	r2, r3
 801ed22:	210e      	movs	r1, #14
 801ed24:	68f8      	ldr	r0, [r7, #12]
 801ed26:	f7f3 f89a 	bl	8011e5e <lv_event_send>
 801ed2a:	4603      	mov	r3, r0
 801ed2c:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(res != LV_RES_OK) return res;
 801ed30:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801ed34:	2b01      	cmp	r3, #1
 801ed36:	d02e      	beq.n	801ed96 <lv_btn_signal+0x2ee>
 801ed38:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801ed3c:	e103      	b.n	801ef46 <lv_btn_signal+0x49e>
            }

        } else { /*If dragged change back the state*/
            if(ext->state == LV_BTN_STATE_PR) {
 801ed3e:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ed40:	7f9b      	ldrb	r3, [r3, #30]
 801ed42:	f003 0307 	and.w	r3, r3, #7
 801ed46:	b2db      	uxtb	r3, r3
 801ed48:	2b01      	cmp	r3, #1
 801ed4a:	d119      	bne.n	801ed80 <lv_btn_signal+0x2d8>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 801ed4c:	2100      	movs	r1, #0
 801ed4e:	68f8      	ldr	r0, [r7, #12]
 801ed50:	f7ff fc72 	bl	801e638 <lv_btn_set_state>
 801ed54:	e01f      	b.n	801ed96 <lv_btn_signal+0x2ee>
 801ed56:	bf00      	nop
 801ed58:	2000c3b4 	.word	0x2000c3b4
 801ed5c:	2000c3c4 	.word	0x2000c3c4
 801ed60:	2000c3c5 	.word	0x2000c3c5
 801ed64:	2000c3c0 	.word	0x2000c3c0
 801ed68:	0801ef75 	.word	0x0801ef75
 801ed6c:	2000c3c7 	.word	0x2000c3c7
 801ed70:	2000c3c6 	.word	0x2000c3c6
 801ed74:	2000c3c8 	.word	0x2000c3c8
 801ed78:	0801b6b1 	.word	0x0801b6b1
 801ed7c:	0801efa1 	.word	0x0801efa1
            } else if(ext->state == LV_BTN_STATE_TGL_PR) {
 801ed80:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ed82:	7f9b      	ldrb	r3, [r3, #30]
 801ed84:	f003 0307 	and.w	r3, r3, #7
 801ed88:	b2db      	uxtb	r3, r3
 801ed8a:	2b03      	cmp	r3, #3
 801ed8c:	d103      	bne.n	801ed96 <lv_btn_signal+0x2ee>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 801ed8e:	2102      	movs	r1, #2
 801ed90:	68f8      	ldr	r0, [r7, #12]
 801ed92:	f7ff fc51 	bl	801e638 <lv_btn_set_state>
            }
        }

#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
        /*Draw the toggled state in the inking instead*/
        if(ext->toggle) {
 801ed96:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ed98:	7f9b      	ldrb	r3, [r3, #30]
 801ed9a:	f003 0308 	and.w	r3, r3, #8
 801ed9e:	b2db      	uxtb	r3, r3
 801eda0:	2b00      	cmp	r3, #0
 801eda2:	d008      	beq.n	801edb6 <lv_btn_signal+0x30e>
            ink_top_state = ext->state;
 801eda4:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801eda6:	7f9b      	ldrb	r3, [r3, #30]
 801eda8:	f3c3 0302 	ubfx	r3, r3, #0, #3
 801edac:	b2db      	uxtb	r3, r3
 801edae:	461a      	mov	r2, r3
 801edb0:	4b67      	ldr	r3, [pc, #412]	; (801ef50 <lv_btn_signal+0x4a8>)
 801edb2:	701a      	strb	r2, [r3, #0]
 801edb4:	e0c5      	b.n	801ef42 <lv_btn_signal+0x49a>
        }
        /*If not a toggle button and the "IN" inking is ready then start an "OUT" inking*/
        else if(ink_ready && ext->ink_out_time > 0) {
 801edb6:	4b67      	ldr	r3, [pc, #412]	; (801ef54 <lv_btn_signal+0x4ac>)
 801edb8:	781b      	ldrb	r3, [r3, #0]
 801edba:	2b00      	cmp	r3, #0
 801edbc:	f000 80c1 	beq.w	801ef42 <lv_btn_signal+0x49a>
 801edc0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801edc2:	8b9b      	ldrh	r3, [r3, #28]
 801edc4:	2b00      	cmp	r3, #0
 801edc6:	f000 80bc 	beq.w	801ef42 <lv_btn_signal+0x49a>
            ink_obj      = btn;
 801edca:	4a63      	ldr	r2, [pc, #396]	; (801ef58 <lv_btn_signal+0x4b0>)
 801edcc:	68fb      	ldr	r3, [r7, #12]
 801edce:	6013      	str	r3, [r2, #0]
            ink_playback = true; /*It is the playback. If not set `lv_btn_ink_effect_anim_ready`
 801edd0:	4b62      	ldr	r3, [pc, #392]	; (801ef5c <lv_btn_signal+0x4b4>)
 801edd2:	2201      	movs	r2, #1
 801edd4:	701a      	strb	r2, [r3, #0]
                                    will start its own playback*/
            lv_indev_get_point(lv_indev_get_act(), &ink_point);
 801edd6:	f7ef febf 	bl	800eb58 <lv_indev_get_act>
 801edda:	4603      	mov	r3, r0
 801eddc:	4960      	ldr	r1, [pc, #384]	; (801ef60 <lv_btn_signal+0x4b8>)
 801edde:	4618      	mov	r0, r3
 801ede0:	f7ef fefd 	bl	800ebde <lv_indev_get_point>

            lv_anim_t a;
            a.var            = ink_obj;
 801ede4:	4b5c      	ldr	r3, [pc, #368]	; (801ef58 <lv_btn_signal+0x4b0>)
 801ede6:	681b      	ldr	r3, [r3, #0]
 801ede8:	613b      	str	r3, [r7, #16]
            a.start          = LV_BTN_INK_VALUE_MAX;
 801edea:	f44f 7380 	mov.w	r3, #256	; 0x100
 801edee:	623b      	str	r3, [r7, #32]
            a.end            = 0;
 801edf0:	2300      	movs	r3, #0
 801edf2:	627b      	str	r3, [r7, #36]	; 0x24
            a.exec_cb        = (lv_anim_exec_xcb_t)lv_btn_ink_effect_anim;
 801edf4:	4b5b      	ldr	r3, [pc, #364]	; (801ef64 <lv_btn_signal+0x4bc>)
 801edf6:	617b      	str	r3, [r7, #20]
            a.path_cb        = lv_anim_path_linear;
 801edf8:	4b5b      	ldr	r3, [pc, #364]	; (801ef68 <lv_btn_signal+0x4c0>)
 801edfa:	61bb      	str	r3, [r7, #24]
            a.ready_cb       = lv_btn_ink_effect_anim_ready;
 801edfc:	4b5b      	ldr	r3, [pc, #364]	; (801ef6c <lv_btn_signal+0x4c4>)
 801edfe:	61fb      	str	r3, [r7, #28]
            a.act_time       = 0;
 801ee00:	2300      	movs	r3, #0
 801ee02:	857b      	strh	r3, [r7, #42]	; 0x2a
            a.time           = ext->ink_out_time;
 801ee04:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 801ee06:	8b9b      	ldrh	r3, [r3, #28]
 801ee08:	853b      	strh	r3, [r7, #40]	; 0x28
            a.playback       = 0;
 801ee0a:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801ee0e:	f36f 0300 	bfc	r3, #0, #1
 801ee12:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
            a.playback_pause = 0;
 801ee16:	2300      	movs	r3, #0
 801ee18:	85bb      	strh	r3, [r7, #44]	; 0x2c
            a.repeat         = 0;
 801ee1a:	f897 3034 	ldrb.w	r3, [r7, #52]	; 0x34
 801ee1e:	f36f 0341 	bfc	r3, #1, #1
 801ee22:	f887 3034 	strb.w	r3, [r7, #52]	; 0x34
            a.repeat_pause   = 0;
 801ee26:	2300      	movs	r3, #0
 801ee28:	85fb      	strh	r3, [r7, #46]	; 0x2e
            lv_anim_create(&a);
 801ee2a:	f107 0310 	add.w	r3, r7, #16
 801ee2e:	4618      	mov	r0, r3
 801ee30:	f7fc fb8c 	bl	801b54c <lv_anim_create>
 801ee34:	e085      	b.n	801ef42 <lv_btn_signal+0x49a>
        }
#endif
    } else if(sign == LV_SIGNAL_CONTROL) {
 801ee36:	7afb      	ldrb	r3, [r7, #11]
 801ee38:	2b11      	cmp	r3, #17
 801ee3a:	d14d      	bne.n	801eed8 <lv_btn_signal+0x430>
        char c = *((char *)param);
 801ee3c:	687b      	ldr	r3, [r7, #4]
 801ee3e:	781b      	ldrb	r3, [r3, #0]
 801ee40:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {
 801ee44:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ee48:	2b13      	cmp	r3, #19
 801ee4a:	d003      	beq.n	801ee54 <lv_btn_signal+0x3ac>
 801ee4c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ee50:	2b11      	cmp	r3, #17
 801ee52:	d11c      	bne.n	801ee8e <lv_btn_signal+0x3e6>
            if(lv_btn_get_toggle(btn)) {
 801ee54:	68f8      	ldr	r0, [r7, #12]
 801ee56:	f7ff fc6c 	bl	801e732 <lv_btn_get_toggle>
 801ee5a:	4603      	mov	r3, r0
 801ee5c:	2b00      	cmp	r3, #0
 801ee5e:	d06f      	beq.n	801ef40 <lv_btn_signal+0x498>
                lv_btn_set_state(btn, LV_BTN_STATE_TGL_REL);
 801ee60:	2102      	movs	r1, #2
 801ee62:	68f8      	ldr	r0, [r7, #12]
 801ee64:	f7ff fbe8 	bl	801e638 <lv_btn_set_state>

                uint32_t state = 1;
 801ee68:	2301      	movs	r3, #1
 801ee6a:	63fb      	str	r3, [r7, #60]	; 0x3c
                res            = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &state);
 801ee6c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 801ee70:	461a      	mov	r2, r3
 801ee72:	210e      	movs	r1, #14
 801ee74:	68f8      	ldr	r0, [r7, #12]
 801ee76:	f7f2 fff2 	bl	8011e5e <lv_event_send>
 801ee7a:	4603      	mov	r3, r0
 801ee7c:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(res != LV_RES_OK) return res;
 801ee80:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801ee84:	2b01      	cmp	r3, #1
 801ee86:	d05b      	beq.n	801ef40 <lv_btn_signal+0x498>
 801ee88:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801ee8c:	e05b      	b.n	801ef46 <lv_btn_signal+0x49e>
            }

        } else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {
 801ee8e:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ee92:	2b14      	cmp	r3, #20
 801ee94:	d003      	beq.n	801ee9e <lv_btn_signal+0x3f6>
 801ee96:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 801ee9a:	2b12      	cmp	r3, #18
 801ee9c:	d151      	bne.n	801ef42 <lv_btn_signal+0x49a>
            if(lv_btn_get_toggle(btn)) {
 801ee9e:	68f8      	ldr	r0, [r7, #12]
 801eea0:	f7ff fc47 	bl	801e732 <lv_btn_get_toggle>
 801eea4:	4603      	mov	r3, r0
 801eea6:	2b00      	cmp	r3, #0
 801eea8:	d04b      	beq.n	801ef42 <lv_btn_signal+0x49a>
                lv_btn_set_state(btn, LV_BTN_STATE_REL);
 801eeaa:	2100      	movs	r1, #0
 801eeac:	68f8      	ldr	r0, [r7, #12]
 801eeae:	f7ff fbc3 	bl	801e638 <lv_btn_set_state>

                uint32_t state = 0;
 801eeb2:	2300      	movs	r3, #0
 801eeb4:	63bb      	str	r3, [r7, #56]	; 0x38
                res            = lv_event_send(btn, LV_EVENT_VALUE_CHANGED, &state);
 801eeb6:	f107 0338 	add.w	r3, r7, #56	; 0x38
 801eeba:	461a      	mov	r2, r3
 801eebc:	210e      	movs	r1, #14
 801eebe:	68f8      	ldr	r0, [r7, #12]
 801eec0:	f7f2 ffcd 	bl	8011e5e <lv_event_send>
 801eec4:	4603      	mov	r3, r0
 801eec6:	f887 3057 	strb.w	r3, [r7, #87]	; 0x57
                if(res != LV_RES_OK) return res;
 801eeca:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801eece:	2b01      	cmp	r3, #1
 801eed0:	d037      	beq.n	801ef42 <lv_btn_signal+0x49a>
 801eed2:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
 801eed6:	e036      	b.n	801ef46 <lv_btn_signal+0x49e>
            }
        }
    } else if(sign == LV_SIGNAL_CLEANUP) {
 801eed8:	7afb      	ldrb	r3, [r7, #11]
 801eeda:	2b00      	cmp	r3, #0
 801eedc:	d10e      	bne.n	801eefc <lv_btn_signal+0x454>
#if LV_USE_ANIMATION && LV_BTN_INK_EFFECT
        if(btn == ink_obj) {
 801eede:	4b1e      	ldr	r3, [pc, #120]	; (801ef58 <lv_btn_signal+0x4b0>)
 801eee0:	681b      	ldr	r3, [r3, #0]
 801eee2:	68fa      	ldr	r2, [r7, #12]
 801eee4:	429a      	cmp	r2, r3
 801eee6:	d12c      	bne.n	801ef42 <lv_btn_signal+0x49a>
            lv_anim_del(ink_obj, (lv_anim_exec_xcb_t)lv_btn_ink_effect_anim);
 801eee8:	4b1b      	ldr	r3, [pc, #108]	; (801ef58 <lv_btn_signal+0x4b0>)
 801eeea:	681b      	ldr	r3, [r3, #0]
 801eeec:	491d      	ldr	r1, [pc, #116]	; (801ef64 <lv_btn_signal+0x4bc>)
 801eeee:	4618      	mov	r0, r3
 801eef0:	f7fc fb76 	bl	801b5e0 <lv_anim_del>
            ink_obj = NULL;
 801eef4:	4b18      	ldr	r3, [pc, #96]	; (801ef58 <lv_btn_signal+0x4b0>)
 801eef6:	2200      	movs	r2, #0
 801eef8:	601a      	str	r2, [r3, #0]
 801eefa:	e022      	b.n	801ef42 <lv_btn_signal+0x49a>
        }
#endif
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 801eefc:	7afb      	ldrb	r3, [r7, #11]
 801eefe:	2b06      	cmp	r3, #6
 801ef00:	d11f      	bne.n	801ef42 <lv_btn_signal+0x49a>
        lv_obj_type_t * buf = param;
 801ef02:	687b      	ldr	r3, [r7, #4]
 801ef04:	64bb      	str	r3, [r7, #72]	; 0x48
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801ef06:	2300      	movs	r3, #0
 801ef08:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
 801ef0c:	e00b      	b.n	801ef26 <lv_btn_signal+0x47e>
            if(buf->type[i] == NULL) break;
 801ef0e:	f897 2056 	ldrb.w	r2, [r7, #86]	; 0x56
 801ef12:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ef14:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801ef18:	2b00      	cmp	r3, #0
 801ef1a:	d009      	beq.n	801ef30 <lv_btn_signal+0x488>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801ef1c:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 801ef20:	3301      	adds	r3, #1
 801ef22:	f887 3056 	strb.w	r3, [r7, #86]	; 0x56
 801ef26:	f897 3056 	ldrb.w	r3, [r7, #86]	; 0x56
 801ef2a:	2b06      	cmp	r3, #6
 801ef2c:	d9ef      	bls.n	801ef0e <lv_btn_signal+0x466>
 801ef2e:	e000      	b.n	801ef32 <lv_btn_signal+0x48a>
            if(buf->type[i] == NULL) break;
 801ef30:	bf00      	nop
        }
        buf->type[i] = "lv_btn";
 801ef32:	f897 2056 	ldrb.w	r2, [r7, #86]	; 0x56
 801ef36:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 801ef38:	490d      	ldr	r1, [pc, #52]	; (801ef70 <lv_btn_signal+0x4c8>)
 801ef3a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 801ef3e:	e000      	b.n	801ef42 <lv_btn_signal+0x49a>
            if(lv_btn_get_toggle(btn)) {
 801ef40:	bf00      	nop
    }

    return res;
 801ef42:	f897 3057 	ldrb.w	r3, [r7, #87]	; 0x57
}
 801ef46:	4618      	mov	r0, r3
 801ef48:	3758      	adds	r7, #88	; 0x58
 801ef4a:	46bd      	mov	sp, r7
 801ef4c:	bd80      	pop	{r7, pc}
 801ef4e:	bf00      	nop
 801ef50:	2000c3c5 	.word	0x2000c3c5
 801ef54:	2000c3c6 	.word	0x2000c3c6
 801ef58:	2000c3c0 	.word	0x2000c3c0
 801ef5c:	2000c3c7 	.word	0x2000c3c7
 801ef60:	2000c3c8 	.word	0x2000c3c8
 801ef64:	0801ef75 	.word	0x0801ef75
 801ef68:	0801b6b1 	.word	0x0801b6b1
 801ef6c:	0801efa1 	.word	0x0801efa1
 801ef70:	08028f80 	.word	0x08028f80

0801ef74 <lv_btn_ink_effect_anim>:
 * The animator function of inking. CAlled to increase the radius of ink
 * @param btn pointer to the animated button
 * @param val the new radius
 */
static void lv_btn_ink_effect_anim(lv_obj_t * btn, lv_anim_value_t val)
{
 801ef74:	b580      	push	{r7, lr}
 801ef76:	b082      	sub	sp, #8
 801ef78:	af00      	add	r7, sp, #0
 801ef7a:	6078      	str	r0, [r7, #4]
 801ef7c:	460b      	mov	r3, r1
 801ef7e:	807b      	strh	r3, [r7, #2]
    if(btn) {
 801ef80:	687b      	ldr	r3, [r7, #4]
 801ef82:	2b00      	cmp	r3, #0
 801ef84:	d005      	beq.n	801ef92 <lv_btn_ink_effect_anim+0x1e>
        ink_act_value = val;
 801ef86:	4a05      	ldr	r2, [pc, #20]	; (801ef9c <lv_btn_ink_effect_anim+0x28>)
 801ef88:	887b      	ldrh	r3, [r7, #2]
 801ef8a:	8013      	strh	r3, [r2, #0]
        lv_obj_invalidate(btn);
 801ef8c:	6878      	ldr	r0, [r7, #4]
 801ef8e:	f7f1 ff4e 	bl	8010e2e <lv_obj_invalidate>
    }
}
 801ef92:	bf00      	nop
 801ef94:	3708      	adds	r7, #8
 801ef96:	46bd      	mov	sp, r7
 801ef98:	bd80      	pop	{r7, pc}
 801ef9a:	bf00      	nop
 801ef9c:	2000c3bc 	.word	0x2000c3bc

0801efa0 <lv_btn_ink_effect_anim_ready>:
/**
 * Called to clean up when the ink animation is ready
 * @param a unused
 */
static void lv_btn_ink_effect_anim_ready(lv_anim_t * a)
{
 801efa0:	b580      	push	{r7, lr}
 801efa2:	b08e      	sub	sp, #56	; 0x38
 801efa4:	af00      	add	r7, sp, #0
 801efa6:	6078      	str	r0, [r7, #4]
    (void)a; /*Unused*/

    lv_btn_ext_t * ext   = lv_obj_get_ext_attr(ink_obj);
 801efa8:	4b31      	ldr	r3, [pc, #196]	; (801f070 <lv_btn_ink_effect_anim_ready+0xd0>)
 801efaa:	681b      	ldr	r3, [r3, #0]
 801efac:	4618      	mov	r0, r3
 801efae:	f7f3 fa40 	bl	8012432 <lv_obj_get_ext_attr>
 801efb2:	6378      	str	r0, [r7, #52]	; 0x34
    lv_btn_state_t state = lv_btn_get_state(ink_obj);
 801efb4:	4b2e      	ldr	r3, [pc, #184]	; (801f070 <lv_btn_ink_effect_anim_ready+0xd0>)
 801efb6:	681b      	ldr	r3, [r3, #0]
 801efb8:	4618      	mov	r0, r3
 801efba:	f7ff fba9 	bl	801e710 <lv_btn_get_state>
 801efbe:	4603      	mov	r3, r0
 801efc0:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    lv_obj_invalidate(ink_obj);
 801efc4:	4b2a      	ldr	r3, [pc, #168]	; (801f070 <lv_btn_ink_effect_anim_ready+0xd0>)
 801efc6:	681b      	ldr	r3, [r3, #0]
 801efc8:	4618      	mov	r0, r3
 801efca:	f7f1 ff30 	bl	8010e2e <lv_obj_invalidate>
    ink_ready = true;
 801efce:	4b29      	ldr	r3, [pc, #164]	; (801f074 <lv_btn_ink_effect_anim_ready+0xd4>)
 801efd0:	2201      	movs	r2, #1
 801efd2:	701a      	strb	r2, [r3, #0]

    if((state == LV_BTN_STATE_REL || state == LV_BTN_STATE_TGL_REL) && ext->toggle == 0 && ink_playback == false) {
 801efd4:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801efd8:	2b00      	cmp	r3, #0
 801efda:	d003      	beq.n	801efe4 <lv_btn_ink_effect_anim_ready+0x44>
 801efdc:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 801efe0:	2b02      	cmp	r3, #2
 801efe2:	d13d      	bne.n	801f060 <lv_btn_ink_effect_anim_ready+0xc0>
 801efe4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801efe6:	7f9b      	ldrb	r3, [r3, #30]
 801efe8:	f003 0308 	and.w	r3, r3, #8
 801efec:	b2db      	uxtb	r3, r3
 801efee:	2b00      	cmp	r3, #0
 801eff0:	d136      	bne.n	801f060 <lv_btn_ink_effect_anim_ready+0xc0>
 801eff2:	4b21      	ldr	r3, [pc, #132]	; (801f078 <lv_btn_ink_effect_anim_ready+0xd8>)
 801eff4:	781b      	ldrb	r3, [r3, #0]
 801eff6:	f083 0301 	eor.w	r3, r3, #1
 801effa:	b2db      	uxtb	r3, r3
 801effc:	2b00      	cmp	r3, #0
 801effe:	d02f      	beq.n	801f060 <lv_btn_ink_effect_anim_ready+0xc0>
        lv_anim_t new_a;
        new_a.var            = ink_obj;
 801f000:	4b1b      	ldr	r3, [pc, #108]	; (801f070 <lv_btn_ink_effect_anim_ready+0xd0>)
 801f002:	681b      	ldr	r3, [r3, #0]
 801f004:	60bb      	str	r3, [r7, #8]
        new_a.start          = LV_BTN_INK_VALUE_MAX;
 801f006:	f44f 7380 	mov.w	r3, #256	; 0x100
 801f00a:	61bb      	str	r3, [r7, #24]
        new_a.end            = 0;
 801f00c:	2300      	movs	r3, #0
 801f00e:	61fb      	str	r3, [r7, #28]
        new_a.exec_cb        = (lv_anim_exec_xcb_t)lv_btn_ink_effect_anim;
 801f010:	4b1a      	ldr	r3, [pc, #104]	; (801f07c <lv_btn_ink_effect_anim_ready+0xdc>)
 801f012:	60fb      	str	r3, [r7, #12]
        new_a.path_cb        = lv_anim_path_linear;
 801f014:	4b1a      	ldr	r3, [pc, #104]	; (801f080 <lv_btn_ink_effect_anim_ready+0xe0>)
 801f016:	613b      	str	r3, [r7, #16]
        new_a.ready_cb       = lv_btn_ink_effect_anim_ready;
 801f018:	4b1a      	ldr	r3, [pc, #104]	; (801f084 <lv_btn_ink_effect_anim_ready+0xe4>)
 801f01a:	617b      	str	r3, [r7, #20]
        new_a.act_time       = -ext->ink_wait_time;
 801f01c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801f01e:	8b5b      	ldrh	r3, [r3, #26]
 801f020:	425b      	negs	r3, r3
 801f022:	b29b      	uxth	r3, r3
 801f024:	b21b      	sxth	r3, r3
 801f026:	847b      	strh	r3, [r7, #34]	; 0x22
        new_a.time           = ext->ink_out_time;
 801f028:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801f02a:	8b9b      	ldrh	r3, [r3, #28]
 801f02c:	843b      	strh	r3, [r7, #32]
        new_a.playback       = 0;
 801f02e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801f032:	f36f 0300 	bfc	r3, #0, #1
 801f036:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        new_a.playback_pause = 0;
 801f03a:	2300      	movs	r3, #0
 801f03c:	84bb      	strh	r3, [r7, #36]	; 0x24
        new_a.repeat         = 0;
 801f03e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 801f042:	f36f 0341 	bfc	r3, #1, #1
 801f046:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        new_a.repeat_pause   = 0;
 801f04a:	2300      	movs	r3, #0
 801f04c:	84fb      	strh	r3, [r7, #38]	; 0x26
        lv_anim_create(&new_a);
 801f04e:	f107 0308 	add.w	r3, r7, #8
 801f052:	4618      	mov	r0, r3
 801f054:	f7fc fa7a 	bl	801b54c <lv_anim_create>

        ink_playback = true;
 801f058:	4b07      	ldr	r3, [pc, #28]	; (801f078 <lv_btn_ink_effect_anim_ready+0xd8>)
 801f05a:	2201      	movs	r2, #1
 801f05c:	701a      	strb	r2, [r3, #0]
    if((state == LV_BTN_STATE_REL || state == LV_BTN_STATE_TGL_REL) && ext->toggle == 0 && ink_playback == false) {
 801f05e:	e002      	b.n	801f066 <lv_btn_ink_effect_anim_ready+0xc6>
    } else {
        ink_obj = NULL;
 801f060:	4b03      	ldr	r3, [pc, #12]	; (801f070 <lv_btn_ink_effect_anim_ready+0xd0>)
 801f062:	2200      	movs	r2, #0
 801f064:	601a      	str	r2, [r3, #0]
    }
}
 801f066:	bf00      	nop
 801f068:	3738      	adds	r7, #56	; 0x38
 801f06a:	46bd      	mov	sp, r7
 801f06c:	bd80      	pop	{r7, pc}
 801f06e:	bf00      	nop
 801f070:	2000c3c0 	.word	0x2000c3c0
 801f074:	2000c3c6 	.word	0x2000c3c6
 801f078:	2000c3c7 	.word	0x2000c3c7
 801f07c:	0801ef75 	.word	0x0801ef75
 801f080:	0801b6b1 	.word	0x0801b6b1
 801f084:	0801efa1 	.word	0x0801efa1

0801f088 <lv_area_copy>:
{
 801f088:	b580      	push	{r7, lr}
 801f08a:	b082      	sub	sp, #8
 801f08c:	af00      	add	r7, sp, #0
 801f08e:	6078      	str	r0, [r7, #4]
 801f090:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 801f092:	2208      	movs	r2, #8
 801f094:	6839      	ldr	r1, [r7, #0]
 801f096:	6878      	ldr	r0, [r7, #4]
 801f098:	f008 f890 	bl	80271bc <memcpy>
}
 801f09c:	bf00      	nop
 801f09e:	3708      	adds	r7, #8
 801f0a0:	46bd      	mov	sp, r7
 801f0a2:	bd80      	pop	{r7, pc}

0801f0a4 <lv_area_get_width>:
{
 801f0a4:	b480      	push	{r7}
 801f0a6:	b083      	sub	sp, #12
 801f0a8:	af00      	add	r7, sp, #0
 801f0aa:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 801f0ac:	687b      	ldr	r3, [r7, #4]
 801f0ae:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 801f0b2:	b29a      	uxth	r2, r3
 801f0b4:	687b      	ldr	r3, [r7, #4]
 801f0b6:	f9b3 3000 	ldrsh.w	r3, [r3]
 801f0ba:	b29b      	uxth	r3, r3
 801f0bc:	1ad3      	subs	r3, r2, r3
 801f0be:	b29b      	uxth	r3, r3
 801f0c0:	3301      	adds	r3, #1
 801f0c2:	b29b      	uxth	r3, r3
 801f0c4:	b21b      	sxth	r3, r3
}
 801f0c6:	4618      	mov	r0, r3
 801f0c8:	370c      	adds	r7, #12
 801f0ca:	46bd      	mov	sp, r7
 801f0cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f0d0:	4770      	bx	lr

0801f0d2 <lv_area_get_height>:
{
 801f0d2:	b480      	push	{r7}
 801f0d4:	b083      	sub	sp, #12
 801f0d6:	af00      	add	r7, sp, #0
 801f0d8:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 801f0da:	687b      	ldr	r3, [r7, #4]
 801f0dc:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 801f0e0:	b29a      	uxth	r2, r3
 801f0e2:	687b      	ldr	r3, [r7, #4]
 801f0e4:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 801f0e8:	b29b      	uxth	r3, r3
 801f0ea:	1ad3      	subs	r3, r2, r3
 801f0ec:	b29b      	uxth	r3, r3
 801f0ee:	3301      	adds	r3, #1
 801f0f0:	b29b      	uxth	r3, r3
 801f0f2:	b21b      	sxth	r3, r3
}
 801f0f4:	4618      	mov	r0, r3
 801f0f6:	370c      	adds	r7, #12
 801f0f8:	46bd      	mov	sp, r7
 801f0fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 801f0fe:	4770      	bx	lr

0801f100 <lv_cont_set_style>:
 * @param cont pointer to a container object
 * @param type which style should be set (can be only `LV_CONT_STYLE_MAIN`)
 * @param style pointer to the new style
 */
static inline void lv_cont_set_style(lv_obj_t * cont, lv_cont_style_t type, const lv_style_t * style)
{
 801f100:	b580      	push	{r7, lr}
 801f102:	b084      	sub	sp, #16
 801f104:	af00      	add	r7, sp, #0
 801f106:	60f8      	str	r0, [r7, #12]
 801f108:	460b      	mov	r3, r1
 801f10a:	607a      	str	r2, [r7, #4]
 801f10c:	72fb      	strb	r3, [r7, #11]
    (void)type; /*Unused*/
    lv_obj_set_style(cont, style);
 801f10e:	6879      	ldr	r1, [r7, #4]
 801f110:	68f8      	ldr	r0, [r7, #12]
 801f112:	f7f2 fdce 	bl	8011cb2 <lv_obj_set_style>
}
 801f116:	bf00      	nop
 801f118:	3710      	adds	r7, #16
 801f11a:	46bd      	mov	sp, r7
 801f11c:	bd80      	pop	{r7, pc}
	...

0801f120 <lv_cont_create>:
 * @param par pointer to an object, it will be the parent of the new container
 * @param copy pointer to a container object, if not NULL then the new object will be copied from it
 * @return pointer to the created container
 */
lv_obj_t * lv_cont_create(lv_obj_t * par, const lv_obj_t * copy)
{
 801f120:	b580      	push	{r7, lr}
 801f122:	b086      	sub	sp, #24
 801f124:	af00      	add	r7, sp, #0
 801f126:	6078      	str	r0, [r7, #4]
 801f128:	6039      	str	r1, [r7, #0]

    LV_LOG_TRACE("container create started");

    /*Create a basic object*/
    lv_obj_t * new_cont = lv_obj_create(par, copy);
 801f12a:	6839      	ldr	r1, [r7, #0]
 801f12c:	6878      	ldr	r0, [r7, #4]
 801f12e:	f7f1 fb29 	bl	8010784 <lv_obj_create>
 801f132:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_cont);
 801f134:	697b      	ldr	r3, [r7, #20]
 801f136:	2b00      	cmp	r3, #0
 801f138:	d106      	bne.n	801f148 <lv_cont_create+0x28>
 801f13a:	4b51      	ldr	r3, [pc, #324]	; (801f280 <lv_cont_create+0x160>)
 801f13c:	2246      	movs	r2, #70	; 0x46
 801f13e:	4951      	ldr	r1, [pc, #324]	; (801f284 <lv_cont_create+0x164>)
 801f140:	2003      	movs	r0, #3
 801f142:	f7fd fb63 	bl	801c80c <lv_log_add>
 801f146:	e7fe      	b.n	801f146 <lv_cont_create+0x26>
    if(new_cont == NULL) return NULL;
 801f148:	697b      	ldr	r3, [r7, #20]
 801f14a:	2b00      	cmp	r3, #0
 801f14c:	d101      	bne.n	801f152 <lv_cont_create+0x32>
 801f14e:	2300      	movs	r3, #0
 801f150:	e091      	b.n	801f276 <lv_cont_create+0x156>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_cont);
 801f152:	4b4d      	ldr	r3, [pc, #308]	; (801f288 <lv_cont_create+0x168>)
 801f154:	681b      	ldr	r3, [r3, #0]
 801f156:	2b00      	cmp	r3, #0
 801f158:	d105      	bne.n	801f166 <lv_cont_create+0x46>
 801f15a:	6978      	ldr	r0, [r7, #20]
 801f15c:	f7f3 f951 	bl	8012402 <lv_obj_get_signal_cb>
 801f160:	4602      	mov	r2, r0
 801f162:	4b49      	ldr	r3, [pc, #292]	; (801f288 <lv_cont_create+0x168>)
 801f164:	601a      	str	r2, [r3, #0]

    lv_obj_allocate_ext_attr(new_cont, sizeof(lv_cont_ext_t));
 801f166:	2102      	movs	r1, #2
 801f168:	6978      	ldr	r0, [r7, #20]
 801f16a:	f7f2 ff25 	bl	8011fb8 <lv_obj_allocate_ext_attr>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(new_cont);
 801f16e:	6978      	ldr	r0, [r7, #20]
 801f170:	f7f3 f95f 	bl	8012432 <lv_obj_get_ext_attr>
 801f174:	6138      	str	r0, [r7, #16]
    if(ext == NULL) return NULL;
 801f176:	693b      	ldr	r3, [r7, #16]
 801f178:	2b00      	cmp	r3, #0
 801f17a:	d101      	bne.n	801f180 <lv_cont_create+0x60>
 801f17c:	2300      	movs	r3, #0
 801f17e:	e07a      	b.n	801f276 <lv_cont_create+0x156>

    lv_mem_assert(ext);
 801f180:	693b      	ldr	r3, [r7, #16]
 801f182:	2b00      	cmp	r3, #0
 801f184:	d106      	bne.n	801f194 <lv_cont_create+0x74>
 801f186:	4b3e      	ldr	r3, [pc, #248]	; (801f280 <lv_cont_create+0x160>)
 801f188:	224f      	movs	r2, #79	; 0x4f
 801f18a:	493e      	ldr	r1, [pc, #248]	; (801f284 <lv_cont_create+0x164>)
 801f18c:	2003      	movs	r0, #3
 801f18e:	f7fd fb3d 	bl	801c80c <lv_log_add>
 801f192:	e7fe      	b.n	801f192 <lv_cont_create+0x72>
    ext->fit_left   = LV_FIT_NONE;
 801f194:	693a      	ldr	r2, [r7, #16]
 801f196:	7813      	ldrb	r3, [r2, #0]
 801f198:	f36f 1305 	bfc	r3, #4, #2
 801f19c:	7013      	strb	r3, [r2, #0]
    ext->fit_right  = LV_FIT_NONE;
 801f19e:	693a      	ldr	r2, [r7, #16]
 801f1a0:	7813      	ldrb	r3, [r2, #0]
 801f1a2:	f36f 1387 	bfc	r3, #6, #2
 801f1a6:	7013      	strb	r3, [r2, #0]
    ext->fit_top    = LV_FIT_NONE;
 801f1a8:	693a      	ldr	r2, [r7, #16]
 801f1aa:	7853      	ldrb	r3, [r2, #1]
 801f1ac:	f36f 0301 	bfc	r3, #0, #2
 801f1b0:	7053      	strb	r3, [r2, #1]
    ext->fit_bottom = LV_FIT_NONE;
 801f1b2:	693a      	ldr	r2, [r7, #16]
 801f1b4:	7853      	ldrb	r3, [r2, #1]
 801f1b6:	f36f 0383 	bfc	r3, #2, #2
 801f1ba:	7053      	strb	r3, [r2, #1]
    ext->layout     = LV_LAYOUT_OFF;
 801f1bc:	693a      	ldr	r2, [r7, #16]
 801f1be:	7813      	ldrb	r3, [r2, #0]
 801f1c0:	f36f 0303 	bfc	r3, #0, #4
 801f1c4:	7013      	strb	r3, [r2, #0]

    lv_obj_set_signal_cb(new_cont, lv_cont_signal);
 801f1c6:	4931      	ldr	r1, [pc, #196]	; (801f28c <lv_cont_create+0x16c>)
 801f1c8:	6978      	ldr	r0, [r7, #20]
 801f1ca:	f7f2 fed9 	bl	8011f80 <lv_obj_set_signal_cb>

    /*Init the new container*/
    if(copy == NULL) {
 801f1ce:	683b      	ldr	r3, [r7, #0]
 801f1d0:	2b00      	cmp	r3, #0
 801f1d2:	d116      	bne.n	801f202 <lv_cont_create+0xe2>
        /*Set the default styles if it's not screen*/
        if(par != NULL) {
 801f1d4:	687b      	ldr	r3, [r7, #4]
 801f1d6:	2b00      	cmp	r3, #0
 801f1d8:	d04c      	beq.n	801f274 <lv_cont_create+0x154>
            lv_theme_t * th = lv_theme_get_current();
 801f1da:	f006 fbd9 	bl	8025990 <lv_theme_get_current>
 801f1de:	60b8      	str	r0, [r7, #8]
            if(th) {
 801f1e0:	68bb      	ldr	r3, [r7, #8]
 801f1e2:	2b00      	cmp	r3, #0
 801f1e4:	d007      	beq.n	801f1f6 <lv_cont_create+0xd6>
                lv_cont_set_style(new_cont, LV_CONT_STYLE_MAIN, th->style.cont);
 801f1e6:	68bb      	ldr	r3, [r7, #8]
 801f1e8:	68db      	ldr	r3, [r3, #12]
 801f1ea:	461a      	mov	r2, r3
 801f1ec:	2100      	movs	r1, #0
 801f1ee:	6978      	ldr	r0, [r7, #20]
 801f1f0:	f7ff ff86 	bl	801f100 <lv_cont_set_style>
 801f1f4:	e03e      	b.n	801f274 <lv_cont_create+0x154>
            } else {
                lv_cont_set_style(new_cont, LV_CONT_STYLE_MAIN, &lv_style_pretty);
 801f1f6:	4a26      	ldr	r2, [pc, #152]	; (801f290 <lv_cont_create+0x170>)
 801f1f8:	2100      	movs	r1, #0
 801f1fa:	6978      	ldr	r0, [r7, #20]
 801f1fc:	f7ff ff80 	bl	801f100 <lv_cont_set_style>
 801f200:	e038      	b.n	801f274 <lv_cont_create+0x154>
            }
        }
    }
    /*Copy an existing object*/
    else {
        lv_cont_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 801f202:	6838      	ldr	r0, [r7, #0]
 801f204:	f7f3 f915 	bl	8012432 <lv_obj_get_ext_attr>
 801f208:	60f8      	str	r0, [r7, #12]
        ext->fit_left            = copy_ext->fit_left;
 801f20a:	68fb      	ldr	r3, [r7, #12]
 801f20c:	781b      	ldrb	r3, [r3, #0]
 801f20e:	f3c3 1301 	ubfx	r3, r3, #4, #2
 801f212:	b2d9      	uxtb	r1, r3
 801f214:	693a      	ldr	r2, [r7, #16]
 801f216:	7813      	ldrb	r3, [r2, #0]
 801f218:	f361 1305 	bfi	r3, r1, #4, #2
 801f21c:	7013      	strb	r3, [r2, #0]
        ext->fit_right           = copy_ext->fit_right;
 801f21e:	68fb      	ldr	r3, [r7, #12]
 801f220:	781b      	ldrb	r3, [r3, #0]
 801f222:	f3c3 1381 	ubfx	r3, r3, #6, #2
 801f226:	b2d9      	uxtb	r1, r3
 801f228:	693a      	ldr	r2, [r7, #16]
 801f22a:	7813      	ldrb	r3, [r2, #0]
 801f22c:	f361 1387 	bfi	r3, r1, #6, #2
 801f230:	7013      	strb	r3, [r2, #0]
        ext->fit_top             = copy_ext->fit_top;
 801f232:	68fb      	ldr	r3, [r7, #12]
 801f234:	785b      	ldrb	r3, [r3, #1]
 801f236:	f3c3 0301 	ubfx	r3, r3, #0, #2
 801f23a:	b2d9      	uxtb	r1, r3
 801f23c:	693a      	ldr	r2, [r7, #16]
 801f23e:	7853      	ldrb	r3, [r2, #1]
 801f240:	f361 0301 	bfi	r3, r1, #0, #2
 801f244:	7053      	strb	r3, [r2, #1]
        ext->fit_bottom          = copy_ext->fit_bottom;
 801f246:	68fb      	ldr	r3, [r7, #12]
 801f248:	785b      	ldrb	r3, [r3, #1]
 801f24a:	f3c3 0381 	ubfx	r3, r3, #2, #2
 801f24e:	b2d9      	uxtb	r1, r3
 801f250:	693a      	ldr	r2, [r7, #16]
 801f252:	7853      	ldrb	r3, [r2, #1]
 801f254:	f361 0383 	bfi	r3, r1, #2, #2
 801f258:	7053      	strb	r3, [r2, #1]
        ext->layout              = copy_ext->layout;
 801f25a:	68fb      	ldr	r3, [r7, #12]
 801f25c:	781b      	ldrb	r3, [r3, #0]
 801f25e:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801f262:	b2d9      	uxtb	r1, r3
 801f264:	693a      	ldr	r2, [r7, #16]
 801f266:	7813      	ldrb	r3, [r2, #0]
 801f268:	f361 0303 	bfi	r3, r1, #0, #4
 801f26c:	7013      	strb	r3, [r2, #0]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_cont);
 801f26e:	6978      	ldr	r0, [r7, #20]
 801f270:	f7f2 fd31 	bl	8011cd6 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("container created");

    return new_cont;
 801f274:	697b      	ldr	r3, [r7, #20]
}
 801f276:	4618      	mov	r0, r3
 801f278:	3718      	adds	r7, #24
 801f27a:	46bd      	mov	sp, r7
 801f27c:	bd80      	pop	{r7, pc}
 801f27e:	bf00      	nop
 801f280:	08028f88 	.word	0x08028f88
 801f284:	08028f98 	.word	0x08028f98
 801f288:	2000c3cc 	.word	0x2000c3cc
 801f28c:	0801f439 	.word	0x0801f439
 801f290:	2000dd28 	.word	0x2000dd28

0801f294 <lv_cont_set_layout>:
 * Set a layout on a container
 * @param cont pointer to a container object
 * @param layout a layout from 'lv_cont_layout_t'
 */
void lv_cont_set_layout(lv_obj_t * cont, lv_layout_t layout)
{
 801f294:	b580      	push	{r7, lr}
 801f296:	b084      	sub	sp, #16
 801f298:	af00      	add	r7, sp, #0
 801f29a:	6078      	str	r0, [r7, #4]
 801f29c:	460b      	mov	r3, r1
 801f29e:	70fb      	strb	r3, [r7, #3]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801f2a0:	6878      	ldr	r0, [r7, #4]
 801f2a2:	f7f3 f8c6 	bl	8012432 <lv_obj_get_ext_attr>
 801f2a6:	60f8      	str	r0, [r7, #12]
    if(ext->layout == layout) return;
 801f2a8:	68fb      	ldr	r3, [r7, #12]
 801f2aa:	781b      	ldrb	r3, [r3, #0]
 801f2ac:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801f2b0:	b2db      	uxtb	r3, r3
 801f2b2:	461a      	mov	r2, r3
 801f2b4:	78fb      	ldrb	r3, [r7, #3]
 801f2b6:	429a      	cmp	r2, r3
 801f2b8:	d00f      	beq.n	801f2da <lv_cont_set_layout+0x46>

    ext->layout = layout;
 801f2ba:	78fb      	ldrb	r3, [r7, #3]
 801f2bc:	f003 030f 	and.w	r3, r3, #15
 801f2c0:	b2d9      	uxtb	r1, r3
 801f2c2:	68fa      	ldr	r2, [r7, #12]
 801f2c4:	7813      	ldrb	r3, [r2, #0]
 801f2c6:	f361 0303 	bfi	r3, r1, #0, #4
 801f2ca:	7013      	strb	r3, [r2, #0]

    /*Send a signal to refresh the layout*/
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
 801f2cc:	687b      	ldr	r3, [r7, #4]
 801f2ce:	69db      	ldr	r3, [r3, #28]
 801f2d0:	2200      	movs	r2, #0
 801f2d2:	2101      	movs	r1, #1
 801f2d4:	6878      	ldr	r0, [r7, #4]
 801f2d6:	4798      	blx	r3
 801f2d8:	e000      	b.n	801f2dc <lv_cont_set_layout+0x48>
    if(ext->layout == layout) return;
 801f2da:	bf00      	nop
}
 801f2dc:	3710      	adds	r7, #16
 801f2de:	46bd      	mov	sp, r7
 801f2e0:	bd80      	pop	{r7, pc}

0801f2e2 <lv_cont_set_fit4>:
 * @param right right fit policy from `lv_fit_t`
 * @param top bottom fit policy from `lv_fit_t`
 * @param bottom bottom fit policy from `lv_fit_t`
 */
void lv_cont_set_fit4(lv_obj_t * cont, lv_fit_t left, lv_fit_t right, lv_fit_t top, lv_fit_t bottom)
{
 801f2e2:	b580      	push	{r7, lr}
 801f2e4:	b084      	sub	sp, #16
 801f2e6:	af00      	add	r7, sp, #0
 801f2e8:	6078      	str	r0, [r7, #4]
 801f2ea:	4608      	mov	r0, r1
 801f2ec:	4611      	mov	r1, r2
 801f2ee:	461a      	mov	r2, r3
 801f2f0:	4603      	mov	r3, r0
 801f2f2:	70fb      	strb	r3, [r7, #3]
 801f2f4:	460b      	mov	r3, r1
 801f2f6:	70bb      	strb	r3, [r7, #2]
 801f2f8:	4613      	mov	r3, r2
 801f2fa:	707b      	strb	r3, [r7, #1]
    lv_obj_invalidate(cont);
 801f2fc:	6878      	ldr	r0, [r7, #4]
 801f2fe:	f7f1 fd96 	bl	8010e2e <lv_obj_invalidate>
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801f302:	6878      	ldr	r0, [r7, #4]
 801f304:	f7f3 f895 	bl	8012432 <lv_obj_get_ext_attr>
 801f308:	60f8      	str	r0, [r7, #12]
    if(ext->fit_left == left && ext->fit_right == right && ext->fit_top == top && ext->fit_bottom == bottom) {
 801f30a:	68fb      	ldr	r3, [r7, #12]
 801f30c:	781b      	ldrb	r3, [r3, #0]
 801f30e:	f3c3 1301 	ubfx	r3, r3, #4, #2
 801f312:	b2db      	uxtb	r3, r3
 801f314:	461a      	mov	r2, r3
 801f316:	78fb      	ldrb	r3, [r7, #3]
 801f318:	429a      	cmp	r2, r3
 801f31a:	d11a      	bne.n	801f352 <lv_cont_set_fit4+0x70>
 801f31c:	68fb      	ldr	r3, [r7, #12]
 801f31e:	781b      	ldrb	r3, [r3, #0]
 801f320:	f3c3 1381 	ubfx	r3, r3, #6, #2
 801f324:	b2db      	uxtb	r3, r3
 801f326:	461a      	mov	r2, r3
 801f328:	78bb      	ldrb	r3, [r7, #2]
 801f32a:	429a      	cmp	r2, r3
 801f32c:	d111      	bne.n	801f352 <lv_cont_set_fit4+0x70>
 801f32e:	68fb      	ldr	r3, [r7, #12]
 801f330:	785b      	ldrb	r3, [r3, #1]
 801f332:	f3c3 0301 	ubfx	r3, r3, #0, #2
 801f336:	b2db      	uxtb	r3, r3
 801f338:	461a      	mov	r2, r3
 801f33a:	787b      	ldrb	r3, [r7, #1]
 801f33c:	429a      	cmp	r2, r3
 801f33e:	d108      	bne.n	801f352 <lv_cont_set_fit4+0x70>
 801f340:	68fb      	ldr	r3, [r7, #12]
 801f342:	785b      	ldrb	r3, [r3, #1]
 801f344:	f3c3 0381 	ubfx	r3, r3, #2, #2
 801f348:	b2db      	uxtb	r3, r3
 801f34a:	461a      	mov	r2, r3
 801f34c:	7e3b      	ldrb	r3, [r7, #24]
 801f34e:	429a      	cmp	r2, r3
 801f350:	d02a      	beq.n	801f3a8 <lv_cont_set_fit4+0xc6>
        return;
    }

    ext->fit_left   = left;
 801f352:	78fb      	ldrb	r3, [r7, #3]
 801f354:	f003 0303 	and.w	r3, r3, #3
 801f358:	b2d9      	uxtb	r1, r3
 801f35a:	68fa      	ldr	r2, [r7, #12]
 801f35c:	7813      	ldrb	r3, [r2, #0]
 801f35e:	f361 1305 	bfi	r3, r1, #4, #2
 801f362:	7013      	strb	r3, [r2, #0]
    ext->fit_right  = right;
 801f364:	78bb      	ldrb	r3, [r7, #2]
 801f366:	f003 0303 	and.w	r3, r3, #3
 801f36a:	b2d9      	uxtb	r1, r3
 801f36c:	68fa      	ldr	r2, [r7, #12]
 801f36e:	7813      	ldrb	r3, [r2, #0]
 801f370:	f361 1387 	bfi	r3, r1, #6, #2
 801f374:	7013      	strb	r3, [r2, #0]
    ext->fit_top    = top;
 801f376:	787b      	ldrb	r3, [r7, #1]
 801f378:	f003 0303 	and.w	r3, r3, #3
 801f37c:	b2d9      	uxtb	r1, r3
 801f37e:	68fa      	ldr	r2, [r7, #12]
 801f380:	7853      	ldrb	r3, [r2, #1]
 801f382:	f361 0301 	bfi	r3, r1, #0, #2
 801f386:	7053      	strb	r3, [r2, #1]
    ext->fit_bottom = bottom;
 801f388:	7e3b      	ldrb	r3, [r7, #24]
 801f38a:	f003 0303 	and.w	r3, r3, #3
 801f38e:	b2d9      	uxtb	r1, r3
 801f390:	68fa      	ldr	r2, [r7, #12]
 801f392:	7853      	ldrb	r3, [r2, #1]
 801f394:	f361 0383 	bfi	r3, r1, #2, #2
 801f398:	7053      	strb	r3, [r2, #1]

    /*Send a signal to refresh the layout*/
    cont->signal_cb(cont, LV_SIGNAL_CHILD_CHG, NULL);
 801f39a:	687b      	ldr	r3, [r7, #4]
 801f39c:	69db      	ldr	r3, [r3, #28]
 801f39e:	2200      	movs	r2, #0
 801f3a0:	2101      	movs	r1, #1
 801f3a2:	6878      	ldr	r0, [r7, #4]
 801f3a4:	4798      	blx	r3
 801f3a6:	e000      	b.n	801f3aa <lv_cont_set_fit4+0xc8>
        return;
 801f3a8:	bf00      	nop
}
 801f3aa:	3710      	adds	r7, #16
 801f3ac:	46bd      	mov	sp, r7
 801f3ae:	bd80      	pop	{r7, pc}

0801f3b0 <lv_cont_get_layout>:
 * Get the layout of a container
 * @param cont pointer to container object
 * @return the layout from 'lv_cont_layout_t'
 */
lv_layout_t lv_cont_get_layout(const lv_obj_t * cont)
{
 801f3b0:	b580      	push	{r7, lr}
 801f3b2:	b084      	sub	sp, #16
 801f3b4:	af00      	add	r7, sp, #0
 801f3b6:	6078      	str	r0, [r7, #4]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801f3b8:	6878      	ldr	r0, [r7, #4]
 801f3ba:	f7f3 f83a 	bl	8012432 <lv_obj_get_ext_attr>
 801f3be:	60f8      	str	r0, [r7, #12]
    return ext->layout;
 801f3c0:	68fb      	ldr	r3, [r7, #12]
 801f3c2:	781b      	ldrb	r3, [r3, #0]
 801f3c4:	f3c3 0303 	ubfx	r3, r3, #0, #4
 801f3c8:	b2db      	uxtb	r3, r3
}
 801f3ca:	4618      	mov	r0, r3
 801f3cc:	3710      	adds	r7, #16
 801f3ce:	46bd      	mov	sp, r7
 801f3d0:	bd80      	pop	{r7, pc}

0801f3d2 <lv_cont_get_fit_left>:
 * Get left fit mode of a container
 * @param cont pointer to a container object
 * @return an element of `lv_fit_t`
 */
lv_fit_t lv_cont_get_fit_left(const lv_obj_t * cont)
{
 801f3d2:	b580      	push	{r7, lr}
 801f3d4:	b084      	sub	sp, #16
 801f3d6:	af00      	add	r7, sp, #0
 801f3d8:	6078      	str	r0, [r7, #4]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801f3da:	6878      	ldr	r0, [r7, #4]
 801f3dc:	f7f3 f829 	bl	8012432 <lv_obj_get_ext_attr>
 801f3e0:	60f8      	str	r0, [r7, #12]
    return ext->fit_left;
 801f3e2:	68fb      	ldr	r3, [r7, #12]
 801f3e4:	781b      	ldrb	r3, [r3, #0]
 801f3e6:	f3c3 1301 	ubfx	r3, r3, #4, #2
 801f3ea:	b2db      	uxtb	r3, r3
}
 801f3ec:	4618      	mov	r0, r3
 801f3ee:	3710      	adds	r7, #16
 801f3f0:	46bd      	mov	sp, r7
 801f3f2:	bd80      	pop	{r7, pc}

0801f3f4 <lv_cont_get_fit_top>:
 * Get top fit mode of a container
 * @param cont pointer to a container object
 * @return an element of `lv_fit_t`
 */
lv_fit_t lv_cont_get_fit_top(const lv_obj_t * cont)
{
 801f3f4:	b580      	push	{r7, lr}
 801f3f6:	b084      	sub	sp, #16
 801f3f8:	af00      	add	r7, sp, #0
 801f3fa:	6078      	str	r0, [r7, #4]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801f3fc:	6878      	ldr	r0, [r7, #4]
 801f3fe:	f7f3 f818 	bl	8012432 <lv_obj_get_ext_attr>
 801f402:	60f8      	str	r0, [r7, #12]
    return ext->fit_top;
 801f404:	68fb      	ldr	r3, [r7, #12]
 801f406:	785b      	ldrb	r3, [r3, #1]
 801f408:	f3c3 0301 	ubfx	r3, r3, #0, #2
 801f40c:	b2db      	uxtb	r3, r3
}
 801f40e:	4618      	mov	r0, r3
 801f410:	3710      	adds	r7, #16
 801f412:	46bd      	mov	sp, r7
 801f414:	bd80      	pop	{r7, pc}

0801f416 <lv_cont_get_fit_bottom>:
 * Get bottom fit mode of a container
 * @param cont pointer to a container object
 * @return an element of `lv_fit_t`
 */
lv_fit_t lv_cont_get_fit_bottom(const lv_obj_t * cont)
{
 801f416:	b580      	push	{r7, lr}
 801f418:	b084      	sub	sp, #16
 801f41a:	af00      	add	r7, sp, #0
 801f41c:	6078      	str	r0, [r7, #4]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801f41e:	6878      	ldr	r0, [r7, #4]
 801f420:	f7f3 f807 	bl	8012432 <lv_obj_get_ext_attr>
 801f424:	60f8      	str	r0, [r7, #12]
    return ext->fit_bottom;
 801f426:	68fb      	ldr	r3, [r7, #12]
 801f428:	785b      	ldrb	r3, [r3, #1]
 801f42a:	f3c3 0381 	ubfx	r3, r3, #2, #2
 801f42e:	b2db      	uxtb	r3, r3
}
 801f430:	4618      	mov	r0, r3
 801f432:	3710      	adds	r7, #16
 801f434:	46bd      	mov	sp, r7
 801f436:	bd80      	pop	{r7, pc}

0801f438 <lv_cont_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_cont_signal(lv_obj_t * cont, lv_signal_t sign, void * param)
{
 801f438:	b590      	push	{r4, r7, lr}
 801f43a:	b087      	sub	sp, #28
 801f43c:	af00      	add	r7, sp, #0
 801f43e:	60f8      	str	r0, [r7, #12]
 801f440:	460b      	mov	r3, r1
 801f442:	607a      	str	r2, [r7, #4]
 801f444:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(cont, sign, param);
 801f446:	4b34      	ldr	r3, [pc, #208]	; (801f518 <lv_cont_signal+0xe0>)
 801f448:	681b      	ldr	r3, [r3, #0]
 801f44a:	7af9      	ldrb	r1, [r7, #11]
 801f44c:	687a      	ldr	r2, [r7, #4]
 801f44e:	68f8      	ldr	r0, [r7, #12]
 801f450:	4798      	blx	r3
 801f452:	4603      	mov	r3, r0
 801f454:	75bb      	strb	r3, [r7, #22]
    if(res != LV_RES_OK) return res;
 801f456:	7dbb      	ldrb	r3, [r7, #22]
 801f458:	2b01      	cmp	r3, #1
 801f45a:	d001      	beq.n	801f460 <lv_cont_signal+0x28>
 801f45c:	7dbb      	ldrb	r3, [r7, #22]
 801f45e:	e056      	b.n	801f50e <lv_cont_signal+0xd6>

    if(sign == LV_SIGNAL_STYLE_CHG) { /*Recalculate the padding if the style changed*/
 801f460:	7afb      	ldrb	r3, [r7, #11]
 801f462:	2b04      	cmp	r3, #4
 801f464:	d106      	bne.n	801f474 <lv_cont_signal+0x3c>
        lv_cont_refr_layout(cont);
 801f466:	68f8      	ldr	r0, [r7, #12]
 801f468:	f000 f85a 	bl	801f520 <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
 801f46c:	68f8      	ldr	r0, [r7, #12]
 801f46e:	f000 fc9c 	bl	801fdaa <lv_cont_refr_autofit>
 801f472:	e04b      	b.n	801f50c <lv_cont_signal+0xd4>
    } else if(sign == LV_SIGNAL_CHILD_CHG) {
 801f474:	7afb      	ldrb	r3, [r7, #11]
 801f476:	2b01      	cmp	r3, #1
 801f478:	d106      	bne.n	801f488 <lv_cont_signal+0x50>
        lv_cont_refr_layout(cont);
 801f47a:	68f8      	ldr	r0, [r7, #12]
 801f47c:	f000 f850 	bl	801f520 <lv_cont_refr_layout>
        lv_cont_refr_autofit(cont);
 801f480:	68f8      	ldr	r0, [r7, #12]
 801f482:	f000 fc92 	bl	801fdaa <lv_cont_refr_autofit>
 801f486:	e041      	b.n	801f50c <lv_cont_signal+0xd4>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
 801f488:	7afb      	ldrb	r3, [r7, #11]
 801f48a:	2b02      	cmp	r3, #2
 801f48c:	d11c      	bne.n	801f4c8 <lv_cont_signal+0x90>
        if(lv_obj_get_width(cont) != lv_area_get_width(param) || lv_obj_get_height(cont) != lv_area_get_height(param)) {
 801f48e:	68f8      	ldr	r0, [r7, #12]
 801f490:	f7f2 fe80 	bl	8012194 <lv_obj_get_width>
 801f494:	4603      	mov	r3, r0
 801f496:	461c      	mov	r4, r3
 801f498:	6878      	ldr	r0, [r7, #4]
 801f49a:	f7ff fe03 	bl	801f0a4 <lv_area_get_width>
 801f49e:	4603      	mov	r3, r0
 801f4a0:	429c      	cmp	r4, r3
 801f4a2:	d10a      	bne.n	801f4ba <lv_cont_signal+0x82>
 801f4a4:	68f8      	ldr	r0, [r7, #12]
 801f4a6:	f7f2 fe83 	bl	80121b0 <lv_obj_get_height>
 801f4aa:	4603      	mov	r3, r0
 801f4ac:	461c      	mov	r4, r3
 801f4ae:	6878      	ldr	r0, [r7, #4]
 801f4b0:	f7ff fe0f 	bl	801f0d2 <lv_area_get_height>
 801f4b4:	4603      	mov	r3, r0
 801f4b6:	429c      	cmp	r4, r3
 801f4b8:	d028      	beq.n	801f50c <lv_cont_signal+0xd4>
            lv_cont_refr_layout(cont);
 801f4ba:	68f8      	ldr	r0, [r7, #12]
 801f4bc:	f000 f830 	bl	801f520 <lv_cont_refr_layout>
            lv_cont_refr_autofit(cont);
 801f4c0:	68f8      	ldr	r0, [r7, #12]
 801f4c2:	f000 fc72 	bl	801fdaa <lv_cont_refr_autofit>
 801f4c6:	e021      	b.n	801f50c <lv_cont_signal+0xd4>
        }
    } else if(sign == LV_SIGNAL_PARENT_SIZE_CHG) {
 801f4c8:	7afb      	ldrb	r3, [r7, #11]
 801f4ca:	2b03      	cmp	r3, #3
 801f4cc:	d103      	bne.n	801f4d6 <lv_cont_signal+0x9e>
        /*FLOOD and FILL fit needs to be refreshed if the parent size has changed*/
        lv_cont_refr_autofit(cont);
 801f4ce:	68f8      	ldr	r0, [r7, #12]
 801f4d0:	f000 fc6b 	bl	801fdaa <lv_cont_refr_autofit>
 801f4d4:	e01a      	b.n	801f50c <lv_cont_signal+0xd4>

    } else if(sign == LV_SIGNAL_GET_TYPE) {
 801f4d6:	7afb      	ldrb	r3, [r7, #11]
 801f4d8:	2b06      	cmp	r3, #6
 801f4da:	d117      	bne.n	801f50c <lv_cont_signal+0xd4>
        lv_obj_type_t * buf = param;
 801f4dc:	687b      	ldr	r3, [r7, #4]
 801f4de:	613b      	str	r3, [r7, #16]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801f4e0:	2300      	movs	r3, #0
 801f4e2:	75fb      	strb	r3, [r7, #23]
 801f4e4:	e008      	b.n	801f4f8 <lv_cont_signal+0xc0>
            if(buf->type[i] == NULL) break;
 801f4e6:	7dfa      	ldrb	r2, [r7, #23]
 801f4e8:	693b      	ldr	r3, [r7, #16]
 801f4ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801f4ee:	2b00      	cmp	r3, #0
 801f4f0:	d006      	beq.n	801f500 <lv_cont_signal+0xc8>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 801f4f2:	7dfb      	ldrb	r3, [r7, #23]
 801f4f4:	3301      	adds	r3, #1
 801f4f6:	75fb      	strb	r3, [r7, #23]
 801f4f8:	7dfb      	ldrb	r3, [r7, #23]
 801f4fa:	2b06      	cmp	r3, #6
 801f4fc:	d9f3      	bls.n	801f4e6 <lv_cont_signal+0xae>
 801f4fe:	e000      	b.n	801f502 <lv_cont_signal+0xca>
            if(buf->type[i] == NULL) break;
 801f500:	bf00      	nop
        }
        buf->type[i] = "lv_cont";
 801f502:	7dfa      	ldrb	r2, [r7, #23]
 801f504:	693b      	ldr	r3, [r7, #16]
 801f506:	4905      	ldr	r1, [pc, #20]	; (801f51c <lv_cont_signal+0xe4>)
 801f508:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 801f50c:	7dbb      	ldrb	r3, [r7, #22]
}
 801f50e:	4618      	mov	r0, r3
 801f510:	371c      	adds	r7, #28
 801f512:	46bd      	mov	sp, r7
 801f514:	bd90      	pop	{r4, r7, pc}
 801f516:	bf00      	nop
 801f518:	2000c3cc 	.word	0x2000c3cc
 801f51c:	08028fb8 	.word	0x08028fb8

0801f520 <lv_cont_refr_layout>:
/**
 * Refresh the layout of a container
 * @param cont pointer to an object which layout should be refreshed
 */
static void lv_cont_refr_layout(lv_obj_t * cont)
{
 801f520:	b580      	push	{r7, lr}
 801f522:	b084      	sub	sp, #16
 801f524:	af00      	add	r7, sp, #0
 801f526:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 801f528:	6878      	ldr	r0, [r7, #4]
 801f52a:	f7ff ff41 	bl	801f3b0 <lv_cont_get_layout>
 801f52e:	4603      	mov	r3, r0
 801f530:	73fb      	strb	r3, [r7, #15]

    /*'cont' has to be at least 1 child*/
    if(lv_obj_get_child(cont, NULL) == NULL) return;
 801f532:	2100      	movs	r1, #0
 801f534:	6878      	ldr	r0, [r7, #4]
 801f536:	f7f2 fdcf 	bl	80120d8 <lv_obj_get_child>
 801f53a:	4603      	mov	r3, r0
 801f53c:	2b00      	cmp	r3, #0
 801f53e:	d031      	beq.n	801f5a4 <lv_cont_refr_layout+0x84>

    if(type == LV_LAYOUT_OFF) return;
 801f540:	7bfb      	ldrb	r3, [r7, #15]
 801f542:	2b00      	cmp	r3, #0
 801f544:	d030      	beq.n	801f5a8 <lv_cont_refr_layout+0x88>

    if(type == LV_LAYOUT_CENTER) {
 801f546:	7bfb      	ldrb	r3, [r7, #15]
 801f548:	2b01      	cmp	r3, #1
 801f54a:	d103      	bne.n	801f554 <lv_cont_refr_layout+0x34>
        lv_cont_layout_center(cont);
 801f54c:	6878      	ldr	r0, [r7, #4]
 801f54e:	f000 f91b 	bl	801f788 <lv_cont_layout_center>
 801f552:	e02a      	b.n	801f5aa <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_COL_L || type == LV_LAYOUT_COL_M || type == LV_LAYOUT_COL_R) {
 801f554:	7bfb      	ldrb	r3, [r7, #15]
 801f556:	2b02      	cmp	r3, #2
 801f558:	d005      	beq.n	801f566 <lv_cont_refr_layout+0x46>
 801f55a:	7bfb      	ldrb	r3, [r7, #15]
 801f55c:	2b03      	cmp	r3, #3
 801f55e:	d002      	beq.n	801f566 <lv_cont_refr_layout+0x46>
 801f560:	7bfb      	ldrb	r3, [r7, #15]
 801f562:	2b04      	cmp	r3, #4
 801f564:	d103      	bne.n	801f56e <lv_cont_refr_layout+0x4e>
        lv_cont_layout_col(cont);
 801f566:	6878      	ldr	r0, [r7, #4]
 801f568:	f000 f822 	bl	801f5b0 <lv_cont_layout_col>
 801f56c:	e01d      	b.n	801f5aa <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_ROW_T || type == LV_LAYOUT_ROW_M || type == LV_LAYOUT_ROW_B) {
 801f56e:	7bfb      	ldrb	r3, [r7, #15]
 801f570:	2b05      	cmp	r3, #5
 801f572:	d005      	beq.n	801f580 <lv_cont_refr_layout+0x60>
 801f574:	7bfb      	ldrb	r3, [r7, #15]
 801f576:	2b06      	cmp	r3, #6
 801f578:	d002      	beq.n	801f580 <lv_cont_refr_layout+0x60>
 801f57a:	7bfb      	ldrb	r3, [r7, #15]
 801f57c:	2b07      	cmp	r3, #7
 801f57e:	d103      	bne.n	801f588 <lv_cont_refr_layout+0x68>
        lv_cont_layout_row(cont);
 801f580:	6878      	ldr	r0, [r7, #4]
 801f582:	f000 f88b 	bl	801f69c <lv_cont_layout_row>
 801f586:	e010      	b.n	801f5aa <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_PRETTY) {
 801f588:	7bfb      	ldrb	r3, [r7, #15]
 801f58a:	2b08      	cmp	r3, #8
 801f58c:	d103      	bne.n	801f596 <lv_cont_refr_layout+0x76>
        lv_cont_layout_pretty(cont);
 801f58e:	6878      	ldr	r0, [r7, #4]
 801f590:	f000 f99e 	bl	801f8d0 <lv_cont_layout_pretty>
 801f594:	e009      	b.n	801f5aa <lv_cont_refr_layout+0x8a>
    } else if(type == LV_LAYOUT_GRID) {
 801f596:	7bfb      	ldrb	r3, [r7, #15]
 801f598:	2b09      	cmp	r3, #9
 801f59a:	d106      	bne.n	801f5aa <lv_cont_refr_layout+0x8a>
        lv_cont_layout_grid(cont);
 801f59c:	6878      	ldr	r0, [r7, #4]
 801f59e:	f000 fb3b 	bl	801fc18 <lv_cont_layout_grid>
 801f5a2:	e002      	b.n	801f5aa <lv_cont_refr_layout+0x8a>
    if(lv_obj_get_child(cont, NULL) == NULL) return;
 801f5a4:	bf00      	nop
 801f5a6:	e000      	b.n	801f5aa <lv_cont_refr_layout+0x8a>
    if(type == LV_LAYOUT_OFF) return;
 801f5a8:	bf00      	nop
    }
}
 801f5aa:	3710      	adds	r7, #16
 801f5ac:	46bd      	mov	sp, r7
 801f5ae:	bd80      	pop	{r7, pc}

0801f5b0 <lv_cont_layout_col>:
/**
 * Handle column type layouts
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_col(lv_obj_t * cont)
{
 801f5b0:	b580      	push	{r7, lr}
 801f5b2:	b088      	sub	sp, #32
 801f5b4:	af02      	add	r7, sp, #8
 801f5b6:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 801f5b8:	6878      	ldr	r0, [r7, #4]
 801f5ba:	f7ff fef9 	bl	801f3b0 <lv_cont_get_layout>
 801f5be:	4603      	mov	r3, r0
 801f5c0:	737b      	strb	r3, [r7, #13]
    lv_obj_t * child;

    /*Adjust margin and get the alignment type*/
    lv_align_t align;
    const lv_style_t * style = lv_obj_get_style(cont);
 801f5c2:	6878      	ldr	r0, [r7, #4]
 801f5c4:	f7f2 fe16 	bl	80121f4 <lv_obj_get_style>
 801f5c8:	60b8      	str	r0, [r7, #8]
    lv_coord_t hpad_corr;

    switch(type) {
 801f5ca:	7b7b      	ldrb	r3, [r7, #13]
 801f5cc:	2b03      	cmp	r3, #3
 801f5ce:	d009      	beq.n	801f5e4 <lv_cont_layout_col+0x34>
 801f5d0:	2b04      	cmp	r3, #4
 801f5d2:	d00c      	beq.n	801f5ee <lv_cont_layout_col+0x3e>
 801f5d4:	2b02      	cmp	r3, #2
 801f5d6:	d114      	bne.n	801f602 <lv_cont_layout_col+0x52>
        case LV_LAYOUT_COL_L:
            hpad_corr = style->body.padding.left;
 801f5d8:	68bb      	ldr	r3, [r7, #8]
 801f5da:	8b5b      	ldrh	r3, [r3, #26]
 801f5dc:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_LEFT;
 801f5de:	2301      	movs	r3, #1
 801f5e0:	74fb      	strb	r3, [r7, #19]
            break;
 801f5e2:	e013      	b.n	801f60c <lv_cont_layout_col+0x5c>
        case LV_LAYOUT_COL_M:
            hpad_corr = 0;
 801f5e4:	2300      	movs	r3, #0
 801f5e6:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_MID;
 801f5e8:	2302      	movs	r3, #2
 801f5ea:	74fb      	strb	r3, [r7, #19]
            break;
 801f5ec:	e00e      	b.n	801f60c <lv_cont_layout_col+0x5c>
        case LV_LAYOUT_COL_R:
            hpad_corr = -style->body.padding.right;
 801f5ee:	68bb      	ldr	r3, [r7, #8]
 801f5f0:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801f5f4:	b29b      	uxth	r3, r3
 801f5f6:	425b      	negs	r3, r3
 801f5f8:	b29b      	uxth	r3, r3
 801f5fa:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_RIGHT;
 801f5fc:	2303      	movs	r3, #3
 801f5fe:	74fb      	strb	r3, [r7, #19]
            break;
 801f600:	e004      	b.n	801f60c <lv_cont_layout_col+0x5c>
        default:
            hpad_corr = 0;
 801f602:	2300      	movs	r3, #0
 801f604:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_LEFT;
 801f606:	2301      	movs	r3, #1
 801f608:	74fb      	strb	r3, [r7, #19]
            break;
 801f60a:	bf00      	nop
    }

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 801f60c:	2101      	movs	r1, #1
 801f60e:	6878      	ldr	r0, [r7, #4]
 801f610:	f7f2 fbea 	bl	8011de8 <lv_obj_set_protect>
    /* Align the children */
    lv_coord_t last_cord = style->body.padding.top;
 801f614:	68bb      	ldr	r3, [r7, #8]
 801f616:	8adb      	ldrh	r3, [r3, #22]
 801f618:	81fb      	strh	r3, [r7, #14]
    LV_LL_READ_BACK(cont->child_ll, child)
 801f61a:	687b      	ldr	r3, [r7, #4]
 801f61c:	3304      	adds	r3, #4
 801f61e:	4618      	mov	r0, r3
 801f620:	f7fc ffff 	bl	801c622 <lv_ll_get_tail>
 801f624:	6178      	str	r0, [r7, #20]
 801f626:	e02e      	b.n	801f686 <lv_cont_layout_col+0xd6>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f628:	6978      	ldr	r0, [r7, #20]
 801f62a:	f7f2 fe3b 	bl	80122a4 <lv_obj_get_hidden>
 801f62e:	4603      	mov	r3, r0
 801f630:	2b00      	cmp	r3, #0
 801f632:	d120      	bne.n	801f676 <lv_cont_layout_col+0xc6>
 801f634:	2104      	movs	r1, #4
 801f636:	6978      	ldr	r0, [r7, #20]
 801f638:	f7f2 fecc 	bl	80123d4 <lv_obj_is_protected>
 801f63c:	4603      	mov	r3, r0
 801f63e:	2b00      	cmp	r3, #0
 801f640:	d119      	bne.n	801f676 <lv_cont_layout_col+0xc6>

        lv_obj_align(child, cont, align, hpad_corr, last_cord);
 801f642:	f9b7 1010 	ldrsh.w	r1, [r7, #16]
 801f646:	7cfa      	ldrb	r2, [r7, #19]
 801f648:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801f64c:	9300      	str	r3, [sp, #0]
 801f64e:	460b      	mov	r3, r1
 801f650:	6879      	ldr	r1, [r7, #4]
 801f652:	6978      	ldr	r0, [r7, #20]
 801f654:	f7f1 fe54 	bl	8011300 <lv_obj_align>
        last_cord += lv_obj_get_height(child) + style->body.padding.inner;
 801f658:	6978      	ldr	r0, [r7, #20]
 801f65a:	f7f2 fda9 	bl	80121b0 <lv_obj_get_height>
 801f65e:	4603      	mov	r3, r0
 801f660:	461a      	mov	r2, r3
 801f662:	68bb      	ldr	r3, [r7, #8]
 801f664:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801f668:	4413      	add	r3, r2
 801f66a:	b29a      	uxth	r2, r3
 801f66c:	89fb      	ldrh	r3, [r7, #14]
 801f66e:	4413      	add	r3, r2
 801f670:	b29b      	uxth	r3, r3
 801f672:	81fb      	strh	r3, [r7, #14]
 801f674:	e000      	b.n	801f678 <lv_cont_layout_col+0xc8>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f676:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 801f678:	687b      	ldr	r3, [r7, #4]
 801f67a:	3304      	adds	r3, #4
 801f67c:	6979      	ldr	r1, [r7, #20]
 801f67e:	4618      	mov	r0, r3
 801f680:	f7fc fffc 	bl	801c67c <lv_ll_get_prev>
 801f684:	6178      	str	r0, [r7, #20]
 801f686:	697b      	ldr	r3, [r7, #20]
 801f688:	2b00      	cmp	r3, #0
 801f68a:	d1cd      	bne.n	801f628 <lv_cont_layout_col+0x78>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 801f68c:	2101      	movs	r1, #1
 801f68e:	6878      	ldr	r0, [r7, #4]
 801f690:	f7f2 fbbf 	bl	8011e12 <lv_obj_clear_protect>
}
 801f694:	bf00      	nop
 801f696:	3718      	adds	r7, #24
 801f698:	46bd      	mov	sp, r7
 801f69a:	bd80      	pop	{r7, pc}

0801f69c <lv_cont_layout_row>:
/**
 * Handle row type layouts
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_row(lv_obj_t * cont)
{
 801f69c:	b580      	push	{r7, lr}
 801f69e:	b088      	sub	sp, #32
 801f6a0:	af02      	add	r7, sp, #8
 801f6a2:	6078      	str	r0, [r7, #4]
    lv_layout_t type = lv_cont_get_layout(cont);
 801f6a4:	6878      	ldr	r0, [r7, #4]
 801f6a6:	f7ff fe83 	bl	801f3b0 <lv_cont_get_layout>
 801f6aa:	4603      	mov	r3, r0
 801f6ac:	737b      	strb	r3, [r7, #13]
    lv_obj_t * child;

    /*Adjust margin and get the alignment type*/
    lv_align_t align;
    const lv_style_t * style = lv_obj_get_style(cont);
 801f6ae:	6878      	ldr	r0, [r7, #4]
 801f6b0:	f7f2 fda0 	bl	80121f4 <lv_obj_get_style>
 801f6b4:	60b8      	str	r0, [r7, #8]
    lv_coord_t vpad_corr;

    switch(type) {
 801f6b6:	7b7b      	ldrb	r3, [r7, #13]
 801f6b8:	2b06      	cmp	r3, #6
 801f6ba:	d009      	beq.n	801f6d0 <lv_cont_layout_row+0x34>
 801f6bc:	2b07      	cmp	r3, #7
 801f6be:	d00c      	beq.n	801f6da <lv_cont_layout_row+0x3e>
 801f6c0:	2b05      	cmp	r3, #5
 801f6c2:	d114      	bne.n	801f6ee <lv_cont_layout_row+0x52>
        case LV_LAYOUT_ROW_T:
            vpad_corr = style->body.padding.top;
 801f6c4:	68bb      	ldr	r3, [r7, #8]
 801f6c6:	8adb      	ldrh	r3, [r3, #22]
 801f6c8:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_LEFT;
 801f6ca:	2301      	movs	r3, #1
 801f6cc:	74fb      	strb	r3, [r7, #19]
            break;
 801f6ce:	e013      	b.n	801f6f8 <lv_cont_layout_row+0x5c>
        case LV_LAYOUT_ROW_M:
            vpad_corr = 0;
 801f6d0:	2300      	movs	r3, #0
 801f6d2:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_LEFT_MID;
 801f6d4:	2307      	movs	r3, #7
 801f6d6:	74fb      	strb	r3, [r7, #19]
            break;
 801f6d8:	e00e      	b.n	801f6f8 <lv_cont_layout_row+0x5c>
        case LV_LAYOUT_ROW_B:
            vpad_corr = -style->body.padding.bottom;
 801f6da:	68bb      	ldr	r3, [r7, #8]
 801f6dc:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 801f6e0:	b29b      	uxth	r3, r3
 801f6e2:	425b      	negs	r3, r3
 801f6e4:	b29b      	uxth	r3, r3
 801f6e6:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_BOTTOM_LEFT;
 801f6e8:	2304      	movs	r3, #4
 801f6ea:	74fb      	strb	r3, [r7, #19]
            break;
 801f6ec:	e004      	b.n	801f6f8 <lv_cont_layout_row+0x5c>
        default:
            vpad_corr = 0;
 801f6ee:	2300      	movs	r3, #0
 801f6f0:	823b      	strh	r3, [r7, #16]
            align     = LV_ALIGN_IN_TOP_LEFT;
 801f6f2:	2301      	movs	r3, #1
 801f6f4:	74fb      	strb	r3, [r7, #19]
            break;
 801f6f6:	bf00      	nop
    }

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 801f6f8:	2101      	movs	r1, #1
 801f6fa:	6878      	ldr	r0, [r7, #4]
 801f6fc:	f7f2 fb74 	bl	8011de8 <lv_obj_set_protect>

    /* Align the children */
    lv_coord_t last_cord = style->body.padding.left;
 801f700:	68bb      	ldr	r3, [r7, #8]
 801f702:	8b5b      	ldrh	r3, [r3, #26]
 801f704:	81fb      	strh	r3, [r7, #14]
    LV_LL_READ_BACK(cont->child_ll, child)
 801f706:	687b      	ldr	r3, [r7, #4]
 801f708:	3304      	adds	r3, #4
 801f70a:	4618      	mov	r0, r3
 801f70c:	f7fc ff89 	bl	801c622 <lv_ll_get_tail>
 801f710:	6178      	str	r0, [r7, #20]
 801f712:	e02e      	b.n	801f772 <lv_cont_layout_row+0xd6>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f714:	6978      	ldr	r0, [r7, #20]
 801f716:	f7f2 fdc5 	bl	80122a4 <lv_obj_get_hidden>
 801f71a:	4603      	mov	r3, r0
 801f71c:	2b00      	cmp	r3, #0
 801f71e:	d120      	bne.n	801f762 <lv_cont_layout_row+0xc6>
 801f720:	2104      	movs	r1, #4
 801f722:	6978      	ldr	r0, [r7, #20]
 801f724:	f7f2 fe56 	bl	80123d4 <lv_obj_is_protected>
 801f728:	4603      	mov	r3, r0
 801f72a:	2b00      	cmp	r3, #0
 801f72c:	d119      	bne.n	801f762 <lv_cont_layout_row+0xc6>

        lv_obj_align(child, cont, align, last_cord, vpad_corr);
 801f72e:	f9b7 100e 	ldrsh.w	r1, [r7, #14]
 801f732:	7cfa      	ldrb	r2, [r7, #19]
 801f734:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801f738:	9300      	str	r3, [sp, #0]
 801f73a:	460b      	mov	r3, r1
 801f73c:	6879      	ldr	r1, [r7, #4]
 801f73e:	6978      	ldr	r0, [r7, #20]
 801f740:	f7f1 fdde 	bl	8011300 <lv_obj_align>
        last_cord += lv_obj_get_width(child) + style->body.padding.inner;
 801f744:	6978      	ldr	r0, [r7, #20]
 801f746:	f7f2 fd25 	bl	8012194 <lv_obj_get_width>
 801f74a:	4603      	mov	r3, r0
 801f74c:	461a      	mov	r2, r3
 801f74e:	68bb      	ldr	r3, [r7, #8]
 801f750:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801f754:	4413      	add	r3, r2
 801f756:	b29a      	uxth	r2, r3
 801f758:	89fb      	ldrh	r3, [r7, #14]
 801f75a:	4413      	add	r3, r2
 801f75c:	b29b      	uxth	r3, r3
 801f75e:	81fb      	strh	r3, [r7, #14]
 801f760:	e000      	b.n	801f764 <lv_cont_layout_row+0xc8>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f762:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 801f764:	687b      	ldr	r3, [r7, #4]
 801f766:	3304      	adds	r3, #4
 801f768:	6979      	ldr	r1, [r7, #20]
 801f76a:	4618      	mov	r0, r3
 801f76c:	f7fc ff86 	bl	801c67c <lv_ll_get_prev>
 801f770:	6178      	str	r0, [r7, #20]
 801f772:	697b      	ldr	r3, [r7, #20]
 801f774:	2b00      	cmp	r3, #0
 801f776:	d1cd      	bne.n	801f714 <lv_cont_layout_row+0x78>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 801f778:	2101      	movs	r1, #1
 801f77a:	6878      	ldr	r0, [r7, #4]
 801f77c:	f7f2 fb49 	bl	8011e12 <lv_obj_clear_protect>
}
 801f780:	bf00      	nop
 801f782:	3718      	adds	r7, #24
 801f784:	46bd      	mov	sp, r7
 801f786:	bd80      	pop	{r7, pc}

0801f788 <lv_cont_layout_center>:
/**
 * Handle the center layout
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_center(lv_obj_t * cont)
{
 801f788:	b580      	push	{r7, lr}
 801f78a:	b088      	sub	sp, #32
 801f78c:	af02      	add	r7, sp, #8
 801f78e:	6078      	str	r0, [r7, #4]
    lv_obj_t * child;
    const lv_style_t * style = lv_obj_get_style(cont);
 801f790:	6878      	ldr	r0, [r7, #4]
 801f792:	f7f2 fd2f 	bl	80121f4 <lv_obj_get_style>
 801f796:	60b8      	str	r0, [r7, #8]
    uint32_t obj_num         = 0;
 801f798:	2300      	movs	r3, #0
 801f79a:	613b      	str	r3, [r7, #16]
    lv_coord_t h_tot         = 0;
 801f79c:	2300      	movs	r3, #0
 801f79e:	81fb      	strh	r3, [r7, #14]

    LV_LL_READ(cont->child_ll, child)
 801f7a0:	687b      	ldr	r3, [r7, #4]
 801f7a2:	3304      	adds	r3, #4
 801f7a4:	4618      	mov	r0, r3
 801f7a6:	f7fc ff29 	bl	801c5fc <lv_ll_get_head>
 801f7aa:	6178      	str	r0, [r7, #20]
 801f7ac:	e026      	b.n	801f7fc <lv_cont_layout_center+0x74>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f7ae:	6978      	ldr	r0, [r7, #20]
 801f7b0:	f7f2 fd78 	bl	80122a4 <lv_obj_get_hidden>
 801f7b4:	4603      	mov	r3, r0
 801f7b6:	2b00      	cmp	r3, #0
 801f7b8:	d118      	bne.n	801f7ec <lv_cont_layout_center+0x64>
 801f7ba:	2104      	movs	r1, #4
 801f7bc:	6978      	ldr	r0, [r7, #20]
 801f7be:	f7f2 fe09 	bl	80123d4 <lv_obj_is_protected>
 801f7c2:	4603      	mov	r3, r0
 801f7c4:	2b00      	cmp	r3, #0
 801f7c6:	d111      	bne.n	801f7ec <lv_cont_layout_center+0x64>
        h_tot += lv_obj_get_height(child) + style->body.padding.inner;
 801f7c8:	6978      	ldr	r0, [r7, #20]
 801f7ca:	f7f2 fcf1 	bl	80121b0 <lv_obj_get_height>
 801f7ce:	4603      	mov	r3, r0
 801f7d0:	461a      	mov	r2, r3
 801f7d2:	68bb      	ldr	r3, [r7, #8]
 801f7d4:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801f7d8:	4413      	add	r3, r2
 801f7da:	b29a      	uxth	r2, r3
 801f7dc:	89fb      	ldrh	r3, [r7, #14]
 801f7de:	4413      	add	r3, r2
 801f7e0:	b29b      	uxth	r3, r3
 801f7e2:	81fb      	strh	r3, [r7, #14]
        obj_num++;
 801f7e4:	693b      	ldr	r3, [r7, #16]
 801f7e6:	3301      	adds	r3, #1
 801f7e8:	613b      	str	r3, [r7, #16]
 801f7ea:	e000      	b.n	801f7ee <lv_cont_layout_center+0x66>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f7ec:	bf00      	nop
    LV_LL_READ(cont->child_ll, child)
 801f7ee:	687b      	ldr	r3, [r7, #4]
 801f7f0:	3304      	adds	r3, #4
 801f7f2:	6979      	ldr	r1, [r7, #20]
 801f7f4:	4618      	mov	r0, r3
 801f7f6:	f7fc ff27 	bl	801c648 <lv_ll_get_next>
 801f7fa:	6178      	str	r0, [r7, #20]
 801f7fc:	697b      	ldr	r3, [r7, #20]
 801f7fe:	2b00      	cmp	r3, #0
 801f800:	d1d5      	bne.n	801f7ae <lv_cont_layout_center+0x26>
    }

    if(obj_num == 0) return;
 801f802:	693b      	ldr	r3, [r7, #16]
 801f804:	2b00      	cmp	r3, #0
 801f806:	d05e      	beq.n	801f8c6 <lv_cont_layout_center+0x13e>

    h_tot -= style->body.padding.inner;
 801f808:	89fa      	ldrh	r2, [r7, #14]
 801f80a:	68bb      	ldr	r3, [r7, #8]
 801f80c:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801f810:	b29b      	uxth	r3, r3
 801f812:	1ad3      	subs	r3, r2, r3
 801f814:	b29b      	uxth	r3, r3
 801f816:	81fb      	strh	r3, [r7, #14]

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 801f818:	2101      	movs	r1, #1
 801f81a:	6878      	ldr	r0, [r7, #4]
 801f81c:	f7f2 fae4 	bl	8011de8 <lv_obj_set_protect>

    /* Align the children */
    lv_coord_t last_cord = -(h_tot / 2);
 801f820:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 801f824:	2b00      	cmp	r3, #0
 801f826:	da00      	bge.n	801f82a <lv_cont_layout_center+0xa2>
 801f828:	3301      	adds	r3, #1
 801f82a:	105b      	asrs	r3, r3, #1
 801f82c:	b21b      	sxth	r3, r3
 801f82e:	b29b      	uxth	r3, r3
 801f830:	425b      	negs	r3, r3
 801f832:	b29b      	uxth	r3, r3
 801f834:	81bb      	strh	r3, [r7, #12]
    LV_LL_READ_BACK(cont->child_ll, child)
 801f836:	687b      	ldr	r3, [r7, #4]
 801f838:	3304      	adds	r3, #4
 801f83a:	4618      	mov	r0, r3
 801f83c:	f7fc fef1 	bl	801c622 <lv_ll_get_tail>
 801f840:	6178      	str	r0, [r7, #20]
 801f842:	e038      	b.n	801f8b6 <lv_cont_layout_center+0x12e>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f844:	6978      	ldr	r0, [r7, #20]
 801f846:	f7f2 fd2d 	bl	80122a4 <lv_obj_get_hidden>
 801f84a:	4603      	mov	r3, r0
 801f84c:	2b00      	cmp	r3, #0
 801f84e:	d12a      	bne.n	801f8a6 <lv_cont_layout_center+0x11e>
 801f850:	2104      	movs	r1, #4
 801f852:	6978      	ldr	r0, [r7, #20]
 801f854:	f7f2 fdbe 	bl	80123d4 <lv_obj_is_protected>
 801f858:	4603      	mov	r3, r0
 801f85a:	2b00      	cmp	r3, #0
 801f85c:	d123      	bne.n	801f8a6 <lv_cont_layout_center+0x11e>

        lv_obj_align(child, cont, LV_ALIGN_CENTER, 0, last_cord + lv_obj_get_height(child) / 2);
 801f85e:	6978      	ldr	r0, [r7, #20]
 801f860:	f7f2 fca6 	bl	80121b0 <lv_obj_get_height>
 801f864:	4603      	mov	r3, r0
 801f866:	2b00      	cmp	r3, #0
 801f868:	da00      	bge.n	801f86c <lv_cont_layout_center+0xe4>
 801f86a:	3301      	adds	r3, #1
 801f86c:	105b      	asrs	r3, r3, #1
 801f86e:	b21b      	sxth	r3, r3
 801f870:	b29a      	uxth	r2, r3
 801f872:	89bb      	ldrh	r3, [r7, #12]
 801f874:	4413      	add	r3, r2
 801f876:	b29b      	uxth	r3, r3
 801f878:	b21b      	sxth	r3, r3
 801f87a:	9300      	str	r3, [sp, #0]
 801f87c:	2300      	movs	r3, #0
 801f87e:	2200      	movs	r2, #0
 801f880:	6879      	ldr	r1, [r7, #4]
 801f882:	6978      	ldr	r0, [r7, #20]
 801f884:	f7f1 fd3c 	bl	8011300 <lv_obj_align>
        last_cord += lv_obj_get_height(child) + style->body.padding.inner;
 801f888:	6978      	ldr	r0, [r7, #20]
 801f88a:	f7f2 fc91 	bl	80121b0 <lv_obj_get_height>
 801f88e:	4603      	mov	r3, r0
 801f890:	461a      	mov	r2, r3
 801f892:	68bb      	ldr	r3, [r7, #8]
 801f894:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801f898:	4413      	add	r3, r2
 801f89a:	b29a      	uxth	r2, r3
 801f89c:	89bb      	ldrh	r3, [r7, #12]
 801f89e:	4413      	add	r3, r2
 801f8a0:	b29b      	uxth	r3, r3
 801f8a2:	81bb      	strh	r3, [r7, #12]
 801f8a4:	e000      	b.n	801f8a8 <lv_cont_layout_center+0x120>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801f8a6:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 801f8a8:	687b      	ldr	r3, [r7, #4]
 801f8aa:	3304      	adds	r3, #4
 801f8ac:	6979      	ldr	r1, [r7, #20]
 801f8ae:	4618      	mov	r0, r3
 801f8b0:	f7fc fee4 	bl	801c67c <lv_ll_get_prev>
 801f8b4:	6178      	str	r0, [r7, #20]
 801f8b6:	697b      	ldr	r3, [r7, #20]
 801f8b8:	2b00      	cmp	r3, #0
 801f8ba:	d1c3      	bne.n	801f844 <lv_cont_layout_center+0xbc>
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 801f8bc:	2101      	movs	r1, #1
 801f8be:	6878      	ldr	r0, [r7, #4]
 801f8c0:	f7f2 faa7 	bl	8011e12 <lv_obj_clear_protect>
 801f8c4:	e000      	b.n	801f8c8 <lv_cont_layout_center+0x140>
    if(obj_num == 0) return;
 801f8c6:	bf00      	nop
}
 801f8c8:	3718      	adds	r7, #24
 801f8ca:	46bd      	mov	sp, r7
 801f8cc:	bd80      	pop	{r7, pc}
	...

0801f8d0 <lv_cont_layout_pretty>:
 * Handle the pretty layout. Put as many object as possible in row
 * then begin a new row
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_pretty(lv_obj_t * cont)
{
 801f8d0:	b5b0      	push	{r4, r5, r7, lr}
 801f8d2:	b090      	sub	sp, #64	; 0x40
 801f8d4:	af02      	add	r7, sp, #8
 801f8d6:	6078      	str	r0, [r7, #4]
    lv_obj_t * child_rs;  /* Row starter child */
    lv_obj_t * child_rc;  /* Row closer child */
    lv_obj_t * child_tmp; /* Temporary child */
    const lv_style_t * style = lv_obj_get_style(cont);
 801f8d8:	6878      	ldr	r0, [r7, #4]
 801f8da:	f7f2 fc8b 	bl	80121f4 <lv_obj_get_style>
 801f8de:	61b8      	str	r0, [r7, #24]
    lv_coord_t w_obj         = lv_obj_get_width(cont);
 801f8e0:	6878      	ldr	r0, [r7, #4]
 801f8e2:	f7f2 fc57 	bl	8012194 <lv_obj_get_width>
 801f8e6:	4603      	mov	r3, r0
 801f8e8:	82fb      	strh	r3, [r7, #22]
    lv_coord_t act_y         = style->body.padding.top;
 801f8ea:	69bb      	ldr	r3, [r7, #24]
 801f8ec:	8adb      	ldrh	r3, [r3, #22]
 801f8ee:	857b      	strh	r3, [r7, #42]	; 0x2a
    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/

    child_rs = lv_ll_get_tail(&cont->child_ll); /*Set the row starter child*/
 801f8f0:	687b      	ldr	r3, [r7, #4]
 801f8f2:	3304      	adds	r3, #4
 801f8f4:	4618      	mov	r0, r3
 801f8f6:	f7fc fe94 	bl	801c622 <lv_ll_get_tail>
 801f8fa:	6378      	str	r0, [r7, #52]	; 0x34
    if(child_rs == NULL) return;                /*Return if no child*/
 801f8fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801f8fe:	2b00      	cmp	r3, #0
 801f900:	f000 8183 	beq.w	801fc0a <lv_cont_layout_pretty+0x33a>

    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 801f904:	2101      	movs	r1, #1
 801f906:	6878      	ldr	r0, [r7, #4]
 801f908:	f7f2 fa6e 	bl	8011de8 <lv_obj_set_protect>

    child_rc = child_rs; /*Initially the the row starter and closer is the same*/
 801f90c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801f90e:	633b      	str	r3, [r7, #48]	; 0x30
    while(child_rs != NULL) {
 801f910:	e170      	b.n	801fbf4 <lv_cont_layout_pretty+0x324>
        lv_coord_t h_row = 0;
 801f912:	2300      	movs	r3, #0
 801f914:	853b      	strh	r3, [r7, #40]	; 0x28
        lv_coord_t w_row =
            style->body.padding.left + style->body.padding.right; /*The width is at least the left+right hpad*/
 801f916:	69bb      	ldr	r3, [r7, #24]
 801f918:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801f91c:	b29a      	uxth	r2, r3
 801f91e:	69bb      	ldr	r3, [r7, #24]
 801f920:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801f924:	b29b      	uxth	r3, r3
 801f926:	4413      	add	r3, r2
 801f928:	b29b      	uxth	r3, r3
        lv_coord_t w_row =
 801f92a:	84fb      	strh	r3, [r7, #38]	; 0x26
        uint32_t obj_num = 0;
 801f92c:	2300      	movs	r3, #0
 801f92e:	623b      	str	r3, [r7, #32]

        /*Find the row closer object and collect some data*/
        do {
            if(lv_obj_get_hidden(child_rc) == false && lv_obj_is_protected(child_rc, LV_PROTECT_POS) == false) {
 801f930:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f932:	f7f2 fcb7 	bl	80122a4 <lv_obj_get_hidden>
 801f936:	4603      	mov	r3, r0
 801f938:	f083 0301 	eor.w	r3, r3, #1
 801f93c:	b2db      	uxtb	r3, r3
 801f93e:	2b00      	cmp	r3, #0
 801f940:	d04b      	beq.n	801f9da <lv_cont_layout_pretty+0x10a>
 801f942:	2104      	movs	r1, #4
 801f944:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f946:	f7f2 fd45 	bl	80123d4 <lv_obj_is_protected>
 801f94a:	4603      	mov	r3, r0
 801f94c:	f083 0301 	eor.w	r3, r3, #1
 801f950:	b2db      	uxtb	r3, r3
 801f952:	2b00      	cmp	r3, #0
 801f954:	d041      	beq.n	801f9da <lv_cont_layout_pretty+0x10a>
                /*If this object is already not fit then break*/
                if(w_row + lv_obj_get_width(child_rc) > w_obj) {
 801f956:	f9b7 4026 	ldrsh.w	r4, [r7, #38]	; 0x26
 801f95a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f95c:	f7f2 fc1a 	bl	8012194 <lv_obj_get_width>
 801f960:	4603      	mov	r3, r0
 801f962:	18e2      	adds	r2, r4, r3
 801f964:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801f968:	429a      	cmp	r2, r3
 801f96a:	dd0d      	ble.n	801f988 <lv_cont_layout_pretty+0xb8>
                    /*Step back one child because the last already not fit, so the previous is the
                     * closer*/
                    if(child_rc != NULL && obj_num != 0) {
 801f96c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801f96e:	2b00      	cmp	r3, #0
 801f970:	d043      	beq.n	801f9fa <lv_cont_layout_pretty+0x12a>
 801f972:	6a3b      	ldr	r3, [r7, #32]
 801f974:	2b00      	cmp	r3, #0
 801f976:	d040      	beq.n	801f9fa <lv_cont_layout_pretty+0x12a>
                        child_rc = lv_ll_get_next(&cont->child_ll, child_rc);
 801f978:	687b      	ldr	r3, [r7, #4]
 801f97a:	3304      	adds	r3, #4
 801f97c:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f97e:	4618      	mov	r0, r3
 801f980:	f7fc fe62 	bl	801c648 <lv_ll_get_next>
 801f984:	6338      	str	r0, [r7, #48]	; 0x30
                    }
                    break;
 801f986:	e038      	b.n	801f9fa <lv_cont_layout_pretty+0x12a>
                }
                w_row += lv_obj_get_width(child_rc) + style->body.padding.inner; /*Add the object width + opad*/
 801f988:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f98a:	f7f2 fc03 	bl	8012194 <lv_obj_get_width>
 801f98e:	4603      	mov	r3, r0
 801f990:	461a      	mov	r2, r3
 801f992:	69bb      	ldr	r3, [r7, #24]
 801f994:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801f998:	4413      	add	r3, r2
 801f99a:	b29a      	uxth	r2, r3
 801f99c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 801f99e:	4413      	add	r3, r2
 801f9a0:	b29b      	uxth	r3, r3
 801f9a2:	84fb      	strh	r3, [r7, #38]	; 0x26
                h_row = LV_MATH_MAX(h_row, lv_obj_get_height(child_rc));         /*Search the highest object*/
 801f9a4:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f9a6:	f7f2 fc03 	bl	80121b0 <lv_obj_get_height>
 801f9aa:	4603      	mov	r3, r0
 801f9ac:	461a      	mov	r2, r3
 801f9ae:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801f9b2:	4293      	cmp	r3, r2
 801f9b4:	dc04      	bgt.n	801f9c0 <lv_cont_layout_pretty+0xf0>
 801f9b6:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f9b8:	f7f2 fbfa 	bl	80121b0 <lv_obj_get_height>
 801f9bc:	4603      	mov	r3, r0
 801f9be:	e001      	b.n	801f9c4 <lv_cont_layout_pretty+0xf4>
 801f9c0:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 801f9c4:	853b      	strh	r3, [r7, #40]	; 0x28
                obj_num++;
 801f9c6:	6a3b      	ldr	r3, [r7, #32]
 801f9c8:	3301      	adds	r3, #1
 801f9ca:	623b      	str	r3, [r7, #32]
                if(lv_obj_is_protected(child_rc, LV_PROTECT_FOLLOW))
 801f9cc:	2108      	movs	r1, #8
 801f9ce:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801f9d0:	f7f2 fd00 	bl	80123d4 <lv_obj_is_protected>
 801f9d4:	4603      	mov	r3, r0
 801f9d6:	2b00      	cmp	r3, #0
 801f9d8:	d111      	bne.n	801f9fe <lv_cont_layout_pretty+0x12e>
                    break; /*If can not be followed by an other object then break here*/
            }
            child_rc = lv_ll_get_prev(&cont->child_ll, child_rc); /*Load the next object*/
 801f9da:	687b      	ldr	r3, [r7, #4]
 801f9dc:	3304      	adds	r3, #4
 801f9de:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801f9e0:	4618      	mov	r0, r3
 801f9e2:	f7fc fe4b 	bl	801c67c <lv_ll_get_prev>
 801f9e6:	6338      	str	r0, [r7, #48]	; 0x30
            if(obj_num == 0)
 801f9e8:	6a3b      	ldr	r3, [r7, #32]
 801f9ea:	2b00      	cmp	r3, #0
 801f9ec:	d101      	bne.n	801f9f2 <lv_cont_layout_pretty+0x122>
                child_rs = child_rc; /*If the first object was hidden (or too long) then set the
 801f9ee:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801f9f0:	637b      	str	r3, [r7, #52]	; 0x34
                                        next as first */
        } while(child_rc != NULL);
 801f9f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801f9f4:	2b00      	cmp	r3, #0
 801f9f6:	d19b      	bne.n	801f930 <lv_cont_layout_pretty+0x60>
 801f9f8:	e002      	b.n	801fa00 <lv_cont_layout_pretty+0x130>
                    break;
 801f9fa:	bf00      	nop
 801f9fc:	e000      	b.n	801fa00 <lv_cont_layout_pretty+0x130>
                    break; /*If can not be followed by an other object then break here*/
 801f9fe:	bf00      	nop

        /*If the object is too long  then align it to the middle*/
        if(obj_num == 0) {
 801fa00:	6a3b      	ldr	r3, [r7, #32]
 801fa02:	2b00      	cmp	r3, #0
 801fa04:	d112      	bne.n	801fa2c <lv_cont_layout_pretty+0x15c>
            if(child_rc != NULL) {
 801fa06:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801fa08:	2b00      	cmp	r3, #0
 801fa0a:	f000 80dc 	beq.w	801fbc6 <lv_cont_layout_pretty+0x2f6>
                lv_obj_align(child_rc, cont, LV_ALIGN_IN_TOP_MID, 0, act_y);
 801fa0e:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801fa12:	9300      	str	r3, [sp, #0]
 801fa14:	2300      	movs	r3, #0
 801fa16:	2202      	movs	r2, #2
 801fa18:	6879      	ldr	r1, [r7, #4]
 801fa1a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801fa1c:	f7f1 fc70 	bl	8011300 <lv_obj_align>
                h_row = lv_obj_get_height(child_rc); /*Not set previously because of the early break*/
 801fa20:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801fa22:	f7f2 fbc5 	bl	80121b0 <lv_obj_get_height>
 801fa26:	4603      	mov	r3, r0
 801fa28:	853b      	strh	r3, [r7, #40]	; 0x28
 801fa2a:	e0cc      	b.n	801fbc6 <lv_cont_layout_pretty+0x2f6>
            }
        }
        /*If there is only one object in the row then align it to the middle*/
        else if(obj_num == 1) {
 801fa2c:	6a3b      	ldr	r3, [r7, #32]
 801fa2e:	2b01      	cmp	r3, #1
 801fa30:	d109      	bne.n	801fa46 <lv_cont_layout_pretty+0x176>
            lv_obj_align(child_rs, cont, LV_ALIGN_IN_TOP_MID, 0, act_y);
 801fa32:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 801fa36:	9300      	str	r3, [sp, #0]
 801fa38:	2300      	movs	r3, #0
 801fa3a:	2202      	movs	r2, #2
 801fa3c:	6879      	ldr	r1, [r7, #4]
 801fa3e:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801fa40:	f7f1 fc5e 	bl	8011300 <lv_obj_align>
 801fa44:	e0bf      	b.n	801fbc6 <lv_cont_layout_pretty+0x2f6>
        }
        /*If there are two object in the row then align them proportionally*/
        else if(obj_num == 2) {
 801fa46:	6a3b      	ldr	r3, [r7, #32]
 801fa48:	2b02      	cmp	r3, #2
 801fa4a:	d155      	bne.n	801faf8 <lv_cont_layout_pretty+0x228>
            lv_obj_t * obj1 = child_rs;
 801fa4c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801fa4e:	613b      	str	r3, [r7, #16]
            lv_obj_t * obj2 = lv_ll_get_prev(&cont->child_ll, child_rs);
 801fa50:	687b      	ldr	r3, [r7, #4]
 801fa52:	3304      	adds	r3, #4
 801fa54:	6b79      	ldr	r1, [r7, #52]	; 0x34
 801fa56:	4618      	mov	r0, r3
 801fa58:	f7fc fe10 	bl	801c67c <lv_ll_get_prev>
 801fa5c:	60f8      	str	r0, [r7, #12]
            w_row           = lv_obj_get_width(obj1) + lv_obj_get_width(obj2);
 801fa5e:	6938      	ldr	r0, [r7, #16]
 801fa60:	f7f2 fb98 	bl	8012194 <lv_obj_get_width>
 801fa64:	4603      	mov	r3, r0
 801fa66:	b29c      	uxth	r4, r3
 801fa68:	68f8      	ldr	r0, [r7, #12]
 801fa6a:	f7f2 fb93 	bl	8012194 <lv_obj_get_width>
 801fa6e:	4603      	mov	r3, r0
 801fa70:	b29b      	uxth	r3, r3
 801fa72:	4423      	add	r3, r4
 801fa74:	b29b      	uxth	r3, r3
 801fa76:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_coord_t pad  = (w_obj - w_row) / 3;
 801fa78:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 801fa7c:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801fa80:	1ad3      	subs	r3, r2, r3
 801fa82:	4a64      	ldr	r2, [pc, #400]	; (801fc14 <lv_cont_layout_pretty+0x344>)
 801fa84:	fb82 1203 	smull	r1, r2, r2, r3
 801fa88:	17db      	asrs	r3, r3, #31
 801fa8a:	1ad3      	subs	r3, r2, r3
 801fa8c:	817b      	strh	r3, [r7, #10]
            lv_obj_align(obj1, cont, LV_ALIGN_IN_TOP_LEFT, pad, act_y + (h_row - lv_obj_get_height(obj1)) / 2);
 801fa8e:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 801fa92:	6938      	ldr	r0, [r7, #16]
 801fa94:	f7f2 fb8c 	bl	80121b0 <lv_obj_get_height>
 801fa98:	4603      	mov	r3, r0
 801fa9a:	1ae3      	subs	r3, r4, r3
 801fa9c:	2b00      	cmp	r3, #0
 801fa9e:	da00      	bge.n	801faa2 <lv_cont_layout_pretty+0x1d2>
 801faa0:	3301      	adds	r3, #1
 801faa2:	105b      	asrs	r3, r3, #1
 801faa4:	b29a      	uxth	r2, r3
 801faa6:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801faa8:	4413      	add	r3, r2
 801faaa:	b29b      	uxth	r3, r3
 801faac:	b21b      	sxth	r3, r3
 801faae:	f9b7 200a 	ldrsh.w	r2, [r7, #10]
 801fab2:	9300      	str	r3, [sp, #0]
 801fab4:	4613      	mov	r3, r2
 801fab6:	2201      	movs	r2, #1
 801fab8:	6879      	ldr	r1, [r7, #4]
 801faba:	6938      	ldr	r0, [r7, #16]
 801fabc:	f7f1 fc20 	bl	8011300 <lv_obj_align>
            lv_obj_align(obj2, cont, LV_ALIGN_IN_TOP_RIGHT, -pad, act_y + (h_row - lv_obj_get_height(obj2)) / 2);
 801fac0:	897b      	ldrh	r3, [r7, #10]
 801fac2:	425b      	negs	r3, r3
 801fac4:	b29b      	uxth	r3, r3
 801fac6:	b21d      	sxth	r5, r3
 801fac8:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 801facc:	68f8      	ldr	r0, [r7, #12]
 801face:	f7f2 fb6f 	bl	80121b0 <lv_obj_get_height>
 801fad2:	4603      	mov	r3, r0
 801fad4:	1ae3      	subs	r3, r4, r3
 801fad6:	2b00      	cmp	r3, #0
 801fad8:	da00      	bge.n	801fadc <lv_cont_layout_pretty+0x20c>
 801fada:	3301      	adds	r3, #1
 801fadc:	105b      	asrs	r3, r3, #1
 801fade:	b29a      	uxth	r2, r3
 801fae0:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801fae2:	4413      	add	r3, r2
 801fae4:	b29b      	uxth	r3, r3
 801fae6:	b21b      	sxth	r3, r3
 801fae8:	9300      	str	r3, [sp, #0]
 801faea:	462b      	mov	r3, r5
 801faec:	2203      	movs	r2, #3
 801faee:	6879      	ldr	r1, [r7, #4]
 801faf0:	68f8      	ldr	r0, [r7, #12]
 801faf2:	f7f1 fc05 	bl	8011300 <lv_obj_align>
 801faf6:	e066      	b.n	801fbc6 <lv_cont_layout_pretty+0x2f6>
        }
        /* Align the children (from child_rs to child_rc)*/
        else {
            w_row -= style->body.padding.inner * obj_num;
 801faf8:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 801fafa:	69bb      	ldr	r3, [r7, #24]
 801fafc:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801fb00:	b299      	uxth	r1, r3
 801fb02:	6a3b      	ldr	r3, [r7, #32]
 801fb04:	b29b      	uxth	r3, r3
 801fb06:	fb11 f303 	smulbb	r3, r1, r3
 801fb0a:	b29b      	uxth	r3, r3
 801fb0c:	1ad3      	subs	r3, r2, r3
 801fb0e:	b29b      	uxth	r3, r3
 801fb10:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_coord_t new_opad = (w_obj - w_row) / (obj_num - 1);
 801fb12:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 801fb16:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801fb1a:	1ad3      	subs	r3, r2, r3
 801fb1c:	461a      	mov	r2, r3
 801fb1e:	6a3b      	ldr	r3, [r7, #32]
 801fb20:	3b01      	subs	r3, #1
 801fb22:	fbb2 f3f3 	udiv	r3, r2, r3
 801fb26:	82bb      	strh	r3, [r7, #20]
            lv_coord_t act_x    = style->body.padding.left; /*x init*/
 801fb28:	69bb      	ldr	r3, [r7, #24]
 801fb2a:	8b5b      	ldrh	r3, [r3, #26]
 801fb2c:	83fb      	strh	r3, [r7, #30]
            child_tmp           = child_rs;
 801fb2e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801fb30:	62fb      	str	r3, [r7, #44]	; 0x2c
            while(child_tmp != NULL) {
 801fb32:	e043      	b.n	801fbbc <lv_cont_layout_pretty+0x2ec>
                if(lv_obj_get_hidden(child_tmp) == false && lv_obj_is_protected(child_tmp, LV_PROTECT_POS) == false) {
 801fb34:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801fb36:	f7f2 fbb5 	bl	80122a4 <lv_obj_get_hidden>
 801fb3a:	4603      	mov	r3, r0
 801fb3c:	f083 0301 	eor.w	r3, r3, #1
 801fb40:	b2db      	uxtb	r3, r3
 801fb42:	2b00      	cmp	r3, #0
 801fb44:	d02f      	beq.n	801fba6 <lv_cont_layout_pretty+0x2d6>
 801fb46:	2104      	movs	r1, #4
 801fb48:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801fb4a:	f7f2 fc43 	bl	80123d4 <lv_obj_is_protected>
 801fb4e:	4603      	mov	r3, r0
 801fb50:	f083 0301 	eor.w	r3, r3, #1
 801fb54:	b2db      	uxtb	r3, r3
 801fb56:	2b00      	cmp	r3, #0
 801fb58:	d025      	beq.n	801fba6 <lv_cont_layout_pretty+0x2d6>
                    lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT, act_x,
                                 act_y + (h_row - lv_obj_get_height(child_tmp)) / 2);
 801fb5a:	f9b7 4028 	ldrsh.w	r4, [r7, #40]	; 0x28
 801fb5e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801fb60:	f7f2 fb26 	bl	80121b0 <lv_obj_get_height>
 801fb64:	4603      	mov	r3, r0
 801fb66:	1ae3      	subs	r3, r4, r3
 801fb68:	2b00      	cmp	r3, #0
 801fb6a:	da00      	bge.n	801fb6e <lv_cont_layout_pretty+0x29e>
 801fb6c:	3301      	adds	r3, #1
 801fb6e:	105b      	asrs	r3, r3, #1
 801fb70:	b29a      	uxth	r2, r3
 801fb72:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801fb74:	4413      	add	r3, r2
 801fb76:	b29b      	uxth	r3, r3
                    lv_obj_align(child_tmp, cont, LV_ALIGN_IN_TOP_LEFT, act_x,
 801fb78:	b21b      	sxth	r3, r3
 801fb7a:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 801fb7e:	9300      	str	r3, [sp, #0]
 801fb80:	4613      	mov	r3, r2
 801fb82:	2201      	movs	r2, #1
 801fb84:	6879      	ldr	r1, [r7, #4]
 801fb86:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801fb88:	f7f1 fbba 	bl	8011300 <lv_obj_align>
                    act_x += lv_obj_get_width(child_tmp) + new_opad;
 801fb8c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 801fb8e:	f7f2 fb01 	bl	8012194 <lv_obj_get_width>
 801fb92:	4603      	mov	r3, r0
 801fb94:	461a      	mov	r2, r3
 801fb96:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801fb9a:	4413      	add	r3, r2
 801fb9c:	b29a      	uxth	r2, r3
 801fb9e:	8bfb      	ldrh	r3, [r7, #30]
 801fba0:	4413      	add	r3, r2
 801fba2:	b29b      	uxth	r3, r3
 801fba4:	83fb      	strh	r3, [r7, #30]
                }
                if(child_tmp == child_rc) break;
 801fba6:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 801fba8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801fbaa:	429a      	cmp	r2, r3
 801fbac:	d00a      	beq.n	801fbc4 <lv_cont_layout_pretty+0x2f4>
                child_tmp = lv_ll_get_prev(&cont->child_ll, child_tmp);
 801fbae:	687b      	ldr	r3, [r7, #4]
 801fbb0:	3304      	adds	r3, #4
 801fbb2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 801fbb4:	4618      	mov	r0, r3
 801fbb6:	f7fc fd61 	bl	801c67c <lv_ll_get_prev>
 801fbba:	62f8      	str	r0, [r7, #44]	; 0x2c
            while(child_tmp != NULL) {
 801fbbc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fbbe:	2b00      	cmp	r3, #0
 801fbc0:	d1b8      	bne.n	801fb34 <lv_cont_layout_pretty+0x264>
 801fbc2:	e000      	b.n	801fbc6 <lv_cont_layout_pretty+0x2f6>
                if(child_tmp == child_rc) break;
 801fbc4:	bf00      	nop
            }
        }

        if(child_rc == NULL) break;
 801fbc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801fbc8:	2b00      	cmp	r3, #0
 801fbca:	d018      	beq.n	801fbfe <lv_cont_layout_pretty+0x32e>
        act_y += style->body.padding.inner + h_row;           /*y increment*/
 801fbcc:	69bb      	ldr	r3, [r7, #24]
 801fbce:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801fbd2:	b29a      	uxth	r2, r3
 801fbd4:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 801fbd6:	4413      	add	r3, r2
 801fbd8:	b29a      	uxth	r2, r3
 801fbda:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 801fbdc:	4413      	add	r3, r2
 801fbde:	b29b      	uxth	r3, r3
 801fbe0:	857b      	strh	r3, [r7, #42]	; 0x2a
        child_rs = lv_ll_get_prev(&cont->child_ll, child_rc); /*Go to the next object*/
 801fbe2:	687b      	ldr	r3, [r7, #4]
 801fbe4:	3304      	adds	r3, #4
 801fbe6:	6b39      	ldr	r1, [r7, #48]	; 0x30
 801fbe8:	4618      	mov	r0, r3
 801fbea:	f7fc fd47 	bl	801c67c <lv_ll_get_prev>
 801fbee:	6378      	str	r0, [r7, #52]	; 0x34
        child_rc = child_rs;
 801fbf0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801fbf2:	633b      	str	r3, [r7, #48]	; 0x30
    while(child_rs != NULL) {
 801fbf4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801fbf6:	2b00      	cmp	r3, #0
 801fbf8:	f47f ae8b 	bne.w	801f912 <lv_cont_layout_pretty+0x42>
 801fbfc:	e000      	b.n	801fc00 <lv_cont_layout_pretty+0x330>
        if(child_rc == NULL) break;
 801fbfe:	bf00      	nop
    }
    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 801fc00:	2101      	movs	r1, #1
 801fc02:	6878      	ldr	r0, [r7, #4]
 801fc04:	f7f2 f905 	bl	8011e12 <lv_obj_clear_protect>
 801fc08:	e000      	b.n	801fc0c <lv_cont_layout_pretty+0x33c>
    if(child_rs == NULL) return;                /*Return if no child*/
 801fc0a:	bf00      	nop
}
 801fc0c:	3738      	adds	r7, #56	; 0x38
 801fc0e:	46bd      	mov	sp, r7
 801fc10:	bdb0      	pop	{r4, r5, r7, pc}
 801fc12:	bf00      	nop
 801fc14:	55555556 	.word	0x55555556

0801fc18 <lv_cont_layout_grid>:
/**
 * Handle the grid layout. Align same-sized objects in a grid
 * @param cont pointer to an object which layout should be handled
 */
static void lv_cont_layout_grid(lv_obj_t * cont)
{
 801fc18:	b580      	push	{r7, lr}
 801fc1a:	b08a      	sub	sp, #40	; 0x28
 801fc1c:	af00      	add	r7, sp, #0
 801fc1e:	6078      	str	r0, [r7, #4]
    lv_obj_t * child;
    const lv_style_t * style = lv_obj_get_style(cont);
 801fc20:	6878      	ldr	r0, [r7, #4]
 801fc22:	f7f2 fae7 	bl	80121f4 <lv_obj_get_style>
 801fc26:	61b8      	str	r0, [r7, #24]
    lv_coord_t w_tot         = lv_obj_get_width(cont);
 801fc28:	6878      	ldr	r0, [r7, #4]
 801fc2a:	f7f2 fab3 	bl	8012194 <lv_obj_get_width>
 801fc2e:	4603      	mov	r3, r0
 801fc30:	82fb      	strh	r3, [r7, #22]
    lv_coord_t w_obj         = lv_obj_get_width(lv_obj_get_child(cont, NULL));
 801fc32:	2100      	movs	r1, #0
 801fc34:	6878      	ldr	r0, [r7, #4]
 801fc36:	f7f2 fa4f 	bl	80120d8 <lv_obj_get_child>
 801fc3a:	4603      	mov	r3, r0
 801fc3c:	4618      	mov	r0, r3
 801fc3e:	f7f2 faa9 	bl	8012194 <lv_obj_get_width>
 801fc42:	4603      	mov	r3, r0
 801fc44:	82bb      	strh	r3, [r7, #20]
    lv_coord_t h_obj         = lv_obj_get_height(lv_obj_get_child(cont, NULL));
 801fc46:	2100      	movs	r1, #0
 801fc48:	6878      	ldr	r0, [r7, #4]
 801fc4a:	f7f2 fa45 	bl	80120d8 <lv_obj_get_child>
 801fc4e:	4603      	mov	r3, r0
 801fc50:	4618      	mov	r0, r3
 801fc52:	f7f2 faad 	bl	80121b0 <lv_obj_get_height>
 801fc56:	4603      	mov	r3, r0
 801fc58:	827b      	strh	r3, [r7, #18]
    uint16_t obj_row         = (w_tot - style->body.padding.left - style->body.padding.right) /
 801fc5a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801fc5e:	69ba      	ldr	r2, [r7, #24]
 801fc60:	f9b2 201a 	ldrsh.w	r2, [r2, #26]
 801fc64:	1a9b      	subs	r3, r3, r2
 801fc66:	69ba      	ldr	r2, [r7, #24]
 801fc68:	f9b2 201c 	ldrsh.w	r2, [r2, #28]
 801fc6c:	1a9a      	subs	r2, r3, r2
                       (w_obj + style->body.padding.inner); /*Obj. num. in a row*/
 801fc6e:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801fc72:	69b9      	ldr	r1, [r7, #24]
 801fc74:	f9b1 101e 	ldrsh.w	r1, [r1, #30]
 801fc78:	440b      	add	r3, r1
    uint16_t obj_row         = (w_tot - style->body.padding.left - style->body.padding.right) /
 801fc7a:	fb92 f3f3 	sdiv	r3, r2, r3
 801fc7e:	823b      	strh	r3, [r7, #16]
    lv_coord_t x_ofs;
    if(obj_row > 1) {
 801fc80:	8a3b      	ldrh	r3, [r7, #16]
 801fc82:	2b01      	cmp	r3, #1
 801fc84:	d918      	bls.n	801fcb8 <lv_cont_layout_grid+0xa0>
        x_ofs = (w_obj + (w_tot - style->body.padding.left - style->body.padding.right) - (obj_row * w_obj)) /
 801fc86:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 801fc8a:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801fc8e:	69b9      	ldr	r1, [r7, #24]
 801fc90:	f9b1 101a 	ldrsh.w	r1, [r1, #26]
 801fc94:	1a5b      	subs	r3, r3, r1
 801fc96:	69b9      	ldr	r1, [r7, #24]
 801fc98:	f9b1 101c 	ldrsh.w	r1, [r1, #28]
 801fc9c:	1a5b      	subs	r3, r3, r1
 801fc9e:	441a      	add	r2, r3
 801fca0:	8a3b      	ldrh	r3, [r7, #16]
 801fca2:	f9b7 1014 	ldrsh.w	r1, [r7, #20]
 801fca6:	fb01 f303 	mul.w	r3, r1, r3
 801fcaa:	1ad2      	subs	r2, r2, r3
                (obj_row - 1);
 801fcac:	8a3b      	ldrh	r3, [r7, #16]
 801fcae:	3b01      	subs	r3, #1
        x_ofs = (w_obj + (w_tot - style->body.padding.left - style->body.padding.right) - (obj_row * w_obj)) /
 801fcb0:	fb92 f3f3 	sdiv	r3, r2, r3
 801fcb4:	847b      	strh	r3, [r7, #34]	; 0x22
 801fcb6:	e012      	b.n	801fcde <lv_cont_layout_grid+0xc6>
    } else {
        x_ofs = w_tot / 2 - w_obj / 2;
 801fcb8:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801fcbc:	2b00      	cmp	r3, #0
 801fcbe:	da00      	bge.n	801fcc2 <lv_cont_layout_grid+0xaa>
 801fcc0:	3301      	adds	r3, #1
 801fcc2:	105b      	asrs	r3, r3, #1
 801fcc4:	b21b      	sxth	r3, r3
 801fcc6:	b29a      	uxth	r2, r3
 801fcc8:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801fccc:	2b00      	cmp	r3, #0
 801fcce:	da00      	bge.n	801fcd2 <lv_cont_layout_grid+0xba>
 801fcd0:	3301      	adds	r3, #1
 801fcd2:	105b      	asrs	r3, r3, #1
 801fcd4:	b21b      	sxth	r3, r3
 801fcd6:	b29b      	uxth	r3, r3
 801fcd8:	1ad3      	subs	r3, r2, r3
 801fcda:	b29b      	uxth	r3, r3
 801fcdc:	847b      	strh	r3, [r7, #34]	; 0x22
    }
    lv_coord_t y_ofs = h_obj + style->body.padding.inner;
 801fcde:	69bb      	ldr	r3, [r7, #24]
 801fce0:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 801fce4:	b29a      	uxth	r2, r3
 801fce6:	8a7b      	ldrh	r3, [r7, #18]
 801fce8:	4413      	add	r3, r2
 801fcea:	b29b      	uxth	r3, r3
 801fcec:	81fb      	strh	r3, [r7, #14]

    /* Disable child change action because the children will be moved a lot
     * an unnecessary child change signals could be sent*/
    lv_obj_set_protect(cont, LV_PROTECT_CHILD_CHG);
 801fcee:	2101      	movs	r1, #1
 801fcf0:	6878      	ldr	r0, [r7, #4]
 801fcf2:	f7f2 f879 	bl	8011de8 <lv_obj_set_protect>

    /* Align the children */
    lv_coord_t act_x = style->body.padding.left;
 801fcf6:	69bb      	ldr	r3, [r7, #24]
 801fcf8:	8b5b      	ldrh	r3, [r3, #26]
 801fcfa:	843b      	strh	r3, [r7, #32]
    lv_coord_t act_y = style->body.padding.top;
 801fcfc:	69bb      	ldr	r3, [r7, #24]
 801fcfe:	8adb      	ldrh	r3, [r3, #22]
 801fd00:	83fb      	strh	r3, [r7, #30]
    uint16_t obj_cnt = 0;
 801fd02:	2300      	movs	r3, #0
 801fd04:	83bb      	strh	r3, [r7, #28]
    LV_LL_READ_BACK(cont->child_ll, child)
 801fd06:	687b      	ldr	r3, [r7, #4]
 801fd08:	3304      	adds	r3, #4
 801fd0a:	4618      	mov	r0, r3
 801fd0c:	f7fc fc89 	bl	801c622 <lv_ll_get_tail>
 801fd10:	6278      	str	r0, [r7, #36]	; 0x24
 801fd12:	e03f      	b.n	801fd94 <lv_cont_layout_grid+0x17c>
    {
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801fd14:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801fd16:	f7f2 fac5 	bl	80122a4 <lv_obj_get_hidden>
 801fd1a:	4603      	mov	r3, r0
 801fd1c:	2b00      	cmp	r3, #0
 801fd1e:	d131      	bne.n	801fd84 <lv_cont_layout_grid+0x16c>
 801fd20:	2104      	movs	r1, #4
 801fd22:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801fd24:	f7f2 fb56 	bl	80123d4 <lv_obj_is_protected>
 801fd28:	4603      	mov	r3, r0
 801fd2a:	2b00      	cmp	r3, #0
 801fd2c:	d12a      	bne.n	801fd84 <lv_cont_layout_grid+0x16c>

        if(obj_row > 1) {
 801fd2e:	8a3b      	ldrh	r3, [r7, #16]
 801fd30:	2b01      	cmp	r3, #1
 801fd32:	d90d      	bls.n	801fd50 <lv_cont_layout_grid+0x138>
            lv_obj_set_pos(child, act_x, act_y);
 801fd34:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 801fd38:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801fd3c:	4619      	mov	r1, r3
 801fd3e:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801fd40:	f7f1 f986 	bl	8011050 <lv_obj_set_pos>
            act_x += x_ofs;
 801fd44:	8c3a      	ldrh	r2, [r7, #32]
 801fd46:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 801fd48:	4413      	add	r3, r2
 801fd4a:	b29b      	uxth	r3, r3
 801fd4c:	843b      	strh	r3, [r7, #32]
 801fd4e:	e007      	b.n	801fd60 <lv_cont_layout_grid+0x148>
        } else {
            lv_obj_set_pos(child, x_ofs, act_y);
 801fd50:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 801fd54:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801fd58:	4619      	mov	r1, r3
 801fd5a:	6a78      	ldr	r0, [r7, #36]	; 0x24
 801fd5c:	f7f1 f978 	bl	8011050 <lv_obj_set_pos>
        }
        obj_cnt++;
 801fd60:	8bbb      	ldrh	r3, [r7, #28]
 801fd62:	3301      	adds	r3, #1
 801fd64:	83bb      	strh	r3, [r7, #28]

        if(obj_cnt >= obj_row) {
 801fd66:	8bba      	ldrh	r2, [r7, #28]
 801fd68:	8a3b      	ldrh	r3, [r7, #16]
 801fd6a:	429a      	cmp	r2, r3
 801fd6c:	d30b      	bcc.n	801fd86 <lv_cont_layout_grid+0x16e>
            obj_cnt = 0;
 801fd6e:	2300      	movs	r3, #0
 801fd70:	83bb      	strh	r3, [r7, #28]
            act_x   = style->body.padding.left;
 801fd72:	69bb      	ldr	r3, [r7, #24]
 801fd74:	8b5b      	ldrh	r3, [r3, #26]
 801fd76:	843b      	strh	r3, [r7, #32]
            act_y += y_ofs;
 801fd78:	8bfa      	ldrh	r2, [r7, #30]
 801fd7a:	89fb      	ldrh	r3, [r7, #14]
 801fd7c:	4413      	add	r3, r2
 801fd7e:	b29b      	uxth	r3, r3
 801fd80:	83fb      	strh	r3, [r7, #30]
 801fd82:	e000      	b.n	801fd86 <lv_cont_layout_grid+0x16e>
        if(lv_obj_get_hidden(child) != false || lv_obj_is_protected(child, LV_PROTECT_POS) != false) continue;
 801fd84:	bf00      	nop
    LV_LL_READ_BACK(cont->child_ll, child)
 801fd86:	687b      	ldr	r3, [r7, #4]
 801fd88:	3304      	adds	r3, #4
 801fd8a:	6a79      	ldr	r1, [r7, #36]	; 0x24
 801fd8c:	4618      	mov	r0, r3
 801fd8e:	f7fc fc75 	bl	801c67c <lv_ll_get_prev>
 801fd92:	6278      	str	r0, [r7, #36]	; 0x24
 801fd94:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801fd96:	2b00      	cmp	r3, #0
 801fd98:	d1bc      	bne.n	801fd14 <lv_cont_layout_grid+0xfc>
        }
    }

    lv_obj_clear_protect(cont, LV_PROTECT_CHILD_CHG);
 801fd9a:	2101      	movs	r1, #1
 801fd9c:	6878      	ldr	r0, [r7, #4]
 801fd9e:	f7f2 f838 	bl	8011e12 <lv_obj_clear_protect>
}
 801fda2:	bf00      	nop
 801fda4:	3728      	adds	r7, #40	; 0x28
 801fda6:	46bd      	mov	sp, r7
 801fda8:	bd80      	pop	{r7, pc}

0801fdaa <lv_cont_refr_autofit>:
/**
 * Handle auto fit. Set the size of the object to involve all children.
 * @param cont pointer to an object which size will be modified
 */
static void lv_cont_refr_autofit(lv_obj_t * cont)
{
 801fdaa:	b580      	push	{r7, lr}
 801fdac:	b090      	sub	sp, #64	; 0x40
 801fdae:	af00      	add	r7, sp, #0
 801fdb0:	6078      	str	r0, [r7, #4]
    lv_cont_ext_t * ext = lv_obj_get_ext_attr(cont);
 801fdb2:	6878      	ldr	r0, [r7, #4]
 801fdb4:	f7f2 fb3d 	bl	8012432 <lv_obj_get_ext_attr>
 801fdb8:	63b8      	str	r0, [r7, #56]	; 0x38

    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
 801fdba:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801fdbc:	781b      	ldrb	r3, [r3, #0]
 801fdbe:	f003 0330 	and.w	r3, r3, #48	; 0x30
 801fdc2:	b2db      	uxtb	r3, r3
 801fdc4:	2b00      	cmp	r3, #0
 801fdc6:	d115      	bne.n	801fdf4 <lv_cont_refr_autofit+0x4a>
 801fdc8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801fdca:	781b      	ldrb	r3, [r3, #0]
 801fdcc:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 801fdd0:	b2db      	uxtb	r3, r3
 801fdd2:	2b00      	cmp	r3, #0
 801fdd4:	d10e      	bne.n	801fdf4 <lv_cont_refr_autofit+0x4a>
 801fdd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801fdd8:	785b      	ldrb	r3, [r3, #1]
 801fdda:	f003 0303 	and.w	r3, r3, #3
 801fdde:	b2db      	uxtb	r3, r3
 801fde0:	2b00      	cmp	r3, #0
 801fde2:	d107      	bne.n	801fdf4 <lv_cont_refr_autofit+0x4a>
       ext->fit_bottom == LV_FIT_NONE) {
 801fde4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801fde6:	785b      	ldrb	r3, [r3, #1]
 801fde8:	f003 030c 	and.w	r3, r3, #12
 801fdec:	b2db      	uxtb	r3, r3
    if(ext->fit_left == LV_FIT_NONE && ext->fit_right == LV_FIT_NONE && ext->fit_top == LV_FIT_NONE &&
 801fdee:	2b00      	cmp	r3, #0
 801fdf0:	f000 81c8 	beq.w	8020184 <lv_cont_refr_autofit+0x3da>
        return;
    }

    lv_area_t tight_area;
    lv_area_t ori;
    const lv_style_t * style = lv_obj_get_style(cont);
 801fdf4:	6878      	ldr	r0, [r7, #4]
 801fdf6:	f7f2 f9fd 	bl	80121f4 <lv_obj_get_style>
 801fdfa:	6378      	str	r0, [r7, #52]	; 0x34
    lv_obj_t * child_i;

    lv_obj_t * par               = lv_obj_get_parent(cont);
 801fdfc:	6878      	ldr	r0, [r7, #4]
 801fdfe:	f7f2 f95f 	bl	80120c0 <lv_obj_get_parent>
 801fe02:	6338      	str	r0, [r7, #48]	; 0x30
    const lv_style_t * par_style = lv_obj_get_style(par);
 801fe04:	6b38      	ldr	r0, [r7, #48]	; 0x30
 801fe06:	f7f2 f9f5 	bl	80121f4 <lv_obj_get_style>
 801fe0a:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_area_t flood_area;
    lv_area_copy(&flood_area, &par->coords);
 801fe0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801fe0e:	f103 0210 	add.w	r2, r3, #16
 801fe12:	f107 0310 	add.w	r3, r7, #16
 801fe16:	4611      	mov	r1, r2
 801fe18:	4618      	mov	r0, r3
 801fe1a:	f7ff f935 	bl	801f088 <lv_area_copy>
    flood_area.x1 += par_style->body.padding.left;
 801fe1e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801fe22:	b29a      	uxth	r2, r3
 801fe24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fe26:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801fe2a:	b29b      	uxth	r3, r3
 801fe2c:	4413      	add	r3, r2
 801fe2e:	b29b      	uxth	r3, r3
 801fe30:	b21b      	sxth	r3, r3
 801fe32:	823b      	strh	r3, [r7, #16]
    flood_area.x2 -= par_style->body.padding.right;
 801fe34:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 801fe38:	b29a      	uxth	r2, r3
 801fe3a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fe3c:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801fe40:	b29b      	uxth	r3, r3
 801fe42:	1ad3      	subs	r3, r2, r3
 801fe44:	b29b      	uxth	r3, r3
 801fe46:	b21b      	sxth	r3, r3
 801fe48:	82bb      	strh	r3, [r7, #20]
    flood_area.y1 += par_style->body.padding.top;
 801fe4a:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 801fe4e:	b29a      	uxth	r2, r3
 801fe50:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fe52:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 801fe56:	b29b      	uxth	r3, r3
 801fe58:	4413      	add	r3, r2
 801fe5a:	b29b      	uxth	r3, r3
 801fe5c:	b21b      	sxth	r3, r3
 801fe5e:	827b      	strh	r3, [r7, #18]
    flood_area.y2 -= par_style->body.padding.bottom;
 801fe60:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 801fe64:	b29a      	uxth	r2, r3
 801fe66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801fe68:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 801fe6c:	b29b      	uxth	r3, r3
 801fe6e:	1ad3      	subs	r3, r2, r3
 801fe70:	b29b      	uxth	r3, r3
 801fe72:	b21b      	sxth	r3, r3
 801fe74:	82fb      	strh	r3, [r7, #22]

    /*Search the side coordinates of the children*/
    lv_obj_get_coords(cont, &ori);
 801fe76:	f107 0318 	add.w	r3, r7, #24
 801fe7a:	4619      	mov	r1, r3
 801fe7c:	6878      	ldr	r0, [r7, #4]
 801fe7e:	f7f2 f948 	bl	8012112 <lv_obj_get_coords>
    lv_obj_get_coords(cont, &tight_area);
 801fe82:	f107 0320 	add.w	r3, r7, #32
 801fe86:	4619      	mov	r1, r3
 801fe88:	6878      	ldr	r0, [r7, #4]
 801fe8a:	f7f2 f942 	bl	8012112 <lv_obj_get_coords>

    bool has_children = lv_ll_is_empty(&cont->child_ll) ? false : true;
 801fe8e:	687b      	ldr	r3, [r7, #4]
 801fe90:	3304      	adds	r3, #4
 801fe92:	4618      	mov	r0, r3
 801fe94:	f7fc fc51 	bl	801c73a <lv_ll_is_empty>
 801fe98:	4603      	mov	r3, r0
 801fe9a:	f083 0301 	eor.w	r3, r3, #1
 801fe9e:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b

    if(has_children) {
 801fea2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801fea6:	2b00      	cmp	r3, #0
 801fea8:	d078      	beq.n	801ff9c <lv_cont_refr_autofit+0x1f2>
        tight_area.x1 = LV_COORD_MAX;
 801feaa:	f647 4318 	movw	r3, #31768	; 0x7c18
 801feae:	843b      	strh	r3, [r7, #32]
        tight_area.y1 = LV_COORD_MAX;
 801feb0:	f647 4318 	movw	r3, #31768	; 0x7c18
 801feb4:	847b      	strh	r3, [r7, #34]	; 0x22
        tight_area.x2 = LV_COORD_MIN;
 801feb6:	f248 33e8 	movw	r3, #33768	; 0x83e8
 801feba:	84bb      	strh	r3, [r7, #36]	; 0x24
        tight_area.y2 = LV_COORD_MIN;
 801febc:	f248 33e8 	movw	r3, #33768	; 0x83e8
 801fec0:	84fb      	strh	r3, [r7, #38]	; 0x26

        LV_LL_READ(cont->child_ll, child_i)
 801fec2:	687b      	ldr	r3, [r7, #4]
 801fec4:	3304      	adds	r3, #4
 801fec6:	4618      	mov	r0, r3
 801fec8:	f7fc fb98 	bl	801c5fc <lv_ll_get_head>
 801fecc:	63f8      	str	r0, [r7, #60]	; 0x3c
 801fece:	e036      	b.n	801ff3e <lv_cont_refr_autofit+0x194>
        {
            if(lv_obj_get_hidden(child_i) != false) continue;
 801fed0:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 801fed2:	f7f2 f9e7 	bl	80122a4 <lv_obj_get_hidden>
 801fed6:	4603      	mov	r3, r0
 801fed8:	2b00      	cmp	r3, #0
 801feda:	d128      	bne.n	801ff2e <lv_cont_refr_autofit+0x184>
            tight_area.x1 = LV_MATH_MIN(tight_area.x1, child_i->coords.x1);
 801fedc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801fede:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 801fee2:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801fee6:	4293      	cmp	r3, r2
 801fee8:	bfa8      	it	ge
 801feea:	4613      	movge	r3, r2
 801feec:	b21b      	sxth	r3, r3
 801feee:	843b      	strh	r3, [r7, #32]
            tight_area.y1 = LV_MATH_MIN(tight_area.y1, child_i->coords.y1);
 801fef0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801fef2:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 801fef6:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801fefa:	4293      	cmp	r3, r2
 801fefc:	bfa8      	it	ge
 801fefe:	4613      	movge	r3, r2
 801ff00:	b21b      	sxth	r3, r3
 801ff02:	847b      	strh	r3, [r7, #34]	; 0x22
            tight_area.x2 = LV_MATH_MAX(tight_area.x2, child_i->coords.x2);
 801ff04:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ff06:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 801ff0a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 801ff0e:	4293      	cmp	r3, r2
 801ff10:	bfb8      	it	lt
 801ff12:	4613      	movlt	r3, r2
 801ff14:	b21b      	sxth	r3, r3
 801ff16:	84bb      	strh	r3, [r7, #36]	; 0x24
            tight_area.y2 = LV_MATH_MAX(tight_area.y2, child_i->coords.y2);
 801ff18:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ff1a:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 801ff1e:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801ff22:	4293      	cmp	r3, r2
 801ff24:	bfb8      	it	lt
 801ff26:	4613      	movlt	r3, r2
 801ff28:	b21b      	sxth	r3, r3
 801ff2a:	84fb      	strh	r3, [r7, #38]	; 0x26
 801ff2c:	e000      	b.n	801ff30 <lv_cont_refr_autofit+0x186>
            if(lv_obj_get_hidden(child_i) != false) continue;
 801ff2e:	bf00      	nop
        LV_LL_READ(cont->child_ll, child_i)
 801ff30:	687b      	ldr	r3, [r7, #4]
 801ff32:	3304      	adds	r3, #4
 801ff34:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 801ff36:	4618      	mov	r0, r3
 801ff38:	f7fc fb86 	bl	801c648 <lv_ll_get_next>
 801ff3c:	63f8      	str	r0, [r7, #60]	; 0x3c
 801ff3e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801ff40:	2b00      	cmp	r3, #0
 801ff42:	d1c5      	bne.n	801fed0 <lv_cont_refr_autofit+0x126>
        }

        tight_area.x1 -= style->body.padding.left;
 801ff44:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801ff48:	b29a      	uxth	r2, r3
 801ff4a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ff4c:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 801ff50:	b29b      	uxth	r3, r3
 801ff52:	1ad3      	subs	r3, r2, r3
 801ff54:	b29b      	uxth	r3, r3
 801ff56:	b21b      	sxth	r3, r3
 801ff58:	843b      	strh	r3, [r7, #32]
        tight_area.x2 += style->body.padding.right;
 801ff5a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 801ff5e:	b29a      	uxth	r2, r3
 801ff60:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ff62:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 801ff66:	b29b      	uxth	r3, r3
 801ff68:	4413      	add	r3, r2
 801ff6a:	b29b      	uxth	r3, r3
 801ff6c:	b21b      	sxth	r3, r3
 801ff6e:	84bb      	strh	r3, [r7, #36]	; 0x24
        tight_area.y1 -= style->body.padding.top;
 801ff70:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 801ff74:	b29a      	uxth	r2, r3
 801ff76:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ff78:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 801ff7c:	b29b      	uxth	r3, r3
 801ff7e:	1ad3      	subs	r3, r2, r3
 801ff80:	b29b      	uxth	r3, r3
 801ff82:	b21b      	sxth	r3, r3
 801ff84:	847b      	strh	r3, [r7, #34]	; 0x22
        tight_area.y2 += style->body.padding.bottom;
 801ff86:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 801ff8a:	b29a      	uxth	r2, r3
 801ff8c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801ff8e:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 801ff92:	b29b      	uxth	r3, r3
 801ff94:	4413      	add	r3, r2
 801ff96:	b29b      	uxth	r3, r3
 801ff98:	b21b      	sxth	r3, r3
 801ff9a:	84fb      	strh	r3, [r7, #38]	; 0x26
    }

    lv_area_t new_area;
    lv_area_copy(&new_area, &ori);
 801ff9c:	f107 0218 	add.w	r2, r7, #24
 801ffa0:	f107 0308 	add.w	r3, r7, #8
 801ffa4:	4611      	mov	r1, r2
 801ffa6:	4618      	mov	r0, r3
 801ffa8:	f7ff f86e 	bl	801f088 <lv_area_copy>

    switch(ext->fit_left) {
 801ffac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801ffae:	781b      	ldrb	r3, [r3, #0]
 801ffb0:	f3c3 1301 	ubfx	r3, r3, #4, #2
 801ffb4:	b2db      	uxtb	r3, r3
 801ffb6:	2b02      	cmp	r3, #2
 801ffb8:	d008      	beq.n	801ffcc <lv_cont_refr_autofit+0x222>
 801ffba:	2b03      	cmp	r3, #3
 801ffbc:	d00a      	beq.n	801ffd4 <lv_cont_refr_autofit+0x22a>
 801ffbe:	2b01      	cmp	r3, #1
 801ffc0:	d000      	beq.n	801ffc4 <lv_cont_refr_autofit+0x21a>
        case LV_FIT_TIGHT: new_area.x1 = tight_area.x1; break;
        case LV_FIT_FLOOD: new_area.x1 = flood_area.x1; break;
        case LV_FIT_FILL: new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, flood_area.x1) : flood_area.x1; break;
        default: break;
 801ffc2:	e018      	b.n	801fff6 <lv_cont_refr_autofit+0x24c>
        case LV_FIT_TIGHT: new_area.x1 = tight_area.x1; break;
 801ffc4:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801ffc8:	813b      	strh	r3, [r7, #8]
 801ffca:	e014      	b.n	801fff6 <lv_cont_refr_autofit+0x24c>
        case LV_FIT_FLOOD: new_area.x1 = flood_area.x1; break;
 801ffcc:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801ffd0:	813b      	strh	r3, [r7, #8]
 801ffd2:	e010      	b.n	801fff6 <lv_cont_refr_autofit+0x24c>
        case LV_FIT_FILL: new_area.x1 = has_children ? LV_MATH_MIN(tight_area.x1, flood_area.x1) : flood_area.x1; break;
 801ffd4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 801ffd8:	2b00      	cmp	r3, #0
 801ffda:	d008      	beq.n	801ffee <lv_cont_refr_autofit+0x244>
 801ffdc:	f9b7 2010 	ldrsh.w	r2, [r7, #16]
 801ffe0:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 801ffe4:	4293      	cmp	r3, r2
 801ffe6:	bfa8      	it	ge
 801ffe8:	4613      	movge	r3, r2
 801ffea:	b21b      	sxth	r3, r3
 801ffec:	e001      	b.n	801fff2 <lv_cont_refr_autofit+0x248>
 801ffee:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 801fff2:	813b      	strh	r3, [r7, #8]
 801fff4:	bf00      	nop
    }

    switch(ext->fit_right) {
 801fff6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 801fff8:	781b      	ldrb	r3, [r3, #0]
 801fffa:	f3c3 1381 	ubfx	r3, r3, #6, #2
 801fffe:	b2db      	uxtb	r3, r3
 8020000:	2b02      	cmp	r3, #2
 8020002:	d008      	beq.n	8020016 <lv_cont_refr_autofit+0x26c>
 8020004:	2b03      	cmp	r3, #3
 8020006:	d00a      	beq.n	802001e <lv_cont_refr_autofit+0x274>
 8020008:	2b01      	cmp	r3, #1
 802000a:	d000      	beq.n	802000e <lv_cont_refr_autofit+0x264>
        case LV_FIT_TIGHT: new_area.x2 = tight_area.x2; break;
        case LV_FIT_FLOOD: new_area.x2 = flood_area.x2; break;
        case LV_FIT_FILL: new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, flood_area.x2) : flood_area.x2; break;
        default: break;
 802000c:	e018      	b.n	8020040 <lv_cont_refr_autofit+0x296>
        case LV_FIT_TIGHT: new_area.x2 = tight_area.x2; break;
 802000e:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8020012:	81bb      	strh	r3, [r7, #12]
 8020014:	e014      	b.n	8020040 <lv_cont_refr_autofit+0x296>
        case LV_FIT_FLOOD: new_area.x2 = flood_area.x2; break;
 8020016:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802001a:	81bb      	strh	r3, [r7, #12]
 802001c:	e010      	b.n	8020040 <lv_cont_refr_autofit+0x296>
        case LV_FIT_FILL: new_area.x2 = has_children ? LV_MATH_MAX(tight_area.x2, flood_area.x2) : flood_area.x2; break;
 802001e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 8020022:	2b00      	cmp	r3, #0
 8020024:	d008      	beq.n	8020038 <lv_cont_refr_autofit+0x28e>
 8020026:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 802002a:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 802002e:	4293      	cmp	r3, r2
 8020030:	bfb8      	it	lt
 8020032:	4613      	movlt	r3, r2
 8020034:	b21b      	sxth	r3, r3
 8020036:	e001      	b.n	802003c <lv_cont_refr_autofit+0x292>
 8020038:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 802003c:	81bb      	strh	r3, [r7, #12]
 802003e:	bf00      	nop
    }

    switch(ext->fit_top) {
 8020040:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8020042:	785b      	ldrb	r3, [r3, #1]
 8020044:	f3c3 0301 	ubfx	r3, r3, #0, #2
 8020048:	b2db      	uxtb	r3, r3
 802004a:	2b02      	cmp	r3, #2
 802004c:	d008      	beq.n	8020060 <lv_cont_refr_autofit+0x2b6>
 802004e:	2b03      	cmp	r3, #3
 8020050:	d00a      	beq.n	8020068 <lv_cont_refr_autofit+0x2be>
 8020052:	2b01      	cmp	r3, #1
 8020054:	d000      	beq.n	8020058 <lv_cont_refr_autofit+0x2ae>
        case LV_FIT_TIGHT: new_area.y1 = tight_area.y1; break;
        case LV_FIT_FLOOD: new_area.y1 = flood_area.y1; break;
        case LV_FIT_FILL: new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, flood_area.y1) : flood_area.y1; break;
        default: break;
 8020056:	e018      	b.n	802008a <lv_cont_refr_autofit+0x2e0>
        case LV_FIT_TIGHT: new_area.y1 = tight_area.y1; break;
 8020058:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 802005c:	817b      	strh	r3, [r7, #10]
 802005e:	e014      	b.n	802008a <lv_cont_refr_autofit+0x2e0>
        case LV_FIT_FLOOD: new_area.y1 = flood_area.y1; break;
 8020060:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8020064:	817b      	strh	r3, [r7, #10]
 8020066:	e010      	b.n	802008a <lv_cont_refr_autofit+0x2e0>
        case LV_FIT_FILL: new_area.y1 = has_children ? LV_MATH_MIN(tight_area.y1, flood_area.y1) : flood_area.y1; break;
 8020068:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 802006c:	2b00      	cmp	r3, #0
 802006e:	d008      	beq.n	8020082 <lv_cont_refr_autofit+0x2d8>
 8020070:	f9b7 2012 	ldrsh.w	r2, [r7, #18]
 8020074:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8020078:	4293      	cmp	r3, r2
 802007a:	bfa8      	it	ge
 802007c:	4613      	movge	r3, r2
 802007e:	b21b      	sxth	r3, r3
 8020080:	e001      	b.n	8020086 <lv_cont_refr_autofit+0x2dc>
 8020082:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8020086:	817b      	strh	r3, [r7, #10]
 8020088:	bf00      	nop
    }

    switch(ext->fit_bottom) {
 802008a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 802008c:	785b      	ldrb	r3, [r3, #1]
 802008e:	f3c3 0381 	ubfx	r3, r3, #2, #2
 8020092:	b2db      	uxtb	r3, r3
 8020094:	2b02      	cmp	r3, #2
 8020096:	d008      	beq.n	80200aa <lv_cont_refr_autofit+0x300>
 8020098:	2b03      	cmp	r3, #3
 802009a:	d00a      	beq.n	80200b2 <lv_cont_refr_autofit+0x308>
 802009c:	2b01      	cmp	r3, #1
 802009e:	d000      	beq.n	80200a2 <lv_cont_refr_autofit+0x2f8>
        case LV_FIT_TIGHT: new_area.y2 = tight_area.y2; break;
        case LV_FIT_FLOOD: new_area.y2 = flood_area.y2; break;
        case LV_FIT_FILL: new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, flood_area.y2) : flood_area.y2; break;
        default: break;
 80200a0:	e018      	b.n	80200d4 <lv_cont_refr_autofit+0x32a>
        case LV_FIT_TIGHT: new_area.y2 = tight_area.y2; break;
 80200a2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80200a6:	81fb      	strh	r3, [r7, #14]
 80200a8:	e014      	b.n	80200d4 <lv_cont_refr_autofit+0x32a>
        case LV_FIT_FLOOD: new_area.y2 = flood_area.y2; break;
 80200aa:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80200ae:	81fb      	strh	r3, [r7, #14]
 80200b0:	e010      	b.n	80200d4 <lv_cont_refr_autofit+0x32a>
        case LV_FIT_FILL: new_area.y2 = has_children ? LV_MATH_MAX(tight_area.y2, flood_area.y2) : flood_area.y2; break;
 80200b2:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 80200b6:	2b00      	cmp	r3, #0
 80200b8:	d008      	beq.n	80200cc <lv_cont_refr_autofit+0x322>
 80200ba:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 80200be:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 80200c2:	4293      	cmp	r3, r2
 80200c4:	bfb8      	it	lt
 80200c6:	4613      	movlt	r3, r2
 80200c8:	b21b      	sxth	r3, r3
 80200ca:	e001      	b.n	80200d0 <lv_cont_refr_autofit+0x326>
 80200cc:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80200d0:	81fb      	strh	r3, [r7, #14]
 80200d2:	bf00      	nop
    }

    /*Do nothing if the coordinates are not changed*/
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
 80200d4:	687b      	ldr	r3, [r7, #4]
 80200d6:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 80200da:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80200de:	429a      	cmp	r2, r3
 80200e0:	d114      	bne.n	802010c <lv_cont_refr_autofit+0x362>
 80200e2:	687b      	ldr	r3, [r7, #4]
 80200e4:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 80200e8:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80200ec:	429a      	cmp	r2, r3
 80200ee:	d10d      	bne.n	802010c <lv_cont_refr_autofit+0x362>
 80200f0:	687b      	ldr	r3, [r7, #4]
 80200f2:	f9b3 2014 	ldrsh.w	r2, [r3, #20]
 80200f6:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80200fa:	429a      	cmp	r2, r3
 80200fc:	d106      	bne.n	802010c <lv_cont_refr_autofit+0x362>
       cont->coords.y2 != new_area.y2) {
 80200fe:	687b      	ldr	r3, [r7, #4]
 8020100:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 8020104:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
    if(cont->coords.x1 != new_area.x1 || cont->coords.y1 != new_area.y1 || cont->coords.x2 != new_area.x2 ||
 8020108:	429a      	cmp	r2, r3
 802010a:	d03c      	beq.n	8020186 <lv_cont_refr_autofit+0x3dc>

        lv_obj_invalidate(cont);
 802010c:	6878      	ldr	r0, [r7, #4]
 802010e:	f7f0 fe8e 	bl	8010e2e <lv_obj_invalidate>
        lv_area_copy(&cont->coords, &new_area);
 8020112:	687b      	ldr	r3, [r7, #4]
 8020114:	3310      	adds	r3, #16
 8020116:	f107 0208 	add.w	r2, r7, #8
 802011a:	4611      	mov	r1, r2
 802011c:	4618      	mov	r0, r3
 802011e:	f7fe ffb3 	bl	801f088 <lv_area_copy>
        lv_obj_invalidate(cont);
 8020122:	6878      	ldr	r0, [r7, #4]
 8020124:	f7f0 fe83 	bl	8010e2e <lv_obj_invalidate>

        /*Notify the object about its new coordinates*/
        cont->signal_cb(cont, LV_SIGNAL_CORD_CHG, &ori);
 8020128:	687b      	ldr	r3, [r7, #4]
 802012a:	69db      	ldr	r3, [r3, #28]
 802012c:	f107 0218 	add.w	r2, r7, #24
 8020130:	2102      	movs	r1, #2
 8020132:	6878      	ldr	r0, [r7, #4]
 8020134:	4798      	blx	r3

        /*Inform the parent about the new coordinates*/
        par->signal_cb(par, LV_SIGNAL_CHILD_CHG, cont);
 8020136:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8020138:	69db      	ldr	r3, [r3, #28]
 802013a:	687a      	ldr	r2, [r7, #4]
 802013c:	2101      	movs	r1, #1
 802013e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8020140:	4798      	blx	r3

        if(lv_obj_get_auto_realign(cont)) {
 8020142:	6878      	ldr	r0, [r7, #4]
 8020144:	f7f2 f842 	bl	80121cc <lv_obj_get_auto_realign>
 8020148:	4603      	mov	r3, r0
 802014a:	2b00      	cmp	r3, #0
 802014c:	d002      	beq.n	8020154 <lv_cont_refr_autofit+0x3aa>
            lv_obj_realign(cont);
 802014e:	6878      	ldr	r0, [r7, #4]
 8020150:	f7f1 fd6a 	bl	8011c28 <lv_obj_realign>
        }

        /*Tell the children the parent's size has changed*/
        LV_LL_READ(cont->child_ll, child_i)
 8020154:	687b      	ldr	r3, [r7, #4]
 8020156:	3304      	adds	r3, #4
 8020158:	4618      	mov	r0, r3
 802015a:	f7fc fa4f 	bl	801c5fc <lv_ll_get_head>
 802015e:	63f8      	str	r0, [r7, #60]	; 0x3c
 8020160:	e00c      	b.n	802017c <lv_cont_refr_autofit+0x3d2>
        {
            child_i->signal_cb(child_i, LV_SIGNAL_PARENT_SIZE_CHG, NULL);
 8020162:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8020164:	69db      	ldr	r3, [r3, #28]
 8020166:	2200      	movs	r2, #0
 8020168:	2103      	movs	r1, #3
 802016a:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 802016c:	4798      	blx	r3
        LV_LL_READ(cont->child_ll, child_i)
 802016e:	687b      	ldr	r3, [r7, #4]
 8020170:	3304      	adds	r3, #4
 8020172:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8020174:	4618      	mov	r0, r3
 8020176:	f7fc fa67 	bl	801c648 <lv_ll_get_next>
 802017a:	63f8      	str	r0, [r7, #60]	; 0x3c
 802017c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802017e:	2b00      	cmp	r3, #0
 8020180:	d1ef      	bne.n	8020162 <lv_cont_refr_autofit+0x3b8>
 8020182:	e000      	b.n	8020186 <lv_cont_refr_autofit+0x3dc>
        return;
 8020184:	bf00      	nop
        }
    }
}
 8020186:	3740      	adds	r7, #64	; 0x40
 8020188:	46bd      	mov	sp, r7
 802018a:	bd80      	pop	{r7, pc}

0802018c <lv_font_get_line_height>:
 * Get the line height of a font. All characters fit into this height
 * @param font_p pointer to a font
 * @return the height of a font
 */
static inline uint8_t lv_font_get_line_height(const lv_font_t * font_p)
{
 802018c:	b480      	push	{r7}
 802018e:	b083      	sub	sp, #12
 8020190:	af00      	add	r7, sp, #0
 8020192:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 8020194:	687b      	ldr	r3, [r7, #4]
 8020196:	7a1b      	ldrb	r3, [r3, #8]
}
 8020198:	4618      	mov	r0, r3
 802019a:	370c      	adds	r7, #12
 802019c:	46bd      	mov	sp, r7
 802019e:	f85d 7b04 	ldr.w	r7, [sp], #4
 80201a2:	4770      	bx	lr

080201a4 <lv_cont_set_fit2>:
 * @param cont pointer to a container object
 * @param hot horizontal fit policy from `lv_fit_t`
 * @param ver vertical fit policy from `lv_fit_t`
 */
static inline void lv_cont_set_fit2(lv_obj_t * cont, lv_fit_t hor, lv_fit_t ver)
{
 80201a4:	b580      	push	{r7, lr}
 80201a6:	b084      	sub	sp, #16
 80201a8:	af02      	add	r7, sp, #8
 80201aa:	6078      	str	r0, [r7, #4]
 80201ac:	460b      	mov	r3, r1
 80201ae:	70fb      	strb	r3, [r7, #3]
 80201b0:	4613      	mov	r3, r2
 80201b2:	70bb      	strb	r3, [r7, #2]
    lv_cont_set_fit4(cont, hor, hor, ver, ver);
 80201b4:	78b8      	ldrb	r0, [r7, #2]
 80201b6:	78fa      	ldrb	r2, [r7, #3]
 80201b8:	78f9      	ldrb	r1, [r7, #3]
 80201ba:	78bb      	ldrb	r3, [r7, #2]
 80201bc:	9300      	str	r3, [sp, #0]
 80201be:	4603      	mov	r3, r0
 80201c0:	6878      	ldr	r0, [r7, #4]
 80201c2:	f7ff f88e 	bl	801f2e2 <lv_cont_set_fit4>
}
 80201c6:	bf00      	nop
 80201c8:	3708      	adds	r7, #8
 80201ca:	46bd      	mov	sp, r7
 80201cc:	bd80      	pop	{r7, pc}

080201ce <lv_page_set_scrl_fit2>:
 * @param page pointer to a page object
 * @param hot horizontal fit policy from `lv_fit_t`
 * @param ver vertical fit policy from `lv_fit_t`
 */
static inline void lv_page_set_scrl_fit2(lv_obj_t * page, lv_fit_t hor, lv_fit_t ver)
{
 80201ce:	b580      	push	{r7, lr}
 80201d0:	b082      	sub	sp, #8
 80201d2:	af00      	add	r7, sp, #0
 80201d4:	6078      	str	r0, [r7, #4]
 80201d6:	460b      	mov	r3, r1
 80201d8:	70fb      	strb	r3, [r7, #3]
 80201da:	4613      	mov	r3, r2
 80201dc:	70bb      	strb	r3, [r7, #2]
    lv_cont_set_fit2(lv_page_get_scrl(page), hor, ver);
 80201de:	6878      	ldr	r0, [r7, #4]
 80201e0:	f002 fe98 	bl	8022f14 <lv_page_get_scrl>
 80201e4:	78ba      	ldrb	r2, [r7, #2]
 80201e6:	78fb      	ldrb	r3, [r7, #3]
 80201e8:	4619      	mov	r1, r3
 80201ea:	f7ff ffdb 	bl	80201a4 <lv_cont_set_fit2>
}
 80201ee:	bf00      	nop
 80201f0:	3708      	adds	r7, #8
 80201f2:	46bd      	mov	sp, r7
 80201f4:	bd80      	pop	{r7, pc}

080201f6 <lv_page_get_scrl_fit_bottom>:
 * Get the bottom fit mode
 * @param page pointer to a page object
 * @return an element of `lv_fit_t`
 */
static inline lv_fit_t lv_page_get_scrl_fit_bottom(const lv_obj_t * page)
{
 80201f6:	b580      	push	{r7, lr}
 80201f8:	b082      	sub	sp, #8
 80201fa:	af00      	add	r7, sp, #0
 80201fc:	6078      	str	r0, [r7, #4]
    return lv_cont_get_fit_bottom(lv_page_get_scrl(page));
 80201fe:	6878      	ldr	r0, [r7, #4]
 8020200:	f002 fe88 	bl	8022f14 <lv_page_get_scrl>
 8020204:	4603      	mov	r3, r0
 8020206:	4618      	mov	r0, r3
 8020208:	f7ff f905 	bl	801f416 <lv_cont_get_fit_bottom>
 802020c:	4603      	mov	r3, r0
}
 802020e:	4618      	mov	r0, r3
 8020210:	3708      	adds	r7, #8
 8020212:	46bd      	mov	sp, r7
 8020214:	bd80      	pop	{r7, pc}

08020216 <lv_ddlist_get_anim_time>:
 * Get the open/close animation time.
 * @param ddlist pointer to a drop down list
 * @return open/close animation time [ms]
 */
static inline uint16_t lv_ddlist_get_anim_time(const lv_obj_t * ddlist)
{
 8020216:	b580      	push	{r7, lr}
 8020218:	b082      	sub	sp, #8
 802021a:	af00      	add	r7, sp, #0
 802021c:	6078      	str	r0, [r7, #4]
    return lv_page_get_anim_time(ddlist);
 802021e:	6878      	ldr	r0, [r7, #4]
 8020220:	f002 fe86 	bl	8022f30 <lv_page_get_anim_time>
 8020224:	4603      	mov	r3, r0
}
 8020226:	4618      	mov	r0, r3
 8020228:	3708      	adds	r7, #8
 802022a:	46bd      	mov	sp, r7
 802022c:	bd80      	pop	{r7, pc}
	...

08020230 <lv_ddlist_create>:
 * @param copy pointer to a drop down list object, if not NULL then the new object will be copied
 * from it
 * @return pointer to the created drop down list
 */
lv_obj_t * lv_ddlist_create(lv_obj_t * par, const lv_obj_t * copy)
{
 8020230:	b590      	push	{r4, r7, lr}
 8020232:	b089      	sub	sp, #36	; 0x24
 8020234:	af00      	add	r7, sp, #0
 8020236:	6078      	str	r0, [r7, #4]
 8020238:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("drop down list create started");

    /*Create the ancestor drop down list*/
    lv_obj_t * new_ddlist = lv_page_create(par, copy);
 802023a:	6839      	ldr	r1, [r7, #0]
 802023c:	6878      	ldr	r0, [r7, #4]
 802023e:	f002 fc23 	bl	8022a88 <lv_page_create>
 8020242:	61f8      	str	r0, [r7, #28]
    lv_mem_assert(new_ddlist);
 8020244:	69fb      	ldr	r3, [r7, #28]
 8020246:	2b00      	cmp	r3, #0
 8020248:	d106      	bne.n	8020258 <lv_ddlist_create+0x28>
 802024a:	4b93      	ldr	r3, [pc, #588]	; (8020498 <lv_ddlist_create+0x268>)
 802024c:	224d      	movs	r2, #77	; 0x4d
 802024e:	4993      	ldr	r1, [pc, #588]	; (802049c <lv_ddlist_create+0x26c>)
 8020250:	2003      	movs	r0, #3
 8020252:	f7fc fadb 	bl	801c80c <lv_log_add>
 8020256:	e7fe      	b.n	8020256 <lv_ddlist_create+0x26>
    if(new_ddlist == NULL) return NULL;
 8020258:	69fb      	ldr	r3, [r7, #28]
 802025a:	2b00      	cmp	r3, #0
 802025c:	d101      	bne.n	8020262 <lv_ddlist_create+0x32>
 802025e:	2300      	movs	r3, #0
 8020260:	e116      	b.n	8020490 <lv_ddlist_create+0x260>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_ddlist);
 8020262:	4b8f      	ldr	r3, [pc, #572]	; (80204a0 <lv_ddlist_create+0x270>)
 8020264:	681b      	ldr	r3, [r3, #0]
 8020266:	2b00      	cmp	r3, #0
 8020268:	d105      	bne.n	8020276 <lv_ddlist_create+0x46>
 802026a:	69f8      	ldr	r0, [r7, #28]
 802026c:	f7f2 f8c9 	bl	8012402 <lv_obj_get_signal_cb>
 8020270:	4602      	mov	r2, r0
 8020272:	4b8b      	ldr	r3, [pc, #556]	; (80204a0 <lv_ddlist_create+0x270>)
 8020274:	601a      	str	r2, [r3, #0]
    if(ancestor_scrl_signal == NULL) ancestor_scrl_signal = lv_obj_get_signal_cb(lv_page_get_scrl(new_ddlist));
 8020276:	4b8b      	ldr	r3, [pc, #556]	; (80204a4 <lv_ddlist_create+0x274>)
 8020278:	681b      	ldr	r3, [r3, #0]
 802027a:	2b00      	cmp	r3, #0
 802027c:	d109      	bne.n	8020292 <lv_ddlist_create+0x62>
 802027e:	69f8      	ldr	r0, [r7, #28]
 8020280:	f002 fe48 	bl	8022f14 <lv_page_get_scrl>
 8020284:	4603      	mov	r3, r0
 8020286:	4618      	mov	r0, r3
 8020288:	f7f2 f8bb 	bl	8012402 <lv_obj_get_signal_cb>
 802028c:	4602      	mov	r2, r0
 802028e:	4b85      	ldr	r3, [pc, #532]	; (80204a4 <lv_ddlist_create+0x274>)
 8020290:	601a      	str	r2, [r3, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(new_ddlist);
 8020292:	4b85      	ldr	r3, [pc, #532]	; (80204a8 <lv_ddlist_create+0x278>)
 8020294:	681b      	ldr	r3, [r3, #0]
 8020296:	2b00      	cmp	r3, #0
 8020298:	d105      	bne.n	80202a6 <lv_ddlist_create+0x76>
 802029a:	69f8      	ldr	r0, [r7, #28]
 802029c:	f7f2 f8bd 	bl	801241a <lv_obj_get_design_cb>
 80202a0:	4602      	mov	r2, r0
 80202a2:	4b81      	ldr	r3, [pc, #516]	; (80204a8 <lv_ddlist_create+0x278>)
 80202a4:	601a      	str	r2, [r3, #0]

    /*Allocate the drop down list type specific extended data*/
    lv_ddlist_ext_t * ext = lv_obj_allocate_ext_attr(new_ddlist, sizeof(lv_ddlist_ext_t));
 80202a6:	2144      	movs	r1, #68	; 0x44
 80202a8:	69f8      	ldr	r0, [r7, #28]
 80202aa:	f7f1 fe85 	bl	8011fb8 <lv_obj_allocate_ext_attr>
 80202ae:	61b8      	str	r0, [r7, #24]
    lv_mem_assert(ext);
 80202b0:	69bb      	ldr	r3, [r7, #24]
 80202b2:	2b00      	cmp	r3, #0
 80202b4:	d106      	bne.n	80202c4 <lv_ddlist_create+0x94>
 80202b6:	4b78      	ldr	r3, [pc, #480]	; (8020498 <lv_ddlist_create+0x268>)
 80202b8:	2256      	movs	r2, #86	; 0x56
 80202ba:	4978      	ldr	r1, [pc, #480]	; (802049c <lv_ddlist_create+0x26c>)
 80202bc:	2003      	movs	r0, #3
 80202be:	f7fc faa5 	bl	801c80c <lv_log_add>
 80202c2:	e7fe      	b.n	80202c2 <lv_ddlist_create+0x92>
    if(ext == NULL) return NULL;
 80202c4:	69bb      	ldr	r3, [r7, #24]
 80202c6:	2b00      	cmp	r3, #0
 80202c8:	d101      	bne.n	80202ce <lv_ddlist_create+0x9e>
 80202ca:	2300      	movs	r3, #0
 80202cc:	e0e0      	b.n	8020490 <lv_ddlist_create+0x260>

    /*Initialize the allocated 'ext' */
    ext->label          = NULL;
 80202ce:	69bb      	ldr	r3, [r7, #24]
 80202d0:	2200      	movs	r2, #0
 80202d2:	631a      	str	r2, [r3, #48]	; 0x30
    ext->opened         = 0;
 80202d4:	69ba      	ldr	r2, [r7, #24]
 80202d6:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 80202da:	f36f 0300 	bfc	r3, #0, #1
 80202de:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
    ext->fix_height     = 0;
 80202e2:	69bb      	ldr	r3, [r7, #24]
 80202e4:	2200      	movs	r2, #0
 80202e6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    ext->sel_opt_id     = 0;
 80202ea:	69bb      	ldr	r3, [r7, #24]
 80202ec:	2200      	movs	r2, #0
 80202ee:	875a      	strh	r2, [r3, #58]	; 0x3a
    ext->sel_opt_id_ori = 0;
 80202f0:	69bb      	ldr	r3, [r7, #24]
 80202f2:	2200      	movs	r2, #0
 80202f4:	879a      	strh	r2, [r3, #60]	; 0x3c
    ext->option_cnt     = 0;
 80202f6:	69bb      	ldr	r3, [r7, #24]
 80202f8:	2200      	movs	r2, #0
 80202fa:	871a      	strh	r2, [r3, #56]	; 0x38
    ext->sel_style      = &lv_style_plain_color;
 80202fc:	69bb      	ldr	r3, [r7, #24]
 80202fe:	4a6b      	ldr	r2, [pc, #428]	; (80204ac <lv_ddlist_create+0x27c>)
 8020300:	635a      	str	r2, [r3, #52]	; 0x34
    ext->draw_arrow     = 0; /*Do not draw arrow by default*/
 8020302:	69ba      	ldr	r2, [r7, #24]
 8020304:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020308:	f36f 0382 	bfc	r3, #2, #1
 802030c:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
    ext->stay_open      = 0;
 8020310:	69ba      	ldr	r2, [r7, #24]
 8020312:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020316:	f36f 03c3 	bfc	r3, #3, #1
 802031a:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e

    /*The signal and design functions are not copied so set them here*/
    lv_obj_set_signal_cb(new_ddlist, lv_ddlist_signal);
 802031e:	4964      	ldr	r1, [pc, #400]	; (80204b0 <lv_ddlist_create+0x280>)
 8020320:	69f8      	ldr	r0, [r7, #28]
 8020322:	f7f1 fe2d 	bl	8011f80 <lv_obj_set_signal_cb>
    lv_obj_set_signal_cb(lv_page_get_scrl(new_ddlist), lv_ddlist_scrl_signal);
 8020326:	69f8      	ldr	r0, [r7, #28]
 8020328:	f002 fdf4 	bl	8022f14 <lv_page_get_scrl>
 802032c:	4603      	mov	r3, r0
 802032e:	4961      	ldr	r1, [pc, #388]	; (80204b4 <lv_ddlist_create+0x284>)
 8020330:	4618      	mov	r0, r3
 8020332:	f7f1 fe25 	bl	8011f80 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_ddlist, lv_ddlist_design);
 8020336:	4960      	ldr	r1, [pc, #384]	; (80204b8 <lv_ddlist_create+0x288>)
 8020338:	69f8      	ldr	r0, [r7, #28]
 802033a:	f7f1 fe2f 	bl	8011f9c <lv_obj_set_design_cb>

    /*Init the new drop down list drop down list*/
    if(copy == NULL) {
 802033e:	683b      	ldr	r3, [r7, #0]
 8020340:	2b00      	cmp	r3, #0
 8020342:	d158      	bne.n	80203f6 <lv_ddlist_create+0x1c6>
        lv_page_set_anim_time(new_ddlist, LV_DDLIST_DEF_ANIM_TIME);
 8020344:	21c8      	movs	r1, #200	; 0xc8
 8020346:	69f8      	ldr	r0, [r7, #28]
 8020348:	f002 fd80 	bl	8022e4c <lv_page_set_anim_time>

        lv_obj_t * scrl = lv_page_get_scrl(new_ddlist);
 802034c:	69f8      	ldr	r0, [r7, #28]
 802034e:	f002 fde1 	bl	8022f14 <lv_page_get_scrl>
 8020352:	6138      	str	r0, [r7, #16]
        lv_obj_set_drag(scrl, false);
 8020354:	2100      	movs	r1, #0
 8020356:	6938      	ldr	r0, [r7, #16]
 8020358:	f7f1 fd19 	bl	8011d8e <lv_obj_set_drag>
        lv_page_set_scrl_fit2(new_ddlist, LV_FIT_FILL, LV_FIT_TIGHT);
 802035c:	2201      	movs	r2, #1
 802035e:	2103      	movs	r1, #3
 8020360:	69f8      	ldr	r0, [r7, #28]
 8020362:	f7ff ff34 	bl	80201ce <lv_page_set_scrl_fit2>

        ext->label = lv_label_create(new_ddlist, NULL);
 8020366:	2100      	movs	r1, #0
 8020368:	69f8      	ldr	r0, [r7, #28]
 802036a:	f001 f877 	bl	802145c <lv_label_create>
 802036e:	4602      	mov	r2, r0
 8020370:	69bb      	ldr	r3, [r7, #24]
 8020372:	631a      	str	r2, [r3, #48]	; 0x30
        lv_cont_set_fit2(new_ddlist, LV_FIT_TIGHT, LV_FIT_NONE);
 8020374:	2200      	movs	r2, #0
 8020376:	2101      	movs	r1, #1
 8020378:	69f8      	ldr	r0, [r7, #28]
 802037a:	f7ff ff13 	bl	80201a4 <lv_cont_set_fit2>
        lv_page_set_sb_mode(new_ddlist, LV_SB_MODE_HIDE);
 802037e:	2104      	movs	r1, #4
 8020380:	69f8      	ldr	r0, [r7, #28]
 8020382:	f002 fd03 	bl	8022d8c <lv_page_set_sb_mode>
        lv_page_set_style(new_ddlist, LV_PAGE_STYLE_SCRL, &lv_style_transp_tight);
 8020386:	4a4d      	ldr	r2, [pc, #308]	; (80204bc <lv_ddlist_create+0x28c>)
 8020388:	2101      	movs	r1, #1
 802038a:	69f8      	ldr	r0, [r7, #28]
 802038c:	f002 fd70 	bl	8022e70 <lv_page_set_style>

        lv_ddlist_set_options(new_ddlist, "Option 1\nOption 2\nOption 3");
 8020390:	494b      	ldr	r1, [pc, #300]	; (80204c0 <lv_ddlist_create+0x290>)
 8020392:	69f8      	ldr	r0, [r7, #28]
 8020394:	f000 f89a 	bl	80204cc <lv_ddlist_set_options>

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 8020398:	f005 fafa 	bl	8025990 <lv_theme_get_current>
 802039c:	60f8      	str	r0, [r7, #12]
        if(th) {
 802039e:	68fb      	ldr	r3, [r7, #12]
 80203a0:	2b00      	cmp	r3, #0
 80203a2:	d018      	beq.n	80203d6 <lv_ddlist_create+0x1a6>
            lv_ddlist_set_style(new_ddlist, LV_DDLIST_STYLE_BG, th->style.ddlist.bg);
 80203a4:	68fb      	ldr	r3, [r7, #12]
 80203a6:	f8d3 3150 	ldr.w	r3, [r3, #336]	; 0x150
 80203aa:	461a      	mov	r2, r3
 80203ac:	2100      	movs	r1, #0
 80203ae:	69f8      	ldr	r0, [r7, #28]
 80203b0:	f000 f90d 	bl	80205ce <lv_ddlist_set_style>
            lv_ddlist_set_style(new_ddlist, LV_DDLIST_STYLE_SEL, th->style.ddlist.sel);
 80203b4:	68fb      	ldr	r3, [r7, #12]
 80203b6:	f8d3 3154 	ldr.w	r3, [r3, #340]	; 0x154
 80203ba:	461a      	mov	r2, r3
 80203bc:	2101      	movs	r1, #1
 80203be:	69f8      	ldr	r0, [r7, #28]
 80203c0:	f000 f905 	bl	80205ce <lv_ddlist_set_style>
            lv_ddlist_set_style(new_ddlist, LV_DDLIST_STYLE_SB, th->style.ddlist.sb);
 80203c4:	68fb      	ldr	r3, [r7, #12]
 80203c6:	f8d3 3158 	ldr.w	r3, [r3, #344]	; 0x158
 80203ca:	461a      	mov	r2, r3
 80203cc:	2102      	movs	r1, #2
 80203ce:	69f8      	ldr	r0, [r7, #28]
 80203d0:	f000 f8fd 	bl	80205ce <lv_ddlist_set_style>
 80203d4:	e05b      	b.n	802048e <lv_ddlist_create+0x25e>
        } else {
            lv_ddlist_set_style(new_ddlist, LV_DDLIST_STYLE_BG, &lv_style_pretty);
 80203d6:	4a3b      	ldr	r2, [pc, #236]	; (80204c4 <lv_ddlist_create+0x294>)
 80203d8:	2100      	movs	r1, #0
 80203da:	69f8      	ldr	r0, [r7, #28]
 80203dc:	f000 f8f7 	bl	80205ce <lv_ddlist_set_style>
            lv_ddlist_set_style(new_ddlist, LV_DDLIST_STYLE_SEL, &lv_style_plain_color);
 80203e0:	4a32      	ldr	r2, [pc, #200]	; (80204ac <lv_ddlist_create+0x27c>)
 80203e2:	2101      	movs	r1, #1
 80203e4:	69f8      	ldr	r0, [r7, #28]
 80203e6:	f000 f8f2 	bl	80205ce <lv_ddlist_set_style>
            lv_ddlist_set_style(new_ddlist, LV_DDLIST_STYLE_SB, &lv_style_pretty_color);
 80203ea:	4a37      	ldr	r2, [pc, #220]	; (80204c8 <lv_ddlist_create+0x298>)
 80203ec:	2102      	movs	r1, #2
 80203ee:	69f8      	ldr	r0, [r7, #28]
 80203f0:	f000 f8ed 	bl	80205ce <lv_ddlist_set_style>
 80203f4:	e04b      	b.n	802048e <lv_ddlist_create+0x25e>
        }
    }
    /*Copy an existing drop down list*/
    else {
        lv_ddlist_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 80203f6:	6838      	ldr	r0, [r7, #0]
 80203f8:	f7f2 f81b 	bl	8012432 <lv_obj_get_ext_attr>
 80203fc:	6178      	str	r0, [r7, #20]
        ext->label                 = lv_label_create(new_ddlist, copy_ext->label);
 80203fe:	697b      	ldr	r3, [r7, #20]
 8020400:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020402:	4619      	mov	r1, r3
 8020404:	69f8      	ldr	r0, [r7, #28]
 8020406:	f001 f829 	bl	802145c <lv_label_create>
 802040a:	4602      	mov	r2, r0
 802040c:	69bb      	ldr	r3, [r7, #24]
 802040e:	631a      	str	r2, [r3, #48]	; 0x30
        lv_label_set_text(ext->label, lv_label_get_text(copy_ext->label));
 8020410:	69bb      	ldr	r3, [r7, #24]
 8020412:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8020414:	697b      	ldr	r3, [r7, #20]
 8020416:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020418:	4618      	mov	r0, r3
 802041a:	f001 fae6 	bl	80219ea <lv_label_get_text>
 802041e:	4603      	mov	r3, r0
 8020420:	4619      	mov	r1, r3
 8020422:	4620      	mov	r0, r4
 8020424:	f001 f962 	bl	80216ec <lv_label_set_text>
        ext->sel_opt_id     = copy_ext->sel_opt_id;
 8020428:	697b      	ldr	r3, [r7, #20]
 802042a:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 802042c:	69bb      	ldr	r3, [r7, #24]
 802042e:	875a      	strh	r2, [r3, #58]	; 0x3a
        ext->sel_opt_id_ori = copy_ext->sel_opt_id;
 8020430:	697b      	ldr	r3, [r7, #20]
 8020432:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8020434:	69bb      	ldr	r3, [r7, #24]
 8020436:	879a      	strh	r2, [r3, #60]	; 0x3c
        ext->fix_height     = copy_ext->fix_height;
 8020438:	697b      	ldr	r3, [r7, #20]
 802043a:	f9b3 2040 	ldrsh.w	r2, [r3, #64]	; 0x40
 802043e:	69bb      	ldr	r3, [r7, #24]
 8020440:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
        ext->option_cnt     = copy_ext->option_cnt;
 8020444:	697b      	ldr	r3, [r7, #20]
 8020446:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 8020448:	69bb      	ldr	r3, [r7, #24]
 802044a:	871a      	strh	r2, [r3, #56]	; 0x38
        ext->sel_style      = copy_ext->sel_style;
 802044c:	697b      	ldr	r3, [r7, #20]
 802044e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8020450:	69bb      	ldr	r3, [r7, #24]
 8020452:	635a      	str	r2, [r3, #52]	; 0x34
        ext->draw_arrow     = copy_ext->draw_arrow;
 8020454:	697b      	ldr	r3, [r7, #20]
 8020456:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 802045a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 802045e:	b2d9      	uxtb	r1, r3
 8020460:	69ba      	ldr	r2, [r7, #24]
 8020462:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020466:	f361 0382 	bfi	r3, r1, #2, #1
 802046a:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
        ext->stay_open      = copy_ext->stay_open;
 802046e:	697b      	ldr	r3, [r7, #20]
 8020470:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020474:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8020478:	b2d9      	uxtb	r1, r3
 802047a:	69ba      	ldr	r2, [r7, #24]
 802047c:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020480:	f361 03c3 	bfi	r3, r1, #3, #1
 8020484:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_ddlist);
 8020488:	69f8      	ldr	r0, [r7, #28]
 802048a:	f7f1 fc24 	bl	8011cd6 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("drop down list created");

    return new_ddlist;
 802048e:	69fb      	ldr	r3, [r7, #28]
}
 8020490:	4618      	mov	r0, r3
 8020492:	3724      	adds	r7, #36	; 0x24
 8020494:	46bd      	mov	sp, r7
 8020496:	bd90      	pop	{r4, r7, pc}
 8020498:	08028fc0 	.word	0x08028fc0
 802049c:	08028fd0 	.word	0x08028fd0
 80204a0:	2000c3d0 	.word	0x2000c3d0
 80204a4:	2000c3d4 	.word	0x2000c3d4
 80204a8:	2000c3d8 	.word	0x2000c3d8
 80204ac:	2000df08 	.word	0x2000df08
 80204b0:	08020bc9 	.word	0x08020bc9
 80204b4:	08020e61 	.word	0x08020e61
 80204b8:	08020791 	.word	0x08020791
 80204bc:	2000dd64 	.word	0x2000dd64
 80204c0:	08028ff0 	.word	0x08028ff0
 80204c4:	2000dd28 	.word	0x2000dd28
 80204c8:	2000dc38 	.word	0x2000dc38

080204cc <lv_ddlist_set_options>:
 * Set the options in a drop down list from a string
 * @param ddlist pointer to drop down list object
 * @param options a string with '\n' separated options. E.g. "One\nTwo\nThree"
 */
void lv_ddlist_set_options(lv_obj_t * ddlist, const char * options)
{
 80204cc:	b580      	push	{r7, lr}
 80204ce:	b086      	sub	sp, #24
 80204d0:	af02      	add	r7, sp, #8
 80204d2:	6078      	str	r0, [r7, #4]
 80204d4:	6039      	str	r1, [r7, #0]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 80204d6:	6878      	ldr	r0, [r7, #4]
 80204d8:	f7f1 ffab 	bl	8012432 <lv_obj_get_ext_attr>
 80204dc:	60b8      	str	r0, [r7, #8]

    /*Count the '\n'-s to determine the number of options*/
    ext->option_cnt = 0;
 80204de:	68bb      	ldr	r3, [r7, #8]
 80204e0:	2200      	movs	r2, #0
 80204e2:	871a      	strh	r2, [r3, #56]	; 0x38
    uint16_t i;
    for(i = 0; options[i] != '\0'; i++) {
 80204e4:	2300      	movs	r3, #0
 80204e6:	81fb      	strh	r3, [r7, #14]
 80204e8:	e00e      	b.n	8020508 <lv_ddlist_set_options+0x3c>
        if(options[i] == '\n') ext->option_cnt++;
 80204ea:	89fb      	ldrh	r3, [r7, #14]
 80204ec:	683a      	ldr	r2, [r7, #0]
 80204ee:	4413      	add	r3, r2
 80204f0:	781b      	ldrb	r3, [r3, #0]
 80204f2:	2b0a      	cmp	r3, #10
 80204f4:	d105      	bne.n	8020502 <lv_ddlist_set_options+0x36>
 80204f6:	68bb      	ldr	r3, [r7, #8]
 80204f8:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80204fa:	3301      	adds	r3, #1
 80204fc:	b29a      	uxth	r2, r3
 80204fe:	68bb      	ldr	r3, [r7, #8]
 8020500:	871a      	strh	r2, [r3, #56]	; 0x38
    for(i = 0; options[i] != '\0'; i++) {
 8020502:	89fb      	ldrh	r3, [r7, #14]
 8020504:	3301      	adds	r3, #1
 8020506:	81fb      	strh	r3, [r7, #14]
 8020508:	89fb      	ldrh	r3, [r7, #14]
 802050a:	683a      	ldr	r2, [r7, #0]
 802050c:	4413      	add	r3, r2
 802050e:	781b      	ldrb	r3, [r3, #0]
 8020510:	2b00      	cmp	r3, #0
 8020512:	d1ea      	bne.n	80204ea <lv_ddlist_set_options+0x1e>
    }
    ext->option_cnt++; /*Last option has no `\n`*/
 8020514:	68bb      	ldr	r3, [r7, #8]
 8020516:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8020518:	3301      	adds	r3, #1
 802051a:	b29a      	uxth	r2, r3
 802051c:	68bb      	ldr	r3, [r7, #8]
 802051e:	871a      	strh	r2, [r3, #56]	; 0x38
    ext->sel_opt_id     = 0;
 8020520:	68bb      	ldr	r3, [r7, #8]
 8020522:	2200      	movs	r2, #0
 8020524:	875a      	strh	r2, [r3, #58]	; 0x3a
    ext->sel_opt_id_ori = 0;
 8020526:	68bb      	ldr	r3, [r7, #8]
 8020528:	2200      	movs	r2, #0
 802052a:	879a      	strh	r2, [r3, #60]	; 0x3c

    lv_label_set_text(ext->label, options);
 802052c:	68bb      	ldr	r3, [r7, #8]
 802052e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020530:	6839      	ldr	r1, [r7, #0]
 8020532:	4618      	mov	r0, r3
 8020534:	f001 f8da 	bl	80216ec <lv_label_set_text>

    lv_ddlist_refr_width(ddlist);
 8020538:	6878      	ldr	r0, [r7, #4]
 802053a:	f000 ff1e 	bl	802137a <lv_ddlist_refr_width>

    switch(lv_label_get_align(ext->label)) {
 802053e:	68bb      	ldr	r3, [r7, #8]
 8020540:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020542:	4618      	mov	r0, r3
 8020544:	f001 fa70 	bl	8021a28 <lv_label_get_align>
 8020548:	4603      	mov	r3, r0
 802054a:	2b01      	cmp	r3, #1
 802054c:	d00d      	beq.n	802056a <lv_ddlist_set_options+0x9e>
 802054e:	2b02      	cmp	r3, #2
 8020550:	d015      	beq.n	802057e <lv_ddlist_set_options+0xb2>
 8020552:	2b00      	cmp	r3, #0
 8020554:	d11d      	bne.n	8020592 <lv_ddlist_set_options+0xc6>
        case LV_LABEL_ALIGN_LEFT: lv_obj_align(ext->label, NULL, LV_ALIGN_IN_LEFT_MID, 0, 0); break;
 8020556:	68bb      	ldr	r3, [r7, #8]
 8020558:	6b18      	ldr	r0, [r3, #48]	; 0x30
 802055a:	2300      	movs	r3, #0
 802055c:	9300      	str	r3, [sp, #0]
 802055e:	2300      	movs	r3, #0
 8020560:	2207      	movs	r2, #7
 8020562:	2100      	movs	r1, #0
 8020564:	f7f0 fecc 	bl	8011300 <lv_obj_align>
 8020568:	e013      	b.n	8020592 <lv_ddlist_set_options+0xc6>
        case LV_LABEL_ALIGN_CENTER: lv_obj_align(ext->label, NULL, LV_ALIGN_CENTER, 0, 0); break;
 802056a:	68bb      	ldr	r3, [r7, #8]
 802056c:	6b18      	ldr	r0, [r3, #48]	; 0x30
 802056e:	2300      	movs	r3, #0
 8020570:	9300      	str	r3, [sp, #0]
 8020572:	2300      	movs	r3, #0
 8020574:	2200      	movs	r2, #0
 8020576:	2100      	movs	r1, #0
 8020578:	f7f0 fec2 	bl	8011300 <lv_obj_align>
 802057c:	e009      	b.n	8020592 <lv_ddlist_set_options+0xc6>
        case LV_LABEL_ALIGN_RIGHT: lv_obj_align(ext->label, NULL, LV_ALIGN_IN_RIGHT_MID, 0, 0); break;
 802057e:	68bb      	ldr	r3, [r7, #8]
 8020580:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8020582:	2300      	movs	r3, #0
 8020584:	9300      	str	r3, [sp, #0]
 8020586:	2300      	movs	r3, #0
 8020588:	2208      	movs	r2, #8
 802058a:	2100      	movs	r1, #0
 802058c:	f7f0 feb8 	bl	8011300 <lv_obj_align>
 8020590:	bf00      	nop
    }

    lv_ddlist_refr_size(ddlist, false);
 8020592:	2100      	movs	r1, #0
 8020594:	6878      	ldr	r0, [r7, #4]
 8020596:	f000 fd9b 	bl	80210d0 <lv_ddlist_refr_size>
}
 802059a:	bf00      	nop
 802059c:	3710      	adds	r7, #16
 802059e:	46bd      	mov	sp, r7
 80205a0:	bd80      	pop	{r7, pc}

080205a2 <lv_ddlist_set_draw_arrow>:
 * Set arrow draw in a drop down list
 * @param ddlist pointer to drop down list object
 * @param en enable/disable a arrow draw. E.g. "true" for draw.
 */
void lv_ddlist_set_draw_arrow(lv_obj_t * ddlist, bool en)
{
 80205a2:	b580      	push	{r7, lr}
 80205a4:	b084      	sub	sp, #16
 80205a6:	af00      	add	r7, sp, #0
 80205a8:	6078      	str	r0, [r7, #4]
 80205aa:	460b      	mov	r3, r1
 80205ac:	70fb      	strb	r3, [r7, #3]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 80205ae:	6878      	ldr	r0, [r7, #4]
 80205b0:	f7f1 ff3f 	bl	8012432 <lv_obj_get_ext_attr>
 80205b4:	60f8      	str	r0, [r7, #12]

    /*Set the flag*/
    ext->draw_arrow = en ? 1 : 0;
 80205b6:	78f9      	ldrb	r1, [r7, #3]
 80205b8:	68fa      	ldr	r2, [r7, #12]
 80205ba:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 80205be:	f361 0382 	bfi	r3, r1, #2, #1
 80205c2:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
}
 80205c6:	bf00      	nop
 80205c8:	3710      	adds	r7, #16
 80205ca:	46bd      	mov	sp, r7
 80205cc:	bd80      	pop	{r7, pc}

080205ce <lv_ddlist_set_style>:
 * @param ddlist pointer to a drop down list object
 * @param type which style should be set
 * @param style pointer to a style
 */
void lv_ddlist_set_style(lv_obj_t * ddlist, lv_ddlist_style_t type, const lv_style_t * style)
{
 80205ce:	b580      	push	{r7, lr}
 80205d0:	b086      	sub	sp, #24
 80205d2:	af00      	add	r7, sp, #0
 80205d4:	60f8      	str	r0, [r7, #12]
 80205d6:	460b      	mov	r3, r1
 80205d8:	607a      	str	r2, [r7, #4]
 80205da:	72fb      	strb	r3, [r7, #11]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 80205dc:	68f8      	ldr	r0, [r7, #12]
 80205de:	f7f1 ff28 	bl	8012432 <lv_obj_get_ext_attr>
 80205e2:	6178      	str	r0, [r7, #20]

    switch(type) {
 80205e4:	7afb      	ldrb	r3, [r7, #11]
 80205e6:	2b01      	cmp	r3, #1
 80205e8:	d013      	beq.n	8020612 <lv_ddlist_set_style+0x44>
 80205ea:	2b02      	cmp	r3, #2
 80205ec:	d00b      	beq.n	8020606 <lv_ddlist_set_style+0x38>
 80205ee:	2b00      	cmp	r3, #0
 80205f0:	d000      	beq.n	80205f4 <lv_ddlist_set_style+0x26>
            ext->sel_style  = style;
            lv_obj_t * scrl = lv_page_get_scrl(ddlist);
            lv_obj_refresh_ext_draw_pad(scrl); /*Because of the wider selected rectangle*/
            break;
    }
}
 80205f2:	e019      	b.n	8020628 <lv_ddlist_set_style+0x5a>
            lv_page_set_style(ddlist, LV_PAGE_STYLE_BG, style);
 80205f4:	687a      	ldr	r2, [r7, #4]
 80205f6:	2100      	movs	r1, #0
 80205f8:	68f8      	ldr	r0, [r7, #12]
 80205fa:	f002 fc39 	bl	8022e70 <lv_page_set_style>
            lv_ddlist_refr_width(ddlist);
 80205fe:	68f8      	ldr	r0, [r7, #12]
 8020600:	f000 febb 	bl	802137a <lv_ddlist_refr_width>
            break;
 8020604:	e010      	b.n	8020628 <lv_ddlist_set_style+0x5a>
        case LV_DDLIST_STYLE_SB: lv_page_set_style(ddlist, LV_PAGE_STYLE_SB, style); break;
 8020606:	687a      	ldr	r2, [r7, #4]
 8020608:	2102      	movs	r1, #2
 802060a:	68f8      	ldr	r0, [r7, #12]
 802060c:	f002 fc30 	bl	8022e70 <lv_page_set_style>
 8020610:	e00a      	b.n	8020628 <lv_ddlist_set_style+0x5a>
            ext->sel_style  = style;
 8020612:	697b      	ldr	r3, [r7, #20]
 8020614:	687a      	ldr	r2, [r7, #4]
 8020616:	635a      	str	r2, [r3, #52]	; 0x34
            lv_obj_t * scrl = lv_page_get_scrl(ddlist);
 8020618:	68f8      	ldr	r0, [r7, #12]
 802061a:	f002 fc7b 	bl	8022f14 <lv_page_get_scrl>
 802061e:	6138      	str	r0, [r7, #16]
            lv_obj_refresh_ext_draw_pad(scrl); /*Because of the wider selected rectangle*/
 8020620:	6938      	ldr	r0, [r7, #16]
 8020622:	f7f1 fcdf 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>
            break;
 8020626:	bf00      	nop
}
 8020628:	bf00      	nop
 802062a:	3718      	adds	r7, #24
 802062c:	46bd      	mov	sp, r7
 802062e:	bd80      	pop	{r7, pc}

08020630 <lv_ddlist_get_selected_str>:
 * @param ddlist pointer to ddlist object
 * @param buf pointer to an array to store the string
 * @param buf_size size of `buf` in bytes. 0: to ignore it.
 */
void lv_ddlist_get_selected_str(const lv_obj_t * ddlist, char * buf, uint16_t buf_size)
{
 8020630:	b580      	push	{r7, lr}
 8020632:	b08a      	sub	sp, #40	; 0x28
 8020634:	af00      	add	r7, sp, #0
 8020636:	60f8      	str	r0, [r7, #12]
 8020638:	60b9      	str	r1, [r7, #8]
 802063a:	4613      	mov	r3, r2
 802063c:	80fb      	strh	r3, [r7, #6]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 802063e:	68f8      	ldr	r0, [r7, #12]
 8020640:	f7f1 fef7 	bl	8012432 <lv_obj_get_ext_attr>
 8020644:	61f8      	str	r0, [r7, #28]

    uint16_t i;
    uint16_t line        = 0;
 8020646:	2300      	movs	r3, #0
 8020648:	84bb      	strh	r3, [r7, #36]	; 0x24
    const char * opt_txt = lv_label_get_text(ext->label);
 802064a:	69fb      	ldr	r3, [r7, #28]
 802064c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802064e:	4618      	mov	r0, r3
 8020650:	f001 f9cb 	bl	80219ea <lv_label_get_text>
 8020654:	61b8      	str	r0, [r7, #24]
    uint16_t txt_len     = strlen(opt_txt);
 8020656:	69b8      	ldr	r0, [r7, #24]
 8020658:	f7df fde4 	bl	8000224 <strlen>
 802065c:	4603      	mov	r3, r0
 802065e:	82fb      	strh	r3, [r7, #22]

    for(i = 0; i < txt_len && line != ext->sel_opt_id; i++) {
 8020660:	2300      	movs	r3, #0
 8020662:	84fb      	strh	r3, [r7, #38]	; 0x26
 8020664:	e00b      	b.n	802067e <lv_ddlist_get_selected_str+0x4e>
        if(opt_txt[i] == '\n') line++;
 8020666:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8020668:	69ba      	ldr	r2, [r7, #24]
 802066a:	4413      	add	r3, r2
 802066c:	781b      	ldrb	r3, [r3, #0]
 802066e:	2b0a      	cmp	r3, #10
 8020670:	d102      	bne.n	8020678 <lv_ddlist_get_selected_str+0x48>
 8020672:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8020674:	3301      	adds	r3, #1
 8020676:	84bb      	strh	r3, [r7, #36]	; 0x24
    for(i = 0; i < txt_len && line != ext->sel_opt_id; i++) {
 8020678:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 802067a:	3301      	adds	r3, #1
 802067c:	84fb      	strh	r3, [r7, #38]	; 0x26
 802067e:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8020680:	8afb      	ldrh	r3, [r7, #22]
 8020682:	429a      	cmp	r2, r3
 8020684:	d204      	bcs.n	8020690 <lv_ddlist_get_selected_str+0x60>
 8020686:	69fb      	ldr	r3, [r7, #28]
 8020688:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 802068a:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 802068c:	429a      	cmp	r2, r3
 802068e:	d1ea      	bne.n	8020666 <lv_ddlist_get_selected_str+0x36>
    }

    uint16_t c;
    for(c = 0; opt_txt[i] != '\n' && i < txt_len; c++, i++) {
 8020690:	2300      	movs	r3, #0
 8020692:	847b      	strh	r3, [r7, #34]	; 0x22
 8020694:	e01d      	b.n	80206d2 <lv_ddlist_get_selected_str+0xa2>
        if(buf_size && c >= buf_size - 1) {
 8020696:	88fb      	ldrh	r3, [r7, #6]
 8020698:	2b00      	cmp	r3, #0
 802069a:	d00c      	beq.n	80206b6 <lv_ddlist_get_selected_str+0x86>
 802069c:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 802069e:	88fb      	ldrh	r3, [r7, #6]
 80206a0:	3b01      	subs	r3, #1
 80206a2:	429a      	cmp	r2, r3
 80206a4:	db07      	blt.n	80206b6 <lv_ddlist_get_selected_str+0x86>
            LV_LOG_WARN("lv_ddlist_get_selected_str: the buffer was too small")
 80206a6:	4b14      	ldr	r3, [pc, #80]	; (80206f8 <lv_ddlist_get_selected_str+0xc8>)
 80206a8:	f240 1261 	movw	r2, #353	; 0x161
 80206ac:	4913      	ldr	r1, [pc, #76]	; (80206fc <lv_ddlist_get_selected_str+0xcc>)
 80206ae:	2002      	movs	r0, #2
 80206b0:	f7fc f8ac 	bl	801c80c <lv_log_add>
            break;
 80206b4:	e017      	b.n	80206e6 <lv_ddlist_get_selected_str+0xb6>
        }
        buf[c] = opt_txt[i];
 80206b6:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80206b8:	69ba      	ldr	r2, [r7, #24]
 80206ba:	441a      	add	r2, r3
 80206bc:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80206be:	68b9      	ldr	r1, [r7, #8]
 80206c0:	440b      	add	r3, r1
 80206c2:	7812      	ldrb	r2, [r2, #0]
 80206c4:	701a      	strb	r2, [r3, #0]
    for(c = 0; opt_txt[i] != '\n' && i < txt_len; c++, i++) {
 80206c6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80206c8:	3301      	adds	r3, #1
 80206ca:	847b      	strh	r3, [r7, #34]	; 0x22
 80206cc:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80206ce:	3301      	adds	r3, #1
 80206d0:	84fb      	strh	r3, [r7, #38]	; 0x26
 80206d2:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 80206d4:	69ba      	ldr	r2, [r7, #24]
 80206d6:	4413      	add	r3, r2
 80206d8:	781b      	ldrb	r3, [r3, #0]
 80206da:	2b0a      	cmp	r3, #10
 80206dc:	d003      	beq.n	80206e6 <lv_ddlist_get_selected_str+0xb6>
 80206de:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 80206e0:	8afb      	ldrh	r3, [r7, #22]
 80206e2:	429a      	cmp	r2, r3
 80206e4:	d3d7      	bcc.n	8020696 <lv_ddlist_get_selected_str+0x66>
    }

    buf[c] = '\0';
 80206e6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 80206e8:	68ba      	ldr	r2, [r7, #8]
 80206ea:	4413      	add	r3, r2
 80206ec:	2200      	movs	r2, #0
 80206ee:	701a      	strb	r2, [r3, #0]
}
 80206f0:	bf00      	nop
 80206f2:	3728      	adds	r7, #40	; 0x28
 80206f4:	46bd      	mov	sp, r7
 80206f6:	bd80      	pop	{r7, pc}
 80206f8:	0802900c 	.word	0x0802900c
 80206fc:	08028fd0 	.word	0x08028fd0

08020700 <lv_ddlist_get_style>:
 * @param ddlist pointer to a drop down list object
 * @param type which style should be get
 * @return style pointer to a style
 */
const lv_style_t * lv_ddlist_get_style(const lv_obj_t * ddlist, lv_ddlist_style_t type)
{
 8020700:	b580      	push	{r7, lr}
 8020702:	b084      	sub	sp, #16
 8020704:	af00      	add	r7, sp, #0
 8020706:	6078      	str	r0, [r7, #4]
 8020708:	460b      	mov	r3, r1
 802070a:	70fb      	strb	r3, [r7, #3]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 802070c:	6878      	ldr	r0, [r7, #4]
 802070e:	f7f1 fe90 	bl	8012432 <lv_obj_get_ext_attr>
 8020712:	60f8      	str	r0, [r7, #12]

    switch(type) {
 8020714:	78fb      	ldrb	r3, [r7, #3]
 8020716:	2b01      	cmp	r3, #1
 8020718:	d00f      	beq.n	802073a <lv_ddlist_get_style+0x3a>
 802071a:	2b02      	cmp	r3, #2
 802071c:	d007      	beq.n	802072e <lv_ddlist_get_style+0x2e>
 802071e:	2b00      	cmp	r3, #0
 8020720:	d10e      	bne.n	8020740 <lv_ddlist_get_style+0x40>
        case LV_DDLIST_STYLE_BG: return lv_page_get_style(ddlist, LV_PAGE_STYLE_BG);
 8020722:	2100      	movs	r1, #0
 8020724:	6878      	ldr	r0, [r7, #4]
 8020726:	f002 fc11 	bl	8022f4c <lv_page_get_style>
 802072a:	4603      	mov	r3, r0
 802072c:	e009      	b.n	8020742 <lv_ddlist_get_style+0x42>
        case LV_DDLIST_STYLE_SB: return lv_page_get_style(ddlist, LV_PAGE_STYLE_SB);
 802072e:	2102      	movs	r1, #2
 8020730:	6878      	ldr	r0, [r7, #4]
 8020732:	f002 fc0b 	bl	8022f4c <lv_page_get_style>
 8020736:	4603      	mov	r3, r0
 8020738:	e003      	b.n	8020742 <lv_ddlist_get_style+0x42>
        case LV_DDLIST_STYLE_SEL: return ext->sel_style;
 802073a:	68fb      	ldr	r3, [r7, #12]
 802073c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 802073e:	e000      	b.n	8020742 <lv_ddlist_get_style+0x42>
        default: return NULL;
 8020740:	2300      	movs	r3, #0
    }

    /*To avoid warning*/
    return NULL;
}
 8020742:	4618      	mov	r0, r3
 8020744:	3710      	adds	r7, #16
 8020746:	46bd      	mov	sp, r7
 8020748:	bd80      	pop	{r7, pc}

0802074a <lv_ddlist_get_txt_flag>:
 * Get the text alignment flag for a drop down list.
 * @param ddlist drop down list
 * @return text alignment flag
 */
static lv_txt_flag_t lv_ddlist_get_txt_flag(const lv_obj_t * ddlist)
{
 802074a:	b580      	push	{r7, lr}
 802074c:	b084      	sub	sp, #16
 802074e:	af00      	add	r7, sp, #0
 8020750:	6078      	str	r0, [r7, #4]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 8020752:	6878      	ldr	r0, [r7, #4]
 8020754:	f7f1 fe6d 	bl	8012432 <lv_obj_get_ext_attr>
 8020758:	60f8      	str	r0, [r7, #12]

    /*The label might be already deleted so just return with some value*/
    if(!ext->label) return LV_TXT_FLAG_CENTER;
 802075a:	68fb      	ldr	r3, [r7, #12]
 802075c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802075e:	2b00      	cmp	r3, #0
 8020760:	d101      	bne.n	8020766 <lv_ddlist_get_txt_flag+0x1c>
 8020762:	2304      	movs	r3, #4
 8020764:	e010      	b.n	8020788 <lv_ddlist_get_txt_flag+0x3e>

    lv_label_align_t align = lv_label_get_align(ext->label);
 8020766:	68fb      	ldr	r3, [r7, #12]
 8020768:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802076a:	4618      	mov	r0, r3
 802076c:	f001 f95c 	bl	8021a28 <lv_label_get_align>
 8020770:	4603      	mov	r3, r0
 8020772:	72fb      	strb	r3, [r7, #11]

    switch(align) {
 8020774:	7afb      	ldrb	r3, [r7, #11]
 8020776:	2b01      	cmp	r3, #1
 8020778:	d003      	beq.n	8020782 <lv_ddlist_get_txt_flag+0x38>
 802077a:	2b02      	cmp	r3, #2
 802077c:	d003      	beq.n	8020786 <lv_ddlist_get_txt_flag+0x3c>
        default:
        case LV_LABEL_ALIGN_LEFT: return LV_TXT_FLAG_NONE;
 802077e:	2300      	movs	r3, #0
 8020780:	e002      	b.n	8020788 <lv_ddlist_get_txt_flag+0x3e>
        case LV_LABEL_ALIGN_CENTER: return LV_TXT_FLAG_CENTER;
 8020782:	2304      	movs	r3, #4
 8020784:	e000      	b.n	8020788 <lv_ddlist_get_txt_flag+0x3e>
        case LV_LABEL_ALIGN_RIGHT: return LV_TXT_FLAG_RIGHT;
 8020786:	2308      	movs	r3, #8
    }
}
 8020788:	4618      	mov	r0, r3
 802078a:	3710      	adds	r7, #16
 802078c:	46bd      	mov	sp, r7
 802078e:	bd80      	pop	{r7, pc}

08020790 <lv_ddlist_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_ddlist_design(lv_obj_t * ddlist, const lv_area_t * mask, lv_design_mode_t mode)
{
 8020790:	b5b0      	push	{r4, r5, r7, lr}
 8020792:	b0b4      	sub	sp, #208	; 0xd0
 8020794:	af06      	add	r7, sp, #24
 8020796:	60f8      	str	r0, [r7, #12]
 8020798:	60b9      	str	r1, [r7, #8]
 802079a:	4613      	mov	r3, r2
 802079c:	71fb      	strb	r3, [r7, #7]
    /*Return false if the object is not covers the mask_p area*/
    if(mode == LV_DESIGN_COVER_CHK) {
 802079e:	79fb      	ldrb	r3, [r7, #7]
 80207a0:	2b02      	cmp	r3, #2
 80207a2:	d107      	bne.n	80207b4 <lv_ddlist_design+0x24>
        return ancestor_design(ddlist, mask, mode);
 80207a4:	4bb4      	ldr	r3, [pc, #720]	; (8020a78 <lv_ddlist_design+0x2e8>)
 80207a6:	681b      	ldr	r3, [r3, #0]
 80207a8:	79fa      	ldrb	r2, [r7, #7]
 80207aa:	68b9      	ldr	r1, [r7, #8]
 80207ac:	68f8      	ldr	r0, [r7, #12]
 80207ae:	4798      	blx	r3
 80207b0:	4603      	mov	r3, r0
 80207b2:	e201      	b.n	8020bb8 <lv_ddlist_design+0x428>
    }
    /*Draw the object*/
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 80207b4:	79fb      	ldrb	r3, [r7, #7]
 80207b6:	2b00      	cmp	r3, #0
 80207b8:	f040 808b 	bne.w	80208d2 <lv_ddlist_design+0x142>
        ancestor_design(ddlist, mask, mode);
 80207bc:	4bae      	ldr	r3, [pc, #696]	; (8020a78 <lv_ddlist_design+0x2e8>)
 80207be:	681b      	ldr	r3, [r3, #0]
 80207c0:	79fa      	ldrb	r2, [r7, #7]
 80207c2:	68b9      	ldr	r1, [r7, #8]
 80207c4:	68f8      	ldr	r0, [r7, #12]
 80207c6:	4798      	blx	r3

        lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 80207c8:	68f8      	ldr	r0, [r7, #12]
 80207ca:	f7f1 fe32 	bl	8012432 <lv_obj_get_ext_attr>
 80207ce:	f8c7 0088 	str.w	r0, [r7, #136]	; 0x88
        lv_opa_t opa_scale    = lv_obj_get_opa_scale(ddlist);
 80207d2:	68f8      	ldr	r0, [r7, #12]
 80207d4:	f7f1 fddf 	bl	8012396 <lv_obj_get_opa_scale>
 80207d8:	4603      	mov	r3, r0
 80207da:	f887 3087 	strb.w	r3, [r7, #135]	; 0x87
        /*If the list is opened draw a rectangle under the selected item*/
        if(ext->opened != 0 || ext->force_sel) {
 80207de:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80207e2:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80207e6:	f003 0301 	and.w	r3, r3, #1
 80207ea:	b2db      	uxtb	r3, r3
 80207ec:	2b00      	cmp	r3, #0
 80207ee:	d109      	bne.n	8020804 <lv_ddlist_design+0x74>
 80207f0:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80207f4:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80207f8:	f003 0302 	and.w	r3, r3, #2
 80207fc:	b2db      	uxtb	r3, r3
 80207fe:	2b00      	cmp	r3, #0
 8020800:	f000 81d9 	beq.w	8020bb6 <lv_ddlist_design+0x426>
            const lv_style_t * style = lv_ddlist_get_style(ddlist, LV_DDLIST_STYLE_BG);
 8020804:	2100      	movs	r1, #0
 8020806:	68f8      	ldr	r0, [r7, #12]
 8020808:	f7ff ff7a 	bl	8020700 <lv_ddlist_get_style>
 802080c:	f8c7 0080 	str.w	r0, [r7, #128]	; 0x80
            const lv_font_t * font   = style->text.font;
 8020810:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8020814:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020816:	67fb      	str	r3, [r7, #124]	; 0x7c
            lv_coord_t font_h        = lv_font_get_line_height(font);
 8020818:	6ff8      	ldr	r0, [r7, #124]	; 0x7c
 802081a:	f7ff fcb7 	bl	802018c <lv_font_get_line_height>
 802081e:	4603      	mov	r3, r0
 8020820:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a

            /*Draw the selected*/
            lv_area_t rect_area;
            rect_area.y1 = ext->label->coords.y1;
 8020824:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 8020828:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802082a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802082e:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            rect_area.y1 += ext->sel_opt_id * (font_h + style->text.line_space);
 8020832:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	; 0x72
 8020836:	b29a      	uxth	r2, r3
 8020838:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 802083c:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
 802083e:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8020842:	f8d7 0080 	ldr.w	r0, [r7, #128]	; 0x80
 8020846:	f9b0 002a 	ldrsh.w	r0, [r0, #42]	; 0x2a
 802084a:	4403      	add	r3, r0
 802084c:	b29b      	uxth	r3, r3
 802084e:	fb11 f303 	smulbb	r3, r1, r3
 8020852:	b29b      	uxth	r3, r3
 8020854:	4413      	add	r3, r2
 8020856:	b29b      	uxth	r3, r3
 8020858:	b21b      	sxth	r3, r3
 802085a:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
            rect_area.y1 -= style->text.line_space / 2;
 802085e:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	; 0x72
 8020862:	b29a      	uxth	r2, r3
 8020864:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8020868:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 802086c:	2b00      	cmp	r3, #0
 802086e:	da00      	bge.n	8020872 <lv_ddlist_design+0xe2>
 8020870:	3301      	adds	r3, #1
 8020872:	105b      	asrs	r3, r3, #1
 8020874:	b21b      	sxth	r3, r3
 8020876:	b29b      	uxth	r3, r3
 8020878:	1ad3      	subs	r3, r2, r3
 802087a:	b29b      	uxth	r3, r3
 802087c:	b21b      	sxth	r3, r3
 802087e:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

            rect_area.y2 = rect_area.y1 + font_h + style->text.line_space - 1;
 8020882:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	; 0x72
 8020886:	b29a      	uxth	r2, r3
 8020888:	f8b7 307a 	ldrh.w	r3, [r7, #122]	; 0x7a
 802088c:	4413      	add	r3, r2
 802088e:	b29a      	uxth	r2, r3
 8020890:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 8020894:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020898:	b29b      	uxth	r3, r3
 802089a:	4413      	add	r3, r2
 802089c:	b29b      	uxth	r3, r3
 802089e:	3b01      	subs	r3, #1
 80208a0:	b29b      	uxth	r3, r3
 80208a2:	b21b      	sxth	r3, r3
 80208a4:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76
            rect_area.x1 = ddlist->coords.x1;
 80208a8:	68fb      	ldr	r3, [r7, #12]
 80208aa:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80208ae:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70
            rect_area.x2 = ddlist->coords.x2;
 80208b2:	68fb      	ldr	r3, [r7, #12]
 80208b4:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80208b8:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74

            lv_draw_rect(&rect_area, mask, ext->sel_style, opa_scale);
 80208bc:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80208c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80208c2:	f897 3087 	ldrb.w	r3, [r7, #135]	; 0x87
 80208c6:	f107 0070 	add.w	r0, r7, #112	; 0x70
 80208ca:	68b9      	ldr	r1, [r7, #8]
 80208cc:	f7f5 f819 	bl	8015902 <lv_draw_rect>
 80208d0:	e171      	b.n	8020bb6 <lv_ddlist_design+0x426>
        }
    }
    /*Post draw when the children are drawn*/
    else if(mode == LV_DESIGN_DRAW_POST) {
 80208d2:	79fb      	ldrb	r3, [r7, #7]
 80208d4:	2b01      	cmp	r3, #1
 80208d6:	f040 816e 	bne.w	8020bb6 <lv_ddlist_design+0x426>
        /*Redraw the text on the selected area with a different color*/
        lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 80208da:	68f8      	ldr	r0, [r7, #12]
 80208dc:	f7f1 fda9 	bl	8012432 <lv_obj_get_ext_attr>
 80208e0:	f8c7 00b4 	str.w	r0, [r7, #180]	; 0xb4
        lv_opa_t opa_scale    = lv_obj_get_opa_scale(ddlist);
 80208e4:	68f8      	ldr	r0, [r7, #12]
 80208e6:	f7f1 fd56 	bl	8012396 <lv_obj_get_opa_scale>
 80208ea:	4603      	mov	r3, r0
 80208ec:	f887 30b3 	strb.w	r3, [r7, #179]	; 0xb3

        /*Redraw only in opened state*/
        if(ext->opened || ext->force_sel) {
 80208f0:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 80208f4:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80208f8:	f003 0301 	and.w	r3, r3, #1
 80208fc:	b2db      	uxtb	r3, r3
 80208fe:	2b00      	cmp	r3, #0
 8020900:	d109      	bne.n	8020916 <lv_ddlist_design+0x186>
 8020902:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8020906:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 802090a:	f003 0302 	and.w	r3, r3, #2
 802090e:	b2db      	uxtb	r3, r3
 8020910:	2b00      	cmp	r3, #0
 8020912:	f000 80b3 	beq.w	8020a7c <lv_ddlist_design+0x2ec>
            const lv_style_t * style = lv_ddlist_get_style(ddlist, LV_DDLIST_STYLE_BG);
 8020916:	2100      	movs	r1, #0
 8020918:	68f8      	ldr	r0, [r7, #12]
 802091a:	f7ff fef1 	bl	8020700 <lv_ddlist_get_style>
 802091e:	f8c7 009c 	str.w	r0, [r7, #156]	; 0x9c
            const lv_font_t * font   = style->text.font;
 8020922:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8020926:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020928:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
            lv_coord_t font_h        = lv_font_get_line_height(font);
 802092c:	f8d7 0098 	ldr.w	r0, [r7, #152]	; 0x98
 8020930:	f7ff fc2c 	bl	802018c <lv_font_get_line_height>
 8020934:	4603      	mov	r3, r0
 8020936:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96

            lv_area_t area_sel;
            area_sel.y1 = ext->label->coords.y1;
 802093a:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 802093e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020940:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8020944:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            area_sel.y1 += ext->sel_opt_id * (font_h + style->text.line_space);
 8020948:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 802094c:	b29a      	uxth	r2, r3
 802094e:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8020952:	8f59      	ldrh	r1, [r3, #58]	; 0x3a
 8020954:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 8020958:	f8d7 009c 	ldr.w	r0, [r7, #156]	; 0x9c
 802095c:	f9b0 002a 	ldrsh.w	r0, [r0, #42]	; 0x2a
 8020960:	4403      	add	r3, r0
 8020962:	b29b      	uxth	r3, r3
 8020964:	fb11 f303 	smulbb	r3, r1, r3
 8020968:	b29b      	uxth	r3, r3
 802096a:	4413      	add	r3, r2
 802096c:	b29b      	uxth	r3, r3
 802096e:	b21b      	sxth	r3, r3
 8020970:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a
            area_sel.y1 -= style->text.line_space / 2;
 8020974:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 8020978:	b29a      	uxth	r2, r3
 802097a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 802097e:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020982:	2b00      	cmp	r3, #0
 8020984:	da00      	bge.n	8020988 <lv_ddlist_design+0x1f8>
 8020986:	3301      	adds	r3, #1
 8020988:	105b      	asrs	r3, r3, #1
 802098a:	b21b      	sxth	r3, r3
 802098c:	b29b      	uxth	r3, r3
 802098e:	1ad3      	subs	r3, r2, r3
 8020990:	b29b      	uxth	r3, r3
 8020992:	b21b      	sxth	r3, r3
 8020994:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

            area_sel.y2 = area_sel.y1 + font_h + style->text.line_space - 1;
 8020998:	f9b7 306a 	ldrsh.w	r3, [r7, #106]	; 0x6a
 802099c:	b29a      	uxth	r2, r3
 802099e:	f8b7 3096 	ldrh.w	r3, [r7, #150]	; 0x96
 80209a2:	4413      	add	r3, r2
 80209a4:	b29a      	uxth	r2, r3
 80209a6:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80209aa:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80209ae:	b29b      	uxth	r3, r3
 80209b0:	4413      	add	r3, r2
 80209b2:	b29b      	uxth	r3, r3
 80209b4:	3b01      	subs	r3, #1
 80209b6:	b29b      	uxth	r3, r3
 80209b8:	b21b      	sxth	r3, r3
 80209ba:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
            area_sel.x1 = ddlist->coords.x1;
 80209be:	68fb      	ldr	r3, [r7, #12]
 80209c0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80209c4:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
            area_sel.x2 = ddlist->coords.x2;
 80209c8:	68fb      	ldr	r3, [r7, #12]
 80209ca:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80209ce:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
            lv_area_t mask_sel;
            bool area_ok;
            area_ok = lv_area_intersect(&mask_sel, mask, &area_sel);
 80209d2:	f107 0268 	add.w	r2, r7, #104	; 0x68
 80209d6:	f107 0360 	add.w	r3, r7, #96	; 0x60
 80209da:	68b9      	ldr	r1, [r7, #8]
 80209dc:	4618      	mov	r0, r3
 80209de:	f7fb f87b 	bl	801bad8 <lv_area_intersect>
 80209e2:	4603      	mov	r3, r0
 80209e4:	f887 3095 	strb.w	r3, [r7, #149]	; 0x95
            if(area_ok) {
 80209e8:	f897 3095 	ldrb.w	r3, [r7, #149]	; 0x95
 80209ec:	2b00      	cmp	r3, #0
 80209ee:	f000 80db 	beq.w	8020ba8 <lv_ddlist_design+0x418>
                const lv_style_t * sel_style = lv_ddlist_get_style(ddlist, LV_DDLIST_STYLE_SEL);
 80209f2:	2101      	movs	r1, #1
 80209f4:	68f8      	ldr	r0, [r7, #12]
 80209f6:	f7ff fe83 	bl	8020700 <lv_ddlist_get_style>
 80209fa:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
                lv_style_t new_style;
                lv_style_copy(&new_style, style);
 80209fe:	f107 0314 	add.w	r3, r7, #20
 8020a02:	f8d7 109c 	ldr.w	r1, [r7, #156]	; 0x9c
 8020a06:	4618      	mov	r0, r3
 8020a08:	f7f3 f82c 	bl	8013a64 <lv_style_copy>
                new_style.text.color = sel_style->text.color;
 8020a0c:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020a10:	8c1b      	ldrh	r3, [r3, #32]
 8020a12:	86bb      	strh	r3, [r7, #52]	; 0x34
                new_style.text.opa   = sel_style->text.opa;
 8020a14:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8020a18:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8020a1c:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
                lv_txt_flag_t flag   = lv_ddlist_get_txt_flag(ddlist);
 8020a20:	68f8      	ldr	r0, [r7, #12]
 8020a22:	f7ff fe92 	bl	802074a <lv_ddlist_get_txt_flag>
 8020a26:	4603      	mov	r3, r0
 8020a28:	f887 308f 	strb.w	r3, [r7, #143]	; 0x8f
                lv_draw_label(&ext->label->coords, &mask_sel, &new_style, opa_scale, lv_label_get_text(ext->label),
 8020a2c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8020a30:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020a32:	f103 0410 	add.w	r4, r3, #16
 8020a36:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8020a3a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020a3c:	4618      	mov	r0, r3
 8020a3e:	f000 ffd4 	bl	80219ea <lv_label_get_text>
 8020a42:	4605      	mov	r5, r0
 8020a44:	f897 00b3 	ldrb.w	r0, [r7, #179]	; 0xb3
 8020a48:	f107 0214 	add.w	r2, r7, #20
 8020a4c:	f107 0160 	add.w	r1, r7, #96	; 0x60
 8020a50:	2300      	movs	r3, #0
 8020a52:	9305      	str	r3, [sp, #20]
 8020a54:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020a58:	9304      	str	r3, [sp, #16]
 8020a5a:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020a5e:	9303      	str	r3, [sp, #12]
 8020a60:	2300      	movs	r3, #0
 8020a62:	9302      	str	r3, [sp, #8]
 8020a64:	f897 308f 	ldrb.w	r3, [r7, #143]	; 0x8f
 8020a68:	9301      	str	r3, [sp, #4]
 8020a6a:	9500      	str	r5, [sp, #0]
 8020a6c:	4603      	mov	r3, r0
 8020a6e:	4620      	mov	r0, r4
 8020a70:	f7f4 fab4 	bl	8014fdc <lv_draw_label>
        if(ext->opened || ext->force_sel) {
 8020a74:	e098      	b.n	8020ba8 <lv_ddlist_design+0x418>
 8020a76:	bf00      	nop
 8020a78:	2000c3d8 	.word	0x2000c3d8
        }

        /*Add a down symbol in ddlist when closed*/
        else {
            /*Draw a arrow in ddlist if enabled*/
            if(ext->draw_arrow) {
 8020a7c:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8020a80:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020a84:	f003 0304 	and.w	r3, r3, #4
 8020a88:	b2db      	uxtb	r3, r3
 8020a8a:	2b00      	cmp	r3, #0
 8020a8c:	f000 808d 	beq.w	8020baa <lv_ddlist_design+0x41a>
                const lv_style_t * style     = lv_ddlist_get_style(ddlist, LV_DDLIST_STYLE_BG);
 8020a90:	2100      	movs	r1, #0
 8020a92:	68f8      	ldr	r0, [r7, #12]
 8020a94:	f7ff fe34 	bl	8020700 <lv_ddlist_get_style>
 8020a98:	f8c7 00ac 	str.w	r0, [r7, #172]	; 0xac
                const lv_font_t * font       = style->text.font;
 8020a9c:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8020aa0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8020aa2:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
                const lv_style_t * sel_style = lv_ddlist_get_style(ddlist, LV_DDLIST_STYLE_BG);
 8020aa6:	2100      	movs	r1, #0
 8020aa8:	68f8      	ldr	r0, [r7, #12]
 8020aaa:	f7ff fe29 	bl	8020700 <lv_ddlist_get_style>
 8020aae:	f8c7 00a4 	str.w	r0, [r7, #164]	; 0xa4
                lv_coord_t font_h            = lv_font_get_line_height(font);
 8020ab2:	f8d7 00a8 	ldr.w	r0, [r7, #168]	; 0xa8
 8020ab6:	f7ff fb69 	bl	802018c <lv_font_get_line_height>
 8020aba:	4603      	mov	r3, r0
 8020abc:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2
                lv_style_t new_style;
                lv_style_copy(&new_style, style);
 8020ac0:	f107 0314 	add.w	r3, r7, #20
 8020ac4:	f8d7 10ac 	ldr.w	r1, [r7, #172]	; 0xac
 8020ac8:	4618      	mov	r0, r3
 8020aca:	f7f2 ffcb 	bl	8013a64 <lv_style_copy>
                new_style.text.color = sel_style->text.color;
 8020ace:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8020ad2:	8c1b      	ldrh	r3, [r3, #32]
 8020ad4:	86bb      	strh	r3, [r7, #52]	; 0x34
                new_style.text.opa   = sel_style->text.opa;
 8020ad6:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8020ada:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8020ade:	f887 3040 	strb.w	r3, [r7, #64]	; 0x40
                lv_area_t area_arrow;
                area_arrow.x2 = ddlist->coords.x2 - style->body.padding.right;
 8020ae2:	68fb      	ldr	r3, [r7, #12]
 8020ae4:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8020ae8:	b29a      	uxth	r2, r3
 8020aea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8020aee:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8020af2:	b29b      	uxth	r3, r3
 8020af4:	1ad3      	subs	r3, r2, r3
 8020af6:	b29b      	uxth	r3, r3
 8020af8:	b21b      	sxth	r3, r3
 8020afa:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
                area_arrow.x1 = area_arrow.x2 -
 8020afe:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8020b02:	b29c      	uxth	r4, r3
                                lv_txt_get_width(LV_SYMBOL_DOWN, strlen(LV_SYMBOL_DOWN), sel_style->text.font, 0, 0);
 8020b04:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 8020b08:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8020b0a:	2300      	movs	r3, #0
 8020b0c:	9300      	str	r3, [sp, #0]
 8020b0e:	2300      	movs	r3, #0
 8020b10:	2103      	movs	r1, #3
 8020b12:	482b      	ldr	r0, [pc, #172]	; (8020bc0 <lv_ddlist_design+0x430>)
 8020b14:	f7fc fc7a 	bl	801d40c <lv_txt_get_width>
 8020b18:	4603      	mov	r3, r0
 8020b1a:	b29b      	uxth	r3, r3
                area_arrow.x1 = area_arrow.x2 -
 8020b1c:	1ae3      	subs	r3, r4, r3
 8020b1e:	b29b      	uxth	r3, r3
 8020b20:	b21b      	sxth	r3, r3
 8020b22:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58

                area_arrow.y1 = ddlist->coords.y1 + style->text.line_space;
 8020b26:	68fb      	ldr	r3, [r7, #12]
 8020b28:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8020b2c:	b29a      	uxth	r2, r3
 8020b2e:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8020b32:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8020b36:	b29b      	uxth	r3, r3
 8020b38:	4413      	add	r3, r2
 8020b3a:	b29b      	uxth	r3, r3
 8020b3c:	b21b      	sxth	r3, r3
 8020b3e:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
                area_arrow.y2 = area_arrow.y1 + font_h;
 8020b42:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8020b46:	b29a      	uxth	r2, r3
 8020b48:	f8b7 30a2 	ldrh.w	r3, [r7, #162]	; 0xa2
 8020b4c:	4413      	add	r3, r2
 8020b4e:	b29b      	uxth	r3, r3
 8020b50:	b21b      	sxth	r3, r3
 8020b52:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e

                lv_area_t mask_arrow;
                bool area_ok;
                area_ok = lv_area_intersect(&mask_arrow, mask, &area_arrow);
 8020b56:	f107 0258 	add.w	r2, r7, #88	; 0x58
 8020b5a:	f107 0350 	add.w	r3, r7, #80	; 0x50
 8020b5e:	68b9      	ldr	r1, [r7, #8]
 8020b60:	4618      	mov	r0, r3
 8020b62:	f7fa ffb9 	bl	801bad8 <lv_area_intersect>
 8020b66:	4603      	mov	r3, r0
 8020b68:	f887 30a1 	strb.w	r3, [r7, #161]	; 0xa1
                if(area_ok) {
 8020b6c:	f897 30a1 	ldrb.w	r3, [r7, #161]	; 0xa1
 8020b70:	2b00      	cmp	r3, #0
 8020b72:	d01a      	beq.n	8020baa <lv_ddlist_design+0x41a>
                    lv_draw_label(&area_arrow, &mask_arrow, &new_style, opa_scale, LV_SYMBOL_DOWN, LV_TXT_FLAG_NONE,
 8020b74:	f897 40b3 	ldrb.w	r4, [r7, #179]	; 0xb3
 8020b78:	f107 0214 	add.w	r2, r7, #20
 8020b7c:	f107 0150 	add.w	r1, r7, #80	; 0x50
 8020b80:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8020b84:	2300      	movs	r3, #0
 8020b86:	9305      	str	r3, [sp, #20]
 8020b88:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020b8c:	9304      	str	r3, [sp, #16]
 8020b8e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8020b92:	9303      	str	r3, [sp, #12]
 8020b94:	2300      	movs	r3, #0
 8020b96:	9302      	str	r3, [sp, #8]
 8020b98:	2300      	movs	r3, #0
 8020b9a:	9301      	str	r3, [sp, #4]
 8020b9c:	4b08      	ldr	r3, [pc, #32]	; (8020bc0 <lv_ddlist_design+0x430>)
 8020b9e:	9300      	str	r3, [sp, #0]
 8020ba0:	4623      	mov	r3, r4
 8020ba2:	f7f4 fa1b 	bl	8014fdc <lv_draw_label>
 8020ba6:	e000      	b.n	8020baa <lv_ddlist_design+0x41a>
        if(ext->opened || ext->force_sel) {
 8020ba8:	bf00      	nop
                                                    custom symbol*/
                }
            }
        }
        /*Draw the scrollbar in the ancestor page design function*/
        ancestor_design(ddlist, mask, mode);
 8020baa:	4b06      	ldr	r3, [pc, #24]	; (8020bc4 <lv_ddlist_design+0x434>)
 8020bac:	681b      	ldr	r3, [r3, #0]
 8020bae:	79fa      	ldrb	r2, [r7, #7]
 8020bb0:	68b9      	ldr	r1, [r7, #8]
 8020bb2:	68f8      	ldr	r0, [r7, #12]
 8020bb4:	4798      	blx	r3
    }

    return true;
 8020bb6:	2301      	movs	r3, #1
}
 8020bb8:	4618      	mov	r0, r3
 8020bba:	37b8      	adds	r7, #184	; 0xb8
 8020bbc:	46bd      	mov	sp, r7
 8020bbe:	bdb0      	pop	{r4, r5, r7, pc}
 8020bc0:	08029044 	.word	0x08029044
 8020bc4:	2000c3d8 	.word	0x2000c3d8

08020bc8 <lv_ddlist_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_ddlist_signal(lv_obj_t * ddlist, lv_signal_t sign, void * param)
{
 8020bc8:	b580      	push	{r7, lr}
 8020bca:	b08c      	sub	sp, #48	; 0x30
 8020bcc:	af00      	add	r7, sp, #0
 8020bce:	60f8      	str	r0, [r7, #12]
 8020bd0:	460b      	mov	r3, r1
 8020bd2:	607a      	str	r2, [r7, #4]
 8020bd4:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;
    /* Include the ancient signal function */
    res = ancestor_signal(ddlist, sign, param);
 8020bd6:	4ba0      	ldr	r3, [pc, #640]	; (8020e58 <lv_ddlist_signal+0x290>)
 8020bd8:	681b      	ldr	r3, [r3, #0]
 8020bda:	7af9      	ldrb	r1, [r7, #11]
 8020bdc:	687a      	ldr	r2, [r7, #4]
 8020bde:	68f8      	ldr	r0, [r7, #12]
 8020be0:	4798      	blx	r3
 8020be2:	4603      	mov	r3, r0
 8020be4:	f887 302e 	strb.w	r3, [r7, #46]	; 0x2e
    if(res != LV_RES_OK) return res;
 8020be8:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8020bec:	2b01      	cmp	r3, #1
 8020bee:	d002      	beq.n	8020bf6 <lv_ddlist_signal+0x2e>
 8020bf0:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 8020bf4:	e12c      	b.n	8020e50 <lv_ddlist_signal+0x288>

    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 8020bf6:	68f8      	ldr	r0, [r7, #12]
 8020bf8:	f7f1 fc1b 	bl	8012432 <lv_obj_get_ext_attr>
 8020bfc:	62b8      	str	r0, [r7, #40]	; 0x28

    if(sign == LV_SIGNAL_STYLE_CHG) {
 8020bfe:	7afb      	ldrb	r3, [r7, #11]
 8020c00:	2b04      	cmp	r3, #4
 8020c02:	d104      	bne.n	8020c0e <lv_ddlist_signal+0x46>
        lv_ddlist_refr_size(ddlist, 0);
 8020c04:	2100      	movs	r1, #0
 8020c06:	68f8      	ldr	r0, [r7, #12]
 8020c08:	f000 fa62 	bl	80210d0 <lv_ddlist_refr_size>
 8020c0c:	e11e      	b.n	8020e4c <lv_ddlist_signal+0x284>
    } else if(sign == LV_SIGNAL_CLEANUP) {
 8020c0e:	7afb      	ldrb	r3, [r7, #11]
 8020c10:	2b00      	cmp	r3, #0
 8020c12:	d103      	bne.n	8020c1c <lv_ddlist_signal+0x54>
        ext->label = NULL;
 8020c14:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020c16:	2200      	movs	r2, #0
 8020c18:	631a      	str	r2, [r3, #48]	; 0x30
 8020c1a:	e117      	b.n	8020e4c <lv_ddlist_signal+0x284>
    } else if(sign == LV_SIGNAL_FOCUS) {
 8020c1c:	7afb      	ldrb	r3, [r7, #11]
 8020c1e:	2b0f      	cmp	r3, #15
 8020c20:	d14f      	bne.n	8020cc2 <lv_ddlist_signal+0xfa>
#if LV_USE_GROUP
        lv_group_t * g             = lv_obj_get_group(ddlist);
 8020c22:	68f8      	ldr	r0, [r7, #12]
 8020c24:	f7f1 fc11 	bl	801244a <lv_obj_get_group>
 8020c28:	61b8      	str	r0, [r7, #24]
        bool editing               = lv_group_get_editing(g);
 8020c2a:	69b8      	ldr	r0, [r7, #24]
 8020c2c:	f7ed fc2e 	bl	800e48c <lv_group_get_editing>
 8020c30:	4603      	mov	r3, r0
 8020c32:	75fb      	strb	r3, [r7, #23]
        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());
 8020c34:	f7ed ff90 	bl	800eb58 <lv_indev_get_act>
 8020c38:	4603      	mov	r3, r0
 8020c3a:	4618      	mov	r0, r3
 8020c3c:	f7ed ff98 	bl	800eb70 <lv_indev_get_type>
 8020c40:	4603      	mov	r3, r0
 8020c42:	75bb      	strb	r3, [r7, #22]

        /*Encoders need special handling*/
        if(indev_type == LV_INDEV_TYPE_ENCODER) {
 8020c44:	7dbb      	ldrb	r3, [r7, #22]
 8020c46:	2b04      	cmp	r3, #4
 8020c48:	d122      	bne.n	8020c90 <lv_ddlist_signal+0xc8>
            /*Open the list if editing*/
            if(editing) {
 8020c4a:	7dfb      	ldrb	r3, [r7, #23]
 8020c4c:	2b00      	cmp	r3, #0
 8020c4e:	d00f      	beq.n	8020c70 <lv_ddlist_signal+0xa8>
                ext->opened         = true;
 8020c50:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020c52:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020c56:	f043 0301 	orr.w	r3, r3, #1
 8020c5a:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
                ext->sel_opt_id_ori = ext->sel_opt_id;
 8020c5e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020c60:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8020c62:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020c64:	879a      	strh	r2, [r3, #60]	; 0x3c
                lv_ddlist_refr_size(ddlist, true);
 8020c66:	2101      	movs	r1, #1
 8020c68:	68f8      	ldr	r0, [r7, #12]
 8020c6a:	f000 fa31 	bl	80210d0 <lv_ddlist_refr_size>
 8020c6e:	e0ed      	b.n	8020e4c <lv_ddlist_signal+0x284>
            }
            /*Close the lift if navigating*/
            else {
                ext->opened     = false;
 8020c70:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020c72:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020c76:	f36f 0300 	bfc	r3, #0, #1
 8020c7a:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
                ext->sel_opt_id = ext->sel_opt_id_ori;
 8020c7e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020c80:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 8020c82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020c84:	875a      	strh	r2, [r3, #58]	; 0x3a
                lv_ddlist_refr_size(ddlist, true);
 8020c86:	2101      	movs	r1, #1
 8020c88:	68f8      	ldr	r0, [r7, #12]
 8020c8a:	f000 fa21 	bl	80210d0 <lv_ddlist_refr_size>
 8020c8e:	e0dd      	b.n	8020e4c <lv_ddlist_signal+0x284>
            }
        } else {
            /*Open the list if closed*/
            if(!ext->opened) {
 8020c90:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020c92:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020c96:	f003 0301 	and.w	r3, r3, #1
 8020c9a:	b2db      	uxtb	r3, r3
 8020c9c:	2b00      	cmp	r3, #0
 8020c9e:	f040 80d5 	bne.w	8020e4c <lv_ddlist_signal+0x284>
                ext->opened         = true;
 8020ca2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020ca4:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020ca8:	f043 0301 	orr.w	r3, r3, #1
 8020cac:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
                ext->sel_opt_id_ori = ext->sel_opt_id; /*Save the current value. Used to revert this
 8020cb0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020cb2:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8020cb4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020cb6:	879a      	strh	r2, [r3, #60]	; 0x3c
                                                          state if ENER wont't be pressed*/
                lv_ddlist_refr_size(ddlist, true);
 8020cb8:	2101      	movs	r1, #1
 8020cba:	68f8      	ldr	r0, [r7, #12]
 8020cbc:	f000 fa08 	bl	80210d0 <lv_ddlist_refr_size>
 8020cc0:	e0c4      	b.n	8020e4c <lv_ddlist_signal+0x284>
            }
        }
#endif
    } else if(sign == LV_SIGNAL_RELEASED) {
 8020cc2:	7afb      	ldrb	r3, [r7, #11]
 8020cc4:	2b0a      	cmp	r3, #10
 8020cc6:	d103      	bne.n	8020cd0 <lv_ddlist_signal+0x108>
        release_handler(ddlist);
 8020cc8:	68f8      	ldr	r0, [r7, #12]
 8020cca:	f000 f927 	bl	8020f1c <release_handler>
 8020cce:	e0bd      	b.n	8020e4c <lv_ddlist_signal+0x284>
    } else if(sign == LV_SIGNAL_DEFOCUS) {
 8020cd0:	7afb      	ldrb	r3, [r7, #11]
 8020cd2:	2b10      	cmp	r3, #16
 8020cd4:	d118      	bne.n	8020d08 <lv_ddlist_signal+0x140>
        if(ext->opened) {
 8020cd6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020cd8:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020cdc:	f003 0301 	and.w	r3, r3, #1
 8020ce0:	b2db      	uxtb	r3, r3
 8020ce2:	2b00      	cmp	r3, #0
 8020ce4:	f000 80b2 	beq.w	8020e4c <lv_ddlist_signal+0x284>
            ext->opened     = false;
 8020ce8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020cea:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020cee:	f36f 0300 	bfc	r3, #0, #1
 8020cf2:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
            ext->sel_opt_id = ext->sel_opt_id_ori;
 8020cf6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020cf8:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 8020cfa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020cfc:	875a      	strh	r2, [r3, #58]	; 0x3a
            lv_ddlist_refr_size(ddlist, true);
 8020cfe:	2101      	movs	r1, #1
 8020d00:	68f8      	ldr	r0, [r7, #12]
 8020d02:	f000 f9e5 	bl	80210d0 <lv_ddlist_refr_size>
 8020d06:	e0a1      	b.n	8020e4c <lv_ddlist_signal+0x284>
        }
    } else if(sign == LV_SIGNAL_CONTROL) {
 8020d08:	7afb      	ldrb	r3, [r7, #11]
 8020d0a:	2b11      	cmp	r3, #17
 8020d0c:	d174      	bne.n	8020df8 <lv_ddlist_signal+0x230>
        char c = *((char *)param);
 8020d0e:	687b      	ldr	r3, [r7, #4]
 8020d10:	781b      	ldrb	r3, [r3, #0]
 8020d12:	77fb      	strb	r3, [r7, #31]
        if(c == LV_KEY_RIGHT || c == LV_KEY_DOWN) {
 8020d14:	7ffb      	ldrb	r3, [r7, #31]
 8020d16:	2b13      	cmp	r3, #19
 8020d18:	d002      	beq.n	8020d20 <lv_ddlist_signal+0x158>
 8020d1a:	7ffb      	ldrb	r3, [r7, #31]
 8020d1c:	2b12      	cmp	r3, #18
 8020d1e:	d126      	bne.n	8020d6e <lv_ddlist_signal+0x1a6>
            if(!ext->opened) {
 8020d20:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020d22:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020d26:	f003 0301 	and.w	r3, r3, #1
 8020d2a:	b2db      	uxtb	r3, r3
 8020d2c:	2b00      	cmp	r3, #0
 8020d2e:	d10a      	bne.n	8020d46 <lv_ddlist_signal+0x17e>
                ext->opened = 1;
 8020d30:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020d32:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020d36:	f043 0301 	orr.w	r3, r3, #1
 8020d3a:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
                lv_ddlist_refr_size(ddlist, true);
 8020d3e:	2101      	movs	r1, #1
 8020d40:	68f8      	ldr	r0, [r7, #12]
 8020d42:	f000 f9c5 	bl	80210d0 <lv_ddlist_refr_size>
            }

            if(ext->sel_opt_id + 1 < ext->option_cnt) {
 8020d46:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020d48:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8020d4a:	3301      	adds	r3, #1
 8020d4c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020d4e:	8f12      	ldrh	r2, [r2, #56]	; 0x38
 8020d50:	4293      	cmp	r3, r2
 8020d52:	da7b      	bge.n	8020e4c <lv_ddlist_signal+0x284>
                ext->sel_opt_id++;
 8020d54:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020d56:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8020d58:	3301      	adds	r3, #1
 8020d5a:	b29a      	uxth	r2, r3
 8020d5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020d5e:	875a      	strh	r2, [r3, #58]	; 0x3a
                lv_ddlist_pos_current_option(ddlist);
 8020d60:	68f8      	ldr	r0, [r7, #12]
 8020d62:	f000 fab4 	bl	80212ce <lv_ddlist_pos_current_option>
                lv_obj_invalidate(ddlist);
 8020d66:	68f8      	ldr	r0, [r7, #12]
 8020d68:	f7f0 f861 	bl	8010e2e <lv_obj_invalidate>
            if(ext->sel_opt_id + 1 < ext->option_cnt) {
 8020d6c:	e06e      	b.n	8020e4c <lv_ddlist_signal+0x284>
            }
        } else if(c == LV_KEY_LEFT || c == LV_KEY_UP) {
 8020d6e:	7ffb      	ldrb	r3, [r7, #31]
 8020d70:	2b14      	cmp	r3, #20
 8020d72:	d002      	beq.n	8020d7a <lv_ddlist_signal+0x1b2>
 8020d74:	7ffb      	ldrb	r3, [r7, #31]
 8020d76:	2b11      	cmp	r3, #17
 8020d78:	d123      	bne.n	8020dc2 <lv_ddlist_signal+0x1fa>
            if(!ext->opened) {
 8020d7a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020d7c:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020d80:	f003 0301 	and.w	r3, r3, #1
 8020d84:	b2db      	uxtb	r3, r3
 8020d86:	2b00      	cmp	r3, #0
 8020d88:	d10a      	bne.n	8020da0 <lv_ddlist_signal+0x1d8>
                ext->opened = 1;
 8020d8a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020d8c:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020d90:	f043 0301 	orr.w	r3, r3, #1
 8020d94:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
                lv_ddlist_refr_size(ddlist, true);
 8020d98:	2101      	movs	r1, #1
 8020d9a:	68f8      	ldr	r0, [r7, #12]
 8020d9c:	f000 f998 	bl	80210d0 <lv_ddlist_refr_size>
            }
            if(ext->sel_opt_id > 0) {
 8020da0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020da2:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8020da4:	2b00      	cmp	r3, #0
 8020da6:	d051      	beq.n	8020e4c <lv_ddlist_signal+0x284>
                ext->sel_opt_id--;
 8020da8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020daa:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8020dac:	3b01      	subs	r3, #1
 8020dae:	b29a      	uxth	r2, r3
 8020db0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020db2:	875a      	strh	r2, [r3, #58]	; 0x3a
                lv_ddlist_pos_current_option(ddlist);
 8020db4:	68f8      	ldr	r0, [r7, #12]
 8020db6:	f000 fa8a 	bl	80212ce <lv_ddlist_pos_current_option>
                lv_obj_invalidate(ddlist);
 8020dba:	68f8      	ldr	r0, [r7, #12]
 8020dbc:	f7f0 f837 	bl	8010e2e <lv_obj_invalidate>
            if(ext->sel_opt_id > 0) {
 8020dc0:	e044      	b.n	8020e4c <lv_ddlist_signal+0x284>
            }
        } else if(c == LV_KEY_ESC) {
 8020dc2:	7ffb      	ldrb	r3, [r7, #31]
 8020dc4:	2b1b      	cmp	r3, #27
 8020dc6:	d141      	bne.n	8020e4c <lv_ddlist_signal+0x284>
            if(ext->opened) {
 8020dc8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020dca:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020dce:	f003 0301 	and.w	r3, r3, #1
 8020dd2:	b2db      	uxtb	r3, r3
 8020dd4:	2b00      	cmp	r3, #0
 8020dd6:	d039      	beq.n	8020e4c <lv_ddlist_signal+0x284>
                ext->opened     = 0;
 8020dd8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8020dda:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020dde:	f36f 0300 	bfc	r3, #0, #1
 8020de2:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
                ext->sel_opt_id = ext->sel_opt_id_ori;
 8020de6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020de8:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 8020dea:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8020dec:	875a      	strh	r2, [r3, #58]	; 0x3a
                lv_ddlist_refr_size(ddlist, true);
 8020dee:	2101      	movs	r1, #1
 8020df0:	68f8      	ldr	r0, [r7, #12]
 8020df2:	f000 f96d 	bl	80210d0 <lv_ddlist_refr_size>
 8020df6:	e029      	b.n	8020e4c <lv_ddlist_signal+0x284>
            }
        }
    } else if(sign == LV_SIGNAL_GET_EDITABLE) {
 8020df8:	7afb      	ldrb	r3, [r7, #11]
 8020dfa:	2b12      	cmp	r3, #18
 8020dfc:	d105      	bne.n	8020e0a <lv_ddlist_signal+0x242>
        bool * editable = (bool *)param;
 8020dfe:	687b      	ldr	r3, [r7, #4]
 8020e00:	623b      	str	r3, [r7, #32]
        *editable       = true;
 8020e02:	6a3b      	ldr	r3, [r7, #32]
 8020e04:	2201      	movs	r2, #1
 8020e06:	701a      	strb	r2, [r3, #0]
 8020e08:	e020      	b.n	8020e4c <lv_ddlist_signal+0x284>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 8020e0a:	7afb      	ldrb	r3, [r7, #11]
 8020e0c:	2b06      	cmp	r3, #6
 8020e0e:	d11d      	bne.n	8020e4c <lv_ddlist_signal+0x284>
        lv_obj_type_t * buf = param;
 8020e10:	687b      	ldr	r3, [r7, #4]
 8020e12:	627b      	str	r3, [r7, #36]	; 0x24
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8020e14:	2300      	movs	r3, #0
 8020e16:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8020e1a:	e00b      	b.n	8020e34 <lv_ddlist_signal+0x26c>
            if(buf->type[i] == NULL) break;
 8020e1c:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 8020e20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020e22:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8020e26:	2b00      	cmp	r3, #0
 8020e28:	d009      	beq.n	8020e3e <lv_ddlist_signal+0x276>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8020e2a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8020e2e:	3301      	adds	r3, #1
 8020e30:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
 8020e34:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8020e38:	2b06      	cmp	r3, #6
 8020e3a:	d9ef      	bls.n	8020e1c <lv_ddlist_signal+0x254>
 8020e3c:	e000      	b.n	8020e40 <lv_ddlist_signal+0x278>
            if(buf->type[i] == NULL) break;
 8020e3e:	bf00      	nop
        }
        buf->type[i] = "lv_ddlist";
 8020e40:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 8020e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8020e46:	4905      	ldr	r1, [pc, #20]	; (8020e5c <lv_ddlist_signal+0x294>)
 8020e48:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 8020e4c:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
}
 8020e50:	4618      	mov	r0, r3
 8020e52:	3730      	adds	r7, #48	; 0x30
 8020e54:	46bd      	mov	sp, r7
 8020e56:	bd80      	pop	{r7, pc}
 8020e58:	2000c3d0 	.word	0x2000c3d0
 8020e5c:	08029048 	.word	0x08029048

08020e60 <lv_ddlist_scrl_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_ddlist_scrl_signal(lv_obj_t * scrl, lv_signal_t sign, void * param)
{
 8020e60:	b580      	push	{r7, lr}
 8020e62:	b08a      	sub	sp, #40	; 0x28
 8020e64:	af00      	add	r7, sp, #0
 8020e66:	60f8      	str	r0, [r7, #12]
 8020e68:	460b      	mov	r3, r1
 8020e6a:	607a      	str	r2, [r7, #4]
 8020e6c:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_scrl_signal(scrl, sign, param);
 8020e6e:	4b2a      	ldr	r3, [pc, #168]	; (8020f18 <lv_ddlist_scrl_signal+0xb8>)
 8020e70:	681b      	ldr	r3, [r3, #0]
 8020e72:	7af9      	ldrb	r1, [r7, #11]
 8020e74:	687a      	ldr	r2, [r7, #4]
 8020e76:	68f8      	ldr	r0, [r7, #12]
 8020e78:	4798      	blx	r3
 8020e7a:	4603      	mov	r3, r0
 8020e7c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
    if(res != LV_RES_OK) return res;
 8020e80:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8020e84:	2b01      	cmp	r3, #1
 8020e86:	d002      	beq.n	8020e8e <lv_ddlist_scrl_signal+0x2e>
 8020e88:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8020e8c:	e03f      	b.n	8020f0e <lv_ddlist_scrl_signal+0xae>

    lv_obj_t * ddlist = lv_obj_get_parent(scrl);
 8020e8e:	68f8      	ldr	r0, [r7, #12]
 8020e90:	f7f1 f916 	bl	80120c0 <lv_obj_get_parent>
 8020e94:	6238      	str	r0, [r7, #32]

    if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 8020e96:	7afb      	ldrb	r3, [r7, #11]
 8020e98:	2b05      	cmp	r3, #5
 8020e9a:	d119      	bne.n	8020ed0 <lv_ddlist_scrl_signal+0x70>
        /*TODO review this*/
        /* Because of the wider selected rectangle ext. size
         * In this way by dragging the scrollable part the wider rectangle area can be redrawn too*/
        const lv_style_t * style = lv_ddlist_get_style(ddlist, LV_DDLIST_STYLE_BG);
 8020e9c:	2100      	movs	r1, #0
 8020e9e:	6a38      	ldr	r0, [r7, #32]
 8020ea0:	f7ff fc2e 	bl	8020700 <lv_ddlist_get_style>
 8020ea4:	61b8      	str	r0, [r7, #24]
        lv_coord_t hpad          = LV_MATH_MAX(style->body.padding.left, style->body.padding.right);
 8020ea6:	69bb      	ldr	r3, [r7, #24]
 8020ea8:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 8020eac:	69bb      	ldr	r3, [r7, #24]
 8020eae:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8020eb2:	4293      	cmp	r3, r2
 8020eb4:	bfb8      	it	lt
 8020eb6:	4613      	movlt	r3, r2
 8020eb8:	82fb      	strh	r3, [r7, #22]
        if(scrl->ext_draw_pad < hpad) scrl->ext_draw_pad = hpad;
 8020eba:	68fb      	ldr	r3, [r7, #12]
 8020ebc:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8020ec0:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8020ec4:	429a      	cmp	r2, r3
 8020ec6:	dd20      	ble.n	8020f0a <lv_ddlist_scrl_signal+0xaa>
 8020ec8:	68fb      	ldr	r3, [r7, #12]
 8020eca:	8afa      	ldrh	r2, [r7, #22]
 8020ecc:	869a      	strh	r2, [r3, #52]	; 0x34
 8020ece:	e01c      	b.n	8020f0a <lv_ddlist_scrl_signal+0xaa>
    } else if(sign == LV_SIGNAL_RELEASED) {
 8020ed0:	7afb      	ldrb	r3, [r7, #11]
 8020ed2:	2b0a      	cmp	r3, #10
 8020ed4:	d10f      	bne.n	8020ef6 <lv_ddlist_scrl_signal+0x96>
        if(lv_indev_is_dragging(lv_indev_get_act()) == false) {
 8020ed6:	f7ed fe3f 	bl	800eb58 <lv_indev_get_act>
 8020eda:	4603      	mov	r3, r0
 8020edc:	4618      	mov	r0, r3
 8020ede:	f7ed fea4 	bl	800ec2a <lv_indev_is_dragging>
 8020ee2:	4603      	mov	r3, r0
 8020ee4:	f083 0301 	eor.w	r3, r3, #1
 8020ee8:	b2db      	uxtb	r3, r3
 8020eea:	2b00      	cmp	r3, #0
 8020eec:	d00d      	beq.n	8020f0a <lv_ddlist_scrl_signal+0xaa>
            release_handler(ddlist);
 8020eee:	6a38      	ldr	r0, [r7, #32]
 8020ef0:	f000 f814 	bl	8020f1c <release_handler>
 8020ef4:	e009      	b.n	8020f0a <lv_ddlist_scrl_signal+0xaa>
        }
    } else if(sign == LV_SIGNAL_CLEANUP) {
 8020ef6:	7afb      	ldrb	r3, [r7, #11]
 8020ef8:	2b00      	cmp	r3, #0
 8020efa:	d106      	bne.n	8020f0a <lv_ddlist_scrl_signal+0xaa>
        lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 8020efc:	6a38      	ldr	r0, [r7, #32]
 8020efe:	f7f1 fa98 	bl	8012432 <lv_obj_get_ext_attr>
 8020f02:	61f8      	str	r0, [r7, #28]
        ext->label            = NULL; /*The label is already deleted*/
 8020f04:	69fb      	ldr	r3, [r7, #28]
 8020f06:	2200      	movs	r2, #0
 8020f08:	631a      	str	r2, [r3, #48]	; 0x30
    }

    return res;
 8020f0a:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
}
 8020f0e:	4618      	mov	r0, r3
 8020f10:	3728      	adds	r7, #40	; 0x28
 8020f12:	46bd      	mov	sp, r7
 8020f14:	bd80      	pop	{r7, pc}
 8020f16:	bf00      	nop
 8020f18:	2000c3d4 	.word	0x2000c3d4

08020f1c <release_handler>:
 * Called when a drop down list is released to open it or set new option
 * @param ddlist pointer to a drop down list object
 * @return LV_ACTION_RES_INV if the ddlist it deleted in the user callback else LV_ACTION_RES_OK
 */
static lv_res_t release_handler(lv_obj_t * ddlist)
{
 8020f1c:	b580      	push	{r7, lr}
 8020f1e:	b08e      	sub	sp, #56	; 0x38
 8020f20:	af00      	add	r7, sp, #0
 8020f22:	6078      	str	r0, [r7, #4]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 8020f24:	6878      	ldr	r0, [r7, #4]
 8020f26:	f7f1 fa84 	bl	8012432 <lv_obj_get_ext_attr>
 8020f2a:	62f8      	str	r0, [r7, #44]	; 0x2c

    if(ext->opened == 0) { /*Open the list*/
 8020f2c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020f2e:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8020f32:	f003 0301 	and.w	r3, r3, #1
 8020f36:	b2db      	uxtb	r3, r3
 8020f38:	2b00      	cmp	r3, #0
 8020f3a:	d113      	bne.n	8020f64 <release_handler+0x48>
        ext->opened = 1;
 8020f3c:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8020f3e:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8020f42:	f043 0301 	orr.w	r3, r3, #1
 8020f46:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
        lv_obj_set_drag(lv_page_get_scrl(ddlist), true);
 8020f4a:	6878      	ldr	r0, [r7, #4]
 8020f4c:	f001 ffe2 	bl	8022f14 <lv_page_get_scrl>
 8020f50:	4603      	mov	r3, r0
 8020f52:	2101      	movs	r1, #1
 8020f54:	4618      	mov	r0, r3
 8020f56:	f7f0 ff1a 	bl	8011d8e <lv_obj_set_drag>
        lv_ddlist_refr_size(ddlist, true);
 8020f5a:	2101      	movs	r1, #1
 8020f5c:	6878      	ldr	r0, [r7, #4]
 8020f5e:	f000 f8b7 	bl	80210d0 <lv_ddlist_refr_size>
 8020f62:	e0ad      	b.n	80210c0 <release_handler+0x1a4>
    } else {

        lv_indev_t * indev = lv_indev_get_act();
 8020f64:	f7ed fdf8 	bl	800eb58 <lv_indev_get_act>
 8020f68:	62b8      	str	r0, [r7, #40]	; 0x28
#if LV_USE_GROUP
        /*Leave edit mode once a new item is selected*/
        if(lv_indev_get_type(indev) == LV_INDEV_TYPE_ENCODER) {
 8020f6a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020f6c:	f7ed fe00 	bl	800eb70 <lv_indev_get_type>
 8020f70:	4603      	mov	r3, r0
 8020f72:	2b04      	cmp	r3, #4
 8020f74:	d111      	bne.n	8020f9a <release_handler+0x7e>
            ext->sel_opt_id_ori = ext->sel_opt_id;
 8020f76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020f78:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8020f7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020f7c:	879a      	strh	r2, [r3, #60]	; 0x3c
            lv_group_t * g      = lv_obj_get_group(ddlist);
 8020f7e:	6878      	ldr	r0, [r7, #4]
 8020f80:	f7f1 fa63 	bl	801244a <lv_obj_get_group>
 8020f84:	6278      	str	r0, [r7, #36]	; 0x24
            if(lv_group_get_editing(g)) {
 8020f86:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8020f88:	f7ed fa80 	bl	800e48c <lv_group_get_editing>
 8020f8c:	4603      	mov	r3, r0
 8020f8e:	2b00      	cmp	r3, #0
 8020f90:	d003      	beq.n	8020f9a <release_handler+0x7e>
                lv_group_set_editing(g, false);
 8020f92:	2100      	movs	r1, #0
 8020f94:	6a78      	ldr	r0, [r7, #36]	; 0x24
 8020f96:	f7ed f9f0 	bl	800e37a <lv_group_set_editing>
            }
        }
#endif

        /*Search the clicked option (For KEYPAD and ENCODER the new value should be already set)*/
        if(lv_indev_get_type(indev) == LV_INDEV_TYPE_POINTER || lv_indev_get_type(indev) == LV_INDEV_TYPE_BUTTON) {
 8020f9a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020f9c:	f7ed fde8 	bl	800eb70 <lv_indev_get_type>
 8020fa0:	4603      	mov	r3, r0
 8020fa2:	2b01      	cmp	r3, #1
 8020fa4:	d005      	beq.n	8020fb2 <release_handler+0x96>
 8020fa6:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020fa8:	f7ed fde2 	bl	800eb70 <lv_indev_get_type>
 8020fac:	4603      	mov	r3, r0
 8020fae:	2b03      	cmp	r3, #3
 8020fb0:	d156      	bne.n	8021060 <release_handler+0x144>
            lv_point_t p;
            lv_indev_get_point(indev, &p);
 8020fb2:	f107 030c 	add.w	r3, r7, #12
 8020fb6:	4619      	mov	r1, r3
 8020fb8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8020fba:	f7ed fe10 	bl	800ebde <lv_indev_get_point>
            p.y -= ext->label->coords.y1;
 8020fbe:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8020fc2:	b29a      	uxth	r2, r3
 8020fc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020fc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020fc8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8020fcc:	b29b      	uxth	r3, r3
 8020fce:	1ad3      	subs	r3, r2, r3
 8020fd0:	b29b      	uxth	r3, r3
 8020fd2:	b21b      	sxth	r3, r3
 8020fd4:	81fb      	strh	r3, [r7, #14]
            p.x -= ext->label->coords.x1;
 8020fd6:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8020fda:	b29a      	uxth	r2, r3
 8020fdc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020fde:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020fe0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8020fe4:	b29b      	uxth	r3, r3
 8020fe6:	1ad3      	subs	r3, r2, r3
 8020fe8:	b29b      	uxth	r3, r3
 8020fea:	b21b      	sxth	r3, r3
 8020fec:	81bb      	strh	r3, [r7, #12]
            uint16_t letter_i;
            letter_i = lv_label_get_letter_on(ext->label, &p);
 8020fee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8020ff0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8020ff2:	f107 020c 	add.w	r2, r7, #12
 8020ff6:	4611      	mov	r1, r2
 8020ff8:	4618      	mov	r0, r3
 8020ffa:	f000 fd53 	bl	8021aa4 <lv_label_get_letter_on>
 8020ffe:	4603      	mov	r3, r0
 8021000:	847b      	strh	r3, [r7, #34]	; 0x22

            uint16_t new_opt  = 0;
 8021002:	2300      	movs	r3, #0
 8021004:	86fb      	strh	r3, [r7, #54]	; 0x36
            const char * txt  = lv_label_get_text(ext->label);
 8021006:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021008:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802100a:	4618      	mov	r0, r3
 802100c:	f000 fced 	bl	80219ea <lv_label_get_text>
 8021010:	61f8      	str	r0, [r7, #28]
            uint32_t i        = 0;
 8021012:	2300      	movs	r3, #0
 8021014:	60bb      	str	r3, [r7, #8]
            uint32_t line_cnt = 0;
 8021016:	2300      	movs	r3, #0
 8021018:	633b      	str	r3, [r7, #48]	; 0x30
            uint32_t letter;
            for(line_cnt = 0; line_cnt < letter_i; line_cnt++) {
 802101a:	2300      	movs	r3, #0
 802101c:	633b      	str	r3, [r7, #48]	; 0x30
 802101e:	e014      	b.n	802104a <release_handler+0x12e>
                letter = lv_txt_encoded_next(txt, &i);
 8021020:	4b2a      	ldr	r3, [pc, #168]	; (80210cc <release_handler+0x1b0>)
 8021022:	681b      	ldr	r3, [r3, #0]
 8021024:	f107 0208 	add.w	r2, r7, #8
 8021028:	4611      	mov	r1, r2
 802102a:	69f8      	ldr	r0, [r7, #28]
 802102c:	4798      	blx	r3
 802102e:	61b8      	str	r0, [r7, #24]
                /*Count he lines to reach the clicked letter. But ignore the last '\n' because it
                 * still belongs to the clicked line*/
                if(letter == '\n' && i != letter_i) new_opt++;
 8021030:	69bb      	ldr	r3, [r7, #24]
 8021032:	2b0a      	cmp	r3, #10
 8021034:	d106      	bne.n	8021044 <release_handler+0x128>
 8021036:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8021038:	68bb      	ldr	r3, [r7, #8]
 802103a:	429a      	cmp	r2, r3
 802103c:	d002      	beq.n	8021044 <release_handler+0x128>
 802103e:	8efb      	ldrh	r3, [r7, #54]	; 0x36
 8021040:	3301      	adds	r3, #1
 8021042:	86fb      	strh	r3, [r7, #54]	; 0x36
            for(line_cnt = 0; line_cnt < letter_i; line_cnt++) {
 8021044:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021046:	3301      	adds	r3, #1
 8021048:	633b      	str	r3, [r7, #48]	; 0x30
 802104a:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 802104c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 802104e:	429a      	cmp	r2, r3
 8021050:	d3e6      	bcc.n	8021020 <release_handler+0x104>
            }

            ext->sel_opt_id     = new_opt;
 8021052:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021054:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 8021056:	875a      	strh	r2, [r3, #58]	; 0x3a
            ext->sel_opt_id_ori = ext->sel_opt_id;
 8021058:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802105a:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 802105c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802105e:	879a      	strh	r2, [r3, #60]	; 0x3c
        }

        uint32_t id  = ext->sel_opt_id; /*Just to use uint32_t in event data*/
 8021060:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021062:	8f5b      	ldrh	r3, [r3, #58]	; 0x3a
 8021064:	613b      	str	r3, [r7, #16]
        lv_res_t res = lv_event_send(ddlist, LV_EVENT_VALUE_CHANGED, &id);
 8021066:	f107 0310 	add.w	r3, r7, #16
 802106a:	461a      	mov	r2, r3
 802106c:	210e      	movs	r1, #14
 802106e:	6878      	ldr	r0, [r7, #4]
 8021070:	f7f0 fef5 	bl	8011e5e <lv_event_send>
 8021074:	4603      	mov	r3, r0
 8021076:	75fb      	strb	r3, [r7, #23]
        if(res != LV_RES_OK) return res;
 8021078:	7dfb      	ldrb	r3, [r7, #23]
 802107a:	2b01      	cmp	r3, #1
 802107c:	d001      	beq.n	8021082 <release_handler+0x166>
 802107e:	7dfb      	ldrb	r3, [r7, #23]
 8021080:	e01f      	b.n	80210c2 <release_handler+0x1a6>

        if(ext->stay_open == 0) {
 8021082:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021084:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 8021088:	f003 0308 	and.w	r3, r3, #8
 802108c:	b2db      	uxtb	r3, r3
 802108e:	2b00      	cmp	r3, #0
 8021090:	d113      	bne.n	80210ba <release_handler+0x19e>
            ext->opened = 0;
 8021092:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8021094:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8021098:	f36f 0300 	bfc	r3, #0, #1
 802109c:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
            lv_obj_set_drag(lv_page_get_scrl(ddlist), false);
 80210a0:	6878      	ldr	r0, [r7, #4]
 80210a2:	f001 ff37 	bl	8022f14 <lv_page_get_scrl>
 80210a6:	4603      	mov	r3, r0
 80210a8:	2100      	movs	r1, #0
 80210aa:	4618      	mov	r0, r3
 80210ac:	f7f0 fe6f 	bl	8011d8e <lv_obj_set_drag>
            lv_ddlist_refr_size(ddlist, true);
 80210b0:	2101      	movs	r1, #1
 80210b2:	6878      	ldr	r0, [r7, #4]
 80210b4:	f000 f80c 	bl	80210d0 <lv_ddlist_refr_size>
 80210b8:	e002      	b.n	80210c0 <release_handler+0x1a4>
        } else {
            lv_obj_invalidate(ddlist);
 80210ba:	6878      	ldr	r0, [r7, #4]
 80210bc:	f7ef feb7 	bl	8010e2e <lv_obj_invalidate>
        }
    }

    return LV_RES_OK;
 80210c0:	2301      	movs	r3, #1
}
 80210c2:	4618      	mov	r0, r3
 80210c4:	3738      	adds	r7, #56	; 0x38
 80210c6:	46bd      	mov	sp, r7
 80210c8:	bd80      	pop	{r7, pc}
 80210ca:	bf00      	nop
 80210cc:	20000c34 	.word	0x20000c34

080210d0 <lv_ddlist_refr_size>:
 * Refresh the size of drop down list according to its status (open or closed)
 * @param ddlist pointer to a drop down list object
 * @param anim Change the size (open/close) with or without animation (true/false)
 */
static void lv_ddlist_refr_size(lv_obj_t * ddlist, lv_anim_enable_t anim)
{
 80210d0:	b580      	push	{r7, lr}
 80210d2:	b092      	sub	sp, #72	; 0x48
 80210d4:	af00      	add	r7, sp, #0
 80210d6:	6078      	str	r0, [r7, #4]
 80210d8:	460b      	mov	r3, r1
 80210da:	70fb      	strb	r3, [r7, #3]
#if LV_USE_ANIMATION == 0
    anim = false;
#endif
    lv_ddlist_ext_t * ext    = lv_obj_get_ext_attr(ddlist);
 80210dc:	6878      	ldr	r0, [r7, #4]
 80210de:	f7f1 f9a8 	bl	8012432 <lv_obj_get_ext_attr>
 80210e2:	6438      	str	r0, [r7, #64]	; 0x40
    const lv_style_t * style = lv_obj_get_style(ddlist);
 80210e4:	6878      	ldr	r0, [r7, #4]
 80210e6:	f7f1 f885 	bl	80121f4 <lv_obj_get_style>
 80210ea:	63f8      	str	r0, [r7, #60]	; 0x3c
    lv_coord_t new_height;

    /*Open the list*/
    if(ext->opened) {
 80210ec:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80210ee:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 80210f2:	f003 0301 	and.w	r3, r3, #1
 80210f6:	b2db      	uxtb	r3, r3
 80210f8:	2b00      	cmp	r3, #0
 80210fa:	d022      	beq.n	8021142 <lv_ddlist_refr_size+0x72>
        if(ext->fix_height == 0) {
 80210fc:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 80210fe:	f9b3 3040 	ldrsh.w	r3, [r3, #64]	; 0x40
 8021102:	2b00      	cmp	r3, #0
 8021104:	d117      	bne.n	8021136 <lv_ddlist_refr_size+0x66>
            new_height =
                lv_obj_get_height(lv_page_get_scrl(ddlist)) + style->body.padding.top + style->body.padding.bottom;
 8021106:	6878      	ldr	r0, [r7, #4]
 8021108:	f001 ff04 	bl	8022f14 <lv_page_get_scrl>
 802110c:	4603      	mov	r3, r0
 802110e:	4618      	mov	r0, r3
 8021110:	f7f1 f84e 	bl	80121b0 <lv_obj_get_height>
 8021114:	4603      	mov	r3, r0
 8021116:	b29a      	uxth	r2, r3
 8021118:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802111a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 802111e:	b29b      	uxth	r3, r3
 8021120:	4413      	add	r3, r2
 8021122:	b29a      	uxth	r2, r3
 8021124:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021126:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802112a:	b29b      	uxth	r3, r3
 802112c:	4413      	add	r3, r2
 802112e:	b29b      	uxth	r3, r3
            new_height =
 8021130:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 8021134:	e022      	b.n	802117c <lv_ddlist_refr_size+0xac>
        } else {
            new_height = ext->fix_height;
 8021136:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8021138:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 802113c:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46
 8021140:	e01c      	b.n	802117c <lv_ddlist_refr_size+0xac>
        }

    }
    /*Close the list*/
    else {
        const lv_font_t * font         = style->text.font;
 8021142:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021144:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021146:	63bb      	str	r3, [r7, #56]	; 0x38
        const lv_style_t * label_style = lv_obj_get_style(ext->label);
 8021148:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 802114a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 802114c:	4618      	mov	r0, r3
 802114e:	f7f1 f851 	bl	80121f4 <lv_obj_get_style>
 8021152:	6378      	str	r0, [r7, #52]	; 0x34
        lv_coord_t font_h              = lv_font_get_line_height(font);
 8021154:	6bb8      	ldr	r0, [r7, #56]	; 0x38
 8021156:	f7ff f819 	bl	802018c <lv_font_get_line_height>
 802115a:	4603      	mov	r3, r0
 802115c:	867b      	strh	r3, [r7, #50]	; 0x32
        new_height                     = font_h + 2 * label_style->text.line_space;
 802115e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8021160:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8021164:	b29b      	uxth	r3, r3
 8021166:	005b      	lsls	r3, r3, #1
 8021168:	b29a      	uxth	r2, r3
 802116a:	8e7b      	ldrh	r3, [r7, #50]	; 0x32
 802116c:	4413      	add	r3, r2
 802116e:	b29b      	uxth	r3, r3
 8021170:	f8a7 3046 	strh.w	r3, [r7, #70]	; 0x46

        lv_page_set_sb_mode(ddlist, LV_SB_MODE_HIDE);
 8021174:	2104      	movs	r1, #4
 8021176:	6878      	ldr	r0, [r7, #4]
 8021178:	f001 fe08 	bl	8022d8c <lv_page_set_sb_mode>
    }

    if(anim == LV_ANIM_OFF) {
 802117c:	78fb      	ldrb	r3, [r7, #3]
 802117e:	2b00      	cmp	r3, #0
 8021180:	d11c      	bne.n	80211bc <lv_ddlist_refr_size+0xec>
        lv_obj_set_height(ddlist, new_height);
 8021182:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 8021186:	4619      	mov	r1, r3
 8021188:	6878      	ldr	r0, [r7, #4]
 802118a:	f7f0 f8a4 	bl	80112d6 <lv_obj_set_height>
        lv_ddlist_pos_current_option(ddlist);
 802118e:	6878      	ldr	r0, [r7, #4]
 8021190:	f000 f89d 	bl	80212ce <lv_ddlist_pos_current_option>
        if(ext->opened) lv_page_set_sb_mode(ddlist, LV_SB_MODE_UNHIDE);
 8021194:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8021196:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 802119a:	f003 0301 	and.w	r3, r3, #1
 802119e:	b2db      	uxtb	r3, r3
 80211a0:	2b00      	cmp	r3, #0
 80211a2:	d003      	beq.n	80211ac <lv_ddlist_refr_size+0xdc>
 80211a4:	2105      	movs	r1, #5
 80211a6:	6878      	ldr	r0, [r7, #4]
 80211a8:	f001 fdf0 	bl	8022d8c <lv_page_set_sb_mode>
#if LV_USE_ANIMATION
        lv_anim_del(ddlist, (lv_anim_exec_xcb_t)lv_ddlist_adjust_height); /*If an animation is in progress then
 80211ac:	4923      	ldr	r1, [pc, #140]	; (802123c <lv_ddlist_refr_size+0x16c>)
 80211ae:	6878      	ldr	r0, [r7, #4]
 80211b0:	f7fa fa16 	bl	801b5e0 <lv_anim_del>
                                                                 it will overwrite this changes*/

        /*Force animation complete to fix highlight selection*/
        lv_ddlist_anim_finish(ddlist);
 80211b4:	6878      	ldr	r0, [r7, #4]
 80211b6:	f000 f855 	bl	8021264 <lv_ddlist_anim_finish>
            ext->force_sel = 1; /*Keep the list item selected*/
            lv_anim_create(&a);
        }
#endif
    }
}
 80211ba:	e03b      	b.n	8021234 <lv_ddlist_refr_size+0x164>
        if(lv_obj_get_height(ddlist) != new_height) {
 80211bc:	6878      	ldr	r0, [r7, #4]
 80211be:	f7f0 fff7 	bl	80121b0 <lv_obj_get_height>
 80211c2:	4603      	mov	r3, r0
 80211c4:	461a      	mov	r2, r3
 80211c6:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80211ca:	4293      	cmp	r3, r2
 80211cc:	d032      	beq.n	8021234 <lv_ddlist_refr_size+0x164>
            a.var            = ddlist;
 80211ce:	687b      	ldr	r3, [r7, #4]
 80211d0:	60bb      	str	r3, [r7, #8]
            a.start          = lv_obj_get_height(ddlist);
 80211d2:	6878      	ldr	r0, [r7, #4]
 80211d4:	f7f0 ffec 	bl	80121b0 <lv_obj_get_height>
 80211d8:	4603      	mov	r3, r0
 80211da:	61bb      	str	r3, [r7, #24]
            a.end            = new_height;
 80211dc:	f9b7 3046 	ldrsh.w	r3, [r7, #70]	; 0x46
 80211e0:	61fb      	str	r3, [r7, #28]
            a.exec_cb        = (lv_anim_exec_xcb_t)lv_ddlist_adjust_height;
 80211e2:	4b16      	ldr	r3, [pc, #88]	; (802123c <lv_ddlist_refr_size+0x16c>)
 80211e4:	60fb      	str	r3, [r7, #12]
            a.path_cb        = lv_anim_path_linear;
 80211e6:	4b16      	ldr	r3, [pc, #88]	; (8021240 <lv_ddlist_refr_size+0x170>)
 80211e8:	613b      	str	r3, [r7, #16]
            a.ready_cb       = lv_ddlist_anim_ready_cb;
 80211ea:	4b16      	ldr	r3, [pc, #88]	; (8021244 <lv_ddlist_refr_size+0x174>)
 80211ec:	617b      	str	r3, [r7, #20]
            a.act_time       = 0;
 80211ee:	2300      	movs	r3, #0
 80211f0:	847b      	strh	r3, [r7, #34]	; 0x22
            a.time           = lv_ddlist_get_anim_time(ddlist);
 80211f2:	6878      	ldr	r0, [r7, #4]
 80211f4:	f7ff f80f 	bl	8020216 <lv_ddlist_get_anim_time>
 80211f8:	4603      	mov	r3, r0
 80211fa:	843b      	strh	r3, [r7, #32]
            a.playback       = 0;
 80211fc:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8021200:	f36f 0300 	bfc	r3, #0, #1
 8021204:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
            a.playback_pause = 0;
 8021208:	2300      	movs	r3, #0
 802120a:	84bb      	strh	r3, [r7, #36]	; 0x24
            a.repeat         = 0;
 802120c:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8021210:	f36f 0341 	bfc	r3, #1, #1
 8021214:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
            a.repeat_pause   = 0;
 8021218:	2300      	movs	r3, #0
 802121a:	84fb      	strh	r3, [r7, #38]	; 0x26
            ext->force_sel = 1; /*Keep the list item selected*/
 802121c:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 802121e:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8021222:	f043 0302 	orr.w	r3, r3, #2
 8021226:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
            lv_anim_create(&a);
 802122a:	f107 0308 	add.w	r3, r7, #8
 802122e:	4618      	mov	r0, r3
 8021230:	f7fa f98c 	bl	801b54c <lv_anim_create>
}
 8021234:	bf00      	nop
 8021236:	3748      	adds	r7, #72	; 0x48
 8021238:	46bd      	mov	sp, r7
 802123a:	bd80      	pop	{r7, pc}
 802123c:	080212a9 	.word	0x080212a9
 8021240:	0801b6b1 	.word	0x0801b6b1
 8021244:	08021249 	.word	0x08021249

08021248 <lv_ddlist_anim_ready_cb>:
 * Position the list and remove the selection highlight if it's closed.
 * Called at end of list animation.
 * @param a pointer to the animation
 */
static void lv_ddlist_anim_ready_cb(lv_anim_t * a)
{
 8021248:	b580      	push	{r7, lr}
 802124a:	b084      	sub	sp, #16
 802124c:	af00      	add	r7, sp, #0
 802124e:	6078      	str	r0, [r7, #4]
    lv_obj_t * ddlist = a->var;
 8021250:	687b      	ldr	r3, [r7, #4]
 8021252:	681b      	ldr	r3, [r3, #0]
 8021254:	60fb      	str	r3, [r7, #12]
    lv_ddlist_anim_finish(ddlist);
 8021256:	68f8      	ldr	r0, [r7, #12]
 8021258:	f000 f804 	bl	8021264 <lv_ddlist_anim_finish>
}
 802125c:	bf00      	nop
 802125e:	3710      	adds	r7, #16
 8021260:	46bd      	mov	sp, r7
 8021262:	bd80      	pop	{r7, pc}

08021264 <lv_ddlist_anim_finish>:
/**
 * Clean up after the open animation
 * @param ddlist
 */
static void lv_ddlist_anim_finish(lv_obj_t * ddlist)
{
 8021264:	b580      	push	{r7, lr}
 8021266:	b084      	sub	sp, #16
 8021268:	af00      	add	r7, sp, #0
 802126a:	6078      	str	r0, [r7, #4]
    lv_ddlist_ext_t * ext = lv_obj_get_ext_attr(ddlist);
 802126c:	6878      	ldr	r0, [r7, #4]
 802126e:	f7f1 f8e0 	bl	8012432 <lv_obj_get_ext_attr>
 8021272:	60f8      	str	r0, [r7, #12]

    lv_ddlist_pos_current_option(ddlist);
 8021274:	6878      	ldr	r0, [r7, #4]
 8021276:	f000 f82a 	bl	80212ce <lv_ddlist_pos_current_option>
    ext->force_sel = 0; /*Turn off drawing of selection*/
 802127a:	68fa      	ldr	r2, [r7, #12]
 802127c:	f892 303e 	ldrb.w	r3, [r2, #62]	; 0x3e
 8021280:	f36f 0341 	bfc	r3, #1, #1
 8021284:	f882 303e 	strb.w	r3, [r2, #62]	; 0x3e
    if(ext->opened) lv_page_set_sb_mode(ddlist, LV_SB_MODE_UNHIDE);
 8021288:	68fb      	ldr	r3, [r7, #12]
 802128a:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
 802128e:	f003 0301 	and.w	r3, r3, #1
 8021292:	b2db      	uxtb	r3, r3
 8021294:	2b00      	cmp	r3, #0
 8021296:	d003      	beq.n	80212a0 <lv_ddlist_anim_finish+0x3c>
 8021298:	2105      	movs	r1, #5
 802129a:	6878      	ldr	r0, [r7, #4]
 802129c:	f001 fd76 	bl	8022d8c <lv_page_set_sb_mode>
}
 80212a0:	bf00      	nop
 80212a2:	3710      	adds	r7, #16
 80212a4:	46bd      	mov	sp, r7
 80212a6:	bd80      	pop	{r7, pc}

080212a8 <lv_ddlist_adjust_height>:
 * This keeps the option visible during animation.
 * @param ddlist Drop down list object
 * @param height New drop down list height
 */
static void lv_ddlist_adjust_height(lv_obj_t * ddlist, lv_anim_value_t height)
{
 80212a8:	b580      	push	{r7, lr}
 80212aa:	b082      	sub	sp, #8
 80212ac:	af00      	add	r7, sp, #0
 80212ae:	6078      	str	r0, [r7, #4]
 80212b0:	460b      	mov	r3, r1
 80212b2:	807b      	strh	r3, [r7, #2]
    lv_obj_set_height(ddlist, height);
 80212b4:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 80212b8:	4619      	mov	r1, r3
 80212ba:	6878      	ldr	r0, [r7, #4]
 80212bc:	f7f0 f80b 	bl	80112d6 <lv_obj_set_height>
    lv_ddlist_pos_current_option(ddlist);
 80212c0:	6878      	ldr	r0, [r7, #4]
 80212c2:	f000 f804 	bl	80212ce <lv_ddlist_pos_current_option>
}
 80212c6:	bf00      	nop
 80212c8:	3708      	adds	r7, #8
 80212ca:	46bd      	mov	sp, r7
 80212cc:	bd80      	pop	{r7, pc}

080212ce <lv_ddlist_pos_current_option>:
/**
 * Set the position of list when it is closed to show the selected item
 * @param ddlist pointer to a drop down list
 */
static void lv_ddlist_pos_current_option(lv_obj_t * ddlist)
{
 80212ce:	b580      	push	{r7, lr}
 80212d0:	b08a      	sub	sp, #40	; 0x28
 80212d2:	af00      	add	r7, sp, #0
 80212d4:	6078      	str	r0, [r7, #4]
    lv_ddlist_ext_t * ext          = lv_obj_get_ext_attr(ddlist);
 80212d6:	6878      	ldr	r0, [r7, #4]
 80212d8:	f7f1 f8ab 	bl	8012432 <lv_obj_get_ext_attr>
 80212dc:	6278      	str	r0, [r7, #36]	; 0x24
    const lv_style_t * style       = lv_obj_get_style(ddlist);
 80212de:	6878      	ldr	r0, [r7, #4]
 80212e0:	f7f0 ff88 	bl	80121f4 <lv_obj_get_style>
 80212e4:	6238      	str	r0, [r7, #32]
    const lv_font_t * font         = style->text.font;
 80212e6:	6a3b      	ldr	r3, [r7, #32]
 80212e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80212ea:	61fb      	str	r3, [r7, #28]
    lv_coord_t font_h              = lv_font_get_line_height(font);
 80212ec:	69f8      	ldr	r0, [r7, #28]
 80212ee:	f7fe ff4d 	bl	802018c <lv_font_get_line_height>
 80212f2:	4603      	mov	r3, r0
 80212f4:	837b      	strh	r3, [r7, #26]
    const lv_style_t * label_style = lv_obj_get_style(ext->label);
 80212f6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80212f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80212fa:	4618      	mov	r0, r3
 80212fc:	f7f0 ff7a 	bl	80121f4 <lv_obj_get_style>
 8021300:	6178      	str	r0, [r7, #20]
    lv_obj_t * scrl                = lv_page_get_scrl(ddlist);
 8021302:	6878      	ldr	r0, [r7, #4]
 8021304:	f001 fe06 	bl	8022f14 <lv_page_get_scrl>
 8021308:	6138      	str	r0, [r7, #16]

    lv_coord_t h = lv_obj_get_height(ddlist);
 802130a:	6878      	ldr	r0, [r7, #4]
 802130c:	f7f0 ff50 	bl	80121b0 <lv_obj_get_height>
 8021310:	4603      	mov	r3, r0
 8021312:	81fb      	strh	r3, [r7, #14]
    lv_coord_t line_y1 =
        ext->sel_opt_id * (font_h + label_style->text.line_space) + ext->label->coords.y1 - scrl->coords.y1;
 8021314:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021316:	8f5a      	ldrh	r2, [r3, #58]	; 0x3a
 8021318:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 802131c:	6979      	ldr	r1, [r7, #20]
 802131e:	f9b1 102a 	ldrsh.w	r1, [r1, #42]	; 0x2a
 8021322:	440b      	add	r3, r1
 8021324:	b29b      	uxth	r3, r3
 8021326:	fb12 f303 	smulbb	r3, r2, r3
 802132a:	b29a      	uxth	r2, r3
 802132c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802132e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8021330:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8021334:	b29b      	uxth	r3, r3
 8021336:	4413      	add	r3, r2
 8021338:	b29a      	uxth	r2, r3
 802133a:	693b      	ldr	r3, [r7, #16]
 802133c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8021340:	b29b      	uxth	r3, r3
 8021342:	1ad3      	subs	r3, r2, r3
 8021344:	b29b      	uxth	r3, r3
    lv_coord_t line_y1 =
 8021346:	81bb      	strh	r3, [r7, #12]

    lv_obj_set_y(scrl, -line_y1 + (h - font_h) / 2);
 8021348:	f9b7 200e 	ldrsh.w	r2, [r7, #14]
 802134c:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8021350:	1ad3      	subs	r3, r2, r3
 8021352:	2b00      	cmp	r3, #0
 8021354:	da00      	bge.n	8021358 <lv_ddlist_pos_current_option+0x8a>
 8021356:	3301      	adds	r3, #1
 8021358:	105b      	asrs	r3, r3, #1
 802135a:	b29a      	uxth	r2, r3
 802135c:	89bb      	ldrh	r3, [r7, #12]
 802135e:	1ad3      	subs	r3, r2, r3
 8021360:	b29b      	uxth	r3, r3
 8021362:	b21b      	sxth	r3, r3
 8021364:	4619      	mov	r1, r3
 8021366:	6938      	ldr	r0, [r7, #16]
 8021368:	f7ef ff12 	bl	8011190 <lv_obj_set_y>
    lv_obj_invalidate(ddlist);
 802136c:	6878      	ldr	r0, [r7, #4]
 802136e:	f7ef fd5e 	bl	8010e2e <lv_obj_invalidate>
}
 8021372:	bf00      	nop
 8021374:	3728      	adds	r7, #40	; 0x28
 8021376:	46bd      	mov	sp, r7
 8021378:	bd80      	pop	{r7, pc}

0802137a <lv_ddlist_refr_width>:
/**
 * Be sure the width of the scrollable exactly fits the ddlist
 * @param ddlist pointer to a ddlist
 */
static void lv_ddlist_refr_width(lv_obj_t * ddlist)
{
 802137a:	b580      	push	{r7, lr}
 802137c:	b082      	sub	sp, #8
 802137e:	af00      	add	r7, sp, #0
 8021380:	6078      	str	r0, [r7, #4]
    /*Set the TIGHT fit horizontally the set the width to the content*/
    lv_page_set_scrl_fit2(ddlist, LV_FIT_TIGHT, lv_page_get_scrl_fit_bottom(ddlist));
 8021382:	6878      	ldr	r0, [r7, #4]
 8021384:	f7fe ff37 	bl	80201f6 <lv_page_get_scrl_fit_bottom>
 8021388:	4603      	mov	r3, r0
 802138a:	461a      	mov	r2, r3
 802138c:	2101      	movs	r1, #1
 802138e:	6878      	ldr	r0, [r7, #4]
 8021390:	f7fe ff1d 	bl	80201ce <lv_page_set_scrl_fit2>

    /*Revert FILL fit to fill the parent with the options area. It allows to RIGHT/CENTER align the text*/
    lv_page_set_scrl_fit2(ddlist, LV_FIT_FILL, lv_page_get_scrl_fit_bottom(ddlist));
 8021394:	6878      	ldr	r0, [r7, #4]
 8021396:	f7fe ff2e 	bl	80201f6 <lv_page_get_scrl_fit_bottom>
 802139a:	4603      	mov	r3, r0
 802139c:	461a      	mov	r2, r3
 802139e:	2103      	movs	r1, #3
 80213a0:	6878      	ldr	r0, [r7, #4]
 80213a2:	f7fe ff14 	bl	80201ce <lv_page_set_scrl_fit2>
}
 80213a6:	bf00      	nop
 80213a8:	3708      	adds	r7, #8
 80213aa:	46bd      	mov	sp, r7
 80213ac:	bd80      	pop	{r7, pc}

080213ae <lv_font_get_line_height>:
{
 80213ae:	b480      	push	{r7}
 80213b0:	b083      	sub	sp, #12
 80213b2:	af00      	add	r7, sp, #0
 80213b4:	6078      	str	r0, [r7, #4]
    return font_p->line_height;
 80213b6:	687b      	ldr	r3, [r7, #4]
 80213b8:	7a1b      	ldrb	r3, [r3, #8]
}
 80213ba:	4618      	mov	r0, r3
 80213bc:	370c      	adds	r7, #12
 80213be:	46bd      	mov	sp, r7
 80213c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80213c4:	4770      	bx	lr

080213c6 <lv_area_get_width>:
{
 80213c6:	b480      	push	{r7}
 80213c8:	b083      	sub	sp, #12
 80213ca:	af00      	add	r7, sp, #0
 80213cc:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80213ce:	687b      	ldr	r3, [r7, #4]
 80213d0:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80213d4:	b29a      	uxth	r2, r3
 80213d6:	687b      	ldr	r3, [r7, #4]
 80213d8:	f9b3 3000 	ldrsh.w	r3, [r3]
 80213dc:	b29b      	uxth	r3, r3
 80213de:	1ad3      	subs	r3, r2, r3
 80213e0:	b29b      	uxth	r3, r3
 80213e2:	3301      	adds	r3, #1
 80213e4:	b29b      	uxth	r3, r3
 80213e6:	b21b      	sxth	r3, r3
}
 80213e8:	4618      	mov	r0, r3
 80213ea:	370c      	adds	r7, #12
 80213ec:	46bd      	mov	sp, r7
 80213ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 80213f2:	4770      	bx	lr

080213f4 <lv_area_get_height>:
{
 80213f4:	b480      	push	{r7}
 80213f6:	b083      	sub	sp, #12
 80213f8:	af00      	add	r7, sp, #0
 80213fa:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 80213fc:	687b      	ldr	r3, [r7, #4]
 80213fe:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8021402:	b29a      	uxth	r2, r3
 8021404:	687b      	ldr	r3, [r7, #4]
 8021406:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 802140a:	b29b      	uxth	r3, r3
 802140c:	1ad3      	subs	r3, r2, r3
 802140e:	b29b      	uxth	r3, r3
 8021410:	3301      	adds	r3, #1
 8021412:	b29b      	uxth	r3, r3
 8021414:	b21b      	sxth	r3, r3
}
 8021416:	4618      	mov	r0, r3
 8021418:	370c      	adds	r7, #12
 802141a:	46bd      	mov	sp, r7
 802141c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021420:	4770      	bx	lr

08021422 <lv_label_set_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @param style pointer to a style
 */
static inline void lv_label_set_style(lv_obj_t * label, lv_label_style_t type, const lv_style_t * style)
{
 8021422:	b580      	push	{r7, lr}
 8021424:	b084      	sub	sp, #16
 8021426:	af00      	add	r7, sp, #0
 8021428:	60f8      	str	r0, [r7, #12]
 802142a:	460b      	mov	r3, r1
 802142c:	607a      	str	r2, [r7, #4]
 802142e:	72fb      	strb	r3, [r7, #11]
    (void)type; /*Unused*/
    lv_obj_set_style(label, style);
 8021430:	6879      	ldr	r1, [r7, #4]
 8021432:	68f8      	ldr	r0, [r7, #12]
 8021434:	f7f0 fc3d 	bl	8011cb2 <lv_obj_set_style>
}
 8021438:	bf00      	nop
 802143a:	3710      	adds	r7, #16
 802143c:	46bd      	mov	sp, r7
 802143e:	bd80      	pop	{r7, pc}

08021440 <lv_label_get_style>:
 * @param label pointer to an label object
 * @param type which style should be get (can be only `LV_LABEL_STYLE_MAIN`)
 * @return pointer to the label's style
 */
static inline const lv_style_t * lv_label_get_style(const lv_obj_t * label, lv_label_style_t type)
{
 8021440:	b580      	push	{r7, lr}
 8021442:	b082      	sub	sp, #8
 8021444:	af00      	add	r7, sp, #0
 8021446:	6078      	str	r0, [r7, #4]
 8021448:	460b      	mov	r3, r1
 802144a:	70fb      	strb	r3, [r7, #3]
    (void)type; /*Unused*/
    return lv_obj_get_style(label);
 802144c:	6878      	ldr	r0, [r7, #4]
 802144e:	f7f0 fed1 	bl	80121f4 <lv_obj_get_style>
 8021452:	4603      	mov	r3, r0
}
 8021454:	4618      	mov	r0, r3
 8021456:	3708      	adds	r7, #8
 8021458:	46bd      	mov	sp, r7
 802145a:	bd80      	pop	{r7, pc}

0802145c <lv_label_create>:
 * @param par pointer to an object, it will be the parent of the new label
 * @param copy pointer to a button object, if not NULL then the new object will be copied from it
 * @return pointer to the created button
 */
lv_obj_t * lv_label_create(lv_obj_t * par, const lv_obj_t * copy)
{
 802145c:	b5b0      	push	{r4, r5, r7, lr}
 802145e:	b086      	sub	sp, #24
 8021460:	af00      	add	r7, sp, #0
 8021462:	6078      	str	r0, [r7, #4]
 8021464:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("label create started");

    /*Create a basic object*/
    lv_obj_t * new_label = lv_obj_create(par, copy);
 8021466:	6839      	ldr	r1, [r7, #0]
 8021468:	6878      	ldr	r0, [r7, #4]
 802146a:	f7ef f98b 	bl	8010784 <lv_obj_create>
 802146e:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_label);
 8021470:	697b      	ldr	r3, [r7, #20]
 8021472:	2b00      	cmp	r3, #0
 8021474:	d106      	bne.n	8021484 <lv_label_create+0x28>
 8021476:	4b97      	ldr	r3, [pc, #604]	; (80216d4 <lv_label_create+0x278>)
 8021478:	224b      	movs	r2, #75	; 0x4b
 802147a:	4997      	ldr	r1, [pc, #604]	; (80216d8 <lv_label_create+0x27c>)
 802147c:	2003      	movs	r0, #3
 802147e:	f7fb f9c5 	bl	801c80c <lv_log_add>
 8021482:	e7fe      	b.n	8021482 <lv_label_create+0x26>
    if(new_label == NULL) return NULL;
 8021484:	697b      	ldr	r3, [r7, #20]
 8021486:	2b00      	cmp	r3, #0
 8021488:	d101      	bne.n	802148e <lv_label_create+0x32>
 802148a:	2300      	movs	r3, #0
 802148c:	e11d      	b.n	80216ca <lv_label_create+0x26e>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_label);
 802148e:	4b93      	ldr	r3, [pc, #588]	; (80216dc <lv_label_create+0x280>)
 8021490:	681b      	ldr	r3, [r3, #0]
 8021492:	2b00      	cmp	r3, #0
 8021494:	d105      	bne.n	80214a2 <lv_label_create+0x46>
 8021496:	6978      	ldr	r0, [r7, #20]
 8021498:	f7f0 ffb3 	bl	8012402 <lv_obj_get_signal_cb>
 802149c:	4602      	mov	r2, r0
 802149e:	4b8f      	ldr	r3, [pc, #572]	; (80216dc <lv_label_create+0x280>)
 80214a0:	601a      	str	r2, [r3, #0]

    /*Extend the basic object to a label object*/
    lv_obj_allocate_ext_attr(new_label, sizeof(lv_label_ext_t));
 80214a2:	2120      	movs	r1, #32
 80214a4:	6978      	ldr	r0, [r7, #20]
 80214a6:	f7f0 fd87 	bl	8011fb8 <lv_obj_allocate_ext_attr>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(new_label);
 80214aa:	6978      	ldr	r0, [r7, #20]
 80214ac:	f7f0 ffc1 	bl	8012432 <lv_obj_get_ext_attr>
 80214b0:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 80214b2:	693b      	ldr	r3, [r7, #16]
 80214b4:	2b00      	cmp	r3, #0
 80214b6:	d106      	bne.n	80214c6 <lv_label_create+0x6a>
 80214b8:	4b86      	ldr	r3, [pc, #536]	; (80216d4 <lv_label_create+0x278>)
 80214ba:	2254      	movs	r2, #84	; 0x54
 80214bc:	4986      	ldr	r1, [pc, #536]	; (80216d8 <lv_label_create+0x27c>)
 80214be:	2003      	movs	r0, #3
 80214c0:	f7fb f9a4 	bl	801c80c <lv_log_add>
 80214c4:	e7fe      	b.n	80214c4 <lv_label_create+0x68>
    if(ext == NULL) return NULL;
 80214c6:	693b      	ldr	r3, [r7, #16]
 80214c8:	2b00      	cmp	r3, #0
 80214ca:	d101      	bne.n	80214d0 <lv_label_create+0x74>
 80214cc:	2300      	movs	r3, #0
 80214ce:	e0fc      	b.n	80216ca <lv_label_create+0x26e>

    ext->text       = NULL;
 80214d0:	693b      	ldr	r3, [r7, #16]
 80214d2:	2200      	movs	r2, #0
 80214d4:	601a      	str	r2, [r3, #0]
    ext->static_txt = 0;
 80214d6:	693a      	ldr	r2, [r7, #16]
 80214d8:	7f93      	ldrb	r3, [r2, #30]
 80214da:	f36f 03c3 	bfc	r3, #3, #1
 80214de:	7793      	strb	r3, [r2, #30]
    ext->recolor    = 0;
 80214e0:	693a      	ldr	r2, [r7, #16]
 80214e2:	7f93      	ldrb	r3, [r2, #30]
 80214e4:	f36f 1386 	bfc	r3, #6, #1
 80214e8:	7793      	strb	r3, [r2, #30]
    ext->body_draw  = 0;
 80214ea:	693a      	ldr	r2, [r7, #16]
 80214ec:	7fd3      	ldrb	r3, [r2, #31]
 80214ee:	f36f 0300 	bfc	r3, #0, #1
 80214f2:	77d3      	strb	r3, [r2, #31]
    ext->align      = LV_LABEL_ALIGN_LEFT;
 80214f4:	693a      	ldr	r2, [r7, #16]
 80214f6:	7f93      	ldrb	r3, [r2, #30]
 80214f8:	f36f 1305 	bfc	r3, #4, #2
 80214fc:	7793      	strb	r3, [r2, #30]
    ext->dot_end    = LV_LABEL_DOT_END_INV;
 80214fe:	693b      	ldr	r3, [r7, #16]
 8021500:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8021504:	811a      	strh	r2, [r3, #8]
    ext->long_mode  = LV_LABEL_LONG_EXPAND;
 8021506:	693a      	ldr	r2, [r7, #16]
 8021508:	7f93      	ldrb	r3, [r2, #30]
 802150a:	f36f 0302 	bfc	r3, #0, #3
 802150e:	7793      	strb	r3, [r2, #30]
#if LV_USE_ANIMATION
    ext->anim_speed = LV_LABEL_DEF_SCROLL_SPEED;
 8021510:	693b      	ldr	r3, [r7, #16]
 8021512:	2219      	movs	r2, #25
 8021514:	839a      	strh	r2, [r3, #28]
#endif
    ext->offset.x = 0;
 8021516:	693b      	ldr	r3, [r7, #16]
 8021518:	2200      	movs	r2, #0
 802151a:	815a      	strh	r2, [r3, #10]
    ext->offset.y = 0;
 802151c:	693b      	ldr	r3, [r7, #16]
 802151e:	2200      	movs	r2, #0
 8021520:	819a      	strh	r2, [r3, #12]

    ext->hint.line_start = -1;
 8021522:	693b      	ldr	r3, [r7, #16]
 8021524:	f04f 32ff 	mov.w	r2, #4294967295
 8021528:	611a      	str	r2, [r3, #16]
    ext->hint.coord_y    = 0;
 802152a:	693b      	ldr	r3, [r7, #16]
 802152c:	2200      	movs	r2, #0
 802152e:	619a      	str	r2, [r3, #24]
    ext->hint.y          = 0;
 8021530:	693b      	ldr	r3, [r7, #16]
 8021532:	2200      	movs	r2, #0
 8021534:	615a      	str	r2, [r3, #20]

#if LV_LABEL_TEXT_SEL
    ext->txt_sel_start = LV_LABEL_TEXT_SEL_OFF;
    ext->txt_sel_end   = LV_LABEL_TEXT_SEL_OFF;
#endif
    ext->dot.tmp_ptr   = NULL;
 8021536:	693b      	ldr	r3, [r7, #16]
 8021538:	2200      	movs	r2, #0
 802153a:	605a      	str	r2, [r3, #4]
    ext->dot_tmp_alloc = 0;
 802153c:	693a      	ldr	r2, [r7, #16]
 802153e:	7fd3      	ldrb	r3, [r2, #31]
 8021540:	f36f 0341 	bfc	r3, #1, #1
 8021544:	77d3      	strb	r3, [r2, #31]

    lv_obj_set_design_cb(new_label, lv_label_design);
 8021546:	4966      	ldr	r1, [pc, #408]	; (80216e0 <lv_label_create+0x284>)
 8021548:	6978      	ldr	r0, [r7, #20]
 802154a:	f7f0 fd27 	bl	8011f9c <lv_obj_set_design_cb>
    lv_obj_set_signal_cb(new_label, lv_label_signal);
 802154e:	4965      	ldr	r1, [pc, #404]	; (80216e4 <lv_label_create+0x288>)
 8021550:	6978      	ldr	r0, [r7, #20]
 8021552:	f7f0 fd15 	bl	8011f80 <lv_obj_set_signal_cb>

    /*Init the new label*/
    if(copy == NULL) {
 8021556:	683b      	ldr	r3, [r7, #0]
 8021558:	2b00      	cmp	r3, #0
 802155a:	d111      	bne.n	8021580 <lv_label_create+0x124>
        lv_obj_set_click(new_label, false);
 802155c:	2100      	movs	r1, #0
 802155e:	6978      	ldr	r0, [r7, #20]
 8021560:	f7f0 fc01 	bl	8011d66 <lv_obj_set_click>
        lv_label_set_long_mode(new_label, LV_LABEL_LONG_EXPAND);
 8021564:	2100      	movs	r1, #0
 8021566:	6978      	ldr	r0, [r7, #20]
 8021568:	f000 f96c 	bl	8021844 <lv_label_set_long_mode>
        lv_label_set_text(new_label, "Text");
 802156c:	495e      	ldr	r1, [pc, #376]	; (80216e8 <lv_label_create+0x28c>)
 802156e:	6978      	ldr	r0, [r7, #20]
 8021570:	f000 f8bc 	bl	80216ec <lv_label_set_text>
        lv_label_set_style(new_label, LV_LABEL_STYLE_MAIN, NULL); /*Inherit parent's style*/
 8021574:	2200      	movs	r2, #0
 8021576:	2100      	movs	r1, #0
 8021578:	6978      	ldr	r0, [r7, #20]
 802157a:	f7ff ff52 	bl	8021422 <lv_label_set_style>
 802157e:	e0a3      	b.n	80216c8 <lv_label_create+0x26c>
    }
    /*Copy 'copy' if not NULL*/
    else {
        lv_label_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 8021580:	6838      	ldr	r0, [r7, #0]
 8021582:	f7f0 ff56 	bl	8012432 <lv_obj_get_ext_attr>
 8021586:	60f8      	str	r0, [r7, #12]
        lv_label_set_long_mode(new_label, lv_label_get_long_mode(copy));
 8021588:	6838      	ldr	r0, [r7, #0]
 802158a:	f000 fa3c 	bl	8021a06 <lv_label_get_long_mode>
 802158e:	4603      	mov	r3, r0
 8021590:	4619      	mov	r1, r3
 8021592:	6978      	ldr	r0, [r7, #20]
 8021594:	f000 f956 	bl	8021844 <lv_label_set_long_mode>
        lv_label_set_recolor(new_label, lv_label_get_recolor(copy));
 8021598:	6838      	ldr	r0, [r7, #0]
 802159a:	f000 fa56 	bl	8021a4a <lv_label_get_recolor>
 802159e:	4603      	mov	r3, r0
 80215a0:	4619      	mov	r1, r3
 80215a2:	6978      	ldr	r0, [r7, #20]
 80215a4:	f000 f9ce 	bl	8021944 <lv_label_set_recolor>
        lv_label_set_body_draw(new_label, lv_label_get_body_draw(copy));
 80215a8:	6838      	ldr	r0, [r7, #0]
 80215aa:	f000 fa64 	bl	8021a76 <lv_label_get_body_draw>
 80215ae:	4603      	mov	r3, r0
 80215b0:	4619      	mov	r1, r3
 80215b2:	6978      	ldr	r0, [r7, #20]
 80215b4:	f000 f9ee 	bl	8021994 <lv_label_set_body_draw>
        lv_label_set_align(new_label, lv_label_get_align(copy));
 80215b8:	6838      	ldr	r0, [r7, #0]
 80215ba:	f000 fa35 	bl	8021a28 <lv_label_get_align>
 80215be:	4603      	mov	r3, r0
 80215c0:	4619      	mov	r1, r3
 80215c2:	6978      	ldr	r0, [r7, #20]
 80215c4:	f000 f99a 	bl	80218fc <lv_label_set_align>
        if(copy_ext->static_txt == 0)
 80215c8:	68fb      	ldr	r3, [r7, #12]
 80215ca:	7f9b      	ldrb	r3, [r3, #30]
 80215cc:	f003 0308 	and.w	r3, r3, #8
 80215d0:	b2db      	uxtb	r3, r3
 80215d2:	2b00      	cmp	r3, #0
 80215d4:	d108      	bne.n	80215e8 <lv_label_create+0x18c>
            lv_label_set_text(new_label, lv_label_get_text(copy));
 80215d6:	6838      	ldr	r0, [r7, #0]
 80215d8:	f000 fa07 	bl	80219ea <lv_label_get_text>
 80215dc:	4603      	mov	r3, r0
 80215de:	4619      	mov	r1, r3
 80215e0:	6978      	ldr	r0, [r7, #20]
 80215e2:	f000 f883 	bl	80216ec <lv_label_set_text>
 80215e6:	e007      	b.n	80215f8 <lv_label_create+0x19c>
        else
            lv_label_set_static_text(new_label, lv_label_get_text(copy));
 80215e8:	6838      	ldr	r0, [r7, #0]
 80215ea:	f000 f9fe 	bl	80219ea <lv_label_get_text>
 80215ee:	4603      	mov	r3, r0
 80215f0:	4619      	mov	r1, r3
 80215f2:	6978      	ldr	r0, [r7, #20]
 80215f4:	f000 f8f8 	bl	80217e8 <lv_label_set_static_text>

        /*In DOT mode save the text byte-to-byte because a '\0' can be in the middle*/
        if(copy_ext->long_mode == LV_LABEL_LONG_DOT) {
 80215f8:	68fb      	ldr	r3, [r7, #12]
 80215fa:	7f9b      	ldrb	r3, [r3, #30]
 80215fc:	f003 0307 	and.w	r3, r3, #7
 8021600:	b2db      	uxtb	r3, r3
 8021602:	2b02      	cmp	r3, #2
 8021604:	d12e      	bne.n	8021664 <lv_label_create+0x208>
            ext->text = lv_mem_realloc(ext->text, lv_mem_get_size(copy_ext->text));
 8021606:	693b      	ldr	r3, [r7, #16]
 8021608:	681c      	ldr	r4, [r3, #0]
 802160a:	68fb      	ldr	r3, [r7, #12]
 802160c:	681b      	ldr	r3, [r3, #0]
 802160e:	4618      	mov	r0, r3
 8021610:	f7fb fa2e 	bl	801ca70 <lv_mem_get_size>
 8021614:	4603      	mov	r3, r0
 8021616:	4619      	mov	r1, r3
 8021618:	4620      	mov	r0, r4
 802161a:	f7fb f9cf 	bl	801c9bc <lv_mem_realloc>
 802161e:	4602      	mov	r2, r0
 8021620:	693b      	ldr	r3, [r7, #16]
 8021622:	601a      	str	r2, [r3, #0]
            lv_mem_assert(ext->text);
 8021624:	693b      	ldr	r3, [r7, #16]
 8021626:	681b      	ldr	r3, [r3, #0]
 8021628:	2b00      	cmp	r3, #0
 802162a:	d106      	bne.n	802163a <lv_label_create+0x1de>
 802162c:	4b29      	ldr	r3, [pc, #164]	; (80216d4 <lv_label_create+0x278>)
 802162e:	2288      	movs	r2, #136	; 0x88
 8021630:	4929      	ldr	r1, [pc, #164]	; (80216d8 <lv_label_create+0x27c>)
 8021632:	2003      	movs	r0, #3
 8021634:	f7fb f8ea 	bl	801c80c <lv_log_add>
 8021638:	e7fe      	b.n	8021638 <lv_label_create+0x1dc>
            if(ext->text == NULL) return NULL;
 802163a:	693b      	ldr	r3, [r7, #16]
 802163c:	681b      	ldr	r3, [r3, #0]
 802163e:	2b00      	cmp	r3, #0
 8021640:	d101      	bne.n	8021646 <lv_label_create+0x1ea>
 8021642:	2300      	movs	r3, #0
 8021644:	e041      	b.n	80216ca <lv_label_create+0x26e>
            memcpy(ext->text, copy_ext->text, lv_mem_get_size(copy_ext->text));
 8021646:	693b      	ldr	r3, [r7, #16]
 8021648:	681c      	ldr	r4, [r3, #0]
 802164a:	68fb      	ldr	r3, [r7, #12]
 802164c:	681d      	ldr	r5, [r3, #0]
 802164e:	68fb      	ldr	r3, [r7, #12]
 8021650:	681b      	ldr	r3, [r3, #0]
 8021652:	4618      	mov	r0, r3
 8021654:	f7fb fa0c 	bl	801ca70 <lv_mem_get_size>
 8021658:	4603      	mov	r3, r0
 802165a:	461a      	mov	r2, r3
 802165c:	4629      	mov	r1, r5
 802165e:	4620      	mov	r0, r4
 8021660:	f005 fdac 	bl	80271bc <memcpy>
        }

        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 8021664:	68fb      	ldr	r3, [r7, #12]
 8021666:	7fdb      	ldrb	r3, [r3, #31]
 8021668:	f003 0302 	and.w	r3, r3, #2
 802166c:	b2db      	uxtb	r3, r3
 802166e:	2b00      	cmp	r3, #0
 8021670:	d013      	beq.n	802169a <lv_label_create+0x23e>
 8021672:	68fb      	ldr	r3, [r7, #12]
 8021674:	685b      	ldr	r3, [r3, #4]
 8021676:	2b00      	cmp	r3, #0
 8021678:	d00f      	beq.n	802169a <lv_label_create+0x23e>
            int len = strlen(copy_ext->dot.tmp_ptr);
 802167a:	68fb      	ldr	r3, [r7, #12]
 802167c:	685b      	ldr	r3, [r3, #4]
 802167e:	4618      	mov	r0, r3
 8021680:	f7de fdd0 	bl	8000224 <strlen>
 8021684:	4603      	mov	r3, r0
 8021686:	60bb      	str	r3, [r7, #8]
            lv_label_set_dot_tmp(new_label, ext->dot.tmp_ptr, len);
 8021688:	693b      	ldr	r3, [r7, #16]
 802168a:	685b      	ldr	r3, [r3, #4]
 802168c:	68ba      	ldr	r2, [r7, #8]
 802168e:	b292      	uxth	r2, r2
 8021690:	4619      	mov	r1, r3
 8021692:	6978      	ldr	r0, [r7, #20]
 8021694:	f001 f902 	bl	802289c <lv_label_set_dot_tmp>
        if(copy_ext->dot_tmp_alloc && copy_ext->dot.tmp_ptr) {
 8021698:	e005      	b.n	80216a6 <lv_label_create+0x24a>
        } else {
            memcpy(ext->dot.tmp, copy_ext->dot.tmp, sizeof(ext->dot.tmp));
 802169a:	693b      	ldr	r3, [r7, #16]
 802169c:	3304      	adds	r3, #4
 802169e:	68fa      	ldr	r2, [r7, #12]
 80216a0:	3204      	adds	r2, #4
 80216a2:	6812      	ldr	r2, [r2, #0]
 80216a4:	601a      	str	r2, [r3, #0]
        }
        ext->dot_tmp_alloc = copy_ext->dot_tmp_alloc;
 80216a6:	68fb      	ldr	r3, [r7, #12]
 80216a8:	7fdb      	ldrb	r3, [r3, #31]
 80216aa:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80216ae:	b2d9      	uxtb	r1, r3
 80216b0:	693a      	ldr	r2, [r7, #16]
 80216b2:	7fd3      	ldrb	r3, [r2, #31]
 80216b4:	f361 0341 	bfi	r3, r1, #1, #1
 80216b8:	77d3      	strb	r3, [r2, #31]
        ext->dot_end       = copy_ext->dot_end;
 80216ba:	68fb      	ldr	r3, [r7, #12]
 80216bc:	891a      	ldrh	r2, [r3, #8]
 80216be:	693b      	ldr	r3, [r7, #16]
 80216c0:	811a      	strh	r2, [r3, #8]

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_label);
 80216c2:	6978      	ldr	r0, [r7, #20]
 80216c4:	f7f0 fb07 	bl	8011cd6 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("label created");

    return new_label;
 80216c8:	697b      	ldr	r3, [r7, #20]
}
 80216ca:	4618      	mov	r0, r3
 80216cc:	3718      	adds	r7, #24
 80216ce:	46bd      	mov	sp, r7
 80216d0:	bdb0      	pop	{r4, r5, r7, pc}
 80216d2:	bf00      	nop
 80216d4:	08029054 	.word	0x08029054
 80216d8:	08029064 	.word	0x08029064
 80216dc:	2000c3dc 	.word	0x2000c3dc
 80216e0:	08021d21 	.word	0x08021d21
 80216e4:	080220cd 	.word	0x080220cd
 80216e8:	08029084 	.word	0x08029084

080216ec <lv_label_set_text>:
 * Set a new text for a label. Memory will be allocated to store the text by the label.
 * @param label pointer to a label object
 * @param text '\0' terminated character string. NULL to refresh with the current text.
 */
void lv_label_set_text(lv_obj_t * label, const char * text)
{
 80216ec:	b590      	push	{r4, r7, lr}
 80216ee:	b085      	sub	sp, #20
 80216f0:	af00      	add	r7, sp, #0
 80216f2:	6078      	str	r0, [r7, #4]
 80216f4:	6039      	str	r1, [r7, #0]
    lv_obj_invalidate(label);
 80216f6:	6878      	ldr	r0, [r7, #4]
 80216f8:	f7ef fb99 	bl	8010e2e <lv_obj_invalidate>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80216fc:	6878      	ldr	r0, [r7, #4]
 80216fe:	f7f0 fe98 	bl	8012432 <lv_obj_get_ext_attr>
 8021702:	60f8      	str	r0, [r7, #12]

    /*If text is NULL then refresh */
    if(text == NULL) {
 8021704:	683b      	ldr	r3, [r7, #0]
 8021706:	2b00      	cmp	r3, #0
 8021708:	d103      	bne.n	8021712 <lv_label_set_text+0x26>
        lv_label_refr_text(label);
 802170a:	6878      	ldr	r0, [r7, #4]
 802170c:	f000 fd9e 	bl	802224c <lv_label_refr_text>
        return;
 8021710:	e062      	b.n	80217d8 <lv_label_set_text+0xec>
    }

    if(ext->text == text) {
 8021712:	68fb      	ldr	r3, [r7, #12]
 8021714:	681b      	ldr	r3, [r3, #0]
 8021716:	683a      	ldr	r2, [r7, #0]
 8021718:	429a      	cmp	r2, r3
 802171a:	d11f      	bne.n	802175c <lv_label_set_text+0x70>
        /*If set its own text then reallocate it (maybe its size changed)*/
        ext->text = lv_mem_realloc(ext->text, strlen(ext->text) + 1);
 802171c:	68fb      	ldr	r3, [r7, #12]
 802171e:	681c      	ldr	r4, [r3, #0]
 8021720:	68fb      	ldr	r3, [r7, #12]
 8021722:	681b      	ldr	r3, [r3, #0]
 8021724:	4618      	mov	r0, r3
 8021726:	f7de fd7d 	bl	8000224 <strlen>
 802172a:	4603      	mov	r3, r0
 802172c:	3301      	adds	r3, #1
 802172e:	4619      	mov	r1, r3
 8021730:	4620      	mov	r0, r4
 8021732:	f7fb f943 	bl	801c9bc <lv_mem_realloc>
 8021736:	4602      	mov	r2, r0
 8021738:	68fb      	ldr	r3, [r7, #12]
 802173a:	601a      	str	r2, [r3, #0]
        lv_mem_assert(ext->text);
 802173c:	68fb      	ldr	r3, [r7, #12]
 802173e:	681b      	ldr	r3, [r3, #0]
 8021740:	2b00      	cmp	r3, #0
 8021742:	d106      	bne.n	8021752 <lv_label_set_text+0x66>
 8021744:	4b26      	ldr	r3, [pc, #152]	; (80217e0 <lv_label_set_text+0xf4>)
 8021746:	22b7      	movs	r2, #183	; 0xb7
 8021748:	4926      	ldr	r1, [pc, #152]	; (80217e4 <lv_label_set_text+0xf8>)
 802174a:	2003      	movs	r0, #3
 802174c:	f7fb f85e 	bl	801c80c <lv_log_add>
 8021750:	e7fe      	b.n	8021750 <lv_label_set_text+0x64>
        if(ext->text == NULL) return;
 8021752:	68fb      	ldr	r3, [r7, #12]
 8021754:	681b      	ldr	r3, [r3, #0]
 8021756:	2b00      	cmp	r3, #0
 8021758:	d139      	bne.n	80217ce <lv_label_set_text+0xe2>
 802175a:	e03d      	b.n	80217d8 <lv_label_set_text+0xec>
    } else {
        /*Allocate space for the new text*/
        uint32_t len = strlen(text) + 1;
 802175c:	6838      	ldr	r0, [r7, #0]
 802175e:	f7de fd61 	bl	8000224 <strlen>
 8021762:	4603      	mov	r3, r0
 8021764:	3301      	adds	r3, #1
 8021766:	60bb      	str	r3, [r7, #8]
        if(ext->text != NULL && ext->static_txt == 0) {
 8021768:	68fb      	ldr	r3, [r7, #12]
 802176a:	681b      	ldr	r3, [r3, #0]
 802176c:	2b00      	cmp	r3, #0
 802176e:	d00e      	beq.n	802178e <lv_label_set_text+0xa2>
 8021770:	68fb      	ldr	r3, [r7, #12]
 8021772:	7f9b      	ldrb	r3, [r3, #30]
 8021774:	f003 0308 	and.w	r3, r3, #8
 8021778:	b2db      	uxtb	r3, r3
 802177a:	2b00      	cmp	r3, #0
 802177c:	d107      	bne.n	802178e <lv_label_set_text+0xa2>
            lv_mem_free(ext->text);
 802177e:	68fb      	ldr	r3, [r7, #12]
 8021780:	681b      	ldr	r3, [r3, #0]
 8021782:	4618      	mov	r0, r3
 8021784:	f7fb f8ce 	bl	801c924 <lv_mem_free>
            ext->text = NULL;
 8021788:	68fb      	ldr	r3, [r7, #12]
 802178a:	2200      	movs	r2, #0
 802178c:	601a      	str	r2, [r3, #0]
        }

        ext->text = lv_mem_alloc(len);
 802178e:	68b8      	ldr	r0, [r7, #8]
 8021790:	f7fb f880 	bl	801c894 <lv_mem_alloc>
 8021794:	4602      	mov	r2, r0
 8021796:	68fb      	ldr	r3, [r7, #12]
 8021798:	601a      	str	r2, [r3, #0]
        lv_mem_assert(ext->text);
 802179a:	68fb      	ldr	r3, [r7, #12]
 802179c:	681b      	ldr	r3, [r3, #0]
 802179e:	2b00      	cmp	r3, #0
 80217a0:	d106      	bne.n	80217b0 <lv_label_set_text+0xc4>
 80217a2:	4b0f      	ldr	r3, [pc, #60]	; (80217e0 <lv_label_set_text+0xf4>)
 80217a4:	22c2      	movs	r2, #194	; 0xc2
 80217a6:	490f      	ldr	r1, [pc, #60]	; (80217e4 <lv_label_set_text+0xf8>)
 80217a8:	2003      	movs	r0, #3
 80217aa:	f7fb f82f 	bl	801c80c <lv_log_add>
 80217ae:	e7fe      	b.n	80217ae <lv_label_set_text+0xc2>
        if(ext->text == NULL) return;
 80217b0:	68fb      	ldr	r3, [r7, #12]
 80217b2:	681b      	ldr	r3, [r3, #0]
 80217b4:	2b00      	cmp	r3, #0
 80217b6:	d00e      	beq.n	80217d6 <lv_label_set_text+0xea>

        strcpy(ext->text, text);
 80217b8:	68fb      	ldr	r3, [r7, #12]
 80217ba:	681b      	ldr	r3, [r3, #0]
 80217bc:	6839      	ldr	r1, [r7, #0]
 80217be:	4618      	mov	r0, r3
 80217c0:	f005 fda0 	bl	8027304 <strcpy>
        ext->static_txt = 0; /*Now the text is dynamically allocated*/
 80217c4:	68fa      	ldr	r2, [r7, #12]
 80217c6:	7f93      	ldrb	r3, [r2, #30]
 80217c8:	f36f 03c3 	bfc	r3, #3, #1
 80217cc:	7793      	strb	r3, [r2, #30]
    }

    lv_label_refr_text(label);
 80217ce:	6878      	ldr	r0, [r7, #4]
 80217d0:	f000 fd3c 	bl	802224c <lv_label_refr_text>
 80217d4:	e000      	b.n	80217d8 <lv_label_set_text+0xec>
        if(ext->text == NULL) return;
 80217d6:	bf00      	nop
}
 80217d8:	3714      	adds	r7, #20
 80217da:	46bd      	mov	sp, r7
 80217dc:	bd90      	pop	{r4, r7, pc}
 80217de:	bf00      	nop
 80217e0:	08029054 	.word	0x08029054
 80217e4:	08029064 	.word	0x08029064

080217e8 <lv_label_set_static_text>:
 * has to be 'alive' while the label exist.
 * @param label pointer to a label object
 * @param text pointer to a text. NULL to refresh with the current text.
 */
void lv_label_set_static_text(lv_obj_t * label, const char * text)
{
 80217e8:	b580      	push	{r7, lr}
 80217ea:	b084      	sub	sp, #16
 80217ec:	af00      	add	r7, sp, #0
 80217ee:	6078      	str	r0, [r7, #4]
 80217f0:	6039      	str	r1, [r7, #0]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80217f2:	6878      	ldr	r0, [r7, #4]
 80217f4:	f7f0 fe1d 	bl	8012432 <lv_obj_get_ext_attr>
 80217f8:	60f8      	str	r0, [r7, #12]
    if(ext->static_txt == 0 && ext->text != NULL) {
 80217fa:	68fb      	ldr	r3, [r7, #12]
 80217fc:	7f9b      	ldrb	r3, [r3, #30]
 80217fe:	f003 0308 	and.w	r3, r3, #8
 8021802:	b2db      	uxtb	r3, r3
 8021804:	2b00      	cmp	r3, #0
 8021806:	d10b      	bne.n	8021820 <lv_label_set_static_text+0x38>
 8021808:	68fb      	ldr	r3, [r7, #12]
 802180a:	681b      	ldr	r3, [r3, #0]
 802180c:	2b00      	cmp	r3, #0
 802180e:	d007      	beq.n	8021820 <lv_label_set_static_text+0x38>
        lv_mem_free(ext->text);
 8021810:	68fb      	ldr	r3, [r7, #12]
 8021812:	681b      	ldr	r3, [r3, #0]
 8021814:	4618      	mov	r0, r3
 8021816:	f7fb f885 	bl	801c924 <lv_mem_free>
        ext->text = NULL;
 802181a:	68fb      	ldr	r3, [r7, #12]
 802181c:	2200      	movs	r2, #0
 802181e:	601a      	str	r2, [r3, #0]
    }

    if(text != NULL) {
 8021820:	683b      	ldr	r3, [r7, #0]
 8021822:	2b00      	cmp	r3, #0
 8021824:	d007      	beq.n	8021836 <lv_label_set_static_text+0x4e>
        ext->static_txt = 1;
 8021826:	68fa      	ldr	r2, [r7, #12]
 8021828:	7f93      	ldrb	r3, [r2, #30]
 802182a:	f043 0308 	orr.w	r3, r3, #8
 802182e:	7793      	strb	r3, [r2, #30]
        ext->text       = (char *)text;
 8021830:	68fb      	ldr	r3, [r7, #12]
 8021832:	683a      	ldr	r2, [r7, #0]
 8021834:	601a      	str	r2, [r3, #0]
    }

    lv_label_refr_text(label);
 8021836:	6878      	ldr	r0, [r7, #4]
 8021838:	f000 fd08 	bl	802224c <lv_label_refr_text>
}
 802183c:	bf00      	nop
 802183e:	3710      	adds	r7, #16
 8021840:	46bd      	mov	sp, r7
 8021842:	bd80      	pop	{r7, pc}

08021844 <lv_label_set_long_mode>:
 * @param long_mode the new mode from 'lv_label_long_mode' enum.
 *                  In LV_LONG_BREAK/LONG/ROLL the size of the label should be set AFTER this
 * function
 */
void lv_label_set_long_mode(lv_obj_t * label, lv_label_long_mode_t long_mode)
{
 8021844:	b580      	push	{r7, lr}
 8021846:	b084      	sub	sp, #16
 8021848:	af00      	add	r7, sp, #0
 802184a:	6078      	str	r0, [r7, #4]
 802184c:	460b      	mov	r3, r1
 802184e:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021850:	6878      	ldr	r0, [r7, #4]
 8021852:	f7f0 fdee 	bl	8012432 <lv_obj_get_ext_attr>
 8021856:	60f8      	str	r0, [r7, #12]

#if LV_USE_ANIMATION
    /*Delete the old animation (if exists)*/
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_x);
 8021858:	4924      	ldr	r1, [pc, #144]	; (80218ec <lv_label_set_long_mode+0xa8>)
 802185a:	6878      	ldr	r0, [r7, #4]
 802185c:	f7f9 fec0 	bl	801b5e0 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_obj_set_y);
 8021860:	4923      	ldr	r1, [pc, #140]	; (80218f0 <lv_label_set_long_mode+0xac>)
 8021862:	6878      	ldr	r0, [r7, #4]
 8021864:	f7f9 febc 	bl	801b5e0 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 8021868:	4922      	ldr	r1, [pc, #136]	; (80218f4 <lv_label_set_long_mode+0xb0>)
 802186a:	6878      	ldr	r0, [r7, #4]
 802186c:	f7f9 feb8 	bl	801b5e0 <lv_anim_del>
    lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 8021870:	4921      	ldr	r1, [pc, #132]	; (80218f8 <lv_label_set_long_mode+0xb4>)
 8021872:	6878      	ldr	r0, [r7, #4]
 8021874:	f7f9 feb4 	bl	801b5e0 <lv_anim_del>
#endif
    ext->offset.x = 0;
 8021878:	68fb      	ldr	r3, [r7, #12]
 802187a:	2200      	movs	r2, #0
 802187c:	815a      	strh	r2, [r3, #10]
    ext->offset.y = 0;
 802187e:	68fb      	ldr	r3, [r7, #12]
 8021880:	2200      	movs	r2, #0
 8021882:	819a      	strh	r2, [r3, #12]

    if(long_mode == LV_LABEL_LONG_SROLL || long_mode == LV_LABEL_LONG_SROLL_CIRC || long_mode == LV_LABEL_LONG_CROP)
 8021884:	78fb      	ldrb	r3, [r7, #3]
 8021886:	2b03      	cmp	r3, #3
 8021888:	d005      	beq.n	8021896 <lv_label_set_long_mode+0x52>
 802188a:	78fb      	ldrb	r3, [r7, #3]
 802188c:	2b04      	cmp	r3, #4
 802188e:	d002      	beq.n	8021896 <lv_label_set_long_mode+0x52>
 8021890:	78fb      	ldrb	r3, [r7, #3]
 8021892:	2b05      	cmp	r3, #5
 8021894:	d105      	bne.n	80218a2 <lv_label_set_long_mode+0x5e>
        ext->expand = 1;
 8021896:	68fa      	ldr	r2, [r7, #12]
 8021898:	7f93      	ldrb	r3, [r2, #30]
 802189a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 802189e:	7793      	strb	r3, [r2, #30]
 80218a0:	e004      	b.n	80218ac <lv_label_set_long_mode+0x68>
    else
        ext->expand = 0;
 80218a2:	68fa      	ldr	r2, [r7, #12]
 80218a4:	7f93      	ldrb	r3, [r2, #30]
 80218a6:	f36f 13c7 	bfc	r3, #7, #1
 80218aa:	7793      	strb	r3, [r2, #30]

    /*Restore the character under the dots*/
    if(ext->long_mode == LV_LABEL_LONG_DOT && ext->dot_end != LV_LABEL_DOT_END_INV) {
 80218ac:	68fb      	ldr	r3, [r7, #12]
 80218ae:	7f9b      	ldrb	r3, [r3, #30]
 80218b0:	f003 0307 	and.w	r3, r3, #7
 80218b4:	b2db      	uxtb	r3, r3
 80218b6:	2b02      	cmp	r3, #2
 80218b8:	d108      	bne.n	80218cc <lv_label_set_long_mode+0x88>
 80218ba:	68fb      	ldr	r3, [r7, #12]
 80218bc:	891b      	ldrh	r3, [r3, #8]
 80218be:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80218c2:	4293      	cmp	r3, r2
 80218c4:	d002      	beq.n	80218cc <lv_label_set_long_mode+0x88>
        lv_label_revert_dots(label);
 80218c6:	6878      	ldr	r0, [r7, #4]
 80218c8:	f000 ff66 	bl	8022798 <lv_label_revert_dots>
    }

    ext->long_mode = long_mode;
 80218cc:	78fb      	ldrb	r3, [r7, #3]
 80218ce:	f003 0307 	and.w	r3, r3, #7
 80218d2:	b2d9      	uxtb	r1, r3
 80218d4:	68fa      	ldr	r2, [r7, #12]
 80218d6:	7f93      	ldrb	r3, [r2, #30]
 80218d8:	f361 0302 	bfi	r3, r1, #0, #3
 80218dc:	7793      	strb	r3, [r2, #30]
    lv_label_refr_text(label);
 80218de:	6878      	ldr	r0, [r7, #4]
 80218e0:	f000 fcb4 	bl	802224c <lv_label_refr_text>
}
 80218e4:	bf00      	nop
 80218e6:	3710      	adds	r7, #16
 80218e8:	46bd      	mov	sp, r7
 80218ea:	bd80      	pop	{r7, pc}
 80218ec:	08011167 	.word	0x08011167
 80218f0:	08011191 	.word	0x08011191
 80218f4:	0802284d 	.word	0x0802284d
 80218f8:	08022875 	.word	0x08022875

080218fc <lv_label_set_align>:
 * Set the align of the label (left or center)
 * @param label pointer to a label object
 * @param align 'LV_LABEL_ALIGN_LEFT' or 'LV_LABEL_ALIGN_LEFT'
 */
void lv_label_set_align(lv_obj_t * label, lv_label_align_t align)
{
 80218fc:	b580      	push	{r7, lr}
 80218fe:	b084      	sub	sp, #16
 8021900:	af00      	add	r7, sp, #0
 8021902:	6078      	str	r0, [r7, #4]
 8021904:	460b      	mov	r3, r1
 8021906:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021908:	6878      	ldr	r0, [r7, #4]
 802190a:	f7f0 fd92 	bl	8012432 <lv_obj_get_ext_attr>
 802190e:	60f8      	str	r0, [r7, #12]
    if(ext->align == align) return;
 8021910:	68fb      	ldr	r3, [r7, #12]
 8021912:	7f9b      	ldrb	r3, [r3, #30]
 8021914:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8021918:	b2db      	uxtb	r3, r3
 802191a:	461a      	mov	r2, r3
 802191c:	78fb      	ldrb	r3, [r7, #3]
 802191e:	429a      	cmp	r2, r3
 8021920:	d00c      	beq.n	802193c <lv_label_set_align+0x40>

    ext->align = align;
 8021922:	78fb      	ldrb	r3, [r7, #3]
 8021924:	f003 0303 	and.w	r3, r3, #3
 8021928:	b2d9      	uxtb	r1, r3
 802192a:	68fa      	ldr	r2, [r7, #12]
 802192c:	7f93      	ldrb	r3, [r2, #30]
 802192e:	f361 1305 	bfi	r3, r1, #4, #2
 8021932:	7793      	strb	r3, [r2, #30]

    lv_obj_invalidate(label); /*Enough to invalidate because alignment is only drawing related
 8021934:	6878      	ldr	r0, [r7, #4]
 8021936:	f7ef fa7a 	bl	8010e2e <lv_obj_invalidate>
 802193a:	e000      	b.n	802193e <lv_label_set_align+0x42>
    if(ext->align == align) return;
 802193c:	bf00      	nop
                                 (lv_refr_label_text() not required)*/
}
 802193e:	3710      	adds	r7, #16
 8021940:	46bd      	mov	sp, r7
 8021942:	bd80      	pop	{r7, pc}

08021944 <lv_label_set_recolor>:
 * Enable the recoloring by in-line commands
 * @param label pointer to a label object
 * @param en true: enable recoloring, false: disable
 */
void lv_label_set_recolor(lv_obj_t * label, bool en)
{
 8021944:	b580      	push	{r7, lr}
 8021946:	b084      	sub	sp, #16
 8021948:	af00      	add	r7, sp, #0
 802194a:	6078      	str	r0, [r7, #4]
 802194c:	460b      	mov	r3, r1
 802194e:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021950:	6878      	ldr	r0, [r7, #4]
 8021952:	f7f0 fd6e 	bl	8012432 <lv_obj_get_ext_attr>
 8021956:	60f8      	str	r0, [r7, #12]
    if(ext->recolor == en) return;
 8021958:	68fb      	ldr	r3, [r7, #12]
 802195a:	7f9b      	ldrb	r3, [r3, #30]
 802195c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 8021960:	b2db      	uxtb	r3, r3
 8021962:	78fa      	ldrb	r2, [r7, #3]
 8021964:	429a      	cmp	r2, r3
 8021966:	d011      	beq.n	802198c <lv_label_set_recolor+0x48>

    ext->recolor = en == false ? 0 : 1;
 8021968:	78fb      	ldrb	r3, [r7, #3]
 802196a:	f083 0301 	eor.w	r3, r3, #1
 802196e:	b2db      	uxtb	r3, r3
 8021970:	2b00      	cmp	r3, #0
 8021972:	d001      	beq.n	8021978 <lv_label_set_recolor+0x34>
 8021974:	2100      	movs	r1, #0
 8021976:	e000      	b.n	802197a <lv_label_set_recolor+0x36>
 8021978:	2101      	movs	r1, #1
 802197a:	68fa      	ldr	r2, [r7, #12]
 802197c:	7f93      	ldrb	r3, [r2, #30]
 802197e:	f361 1386 	bfi	r3, r1, #6, #1
 8021982:	7793      	strb	r3, [r2, #30]

    lv_label_refr_text(label); /*Refresh the text because the potential colo codes in text needs to
 8021984:	6878      	ldr	r0, [r7, #4]
 8021986:	f000 fc61 	bl	802224c <lv_label_refr_text>
 802198a:	e000      	b.n	802198e <lv_label_set_recolor+0x4a>
    if(ext->recolor == en) return;
 802198c:	bf00      	nop
                                  be hided or revealed*/
}
 802198e:	3710      	adds	r7, #16
 8021990:	46bd      	mov	sp, r7
 8021992:	bd80      	pop	{r7, pc}

08021994 <lv_label_set_body_draw>:
 * Set the label to draw (or not draw) background specified in its style's body
 * @param label pointer to a label object
 * @param en true: draw body; false: don't draw body
 */
void lv_label_set_body_draw(lv_obj_t * label, bool en)
{
 8021994:	b580      	push	{r7, lr}
 8021996:	b084      	sub	sp, #16
 8021998:	af00      	add	r7, sp, #0
 802199a:	6078      	str	r0, [r7, #4]
 802199c:	460b      	mov	r3, r1
 802199e:	70fb      	strb	r3, [r7, #3]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80219a0:	6878      	ldr	r0, [r7, #4]
 80219a2:	f7f0 fd46 	bl	8012432 <lv_obj_get_ext_attr>
 80219a6:	60f8      	str	r0, [r7, #12]
    if(ext->body_draw == en) return;
 80219a8:	68fb      	ldr	r3, [r7, #12]
 80219aa:	7fdb      	ldrb	r3, [r3, #31]
 80219ac:	f3c3 0300 	ubfx	r3, r3, #0, #1
 80219b0:	b2db      	uxtb	r3, r3
 80219b2:	78fa      	ldrb	r2, [r7, #3]
 80219b4:	429a      	cmp	r2, r3
 80219b6:	d014      	beq.n	80219e2 <lv_label_set_body_draw+0x4e>

    ext->body_draw = en == false ? 0 : 1;
 80219b8:	78fb      	ldrb	r3, [r7, #3]
 80219ba:	f083 0301 	eor.w	r3, r3, #1
 80219be:	b2db      	uxtb	r3, r3
 80219c0:	2b00      	cmp	r3, #0
 80219c2:	d001      	beq.n	80219c8 <lv_label_set_body_draw+0x34>
 80219c4:	2100      	movs	r1, #0
 80219c6:	e000      	b.n	80219ca <lv_label_set_body_draw+0x36>
 80219c8:	2101      	movs	r1, #1
 80219ca:	68fa      	ldr	r2, [r7, #12]
 80219cc:	7fd3      	ldrb	r3, [r2, #31]
 80219ce:	f361 0300 	bfi	r3, r1, #0, #1
 80219d2:	77d3      	strb	r3, [r2, #31]

    lv_obj_refresh_ext_draw_pad(label);
 80219d4:	6878      	ldr	r0, [r7, #4]
 80219d6:	f7f0 fb05 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>

    lv_obj_invalidate(label);
 80219da:	6878      	ldr	r0, [r7, #4]
 80219dc:	f7ef fa27 	bl	8010e2e <lv_obj_invalidate>
 80219e0:	e000      	b.n	80219e4 <lv_label_set_body_draw+0x50>
    if(ext->body_draw == en) return;
 80219e2:	bf00      	nop
}
 80219e4:	3710      	adds	r7, #16
 80219e6:	46bd      	mov	sp, r7
 80219e8:	bd80      	pop	{r7, pc}

080219ea <lv_label_get_text>:
 * Get the text of a label
 * @param label pointer to a label object
 * @return the text of the label
 */
char * lv_label_get_text(const lv_obj_t * label)
{
 80219ea:	b580      	push	{r7, lr}
 80219ec:	b084      	sub	sp, #16
 80219ee:	af00      	add	r7, sp, #0
 80219f0:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80219f2:	6878      	ldr	r0, [r7, #4]
 80219f4:	f7f0 fd1d 	bl	8012432 <lv_obj_get_ext_attr>
 80219f8:	60f8      	str	r0, [r7, #12]

    return ext->text;
 80219fa:	68fb      	ldr	r3, [r7, #12]
 80219fc:	681b      	ldr	r3, [r3, #0]
}
 80219fe:	4618      	mov	r0, r3
 8021a00:	3710      	adds	r7, #16
 8021a02:	46bd      	mov	sp, r7
 8021a04:	bd80      	pop	{r7, pc}

08021a06 <lv_label_get_long_mode>:
 * Get the long mode of a label
 * @param label pointer to a label object
 * @return the long mode
 */
lv_label_long_mode_t lv_label_get_long_mode(const lv_obj_t * label)
{
 8021a06:	b580      	push	{r7, lr}
 8021a08:	b084      	sub	sp, #16
 8021a0a:	af00      	add	r7, sp, #0
 8021a0c:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021a0e:	6878      	ldr	r0, [r7, #4]
 8021a10:	f7f0 fd0f 	bl	8012432 <lv_obj_get_ext_attr>
 8021a14:	60f8      	str	r0, [r7, #12]
    return ext->long_mode;
 8021a16:	68fb      	ldr	r3, [r7, #12]
 8021a18:	7f9b      	ldrb	r3, [r3, #30]
 8021a1a:	f3c3 0302 	ubfx	r3, r3, #0, #3
 8021a1e:	b2db      	uxtb	r3, r3
}
 8021a20:	4618      	mov	r0, r3
 8021a22:	3710      	adds	r7, #16
 8021a24:	46bd      	mov	sp, r7
 8021a26:	bd80      	pop	{r7, pc}

08021a28 <lv_label_get_align>:
 * Get the align attribute
 * @param label pointer to a label object
 * @return LV_LABEL_ALIGN_LEFT or LV_LABEL_ALIGN_CENTER
 */
lv_label_align_t lv_label_get_align(const lv_obj_t * label)
{
 8021a28:	b580      	push	{r7, lr}
 8021a2a:	b084      	sub	sp, #16
 8021a2c:	af00      	add	r7, sp, #0
 8021a2e:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021a30:	6878      	ldr	r0, [r7, #4]
 8021a32:	f7f0 fcfe 	bl	8012432 <lv_obj_get_ext_attr>
 8021a36:	60f8      	str	r0, [r7, #12]
    return ext->align;
 8021a38:	68fb      	ldr	r3, [r7, #12]
 8021a3a:	7f9b      	ldrb	r3, [r3, #30]
 8021a3c:	f3c3 1301 	ubfx	r3, r3, #4, #2
 8021a40:	b2db      	uxtb	r3, r3
}
 8021a42:	4618      	mov	r0, r3
 8021a44:	3710      	adds	r7, #16
 8021a46:	46bd      	mov	sp, r7
 8021a48:	bd80      	pop	{r7, pc}

08021a4a <lv_label_get_recolor>:
 * Get the recoloring attribute
 * @param label pointer to a label object
 * @return true: recoloring is enabled, false: disable
 */
bool lv_label_get_recolor(const lv_obj_t * label)
{
 8021a4a:	b580      	push	{r7, lr}
 8021a4c:	b084      	sub	sp, #16
 8021a4e:	af00      	add	r7, sp, #0
 8021a50:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021a52:	6878      	ldr	r0, [r7, #4]
 8021a54:	f7f0 fced 	bl	8012432 <lv_obj_get_ext_attr>
 8021a58:	60f8      	str	r0, [r7, #12]
    return ext->recolor == 0 ? false : true;
 8021a5a:	68fb      	ldr	r3, [r7, #12]
 8021a5c:	7f9b      	ldrb	r3, [r3, #30]
 8021a5e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8021a62:	b2db      	uxtb	r3, r3
 8021a64:	2b00      	cmp	r3, #0
 8021a66:	bf14      	ite	ne
 8021a68:	2301      	movne	r3, #1
 8021a6a:	2300      	moveq	r3, #0
 8021a6c:	b2db      	uxtb	r3, r3
}
 8021a6e:	4618      	mov	r0, r3
 8021a70:	3710      	adds	r7, #16
 8021a72:	46bd      	mov	sp, r7
 8021a74:	bd80      	pop	{r7, pc}

08021a76 <lv_label_get_body_draw>:
 * Get the body draw attribute
 * @param label pointer to a label object
 * @return true: draw body; false: don't draw body
 */
bool lv_label_get_body_draw(const lv_obj_t * label)
{
 8021a76:	b580      	push	{r7, lr}
 8021a78:	b084      	sub	sp, #16
 8021a7a:	af00      	add	r7, sp, #0
 8021a7c:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021a7e:	6878      	ldr	r0, [r7, #4]
 8021a80:	f7f0 fcd7 	bl	8012432 <lv_obj_get_ext_attr>
 8021a84:	60f8      	str	r0, [r7, #12]
    return ext->body_draw == 0 ? false : true;
 8021a86:	68fb      	ldr	r3, [r7, #12]
 8021a88:	7fdb      	ldrb	r3, [r3, #31]
 8021a8a:	f003 0301 	and.w	r3, r3, #1
 8021a8e:	b2db      	uxtb	r3, r3
 8021a90:	2b00      	cmp	r3, #0
 8021a92:	bf14      	ite	ne
 8021a94:	2301      	movne	r3, #1
 8021a96:	2300      	moveq	r3, #0
 8021a98:	b2db      	uxtb	r3, r3
}
 8021a9a:	4618      	mov	r0, r3
 8021a9c:	3710      	adds	r7, #16
 8021a9e:	46bd      	mov	sp, r7
 8021aa0:	bd80      	pop	{r7, pc}
	...

08021aa4 <lv_label_get_letter_on>:
 * @param pos pointer to point with coordinates on a the label
 * @return the index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter)
 * Expressed in character index and not byte index (different in UTF-8)
 */
uint16_t lv_label_get_letter_on(const lv_obj_t * label, lv_point_t * pos)
{
 8021aa4:	b580      	push	{r7, lr}
 8021aa6:	b092      	sub	sp, #72	; 0x48
 8021aa8:	af02      	add	r7, sp, #8
 8021aaa:	6078      	str	r0, [r7, #4]
 8021aac:	6039      	str	r1, [r7, #0]
    const char * txt         = lv_label_get_text(label);
 8021aae:	6878      	ldr	r0, [r7, #4]
 8021ab0:	f7ff ff9b 	bl	80219ea <lv_label_get_text>
 8021ab4:	62b8      	str	r0, [r7, #40]	; 0x28
    lv_label_ext_t * ext     = lv_obj_get_ext_attr(label);
 8021ab6:	6878      	ldr	r0, [r7, #4]
 8021ab8:	f7f0 fcbb 	bl	8012432 <lv_obj_get_ext_attr>
 8021abc:	6278      	str	r0, [r7, #36]	; 0x24
    uint32_t line_start      = 0;
 8021abe:	2300      	movs	r3, #0
 8021ac0:	63fb      	str	r3, [r7, #60]	; 0x3c
    uint32_t new_line_start  = 0;
 8021ac2:	2300      	movs	r3, #0
 8021ac4:	63bb      	str	r3, [r7, #56]	; 0x38
    lv_coord_t max_w         = lv_obj_get_width(label);
 8021ac6:	6878      	ldr	r0, [r7, #4]
 8021ac8:	f7f0 fb64 	bl	8012194 <lv_obj_get_width>
 8021acc:	4603      	mov	r3, r0
 8021ace:	86fb      	strh	r3, [r7, #54]	; 0x36
    const lv_style_t * style = lv_obj_get_style(label);
 8021ad0:	6878      	ldr	r0, [r7, #4]
 8021ad2:	f7f0 fb8f 	bl	80121f4 <lv_obj_get_style>
 8021ad6:	6238      	str	r0, [r7, #32]
    const lv_font_t * font   = style->text.font;
 8021ad8:	6a3b      	ldr	r3, [r7, #32]
 8021ada:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021adc:	61fb      	str	r3, [r7, #28]
    uint8_t letter_height    = lv_font_get_line_height(font);
 8021ade:	69f8      	ldr	r0, [r7, #28]
 8021ae0:	f7ff fc65 	bl	80213ae <lv_font_get_line_height>
 8021ae4:	4603      	mov	r3, r0
 8021ae6:	76fb      	strb	r3, [r7, #27]
    lv_coord_t y             = 0;
 8021ae8:	2300      	movs	r3, #0
 8021aea:	86bb      	strh	r3, [r7, #52]	; 0x34
    lv_txt_flag_t flag       = LV_TXT_FLAG_NONE;
 8021aec:	2300      	movs	r3, #0
 8021aee:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 8021af2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021af4:	7f9b      	ldrb	r3, [r3, #30]
 8021af6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8021afa:	b2db      	uxtb	r3, r3
 8021afc:	2b00      	cmp	r3, #0
 8021afe:	d005      	beq.n	8021b0c <lv_label_get_letter_on+0x68>
 8021b00:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021b04:	f043 0301 	orr.w	r3, r3, #1
 8021b08:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 8021b0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021b0e:	7f9b      	ldrb	r3, [r3, #30]
 8021b10:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8021b14:	b2db      	uxtb	r3, r3
 8021b16:	2b00      	cmp	r3, #0
 8021b18:	d005      	beq.n	8021b26 <lv_label_get_letter_on+0x82>
 8021b1a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021b1e:	f043 0302 	orr.w	r3, r3, #2
 8021b22:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
    if(ext->align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 8021b26:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021b28:	7f9b      	ldrb	r3, [r3, #30]
 8021b2a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8021b2e:	b2db      	uxtb	r3, r3
 8021b30:	2b10      	cmp	r3, #16
 8021b32:	d105      	bne.n	8021b40 <lv_label_get_letter_on+0x9c>
 8021b34:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021b38:	f043 0304 	orr.w	r3, r3, #4
 8021b3c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33

    /*If the width will be expanded set the max length to very big */
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 8021b40:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021b42:	7f9b      	ldrb	r3, [r3, #30]
 8021b44:	f003 0307 	and.w	r3, r3, #7
 8021b48:	b2db      	uxtb	r3, r3
 8021b4a:	2b00      	cmp	r3, #0
 8021b4c:	d12f      	bne.n	8021bae <lv_label_get_letter_on+0x10a>
        max_w = LV_COORD_MAX;
 8021b4e:	f647 4318 	movw	r3, #31768	; 0x7c18
 8021b52:	86fb      	strh	r3, [r7, #54]	; 0x36
    }

    /*Search the line of the index letter */;
    while(txt[line_start] != '\0') {
 8021b54:	e02b      	b.n	8021bae <lv_label_get_letter_on+0x10a>
        new_line_start += lv_txt_get_next_line(&txt[line_start], font, style->text.letter_space, max_w, flag);
 8021b56:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8021b58:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021b5a:	18d0      	adds	r0, r2, r3
 8021b5c:	6a3b      	ldr	r3, [r7, #32]
 8021b5e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8021b62:	f9b7 1036 	ldrsh.w	r1, [r7, #54]	; 0x36
 8021b66:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021b6a:	9300      	str	r3, [sp, #0]
 8021b6c:	460b      	mov	r3, r1
 8021b6e:	69f9      	ldr	r1, [r7, #28]
 8021b70:	f7fb fb9a 	bl	801d2a8 <lv_txt_get_next_line>
 8021b74:	4603      	mov	r3, r0
 8021b76:	461a      	mov	r2, r3
 8021b78:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021b7a:	4413      	add	r3, r2
 8021b7c:	63bb      	str	r3, [r7, #56]	; 0x38

        if(pos->y <= y + letter_height) break; /*The line is found (stored in 'line_start')*/
 8021b7e:	683b      	ldr	r3, [r7, #0]
 8021b80:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8021b84:	4619      	mov	r1, r3
 8021b86:	f9b7 2034 	ldrsh.w	r2, [r7, #52]	; 0x34
 8021b8a:	7efb      	ldrb	r3, [r7, #27]
 8021b8c:	4413      	add	r3, r2
 8021b8e:	4299      	cmp	r1, r3
 8021b90:	dd14      	ble.n	8021bbc <lv_label_get_letter_on+0x118>
        y += letter_height + style->text.line_space;
 8021b92:	7efb      	ldrb	r3, [r7, #27]
 8021b94:	b29a      	uxth	r2, r3
 8021b96:	6a3b      	ldr	r3, [r7, #32]
 8021b98:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8021b9c:	b29b      	uxth	r3, r3
 8021b9e:	4413      	add	r3, r2
 8021ba0:	b29a      	uxth	r2, r3
 8021ba2:	8ebb      	ldrh	r3, [r7, #52]	; 0x34
 8021ba4:	4413      	add	r3, r2
 8021ba6:	b29b      	uxth	r3, r3
 8021ba8:	86bb      	strh	r3, [r7, #52]	; 0x34

        line_start = new_line_start;
 8021baa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021bac:	63fb      	str	r3, [r7, #60]	; 0x3c
    while(txt[line_start] != '\0') {
 8021bae:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8021bb0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021bb2:	4413      	add	r3, r2
 8021bb4:	781b      	ldrb	r3, [r3, #0]
 8021bb6:	2b00      	cmp	r3, #0
 8021bb8:	d1cd      	bne.n	8021b56 <lv_label_get_letter_on+0xb2>
 8021bba:	e000      	b.n	8021bbe <lv_label_get_letter_on+0x11a>
        if(pos->y <= y + letter_height) break; /*The line is found (stored in 'line_start')*/
 8021bbc:	bf00      	nop
    }

    /*Calculate the x coordinate*/
    lv_coord_t x = 0;
 8021bbe:	2300      	movs	r3, #0
 8021bc0:	863b      	strh	r3, [r7, #48]	; 0x30
    if(ext->align == LV_LABEL_ALIGN_CENTER) {
 8021bc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8021bc4:	7f9b      	ldrb	r3, [r3, #30]
 8021bc6:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8021bca:	b2db      	uxtb	r3, r3
 8021bcc:	2b10      	cmp	r3, #16
 8021bce:	d12b      	bne.n	8021c28 <lv_label_get_letter_on+0x184>
        lv_coord_t line_w;
        line_w = lv_txt_get_width(&txt[line_start], new_line_start - line_start, font, style->text.letter_space, flag);
 8021bd0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8021bd2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021bd4:	18d0      	adds	r0, r2, r3
 8021bd6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021bd8:	b29a      	uxth	r2, r3
 8021bda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021bdc:	b29b      	uxth	r3, r3
 8021bde:	1ad3      	subs	r3, r2, r3
 8021be0:	b299      	uxth	r1, r3
 8021be2:	6a3b      	ldr	r3, [r7, #32]
 8021be4:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
 8021be8:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021bec:	9300      	str	r3, [sp, #0]
 8021bee:	4613      	mov	r3, r2
 8021bf0:	69fa      	ldr	r2, [r7, #28]
 8021bf2:	f7fb fc0b 	bl	801d40c <lv_txt_get_width>
 8021bf6:	4603      	mov	r3, r0
 8021bf8:	833b      	strh	r3, [r7, #24]
        x += lv_obj_get_width(label) / 2 - line_w / 2;
 8021bfa:	6878      	ldr	r0, [r7, #4]
 8021bfc:	f7f0 faca 	bl	8012194 <lv_obj_get_width>
 8021c00:	4603      	mov	r3, r0
 8021c02:	2b00      	cmp	r3, #0
 8021c04:	da00      	bge.n	8021c08 <lv_label_get_letter_on+0x164>
 8021c06:	3301      	adds	r3, #1
 8021c08:	105b      	asrs	r3, r3, #1
 8021c0a:	b21b      	sxth	r3, r3
 8021c0c:	461a      	mov	r2, r3
 8021c0e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8021c12:	2b00      	cmp	r3, #0
 8021c14:	da00      	bge.n	8021c18 <lv_label_get_letter_on+0x174>
 8021c16:	3301      	adds	r3, #1
 8021c18:	105b      	asrs	r3, r3, #1
 8021c1a:	b21b      	sxth	r3, r3
 8021c1c:	1ad3      	subs	r3, r2, r3
 8021c1e:	b29a      	uxth	r2, r3
 8021c20:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8021c22:	4413      	add	r3, r2
 8021c24:	b29b      	uxth	r3, r3
 8021c26:	863b      	strh	r3, [r7, #48]	; 0x30
    }

    lv_txt_cmd_state_t cmd_state = LV_TXT_CMD_STATE_WAIT;
 8021c28:	2300      	movs	r3, #0
 8021c2a:	73fb      	strb	r3, [r7, #15]

    uint32_t i         = line_start;
 8021c2c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021c2e:	60bb      	str	r3, [r7, #8]
    uint32_t i_current = i;
 8021c30:	68bb      	ldr	r3, [r7, #8]
 8021c32:	62fb      	str	r3, [r7, #44]	; 0x2c
    uint32_t letter;
    uint32_t letter_next;

    if(new_line_start > 0) {
 8021c34:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021c36:	2b00      	cmp	r3, #0
 8021c38:	d04a      	beq.n	8021cd0 <lv_label_get_letter_on+0x22c>
        while(i <= new_line_start - 1) {
 8021c3a:	e044      	b.n	8021cc6 <lv_label_get_letter_on+0x222>
            /* Get the current letter.
             * Be careful 'i' already points to the next character*/
            letter = lv_txt_encoded_next(txt, &i);
 8021c3c:	4b2a      	ldr	r3, [pc, #168]	; (8021ce8 <lv_label_get_letter_on+0x244>)
 8021c3e:	681b      	ldr	r3, [r3, #0]
 8021c40:	f107 0208 	add.w	r2, r7, #8
 8021c44:	4611      	mov	r1, r2
 8021c46:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8021c48:	4798      	blx	r3
 8021c4a:	6178      	str	r0, [r7, #20]

            /*Get the next letter too for kerning*/
            letter_next = lv_txt_encoded_next(&txt[i], NULL);
 8021c4c:	4b26      	ldr	r3, [pc, #152]	; (8021ce8 <lv_label_get_letter_on+0x244>)
 8021c4e:	681b      	ldr	r3, [r3, #0]
 8021c50:	68ba      	ldr	r2, [r7, #8]
 8021c52:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 8021c54:	440a      	add	r2, r1
 8021c56:	2100      	movs	r1, #0
 8021c58:	4610      	mov	r0, r2
 8021c5a:	4798      	blx	r3
 8021c5c:	6138      	str	r0, [r7, #16]

            /*Handle the recolor command*/
            if((flag & LV_TXT_FLAG_RECOLOR) != 0) {
 8021c5e:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8021c62:	f003 0301 	and.w	r3, r3, #1
 8021c66:	2b00      	cmp	r3, #0
 8021c68:	d00e      	beq.n	8021c88 <lv_label_get_letter_on+0x1e4>
                if(lv_txt_is_cmd(&cmd_state, txt[i]) != false) {
 8021c6a:	68bb      	ldr	r3, [r7, #8]
 8021c6c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8021c6e:	4413      	add	r3, r2
 8021c70:	781b      	ldrb	r3, [r3, #0]
 8021c72:	461a      	mov	r2, r3
 8021c74:	f107 030f 	add.w	r3, r7, #15
 8021c78:	4611      	mov	r1, r2
 8021c7a:	4618      	mov	r0, r3
 8021c7c:	f7fb fc30 	bl	801d4e0 <lv_txt_is_cmd>
 8021c80:	4603      	mov	r3, r0
 8021c82:	2b00      	cmp	r3, #0
 8021c84:	d000      	beq.n	8021c88 <lv_label_get_letter_on+0x1e4>
                    continue; /*Skip the letter is it is part of a command*/
 8021c86:	e01e      	b.n	8021cc6 <lv_label_get_letter_on+0x222>
                }
            }

            x += lv_font_get_glyph_width(font, letter, letter_next);
 8021c88:	693a      	ldr	r2, [r7, #16]
 8021c8a:	6979      	ldr	r1, [r7, #20]
 8021c8c:	69f8      	ldr	r0, [r7, #28]
 8021c8e:	f7f8 fe33 	bl	801a8f8 <lv_font_get_glyph_width>
 8021c92:	4603      	mov	r3, r0
 8021c94:	461a      	mov	r2, r3
 8021c96:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8021c98:	4413      	add	r3, r2
 8021c9a:	b29b      	uxth	r3, r3
 8021c9c:	863b      	strh	r3, [r7, #48]	; 0x30
            if(pos->x < x) {
 8021c9e:	683b      	ldr	r3, [r7, #0]
 8021ca0:	f9b3 3000 	ldrsh.w	r3, [r3]
 8021ca4:	f9b7 2030 	ldrsh.w	r2, [r7, #48]	; 0x30
 8021ca8:	429a      	cmp	r2, r3
 8021caa:	dd02      	ble.n	8021cb2 <lv_label_get_letter_on+0x20e>
                i = i_current;
 8021cac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8021cae:	60bb      	str	r3, [r7, #8]
                break;
 8021cb0:	e00e      	b.n	8021cd0 <lv_label_get_letter_on+0x22c>
            }
            x += style->text.letter_space;
 8021cb2:	6a3b      	ldr	r3, [r7, #32]
 8021cb4:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8021cb8:	b29a      	uxth	r2, r3
 8021cba:	8e3b      	ldrh	r3, [r7, #48]	; 0x30
 8021cbc:	4413      	add	r3, r2
 8021cbe:	b29b      	uxth	r3, r3
 8021cc0:	863b      	strh	r3, [r7, #48]	; 0x30
            i_current = i;
 8021cc2:	68bb      	ldr	r3, [r7, #8]
 8021cc4:	62fb      	str	r3, [r7, #44]	; 0x2c
        while(i <= new_line_start - 1) {
 8021cc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8021cc8:	1e5a      	subs	r2, r3, #1
 8021cca:	68bb      	ldr	r3, [r7, #8]
 8021ccc:	429a      	cmp	r2, r3
 8021cce:	d2b5      	bcs.n	8021c3c <lv_label_get_letter_on+0x198>
        }
    }

    return lv_encoded_get_char_id(txt, i);
 8021cd0:	4b06      	ldr	r3, [pc, #24]	; (8021cec <lv_label_get_letter_on+0x248>)
 8021cd2:	681b      	ldr	r3, [r3, #0]
 8021cd4:	68ba      	ldr	r2, [r7, #8]
 8021cd6:	4611      	mov	r1, r2
 8021cd8:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8021cda:	4798      	blx	r3
 8021cdc:	4603      	mov	r3, r0
 8021cde:	b29b      	uxth	r3, r3
}
 8021ce0:	4618      	mov	r0, r3
 8021ce2:	3740      	adds	r7, #64	; 0x40
 8021ce4:	46bd      	mov	sp, r7
 8021ce6:	bd80      	pop	{r7, pc}
 8021ce8:	20000c34 	.word	0x20000c34
 8021cec:	20000c40 	.word	0x20000c40

08021cf0 <lv_label_get_text_sel_start>:
 * @brief Get the selection start index.
 * @param label pointer to a label object.
 * @return selection start index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint16_t lv_label_get_text_sel_start(const lv_obj_t * label)
{
 8021cf0:	b480      	push	{r7}
 8021cf2:	b083      	sub	sp, #12
 8021cf4:	af00      	add	r7, sp, #0
 8021cf6:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->txt_sel_start;

#else
    (void)label;    /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 8021cf8:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 8021cfc:	4618      	mov	r0, r3
 8021cfe:	370c      	adds	r7, #12
 8021d00:	46bd      	mov	sp, r7
 8021d02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d06:	4770      	bx	lr

08021d08 <lv_label_get_text_sel_end>:
 * @brief Get the selection end index.
 * @param label pointer to a label object.
 * @return selection end index. `LV_LABEL_TXT_SEL_OFF` if nothing is selected.
 */
uint16_t lv_label_get_text_sel_end(const lv_obj_t * label)
{
 8021d08:	b480      	push	{r7}
 8021d0a:	b083      	sub	sp, #12
 8021d0c:	af00      	add	r7, sp, #0
 8021d0e:	6078      	str	r0, [r7, #4]
#if LV_LABEL_TEXT_SEL
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
    return ext->txt_sel_end;
#else
    (void)label; /*Unused*/
    return LV_LABEL_TEXT_SEL_OFF;
 8021d10:	f64f 73ff 	movw	r3, #65535	; 0xffff
#endif
}
 8021d14:	4618      	mov	r0, r3
 8021d16:	370c      	adds	r7, #12
 8021d18:	46bd      	mov	sp, r7
 8021d1a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8021d1e:	4770      	bx	lr

08021d20 <lv_label_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_label_design(lv_obj_t * label, const lv_area_t * mask, lv_design_mode_t mode)
{
 8021d20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8021d22:	b099      	sub	sp, #100	; 0x64
 8021d24:	af06      	add	r7, sp, #24
 8021d26:	60f8      	str	r0, [r7, #12]
 8021d28:	60b9      	str	r1, [r7, #8]
 8021d2a:	4613      	mov	r3, r2
 8021d2c:	71fb      	strb	r3, [r7, #7]
    /* A label never covers an area */
    if(mode == LV_DESIGN_COVER_CHK)
 8021d2e:	79fb      	ldrb	r3, [r7, #7]
 8021d30:	2b02      	cmp	r3, #2
 8021d32:	d101      	bne.n	8021d38 <lv_label_design+0x18>
        return false;
 8021d34:	2300      	movs	r3, #0
 8021d36:	e1c4      	b.n	80220c2 <lv_label_design+0x3a2>
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 8021d38:	79fb      	ldrb	r3, [r7, #7]
 8021d3a:	2b00      	cmp	r3, #0
 8021d3c:	f040 81c0 	bne.w	80220c0 <lv_label_design+0x3a0>
        lv_area_t coords;
        const lv_style_t * style = lv_obj_get_style(label);
 8021d40:	68f8      	ldr	r0, [r7, #12]
 8021d42:	f7f0 fa57 	bl	80121f4 <lv_obj_get_style>
 8021d46:	63f8      	str	r0, [r7, #60]	; 0x3c
        lv_opa_t opa_scale       = lv_obj_get_opa_scale(label);
 8021d48:	68f8      	ldr	r0, [r7, #12]
 8021d4a:	f7f0 fb24 	bl	8012396 <lv_obj_get_opa_scale>
 8021d4e:	4603      	mov	r3, r0
 8021d50:	f887 303b 	strb.w	r3, [r7, #59]	; 0x3b
        lv_obj_get_coords(label, &coords);
 8021d54:	f107 0328 	add.w	r3, r7, #40	; 0x28
 8021d58:	4619      	mov	r1, r3
 8021d5a:	68f8      	ldr	r0, [r7, #12]
 8021d5c:	f7f0 f9d9 	bl	8012112 <lv_obj_get_coords>

#if LV_USE_GROUP
        lv_group_t * g = lv_obj_get_group(label);
 8021d60:	68f8      	ldr	r0, [r7, #12]
 8021d62:	f7f0 fb72 	bl	801244a <lv_obj_get_group>
 8021d66:	6378      	str	r0, [r7, #52]	; 0x34
        if(lv_group_get_focused(g) == label) {
 8021d68:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8021d6a:	f7ec fb77 	bl	800e45c <lv_group_get_focused>
 8021d6e:	4602      	mov	r2, r0
 8021d70:	68fb      	ldr	r3, [r7, #12]
 8021d72:	4293      	cmp	r3, r2
 8021d74:	d107      	bne.n	8021d86 <lv_label_design+0x66>
            lv_draw_rect(&coords, mask, style, opa_scale);
 8021d76:	f897 303b 	ldrb.w	r3, [r7, #59]	; 0x3b
 8021d7a:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8021d7e:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8021d80:	68b9      	ldr	r1, [r7, #8]
 8021d82:	f7f3 fdbe 	bl	8015902 <lv_draw_rect>
        }
#endif

        lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8021d86:	68f8      	ldr	r0, [r7, #12]
 8021d88:	f7f0 fb53 	bl	8012432 <lv_obj_get_ext_attr>
 8021d8c:	6338      	str	r0, [r7, #48]	; 0x30

        if(ext->body_draw) {
 8021d8e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021d90:	7fdb      	ldrb	r3, [r3, #31]
 8021d92:	f003 0301 	and.w	r3, r3, #1
 8021d96:	b2db      	uxtb	r3, r3
 8021d98:	2b00      	cmp	r3, #0
 8021d9a:	d03b      	beq.n	8021e14 <lv_label_design+0xf4>
            lv_area_t bg;
            lv_obj_get_coords(label, &bg);
 8021d9c:	f107 0320 	add.w	r3, r7, #32
 8021da0:	4619      	mov	r1, r3
 8021da2:	68f8      	ldr	r0, [r7, #12]
 8021da4:	f7f0 f9b5 	bl	8012112 <lv_obj_get_coords>
            bg.x1 -= style->body.padding.left;
 8021da8:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8021dac:	b29a      	uxth	r2, r3
 8021dae:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021db0:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8021db4:	b29b      	uxth	r3, r3
 8021db6:	1ad3      	subs	r3, r2, r3
 8021db8:	b29b      	uxth	r3, r3
 8021dba:	b21b      	sxth	r3, r3
 8021dbc:	843b      	strh	r3, [r7, #32]
            bg.x2 += style->body.padding.right;
 8021dbe:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8021dc2:	b29a      	uxth	r2, r3
 8021dc4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021dc6:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8021dca:	b29b      	uxth	r3, r3
 8021dcc:	4413      	add	r3, r2
 8021dce:	b29b      	uxth	r3, r3
 8021dd0:	b21b      	sxth	r3, r3
 8021dd2:	84bb      	strh	r3, [r7, #36]	; 0x24
            bg.y1 -= style->body.padding.top;
 8021dd4:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8021dd8:	b29a      	uxth	r2, r3
 8021dda:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021ddc:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8021de0:	b29b      	uxth	r3, r3
 8021de2:	1ad3      	subs	r3, r2, r3
 8021de4:	b29b      	uxth	r3, r3
 8021de6:	b21b      	sxth	r3, r3
 8021de8:	847b      	strh	r3, [r7, #34]	; 0x22
            bg.y2 += style->body.padding.bottom;
 8021dea:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8021dee:	b29a      	uxth	r2, r3
 8021df0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021df2:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8021df6:	b29b      	uxth	r3, r3
 8021df8:	4413      	add	r3, r2
 8021dfa:	b29b      	uxth	r3, r3
 8021dfc:	b21b      	sxth	r3, r3
 8021dfe:	84fb      	strh	r3, [r7, #38]	; 0x26

            lv_draw_rect(&bg, mask, style, lv_obj_get_opa_scale(label));
 8021e00:	68f8      	ldr	r0, [r7, #12]
 8021e02:	f7f0 fac8 	bl	8012396 <lv_obj_get_opa_scale>
 8021e06:	4603      	mov	r3, r0
 8021e08:	f107 0020 	add.w	r0, r7, #32
 8021e0c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8021e0e:	68b9      	ldr	r1, [r7, #8]
 8021e10:	f7f3 fd77 	bl	8015902 <lv_draw_rect>
        }

        /*TEST: draw a background for the label*/
        // lv_draw_rect(&label->coords, mask, &lv_style_plain_color, LV_OPA_COVER);

        lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 8021e14:	2300      	movs	r3, #0
 8021e16:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 8021e1a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021e1c:	7f9b      	ldrb	r3, [r3, #30]
 8021e1e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8021e22:	b2db      	uxtb	r3, r3
 8021e24:	2b00      	cmp	r3, #0
 8021e26:	d005      	beq.n	8021e34 <lv_label_design+0x114>
 8021e28:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021e2c:	f043 0301 	orr.w	r3, r3, #1
 8021e30:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 8021e34:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021e36:	7f9b      	ldrb	r3, [r3, #30]
 8021e38:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8021e3c:	b2db      	uxtb	r3, r3
 8021e3e:	2b00      	cmp	r3, #0
 8021e40:	d005      	beq.n	8021e4e <lv_label_design+0x12e>
 8021e42:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021e46:	f043 0302 	orr.w	r3, r3, #2
 8021e4a:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->align == LV_LABEL_ALIGN_CENTER) flag |= LV_TXT_FLAG_CENTER;
 8021e4e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021e50:	7f9b      	ldrb	r3, [r3, #30]
 8021e52:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8021e56:	b2db      	uxtb	r3, r3
 8021e58:	2b10      	cmp	r3, #16
 8021e5a:	d105      	bne.n	8021e68 <lv_label_design+0x148>
 8021e5c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021e60:	f043 0304 	orr.w	r3, r3, #4
 8021e64:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
        if(ext->align == LV_LABEL_ALIGN_RIGHT) flag |= LV_TXT_FLAG_RIGHT;
 8021e68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021e6a:	7f9b      	ldrb	r3, [r3, #30]
 8021e6c:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8021e70:	b2db      	uxtb	r3, r3
 8021e72:	2b20      	cmp	r3, #32
 8021e74:	d105      	bne.n	8021e82 <lv_label_design+0x162>
 8021e76:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021e7a:	f043 0308 	orr.w	r3, r3, #8
 8021e7e:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47

        /* In ROLL mode the CENTER and RIGHT are pointless so remove them.
         * (In addition they will result mis-alignment is this case)*/
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 8021e82:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021e84:	7f9b      	ldrb	r3, [r3, #30]
 8021e86:	f003 0307 	and.w	r3, r3, #7
 8021e8a:	b2db      	uxtb	r3, r3
 8021e8c:	2b03      	cmp	r3, #3
 8021e8e:	d006      	beq.n	8021e9e <lv_label_design+0x17e>
 8021e90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021e92:	7f9b      	ldrb	r3, [r3, #30]
 8021e94:	f003 0307 	and.w	r3, r3, #7
 8021e98:	b2db      	uxtb	r3, r3
 8021e9a:	2b04      	cmp	r3, #4
 8021e9c:	d138      	bne.n	8021f10 <lv_label_design+0x1f0>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 8021e9e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021ea0:	7f9b      	ldrb	r3, [r3, #30]
 8021ea2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8021ea6:	b2db      	uxtb	r3, r3
        if((ext->long_mode == LV_LABEL_LONG_SROLL || ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) &&
 8021ea8:	2b10      	cmp	r3, #16
 8021eaa:	d006      	beq.n	8021eba <lv_label_design+0x19a>
           (ext->align == LV_LABEL_ALIGN_CENTER || ext->align == LV_LABEL_ALIGN_RIGHT)) {
 8021eac:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021eae:	7f9b      	ldrb	r3, [r3, #30]
 8021eb0:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8021eb4:	b2db      	uxtb	r3, r3
 8021eb6:	2b20      	cmp	r3, #32
 8021eb8:	d12a      	bne.n	8021f10 <lv_label_design+0x1f0>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
 8021eba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021ebc:	6819      	ldr	r1, [r3, #0]
 8021ebe:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021ec0:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8021ec2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021ec4:	f9b3 5028 	ldrsh.w	r5, [r3, #40]	; 0x28
 8021ec8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021eca:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8021ece:	f107 001c 	add.w	r0, r7, #28
 8021ed2:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 8021ed6:	9202      	str	r2, [sp, #8]
 8021ed8:	f647 4218 	movw	r2, #31768	; 0x7c18
 8021edc:	9201      	str	r2, [sp, #4]
 8021ede:	9300      	str	r3, [sp, #0]
 8021ee0:	462b      	mov	r3, r5
 8021ee2:	4622      	mov	r2, r4
 8021ee4:	f7fb f92e 	bl	801d144 <lv_txt_get_size>
                            LV_COORD_MAX, flag);
            if(size.x > lv_obj_get_width(label)) {
 8021ee8:	f9b7 401c 	ldrsh.w	r4, [r7, #28]
 8021eec:	68f8      	ldr	r0, [r7, #12]
 8021eee:	f7f0 f951 	bl	8012194 <lv_obj_get_width>
 8021ef2:	4603      	mov	r3, r0
 8021ef4:	429c      	cmp	r4, r3
 8021ef6:	dd0b      	ble.n	8021f10 <lv_label_design+0x1f0>
                flag &= ~LV_TXT_FLAG_RIGHT;
 8021ef8:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021efc:	f023 0308 	bic.w	r3, r3, #8
 8021f00:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
                flag &= ~LV_TXT_FLAG_CENTER;
 8021f04:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021f08:	f023 0304 	bic.w	r3, r3, #4
 8021f0c:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            }
        }

        lv_draw_label_hint_t * hint = &ext->hint;
 8021f10:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021f12:	3310      	adds	r3, #16
 8021f14:	643b      	str	r3, [r7, #64]	; 0x40
        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC || lv_obj_get_height(label) < LV_LABEL_HINT_HEIGHT_LIMIT)
 8021f16:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021f18:	7f9b      	ldrb	r3, [r3, #30]
 8021f1a:	f003 0307 	and.w	r3, r3, #7
 8021f1e:	b2db      	uxtb	r3, r3
 8021f20:	2b04      	cmp	r3, #4
 8021f22:	d006      	beq.n	8021f32 <lv_label_design+0x212>
 8021f24:	68f8      	ldr	r0, [r7, #12]
 8021f26:	f7f0 f943 	bl	80121b0 <lv_obj_get_height>
 8021f2a:	4603      	mov	r3, r0
 8021f2c:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8021f30:	da01      	bge.n	8021f36 <lv_label_design+0x216>
            hint = NULL;
 8021f32:	2300      	movs	r3, #0
 8021f34:	643b      	str	r3, [r7, #64]	; 0x40

        lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ext->offset,
 8021f36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021f38:	681c      	ldr	r4, [r3, #0]
 8021f3a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021f3c:	f103 050a 	add.w	r5, r3, #10
 8021f40:	68f8      	ldr	r0, [r7, #12]
 8021f42:	f7ff fed5 	bl	8021cf0 <lv_label_get_text_sel_start>
 8021f46:	4603      	mov	r3, r0
 8021f48:	461e      	mov	r6, r3
 8021f4a:	68f8      	ldr	r0, [r7, #12]
 8021f4c:	f7ff fedc 	bl	8021d08 <lv_label_get_text_sel_end>
 8021f50:	4603      	mov	r3, r0
 8021f52:	4619      	mov	r1, r3
 8021f54:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 8021f58:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8021f5c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8021f5e:	9305      	str	r3, [sp, #20]
 8021f60:	9104      	str	r1, [sp, #16]
 8021f62:	9603      	str	r6, [sp, #12]
 8021f64:	9502      	str	r5, [sp, #8]
 8021f66:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8021f6a:	9301      	str	r3, [sp, #4]
 8021f6c:	9400      	str	r4, [sp, #0]
 8021f6e:	4613      	mov	r3, r2
 8021f70:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 8021f72:	68b9      	ldr	r1, [r7, #8]
 8021f74:	f7f3 f832 	bl	8014fdc <lv_draw_label>
                      lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), hint);

        if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 8021f78:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021f7a:	7f9b      	ldrb	r3, [r3, #30]
 8021f7c:	f003 0307 	and.w	r3, r3, #7
 8021f80:	b2db      	uxtb	r3, r3
 8021f82:	2b04      	cmp	r3, #4
 8021f84:	f040 809c 	bne.w	80220c0 <lv_label_design+0x3a0>
            lv_point_t size;
            lv_txt_get_size(&size, ext->text, style->text.font, style->text.letter_space, style->text.line_space,
 8021f88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021f8a:	6819      	ldr	r1, [r3, #0]
 8021f8c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021f8e:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8021f90:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021f92:	f9b3 5028 	ldrsh.w	r5, [r3, #40]	; 0x28
 8021f96:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021f98:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8021f9c:	f107 0018 	add.w	r0, r7, #24
 8021fa0:	f897 2047 	ldrb.w	r2, [r7, #71]	; 0x47
 8021fa4:	9202      	str	r2, [sp, #8]
 8021fa6:	f647 4218 	movw	r2, #31768	; 0x7c18
 8021faa:	9201      	str	r2, [sp, #4]
 8021fac:	9300      	str	r3, [sp, #0]
 8021fae:	462b      	mov	r3, r5
 8021fb0:	4622      	mov	r2, r4
 8021fb2:	f7fb f8c7 	bl	801d144 <lv_txt_get_size>
                            LV_COORD_MAX, flag);

            lv_point_t ofs;

            /*Draw the text again next to the original to make an circular effect */
            if(size.x > lv_obj_get_width(label)) {
 8021fb6:	f9b7 4018 	ldrsh.w	r4, [r7, #24]
 8021fba:	68f8      	ldr	r0, [r7, #12]
 8021fbc:	f7f0 f8ea 	bl	8012194 <lv_obj_get_width>
 8021fc0:	4603      	mov	r3, r0
 8021fc2:	429c      	cmp	r4, r3
 8021fc4:	dd3c      	ble.n	8022040 <lv_label_design+0x320>
                ofs.x = ext->offset.x + size.x +
 8021fc6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021fc8:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8021fcc:	b29a      	uxth	r2, r3
 8021fce:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8021fd2:	b29b      	uxth	r3, r3
 8021fd4:	4413      	add	r3, r2
 8021fd6:	b29c      	uxth	r4, r3
                        lv_font_get_glyph_width(style->text.font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 8021fd8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8021fda:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8021fdc:	2220      	movs	r2, #32
 8021fde:	2120      	movs	r1, #32
 8021fe0:	4618      	mov	r0, r3
 8021fe2:	f7f8 fc89 	bl	801a8f8 <lv_font_get_glyph_width>
 8021fe6:	4603      	mov	r3, r0
                ofs.x = ext->offset.x + size.x +
 8021fe8:	461a      	mov	r2, r3
 8021fea:	0052      	lsls	r2, r2, #1
 8021fec:	4413      	add	r3, r2
 8021fee:	b29b      	uxth	r3, r3
 8021ff0:	4423      	add	r3, r4
 8021ff2:	b29b      	uxth	r3, r3
 8021ff4:	b21b      	sxth	r3, r3
 8021ff6:	82bb      	strh	r3, [r7, #20]
                ofs.y = ext->offset.y;
 8021ff8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8021ffa:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 8021ffe:	82fb      	strh	r3, [r7, #22]

                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
 8022000:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022002:	681c      	ldr	r4, [r3, #0]
 8022004:	68f8      	ldr	r0, [r7, #12]
 8022006:	f7ff fe73 	bl	8021cf0 <lv_label_get_text_sel_start>
 802200a:	4603      	mov	r3, r0
 802200c:	461d      	mov	r5, r3
 802200e:	68f8      	ldr	r0, [r7, #12]
 8022010:	f7ff fe7a 	bl	8021d08 <lv_label_get_text_sel_end>
 8022014:	4603      	mov	r3, r0
 8022016:	4619      	mov	r1, r3
 8022018:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 802201c:	f107 0028 	add.w	r0, r7, #40	; 0x28
 8022020:	2300      	movs	r3, #0
 8022022:	9305      	str	r3, [sp, #20]
 8022024:	9104      	str	r1, [sp, #16]
 8022026:	9503      	str	r5, [sp, #12]
 8022028:	f107 0314 	add.w	r3, r7, #20
 802202c:	9302      	str	r3, [sp, #8]
 802202e:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8022032:	9301      	str	r3, [sp, #4]
 8022034:	9400      	str	r4, [sp, #0]
 8022036:	4613      	mov	r3, r2
 8022038:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 802203a:	68b9      	ldr	r1, [r7, #8]
 802203c:	f7f2 ffce 	bl	8014fdc <lv_draw_label>
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), NULL);
            }

            /*Draw the text again below the original to make an circular effect */
            if(size.y > lv_obj_get_height(label)) {
 8022040:	f9b7 401a 	ldrsh.w	r4, [r7, #26]
 8022044:	68f8      	ldr	r0, [r7, #12]
 8022046:	f7f0 f8b3 	bl	80121b0 <lv_obj_get_height>
 802204a:	4603      	mov	r3, r0
 802204c:	429c      	cmp	r4, r3
 802204e:	dd37      	ble.n	80220c0 <lv_label_design+0x3a0>
                ofs.x = ext->offset.x;
 8022050:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022052:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8022056:	82bb      	strh	r3, [r7, #20]
                ofs.y = ext->offset.y + size.y + lv_font_get_line_height(style->text.font);
 8022058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 802205a:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 802205e:	b29a      	uxth	r2, r3
 8022060:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8022064:	b29b      	uxth	r3, r3
 8022066:	4413      	add	r3, r2
 8022068:	b29c      	uxth	r4, r3
 802206a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802206c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802206e:	4618      	mov	r0, r3
 8022070:	f7ff f99d 	bl	80213ae <lv_font_get_line_height>
 8022074:	4603      	mov	r3, r0
 8022076:	b29b      	uxth	r3, r3
 8022078:	4423      	add	r3, r4
 802207a:	b29b      	uxth	r3, r3
 802207c:	b21b      	sxth	r3, r3
 802207e:	82fb      	strh	r3, [r7, #22]
                lv_draw_label(&coords, mask, style, opa_scale, ext->text, flag, &ofs,
 8022080:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8022082:	681c      	ldr	r4, [r3, #0]
 8022084:	68f8      	ldr	r0, [r7, #12]
 8022086:	f7ff fe33 	bl	8021cf0 <lv_label_get_text_sel_start>
 802208a:	4603      	mov	r3, r0
 802208c:	461d      	mov	r5, r3
 802208e:	68f8      	ldr	r0, [r7, #12]
 8022090:	f7ff fe3a 	bl	8021d08 <lv_label_get_text_sel_end>
 8022094:	4603      	mov	r3, r0
 8022096:	4619      	mov	r1, r3
 8022098:	f897 203b 	ldrb.w	r2, [r7, #59]	; 0x3b
 802209c:	f107 0028 	add.w	r0, r7, #40	; 0x28
 80220a0:	2300      	movs	r3, #0
 80220a2:	9305      	str	r3, [sp, #20]
 80220a4:	9104      	str	r1, [sp, #16]
 80220a6:	9503      	str	r5, [sp, #12]
 80220a8:	f107 0314 	add.w	r3, r7, #20
 80220ac:	9302      	str	r3, [sp, #8]
 80220ae:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80220b2:	9301      	str	r3, [sp, #4]
 80220b4:	9400      	str	r4, [sp, #0]
 80220b6:	4613      	mov	r3, r2
 80220b8:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 80220ba:	68b9      	ldr	r1, [r7, #8]
 80220bc:	f7f2 ff8e 	bl	8014fdc <lv_draw_label>
                              lv_label_get_text_sel_start(label), lv_label_get_text_sel_end(label), NULL);
            }
        }
    }
    return true;
 80220c0:	2301      	movs	r3, #1
}
 80220c2:	4618      	mov	r0, r3
 80220c4:	374c      	adds	r7, #76	; 0x4c
 80220c6:	46bd      	mov	sp, r7
 80220c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080220cc <lv_label_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_label_signal(lv_obj_t * label, lv_signal_t sign, void * param)
{
 80220cc:	b590      	push	{r4, r7, lr}
 80220ce:	b089      	sub	sp, #36	; 0x24
 80220d0:	af00      	add	r7, sp, #0
 80220d2:	60f8      	str	r0, [r7, #12]
 80220d4:	460b      	mov	r3, r1
 80220d6:	607a      	str	r2, [r7, #4]
 80220d8:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(label, sign, param);
 80220da:	4b5a      	ldr	r3, [pc, #360]	; (8022244 <lv_label_signal+0x178>)
 80220dc:	681b      	ldr	r3, [r3, #0]
 80220de:	7af9      	ldrb	r1, [r7, #11]
 80220e0:	687a      	ldr	r2, [r7, #4]
 80220e2:	68f8      	ldr	r0, [r7, #12]
 80220e4:	4798      	blx	r3
 80220e6:	4603      	mov	r3, r0
 80220e8:	77bb      	strb	r3, [r7, #30]
    if(res != LV_RES_OK) return res;
 80220ea:	7fbb      	ldrb	r3, [r7, #30]
 80220ec:	2b01      	cmp	r3, #1
 80220ee:	d001      	beq.n	80220f4 <lv_label_signal+0x28>
 80220f0:	7fbb      	ldrb	r3, [r7, #30]
 80220f2:	e0a3      	b.n	802223c <lv_label_signal+0x170>

    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80220f4:	68f8      	ldr	r0, [r7, #12]
 80220f6:	f7f0 f99c 	bl	8012432 <lv_obj_get_ext_attr>
 80220fa:	61b8      	str	r0, [r7, #24]
    if(sign == LV_SIGNAL_CLEANUP) {
 80220fc:	7afb      	ldrb	r3, [r7, #11]
 80220fe:	2b00      	cmp	r3, #0
 8022100:	d112      	bne.n	8022128 <lv_label_signal+0x5c>
        if(ext->static_txt == 0) {
 8022102:	69bb      	ldr	r3, [r7, #24]
 8022104:	7f9b      	ldrb	r3, [r3, #30]
 8022106:	f003 0308 	and.w	r3, r3, #8
 802210a:	b2db      	uxtb	r3, r3
 802210c:	2b00      	cmp	r3, #0
 802210e:	d107      	bne.n	8022120 <lv_label_signal+0x54>
            lv_mem_free(ext->text);
 8022110:	69bb      	ldr	r3, [r7, #24]
 8022112:	681b      	ldr	r3, [r3, #0]
 8022114:	4618      	mov	r0, r3
 8022116:	f7fa fc05 	bl	801c924 <lv_mem_free>
            ext->text = NULL;
 802211a:	69bb      	ldr	r3, [r7, #24]
 802211c:	2200      	movs	r2, #0
 802211e:	601a      	str	r2, [r3, #0]
        }
        lv_label_dot_tmp_free(label);
 8022120:	68f8      	ldr	r0, [r7, #12]
 8022122:	f000 fc21 	bl	8022968 <lv_label_dot_tmp_free>
 8022126:	e088      	b.n	802223a <lv_label_signal+0x16e>
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 8022128:	7afb      	ldrb	r3, [r7, #11]
 802212a:	2b04      	cmp	r3, #4
 802212c:	d106      	bne.n	802213c <lv_label_signal+0x70>
        /*Revert dots for proper refresh*/
        lv_label_revert_dots(label);
 802212e:	68f8      	ldr	r0, [r7, #12]
 8022130:	f000 fb32 	bl	8022798 <lv_label_revert_dots>

        lv_label_refr_text(label);
 8022134:	68f8      	ldr	r0, [r7, #12]
 8022136:	f000 f889 	bl	802224c <lv_label_refr_text>
 802213a:	e07e      	b.n	802223a <lv_label_signal+0x16e>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
 802213c:	7afb      	ldrb	r3, [r7, #11]
 802213e:	2b02      	cmp	r3, #2
 8022140:	d120      	bne.n	8022184 <lv_label_signal+0xb8>
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 8022142:	68fb      	ldr	r3, [r7, #12]
 8022144:	3310      	adds	r3, #16
 8022146:	4618      	mov	r0, r3
 8022148:	f7ff f93d 	bl	80213c6 <lv_area_get_width>
 802214c:	4603      	mov	r3, r0
 802214e:	461c      	mov	r4, r3
 8022150:	6878      	ldr	r0, [r7, #4]
 8022152:	f7ff f938 	bl	80213c6 <lv_area_get_width>
 8022156:	4603      	mov	r3, r0
 8022158:	429c      	cmp	r4, r3
 802215a:	d10c      	bne.n	8022176 <lv_label_signal+0xaa>
           lv_area_get_height(&label->coords) != lv_area_get_height(param)) {
 802215c:	68fb      	ldr	r3, [r7, #12]
 802215e:	3310      	adds	r3, #16
 8022160:	4618      	mov	r0, r3
 8022162:	f7ff f947 	bl	80213f4 <lv_area_get_height>
 8022166:	4603      	mov	r3, r0
 8022168:	461c      	mov	r4, r3
 802216a:	6878      	ldr	r0, [r7, #4]
 802216c:	f7ff f942 	bl	80213f4 <lv_area_get_height>
 8022170:	4603      	mov	r3, r0
        if(lv_area_get_width(&label->coords) != lv_area_get_width(param) ||
 8022172:	429c      	cmp	r4, r3
 8022174:	d061      	beq.n	802223a <lv_label_signal+0x16e>
            lv_label_revert_dots(label);
 8022176:	68f8      	ldr	r0, [r7, #12]
 8022178:	f000 fb0e 	bl	8022798 <lv_label_revert_dots>
            lv_label_refr_text(label);
 802217c:	68f8      	ldr	r0, [r7, #12]
 802217e:	f000 f865 	bl	802224c <lv_label_refr_text>
 8022182:	e05a      	b.n	802223a <lv_label_signal+0x16e>
        }
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 8022184:	7afb      	ldrb	r3, [r7, #11]
 8022186:	2b05      	cmp	r3, #5
 8022188:	d13c      	bne.n	8022204 <lv_label_signal+0x138>
        if(ext->body_draw) {
 802218a:	69bb      	ldr	r3, [r7, #24]
 802218c:	7fdb      	ldrb	r3, [r3, #31]
 802218e:	f003 0301 	and.w	r3, r3, #1
 8022192:	b2db      	uxtb	r3, r3
 8022194:	2b00      	cmp	r3, #0
 8022196:	d050      	beq.n	802223a <lv_label_signal+0x16e>
            const lv_style_t * style = lv_label_get_style(label, LV_LABEL_STYLE_MAIN);
 8022198:	2100      	movs	r1, #0
 802219a:	68f8      	ldr	r0, [r7, #12]
 802219c:	f7ff f950 	bl	8021440 <lv_label_get_style>
 80221a0:	6138      	str	r0, [r7, #16]

            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.left);
 80221a2:	693b      	ldr	r3, [r7, #16]
 80221a4:	f9b3 201a 	ldrsh.w	r2, [r3, #26]
 80221a8:	68fb      	ldr	r3, [r7, #12]
 80221aa:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80221ae:	4293      	cmp	r3, r2
 80221b0:	bfb8      	it	lt
 80221b2:	4613      	movlt	r3, r2
 80221b4:	b21a      	sxth	r2, r3
 80221b6:	68fb      	ldr	r3, [r7, #12]
 80221b8:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.right);
 80221ba:	693b      	ldr	r3, [r7, #16]
 80221bc:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 80221c0:	68fb      	ldr	r3, [r7, #12]
 80221c2:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80221c6:	4293      	cmp	r3, r2
 80221c8:	bfb8      	it	lt
 80221ca:	4613      	movlt	r3, r2
 80221cc:	b21a      	sxth	r2, r3
 80221ce:	68fb      	ldr	r3, [r7, #12]
 80221d0:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.top);
 80221d2:	693b      	ldr	r3, [r7, #16]
 80221d4:	f9b3 2016 	ldrsh.w	r2, [r3, #22]
 80221d8:	68fb      	ldr	r3, [r7, #12]
 80221da:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80221de:	4293      	cmp	r3, r2
 80221e0:	bfb8      	it	lt
 80221e2:	4613      	movlt	r3, r2
 80221e4:	b21a      	sxth	r2, r3
 80221e6:	68fb      	ldr	r3, [r7, #12]
 80221e8:	869a      	strh	r2, [r3, #52]	; 0x34
            label->ext_draw_pad = LV_MATH_MAX(label->ext_draw_pad, style->body.padding.bottom);
 80221ea:	693b      	ldr	r3, [r7, #16]
 80221ec:	f9b3 2018 	ldrsh.w	r2, [r3, #24]
 80221f0:	68fb      	ldr	r3, [r7, #12]
 80221f2:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 80221f6:	4293      	cmp	r3, r2
 80221f8:	bfb8      	it	lt
 80221fa:	4613      	movlt	r3, r2
 80221fc:	b21a      	sxth	r2, r3
 80221fe:	68fb      	ldr	r3, [r7, #12]
 8022200:	869a      	strh	r2, [r3, #52]	; 0x34
 8022202:	e01a      	b.n	802223a <lv_label_signal+0x16e>
        }
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 8022204:	7afb      	ldrb	r3, [r7, #11]
 8022206:	2b06      	cmp	r3, #6
 8022208:	d117      	bne.n	802223a <lv_label_signal+0x16e>
        lv_obj_type_t * buf = param;
 802220a:	687b      	ldr	r3, [r7, #4]
 802220c:	617b      	str	r3, [r7, #20]
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 802220e:	2300      	movs	r3, #0
 8022210:	77fb      	strb	r3, [r7, #31]
 8022212:	e008      	b.n	8022226 <lv_label_signal+0x15a>
            if(buf->type[i] == NULL) break;
 8022214:	7ffa      	ldrb	r2, [r7, #31]
 8022216:	697b      	ldr	r3, [r7, #20]
 8022218:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 802221c:	2b00      	cmp	r3, #0
 802221e:	d006      	beq.n	802222e <lv_label_signal+0x162>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8022220:	7ffb      	ldrb	r3, [r7, #31]
 8022222:	3301      	adds	r3, #1
 8022224:	77fb      	strb	r3, [r7, #31]
 8022226:	7ffb      	ldrb	r3, [r7, #31]
 8022228:	2b06      	cmp	r3, #6
 802222a:	d9f3      	bls.n	8022214 <lv_label_signal+0x148>
 802222c:	e000      	b.n	8022230 <lv_label_signal+0x164>
            if(buf->type[i] == NULL) break;
 802222e:	bf00      	nop
        }
        buf->type[i] = "lv_label";
 8022230:	7ffa      	ldrb	r2, [r7, #31]
 8022232:	697b      	ldr	r3, [r7, #20]
 8022234:	4904      	ldr	r1, [pc, #16]	; (8022248 <lv_label_signal+0x17c>)
 8022236:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 802223a:	7fbb      	ldrb	r3, [r7, #30]
}
 802223c:	4618      	mov	r0, r3
 802223e:	3724      	adds	r7, #36	; 0x24
 8022240:	46bd      	mov	sp, r7
 8022242:	bd90      	pop	{r4, r7, pc}
 8022244:	2000c3dc 	.word	0x2000c3dc
 8022248:	0802908c 	.word	0x0802908c

0802224c <lv_label_refr_text>:
/**
 * Refresh the label with its text stored in its extended data
 * @param label pointer to a label object
 */
static void lv_label_refr_text(lv_obj_t * label)
{
 802224c:	b590      	push	{r4, r7, lr}
 802224e:	b09d      	sub	sp, #116	; 0x74
 8022250:	af04      	add	r7, sp, #16
 8022252:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8022254:	6878      	ldr	r0, [r7, #4]
 8022256:	f7f0 f8ec 	bl	8012432 <lv_obj_get_ext_attr>
 802225a:	64f8      	str	r0, [r7, #76]	; 0x4c

    if(ext->text == NULL) return;
 802225c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802225e:	681b      	ldr	r3, [r3, #0]
 8022260:	2b00      	cmp	r3, #0
 8022262:	f000 828f 	beq.w	8022784 <lv_label_refr_text+0x538>

    ext->hint.line_start = -1; /*The hint is invalid if the text changes*/
 8022266:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022268:	f04f 32ff 	mov.w	r2, #4294967295
 802226c:	611a      	str	r2, [r3, #16]

    lv_coord_t max_w         = lv_obj_get_width(label);
 802226e:	6878      	ldr	r0, [r7, #4]
 8022270:	f7ef ff90 	bl	8012194 <lv_obj_get_width>
 8022274:	4603      	mov	r3, r0
 8022276:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
    const lv_style_t * style = lv_obj_get_style(label);
 802227a:	6878      	ldr	r0, [r7, #4]
 802227c:	f7ef ffba 	bl	80121f4 <lv_obj_get_style>
 8022280:	64b8      	str	r0, [r7, #72]	; 0x48
    const lv_font_t * font   = style->text.font;
 8022282:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8022284:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022286:	647b      	str	r3, [r7, #68]	; 0x44

    /*If the width will be expanded set the max length to very big */
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 8022288:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802228a:	7f9b      	ldrb	r3, [r3, #30]
 802228c:	f003 0307 	and.w	r3, r3, #7
 8022290:	b2db      	uxtb	r3, r3
 8022292:	2b00      	cmp	r3, #0
 8022294:	d103      	bne.n	802229e <lv_label_refr_text+0x52>
        max_w = LV_COORD_MAX;
 8022296:	f647 4318 	movw	r3, #31768	; 0x7c18
 802229a:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e
    }

    /*Calc. the height and longest line*/
    lv_point_t size;
    lv_txt_flag_t flag = LV_TXT_FLAG_NONE;
 802229e:	2300      	movs	r3, #0
 80222a0:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(ext->recolor != 0) flag |= LV_TXT_FLAG_RECOLOR;
 80222a4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80222a6:	7f9b      	ldrb	r3, [r3, #30]
 80222a8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80222ac:	b2db      	uxtb	r3, r3
 80222ae:	2b00      	cmp	r3, #0
 80222b0:	d005      	beq.n	80222be <lv_label_refr_text+0x72>
 80222b2:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 80222b6:	f043 0301 	orr.w	r3, r3, #1
 80222ba:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    if(ext->expand != 0) flag |= LV_TXT_FLAG_EXPAND;
 80222be:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80222c0:	7f9b      	ldrb	r3, [r3, #30]
 80222c2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80222c6:	b2db      	uxtb	r3, r3
 80222c8:	2b00      	cmp	r3, #0
 80222ca:	d005      	beq.n	80222d8 <lv_label_refr_text+0x8c>
 80222cc:	f897 305d 	ldrb.w	r3, [r7, #93]	; 0x5d
 80222d0:	f043 0302 	orr.w	r3, r3, #2
 80222d4:	f887 305d 	strb.w	r3, [r7, #93]	; 0x5d
    lv_txt_get_size(&size, ext->text, font, style->text.letter_space, style->text.line_space, max_w, flag);
 80222d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80222da:	6819      	ldr	r1, [r3, #0]
 80222dc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80222de:	f9b3 4028 	ldrsh.w	r4, [r3, #40]	; 0x28
 80222e2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80222e4:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 80222e8:	f107 0038 	add.w	r0, r7, #56	; 0x38
 80222ec:	f897 205d 	ldrb.w	r2, [r7, #93]	; 0x5d
 80222f0:	9202      	str	r2, [sp, #8]
 80222f2:	f9b7 205e 	ldrsh.w	r2, [r7, #94]	; 0x5e
 80222f6:	9201      	str	r2, [sp, #4]
 80222f8:	9300      	str	r3, [sp, #0]
 80222fa:	4623      	mov	r3, r4
 80222fc:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80222fe:	f7fa ff21 	bl	801d144 <lv_txt_get_size>

    /*Set the full size in expand mode*/
    if(ext->long_mode == LV_LABEL_LONG_EXPAND) {
 8022302:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022304:	7f9b      	ldrb	r3, [r3, #30]
 8022306:	f003 0307 	and.w	r3, r3, #7
 802230a:	b2db      	uxtb	r3, r3
 802230c:	2b00      	cmp	r3, #0
 802230e:	d108      	bne.n	8022322 <lv_label_refr_text+0xd6>
        lv_obj_set_size(label, size.x, size.y);
 8022310:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8022314:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8022318:	4619      	mov	r1, r3
 802231a:	6878      	ldr	r0, [r7, #4]
 802231c:	f7ee ff4d 	bl	80111ba <lv_obj_set_size>
 8022320:	e22c      	b.n	802277c <lv_label_refr_text+0x530>
    }
    /*In roll mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL) {
 8022322:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022324:	7f9b      	ldrb	r3, [r3, #30]
 8022326:	f003 0307 	and.w	r3, r3, #7
 802232a:	b2db      	uxtb	r3, r3
 802232c:	2b03      	cmp	r3, #3
 802232e:	f040 809f 	bne.w	8022470 <lv_label_refr_text+0x224>
#if LV_USE_ANIMATION
        lv_anim_t anim;
        anim.var      = label;
 8022332:	687b      	ldr	r3, [r7, #4]
 8022334:	60bb      	str	r3, [r7, #8]
        anim.repeat   = 1;
 8022336:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 802233a:	f043 0302 	orr.w	r3, r3, #2
 802233e:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.playback = 1;
 8022342:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8022346:	f043 0301 	orr.w	r3, r3, #1
 802234a:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.start    = 0;
 802234e:	2300      	movs	r3, #0
 8022350:	61bb      	str	r3, [r7, #24]
        anim.ready_cb = NULL;
 8022352:	2300      	movs	r3, #0
 8022354:	617b      	str	r3, [r7, #20]
        anim.path_cb  = lv_anim_path_linear;
 8022356:	4baa      	ldr	r3, [pc, #680]	; (8022600 <lv_label_refr_text+0x3b4>)
 8022358:	613b      	str	r3, [r7, #16]
        anim.playback_pause =
            (((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 802235a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802235c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802235e:	2220      	movs	r2, #32
 8022360:	2120      	movs	r1, #32
 8022362:	4618      	mov	r0, r3
 8022364:	f7f8 fac8 	bl	801a8f8 <lv_font_get_glyph_width>
 8022368:	4603      	mov	r3, r0
 802236a:	461a      	mov	r2, r3
 802236c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802236e:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8022372:	4413      	add	r3, r2
 8022374:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8022378:	fb02 f303 	mul.w	r3, r2, r3
             ext->anim_speed) *
 802237c:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 802237e:	8b92      	ldrh	r2, [r2, #28]
            (((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 8022380:	fb93 f3f2 	sdiv	r3, r3, r2
        anim.playback_pause =
 8022384:	b29b      	uxth	r3, r3
 8022386:	461a      	mov	r2, r3
 8022388:	0052      	lsls	r2, r2, #1
 802238a:	4413      	add	r3, r2
 802238c:	b29b      	uxth	r3, r3
 802238e:	84bb      	strh	r3, [r7, #36]	; 0x24
            LV_LABEL_WAIT_CHAR_COUNT;
        anim.repeat_pause = anim.playback_pause;
 8022390:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8022392:	84fb      	strh	r3, [r7, #38]	; 0x26
        anim.act_time     = -anim.playback_pause;
 8022394:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8022396:	425b      	negs	r3, r3
 8022398:	b29b      	uxth	r3, r3
 802239a:	b21b      	sxth	r3, r3
 802239c:	847b      	strh	r3, [r7, #34]	; 0x22

        bool hor_anim = false;
 802239e:	2300      	movs	r3, #0
 80223a0:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
        if(size.x > lv_obj_get_width(label)) {
 80223a4:	f9b7 4038 	ldrsh.w	r4, [r7, #56]	; 0x38
 80223a8:	6878      	ldr	r0, [r7, #4]
 80223aa:	f7ef fef3 	bl	8012194 <lv_obj_get_width>
 80223ae:	4603      	mov	r3, r0
 80223b0:	429c      	cmp	r4, r3
 80223b2:	dd1e      	ble.n	80223f2 <lv_label_refr_text+0x1a6>
            anim.end     = lv_obj_get_width(label) - size.x;
 80223b4:	6878      	ldr	r0, [r7, #4]
 80223b6:	f7ef feed 	bl	8012194 <lv_obj_get_width>
 80223ba:	4603      	mov	r3, r0
 80223bc:	461a      	mov	r2, r3
 80223be:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 80223c2:	1ad3      	subs	r3, r2, r3
 80223c4:	61fb      	str	r3, [r7, #28]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_x;
 80223c6:	4b8f      	ldr	r3, [pc, #572]	; (8022604 <lv_label_refr_text+0x3b8>)
 80223c8:	60fb      	str	r3, [r7, #12]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 80223ca:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80223cc:	8b9b      	ldrh	r3, [r3, #28]
 80223ce:	69ba      	ldr	r2, [r7, #24]
 80223d0:	b211      	sxth	r1, r2
 80223d2:	69fa      	ldr	r2, [r7, #28]
 80223d4:	b212      	sxth	r2, r2
 80223d6:	4618      	mov	r0, r3
 80223d8:	f7f9 f93a 	bl	801b650 <lv_anim_speed_to_time>
 80223dc:	4603      	mov	r3, r0
 80223de:	843b      	strh	r3, [r7, #32]
            lv_anim_create(&anim);
 80223e0:	f107 0308 	add.w	r3, r7, #8
 80223e4:	4618      	mov	r0, r3
 80223e6:	f7f9 f8b1 	bl	801b54c <lv_anim_create>
            hor_anim = true;
 80223ea:	2301      	movs	r3, #1
 80223ec:	f887 305c 	strb.w	r3, [r7, #92]	; 0x5c
 80223f0:	e006      	b.n	8022400 <lv_label_refr_text+0x1b4>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 80223f2:	4984      	ldr	r1, [pc, #528]	; (8022604 <lv_label_refr_text+0x3b8>)
 80223f4:	6878      	ldr	r0, [r7, #4]
 80223f6:	f7f9 f8f3 	bl	801b5e0 <lv_anim_del>
            ext->offset.x = 0;
 80223fa:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80223fc:	2200      	movs	r2, #0
 80223fe:	815a      	strh	r2, [r3, #10]
        }

        if(size.y > lv_obj_get_height(label) && hor_anim == false) {
 8022400:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8022404:	6878      	ldr	r0, [r7, #4]
 8022406:	f7ef fed3 	bl	80121b0 <lv_obj_get_height>
 802240a:	4603      	mov	r3, r0
 802240c:	429c      	cmp	r4, r3
 802240e:	dd27      	ble.n	8022460 <lv_label_refr_text+0x214>
 8022410:	f897 305c 	ldrb.w	r3, [r7, #92]	; 0x5c
 8022414:	f083 0301 	eor.w	r3, r3, #1
 8022418:	b2db      	uxtb	r3, r3
 802241a:	2b00      	cmp	r3, #0
 802241c:	d020      	beq.n	8022460 <lv_label_refr_text+0x214>
            anim.end     = lv_obj_get_height(label) - size.y - (lv_font_get_line_height(font));
 802241e:	6878      	ldr	r0, [r7, #4]
 8022420:	f7ef fec6 	bl	80121b0 <lv_obj_get_height>
 8022424:	4603      	mov	r3, r0
 8022426:	461a      	mov	r2, r3
 8022428:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 802242c:	1ad4      	subs	r4, r2, r3
 802242e:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8022430:	f7fe ffbd 	bl	80213ae <lv_font_get_line_height>
 8022434:	4603      	mov	r3, r0
 8022436:	1ae3      	subs	r3, r4, r3
 8022438:	61fb      	str	r3, [r7, #28]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_y;
 802243a:	4b73      	ldr	r3, [pc, #460]	; (8022608 <lv_label_refr_text+0x3bc>)
 802243c:	60fb      	str	r3, [r7, #12]

            anim.time = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 802243e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022440:	8b9b      	ldrh	r3, [r3, #28]
 8022442:	69ba      	ldr	r2, [r7, #24]
 8022444:	b211      	sxth	r1, r2
 8022446:	69fa      	ldr	r2, [r7, #28]
 8022448:	b212      	sxth	r2, r2
 802244a:	4618      	mov	r0, r3
 802244c:	f7f9 f900 	bl	801b650 <lv_anim_speed_to_time>
 8022450:	4603      	mov	r3, r0
 8022452:	843b      	strh	r3, [r7, #32]
            lv_anim_create(&anim);
 8022454:	f107 0308 	add.w	r3, r7, #8
 8022458:	4618      	mov	r0, r3
 802245a:	f7f9 f877 	bl	801b54c <lv_anim_create>
 802245e:	e18d      	b.n	802277c <lv_label_refr_text+0x530>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 8022460:	4969      	ldr	r1, [pc, #420]	; (8022608 <lv_label_refr_text+0x3bc>)
 8022462:	6878      	ldr	r0, [r7, #4]
 8022464:	f7f9 f8bc 	bl	801b5e0 <lv_anim_del>
            ext->offset.y = 0;
 8022468:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802246a:	2200      	movs	r2, #0
 802246c:	819a      	strh	r2, [r3, #12]
 802246e:	e185      	b.n	802277c <lv_label_refr_text+0x530>
        }
#endif
    }
    /*In roll inf. mode keep the size but start offset animations*/
    else if(ext->long_mode == LV_LABEL_LONG_SROLL_CIRC) {
 8022470:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022472:	7f9b      	ldrb	r3, [r3, #30]
 8022474:	f003 0307 	and.w	r3, r3, #7
 8022478:	b2db      	uxtb	r3, r3
 802247a:	2b04      	cmp	r3, #4
 802247c:	f040 809c 	bne.w	80225b8 <lv_label_refr_text+0x36c>
#if LV_USE_ANIMATION
        lv_anim_t anim;
        anim.var      = label;
 8022480:	687b      	ldr	r3, [r7, #4]
 8022482:	60bb      	str	r3, [r7, #8]
        anim.repeat   = 1;
 8022484:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8022488:	f043 0302 	orr.w	r3, r3, #2
 802248c:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.playback = 0;
 8022490:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 8022494:	f36f 0300 	bfc	r3, #0, #1
 8022498:	f887 302c 	strb.w	r3, [r7, #44]	; 0x2c
        anim.start    = 0;
 802249c:	2300      	movs	r3, #0
 802249e:	61bb      	str	r3, [r7, #24]
        anim.act_time = -(((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 80224a0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80224a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80224a4:	2220      	movs	r2, #32
 80224a6:	2120      	movs	r1, #32
 80224a8:	4618      	mov	r0, r3
 80224aa:	f7f8 fa25 	bl	801a8f8 <lv_font_get_glyph_width>
 80224ae:	4603      	mov	r3, r0
 80224b0:	461a      	mov	r2, r3
 80224b2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80224b4:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 80224b8:	4413      	add	r3, r2
 80224ba:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80224be:	fb02 f303 	mul.w	r3, r2, r3
                          ext->anim_speed) *
 80224c2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80224c4:	8b92      	ldrh	r2, [r2, #28]
        anim.act_time = -(((lv_font_get_glyph_width(style->text.font, ' ', ' ') + style->text.letter_space) * 1000) /
 80224c6:	fb93 f3f2 	sdiv	r3, r3, r2
 80224ca:	b29b      	uxth	r3, r3
 80224cc:	461a      	mov	r2, r3
 80224ce:	009b      	lsls	r3, r3, #2
 80224d0:	1ad3      	subs	r3, r2, r3
 80224d2:	b29b      	uxth	r3, r3
 80224d4:	b21b      	sxth	r3, r3
 80224d6:	847b      	strh	r3, [r7, #34]	; 0x22
                        LV_LABEL_WAIT_CHAR_COUNT;
        anim.ready_cb       = NULL;
 80224d8:	2300      	movs	r3, #0
 80224da:	617b      	str	r3, [r7, #20]
        anim.path_cb        = lv_anim_path_linear;
 80224dc:	4b48      	ldr	r3, [pc, #288]	; (8022600 <lv_label_refr_text+0x3b4>)
 80224de:	613b      	str	r3, [r7, #16]
        anim.playback_pause = 0;
 80224e0:	2300      	movs	r3, #0
 80224e2:	84bb      	strh	r3, [r7, #36]	; 0x24
        anim.repeat_pause   = 0;
 80224e4:	2300      	movs	r3, #0
 80224e6:	84fb      	strh	r3, [r7, #38]	; 0x26

        bool hor_anim = false;
 80224e8:	2300      	movs	r3, #0
 80224ea:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
        if(size.x > lv_obj_get_width(label)) {
 80224ee:	f9b7 4038 	ldrsh.w	r4, [r7, #56]	; 0x38
 80224f2:	6878      	ldr	r0, [r7, #4]
 80224f4:	f7ef fe4e 	bl	8012194 <lv_obj_get_width>
 80224f8:	4603      	mov	r3, r0
 80224fa:	429c      	cmp	r4, r3
 80224fc:	dd22      	ble.n	8022544 <lv_label_refr_text+0x2f8>
            anim.end     = -size.x - lv_font_get_glyph_width(font, ' ', ' ') * LV_LABEL_WAIT_CHAR_COUNT;
 80224fe:	2220      	movs	r2, #32
 8022500:	2120      	movs	r1, #32
 8022502:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8022504:	f7f8 f9f8 	bl	801a8f8 <lv_font_get_glyph_width>
 8022508:	4603      	mov	r3, r0
 802250a:	461a      	mov	r2, r3
 802250c:	009b      	lsls	r3, r3, #2
 802250e:	1ad3      	subs	r3, r2, r3
 8022510:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8022514:	1a9b      	subs	r3, r3, r2
 8022516:	61fb      	str	r3, [r7, #28]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_x;
 8022518:	4b3a      	ldr	r3, [pc, #232]	; (8022604 <lv_label_refr_text+0x3b8>)
 802251a:	60fb      	str	r3, [r7, #12]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 802251c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802251e:	8b9b      	ldrh	r3, [r3, #28]
 8022520:	69ba      	ldr	r2, [r7, #24]
 8022522:	b211      	sxth	r1, r2
 8022524:	69fa      	ldr	r2, [r7, #28]
 8022526:	b212      	sxth	r2, r2
 8022528:	4618      	mov	r0, r3
 802252a:	f7f9 f891 	bl	801b650 <lv_anim_speed_to_time>
 802252e:	4603      	mov	r3, r0
 8022530:	843b      	strh	r3, [r7, #32]
            lv_anim_create(&anim);
 8022532:	f107 0308 	add.w	r3, r7, #8
 8022536:	4618      	mov	r0, r3
 8022538:	f7f9 f808 	bl	801b54c <lv_anim_create>
            hor_anim = true;
 802253c:	2301      	movs	r3, #1
 802253e:	f887 305b 	strb.w	r3, [r7, #91]	; 0x5b
 8022542:	e006      	b.n	8022552 <lv_label_refr_text+0x306>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_x);
 8022544:	492f      	ldr	r1, [pc, #188]	; (8022604 <lv_label_refr_text+0x3b8>)
 8022546:	6878      	ldr	r0, [r7, #4]
 8022548:	f7f9 f84a 	bl	801b5e0 <lv_anim_del>
            ext->offset.x = 0;
 802254c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802254e:	2200      	movs	r2, #0
 8022550:	815a      	strh	r2, [r3, #10]
        }

        if(size.y > lv_obj_get_height(label) && hor_anim == false) {
 8022552:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 8022556:	6878      	ldr	r0, [r7, #4]
 8022558:	f7ef fe2a 	bl	80121b0 <lv_obj_get_height>
 802255c:	4603      	mov	r3, r0
 802255e:	429c      	cmp	r4, r3
 8022560:	dd22      	ble.n	80225a8 <lv_label_refr_text+0x35c>
 8022562:	f897 305b 	ldrb.w	r3, [r7, #91]	; 0x5b
 8022566:	f083 0301 	eor.w	r3, r3, #1
 802256a:	b2db      	uxtb	r3, r3
 802256c:	2b00      	cmp	r3, #0
 802256e:	d01b      	beq.n	80225a8 <lv_label_refr_text+0x35c>
            anim.end     = -size.y - (lv_font_get_line_height(font));
 8022570:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8022574:	425c      	negs	r4, r3
 8022576:	6c78      	ldr	r0, [r7, #68]	; 0x44
 8022578:	f7fe ff19 	bl	80213ae <lv_font_get_line_height>
 802257c:	4603      	mov	r3, r0
 802257e:	1ae3      	subs	r3, r4, r3
 8022580:	61fb      	str	r3, [r7, #28]
            anim.exec_cb = (lv_anim_exec_xcb_t)lv_label_set_offset_y;
 8022582:	4b21      	ldr	r3, [pc, #132]	; (8022608 <lv_label_refr_text+0x3bc>)
 8022584:	60fb      	str	r3, [r7, #12]
            anim.time    = lv_anim_speed_to_time(ext->anim_speed, anim.start, anim.end);
 8022586:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022588:	8b9b      	ldrh	r3, [r3, #28]
 802258a:	69ba      	ldr	r2, [r7, #24]
 802258c:	b211      	sxth	r1, r2
 802258e:	69fa      	ldr	r2, [r7, #28]
 8022590:	b212      	sxth	r2, r2
 8022592:	4618      	mov	r0, r3
 8022594:	f7f9 f85c 	bl	801b650 <lv_anim_speed_to_time>
 8022598:	4603      	mov	r3, r0
 802259a:	843b      	strh	r3, [r7, #32]
            lv_anim_create(&anim);
 802259c:	f107 0308 	add.w	r3, r7, #8
 80225a0:	4618      	mov	r0, r3
 80225a2:	f7f8 ffd3 	bl	801b54c <lv_anim_create>
 80225a6:	e0e9      	b.n	802277c <lv_label_refr_text+0x530>
        } else {
            /*Delete the offset animation if not required*/
            lv_anim_del(label, (lv_anim_exec_xcb_t)lv_label_set_offset_y);
 80225a8:	4917      	ldr	r1, [pc, #92]	; (8022608 <lv_label_refr_text+0x3bc>)
 80225aa:	6878      	ldr	r0, [r7, #4]
 80225ac:	f7f9 f818 	bl	801b5e0 <lv_anim_del>
            ext->offset.y = 0;
 80225b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80225b2:	2200      	movs	r2, #0
 80225b4:	819a      	strh	r2, [r3, #12]
 80225b6:	e0e1      	b.n	802277c <lv_label_refr_text+0x530>
        }
#endif
    } else if(ext->long_mode == LV_LABEL_LONG_DOT) {
 80225b8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80225ba:	7f9b      	ldrb	r3, [r3, #30]
 80225bc:	f003 0307 	and.w	r3, r3, #7
 80225c0:	b2db      	uxtb	r3, r3
 80225c2:	2b02      	cmp	r3, #2
 80225c4:	f040 80cd 	bne.w	8022762 <lv_label_refr_text+0x516>
        if(size.y <= lv_obj_get_height(label)) { /*No dots are required, the text is short enough*/
 80225c8:	f9b7 403a 	ldrsh.w	r4, [r7, #58]	; 0x3a
 80225cc:	6878      	ldr	r0, [r7, #4]
 80225ce:	f7ef fdef 	bl	80121b0 <lv_obj_get_height>
 80225d2:	4603      	mov	r3, r0
 80225d4:	429c      	cmp	r4, r3
 80225d6:	dc04      	bgt.n	80225e2 <lv_label_refr_text+0x396>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 80225d8:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80225da:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80225de:	811a      	strh	r2, [r3, #8]
 80225e0:	e0cc      	b.n	802277c <lv_label_refr_text+0x530>
        } else if(lv_txt_get_encoded_length(ext->text) <= LV_LABEL_DOT_NUM) { /*Don't turn to dots all the characters*/
 80225e2:	4b0a      	ldr	r3, [pc, #40]	; (802260c <lv_label_refr_text+0x3c0>)
 80225e4:	681b      	ldr	r3, [r3, #0]
 80225e6:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80225e8:	6812      	ldr	r2, [r2, #0]
 80225ea:	4610      	mov	r0, r2
 80225ec:	4798      	blx	r3
 80225ee:	4603      	mov	r3, r0
 80225f0:	2b03      	cmp	r3, #3
 80225f2:	d80d      	bhi.n	8022610 <lv_label_refr_text+0x3c4>
            ext->dot_end = LV_LABEL_DOT_END_INV;
 80225f4:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80225f6:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80225fa:	811a      	strh	r2, [r3, #8]
 80225fc:	e0be      	b.n	802277c <lv_label_refr_text+0x530>
 80225fe:	bf00      	nop
 8022600:	0801b6b1 	.word	0x0801b6b1
 8022604:	0802284d 	.word	0x0802284d
 8022608:	08022875 	.word	0x08022875
 802260c:	20000c44 	.word	0x20000c44
        } else {
            lv_point_t p;
            p.x = lv_obj_get_width(label) -
 8022610:	6878      	ldr	r0, [r7, #4]
 8022612:	f7ef fdbf 	bl	8012194 <lv_obj_get_width>
 8022616:	4603      	mov	r3, r0
 8022618:	b29c      	uxth	r4, r3
                  (lv_font_get_glyph_width(style->text.font, '.', '.') + style->text.letter_space) *
 802261a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802261c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802261e:	222e      	movs	r2, #46	; 0x2e
 8022620:	212e      	movs	r1, #46	; 0x2e
 8022622:	4618      	mov	r0, r3
 8022624:	f7f8 f968 	bl	801a8f8 <lv_font_get_glyph_width>
 8022628:	4603      	mov	r3, r0
 802262a:	461a      	mov	r2, r3
 802262c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802262e:	f9b3 3028 	ldrsh.w	r3, [r3, #40]	; 0x28
 8022632:	4413      	add	r3, r2
            p.x = lv_obj_get_width(label) -
 8022634:	b29b      	uxth	r3, r3
 8022636:	461a      	mov	r2, r3
 8022638:	009b      	lsls	r3, r3, #2
 802263a:	1ad3      	subs	r3, r2, r3
 802263c:	b29b      	uxth	r3, r3
 802263e:	4423      	add	r3, r4
 8022640:	b29b      	uxth	r3, r3
 8022642:	b21b      	sxth	r3, r3
 8022644:	86bb      	strh	r3, [r7, #52]	; 0x34
                      LV_LABEL_DOT_NUM; /*Shrink with dots*/
            p.y = lv_obj_get_height(label);
 8022646:	6878      	ldr	r0, [r7, #4]
 8022648:	f7ef fdb2 	bl	80121b0 <lv_obj_get_height>
 802264c:	4603      	mov	r3, r0
 802264e:	86fb      	strh	r3, [r7, #54]	; 0x36
            p.y -= p.y %
 8022650:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8022654:	461c      	mov	r4, r3
                   (lv_font_get_line_height(style->text.font) + style->text.line_space); /*Round down to the last line*/
 8022656:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8022658:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 802265a:	4618      	mov	r0, r3
 802265c:	f7fe fea7 	bl	80213ae <lv_font_get_line_height>
 8022660:	4603      	mov	r3, r0
 8022662:	461a      	mov	r2, r3
 8022664:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8022666:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 802266a:	4413      	add	r3, r2
            p.y -= p.y %
 802266c:	fb94 f2f3 	sdiv	r2, r4, r3
 8022670:	fb03 f302 	mul.w	r3, r3, r2
 8022674:	1ae3      	subs	r3, r4, r3
 8022676:	f9b7 2036 	ldrsh.w	r2, [r7, #54]	; 0x36
 802267a:	b292      	uxth	r2, r2
 802267c:	b29b      	uxth	r3, r3
 802267e:	1ad3      	subs	r3, r2, r3
 8022680:	b29b      	uxth	r3, r3
 8022682:	b21b      	sxth	r3, r3
 8022684:	86fb      	strh	r3, [r7, #54]	; 0x36
            p.y -= style->text.line_space;                                               /*Trim the last line space*/
 8022686:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 802268a:	b29a      	uxth	r2, r3
 802268c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 802268e:	f9b3 302a 	ldrsh.w	r3, [r3, #42]	; 0x2a
 8022692:	b29b      	uxth	r3, r3
 8022694:	1ad3      	subs	r3, r2, r3
 8022696:	b29b      	uxth	r3, r3
 8022698:	b21b      	sxth	r3, r3
 802269a:	86fb      	strh	r3, [r7, #54]	; 0x36
            uint32_t letter_id = lv_label_get_letter_on(label, &p);
 802269c:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80226a0:	4619      	mov	r1, r3
 80226a2:	6878      	ldr	r0, [r7, #4]
 80226a4:	f7ff f9fe 	bl	8021aa4 <lv_label_get_letter_on>
 80226a8:	4603      	mov	r3, r0
 80226aa:	643b      	str	r3, [r7, #64]	; 0x40

            /*Save letters under the dots and replace them with dots*/
            uint32_t i;
            uint32_t byte_id     = lv_txt_encoded_get_byte_id(ext->text, letter_id);
 80226ac:	4b37      	ldr	r3, [pc, #220]	; (802278c <lv_label_refr_text+0x540>)
 80226ae:	681b      	ldr	r3, [r3, #0]
 80226b0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80226b2:	6812      	ldr	r2, [r2, #0]
 80226b4:	6c39      	ldr	r1, [r7, #64]	; 0x40
 80226b6:	4610      	mov	r0, r2
 80226b8:	4798      	blx	r3
 80226ba:	4603      	mov	r3, r0
 80226bc:	633b      	str	r3, [r7, #48]	; 0x30
            uint32_t byte_id_ori = byte_id;
 80226be:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80226c0:	63fb      	str	r3, [r7, #60]	; 0x3c
            uint8_t len          = 0;
 80226c2:	2300      	movs	r3, #0
 80226c4:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 80226c8:	2300      	movs	r3, #0
 80226ca:	657b      	str	r3, [r7, #84]	; 0x54
 80226cc:	e019      	b.n	8022702 <lv_label_refr_text+0x4b6>
                len += lv_txt_encoded_size(&ext->text[byte_id]);
 80226ce:	4b30      	ldr	r3, [pc, #192]	; (8022790 <lv_label_refr_text+0x544>)
 80226d0:	681b      	ldr	r3, [r3, #0]
 80226d2:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80226d4:	6811      	ldr	r1, [r2, #0]
 80226d6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80226d8:	440a      	add	r2, r1
 80226da:	4610      	mov	r0, r2
 80226dc:	4798      	blx	r3
 80226de:	4603      	mov	r3, r0
 80226e0:	461a      	mov	r2, r3
 80226e2:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 80226e6:	4413      	add	r3, r2
 80226e8:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
                lv_txt_encoded_next(ext->text, &byte_id);
 80226ec:	4b29      	ldr	r3, [pc, #164]	; (8022794 <lv_label_refr_text+0x548>)
 80226ee:	681b      	ldr	r3, [r3, #0]
 80226f0:	6cfa      	ldr	r2, [r7, #76]	; 0x4c
 80226f2:	6812      	ldr	r2, [r2, #0]
 80226f4:	f107 0130 	add.w	r1, r7, #48	; 0x30
 80226f8:	4610      	mov	r0, r2
 80226fa:	4798      	blx	r3
            for(i = 0; i <= LV_LABEL_DOT_NUM; i++) {
 80226fc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 80226fe:	3301      	adds	r3, #1
 8022700:	657b      	str	r3, [r7, #84]	; 0x54
 8022702:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8022704:	2b03      	cmp	r3, #3
 8022706:	d9e2      	bls.n	80226ce <lv_label_refr_text+0x482>
            }

            if(lv_label_set_dot_tmp(label, &ext->text[byte_id_ori], len)) {
 8022708:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802270a:	681a      	ldr	r2, [r3, #0]
 802270c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802270e:	4413      	add	r3, r2
 8022710:	f897 2053 	ldrb.w	r2, [r7, #83]	; 0x53
 8022714:	b292      	uxth	r2, r2
 8022716:	4619      	mov	r1, r3
 8022718:	6878      	ldr	r0, [r7, #4]
 802271a:	f000 f8bf 	bl	802289c <lv_label_set_dot_tmp>
 802271e:	4603      	mov	r3, r0
 8022720:	2b00      	cmp	r3, #0
 8022722:	d02b      	beq.n	802277c <lv_label_refr_text+0x530>
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 8022724:	2300      	movs	r3, #0
 8022726:	657b      	str	r3, [r7, #84]	; 0x54
 8022728:	e00a      	b.n	8022740 <lv_label_refr_text+0x4f4>
                    ext->text[byte_id_ori + i] = '.';
 802272a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802272c:	681a      	ldr	r2, [r3, #0]
 802272e:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 8022730:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8022732:	440b      	add	r3, r1
 8022734:	4413      	add	r3, r2
 8022736:	222e      	movs	r2, #46	; 0x2e
 8022738:	701a      	strb	r2, [r3, #0]
                for(i = 0; i < LV_LABEL_DOT_NUM; i++) {
 802273a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 802273c:	3301      	adds	r3, #1
 802273e:	657b      	str	r3, [r7, #84]	; 0x54
 8022740:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8022742:	2b02      	cmp	r3, #2
 8022744:	d9f1      	bls.n	802272a <lv_label_refr_text+0x4de>
                }
                ext->text[byte_id_ori + LV_LABEL_DOT_NUM] = '\0';
 8022746:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022748:	681a      	ldr	r2, [r3, #0]
 802274a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802274c:	3303      	adds	r3, #3
 802274e:	4413      	add	r3, r2
 8022750:	2200      	movs	r2, #0
 8022752:	701a      	strb	r2, [r3, #0]
                ext->dot_end                              = letter_id + LV_LABEL_DOT_NUM;
 8022754:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8022756:	b29b      	uxth	r3, r3
 8022758:	3303      	adds	r3, #3
 802275a:	b29a      	uxth	r2, r3
 802275c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802275e:	811a      	strh	r2, [r3, #8]
 8022760:	e00c      	b.n	802277c <lv_label_refr_text+0x530>
            }
        }
    }
    /*In break mode only the height can change*/
    else if(ext->long_mode == LV_LABEL_LONG_BREAK) {
 8022762:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8022764:	7f9b      	ldrb	r3, [r3, #30]
 8022766:	f003 0307 	and.w	r3, r3, #7
 802276a:	b2db      	uxtb	r3, r3
 802276c:	2b01      	cmp	r3, #1
 802276e:	d105      	bne.n	802277c <lv_label_refr_text+0x530>
        lv_obj_set_height(label, size.y);
 8022770:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8022774:	4619      	mov	r1, r3
 8022776:	6878      	ldr	r0, [r7, #4]
 8022778:	f7ee fdad 	bl	80112d6 <lv_obj_set_height>
    /*Do not set the size in Clip mode*/
    else if(ext->long_mode == LV_LABEL_LONG_CROP) {
        /*Do nothing*/
    }

    lv_obj_invalidate(label);
 802277c:	6878      	ldr	r0, [r7, #4]
 802277e:	f7ee fb56 	bl	8010e2e <lv_obj_invalidate>
 8022782:	e000      	b.n	8022786 <lv_label_refr_text+0x53a>
    if(ext->text == NULL) return;
 8022784:	bf00      	nop
}
 8022786:	3764      	adds	r7, #100	; 0x64
 8022788:	46bd      	mov	sp, r7
 802278a:	bd90      	pop	{r4, r7, pc}
 802278c:	20000c3c 	.word	0x20000c3c
 8022790:	20000c30 	.word	0x20000c30
 8022794:	20000c34 	.word	0x20000c34

08022798 <lv_label_revert_dots>:

static void lv_label_revert_dots(lv_obj_t * label)
{
 8022798:	b580      	push	{r7, lr}
 802279a:	b088      	sub	sp, #32
 802279c:	af00      	add	r7, sp, #0
 802279e:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80227a0:	6878      	ldr	r0, [r7, #4]
 80227a2:	f7ef fe46 	bl	8012432 <lv_obj_get_ext_attr>
 80227a6:	61b8      	str	r0, [r7, #24]
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 80227a8:	69bb      	ldr	r3, [r7, #24]
 80227aa:	7f9b      	ldrb	r3, [r3, #30]
 80227ac:	f003 0307 	and.w	r3, r3, #7
 80227b0:	b2db      	uxtb	r3, r3
 80227b2:	2b02      	cmp	r3, #2
 80227b4:	d142      	bne.n	802283c <lv_label_revert_dots+0xa4>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 80227b6:	69bb      	ldr	r3, [r7, #24]
 80227b8:	891b      	ldrh	r3, [r3, #8]
 80227ba:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80227be:	4293      	cmp	r3, r2
 80227c0:	d03e      	beq.n	8022840 <lv_label_revert_dots+0xa8>
    uint32_t letter_i = ext->dot_end - LV_LABEL_DOT_NUM;
 80227c2:	69bb      	ldr	r3, [r7, #24]
 80227c4:	891b      	ldrh	r3, [r3, #8]
 80227c6:	3b03      	subs	r3, #3
 80227c8:	617b      	str	r3, [r7, #20]
    uint32_t byte_i   = lv_txt_encoded_get_byte_id(ext->text, letter_i);
 80227ca:	4b1f      	ldr	r3, [pc, #124]	; (8022848 <lv_label_revert_dots+0xb0>)
 80227cc:	681b      	ldr	r3, [r3, #0]
 80227ce:	69ba      	ldr	r2, [r7, #24]
 80227d0:	6812      	ldr	r2, [r2, #0]
 80227d2:	6979      	ldr	r1, [r7, #20]
 80227d4:	4610      	mov	r0, r2
 80227d6:	4798      	blx	r3
 80227d8:	6138      	str	r0, [r7, #16]

    /*Restore the characters*/
    uint8_t i      = 0;
 80227da:	2300      	movs	r3, #0
 80227dc:	77fb      	strb	r3, [r7, #31]
    char * dot_tmp = lv_label_get_dot_tmp(label);
 80227de:	6878      	ldr	r0, [r7, #4]
 80227e0:	f000 f8aa 	bl	8022938 <lv_label_get_dot_tmp>
 80227e4:	60f8      	str	r0, [r7, #12]
    while(ext->text[byte_i + i] != '\0') {
 80227e6:	e00d      	b.n	8022804 <lv_label_revert_dots+0x6c>
        ext->text[byte_i + i] = dot_tmp[i];
 80227e8:	7ffb      	ldrb	r3, [r7, #31]
 80227ea:	68fa      	ldr	r2, [r7, #12]
 80227ec:	441a      	add	r2, r3
 80227ee:	69bb      	ldr	r3, [r7, #24]
 80227f0:	6819      	ldr	r1, [r3, #0]
 80227f2:	7ff8      	ldrb	r0, [r7, #31]
 80227f4:	693b      	ldr	r3, [r7, #16]
 80227f6:	4403      	add	r3, r0
 80227f8:	440b      	add	r3, r1
 80227fa:	7812      	ldrb	r2, [r2, #0]
 80227fc:	701a      	strb	r2, [r3, #0]
        i++;
 80227fe:	7ffb      	ldrb	r3, [r7, #31]
 8022800:	3301      	adds	r3, #1
 8022802:	77fb      	strb	r3, [r7, #31]
    while(ext->text[byte_i + i] != '\0') {
 8022804:	69bb      	ldr	r3, [r7, #24]
 8022806:	681a      	ldr	r2, [r3, #0]
 8022808:	7ff9      	ldrb	r1, [r7, #31]
 802280a:	693b      	ldr	r3, [r7, #16]
 802280c:	440b      	add	r3, r1
 802280e:	4413      	add	r3, r2
 8022810:	781b      	ldrb	r3, [r3, #0]
 8022812:	2b00      	cmp	r3, #0
 8022814:	d1e8      	bne.n	80227e8 <lv_label_revert_dots+0x50>
    }
    ext->text[byte_i + i] = dot_tmp[i];
 8022816:	7ffb      	ldrb	r3, [r7, #31]
 8022818:	68fa      	ldr	r2, [r7, #12]
 802281a:	441a      	add	r2, r3
 802281c:	69bb      	ldr	r3, [r7, #24]
 802281e:	6819      	ldr	r1, [r3, #0]
 8022820:	7ff8      	ldrb	r0, [r7, #31]
 8022822:	693b      	ldr	r3, [r7, #16]
 8022824:	4403      	add	r3, r0
 8022826:	440b      	add	r3, r1
 8022828:	7812      	ldrb	r2, [r2, #0]
 802282a:	701a      	strb	r2, [r3, #0]
    lv_label_dot_tmp_free(label);
 802282c:	6878      	ldr	r0, [r7, #4]
 802282e:	f000 f89b 	bl	8022968 <lv_label_dot_tmp_free>

    ext->dot_end = LV_LABEL_DOT_END_INV;
 8022832:	69bb      	ldr	r3, [r7, #24]
 8022834:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8022838:	811a      	strh	r2, [r3, #8]
 802283a:	e002      	b.n	8022842 <lv_label_revert_dots+0xaa>
    if(ext->long_mode != LV_LABEL_LONG_DOT) return;
 802283c:	bf00      	nop
 802283e:	e000      	b.n	8022842 <lv_label_revert_dots+0xaa>
    if(ext->dot_end == LV_LABEL_DOT_END_INV) return;
 8022840:	bf00      	nop
}
 8022842:	3720      	adds	r7, #32
 8022844:	46bd      	mov	sp, r7
 8022846:	bd80      	pop	{r7, pc}
 8022848:	20000c3c 	.word	0x20000c3c

0802284c <lv_label_set_offset_x>:

#if LV_USE_ANIMATION
static void lv_label_set_offset_x(lv_obj_t * label, lv_coord_t x)
{
 802284c:	b580      	push	{r7, lr}
 802284e:	b084      	sub	sp, #16
 8022850:	af00      	add	r7, sp, #0
 8022852:	6078      	str	r0, [r7, #4]
 8022854:	460b      	mov	r3, r1
 8022856:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8022858:	6878      	ldr	r0, [r7, #4]
 802285a:	f7ef fdea 	bl	8012432 <lv_obj_get_ext_attr>
 802285e:	60f8      	str	r0, [r7, #12]
    ext->offset.x        = x;
 8022860:	68fb      	ldr	r3, [r7, #12]
 8022862:	887a      	ldrh	r2, [r7, #2]
 8022864:	815a      	strh	r2, [r3, #10]
    lv_obj_invalidate(label);
 8022866:	6878      	ldr	r0, [r7, #4]
 8022868:	f7ee fae1 	bl	8010e2e <lv_obj_invalidate>
}
 802286c:	bf00      	nop
 802286e:	3710      	adds	r7, #16
 8022870:	46bd      	mov	sp, r7
 8022872:	bd80      	pop	{r7, pc}

08022874 <lv_label_set_offset_y>:

static void lv_label_set_offset_y(lv_obj_t * label, lv_coord_t y)
{
 8022874:	b580      	push	{r7, lr}
 8022876:	b084      	sub	sp, #16
 8022878:	af00      	add	r7, sp, #0
 802287a:	6078      	str	r0, [r7, #4]
 802287c:	460b      	mov	r3, r1
 802287e:	807b      	strh	r3, [r7, #2]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8022880:	6878      	ldr	r0, [r7, #4]
 8022882:	f7ef fdd6 	bl	8012432 <lv_obj_get_ext_attr>
 8022886:	60f8      	str	r0, [r7, #12]
    ext->offset.y        = y;
 8022888:	68fb      	ldr	r3, [r7, #12]
 802288a:	887a      	ldrh	r2, [r7, #2]
 802288c:	819a      	strh	r2, [r3, #12]
    lv_obj_invalidate(label);
 802288e:	6878      	ldr	r0, [r7, #4]
 8022890:	f7ee facd 	bl	8010e2e <lv_obj_invalidate>
}
 8022894:	bf00      	nop
 8022896:	3710      	adds	r7, #16
 8022898:	46bd      	mov	sp, r7
 802289a:	bd80      	pop	{r7, pc}

0802289c <lv_label_set_dot_tmp>:
 * @param label pointer to label object
 * @param len Number of characters to store.
 * @return true on success.
 */
static bool lv_label_set_dot_tmp(lv_obj_t * label, char * data, uint16_t len)
{
 802289c:	b580      	push	{r7, lr}
 802289e:	b086      	sub	sp, #24
 80228a0:	af00      	add	r7, sp, #0
 80228a2:	60f8      	str	r0, [r7, #12]
 80228a4:	60b9      	str	r1, [r7, #8]
 80228a6:	4613      	mov	r3, r2
 80228a8:	80fb      	strh	r3, [r7, #6]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 80228aa:	68f8      	ldr	r0, [r7, #12]
 80228ac:	f7ef fdc1 	bl	8012432 <lv_obj_get_ext_attr>
 80228b0:	6178      	str	r0, [r7, #20]
    lv_label_dot_tmp_free(label); /* Deallocate any existing space */
 80228b2:	68f8      	ldr	r0, [r7, #12]
 80228b4:	f000 f858 	bl	8022968 <lv_label_dot_tmp_free>
    if(len > sizeof(char *)) {
 80228b8:	88fb      	ldrh	r3, [r7, #6]
 80228ba:	2b04      	cmp	r3, #4
 80228bc:	d927      	bls.n	802290e <lv_label_set_dot_tmp+0x72>
        /* Memory needs to be allocated. Allocates an additional byte
         * for a NULL-terminator so it can be copied. */
        ext->dot.tmp_ptr = lv_mem_alloc(len + 1);
 80228be:	88fb      	ldrh	r3, [r7, #6]
 80228c0:	3301      	adds	r3, #1
 80228c2:	4618      	mov	r0, r3
 80228c4:	f7f9 ffe6 	bl	801c894 <lv_mem_alloc>
 80228c8:	4602      	mov	r2, r0
 80228ca:	697b      	ldr	r3, [r7, #20]
 80228cc:	605a      	str	r2, [r3, #4]
        if(ext->dot.tmp_ptr == NULL) {
 80228ce:	697b      	ldr	r3, [r7, #20]
 80228d0:	685b      	ldr	r3, [r3, #4]
 80228d2:	2b00      	cmp	r3, #0
 80228d4:	d108      	bne.n	80228e8 <lv_label_set_dot_tmp+0x4c>
            LV_LOG_ERROR("Failed to allocate memory for dot_tmp_ptr");
 80228d6:	4b16      	ldr	r3, [pc, #88]	; (8022930 <lv_label_set_dot_tmp+0x94>)
 80228d8:	f240 4291 	movw	r2, #1169	; 0x491
 80228dc:	4915      	ldr	r1, [pc, #84]	; (8022934 <lv_label_set_dot_tmp+0x98>)
 80228de:	2003      	movs	r0, #3
 80228e0:	f7f9 ff94 	bl	801c80c <lv_log_add>
            return false;
 80228e4:	2300      	movs	r3, #0
 80228e6:	e01f      	b.n	8022928 <lv_label_set_dot_tmp+0x8c>
        }
        memcpy(ext->dot.tmp_ptr, data, len);
 80228e8:	697b      	ldr	r3, [r7, #20]
 80228ea:	685b      	ldr	r3, [r3, #4]
 80228ec:	88fa      	ldrh	r2, [r7, #6]
 80228ee:	68b9      	ldr	r1, [r7, #8]
 80228f0:	4618      	mov	r0, r3
 80228f2:	f004 fc63 	bl	80271bc <memcpy>
        ext->dot.tmp_ptr[len] = '\0';
 80228f6:	697b      	ldr	r3, [r7, #20]
 80228f8:	685a      	ldr	r2, [r3, #4]
 80228fa:	88fb      	ldrh	r3, [r7, #6]
 80228fc:	4413      	add	r3, r2
 80228fe:	2200      	movs	r2, #0
 8022900:	701a      	strb	r2, [r3, #0]
        ext->dot_tmp_alloc    = true;
 8022902:	697a      	ldr	r2, [r7, #20]
 8022904:	7fd3      	ldrb	r3, [r2, #31]
 8022906:	f043 0302 	orr.w	r3, r3, #2
 802290a:	77d3      	strb	r3, [r2, #31]
 802290c:	e00b      	b.n	8022926 <lv_label_set_dot_tmp+0x8a>
    } else {
        /* Characters can be directly stored in object */
        ext->dot_tmp_alloc = false;
 802290e:	697a      	ldr	r2, [r7, #20]
 8022910:	7fd3      	ldrb	r3, [r2, #31]
 8022912:	f36f 0341 	bfc	r3, #1, #1
 8022916:	77d3      	strb	r3, [r2, #31]
        memcpy(ext->dot.tmp, data, len);
 8022918:	697b      	ldr	r3, [r7, #20]
 802291a:	3304      	adds	r3, #4
 802291c:	88fa      	ldrh	r2, [r7, #6]
 802291e:	68b9      	ldr	r1, [r7, #8]
 8022920:	4618      	mov	r0, r3
 8022922:	f004 fc4b 	bl	80271bc <memcpy>
    }
    return true;
 8022926:	2301      	movs	r3, #1
}
 8022928:	4618      	mov	r0, r3
 802292a:	3718      	adds	r7, #24
 802292c:	46bd      	mov	sp, r7
 802292e:	bd80      	pop	{r7, pc}
 8022930:	08029098 	.word	0x08029098
 8022934:	08029064 	.word	0x08029064

08022938 <lv_label_get_dot_tmp>:
 * Get the stored dot_tmp characters
 * @param label pointer to label object
 * @return char pointer to a stored characters. Is *not* necessarily NULL-terminated.
 */
static char * lv_label_get_dot_tmp(lv_obj_t * label)
{
 8022938:	b580      	push	{r7, lr}
 802293a:	b084      	sub	sp, #16
 802293c:	af00      	add	r7, sp, #0
 802293e:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8022940:	6878      	ldr	r0, [r7, #4]
 8022942:	f7ef fd76 	bl	8012432 <lv_obj_get_ext_attr>
 8022946:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc) {
 8022948:	68fb      	ldr	r3, [r7, #12]
 802294a:	7fdb      	ldrb	r3, [r3, #31]
 802294c:	f003 0302 	and.w	r3, r3, #2
 8022950:	b2db      	uxtb	r3, r3
 8022952:	2b00      	cmp	r3, #0
 8022954:	d002      	beq.n	802295c <lv_label_get_dot_tmp+0x24>
        return ext->dot.tmp_ptr;
 8022956:	68fb      	ldr	r3, [r7, #12]
 8022958:	685b      	ldr	r3, [r3, #4]
 802295a:	e001      	b.n	8022960 <lv_label_get_dot_tmp+0x28>
    } else {
        return ext->dot.tmp;
 802295c:	68fb      	ldr	r3, [r7, #12]
 802295e:	3304      	adds	r3, #4
    }
}
 8022960:	4618      	mov	r0, r3
 8022962:	3710      	adds	r7, #16
 8022964:	46bd      	mov	sp, r7
 8022966:	bd80      	pop	{r7, pc}

08022968 <lv_label_dot_tmp_free>:
 * Free the dot_tmp_ptr field if it was previously allocated.
 * Always clears the field
 * @param label pointer to label object.
 */
static void lv_label_dot_tmp_free(lv_obj_t * label)
{
 8022968:	b580      	push	{r7, lr}
 802296a:	b084      	sub	sp, #16
 802296c:	af00      	add	r7, sp, #0
 802296e:	6078      	str	r0, [r7, #4]
    lv_label_ext_t * ext = lv_obj_get_ext_attr(label);
 8022970:	6878      	ldr	r0, [r7, #4]
 8022972:	f7ef fd5e 	bl	8012432 <lv_obj_get_ext_attr>
 8022976:	60f8      	str	r0, [r7, #12]
    if(ext->dot_tmp_alloc && ext->dot.tmp_ptr) {
 8022978:	68fb      	ldr	r3, [r7, #12]
 802297a:	7fdb      	ldrb	r3, [r3, #31]
 802297c:	f003 0302 	and.w	r3, r3, #2
 8022980:	b2db      	uxtb	r3, r3
 8022982:	2b00      	cmp	r3, #0
 8022984:	d008      	beq.n	8022998 <lv_label_dot_tmp_free+0x30>
 8022986:	68fb      	ldr	r3, [r7, #12]
 8022988:	685b      	ldr	r3, [r3, #4]
 802298a:	2b00      	cmp	r3, #0
 802298c:	d004      	beq.n	8022998 <lv_label_dot_tmp_free+0x30>
        lv_mem_free(ext->dot.tmp_ptr);
 802298e:	68fb      	ldr	r3, [r7, #12]
 8022990:	685b      	ldr	r3, [r3, #4]
 8022992:	4618      	mov	r0, r3
 8022994:	f7f9 ffc6 	bl	801c924 <lv_mem_free>
    }
    ext->dot_tmp_alloc = false;
 8022998:	68fa      	ldr	r2, [r7, #12]
 802299a:	7fd3      	ldrb	r3, [r2, #31]
 802299c:	f36f 0341 	bfc	r3, #1, #1
 80229a0:	77d3      	strb	r3, [r2, #31]
    ext->dot.tmp_ptr   = NULL;
 80229a2:	68fb      	ldr	r3, [r7, #12]
 80229a4:	2200      	movs	r2, #0
 80229a6:	605a      	str	r2, [r3, #4]
}
 80229a8:	bf00      	nop
 80229aa:	3710      	adds	r7, #16
 80229ac:	46bd      	mov	sp, r7
 80229ae:	bd80      	pop	{r7, pc}

080229b0 <lv_area_copy>:
 * Copy an area
 * @param dest pointer to the destination area
 * @param src pointer to the source area
 */
inline static void lv_area_copy(lv_area_t * dest, const lv_area_t * src)
{
 80229b0:	b580      	push	{r7, lr}
 80229b2:	b082      	sub	sp, #8
 80229b4:	af00      	add	r7, sp, #0
 80229b6:	6078      	str	r0, [r7, #4]
 80229b8:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80229ba:	2208      	movs	r2, #8
 80229bc:	6839      	ldr	r1, [r7, #0]
 80229be:	6878      	ldr	r0, [r7, #4]
 80229c0:	f004 fbfc 	bl	80271bc <memcpy>
}
 80229c4:	bf00      	nop
 80229c6:	3708      	adds	r7, #8
 80229c8:	46bd      	mov	sp, r7
 80229ca:	bd80      	pop	{r7, pc}

080229cc <lv_area_get_width>:
 * Get the width of an area
 * @param area_p pointer to an area
 * @return the width of the area (if x1 == x2 -> width = 1)
 */
static inline lv_coord_t lv_area_get_width(const lv_area_t * area_p)
{
 80229cc:	b480      	push	{r7}
 80229ce:	b083      	sub	sp, #12
 80229d0:	af00      	add	r7, sp, #0
 80229d2:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80229d4:	687b      	ldr	r3, [r7, #4]
 80229d6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80229da:	b29a      	uxth	r2, r3
 80229dc:	687b      	ldr	r3, [r7, #4]
 80229de:	f9b3 3000 	ldrsh.w	r3, [r3]
 80229e2:	b29b      	uxth	r3, r3
 80229e4:	1ad3      	subs	r3, r2, r3
 80229e6:	b29b      	uxth	r3, r3
 80229e8:	3301      	adds	r3, #1
 80229ea:	b29b      	uxth	r3, r3
 80229ec:	b21b      	sxth	r3, r3
}
 80229ee:	4618      	mov	r0, r3
 80229f0:	370c      	adds	r7, #12
 80229f2:	46bd      	mov	sp, r7
 80229f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80229f8:	4770      	bx	lr

080229fa <lv_area_get_height>:
 * Get the height of an area
 * @param area_p pointer to an area
 * @return the height of the area (if y1 == y2 -> height = 1)
 */
static inline lv_coord_t lv_area_get_height(const lv_area_t * area_p)
{
 80229fa:	b480      	push	{r7}
 80229fc:	b083      	sub	sp, #12
 80229fe:	af00      	add	r7, sp, #0
 8022a00:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 8022a02:	687b      	ldr	r3, [r7, #4]
 8022a04:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8022a08:	b29a      	uxth	r2, r3
 8022a0a:	687b      	ldr	r3, [r7, #4]
 8022a0c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8022a10:	b29b      	uxth	r3, r3
 8022a12:	1ad3      	subs	r3, r2, r3
 8022a14:	b29b      	uxth	r3, r3
 8022a16:	3301      	adds	r3, #1
 8022a18:	b29b      	uxth	r3, r3
 8022a1a:	b21b      	sxth	r3, r3
}
 8022a1c:	4618      	mov	r0, r3
 8022a1e:	370c      	adds	r7, #12
 8022a20:	46bd      	mov	sp, r7
 8022a22:	f85d 7b04 	ldr.w	r7, [sp], #4
 8022a26:	4770      	bx	lr

08022a28 <lv_page_get_scrl_width>:
{
 8022a28:	b580      	push	{r7, lr}
 8022a2a:	b082      	sub	sp, #8
 8022a2c:	af00      	add	r7, sp, #0
 8022a2e:	6078      	str	r0, [r7, #4]
    return lv_obj_get_width(lv_page_get_scrl(page));
 8022a30:	6878      	ldr	r0, [r7, #4]
 8022a32:	f000 fa6f 	bl	8022f14 <lv_page_get_scrl>
 8022a36:	4603      	mov	r3, r0
 8022a38:	4618      	mov	r0, r3
 8022a3a:	f7ef fbab 	bl	8012194 <lv_obj_get_width>
 8022a3e:	4603      	mov	r3, r0
}
 8022a40:	4618      	mov	r0, r3
 8022a42:	3708      	adds	r7, #8
 8022a44:	46bd      	mov	sp, r7
 8022a46:	bd80      	pop	{r7, pc}

08022a48 <lv_page_get_scrl_fit_left>:
{
 8022a48:	b580      	push	{r7, lr}
 8022a4a:	b082      	sub	sp, #8
 8022a4c:	af00      	add	r7, sp, #0
 8022a4e:	6078      	str	r0, [r7, #4]
    return lv_cont_get_fit_left(lv_page_get_scrl(page));
 8022a50:	6878      	ldr	r0, [r7, #4]
 8022a52:	f000 fa5f 	bl	8022f14 <lv_page_get_scrl>
 8022a56:	4603      	mov	r3, r0
 8022a58:	4618      	mov	r0, r3
 8022a5a:	f7fc fcba 	bl	801f3d2 <lv_cont_get_fit_left>
 8022a5e:	4603      	mov	r3, r0
}
 8022a60:	4618      	mov	r0, r3
 8022a62:	3708      	adds	r7, #8
 8022a64:	46bd      	mov	sp, r7
 8022a66:	bd80      	pop	{r7, pc}

08022a68 <lv_page_get_scrl_fit_top>:
{
 8022a68:	b580      	push	{r7, lr}
 8022a6a:	b082      	sub	sp, #8
 8022a6c:	af00      	add	r7, sp, #0
 8022a6e:	6078      	str	r0, [r7, #4]
    return lv_cont_get_fit_top(lv_page_get_scrl(page));
 8022a70:	6878      	ldr	r0, [r7, #4]
 8022a72:	f000 fa4f 	bl	8022f14 <lv_page_get_scrl>
 8022a76:	4603      	mov	r3, r0
 8022a78:	4618      	mov	r0, r3
 8022a7a:	f7fc fcbb 	bl	801f3f4 <lv_cont_get_fit_top>
 8022a7e:	4603      	mov	r3, r0
}
 8022a80:	4618      	mov	r0, r3
 8022a82:	3708      	adds	r7, #8
 8022a84:	46bd      	mov	sp, r7
 8022a86:	bd80      	pop	{r7, pc}

08022a88 <lv_page_create>:
 * @param par pointer to an object, it will be the parent of the new page
 * @param copy pointer to a page object, if not NULL then the new object will be copied from it
 * @return pointer to the created page
 */
lv_obj_t * lv_page_create(lv_obj_t * par, const lv_obj_t * copy)
{
 8022a88:	b580      	push	{r7, lr}
 8022a8a:	b088      	sub	sp, #32
 8022a8c:	af02      	add	r7, sp, #8
 8022a8e:	6078      	str	r0, [r7, #4]
 8022a90:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("page create started");

    /*Create the ancestor object*/
    lv_obj_t * new_page = lv_cont_create(par, copy);
 8022a92:	6839      	ldr	r1, [r7, #0]
 8022a94:	6878      	ldr	r0, [r7, #4]
 8022a96:	f7fc fb43 	bl	801f120 <lv_cont_create>
 8022a9a:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_page);
 8022a9c:	697b      	ldr	r3, [r7, #20]
 8022a9e:	2b00      	cmp	r3, #0
 8022aa0:	d106      	bne.n	8022ab0 <lv_page_create+0x28>
 8022aa2:	4bad      	ldr	r3, [pc, #692]	; (8022d58 <lv_page_create+0x2d0>)
 8022aa4:	2250      	movs	r2, #80	; 0x50
 8022aa6:	49ad      	ldr	r1, [pc, #692]	; (8022d5c <lv_page_create+0x2d4>)
 8022aa8:	2003      	movs	r0, #3
 8022aaa:	f7f9 feaf 	bl	801c80c <lv_log_add>
 8022aae:	e7fe      	b.n	8022aae <lv_page_create+0x26>
    if(new_page == NULL) return NULL;
 8022ab0:	697b      	ldr	r3, [r7, #20]
 8022ab2:	2b00      	cmp	r3, #0
 8022ab4:	d101      	bne.n	8022aba <lv_page_create+0x32>
 8022ab6:	2300      	movs	r3, #0
 8022ab8:	e149      	b.n	8022d4e <lv_page_create+0x2c6>

    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_page);
 8022aba:	4ba9      	ldr	r3, [pc, #676]	; (8022d60 <lv_page_create+0x2d8>)
 8022abc:	681b      	ldr	r3, [r3, #0]
 8022abe:	2b00      	cmp	r3, #0
 8022ac0:	d105      	bne.n	8022ace <lv_page_create+0x46>
 8022ac2:	6978      	ldr	r0, [r7, #20]
 8022ac4:	f7ef fc9d 	bl	8012402 <lv_obj_get_signal_cb>
 8022ac8:	4602      	mov	r2, r0
 8022aca:	4ba5      	ldr	r3, [pc, #660]	; (8022d60 <lv_page_create+0x2d8>)
 8022acc:	601a      	str	r2, [r3, #0]
    if(ancestor_design == NULL) ancestor_design = lv_obj_get_design_cb(new_page);
 8022ace:	4ba5      	ldr	r3, [pc, #660]	; (8022d64 <lv_page_create+0x2dc>)
 8022ad0:	681b      	ldr	r3, [r3, #0]
 8022ad2:	2b00      	cmp	r3, #0
 8022ad4:	d105      	bne.n	8022ae2 <lv_page_create+0x5a>
 8022ad6:	6978      	ldr	r0, [r7, #20]
 8022ad8:	f7ef fc9f 	bl	801241a <lv_obj_get_design_cb>
 8022adc:	4602      	mov	r2, r0
 8022ade:	4ba1      	ldr	r3, [pc, #644]	; (8022d64 <lv_page_create+0x2dc>)
 8022ae0:	601a      	str	r2, [r3, #0]

    /*Allocate the object type specific extended data*/
    lv_page_ext_t * ext = lv_obj_allocate_ext_attr(new_page, sizeof(lv_page_ext_t));
 8022ae2:	2130      	movs	r1, #48	; 0x30
 8022ae4:	6978      	ldr	r0, [r7, #20]
 8022ae6:	f7ef fa67 	bl	8011fb8 <lv_obj_allocate_ext_attr>
 8022aea:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 8022aec:	693b      	ldr	r3, [r7, #16]
 8022aee:	2b00      	cmp	r3, #0
 8022af0:	d106      	bne.n	8022b00 <lv_page_create+0x78>
 8022af2:	4b99      	ldr	r3, [pc, #612]	; (8022d58 <lv_page_create+0x2d0>)
 8022af4:	2258      	movs	r2, #88	; 0x58
 8022af6:	4999      	ldr	r1, [pc, #612]	; (8022d5c <lv_page_create+0x2d4>)
 8022af8:	2003      	movs	r0, #3
 8022afa:	f7f9 fe87 	bl	801c80c <lv_log_add>
 8022afe:	e7fe      	b.n	8022afe <lv_page_create+0x76>
    if(ext == NULL) return NULL;
 8022b00:	693b      	ldr	r3, [r7, #16]
 8022b02:	2b00      	cmp	r3, #0
 8022b04:	d101      	bne.n	8022b0a <lv_page_create+0x82>
 8022b06:	2300      	movs	r3, #0
 8022b08:	e121      	b.n	8022d4e <lv_page_create+0x2c6>

    ext->scrl        = NULL;
 8022b0a:	693b      	ldr	r3, [r7, #16]
 8022b0c:	2200      	movs	r2, #0
 8022b0e:	605a      	str	r2, [r3, #4]
    ext->sb.hor_draw = 0;
 8022b10:	693a      	ldr	r2, [r7, #16]
 8022b12:	7f13      	ldrb	r3, [r2, #28]
 8022b14:	f36f 0300 	bfc	r3, #0, #1
 8022b18:	7713      	strb	r3, [r2, #28]
    ext->sb.ver_draw = 0;
 8022b1a:	693a      	ldr	r2, [r7, #16]
 8022b1c:	7f13      	ldrb	r3, [r2, #28]
 8022b1e:	f36f 0341 	bfc	r3, #1, #1
 8022b22:	7713      	strb	r3, [r2, #28]
    ext->sb.style    = &lv_style_pretty;
 8022b24:	693b      	ldr	r3, [r7, #16]
 8022b26:	4a90      	ldr	r2, [pc, #576]	; (8022d68 <lv_page_create+0x2e0>)
 8022b28:	609a      	str	r2, [r3, #8]
    ext->sb.mode     = LV_SB_MODE_AUTO;
 8022b2a:	693a      	ldr	r2, [r7, #16]
 8022b2c:	7f13      	ldrb	r3, [r2, #28]
 8022b2e:	2103      	movs	r1, #3
 8022b30:	f361 0384 	bfi	r3, r1, #2, #3
 8022b34:	7713      	strb	r3, [r2, #28]
#if LV_USE_ANIMATION
    ext->edge_flash.enabled   = 0;
 8022b36:	693a      	ldr	r2, [r7, #16]
 8022b38:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8022b3c:	f36f 0300 	bfc	r3, #0, #1
 8022b40:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.bottom_ip = 0;
 8022b44:	693a      	ldr	r2, [r7, #16]
 8022b46:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8022b4a:	f36f 0382 	bfc	r3, #2, #1
 8022b4e:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.top_ip    = 0;
 8022b52:	693a      	ldr	r2, [r7, #16]
 8022b54:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8022b58:	f36f 0341 	bfc	r3, #1, #1
 8022b5c:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.left_ip   = 0;
 8022b60:	693a      	ldr	r2, [r7, #16]
 8022b62:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8022b66:	f36f 1304 	bfc	r3, #4, #1
 8022b6a:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.right_ip  = 0;
 8022b6e:	693a      	ldr	r2, [r7, #16]
 8022b70:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8022b74:	f36f 03c3 	bfc	r3, #3, #1
 8022b78:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.state     = 0;
 8022b7c:	693b      	ldr	r3, [r7, #16]
 8022b7e:	2200      	movs	r2, #0
 8022b80:	841a      	strh	r2, [r3, #32]
    ext->edge_flash.style     = &lv_style_plain_color;
 8022b82:	693b      	ldr	r3, [r7, #16]
 8022b84:	4a79      	ldr	r2, [pc, #484]	; (8022d6c <lv_page_create+0x2e4>)
 8022b86:	625a      	str	r2, [r3, #36]	; 0x24
    ext->anim_time            = LV_PAGE_DEF_ANIM_TIME;
 8022b88:	693b      	ldr	r3, [r7, #16]
 8022b8a:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8022b8e:	859a      	strh	r2, [r3, #44]	; 0x2c
#endif
    ext->scroll_prop    = 0;
 8022b90:	693a      	ldr	r2, [r7, #16]
 8022b92:	f892 302e 	ldrb.w	r3, [r2, #46]	; 0x2e
 8022b96:	f36f 0300 	bfc	r3, #0, #1
 8022b9a:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
    ext->scroll_prop_ip = 0;
 8022b9e:	693a      	ldr	r2, [r7, #16]
 8022ba0:	f892 302e 	ldrb.w	r3, [r2, #46]	; 0x2e
 8022ba4:	f36f 0341 	bfc	r3, #1, #1
 8022ba8:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e

    /*Init the new page object*/
    if(copy == NULL) {
 8022bac:	683b      	ldr	r3, [r7, #0]
 8022bae:	2b00      	cmp	r3, #0
 8022bb0:	f040 8084 	bne.w	8022cbc <lv_page_create+0x234>
        ext->scrl = lv_cont_create(new_page, NULL);
 8022bb4:	2100      	movs	r1, #0
 8022bb6:	6978      	ldr	r0, [r7, #20]
 8022bb8:	f7fc fab2 	bl	801f120 <lv_cont_create>
 8022bbc:	4602      	mov	r2, r0
 8022bbe:	693b      	ldr	r3, [r7, #16]
 8022bc0:	605a      	str	r2, [r3, #4]
        lv_obj_set_signal_cb(ext->scrl, lv_page_scrollable_signal);
 8022bc2:	693b      	ldr	r3, [r7, #16]
 8022bc4:	685b      	ldr	r3, [r3, #4]
 8022bc6:	496a      	ldr	r1, [pc, #424]	; (8022d70 <lv_page_create+0x2e8>)
 8022bc8:	4618      	mov	r0, r3
 8022bca:	f7ef f9d9 	bl	8011f80 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(ext->scrl, lv_scrl_design);
 8022bce:	693b      	ldr	r3, [r7, #16]
 8022bd0:	685b      	ldr	r3, [r3, #4]
 8022bd2:	4968      	ldr	r1, [pc, #416]	; (8022d74 <lv_page_create+0x2ec>)
 8022bd4:	4618      	mov	r0, r3
 8022bd6:	f7ef f9e1 	bl	8011f9c <lv_obj_set_design_cb>
        lv_obj_set_drag(ext->scrl, true);
 8022bda:	693b      	ldr	r3, [r7, #16]
 8022bdc:	685b      	ldr	r3, [r3, #4]
 8022bde:	2101      	movs	r1, #1
 8022be0:	4618      	mov	r0, r3
 8022be2:	f7ef f8d4 	bl	8011d8e <lv_obj_set_drag>
        lv_obj_set_drag_throw(ext->scrl, true);
 8022be6:	693b      	ldr	r3, [r7, #16]
 8022be8:	685b      	ldr	r3, [r3, #4]
 8022bea:	2101      	movs	r1, #1
 8022bec:	4618      	mov	r0, r3
 8022bee:	f7ef f8e7 	bl	8011dc0 <lv_obj_set_drag_throw>
        lv_obj_set_protect(ext->scrl, LV_PROTECT_PARENT | LV_PROTECT_PRESS_LOST);
 8022bf2:	693b      	ldr	r3, [r7, #16]
 8022bf4:	685b      	ldr	r3, [r3, #4]
 8022bf6:	2112      	movs	r1, #18
 8022bf8:	4618      	mov	r0, r3
 8022bfa:	f7ef f8f5 	bl	8011de8 <lv_obj_set_protect>
        lv_cont_set_fit4(ext->scrl, LV_FIT_FILL, LV_FIT_FILL, LV_FIT_FILL, LV_FIT_FILL);
 8022bfe:	693b      	ldr	r3, [r7, #16]
 8022c00:	6858      	ldr	r0, [r3, #4]
 8022c02:	2303      	movs	r3, #3
 8022c04:	9300      	str	r3, [sp, #0]
 8022c06:	2303      	movs	r3, #3
 8022c08:	2203      	movs	r2, #3
 8022c0a:	2103      	movs	r1, #3
 8022c0c:	f7fc fb69 	bl	801f2e2 <lv_cont_set_fit4>
        lv_obj_set_event_cb(ext->scrl, scrl_def_event_cb); /*Propagate some event to the background
 8022c10:	693b      	ldr	r3, [r7, #16]
 8022c12:	685b      	ldr	r3, [r3, #4]
 8022c14:	4958      	ldr	r1, [pc, #352]	; (8022d78 <lv_page_create+0x2f0>)
 8022c16:	4618      	mov	r0, r3
 8022c18:	f7ef f913 	bl	8011e42 <lv_obj_set_event_cb>
                                                              object by default for convenience */

        /* Add the signal function only if 'scrolling' is created
         * because everything has to be ready before any signal is received*/
        lv_obj_set_signal_cb(new_page, lv_page_signal);
 8022c1c:	4957      	ldr	r1, [pc, #348]	; (8022d7c <lv_page_create+0x2f4>)
 8022c1e:	6978      	ldr	r0, [r7, #20]
 8022c20:	f7ef f9ae 	bl	8011f80 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_page, lv_page_design);
 8022c24:	4956      	ldr	r1, [pc, #344]	; (8022d80 <lv_page_create+0x2f8>)
 8022c26:	6978      	ldr	r0, [r7, #20]
 8022c28:	f7ef f9b8 	bl	8011f9c <lv_obj_set_design_cb>

        lv_page_set_sb_mode(new_page, ext->sb.mode);
 8022c2c:	693b      	ldr	r3, [r7, #16]
 8022c2e:	7f1b      	ldrb	r3, [r3, #28]
 8022c30:	f3c3 0382 	ubfx	r3, r3, #2, #3
 8022c34:	b2db      	uxtb	r3, r3
 8022c36:	4619      	mov	r1, r3
 8022c38:	6978      	ldr	r0, [r7, #20]
 8022c3a:	f000 f8a7 	bl	8022d8c <lv_page_set_sb_mode>

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 8022c3e:	f002 fea7 	bl	8025990 <lv_theme_get_current>
 8022c42:	60b8      	str	r0, [r7, #8]
        if(th) {
 8022c44:	68bb      	ldr	r3, [r7, #8]
 8022c46:	2b00      	cmp	r3, #0
 8022c48:	d028      	beq.n	8022c9c <lv_page_create+0x214>
            if(par == NULL) { /*Different styles if it is screen*/
 8022c4a:	687b      	ldr	r3, [r7, #4]
 8022c4c:	2b00      	cmp	r3, #0
 8022c4e:	d10c      	bne.n	8022c6a <lv_page_create+0x1e2>
                lv_page_set_style(new_page, LV_PAGE_STYLE_BG, th->style.bg);
 8022c50:	68bb      	ldr	r3, [r7, #8]
 8022c52:	685b      	ldr	r3, [r3, #4]
 8022c54:	461a      	mov	r2, r3
 8022c56:	2100      	movs	r1, #0
 8022c58:	6978      	ldr	r0, [r7, #20]
 8022c5a:	f000 f909 	bl	8022e70 <lv_page_set_style>
                lv_page_set_style(new_page, LV_PAGE_STYLE_SCRL, &lv_style_transp);
 8022c5e:	4a49      	ldr	r2, [pc, #292]	; (8022d84 <lv_page_create+0x2fc>)
 8022c60:	2101      	movs	r1, #1
 8022c62:	6978      	ldr	r0, [r7, #20]
 8022c64:	f000 f904 	bl	8022e70 <lv_page_set_style>
 8022c68:	e00f      	b.n	8022c8a <lv_page_create+0x202>
            } else {
                lv_page_set_style(new_page, LV_PAGE_STYLE_BG, th->style.page.bg);
 8022c6a:	68bb      	ldr	r3, [r7, #8]
 8022c6c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 8022c70:	461a      	mov	r2, r3
 8022c72:	2100      	movs	r1, #0
 8022c74:	6978      	ldr	r0, [r7, #20]
 8022c76:	f000 f8fb 	bl	8022e70 <lv_page_set_style>
                lv_page_set_style(new_page, LV_PAGE_STYLE_SCRL, th->style.page.scrl);
 8022c7a:	68bb      	ldr	r3, [r7, #8]
 8022c7c:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8022c80:	461a      	mov	r2, r3
 8022c82:	2101      	movs	r1, #1
 8022c84:	6978      	ldr	r0, [r7, #20]
 8022c86:	f000 f8f3 	bl	8022e70 <lv_page_set_style>
            }
            lv_page_set_style(new_page, LV_PAGE_STYLE_SB, th->style.page.sb);
 8022c8a:	68bb      	ldr	r3, [r7, #8]
 8022c8c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8022c90:	461a      	mov	r2, r3
 8022c92:	2102      	movs	r1, #2
 8022c94:	6978      	ldr	r0, [r7, #20]
 8022c96:	f000 f8eb 	bl	8022e70 <lv_page_set_style>
 8022c9a:	e054      	b.n	8022d46 <lv_page_create+0x2be>
        } else {
            lv_page_set_style(new_page, LV_PAGE_STYLE_BG, &lv_style_pretty_color);
 8022c9c:	4a3a      	ldr	r2, [pc, #232]	; (8022d88 <lv_page_create+0x300>)
 8022c9e:	2100      	movs	r1, #0
 8022ca0:	6978      	ldr	r0, [r7, #20]
 8022ca2:	f000 f8e5 	bl	8022e70 <lv_page_set_style>
            lv_page_set_style(new_page, LV_PAGE_STYLE_SCRL, &lv_style_pretty);
 8022ca6:	4a30      	ldr	r2, [pc, #192]	; (8022d68 <lv_page_create+0x2e0>)
 8022ca8:	2101      	movs	r1, #1
 8022caa:	6978      	ldr	r0, [r7, #20]
 8022cac:	f000 f8e0 	bl	8022e70 <lv_page_set_style>
            lv_page_set_style(new_page, LV_PAGE_STYLE_SB, &lv_style_pretty_color);
 8022cb0:	4a35      	ldr	r2, [pc, #212]	; (8022d88 <lv_page_create+0x300>)
 8022cb2:	2102      	movs	r1, #2
 8022cb4:	6978      	ldr	r0, [r7, #20]
 8022cb6:	f000 f8db 	bl	8022e70 <lv_page_set_style>
 8022cba:	e044      	b.n	8022d46 <lv_page_create+0x2be>
        }

    } else {
        lv_page_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 8022cbc:	6838      	ldr	r0, [r7, #0]
 8022cbe:	f7ef fbb8 	bl	8012432 <lv_obj_get_ext_attr>
 8022cc2:	60f8      	str	r0, [r7, #12]
        ext->scrl                = lv_cont_create(new_page, copy_ext->scrl);
 8022cc4:	68fb      	ldr	r3, [r7, #12]
 8022cc6:	685b      	ldr	r3, [r3, #4]
 8022cc8:	4619      	mov	r1, r3
 8022cca:	6978      	ldr	r0, [r7, #20]
 8022ccc:	f7fc fa28 	bl	801f120 <lv_cont_create>
 8022cd0:	4602      	mov	r2, r0
 8022cd2:	693b      	ldr	r3, [r7, #16]
 8022cd4:	605a      	str	r2, [r3, #4]
        lv_obj_set_signal_cb(ext->scrl, lv_page_scrollable_signal);
 8022cd6:	693b      	ldr	r3, [r7, #16]
 8022cd8:	685b      	ldr	r3, [r3, #4]
 8022cda:	4925      	ldr	r1, [pc, #148]	; (8022d70 <lv_page_create+0x2e8>)
 8022cdc:	4618      	mov	r0, r3
 8022cde:	f7ef f94f 	bl	8011f80 <lv_obj_set_signal_cb>

        lv_page_set_sb_mode(new_page, copy_ext->sb.mode);
 8022ce2:	68fb      	ldr	r3, [r7, #12]
 8022ce4:	7f1b      	ldrb	r3, [r3, #28]
 8022ce6:	f3c3 0382 	ubfx	r3, r3, #2, #3
 8022cea:	b2db      	uxtb	r3, r3
 8022cec:	4619      	mov	r1, r3
 8022cee:	6978      	ldr	r0, [r7, #20]
 8022cf0:	f000 f84c 	bl	8022d8c <lv_page_set_sb_mode>

        lv_page_set_style(new_page, LV_PAGE_STYLE_BG, lv_page_get_style(copy, LV_PAGE_STYLE_BG));
 8022cf4:	2100      	movs	r1, #0
 8022cf6:	6838      	ldr	r0, [r7, #0]
 8022cf8:	f000 f928 	bl	8022f4c <lv_page_get_style>
 8022cfc:	4603      	mov	r3, r0
 8022cfe:	461a      	mov	r2, r3
 8022d00:	2100      	movs	r1, #0
 8022d02:	6978      	ldr	r0, [r7, #20]
 8022d04:	f000 f8b4 	bl	8022e70 <lv_page_set_style>
        lv_page_set_style(new_page, LV_PAGE_STYLE_SCRL, lv_page_get_style(copy, LV_PAGE_STYLE_SCRL));
 8022d08:	2101      	movs	r1, #1
 8022d0a:	6838      	ldr	r0, [r7, #0]
 8022d0c:	f000 f91e 	bl	8022f4c <lv_page_get_style>
 8022d10:	4603      	mov	r3, r0
 8022d12:	461a      	mov	r2, r3
 8022d14:	2101      	movs	r1, #1
 8022d16:	6978      	ldr	r0, [r7, #20]
 8022d18:	f000 f8aa 	bl	8022e70 <lv_page_set_style>
        lv_page_set_style(new_page, LV_PAGE_STYLE_SB, lv_page_get_style(copy, LV_PAGE_STYLE_SB));
 8022d1c:	2102      	movs	r1, #2
 8022d1e:	6838      	ldr	r0, [r7, #0]
 8022d20:	f000 f914 	bl	8022f4c <lv_page_get_style>
 8022d24:	4603      	mov	r3, r0
 8022d26:	461a      	mov	r2, r3
 8022d28:	2102      	movs	r1, #2
 8022d2a:	6978      	ldr	r0, [r7, #20]
 8022d2c:	f000 f8a0 	bl	8022e70 <lv_page_set_style>

        /* Add the signal function only if 'scrolling' is created
         * because everything has to be ready before any signal is received*/
        lv_obj_set_signal_cb(new_page, lv_page_signal);
 8022d30:	4912      	ldr	r1, [pc, #72]	; (8022d7c <lv_page_create+0x2f4>)
 8022d32:	6978      	ldr	r0, [r7, #20]
 8022d34:	f7ef f924 	bl	8011f80 <lv_obj_set_signal_cb>
        lv_obj_set_design_cb(new_page, lv_page_design);
 8022d38:	4911      	ldr	r1, [pc, #68]	; (8022d80 <lv_page_create+0x2f8>)
 8022d3a:	6978      	ldr	r0, [r7, #20]
 8022d3c:	f7ef f92e 	bl	8011f9c <lv_obj_set_design_cb>

        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_page);
 8022d40:	6978      	ldr	r0, [r7, #20]
 8022d42:	f7ee ffc8 	bl	8011cd6 <lv_obj_refresh_style>
    }

    lv_page_sb_refresh(new_page);
 8022d46:	6978      	ldr	r0, [r7, #20]
 8022d48:	f001 fa84 	bl	8024254 <lv_page_sb_refresh>

    LV_LOG_INFO("page created");

    return new_page;
 8022d4c:	697b      	ldr	r3, [r7, #20]
}
 8022d4e:	4618      	mov	r0, r3
 8022d50:	3718      	adds	r7, #24
 8022d52:	46bd      	mov	sp, r7
 8022d54:	bd80      	pop	{r7, pc}
 8022d56:	bf00      	nop
 8022d58:	080290c4 	.word	0x080290c4
 8022d5c:	080290d4 	.word	0x080290d4
 8022d60:	2000c3e4 	.word	0x2000c3e4
 8022d64:	2000c3e0 	.word	0x2000c3e0
 8022d68:	2000dd28 	.word	0x2000dd28
 8022d6c:	2000df08 	.word	0x2000df08
 8022d70:	08023ac5 	.word	0x08023ac5
 8022d74:	08023621 	.word	0x08023621
 8022d78:	080241f9 	.word	0x080241f9
 8022d7c:	080236f9 	.word	0x080236f9
 8022d80:	08023135 	.word	0x08023135
 8022d84:	2000dc74 	.word	0x2000dc74
 8022d88:	2000dc38 	.word	0x2000dc38

08022d8c <lv_page_set_sb_mode>:
 * Set the scroll bar mode on a page
 * @param page pointer to a page object
 * @param sb_mode the new mode from 'lv_page_sb.mode_t' enum
 */
void lv_page_set_sb_mode(lv_obj_t * page, lv_sb_mode_t sb_mode)
{
 8022d8c:	b580      	push	{r7, lr}
 8022d8e:	b084      	sub	sp, #16
 8022d90:	af00      	add	r7, sp, #0
 8022d92:	6078      	str	r0, [r7, #4]
 8022d94:	460b      	mov	r3, r1
 8022d96:	70fb      	strb	r3, [r7, #3]
    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 8022d98:	6878      	ldr	r0, [r7, #4]
 8022d9a:	f7ef fb4a 	bl	8012432 <lv_obj_get_ext_attr>
 8022d9e:	60f8      	str	r0, [r7, #12]
    if(ext->sb.mode == sb_mode) return;
 8022da0:	68fb      	ldr	r3, [r7, #12]
 8022da2:	7f1b      	ldrb	r3, [r3, #28]
 8022da4:	f3c3 0382 	ubfx	r3, r3, #2, #3
 8022da8:	b2db      	uxtb	r3, r3
 8022daa:	461a      	mov	r2, r3
 8022dac:	78fb      	ldrb	r3, [r7, #3]
 8022dae:	429a      	cmp	r2, r3
 8022db0:	d048      	beq.n	8022e44 <lv_page_set_sb_mode+0xb8>

    if(sb_mode == LV_SB_MODE_HIDE)
 8022db2:	78fb      	ldrb	r3, [r7, #3]
 8022db4:	2b04      	cmp	r3, #4
 8022db6:	d10d      	bne.n	8022dd4 <lv_page_set_sb_mode+0x48>
        ext->sb.mode |= LV_SB_MODE_HIDE; /*Set the hidden flag*/
 8022db8:	68fb      	ldr	r3, [r7, #12]
 8022dba:	7f1b      	ldrb	r3, [r3, #28]
 8022dbc:	f3c3 0382 	ubfx	r3, r3, #2, #3
 8022dc0:	b2db      	uxtb	r3, r3
 8022dc2:	f043 0304 	orr.w	r3, r3, #4
 8022dc6:	b2d9      	uxtb	r1, r3
 8022dc8:	68fa      	ldr	r2, [r7, #12]
 8022dca:	7f13      	ldrb	r3, [r2, #28]
 8022dcc:	f361 0384 	bfi	r3, r1, #2, #3
 8022dd0:	7713      	strb	r3, [r2, #28]
 8022dd2:	e026      	b.n	8022e22 <lv_page_set_sb_mode+0x96>
    else if(sb_mode == LV_SB_MODE_UNHIDE)
 8022dd4:	78fb      	ldrb	r3, [r7, #3]
 8022dd6:	2b05      	cmp	r3, #5
 8022dd8:	d10d      	bne.n	8022df6 <lv_page_set_sb_mode+0x6a>
        ext->sb.mode &= (~LV_SB_MODE_HIDE); /*Clear the hidden flag*/
 8022dda:	68fb      	ldr	r3, [r7, #12]
 8022ddc:	7f1b      	ldrb	r3, [r3, #28]
 8022dde:	f3c3 0382 	ubfx	r3, r3, #2, #3
 8022de2:	b2db      	uxtb	r3, r3
 8022de4:	f003 0303 	and.w	r3, r3, #3
 8022de8:	b2d9      	uxtb	r1, r3
 8022dea:	68fa      	ldr	r2, [r7, #12]
 8022dec:	7f13      	ldrb	r3, [r2, #28]
 8022dee:	f361 0384 	bfi	r3, r1, #2, #3
 8022df2:	7713      	strb	r3, [r2, #28]
 8022df4:	e015      	b.n	8022e22 <lv_page_set_sb_mode+0x96>
    else {
        if(ext->sb.mode & LV_SB_MODE_HIDE) sb_mode |= LV_SB_MODE_HIDE;
 8022df6:	68fb      	ldr	r3, [r7, #12]
 8022df8:	7f1b      	ldrb	r3, [r3, #28]
 8022dfa:	f3c3 0382 	ubfx	r3, r3, #2, #3
 8022dfe:	b2db      	uxtb	r3, r3
 8022e00:	f003 0304 	and.w	r3, r3, #4
 8022e04:	2b00      	cmp	r3, #0
 8022e06:	d003      	beq.n	8022e10 <lv_page_set_sb_mode+0x84>
 8022e08:	78fb      	ldrb	r3, [r7, #3]
 8022e0a:	f043 0304 	orr.w	r3, r3, #4
 8022e0e:	70fb      	strb	r3, [r7, #3]
        ext->sb.mode = sb_mode;
 8022e10:	78fb      	ldrb	r3, [r7, #3]
 8022e12:	f003 0307 	and.w	r3, r3, #7
 8022e16:	b2d9      	uxtb	r1, r3
 8022e18:	68fa      	ldr	r2, [r7, #12]
 8022e1a:	7f13      	ldrb	r3, [r2, #28]
 8022e1c:	f361 0384 	bfi	r3, r1, #2, #3
 8022e20:	7713      	strb	r3, [r2, #28]
    }

    ext->sb.hor_draw = 0;
 8022e22:	68fa      	ldr	r2, [r7, #12]
 8022e24:	7f13      	ldrb	r3, [r2, #28]
 8022e26:	f36f 0300 	bfc	r3, #0, #1
 8022e2a:	7713      	strb	r3, [r2, #28]
    ext->sb.ver_draw = 0;
 8022e2c:	68fa      	ldr	r2, [r7, #12]
 8022e2e:	7f13      	ldrb	r3, [r2, #28]
 8022e30:	f36f 0341 	bfc	r3, #1, #1
 8022e34:	7713      	strb	r3, [r2, #28]

    lv_page_sb_refresh(page);
 8022e36:	6878      	ldr	r0, [r7, #4]
 8022e38:	f001 fa0c 	bl	8024254 <lv_page_sb_refresh>
    lv_obj_invalidate(page);
 8022e3c:	6878      	ldr	r0, [r7, #4]
 8022e3e:	f7ed fff6 	bl	8010e2e <lv_obj_invalidate>
 8022e42:	e000      	b.n	8022e46 <lv_page_set_sb_mode+0xba>
    if(ext->sb.mode == sb_mode) return;
 8022e44:	bf00      	nop
}
 8022e46:	3710      	adds	r7, #16
 8022e48:	46bd      	mov	sp, r7
 8022e4a:	bd80      	pop	{r7, pc}

08022e4c <lv_page_set_anim_time>:
 * Set the animation time for the page
 * @param page pointer to a page object
 * @param anim_time animation time in milliseconds
 */
void lv_page_set_anim_time(lv_obj_t * page, uint16_t anim_time)
{
 8022e4c:	b580      	push	{r7, lr}
 8022e4e:	b084      	sub	sp, #16
 8022e50:	af00      	add	r7, sp, #0
 8022e52:	6078      	str	r0, [r7, #4]
 8022e54:	460b      	mov	r3, r1
 8022e56:	807b      	strh	r3, [r7, #2]
#if LV_USE_ANIMATION
    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 8022e58:	6878      	ldr	r0, [r7, #4]
 8022e5a:	f7ef faea 	bl	8012432 <lv_obj_get_ext_attr>
 8022e5e:	60f8      	str	r0, [r7, #12]
    ext->anim_time      = anim_time;
 8022e60:	68fb      	ldr	r3, [r7, #12]
 8022e62:	887a      	ldrh	r2, [r7, #2]
 8022e64:	859a      	strh	r2, [r3, #44]	; 0x2c
#else
    (void)page;      /*Unused*/
    (void)anim_time; /*Unused*/
#endif
}
 8022e66:	bf00      	nop
 8022e68:	3710      	adds	r7, #16
 8022e6a:	46bd      	mov	sp, r7
 8022e6c:	bd80      	pop	{r7, pc}
	...

08022e70 <lv_page_set_style>:
 * @param page pointer to a page object
 * @param type which style should be set
 * @param style pointer to a style
 *  */
void lv_page_set_style(lv_obj_t * page, lv_page_style_t type, const lv_style_t * style)
{
 8022e70:	b580      	push	{r7, lr}
 8022e72:	b086      	sub	sp, #24
 8022e74:	af00      	add	r7, sp, #0
 8022e76:	60f8      	str	r0, [r7, #12]
 8022e78:	460b      	mov	r3, r1
 8022e7a:	607a      	str	r2, [r7, #4]
 8022e7c:	72fb      	strb	r3, [r7, #11]
    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 8022e7e:	68f8      	ldr	r0, [r7, #12]
 8022e80:	f7ef fad7 	bl	8012432 <lv_obj_get_ext_attr>
 8022e84:	6178      	str	r0, [r7, #20]

    switch(type) {
 8022e86:	7afb      	ldrb	r3, [r7, #11]
 8022e88:	2b03      	cmp	r3, #3
 8022e8a:	d83e      	bhi.n	8022f0a <lv_page_set_style+0x9a>
 8022e8c:	a201      	add	r2, pc, #4	; (adr r2, 8022e94 <lv_page_set_style+0x24>)
 8022e8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022e92:	bf00      	nop
 8022e94:	08022ea5 	.word	0x08022ea5
 8022e98:	08022eaf 	.word	0x08022eaf
 8022e9c:	08022ebd 	.word	0x08022ebd
 8022ea0:	08022f03 	.word	0x08022f03
        case LV_PAGE_STYLE_BG: lv_obj_set_style(page, style); break;
 8022ea4:	6879      	ldr	r1, [r7, #4]
 8022ea6:	68f8      	ldr	r0, [r7, #12]
 8022ea8:	f7ee ff03 	bl	8011cb2 <lv_obj_set_style>
 8022eac:	e02d      	b.n	8022f0a <lv_page_set_style+0x9a>
        case LV_PAGE_STYLE_SCRL: lv_obj_set_style(ext->scrl, style); break;
 8022eae:	697b      	ldr	r3, [r7, #20]
 8022eb0:	685b      	ldr	r3, [r3, #4]
 8022eb2:	6879      	ldr	r1, [r7, #4]
 8022eb4:	4618      	mov	r0, r3
 8022eb6:	f7ee fefc 	bl	8011cb2 <lv_obj_set_style>
 8022eba:	e026      	b.n	8022f0a <lv_page_set_style+0x9a>
        case LV_PAGE_STYLE_SB:
            ext->sb.style = style;
 8022ebc:	697b      	ldr	r3, [r7, #20]
 8022ebe:	687a      	ldr	r2, [r7, #4]
 8022ec0:	609a      	str	r2, [r3, #8]
            lv_area_set_height(&ext->sb.hor_area, ext->sb.style->body.padding.inner);
 8022ec2:	697b      	ldr	r3, [r7, #20]
 8022ec4:	f103 020c 	add.w	r2, r3, #12
 8022ec8:	697b      	ldr	r3, [r7, #20]
 8022eca:	689b      	ldr	r3, [r3, #8]
 8022ecc:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8022ed0:	4619      	mov	r1, r3
 8022ed2:	4610      	mov	r0, r2
 8022ed4:	f7f8 fd9f 	bl	801ba16 <lv_area_set_height>
            lv_area_set_width(&ext->sb.ver_area, ext->sb.style->body.padding.inner);
 8022ed8:	697b      	ldr	r3, [r7, #20]
 8022eda:	f103 0214 	add.w	r2, r3, #20
 8022ede:	697b      	ldr	r3, [r7, #20]
 8022ee0:	689b      	ldr	r3, [r3, #8]
 8022ee2:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8022ee6:	4619      	mov	r1, r3
 8022ee8:	4610      	mov	r0, r2
 8022eea:	f7f8 fd7c 	bl	801b9e6 <lv_area_set_width>
            lv_page_sb_refresh(page);
 8022eee:	68f8      	ldr	r0, [r7, #12]
 8022ef0:	f001 f9b0 	bl	8024254 <lv_page_sb_refresh>
            lv_obj_refresh_ext_draw_pad(page);
 8022ef4:	68f8      	ldr	r0, [r7, #12]
 8022ef6:	f7ef f875 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>
            lv_obj_invalidate(page);
 8022efa:	68f8      	ldr	r0, [r7, #12]
 8022efc:	f7ed ff97 	bl	8010e2e <lv_obj_invalidate>
            break;
 8022f00:	e003      	b.n	8022f0a <lv_page_set_style+0x9a>
#if LV_USE_ANIMATION
        case LV_PAGE_STYLE_EDGE_FLASH: ext->edge_flash.style = style; break;
 8022f02:	697b      	ldr	r3, [r7, #20]
 8022f04:	687a      	ldr	r2, [r7, #4]
 8022f06:	625a      	str	r2, [r3, #36]	; 0x24
 8022f08:	bf00      	nop
#endif
    }
}
 8022f0a:	bf00      	nop
 8022f0c:	3718      	adds	r7, #24
 8022f0e:	46bd      	mov	sp, r7
 8022f10:	bd80      	pop	{r7, pc}
 8022f12:	bf00      	nop

08022f14 <lv_page_get_scrl>:
 * Get the scrollable object of a page
 * @param page pointer to a page object
 * @return pointer to a container which is the scrollable part of the page
 */
lv_obj_t * lv_page_get_scrl(const lv_obj_t * page)
{
 8022f14:	b580      	push	{r7, lr}
 8022f16:	b084      	sub	sp, #16
 8022f18:	af00      	add	r7, sp, #0
 8022f1a:	6078      	str	r0, [r7, #4]
    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 8022f1c:	6878      	ldr	r0, [r7, #4]
 8022f1e:	f7ef fa88 	bl	8012432 <lv_obj_get_ext_attr>
 8022f22:	60f8      	str	r0, [r7, #12]

    return ext->scrl;
 8022f24:	68fb      	ldr	r3, [r7, #12]
 8022f26:	685b      	ldr	r3, [r3, #4]
}
 8022f28:	4618      	mov	r0, r3
 8022f2a:	3710      	adds	r7, #16
 8022f2c:	46bd      	mov	sp, r7
 8022f2e:	bd80      	pop	{r7, pc}

08022f30 <lv_page_get_anim_time>:
 * Get the animation time
 * @param page pointer to a page object
 * @return the animation time in milliseconds
 */
uint16_t lv_page_get_anim_time(const lv_obj_t * page)
{
 8022f30:	b580      	push	{r7, lr}
 8022f32:	b084      	sub	sp, #16
 8022f34:	af00      	add	r7, sp, #0
 8022f36:	6078      	str	r0, [r7, #4]
#if LV_USE_ANIMATION
    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 8022f38:	6878      	ldr	r0, [r7, #4]
 8022f3a:	f7ef fa7a 	bl	8012432 <lv_obj_get_ext_attr>
 8022f3e:	60f8      	str	r0, [r7, #12]
    return ext->anim_time;
 8022f40:	68fb      	ldr	r3, [r7, #12]
 8022f42:	8d9b      	ldrh	r3, [r3, #44]	; 0x2c
#else
    (void)page; /*Unused*/
    return 0;
#endif
}
 8022f44:	4618      	mov	r0, r3
 8022f46:	3710      	adds	r7, #16
 8022f48:	46bd      	mov	sp, r7
 8022f4a:	bd80      	pop	{r7, pc}

08022f4c <lv_page_get_style>:
 * @param page pointer to page object
 * @param type which style should be get
 * @return style pointer to a style
 *  */
const lv_style_t * lv_page_get_style(const lv_obj_t * page, lv_page_style_t type)
{
 8022f4c:	b580      	push	{r7, lr}
 8022f4e:	b084      	sub	sp, #16
 8022f50:	af00      	add	r7, sp, #0
 8022f52:	6078      	str	r0, [r7, #4]
 8022f54:	460b      	mov	r3, r1
 8022f56:	70fb      	strb	r3, [r7, #3]
    const lv_style_t * style = NULL;
 8022f58:	2300      	movs	r3, #0
 8022f5a:	60fb      	str	r3, [r7, #12]
    lv_page_ext_t * ext      = lv_obj_get_ext_attr(page);
 8022f5c:	6878      	ldr	r0, [r7, #4]
 8022f5e:	f7ef fa68 	bl	8012432 <lv_obj_get_ext_attr>
 8022f62:	60b8      	str	r0, [r7, #8]

    switch(type) {
 8022f64:	78fb      	ldrb	r3, [r7, #3]
 8022f66:	2b03      	cmp	r3, #3
 8022f68:	d81e      	bhi.n	8022fa8 <lv_page_get_style+0x5c>
 8022f6a:	a201      	add	r2, pc, #4	; (adr r2, 8022f70 <lv_page_get_style+0x24>)
 8022f6c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8022f70:	08022f81 	.word	0x08022f81
 8022f74:	08022f8b 	.word	0x08022f8b
 8022f78:	08022f99 	.word	0x08022f99
 8022f7c:	08022fa1 	.word	0x08022fa1
        case LV_PAGE_STYLE_BG: style = lv_obj_get_style(page); break;
 8022f80:	6878      	ldr	r0, [r7, #4]
 8022f82:	f7ef f937 	bl	80121f4 <lv_obj_get_style>
 8022f86:	60f8      	str	r0, [r7, #12]
 8022f88:	e011      	b.n	8022fae <lv_page_get_style+0x62>
        case LV_PAGE_STYLE_SCRL: style = lv_obj_get_style(ext->scrl); break;
 8022f8a:	68bb      	ldr	r3, [r7, #8]
 8022f8c:	685b      	ldr	r3, [r3, #4]
 8022f8e:	4618      	mov	r0, r3
 8022f90:	f7ef f930 	bl	80121f4 <lv_obj_get_style>
 8022f94:	60f8      	str	r0, [r7, #12]
 8022f96:	e00a      	b.n	8022fae <lv_page_get_style+0x62>
        case LV_PAGE_STYLE_SB: style = ext->sb.style; break;
 8022f98:	68bb      	ldr	r3, [r7, #8]
 8022f9a:	689b      	ldr	r3, [r3, #8]
 8022f9c:	60fb      	str	r3, [r7, #12]
 8022f9e:	e006      	b.n	8022fae <lv_page_get_style+0x62>
#if LV_USE_ANIMATION
        case LV_PAGE_STYLE_EDGE_FLASH: style = ext->edge_flash.style; break;
 8022fa0:	68bb      	ldr	r3, [r7, #8]
 8022fa2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8022fa4:	60fb      	str	r3, [r7, #12]
 8022fa6:	e002      	b.n	8022fae <lv_page_get_style+0x62>
#endif
        default: style = NULL; break;
 8022fa8:	2300      	movs	r3, #0
 8022faa:	60fb      	str	r3, [r7, #12]
 8022fac:	bf00      	nop
    }

    return style;
 8022fae:	68fb      	ldr	r3, [r7, #12]
}
 8022fb0:	4618      	mov	r0, r3
 8022fb2:	3710      	adds	r7, #16
 8022fb4:	46bd      	mov	sp, r7
 8022fb6:	bd80      	pop	{r7, pc}

08022fb8 <lv_page_scroll_hor>:
 * Scroll the page horizontally
 * @param page pointer to a page object
 * @param dist the distance to scroll (< 0: scroll right; > 0 scroll left)
 */
void lv_page_scroll_hor(lv_obj_t * page, lv_coord_t dist)
{
 8022fb8:	b580      	push	{r7, lr}
 8022fba:	b08e      	sub	sp, #56	; 0x38
 8022fbc:	af00      	add	r7, sp, #0
 8022fbe:	6078      	str	r0, [r7, #4]
 8022fc0:	460b      	mov	r3, r1
 8022fc2:	807b      	strh	r3, [r7, #2]
    lv_obj_t * scrl = lv_page_get_scrl(page);
 8022fc4:	6878      	ldr	r0, [r7, #4]
 8022fc6:	f7ff ffa5 	bl	8022f14 <lv_page_get_scrl>
 8022fca:	6378      	str	r0, [r7, #52]	; 0x34

#if LV_USE_ANIMATION
    lv_anim_t a;
    a.var            = scrl;
 8022fcc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8022fce:	60fb      	str	r3, [r7, #12]
    a.start          = lv_obj_get_x(scrl);
 8022fd0:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8022fd2:	f7ef f8ad 	bl	8012130 <lv_obj_get_x>
 8022fd6:	4603      	mov	r3, r0
 8022fd8:	61fb      	str	r3, [r7, #28]
    a.end            = a.start + dist;
 8022fda:	69fa      	ldr	r2, [r7, #28]
 8022fdc:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8022fe0:	4413      	add	r3, r2
 8022fe2:	623b      	str	r3, [r7, #32]
    a.exec_cb        = (lv_anim_exec_xcb_t)lv_obj_set_x;
 8022fe4:	4b11      	ldr	r3, [pc, #68]	; (802302c <lv_page_scroll_hor+0x74>)
 8022fe6:	613b      	str	r3, [r7, #16]
    a.path_cb        = lv_anim_path_linear;
 8022fe8:	4b11      	ldr	r3, [pc, #68]	; (8023030 <lv_page_scroll_hor+0x78>)
 8022fea:	617b      	str	r3, [r7, #20]
    a.ready_cb       = NULL;
 8022fec:	2300      	movs	r3, #0
 8022fee:	61bb      	str	r3, [r7, #24]
    a.act_time       = 0;
 8022ff0:	2300      	movs	r3, #0
 8022ff2:	84fb      	strh	r3, [r7, #38]	; 0x26
    a.time           = LV_PAGE_SCROLL_ANIM_TIME;
 8022ff4:	23c8      	movs	r3, #200	; 0xc8
 8022ff6:	84bb      	strh	r3, [r7, #36]	; 0x24
    a.playback       = 0;
 8022ff8:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8022ffc:	f36f 0300 	bfc	r3, #0, #1
 8023000:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    a.playback_pause = 0;
 8023004:	2300      	movs	r3, #0
 8023006:	853b      	strh	r3, [r7, #40]	; 0x28
    a.repeat         = 0;
 8023008:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 802300c:	f36f 0341 	bfc	r3, #1, #1
 8023010:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    a.repeat_pause   = 0;
 8023014:	2300      	movs	r3, #0
 8023016:	857b      	strh	r3, [r7, #42]	; 0x2a
    lv_anim_create(&a);
 8023018:	f107 030c 	add.w	r3, r7, #12
 802301c:	4618      	mov	r0, r3
 802301e:	f7f8 fa95 	bl	801b54c <lv_anim_create>
#else
    lv_obj_set_x(scrl, lv_obj_get_x(scrl) + dist);
#endif
}
 8023022:	bf00      	nop
 8023024:	3738      	adds	r7, #56	; 0x38
 8023026:	46bd      	mov	sp, r7
 8023028:	bd80      	pop	{r7, pc}
 802302a:	bf00      	nop
 802302c:	08011167 	.word	0x08011167
 8023030:	0801b6b1 	.word	0x0801b6b1

08023034 <lv_page_scroll_ver>:
 * Scroll the page vertically
 * @param page pointer to a page object
 * @param dist the distance to scroll (< 0: scroll down; > 0 scroll up)
 */
void lv_page_scroll_ver(lv_obj_t * page, lv_coord_t dist)
{
 8023034:	b580      	push	{r7, lr}
 8023036:	b08e      	sub	sp, #56	; 0x38
 8023038:	af00      	add	r7, sp, #0
 802303a:	6078      	str	r0, [r7, #4]
 802303c:	460b      	mov	r3, r1
 802303e:	807b      	strh	r3, [r7, #2]
    lv_obj_t * scrl = lv_page_get_scrl(page);
 8023040:	6878      	ldr	r0, [r7, #4]
 8023042:	f7ff ff67 	bl	8022f14 <lv_page_get_scrl>
 8023046:	6378      	str	r0, [r7, #52]	; 0x34

#if LV_USE_ANIMATION
    lv_anim_t a;
    a.var            = scrl;
 8023048:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802304a:	60fb      	str	r3, [r7, #12]
    a.start          = lv_obj_get_y(scrl);
 802304c:	6b78      	ldr	r0, [r7, #52]	; 0x34
 802304e:	f7ef f888 	bl	8012162 <lv_obj_get_y>
 8023052:	4603      	mov	r3, r0
 8023054:	61fb      	str	r3, [r7, #28]
    a.end            = a.start + dist;
 8023056:	69fa      	ldr	r2, [r7, #28]
 8023058:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 802305c:	4413      	add	r3, r2
 802305e:	623b      	str	r3, [r7, #32]
    a.exec_cb        = (lv_anim_exec_xcb_t)lv_obj_set_y;
 8023060:	4b11      	ldr	r3, [pc, #68]	; (80230a8 <lv_page_scroll_ver+0x74>)
 8023062:	613b      	str	r3, [r7, #16]
    a.path_cb        = lv_anim_path_linear;
 8023064:	4b11      	ldr	r3, [pc, #68]	; (80230ac <lv_page_scroll_ver+0x78>)
 8023066:	617b      	str	r3, [r7, #20]
    a.ready_cb       = NULL;
 8023068:	2300      	movs	r3, #0
 802306a:	61bb      	str	r3, [r7, #24]
    a.act_time       = 0;
 802306c:	2300      	movs	r3, #0
 802306e:	84fb      	strh	r3, [r7, #38]	; 0x26
    a.time           = LV_PAGE_SCROLL_ANIM_TIME;
 8023070:	23c8      	movs	r3, #200	; 0xc8
 8023072:	84bb      	strh	r3, [r7, #36]	; 0x24
    a.playback       = 0;
 8023074:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8023078:	f36f 0300 	bfc	r3, #0, #1
 802307c:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    a.playback_pause = 0;
 8023080:	2300      	movs	r3, #0
 8023082:	853b      	strh	r3, [r7, #40]	; 0x28
    a.repeat         = 0;
 8023084:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8023088:	f36f 0341 	bfc	r3, #1, #1
 802308c:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
    a.repeat_pause   = 0;
 8023090:	2300      	movs	r3, #0
 8023092:	857b      	strh	r3, [r7, #42]	; 0x2a
    lv_anim_create(&a);
 8023094:	f107 030c 	add.w	r3, r7, #12
 8023098:	4618      	mov	r0, r3
 802309a:	f7f8 fa57 	bl	801b54c <lv_anim_create>
#else
    lv_obj_set_y(scrl, lv_obj_get_y(scrl) + dist);
#endif
}
 802309e:	bf00      	nop
 80230a0:	3738      	adds	r7, #56	; 0x38
 80230a2:	46bd      	mov	sp, r7
 80230a4:	bd80      	pop	{r7, pc}
 80230a6:	bf00      	nop
 80230a8:	08011191 	.word	0x08011191
 80230ac:	0801b6b1 	.word	0x0801b6b1

080230b0 <lv_page_start_edge_flash>:
 * Not intended to use directly by the user but by other object types internally.
 * Start an edge flash animation. Exactly one `ext->edge_flash.xxx_ip` should be set
 * @param page
 */
void lv_page_start_edge_flash(lv_obj_t * page)
{
 80230b0:	b580      	push	{r7, lr}
 80230b2:	b08e      	sub	sp, #56	; 0x38
 80230b4:	af00      	add	r7, sp, #0
 80230b6:	6078      	str	r0, [r7, #4]
#if LV_USE_ANIMATION
    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 80230b8:	6878      	ldr	r0, [r7, #4]
 80230ba:	f7ef f9ba 	bl	8012432 <lv_obj_get_ext_attr>
 80230be:	6378      	str	r0, [r7, #52]	; 0x34
    if(ext->edge_flash.enabled) {
 80230c0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80230c2:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80230c6:	f003 0301 	and.w	r3, r3, #1
 80230ca:	b2db      	uxtb	r3, r3
 80230cc:	2b00      	cmp	r3, #0
 80230ce:	d026      	beq.n	802311e <lv_page_start_edge_flash+0x6e>
        lv_anim_t a;
        a.var            = page;
 80230d0:	687b      	ldr	r3, [r7, #4]
 80230d2:	60fb      	str	r3, [r7, #12]
        a.start          = 0;
 80230d4:	2300      	movs	r3, #0
 80230d6:	61fb      	str	r3, [r7, #28]
        a.end            = LV_PAGE_END_FLASH_SIZE;
 80230d8:	2319      	movs	r3, #25
 80230da:	623b      	str	r3, [r7, #32]
        a.exec_cb        = (lv_anim_exec_xcb_t)edge_flash_anim;
 80230dc:	4b12      	ldr	r3, [pc, #72]	; (8023128 <lv_page_start_edge_flash+0x78>)
 80230de:	613b      	str	r3, [r7, #16]
        a.path_cb        = lv_anim_path_linear;
 80230e0:	4b12      	ldr	r3, [pc, #72]	; (802312c <lv_page_start_edge_flash+0x7c>)
 80230e2:	617b      	str	r3, [r7, #20]
        a.ready_cb       = edge_flash_anim_end;
 80230e4:	4b12      	ldr	r3, [pc, #72]	; (8023130 <lv_page_start_edge_flash+0x80>)
 80230e6:	61bb      	str	r3, [r7, #24]
        a.act_time       = 0;
 80230e8:	2300      	movs	r3, #0
 80230ea:	84fb      	strh	r3, [r7, #38]	; 0x26
        a.time           = LV_PAGE_END_ANIM_TIME;
 80230ec:	f44f 7396 	mov.w	r3, #300	; 0x12c
 80230f0:	84bb      	strh	r3, [r7, #36]	; 0x24
        a.playback       = 1;
 80230f2:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 80230f6:	f043 0301 	orr.w	r3, r3, #1
 80230fa:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
        a.playback_pause = LV_PAGE_END_ANIM_WAIT_TIME;
 80230fe:	f44f 7396 	mov.w	r3, #300	; 0x12c
 8023102:	853b      	strh	r3, [r7, #40]	; 0x28
        a.repeat         = 0;
 8023104:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
 8023108:	f36f 0341 	bfc	r3, #1, #1
 802310c:	f887 3030 	strb.w	r3, [r7, #48]	; 0x30
        a.repeat_pause   = 0;
 8023110:	2300      	movs	r3, #0
 8023112:	857b      	strh	r3, [r7, #42]	; 0x2a
        lv_anim_create(&a);
 8023114:	f107 030c 	add.w	r3, r7, #12
 8023118:	4618      	mov	r0, r3
 802311a:	f7f8 fa17 	bl	801b54c <lv_anim_create>
    }
#else
    (void)page; /*Unused*/
#endif
}
 802311e:	bf00      	nop
 8023120:	3738      	adds	r7, #56	; 0x38
 8023122:	46bd      	mov	sp, r7
 8023124:	bd80      	pop	{r7, pc}
 8023126:	bf00      	nop
 8023128:	08024853 	.word	0x08024853
 802312c:	0801b6b1 	.word	0x0801b6b1
 8023130:	0802487b 	.word	0x0802487b

08023134 <lv_page_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_page_design(lv_obj_t * page, const lv_area_t * mask, lv_design_mode_t mode)
{
 8023134:	b590      	push	{r4, r7, lr}
 8023136:	b0ab      	sub	sp, #172	; 0xac
 8023138:	af00      	add	r7, sp, #0
 802313a:	60f8      	str	r0, [r7, #12]
 802313c:	60b9      	str	r1, [r7, #8]
 802313e:	4613      	mov	r3, r2
 8023140:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 8023142:	79fb      	ldrb	r3, [r7, #7]
 8023144:	2b02      	cmp	r3, #2
 8023146:	d107      	bne.n	8023158 <lv_page_design+0x24>
        return ancestor_design(page, mask, mode);
 8023148:	4ba3      	ldr	r3, [pc, #652]	; (80233d8 <lv_page_design+0x2a4>)
 802314a:	681b      	ldr	r3, [r3, #0]
 802314c:	79fa      	ldrb	r2, [r7, #7]
 802314e:	68b9      	ldr	r1, [r7, #8]
 8023150:	68f8      	ldr	r0, [r7, #12]
 8023152:	4798      	blx	r3
 8023154:	4603      	mov	r3, r0
 8023156:	e25c      	b.n	8023612 <lv_page_design+0x4de>
    }
    /*Cache page bg style for temporary modification*/
    const lv_style_t * style = lv_page_get_style(page, LV_PAGE_STYLE_BG);
 8023158:	2100      	movs	r1, #0
 802315a:	68f8      	ldr	r0, [r7, #12]
 802315c:	f7ff fef6 	bl	8022f4c <lv_page_get_style>
 8023160:	f8c7 00a4 	str.w	r0, [r7, #164]	; 0xa4
    lv_style_t style_tmp;
    lv_style_copy(&style_tmp, style);
 8023164:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8023168:	f8d7 10a4 	ldr.w	r1, [r7, #164]	; 0xa4
 802316c:	4618      	mov	r0, r3
 802316e:	f7f0 fc79 	bl	8013a64 <lv_style_copy>

    if(mode == LV_DESIGN_DRAW_MAIN) {
 8023172:	79fb      	ldrb	r3, [r7, #7]
 8023174:	2b00      	cmp	r3, #0
 8023176:	d110      	bne.n	802319a <lv_page_design+0x66>
        /*Draw without border*/
        style_tmp.body.border.width = 0;
 8023178:	2300      	movs	r3, #0
 802317a:	f8a7 3068 	strh.w	r3, [r7, #104]	; 0x68
        lv_draw_rect(&page->coords, mask, &style_tmp, lv_obj_get_opa_scale(page));
 802317e:	68fb      	ldr	r3, [r7, #12]
 8023180:	f103 0410 	add.w	r4, r3, #16
 8023184:	68f8      	ldr	r0, [r7, #12]
 8023186:	f7ef f906 	bl	8012396 <lv_obj_get_opa_scale>
 802318a:	4603      	mov	r3, r0
 802318c:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 8023190:	68b9      	ldr	r1, [r7, #8]
 8023192:	4620      	mov	r0, r4
 8023194:	f7f2 fbb5 	bl	8015902 <lv_draw_rect>
 8023198:	e23a      	b.n	8023610 <lv_page_design+0x4dc>

    } else if(mode == LV_DESIGN_DRAW_POST) {
 802319a:	79fb      	ldrb	r3, [r7, #7]
 802319c:	2b01      	cmp	r3, #1
 802319e:	f040 8237 	bne.w	8023610 <lv_page_design+0x4dc>
        /*Draw only a border*/
        style_tmp.body.shadow.width = 0;
 80231a2:	2300      	movs	r3, #0
 80231a4:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
        style_tmp.body.opa          = LV_OPA_TRANSP;
 80231a8:	2300      	movs	r3, #0
 80231aa:	f887 3064 	strb.w	r3, [r7, #100]	; 0x64
        lv_draw_rect(&page->coords, mask, &style_tmp, lv_obj_get_opa_scale(page));
 80231ae:	68fb      	ldr	r3, [r7, #12]
 80231b0:	f103 0410 	add.w	r4, r3, #16
 80231b4:	68f8      	ldr	r0, [r7, #12]
 80231b6:	f7ef f8ee 	bl	8012396 <lv_obj_get_opa_scale>
 80231ba:	4603      	mov	r3, r0
 80231bc:	f107 025c 	add.w	r2, r7, #92	; 0x5c
 80231c0:	68b9      	ldr	r1, [r7, #8]
 80231c2:	4620      	mov	r0, r4
 80231c4:	f7f2 fb9d 	bl	8015902 <lv_draw_rect>

        lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 80231c8:	68f8      	ldr	r0, [r7, #12]
 80231ca:	f7ef f932 	bl	8012432 <lv_obj_get_ext_attr>
 80231ce:	f8c7 00a0 	str.w	r0, [r7, #160]	; 0xa0

        /*Draw the scrollbars*/
        lv_area_t sb_area;
        if(ext->sb.hor_draw && (ext->sb.mode & LV_SB_MODE_HIDE) == 0) {
 80231d2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80231d6:	7f1b      	ldrb	r3, [r3, #28]
 80231d8:	f003 0301 	and.w	r3, r3, #1
 80231dc:	b2db      	uxtb	r3, r3
 80231de:	2b00      	cmp	r3, #0
 80231e0:	d050      	beq.n	8023284 <lv_page_design+0x150>
 80231e2:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80231e6:	7f1b      	ldrb	r3, [r3, #28]
 80231e8:	f3c3 0382 	ubfx	r3, r3, #2, #3
 80231ec:	b2db      	uxtb	r3, r3
 80231ee:	f003 0304 	and.w	r3, r3, #4
 80231f2:	2b00      	cmp	r3, #0
 80231f4:	d146      	bne.n	8023284 <lv_page_design+0x150>
            /*Convert the relative coordinates to absolute*/
            lv_area_copy(&sb_area, &ext->sb.hor_area);
 80231f6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80231fa:	f103 020c 	add.w	r2, r3, #12
 80231fe:	f107 0354 	add.w	r3, r7, #84	; 0x54
 8023202:	4611      	mov	r1, r2
 8023204:	4618      	mov	r0, r3
 8023206:	f7ff fbd3 	bl	80229b0 <lv_area_copy>
            sb_area.x1 += page->coords.x1;
 802320a:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 802320e:	b29a      	uxth	r2, r3
 8023210:	68fb      	ldr	r3, [r7, #12]
 8023212:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8023216:	b29b      	uxth	r3, r3
 8023218:	4413      	add	r3, r2
 802321a:	b29b      	uxth	r3, r3
 802321c:	b21b      	sxth	r3, r3
 802321e:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            sb_area.y1 += page->coords.y1;
 8023222:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8023226:	b29a      	uxth	r2, r3
 8023228:	68fb      	ldr	r3, [r7, #12]
 802322a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802322e:	b29b      	uxth	r3, r3
 8023230:	4413      	add	r3, r2
 8023232:	b29b      	uxth	r3, r3
 8023234:	b21b      	sxth	r3, r3
 8023236:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
            sb_area.x2 += page->coords.x1;
 802323a:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 802323e:	b29a      	uxth	r2, r3
 8023240:	68fb      	ldr	r3, [r7, #12]
 8023242:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8023246:	b29b      	uxth	r3, r3
 8023248:	4413      	add	r3, r2
 802324a:	b29b      	uxth	r3, r3
 802324c:	b21b      	sxth	r3, r3
 802324e:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
            sb_area.y2 += page->coords.y1;
 8023252:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8023256:	b29a      	uxth	r2, r3
 8023258:	68fb      	ldr	r3, [r7, #12]
 802325a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802325e:	b29b      	uxth	r3, r3
 8023260:	4413      	add	r3, r2
 8023262:	b29b      	uxth	r3, r3
 8023264:	b21b      	sxth	r3, r3
 8023266:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            lv_draw_rect(&sb_area, mask, ext->sb.style, lv_obj_get_opa_scale(page));
 802326a:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802326e:	689c      	ldr	r4, [r3, #8]
 8023270:	68f8      	ldr	r0, [r7, #12]
 8023272:	f7ef f890 	bl	8012396 <lv_obj_get_opa_scale>
 8023276:	4603      	mov	r3, r0
 8023278:	f107 0054 	add.w	r0, r7, #84	; 0x54
 802327c:	4622      	mov	r2, r4
 802327e:	68b9      	ldr	r1, [r7, #8]
 8023280:	f7f2 fb3f 	bl	8015902 <lv_draw_rect>
        }

        if(ext->sb.ver_draw && (ext->sb.mode & LV_SB_MODE_HIDE) == 0) {
 8023284:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023288:	7f1b      	ldrb	r3, [r3, #28]
 802328a:	f003 0302 	and.w	r3, r3, #2
 802328e:	b2db      	uxtb	r3, r3
 8023290:	2b00      	cmp	r3, #0
 8023292:	d050      	beq.n	8023336 <lv_page_design+0x202>
 8023294:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023298:	7f1b      	ldrb	r3, [r3, #28]
 802329a:	f3c3 0382 	ubfx	r3, r3, #2, #3
 802329e:	b2db      	uxtb	r3, r3
 80232a0:	f003 0304 	and.w	r3, r3, #4
 80232a4:	2b00      	cmp	r3, #0
 80232a6:	d146      	bne.n	8023336 <lv_page_design+0x202>
            /*Convert the relative coordinates to absolute*/
            lv_area_copy(&sb_area, &ext->sb.ver_area);
 80232a8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80232ac:	f103 0214 	add.w	r2, r3, #20
 80232b0:	f107 0354 	add.w	r3, r7, #84	; 0x54
 80232b4:	4611      	mov	r1, r2
 80232b6:	4618      	mov	r0, r3
 80232b8:	f7ff fb7a 	bl	80229b0 <lv_area_copy>
            sb_area.x1 += page->coords.x1;
 80232bc:	f9b7 3054 	ldrsh.w	r3, [r7, #84]	; 0x54
 80232c0:	b29a      	uxth	r2, r3
 80232c2:	68fb      	ldr	r3, [r7, #12]
 80232c4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80232c8:	b29b      	uxth	r3, r3
 80232ca:	4413      	add	r3, r2
 80232cc:	b29b      	uxth	r3, r3
 80232ce:	b21b      	sxth	r3, r3
 80232d0:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            sb_area.y1 += page->coords.y1;
 80232d4:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 80232d8:	b29a      	uxth	r2, r3
 80232da:	68fb      	ldr	r3, [r7, #12]
 80232dc:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80232e0:	b29b      	uxth	r3, r3
 80232e2:	4413      	add	r3, r2
 80232e4:	b29b      	uxth	r3, r3
 80232e6:	b21b      	sxth	r3, r3
 80232e8:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
            sb_area.x2 += page->coords.x1;
 80232ec:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 80232f0:	b29a      	uxth	r2, r3
 80232f2:	68fb      	ldr	r3, [r7, #12]
 80232f4:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80232f8:	b29b      	uxth	r3, r3
 80232fa:	4413      	add	r3, r2
 80232fc:	b29b      	uxth	r3, r3
 80232fe:	b21b      	sxth	r3, r3
 8023300:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
            sb_area.y2 += page->coords.y1;
 8023304:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8023308:	b29a      	uxth	r2, r3
 802330a:	68fb      	ldr	r3, [r7, #12]
 802330c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8023310:	b29b      	uxth	r3, r3
 8023312:	4413      	add	r3, r2
 8023314:	b29b      	uxth	r3, r3
 8023316:	b21b      	sxth	r3, r3
 8023318:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            lv_draw_rect(&sb_area, mask, ext->sb.style, lv_obj_get_opa_scale(page));
 802331c:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023320:	689c      	ldr	r4, [r3, #8]
 8023322:	68f8      	ldr	r0, [r7, #12]
 8023324:	f7ef f837 	bl	8012396 <lv_obj_get_opa_scale>
 8023328:	4603      	mov	r3, r0
 802332a:	f107 0054 	add.w	r0, r7, #84	; 0x54
 802332e:	4622      	mov	r2, r4
 8023330:	68b9      	ldr	r1, [r7, #8]
 8023332:	f7f2 fae6 	bl	8015902 <lv_draw_rect>
        }

#if LV_USE_ANIMATION
        {
            lv_coord_t page_w = lv_obj_get_width(page);
 8023336:	68f8      	ldr	r0, [r7, #12]
 8023338:	f7ee ff2c 	bl	8012194 <lv_obj_get_width>
 802333c:	4603      	mov	r3, r0
 802333e:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
            lv_coord_t page_h = lv_obj_get_height(page);
 8023342:	68f8      	ldr	r0, [r7, #12]
 8023344:	f7ee ff34 	bl	80121b0 <lv_obj_get_height>
 8023348:	4603      	mov	r3, r0
 802334a:	f8a7 309c 	strh.w	r3, [r7, #156]	; 0x9c

            lv_area_t flash_area;

            if(ext->edge_flash.top_ip) {
 802334e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023352:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023356:	f003 0302 	and.w	r3, r3, #2
 802335a:	b2db      	uxtb	r3, r3
 802335c:	2b00      	cmp	r3, #0
 802335e:	d03d      	beq.n	80233dc <lv_page_design+0x2a8>
                flash_area.x1 = page->coords.x1 - page_w;
 8023360:	68fb      	ldr	r3, [r7, #12]
 8023362:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8023366:	b29a      	uxth	r2, r3
 8023368:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 802336c:	1ad3      	subs	r3, r2, r3
 802336e:	b29b      	uxth	r3, r3
 8023370:	b21b      	sxth	r3, r3
 8023372:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                flash_area.x2 = page->coords.x2 + page_w;
 8023376:	68fb      	ldr	r3, [r7, #12]
 8023378:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 802337c:	b29a      	uxth	r2, r3
 802337e:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 8023382:	4413      	add	r3, r2
 8023384:	b29b      	uxth	r3, r3
 8023386:	b21b      	sxth	r3, r3
 8023388:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                flash_area.y1 = page->coords.y1 - 3 * page_w + ext->edge_flash.state;
 802338c:	68fb      	ldr	r3, [r7, #12]
 802338e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8023392:	b29a      	uxth	r2, r3
 8023394:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 8023398:	4619      	mov	r1, r3
 802339a:	009b      	lsls	r3, r3, #2
 802339c:	1acb      	subs	r3, r1, r3
 802339e:	b29b      	uxth	r3, r3
 80233a0:	4413      	add	r3, r2
 80233a2:	b29a      	uxth	r2, r3
 80233a4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80233a8:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 80233ac:	b29b      	uxth	r3, r3
 80233ae:	4413      	add	r3, r2
 80233b0:	b29b      	uxth	r3, r3
 80233b2:	b21b      	sxth	r3, r3
 80233b4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                flash_area.y2 = page->coords.y1 + ext->edge_flash.state;
 80233b8:	68fb      	ldr	r3, [r7, #12]
 80233ba:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80233be:	b29a      	uxth	r2, r3
 80233c0:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80233c4:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 80233c8:	b29b      	uxth	r3, r3
 80233ca:	4413      	add	r3, r2
 80233cc:	b29b      	uxth	r3, r3
 80233ce:	b21b      	sxth	r3, r3
 80233d0:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
 80233d4:	e0cd      	b.n	8023572 <lv_page_design+0x43e>
 80233d6:	bf00      	nop
 80233d8:	2000c3e0 	.word	0x2000c3e0
            } else if(ext->edge_flash.bottom_ip) {
 80233dc:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80233e0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80233e4:	f003 0304 	and.w	r3, r3, #4
 80233e8:	b2db      	uxtb	r3, r3
 80233ea:	2b00      	cmp	r3, #0
 80233ec:	d03a      	beq.n	8023464 <lv_page_design+0x330>
                flash_area.x1 = page->coords.x1 - page_w;
 80233ee:	68fb      	ldr	r3, [r7, #12]
 80233f0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80233f4:	b29a      	uxth	r2, r3
 80233f6:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 80233fa:	1ad3      	subs	r3, r2, r3
 80233fc:	b29b      	uxth	r3, r3
 80233fe:	b21b      	sxth	r3, r3
 8023400:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                flash_area.x2 = page->coords.x2 + page_w;
 8023404:	68fb      	ldr	r3, [r7, #12]
 8023406:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 802340a:	b29a      	uxth	r2, r3
 802340c:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 8023410:	4413      	add	r3, r2
 8023412:	b29b      	uxth	r3, r3
 8023414:	b21b      	sxth	r3, r3
 8023416:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                flash_area.y1 = page->coords.y2 - ext->edge_flash.state;
 802341a:	68fb      	ldr	r3, [r7, #12]
 802341c:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023420:	b29a      	uxth	r2, r3
 8023422:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023426:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 802342a:	b29b      	uxth	r3, r3
 802342c:	1ad3      	subs	r3, r2, r3
 802342e:	b29b      	uxth	r3, r3
 8023430:	b21b      	sxth	r3, r3
 8023432:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                flash_area.y2 = page->coords.y2 + 3 * page_w - ext->edge_flash.state;
 8023436:	68fb      	ldr	r3, [r7, #12]
 8023438:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 802343c:	b29a      	uxth	r2, r3
 802343e:	f8b7 309e 	ldrh.w	r3, [r7, #158]	; 0x9e
 8023442:	4619      	mov	r1, r3
 8023444:	0049      	lsls	r1, r1, #1
 8023446:	440b      	add	r3, r1
 8023448:	b29b      	uxth	r3, r3
 802344a:	4413      	add	r3, r2
 802344c:	b29a      	uxth	r2, r3
 802344e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023452:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 8023456:	b29b      	uxth	r3, r3
 8023458:	1ad3      	subs	r3, r2, r3
 802345a:	b29b      	uxth	r3, r3
 802345c:	b21b      	sxth	r3, r3
 802345e:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
 8023462:	e086      	b.n	8023572 <lv_page_design+0x43e>
            } else if(ext->edge_flash.right_ip) {
 8023464:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023468:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 802346c:	f003 0308 	and.w	r3, r3, #8
 8023470:	b2db      	uxtb	r3, r3
 8023472:	2b00      	cmp	r3, #0
 8023474:	d03a      	beq.n	80234ec <lv_page_design+0x3b8>
                flash_area.x1 = page->coords.x2 - ext->edge_flash.state;
 8023476:	68fb      	ldr	r3, [r7, #12]
 8023478:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 802347c:	b29a      	uxth	r2, r3
 802347e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023482:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 8023486:	b29b      	uxth	r3, r3
 8023488:	1ad3      	subs	r3, r2, r3
 802348a:	b29b      	uxth	r3, r3
 802348c:	b21b      	sxth	r3, r3
 802348e:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                flash_area.x2 = page->coords.x2 + 3 * page_h - ext->edge_flash.state;
 8023492:	68fb      	ldr	r3, [r7, #12]
 8023494:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8023498:	b29a      	uxth	r2, r3
 802349a:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 802349e:	4619      	mov	r1, r3
 80234a0:	0049      	lsls	r1, r1, #1
 80234a2:	440b      	add	r3, r1
 80234a4:	b29b      	uxth	r3, r3
 80234a6:	4413      	add	r3, r2
 80234a8:	b29a      	uxth	r2, r3
 80234aa:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80234ae:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 80234b2:	b29b      	uxth	r3, r3
 80234b4:	1ad3      	subs	r3, r2, r3
 80234b6:	b29b      	uxth	r3, r3
 80234b8:	b21b      	sxth	r3, r3
 80234ba:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                flash_area.y1 = page->coords.y1 - page_h;
 80234be:	68fb      	ldr	r3, [r7, #12]
 80234c0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80234c4:	b29a      	uxth	r2, r3
 80234c6:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 80234ca:	1ad3      	subs	r3, r2, r3
 80234cc:	b29b      	uxth	r3, r3
 80234ce:	b21b      	sxth	r3, r3
 80234d0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                flash_area.y2 = page->coords.y2 + page_h;
 80234d4:	68fb      	ldr	r3, [r7, #12]
 80234d6:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80234da:	b29a      	uxth	r2, r3
 80234dc:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 80234e0:	4413      	add	r3, r2
 80234e2:	b29b      	uxth	r3, r3
 80234e4:	b21b      	sxth	r3, r3
 80234e6:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
 80234ea:	e042      	b.n	8023572 <lv_page_design+0x43e>
            } else if(ext->edge_flash.left_ip) {
 80234ec:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80234f0:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80234f4:	f003 0310 	and.w	r3, r3, #16
 80234f8:	b2db      	uxtb	r3, r3
 80234fa:	2b00      	cmp	r3, #0
 80234fc:	d039      	beq.n	8023572 <lv_page_design+0x43e>
                flash_area.x1 = page->coords.x1 - 3 * page_h + ext->edge_flash.state;
 80234fe:	68fb      	ldr	r3, [r7, #12]
 8023500:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8023504:	b29a      	uxth	r2, r3
 8023506:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 802350a:	4619      	mov	r1, r3
 802350c:	009b      	lsls	r3, r3, #2
 802350e:	1acb      	subs	r3, r1, r3
 8023510:	b29b      	uxth	r3, r3
 8023512:	4413      	add	r3, r2
 8023514:	b29a      	uxth	r2, r3
 8023516:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802351a:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 802351e:	b29b      	uxth	r3, r3
 8023520:	4413      	add	r3, r2
 8023522:	b29b      	uxth	r3, r3
 8023524:	b21b      	sxth	r3, r3
 8023526:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c
                flash_area.x2 = page->coords.x1 + ext->edge_flash.state;
 802352a:	68fb      	ldr	r3, [r7, #12]
 802352c:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8023530:	b29a      	uxth	r2, r3
 8023532:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023536:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 802353a:	b29b      	uxth	r3, r3
 802353c:	4413      	add	r3, r2
 802353e:	b29b      	uxth	r3, r3
 8023540:	b21b      	sxth	r3, r3
 8023542:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                flash_area.y1 = page->coords.y1 - page_h;
 8023546:	68fb      	ldr	r3, [r7, #12]
 8023548:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802354c:	b29a      	uxth	r2, r3
 802354e:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 8023552:	1ad3      	subs	r3, r2, r3
 8023554:	b29b      	uxth	r3, r3
 8023556:	b21b      	sxth	r3, r3
 8023558:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
                flash_area.y2 = page->coords.y2 + page_h;
 802355c:	68fb      	ldr	r3, [r7, #12]
 802355e:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023562:	b29a      	uxth	r2, r3
 8023564:	f8b7 309c 	ldrh.w	r3, [r7, #156]	; 0x9c
 8023568:	4413      	add	r3, r2
 802356a:	b29b      	uxth	r3, r3
 802356c:	b21b      	sxth	r3, r3
 802356e:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            }

            if(ext->edge_flash.left_ip || ext->edge_flash.right_ip || ext->edge_flash.top_ip ||
 8023572:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023576:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 802357a:	f003 0310 	and.w	r3, r3, #16
 802357e:	b2db      	uxtb	r3, r3
 8023580:	2b00      	cmp	r3, #0
 8023582:	d11a      	bne.n	80235ba <lv_page_design+0x486>
 8023584:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8023588:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 802358c:	f003 0308 	and.w	r3, r3, #8
 8023590:	b2db      	uxtb	r3, r3
 8023592:	2b00      	cmp	r3, #0
 8023594:	d111      	bne.n	80235ba <lv_page_design+0x486>
 8023596:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 802359a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 802359e:	f003 0302 	and.w	r3, r3, #2
 80235a2:	b2db      	uxtb	r3, r3
 80235a4:	2b00      	cmp	r3, #0
 80235a6:	d108      	bne.n	80235ba <lv_page_design+0x486>
 80235a8:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80235ac:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 80235b0:	f003 0304 	and.w	r3, r3, #4
 80235b4:	b2db      	uxtb	r3, r3
 80235b6:	2b00      	cmp	r3, #0
 80235b8:	d02a      	beq.n	8023610 <lv_page_design+0x4dc>
               ext->edge_flash.bottom_ip) {
                lv_style_t flash_style;
                lv_style_copy(&flash_style, ext->edge_flash.style);
 80235ba:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80235be:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80235c0:	f107 0310 	add.w	r3, r7, #16
 80235c4:	4611      	mov	r1, r2
 80235c6:	4618      	mov	r0, r3
 80235c8:	f7f0 fa4c 	bl	8013a64 <lv_style_copy>
                flash_style.body.radius = LV_RADIUS_CIRCLE;
 80235cc:	f647 4318 	movw	r3, #31768	; 0x7c18
 80235d0:	82fb      	strh	r3, [r7, #22]
                uint32_t opa            = (flash_style.body.opa * ext->edge_flash.state) / LV_PAGE_END_FLASH_SIZE;
 80235d2:	7e3b      	ldrb	r3, [r7, #24]
 80235d4:	461a      	mov	r2, r3
 80235d6:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 80235da:	f9b3 3020 	ldrsh.w	r3, [r3, #32]
 80235de:	fb03 f302 	mul.w	r3, r3, r2
 80235e2:	4a0e      	ldr	r2, [pc, #56]	; (802361c <lv_page_design+0x4e8>)
 80235e4:	fb82 1203 	smull	r1, r2, r2, r3
 80235e8:	10d2      	asrs	r2, r2, #3
 80235ea:	17db      	asrs	r3, r3, #31
 80235ec:	1ad3      	subs	r3, r2, r3
 80235ee:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                flash_style.body.opa    = opa;
 80235f2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80235f6:	b2db      	uxtb	r3, r3
 80235f8:	763b      	strb	r3, [r7, #24]
                lv_draw_rect(&flash_area, mask, &flash_style, lv_obj_get_opa_scale(page));
 80235fa:	68f8      	ldr	r0, [r7, #12]
 80235fc:	f7ee fecb 	bl	8012396 <lv_obj_get_opa_scale>
 8023600:	4603      	mov	r3, r0
 8023602:	f107 0210 	add.w	r2, r7, #16
 8023606:	f107 004c 	add.w	r0, r7, #76	; 0x4c
 802360a:	68b9      	ldr	r1, [r7, #8]
 802360c:	f7f2 f979 	bl	8015902 <lv_draw_rect>
            }
        }
#endif
    }

    return true;
 8023610:	2301      	movs	r3, #1
}
 8023612:	4618      	mov	r0, r3
 8023614:	37ac      	adds	r7, #172	; 0xac
 8023616:	46bd      	mov	sp, r7
 8023618:	bd90      	pop	{r4, r7, pc}
 802361a:	bf00      	nop
 802361c:	51eb851f 	.word	0x51eb851f

08023620 <lv_scrl_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_scrl_design(lv_obj_t * scrl, const lv_area_t * mask, lv_design_mode_t mode)
{
 8023620:	b580      	push	{r7, lr}
 8023622:	b08a      	sub	sp, #40	; 0x28
 8023624:	af00      	add	r7, sp, #0
 8023626:	60f8      	str	r0, [r7, #12]
 8023628:	60b9      	str	r1, [r7, #8]
 802362a:	4613      	mov	r3, r2
 802362c:	71fb      	strb	r3, [r7, #7]
    if(mode == LV_DESIGN_COVER_CHK) {
 802362e:	79fb      	ldrb	r3, [r7, #7]
 8023630:	2b02      	cmp	r3, #2
 8023632:	d107      	bne.n	8023644 <lv_scrl_design+0x24>
        return ancestor_design(scrl, mask, mode);
 8023634:	4b2f      	ldr	r3, [pc, #188]	; (80236f4 <lv_scrl_design+0xd4>)
 8023636:	681b      	ldr	r3, [r3, #0]
 8023638:	79fa      	ldrb	r2, [r7, #7]
 802363a:	68b9      	ldr	r1, [r7, #8]
 802363c:	68f8      	ldr	r0, [r7, #12]
 802363e:	4798      	blx	r3
 8023640:	4603      	mov	r3, r0
 8023642:	e052      	b.n	80236ea <lv_scrl_design+0xca>
    } else if(mode == LV_DESIGN_DRAW_MAIN) {
 8023644:	79fb      	ldrb	r3, [r7, #7]
 8023646:	2b00      	cmp	r3, #0
 8023648:	d145      	bne.n	80236d6 <lv_scrl_design+0xb6>
#if LV_USE_GROUP
        /* If the page is focused in a group and
         * the background object is not visible (transparent)
         * then "activate" the style of the scrollable*/
        const lv_style_t * style_scrl_ori = lv_obj_get_style(scrl);
 802364a:	68f8      	ldr	r0, [r7, #12]
 802364c:	f7ee fdd2 	bl	80121f4 <lv_obj_get_style>
 8023650:	6238      	str	r0, [r7, #32]
        lv_obj_t * page                   = lv_obj_get_parent(scrl);
 8023652:	68f8      	ldr	r0, [r7, #12]
 8023654:	f7ee fd34 	bl	80120c0 <lv_obj_get_parent>
 8023658:	61f8      	str	r0, [r7, #28]
        const lv_style_t * style_page     = lv_obj_get_style(page);
 802365a:	69f8      	ldr	r0, [r7, #28]
 802365c:	f7ee fdca 	bl	80121f4 <lv_obj_get_style>
 8023660:	61b8      	str	r0, [r7, #24]
        lv_group_t * g                    = lv_obj_get_group(page);
 8023662:	69f8      	ldr	r0, [r7, #28]
 8023664:	f7ee fef1 	bl	801244a <lv_obj_get_group>
 8023668:	6178      	str	r0, [r7, #20]
        if((style_page->body.opa == LV_OPA_TRANSP) &&
 802366a:	69bb      	ldr	r3, [r7, #24]
 802366c:	7a1b      	ldrb	r3, [r3, #8]
 802366e:	2b00      	cmp	r3, #0
 8023670:	d127      	bne.n	80236c2 <lv_scrl_design+0xa2>
           style_page->body.border.width == 0) { /*Is the background visible?*/
 8023672:	69bb      	ldr	r3, [r7, #24]
 8023674:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
        if((style_page->body.opa == LV_OPA_TRANSP) &&
 8023678:	2b00      	cmp	r3, #0
 802367a:	d122      	bne.n	80236c2 <lv_scrl_design+0xa2>
            if(lv_group_get_focused(g) == page) {
 802367c:	6978      	ldr	r0, [r7, #20]
 802367e:	f7ea feed 	bl	800e45c <lv_group_get_focused>
 8023682:	4602      	mov	r2, r0
 8023684:	69fb      	ldr	r3, [r7, #28]
 8023686:	4293      	cmp	r3, r2
 8023688:	d11b      	bne.n	80236c2 <lv_scrl_design+0xa2>
                lv_style_t * style_mod;
                style_mod = lv_group_mod_style(g, style_scrl_ori);
 802368a:	6a39      	ldr	r1, [r7, #32]
 802368c:	6978      	ldr	r0, [r7, #20]
 802368e:	f7ea feb5 	bl	800e3fc <lv_group_mod_style>
 8023692:	6278      	str	r0, [r7, #36]	; 0x24
                /*If still not visible modify the style a littel bit*/
                if((style_mod->body.opa == LV_OPA_TRANSP) && style_mod->body.border.width == 0) {
 8023694:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8023696:	7a1b      	ldrb	r3, [r3, #8]
 8023698:	2b00      	cmp	r3, #0
 802369a:	d10f      	bne.n	80236bc <lv_scrl_design+0x9c>
 802369c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802369e:	f9b3 300c 	ldrsh.w	r3, [r3, #12]
 80236a2:	2b00      	cmp	r3, #0
 80236a4:	d10a      	bne.n	80236bc <lv_scrl_design+0x9c>
                    style_mod->body.opa          = LV_OPA_50;
 80236a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80236a8:	227f      	movs	r2, #127	; 0x7f
 80236aa:	721a      	strb	r2, [r3, #8]
                    style_mod->body.border.width = 1;
 80236ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80236ae:	2201      	movs	r2, #1
 80236b0:	819a      	strh	r2, [r3, #12]
                    style_mod                    = lv_group_mod_style(g, style_mod);
 80236b2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80236b4:	6978      	ldr	r0, [r7, #20]
 80236b6:	f7ea fea1 	bl	800e3fc <lv_group_mod_style>
 80236ba:	6278      	str	r0, [r7, #36]	; 0x24
                }

                scrl->style_p = style_mod; /*Temporally change the style to the activated */
 80236bc:	68fb      	ldr	r3, [r7, #12]
 80236be:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80236c0:	629a      	str	r2, [r3, #40]	; 0x28
            }
        }
#endif
        ancestor_design(scrl, mask, mode);
 80236c2:	4b0c      	ldr	r3, [pc, #48]	; (80236f4 <lv_scrl_design+0xd4>)
 80236c4:	681b      	ldr	r3, [r3, #0]
 80236c6:	79fa      	ldrb	r2, [r7, #7]
 80236c8:	68b9      	ldr	r1, [r7, #8]
 80236ca:	68f8      	ldr	r0, [r7, #12]
 80236cc:	4798      	blx	r3

#if LV_USE_GROUP
        scrl->style_p = style_scrl_ori; /*Revert the style*/
 80236ce:	68fb      	ldr	r3, [r7, #12]
 80236d0:	6a3a      	ldr	r2, [r7, #32]
 80236d2:	629a      	str	r2, [r3, #40]	; 0x28
 80236d4:	e008      	b.n	80236e8 <lv_scrl_design+0xc8>
#endif
    } else if(mode == LV_DESIGN_DRAW_POST) {
 80236d6:	79fb      	ldrb	r3, [r7, #7]
 80236d8:	2b01      	cmp	r3, #1
 80236da:	d105      	bne.n	80236e8 <lv_scrl_design+0xc8>
        ancestor_design(scrl, mask, mode);
 80236dc:	4b05      	ldr	r3, [pc, #20]	; (80236f4 <lv_scrl_design+0xd4>)
 80236de:	681b      	ldr	r3, [r3, #0]
 80236e0:	79fa      	ldrb	r2, [r7, #7]
 80236e2:	68b9      	ldr	r1, [r7, #8]
 80236e4:	68f8      	ldr	r0, [r7, #12]
 80236e6:	4798      	blx	r3
    }

    return true;
 80236e8:	2301      	movs	r3, #1
}
 80236ea:	4618      	mov	r0, r3
 80236ec:	3728      	adds	r7, #40	; 0x28
 80236ee:	46bd      	mov	sp, r7
 80236f0:	bd80      	pop	{r7, pc}
 80236f2:	bf00      	nop
 80236f4:	2000c3e0 	.word	0x2000c3e0

080236f8 <lv_page_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_page_signal(lv_obj_t * page, lv_signal_t sign, void * param)
{
 80236f8:	b590      	push	{r4, r7, lr}
 80236fa:	b08f      	sub	sp, #60	; 0x3c
 80236fc:	af00      	add	r7, sp, #0
 80236fe:	60f8      	str	r0, [r7, #12]
 8023700:	460b      	mov	r3, r1
 8023702:	607a      	str	r2, [r7, #4]
 8023704:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(page, sign, param);
 8023706:	4ba1      	ldr	r3, [pc, #644]	; (802398c <lv_page_signal+0x294>)
 8023708:	681b      	ldr	r3, [r3, #0]
 802370a:	7af9      	ldrb	r1, [r7, #11]
 802370c:	687a      	ldr	r2, [r7, #4]
 802370e:	68f8      	ldr	r0, [r7, #12]
 8023710:	4798      	blx	r3
 8023712:	4603      	mov	r3, r0
 8023714:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
    if(res != LV_RES_OK) return res;
 8023718:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 802371c:	2b01      	cmp	r3, #1
 802371e:	d002      	beq.n	8023726 <lv_page_signal+0x2e>
 8023720:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 8023724:	e1c7      	b.n	8023ab6 <lv_page_signal+0x3be>

    lv_page_ext_t * ext = lv_obj_get_ext_attr(page);
 8023726:	68f8      	ldr	r0, [r7, #12]
 8023728:	f7ee fe83 	bl	8012432 <lv_obj_get_ext_attr>
 802372c:	62f8      	str	r0, [r7, #44]	; 0x2c
    lv_obj_t * child;
    if(sign == LV_SIGNAL_CHILD_CHG) { /*Automatically move children to the scrollable object*/
 802372e:	7afb      	ldrb	r3, [r7, #11]
 8023730:	2b01      	cmp	r3, #1
 8023732:	f040 8086 	bne.w	8023842 <lv_page_signal+0x14a>
        const lv_style_t * style = lv_page_get_style(page, LV_PAGE_STYLE_SCRL);
 8023736:	2101      	movs	r1, #1
 8023738:	68f8      	ldr	r0, [r7, #12]
 802373a:	f7ff fc07 	bl	8022f4c <lv_page_get_style>
 802373e:	61f8      	str	r0, [r7, #28]
        lv_fit_t fit_left        = lv_page_get_scrl_fit_left(page);
 8023740:	68f8      	ldr	r0, [r7, #12]
 8023742:	f7ff f981 	bl	8022a48 <lv_page_get_scrl_fit_left>
 8023746:	4603      	mov	r3, r0
 8023748:	76fb      	strb	r3, [r7, #27]
        lv_fit_t fit_top         = lv_page_get_scrl_fit_top(page);
 802374a:	68f8      	ldr	r0, [r7, #12]
 802374c:	f7ff f98c 	bl	8022a68 <lv_page_get_scrl_fit_top>
 8023750:	4603      	mov	r3, r0
 8023752:	76bb      	strb	r3, [r7, #26]
        child                    = lv_obj_get_child(page, NULL);
 8023754:	2100      	movs	r1, #0
 8023756:	68f8      	ldr	r0, [r7, #12]
 8023758:	f7ee fcbe 	bl	80120d8 <lv_obj_get_child>
 802375c:	6378      	str	r0, [r7, #52]	; 0x34
        while(child != NULL) {
 802375e:	e06c      	b.n	802383a <lv_page_signal+0x142>
            if(lv_obj_is_protected(child, LV_PROTECT_PARENT) == false) {
 8023760:	2102      	movs	r1, #2
 8023762:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8023764:	f7ee fe36 	bl	80123d4 <lv_obj_is_protected>
 8023768:	4603      	mov	r3, r0
 802376a:	f083 0301 	eor.w	r3, r3, #1
 802376e:	b2db      	uxtb	r3, r3
 8023770:	2b00      	cmp	r3, #0
 8023772:	d05d      	beq.n	8023830 <lv_page_signal+0x138>
                lv_obj_t * tmp = child;
 8023774:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8023776:	617b      	str	r3, [r7, #20]
                child          = lv_obj_get_child(page, child); /*Get the next child before move this*/
 8023778:	6b79      	ldr	r1, [r7, #52]	; 0x34
 802377a:	68f8      	ldr	r0, [r7, #12]
 802377c:	f7ee fcac 	bl	80120d8 <lv_obj_get_child>
 8023780:	6378      	str	r0, [r7, #52]	; 0x34

                /* Reposition the child to take padding into account (Only if it's on (0;0) now)
                 * It's required to keep new the object on the same coordinate if FIT is enabled.*/
                if((tmp->coords.x1 == page->coords.x1) && (fit_left == LV_FIT_TIGHT || fit_left == LV_FIT_FILL)) {
 8023782:	697b      	ldr	r3, [r7, #20]
 8023784:	f9b3 2010 	ldrsh.w	r2, [r3, #16]
 8023788:	68fb      	ldr	r3, [r7, #12]
 802378a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802378e:	429a      	cmp	r2, r3
 8023790:	d11f      	bne.n	80237d2 <lv_page_signal+0xda>
 8023792:	7efb      	ldrb	r3, [r7, #27]
 8023794:	2b01      	cmp	r3, #1
 8023796:	d002      	beq.n	802379e <lv_page_signal+0xa6>
 8023798:	7efb      	ldrb	r3, [r7, #27]
 802379a:	2b03      	cmp	r3, #3
 802379c:	d119      	bne.n	80237d2 <lv_page_signal+0xda>
                    tmp->coords.x1 += style->body.padding.left;
 802379e:	697b      	ldr	r3, [r7, #20]
 80237a0:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80237a4:	b29a      	uxth	r2, r3
 80237a6:	69fb      	ldr	r3, [r7, #28]
 80237a8:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 80237ac:	b29b      	uxth	r3, r3
 80237ae:	4413      	add	r3, r2
 80237b0:	b29b      	uxth	r3, r3
 80237b2:	b21a      	sxth	r2, r3
 80237b4:	697b      	ldr	r3, [r7, #20]
 80237b6:	821a      	strh	r2, [r3, #16]
                    tmp->coords.x2 += style->body.padding.left;
 80237b8:	697b      	ldr	r3, [r7, #20]
 80237ba:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 80237be:	b29a      	uxth	r2, r3
 80237c0:	69fb      	ldr	r3, [r7, #28]
 80237c2:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 80237c6:	b29b      	uxth	r3, r3
 80237c8:	4413      	add	r3, r2
 80237ca:	b29b      	uxth	r3, r3
 80237cc:	b21a      	sxth	r2, r3
 80237ce:	697b      	ldr	r3, [r7, #20]
 80237d0:	829a      	strh	r2, [r3, #20]
                }
                if((tmp->coords.y1 == page->coords.y1) && (fit_top == LV_FIT_TIGHT || fit_top == LV_FIT_FILL)) {
 80237d2:	697b      	ldr	r3, [r7, #20]
 80237d4:	f9b3 2012 	ldrsh.w	r2, [r3, #18]
 80237d8:	68fb      	ldr	r3, [r7, #12]
 80237da:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80237de:	429a      	cmp	r2, r3
 80237e0:	d11f      	bne.n	8023822 <lv_page_signal+0x12a>
 80237e2:	7ebb      	ldrb	r3, [r7, #26]
 80237e4:	2b01      	cmp	r3, #1
 80237e6:	d002      	beq.n	80237ee <lv_page_signal+0xf6>
 80237e8:	7ebb      	ldrb	r3, [r7, #26]
 80237ea:	2b03      	cmp	r3, #3
 80237ec:	d119      	bne.n	8023822 <lv_page_signal+0x12a>
                    tmp->coords.y1 += style->body.padding.top;
 80237ee:	697b      	ldr	r3, [r7, #20]
 80237f0:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80237f4:	b29a      	uxth	r2, r3
 80237f6:	69fb      	ldr	r3, [r7, #28]
 80237f8:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80237fc:	b29b      	uxth	r3, r3
 80237fe:	4413      	add	r3, r2
 8023800:	b29b      	uxth	r3, r3
 8023802:	b21a      	sxth	r2, r3
 8023804:	697b      	ldr	r3, [r7, #20]
 8023806:	825a      	strh	r2, [r3, #18]
                    tmp->coords.y2 += style->body.padding.top;
 8023808:	697b      	ldr	r3, [r7, #20]
 802380a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 802380e:	b29a      	uxth	r2, r3
 8023810:	69fb      	ldr	r3, [r7, #28]
 8023812:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023816:	b29b      	uxth	r3, r3
 8023818:	4413      	add	r3, r2
 802381a:	b29b      	uxth	r3, r3
 802381c:	b21a      	sxth	r2, r3
 802381e:	697b      	ldr	r3, [r7, #20]
 8023820:	82da      	strh	r2, [r3, #22]
                }
                lv_obj_set_parent(tmp, ext->scrl);
 8023822:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023824:	685b      	ldr	r3, [r3, #4]
 8023826:	4619      	mov	r1, r3
 8023828:	6978      	ldr	r0, [r7, #20]
 802382a:	f7ed fb8f 	bl	8010f4c <lv_obj_set_parent>
 802382e:	e004      	b.n	802383a <lv_page_signal+0x142>
            } else {
                child = lv_obj_get_child(page, child);
 8023830:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8023832:	68f8      	ldr	r0, [r7, #12]
 8023834:	f7ee fc50 	bl	80120d8 <lv_obj_get_child>
 8023838:	6378      	str	r0, [r7, #52]	; 0x34
        while(child != NULL) {
 802383a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 802383c:	2b00      	cmp	r3, #0
 802383e:	d18f      	bne.n	8023760 <lv_page_signal+0x68>
 8023840:	e137      	b.n	8023ab2 <lv_page_signal+0x3ba>
            }
        }
    } else if(sign == LV_SIGNAL_STYLE_CHG) {
 8023842:	7afb      	ldrb	r3, [r7, #11]
 8023844:	2b04      	cmp	r3, #4
 8023846:	d11e      	bne.n	8023886 <lv_page_signal+0x18e>
        ext->scrl->signal_cb(ext->scrl, LV_SIGNAL_CORD_CHG, &ext->scrl->coords);
 8023848:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802384a:	685b      	ldr	r3, [r3, #4]
 802384c:	69db      	ldr	r3, [r3, #28]
 802384e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8023850:	6850      	ldr	r0, [r2, #4]
 8023852:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8023854:	6852      	ldr	r2, [r2, #4]
 8023856:	3210      	adds	r2, #16
 8023858:	2102      	movs	r1, #2
 802385a:	4798      	blx	r3

        /*The scrollbars are important only if they are visible now*/
        if(ext->sb.hor_draw || ext->sb.ver_draw) lv_page_sb_refresh(page);
 802385c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802385e:	7f1b      	ldrb	r3, [r3, #28]
 8023860:	f003 0301 	and.w	r3, r3, #1
 8023864:	b2db      	uxtb	r3, r3
 8023866:	2b00      	cmp	r3, #0
 8023868:	d106      	bne.n	8023878 <lv_page_signal+0x180>
 802386a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802386c:	7f1b      	ldrb	r3, [r3, #28]
 802386e:	f003 0302 	and.w	r3, r3, #2
 8023872:	b2db      	uxtb	r3, r3
 8023874:	2b00      	cmp	r3, #0
 8023876:	d002      	beq.n	802387e <lv_page_signal+0x186>
 8023878:	68f8      	ldr	r0, [r7, #12]
 802387a:	f000 fceb 	bl	8024254 <lv_page_sb_refresh>

        /*Refresh the ext. size because the scrollbars might be positioned out of the page*/
        lv_obj_refresh_ext_draw_pad(page);
 802387e:	68f8      	ldr	r0, [r7, #12]
 8023880:	f7ee fbb0 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>
 8023884:	e115      	b.n	8023ab2 <lv_page_signal+0x3ba>
    } else if(sign == LV_SIGNAL_CORD_CHG) {
 8023886:	7afb      	ldrb	r3, [r7, #11]
 8023888:	2b02      	cmp	r3, #2
 802388a:	d138      	bne.n	80238fe <lv_page_signal+0x206>
        /*Refresh the scrollbar and notify the scrl if the size is changed*/
        if(ext->scrl != NULL && (lv_obj_get_width(page) != lv_area_get_width(param) ||
 802388c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802388e:	685b      	ldr	r3, [r3, #4]
 8023890:	2b00      	cmp	r3, #0
 8023892:	f000 810e 	beq.w	8023ab2 <lv_page_signal+0x3ba>
 8023896:	68f8      	ldr	r0, [r7, #12]
 8023898:	f7ee fc7c 	bl	8012194 <lv_obj_get_width>
 802389c:	4603      	mov	r3, r0
 802389e:	461c      	mov	r4, r3
 80238a0:	6878      	ldr	r0, [r7, #4]
 80238a2:	f7ff f893 	bl	80229cc <lv_area_get_width>
 80238a6:	4603      	mov	r3, r0
 80238a8:	429c      	cmp	r4, r3
 80238aa:	d10b      	bne.n	80238c4 <lv_page_signal+0x1cc>
                                 lv_obj_get_height(page) != lv_area_get_height(param))) {
 80238ac:	68f8      	ldr	r0, [r7, #12]
 80238ae:	f7ee fc7f 	bl	80121b0 <lv_obj_get_height>
 80238b2:	4603      	mov	r3, r0
 80238b4:	461c      	mov	r4, r3
 80238b6:	6878      	ldr	r0, [r7, #4]
 80238b8:	f7ff f89f 	bl	80229fa <lv_area_get_height>
 80238bc:	4603      	mov	r3, r0
        if(ext->scrl != NULL && (lv_obj_get_width(page) != lv_area_get_width(param) ||
 80238be:	429c      	cmp	r4, r3
 80238c0:	f000 80f7 	beq.w	8023ab2 <lv_page_signal+0x3ba>
            /*If no hor_fit enabled set the scrollable's width to the page's width*/
            ext->scrl->signal_cb(ext->scrl, LV_SIGNAL_CORD_CHG, &ext->scrl->coords);
 80238c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80238c6:	685b      	ldr	r3, [r3, #4]
 80238c8:	69db      	ldr	r3, [r3, #28]
 80238ca:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80238cc:	6850      	ldr	r0, [r2, #4]
 80238ce:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 80238d0:	6852      	ldr	r2, [r2, #4]
 80238d2:	3210      	adds	r2, #16
 80238d4:	2102      	movs	r1, #2
 80238d6:	4798      	blx	r3

            /*The scrollbars are important only if they are visible now*/
            if(ext->sb.hor_draw || ext->sb.ver_draw) lv_page_sb_refresh(page);
 80238d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80238da:	7f1b      	ldrb	r3, [r3, #28]
 80238dc:	f003 0301 	and.w	r3, r3, #1
 80238e0:	b2db      	uxtb	r3, r3
 80238e2:	2b00      	cmp	r3, #0
 80238e4:	d107      	bne.n	80238f6 <lv_page_signal+0x1fe>
 80238e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80238e8:	7f1b      	ldrb	r3, [r3, #28]
 80238ea:	f003 0302 	and.w	r3, r3, #2
 80238ee:	b2db      	uxtb	r3, r3
 80238f0:	2b00      	cmp	r3, #0
 80238f2:	f000 80de 	beq.w	8023ab2 <lv_page_signal+0x3ba>
 80238f6:	68f8      	ldr	r0, [r7, #12]
 80238f8:	f000 fcac 	bl	8024254 <lv_page_sb_refresh>
 80238fc:	e0d9      	b.n	8023ab2 <lv_page_signal+0x3ba>
        }
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 80238fe:	7afb      	ldrb	r3, [r7, #11]
 8023900:	2b05      	cmp	r3, #5
 8023902:	d12b      	bne.n	802395c <lv_page_signal+0x264>
        /*Ensure ext. size for the scrollbars if they are out of the page*/
        if(page->ext_draw_pad < (-ext->sb.style->body.padding.right))
 8023904:	68fb      	ldr	r3, [r7, #12]
 8023906:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 802390a:	461a      	mov	r2, r3
 802390c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802390e:	689b      	ldr	r3, [r3, #8]
 8023910:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8023914:	425b      	negs	r3, r3
 8023916:	429a      	cmp	r2, r3
 8023918:	da09      	bge.n	802392e <lv_page_signal+0x236>
            page->ext_draw_pad = -ext->sb.style->body.padding.right;
 802391a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 802391c:	689b      	ldr	r3, [r3, #8]
 802391e:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8023922:	b29b      	uxth	r3, r3
 8023924:	425b      	negs	r3, r3
 8023926:	b29b      	uxth	r3, r3
 8023928:	b21a      	sxth	r2, r3
 802392a:	68fb      	ldr	r3, [r7, #12]
 802392c:	869a      	strh	r2, [r3, #52]	; 0x34
        if(page->ext_draw_pad < (-ext->sb.style->body.padding.bottom))
 802392e:	68fb      	ldr	r3, [r7, #12]
 8023930:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8023934:	461a      	mov	r2, r3
 8023936:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023938:	689b      	ldr	r3, [r3, #8]
 802393a:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802393e:	425b      	negs	r3, r3
 8023940:	429a      	cmp	r2, r3
 8023942:	f280 80b6 	bge.w	8023ab2 <lv_page_signal+0x3ba>
            page->ext_draw_pad = -ext->sb.style->body.padding.bottom;
 8023946:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8023948:	689b      	ldr	r3, [r3, #8]
 802394a:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802394e:	b29b      	uxth	r3, r3
 8023950:	425b      	negs	r3, r3
 8023952:	b29b      	uxth	r3, r3
 8023954:	b21a      	sxth	r2, r3
 8023956:	68fb      	ldr	r3, [r7, #12]
 8023958:	869a      	strh	r2, [r3, #52]	; 0x34
 802395a:	e0aa      	b.n	8023ab2 <lv_page_signal+0x3ba>
    } else if(sign == LV_SIGNAL_CONTROL) {
 802395c:	7afb      	ldrb	r3, [r7, #11]
 802395e:	2b11      	cmp	r3, #17
 8023960:	d17d      	bne.n	8023a5e <lv_page_signal+0x366>
        uint32_t c = *((uint32_t *)param);
 8023962:	687b      	ldr	r3, [r7, #4]
 8023964:	681b      	ldr	r3, [r3, #0]
 8023966:	623b      	str	r3, [r7, #32]

        if(c == LV_KEY_DOWN) {
 8023968:	6a3b      	ldr	r3, [r7, #32]
 802396a:	2b12      	cmp	r3, #18
 802396c:	d110      	bne.n	8023990 <lv_page_signal+0x298>
            lv_page_scroll_ver(page, -lv_obj_get_height(page) / 4);
 802396e:	68f8      	ldr	r0, [r7, #12]
 8023970:	f7ee fc1e 	bl	80121b0 <lv_obj_get_height>
 8023974:	4603      	mov	r3, r0
 8023976:	425b      	negs	r3, r3
 8023978:	2b00      	cmp	r3, #0
 802397a:	da00      	bge.n	802397e <lv_page_signal+0x286>
 802397c:	3303      	adds	r3, #3
 802397e:	109b      	asrs	r3, r3, #2
 8023980:	b21b      	sxth	r3, r3
 8023982:	4619      	mov	r1, r3
 8023984:	68f8      	ldr	r0, [r7, #12]
 8023986:	f7ff fb55 	bl	8023034 <lv_page_scroll_ver>
 802398a:	e092      	b.n	8023ab2 <lv_page_signal+0x3ba>
 802398c:	2000c3e4 	.word	0x2000c3e4
        } else if(c == LV_KEY_UP) {
 8023990:	6a3b      	ldr	r3, [r7, #32]
 8023992:	2b11      	cmp	r3, #17
 8023994:	d10d      	bne.n	80239b2 <lv_page_signal+0x2ba>
            lv_page_scroll_ver(page, lv_obj_get_height(page) / 4);
 8023996:	68f8      	ldr	r0, [r7, #12]
 8023998:	f7ee fc0a 	bl	80121b0 <lv_obj_get_height>
 802399c:	4603      	mov	r3, r0
 802399e:	2b00      	cmp	r3, #0
 80239a0:	da00      	bge.n	80239a4 <lv_page_signal+0x2ac>
 80239a2:	3303      	adds	r3, #3
 80239a4:	109b      	asrs	r3, r3, #2
 80239a6:	b21b      	sxth	r3, r3
 80239a8:	4619      	mov	r1, r3
 80239aa:	68f8      	ldr	r0, [r7, #12]
 80239ac:	f7ff fb42 	bl	8023034 <lv_page_scroll_ver>
 80239b0:	e07f      	b.n	8023ab2 <lv_page_signal+0x3ba>
        } else if(c == LV_KEY_RIGHT) {
 80239b2:	6a3b      	ldr	r3, [r7, #32]
 80239b4:	2b13      	cmp	r3, #19
 80239b6:	d128      	bne.n	8023a0a <lv_page_signal+0x312>
            /*If the page can't be scrolled horizontally because it's not wide enough then scroll it
             * vertically*/
            if(lv_page_get_scrl_width(page) <= lv_obj_get_width(page))
 80239b8:	68f8      	ldr	r0, [r7, #12]
 80239ba:	f7ff f835 	bl	8022a28 <lv_page_get_scrl_width>
 80239be:	4603      	mov	r3, r0
 80239c0:	461c      	mov	r4, r3
 80239c2:	68f8      	ldr	r0, [r7, #12]
 80239c4:	f7ee fbe6 	bl	8012194 <lv_obj_get_width>
 80239c8:	4603      	mov	r3, r0
 80239ca:	429c      	cmp	r4, r3
 80239cc:	dc0e      	bgt.n	80239ec <lv_page_signal+0x2f4>
                lv_page_scroll_ver(page, -lv_obj_get_height(page) / 4);
 80239ce:	68f8      	ldr	r0, [r7, #12]
 80239d0:	f7ee fbee 	bl	80121b0 <lv_obj_get_height>
 80239d4:	4603      	mov	r3, r0
 80239d6:	425b      	negs	r3, r3
 80239d8:	2b00      	cmp	r3, #0
 80239da:	da00      	bge.n	80239de <lv_page_signal+0x2e6>
 80239dc:	3303      	adds	r3, #3
 80239de:	109b      	asrs	r3, r3, #2
 80239e0:	b21b      	sxth	r3, r3
 80239e2:	4619      	mov	r1, r3
 80239e4:	68f8      	ldr	r0, [r7, #12]
 80239e6:	f7ff fb25 	bl	8023034 <lv_page_scroll_ver>
 80239ea:	e062      	b.n	8023ab2 <lv_page_signal+0x3ba>
            else
                lv_page_scroll_hor(page, -lv_obj_get_width(page) / 4);
 80239ec:	68f8      	ldr	r0, [r7, #12]
 80239ee:	f7ee fbd1 	bl	8012194 <lv_obj_get_width>
 80239f2:	4603      	mov	r3, r0
 80239f4:	425b      	negs	r3, r3
 80239f6:	2b00      	cmp	r3, #0
 80239f8:	da00      	bge.n	80239fc <lv_page_signal+0x304>
 80239fa:	3303      	adds	r3, #3
 80239fc:	109b      	asrs	r3, r3, #2
 80239fe:	b21b      	sxth	r3, r3
 8023a00:	4619      	mov	r1, r3
 8023a02:	68f8      	ldr	r0, [r7, #12]
 8023a04:	f7ff fad8 	bl	8022fb8 <lv_page_scroll_hor>
 8023a08:	e053      	b.n	8023ab2 <lv_page_signal+0x3ba>
        } else if(c == LV_KEY_LEFT) {
 8023a0a:	6a3b      	ldr	r3, [r7, #32]
 8023a0c:	2b14      	cmp	r3, #20
 8023a0e:	d150      	bne.n	8023ab2 <lv_page_signal+0x3ba>
            /*If the page can't be scrolled horizontally because it's not wide enough then scroll it
             * vertically*/
            if(lv_page_get_scrl_width(page) <= lv_obj_get_width(page))
 8023a10:	68f8      	ldr	r0, [r7, #12]
 8023a12:	f7ff f809 	bl	8022a28 <lv_page_get_scrl_width>
 8023a16:	4603      	mov	r3, r0
 8023a18:	461c      	mov	r4, r3
 8023a1a:	68f8      	ldr	r0, [r7, #12]
 8023a1c:	f7ee fbba 	bl	8012194 <lv_obj_get_width>
 8023a20:	4603      	mov	r3, r0
 8023a22:	429c      	cmp	r4, r3
 8023a24:	dc0d      	bgt.n	8023a42 <lv_page_signal+0x34a>
                lv_page_scroll_ver(page, lv_obj_get_height(page) / 4);
 8023a26:	68f8      	ldr	r0, [r7, #12]
 8023a28:	f7ee fbc2 	bl	80121b0 <lv_obj_get_height>
 8023a2c:	4603      	mov	r3, r0
 8023a2e:	2b00      	cmp	r3, #0
 8023a30:	da00      	bge.n	8023a34 <lv_page_signal+0x33c>
 8023a32:	3303      	adds	r3, #3
 8023a34:	109b      	asrs	r3, r3, #2
 8023a36:	b21b      	sxth	r3, r3
 8023a38:	4619      	mov	r1, r3
 8023a3a:	68f8      	ldr	r0, [r7, #12]
 8023a3c:	f7ff fafa 	bl	8023034 <lv_page_scroll_ver>
 8023a40:	e037      	b.n	8023ab2 <lv_page_signal+0x3ba>
            else
                lv_page_scroll_hor(page, lv_obj_get_width(page) / 4);
 8023a42:	68f8      	ldr	r0, [r7, #12]
 8023a44:	f7ee fba6 	bl	8012194 <lv_obj_get_width>
 8023a48:	4603      	mov	r3, r0
 8023a4a:	2b00      	cmp	r3, #0
 8023a4c:	da00      	bge.n	8023a50 <lv_page_signal+0x358>
 8023a4e:	3303      	adds	r3, #3
 8023a50:	109b      	asrs	r3, r3, #2
 8023a52:	b21b      	sxth	r3, r3
 8023a54:	4619      	mov	r1, r3
 8023a56:	68f8      	ldr	r0, [r7, #12]
 8023a58:	f7ff faae 	bl	8022fb8 <lv_page_scroll_hor>
 8023a5c:	e029      	b.n	8023ab2 <lv_page_signal+0x3ba>
        }
    } else if(sign == LV_SIGNAL_GET_EDITABLE) {
 8023a5e:	7afb      	ldrb	r3, [r7, #11]
 8023a60:	2b12      	cmp	r3, #18
 8023a62:	d105      	bne.n	8023a70 <lv_page_signal+0x378>
        bool * editable = (bool *)param;
 8023a64:	687b      	ldr	r3, [r7, #4]
 8023a66:	627b      	str	r3, [r7, #36]	; 0x24
        *editable       = true;
 8023a68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8023a6a:	2201      	movs	r2, #1
 8023a6c:	701a      	strb	r2, [r3, #0]
 8023a6e:	e020      	b.n	8023ab2 <lv_page_signal+0x3ba>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 8023a70:	7afb      	ldrb	r3, [r7, #11]
 8023a72:	2b06      	cmp	r3, #6
 8023a74:	d11d      	bne.n	8023ab2 <lv_page_signal+0x3ba>
        lv_obj_type_t * buf = param;
 8023a76:	687b      	ldr	r3, [r7, #4]
 8023a78:	62bb      	str	r3, [r7, #40]	; 0x28
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8023a7a:	2300      	movs	r3, #0
 8023a7c:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8023a80:	e00b      	b.n	8023a9a <lv_page_signal+0x3a2>
            if(buf->type[i] == NULL) break;
 8023a82:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 8023a86:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023a88:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8023a8c:	2b00      	cmp	r3, #0
 8023a8e:	d009      	beq.n	8023aa4 <lv_page_signal+0x3ac>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8023a90:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8023a94:	3301      	adds	r3, #1
 8023a96:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 8023a9a:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
 8023a9e:	2b06      	cmp	r3, #6
 8023aa0:	d9ef      	bls.n	8023a82 <lv_page_signal+0x38a>
 8023aa2:	e000      	b.n	8023aa6 <lv_page_signal+0x3ae>
            if(buf->type[i] == NULL) break;
 8023aa4:	bf00      	nop
        }
        buf->type[i] = "lv_page";
 8023aa6:	f897 2033 	ldrb.w	r2, [r7, #51]	; 0x33
 8023aaa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8023aac:	4904      	ldr	r1, [pc, #16]	; (8023ac0 <lv_page_signal+0x3c8>)
 8023aae:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    }

    return res;
 8023ab2:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
}
 8023ab6:	4618      	mov	r0, r3
 8023ab8:	373c      	adds	r7, #60	; 0x3c
 8023aba:	46bd      	mov	sp, r7
 8023abc:	bd90      	pop	{r4, r7, pc}
 8023abe:	bf00      	nop
 8023ac0:	080290f4 	.word	0x080290f4

08023ac4 <lv_page_scrollable_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_page_scrollable_signal(lv_obj_t * scrl, lv_signal_t sign, void * param)
{
 8023ac4:	b590      	push	{r4, r7, lr}
 8023ac6:	b097      	sub	sp, #92	; 0x5c
 8023ac8:	af00      	add	r7, sp, #0
 8023aca:	60f8      	str	r0, [r7, #12]
 8023acc:	460b      	mov	r3, r1
 8023ace:	607a      	str	r2, [r7, #4]
 8023ad0:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(scrl, sign, param);
 8023ad2:	4bbf      	ldr	r3, [pc, #764]	; (8023dd0 <lv_page_scrollable_signal+0x30c>)
 8023ad4:	681b      	ldr	r3, [r3, #0]
 8023ad6:	7af9      	ldrb	r1, [r7, #11]
 8023ad8:	687a      	ldr	r2, [r7, #4]
 8023ada:	68f8      	ldr	r0, [r7, #12]
 8023adc:	4798      	blx	r3
 8023ade:	4603      	mov	r3, r0
 8023ae0:	f887 3051 	strb.w	r3, [r7, #81]	; 0x51
    if(res != LV_RES_OK) return res;
 8023ae4:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 8023ae8:	2b01      	cmp	r3, #1
 8023aea:	d002      	beq.n	8023af2 <lv_page_scrollable_signal+0x2e>
 8023aec:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
 8023af0:	e37e      	b.n	80241f0 <lv_page_scrollable_signal+0x72c>

    lv_obj_t * page               = lv_obj_get_parent(scrl);
 8023af2:	68f8      	ldr	r0, [r7, #12]
 8023af4:	f7ee fae4 	bl	80120c0 <lv_obj_get_parent>
 8023af8:	64f8      	str	r0, [r7, #76]	; 0x4c
    const lv_style_t * page_style = lv_obj_get_style(page);
 8023afa:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023afc:	f7ee fb7a 	bl	80121f4 <lv_obj_get_style>
 8023b00:	64b8      	str	r0, [r7, #72]	; 0x48
    lv_page_ext_t * page_ext      = lv_obj_get_ext_attr(page);
 8023b02:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023b04:	f7ee fc95 	bl	8012432 <lv_obj_get_ext_attr>
 8023b08:	6478      	str	r0, [r7, #68]	; 0x44

    if(sign == LV_SIGNAL_CORD_CHG) {
 8023b0a:	7afb      	ldrb	r3, [r7, #11]
 8023b0c:	2b02      	cmp	r3, #2
 8023b0e:	f040 82c8 	bne.w	80240a2 <lv_page_scrollable_signal+0x5de>
        /*Limit the position of the scrollable object to be always visible
         * (Do not let its edge inner then its parent respective edge)*/
        lv_coord_t new_x = lv_obj_get_x(scrl);
 8023b12:	68f8      	ldr	r0, [r7, #12]
 8023b14:	f7ee fb0c 	bl	8012130 <lv_obj_get_x>
 8023b18:	4603      	mov	r3, r0
 8023b1a:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
        lv_coord_t new_y = lv_obj_get_y(scrl);
 8023b1e:	68f8      	ldr	r0, [r7, #12]
 8023b20:	f7ee fb1f 	bl	8012162 <lv_obj_get_y>
 8023b24:	4603      	mov	r3, r0
 8023b26:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        bool refr_x      = false;
 8023b2a:	2300      	movs	r3, #0
 8023b2c:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
        bool refr_y      = false;
 8023b30:	2300      	movs	r3, #0
 8023b32:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
        lv_area_t page_coords;
        lv_area_t scrl_coords;
        lv_obj_get_coords(scrl, &scrl_coords);
 8023b36:	f107 031c 	add.w	r3, r7, #28
 8023b3a:	4619      	mov	r1, r3
 8023b3c:	68f8      	ldr	r0, [r7, #12]
 8023b3e:	f7ee fae8 	bl	8012112 <lv_obj_get_coords>
        lv_obj_get_coords(page, &page_coords);
 8023b42:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8023b46:	4619      	mov	r1, r3
 8023b48:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023b4a:	f7ee fae2 	bl	8012112 <lv_obj_get_coords>

        lv_area_t * ori_coords = (lv_area_t *)param;
 8023b4e:	687b      	ldr	r3, [r7, #4]
 8023b50:	63fb      	str	r3, [r7, #60]	; 0x3c
        lv_coord_t diff_x      = scrl->coords.x1 - ori_coords->x1;
 8023b52:	68fb      	ldr	r3, [r7, #12]
 8023b54:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8023b58:	b29a      	uxth	r2, r3
 8023b5a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8023b5c:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023b60:	b29b      	uxth	r3, r3
 8023b62:	1ad3      	subs	r3, r2, r3
 8023b64:	b29b      	uxth	r3, r3
 8023b66:	877b      	strh	r3, [r7, #58]	; 0x3a
        lv_coord_t diff_y      = scrl->coords.y1 - ori_coords->y1;
 8023b68:	68fb      	ldr	r3, [r7, #12]
 8023b6a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8023b6e:	b29a      	uxth	r2, r3
 8023b70:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8023b72:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8023b76:	b29b      	uxth	r3, r3
 8023b78:	1ad3      	subs	r3, r2, r3
 8023b7a:	b29b      	uxth	r3, r3
 8023b7c:	873b      	strh	r3, [r7, #56]	; 0x38
        lv_coord_t hpad        = page_style->body.padding.left + page_style->body.padding.right;
 8023b7e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023b80:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8023b84:	b29a      	uxth	r2, r3
 8023b86:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023b88:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8023b8c:	b29b      	uxth	r3, r3
 8023b8e:	4413      	add	r3, r2
 8023b90:	b29b      	uxth	r3, r3
 8023b92:	86fb      	strh	r3, [r7, #54]	; 0x36
        lv_coord_t vpad        = page_style->body.padding.top + page_style->body.padding.bottom;
 8023b94:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023b96:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023b9a:	b29a      	uxth	r2, r3
 8023b9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023b9e:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8023ba2:	b29b      	uxth	r3, r3
 8023ba4:	4413      	add	r3, r2
 8023ba6:	b29b      	uxth	r3, r3
 8023ba8:	86bb      	strh	r3, [r7, #52]	; 0x34
        lv_obj_t * page_parent = lv_obj_get_parent(page);
 8023baa:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023bac:	f7ee fa88 	bl	80120c0 <lv_obj_get_parent>
 8023bb0:	6338      	str	r0, [r7, #48]	; 0x30

        lv_indev_t * indev = lv_indev_get_act();
 8023bb2:	f7ea ffd1 	bl	800eb58 <lv_indev_get_act>
 8023bb6:	62f8      	str	r0, [r7, #44]	; 0x2c
        lv_point_t drag_vect;
        lv_indev_get_vect(indev, &drag_vect);
 8023bb8:	f107 0318 	add.w	r3, r7, #24
 8023bbc:	4619      	mov	r1, r3
 8023bbe:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023bc0:	f7eb f857 	bl	800ec72 <lv_indev_get_vect>

        /* Start the scroll propagation if there is drag vector on the indev, but the drag is not
         * started yet and the scrollable is in a corner. It will enable the scroll propagation only
         * when a new scroll begins and not when the scrollable is already being scrolled.*/
        if(page_ext->scroll_prop && page_ext->scroll_prop_ip == 0 && lv_indev_is_dragging(indev) == false) {
 8023bc4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023bc6:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8023bca:	f003 0301 	and.w	r3, r3, #1
 8023bce:	b2db      	uxtb	r3, r3
 8023bd0:	2b00      	cmp	r3, #0
 8023bd2:	d05d      	beq.n	8023c90 <lv_page_scrollable_signal+0x1cc>
 8023bd4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023bd6:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8023bda:	f003 0302 	and.w	r3, r3, #2
 8023bde:	b2db      	uxtb	r3, r3
 8023be0:	2b00      	cmp	r3, #0
 8023be2:	d155      	bne.n	8023c90 <lv_page_scrollable_signal+0x1cc>
 8023be4:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 8023be6:	f7eb f820 	bl	800ec2a <lv_indev_is_dragging>
 8023bea:	4603      	mov	r3, r0
 8023bec:	f083 0301 	eor.w	r3, r3, #1
 8023bf0:	b2db      	uxtb	r3, r3
 8023bf2:	2b00      	cmp	r3, #0
 8023bf4:	d04c      	beq.n	8023c90 <lv_page_scrollable_signal+0x1cc>
            if(((drag_vect.y > 0 && scrl_coords.y1 == page_coords.y1 + page_style->body.padding.top) ||
 8023bf6:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8023bfa:	2b00      	cmp	r3, #0
 8023bfc:	dd0b      	ble.n	8023c16 <lv_page_scrollable_signal+0x152>
 8023bfe:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8023c02:	461a      	mov	r2, r3
 8023c04:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8023c08:	4619      	mov	r1, r3
 8023c0a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023c0c:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023c10:	440b      	add	r3, r1
 8023c12:	429a      	cmp	r2, r3
 8023c14:	d00f      	beq.n	8023c36 <lv_page_scrollable_signal+0x172>
                (drag_vect.y < 0 && scrl_coords.y2 == page_coords.y2 - page_style->body.padding.bottom)) &&
 8023c16:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
            if(((drag_vect.y > 0 && scrl_coords.y1 == page_coords.y1 + page_style->body.padding.top) ||
 8023c1a:	2b00      	cmp	r3, #0
 8023c1c:	da38      	bge.n	8023c90 <lv_page_scrollable_signal+0x1cc>
                (drag_vect.y < 0 && scrl_coords.y2 == page_coords.y2 - page_style->body.padding.bottom)) &&
 8023c1e:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8023c22:	461a      	mov	r2, r3
 8023c24:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8023c28:	4619      	mov	r1, r3
 8023c2a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023c2c:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8023c30:	1acb      	subs	r3, r1, r3
 8023c32:	429a      	cmp	r2, r3
 8023c34:	d12c      	bne.n	8023c90 <lv_page_scrollable_signal+0x1cc>
               ((drag_vect.x > 0 && scrl_coords.x1 == page_coords.x1 + page_style->body.padding.left) ||
 8023c36:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
                (drag_vect.y < 0 && scrl_coords.y2 == page_coords.y2 - page_style->body.padding.bottom)) &&
 8023c3a:	2b00      	cmp	r3, #0
 8023c3c:	dd0b      	ble.n	8023c56 <lv_page_scrollable_signal+0x192>
               ((drag_vect.x > 0 && scrl_coords.x1 == page_coords.x1 + page_style->body.padding.left) ||
 8023c3e:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8023c42:	461a      	mov	r2, r3
 8023c44:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8023c48:	4619      	mov	r1, r3
 8023c4a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023c4c:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8023c50:	440b      	add	r3, r1
 8023c52:	429a      	cmp	r2, r3
 8023c54:	d00f      	beq.n	8023c76 <lv_page_scrollable_signal+0x1b2>
                (drag_vect.x < 0 && scrl_coords.x2 == page_coords.x2 - page_style->body.padding.right))) {
 8023c56:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
               ((drag_vect.x > 0 && scrl_coords.x1 == page_coords.x1 + page_style->body.padding.left) ||
 8023c5a:	2b00      	cmp	r3, #0
 8023c5c:	da18      	bge.n	8023c90 <lv_page_scrollable_signal+0x1cc>
                (drag_vect.x < 0 && scrl_coords.x2 == page_coords.x2 - page_style->body.padding.right))) {
 8023c5e:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8023c62:	461a      	mov	r2, r3
 8023c64:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8023c68:	4619      	mov	r1, r3
 8023c6a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023c6c:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8023c70:	1acb      	subs	r3, r1, r3
 8023c72:	429a      	cmp	r2, r3
 8023c74:	d10c      	bne.n	8023c90 <lv_page_scrollable_signal+0x1cc>

                if(lv_obj_get_parent(page_parent) != NULL) { /*Do not propagate the scroll to a screen*/
 8023c76:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8023c78:	f7ee fa22 	bl	80120c0 <lv_obj_get_parent>
 8023c7c:	4603      	mov	r3, r0
 8023c7e:	2b00      	cmp	r3, #0
 8023c80:	d006      	beq.n	8023c90 <lv_page_scrollable_signal+0x1cc>
                    page_ext->scroll_prop_ip = 1;
 8023c82:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8023c84:	f892 302e 	ldrb.w	r3, [r2, #46]	; 0x2e
 8023c88:	f043 0302 	orr.w	r3, r3, #2
 8023c8c:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e
                }
            }
        }

        /*scrollable width smaller then page width? -> align to left*/
        if(lv_area_get_width(&scrl_coords) + hpad <= lv_area_get_width(&page_coords)) {
 8023c90:	f107 031c 	add.w	r3, r7, #28
 8023c94:	4618      	mov	r0, r3
 8023c96:	f7fe fe99 	bl	80229cc <lv_area_get_width>
 8023c9a:	4603      	mov	r3, r0
 8023c9c:	461a      	mov	r2, r3
 8023c9e:	f9b7 3036 	ldrsh.w	r3, [r7, #54]	; 0x36
 8023ca2:	18d4      	adds	r4, r2, r3
 8023ca4:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8023ca8:	4618      	mov	r0, r3
 8023caa:	f7fe fe8f 	bl	80229cc <lv_area_get_width>
 8023cae:	4603      	mov	r3, r0
 8023cb0:	429c      	cmp	r4, r3
 8023cb2:	dc14      	bgt.n	8023cde <lv_page_scrollable_signal+0x21a>
            if(scrl_coords.x1 != page_coords.x1 + page_style->body.padding.left) {
 8023cb4:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8023cb8:	461a      	mov	r2, r3
 8023cba:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8023cbe:	4619      	mov	r1, r3
 8023cc0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023cc2:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8023cc6:	440b      	add	r3, r1
 8023cc8:	429a      	cmp	r2, r3
 8023cca:	f000 80c8 	beq.w	8023e5e <lv_page_scrollable_signal+0x39a>
                new_x  = page_style->body.padding.left;
 8023cce:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023cd0:	8b5b      	ldrh	r3, [r3, #26]
 8023cd2:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                refr_x = true;
 8023cd6:	2301      	movs	r3, #1
 8023cd8:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
 8023cdc:	e0bf      	b.n	8023e5e <lv_page_scrollable_signal+0x39a>
            }
        } else {
            /*If the scroll propagation is in progress revert the original coordinates (don't let
             * the page scroll)*/
            if(page_ext->scroll_prop_ip) {
 8023cde:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023ce0:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8023ce4:	f003 0302 	and.w	r3, r3, #2
 8023ce8:	b2db      	uxtb	r3, r3
 8023cea:	2b00      	cmp	r3, #0
 8023cec:	d015      	beq.n	8023d1a <lv_page_scrollable_signal+0x256>
                if(drag_vect.x == diff_x) { /*`scrl` is bouncing: drag pos. it somewhere and here it
 8023cee:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8023cf2:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8023cf6:	429a      	cmp	r2, r3
 8023cf8:	f040 80b1 	bne.w	8023e5e <lv_page_scrollable_signal+0x39a>
                                               is reverted. Handle only the pos. because of drag*/
                    new_x  = ori_coords->x1 - page_coords.x1;
 8023cfc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8023cfe:	f9b3 3000 	ldrsh.w	r3, [r3]
 8023d02:	b29a      	uxth	r2, r3
 8023d04:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8023d08:	b29b      	uxth	r3, r3
 8023d0a:	1ad3      	subs	r3, r2, r3
 8023d0c:	b29b      	uxth	r3, r3
 8023d0e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                    refr_x = true;
 8023d12:	2301      	movs	r3, #1
 8023d14:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
 8023d18:	e0a1      	b.n	8023e5e <lv_page_scrollable_signal+0x39a>
                }
            }
            /*The edges of the scrollable can not be in the page (minus hpad) */
            else if(scrl_coords.x2 < page_coords.x2 - page_style->body.padding.right) {
 8023d1a:	f9b7 3020 	ldrsh.w	r3, [r7, #32]
 8023d1e:	461a      	mov	r2, r3
 8023d20:	f9b7 3028 	ldrsh.w	r3, [r7, #40]	; 0x28
 8023d24:	4619      	mov	r1, r3
 8023d26:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023d28:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8023d2c:	1acb      	subs	r3, r1, r3
 8023d2e:	429a      	cmp	r2, r3
 8023d30:	da50      	bge.n	8023dd4 <lv_page_scrollable_signal+0x310>
                new_x = lv_area_get_width(&page_coords) - lv_area_get_width(&scrl_coords) -
 8023d32:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8023d36:	4618      	mov	r0, r3
 8023d38:	f7fe fe48 	bl	80229cc <lv_area_get_width>
 8023d3c:	4603      	mov	r3, r0
 8023d3e:	b29c      	uxth	r4, r3
 8023d40:	f107 031c 	add.w	r3, r7, #28
 8023d44:	4618      	mov	r0, r3
 8023d46:	f7fe fe41 	bl	80229cc <lv_area_get_width>
 8023d4a:	4603      	mov	r3, r0
 8023d4c:	b29b      	uxth	r3, r3
 8023d4e:	1ae3      	subs	r3, r4, r3
 8023d50:	b29a      	uxth	r2, r3
                        page_style->body.padding.right; /* Right align */
 8023d52:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023d54:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8023d58:	b29b      	uxth	r3, r3
                new_x = lv_area_get_width(&page_coords) - lv_area_get_width(&scrl_coords) -
 8023d5a:	1ad3      	subs	r3, r2, r3
 8023d5c:	b29b      	uxth	r3, r3
 8023d5e:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                refr_x = true;
 8023d62:	2301      	movs	r3, #1
 8023d64:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
#if LV_USE_ANIMATION
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023d68:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023d6a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023d6e:	f003 0301 	and.w	r3, r3, #1
 8023d72:	b2db      	uxtb	r3, r3
 8023d74:	2b00      	cmp	r3, #0
 8023d76:	d072      	beq.n	8023e5e <lv_page_scrollable_signal+0x39a>
 8023d78:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023d7a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023d7e:	f003 0310 	and.w	r3, r3, #16
 8023d82:	b2db      	uxtb	r3, r3
 8023d84:	2b00      	cmp	r3, #0
 8023d86:	d16a      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023d88:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023d8a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023d8e:	f003 0308 	and.w	r3, r3, #8
 8023d92:	b2db      	uxtb	r3, r3
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023d94:	2b00      	cmp	r3, #0
 8023d96:	d162      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023d98:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023d9a:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023d9e:	f003 0302 	and.w	r3, r3, #2
 8023da2:	b2db      	uxtb	r3, r3
 8023da4:	2b00      	cmp	r3, #0
 8023da6:	d15a      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                   page_ext->edge_flash.bottom_ip == 0) {
 8023da8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023daa:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023dae:	f003 0304 	and.w	r3, r3, #4
 8023db2:	b2db      	uxtb	r3, r3
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023db4:	2b00      	cmp	r3, #0
 8023db6:	d152      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                    lv_page_start_edge_flash(page);
 8023db8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023dba:	f7ff f979 	bl	80230b0 <lv_page_start_edge_flash>
                    page_ext->edge_flash.right_ip = 1;
 8023dbe:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8023dc0:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8023dc4:	f043 0308 	orr.w	r3, r3, #8
 8023dc8:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 8023dcc:	e047      	b.n	8023e5e <lv_page_scrollable_signal+0x39a>
 8023dce:	bf00      	nop
 8023dd0:	2000c3e4 	.word	0x2000c3e4
                }
#endif
            } else if(scrl_coords.x1 > page_coords.x1 + page_style->body.padding.left) {
 8023dd4:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8023dd8:	461a      	mov	r2, r3
 8023dda:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	; 0x24
 8023dde:	4619      	mov	r1, r3
 8023de0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023de2:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8023de6:	440b      	add	r3, r1
 8023de8:	429a      	cmp	r2, r3
 8023dea:	dd38      	ble.n	8023e5e <lv_page_scrollable_signal+0x39a>
                new_x  = page_style->body.padding.left; /*Left align*/
 8023dec:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023dee:	8b5b      	ldrh	r3, [r3, #26]
 8023df0:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                refr_x = true;
 8023df4:	2301      	movs	r3, #1
 8023df6:	f887 3053 	strb.w	r3, [r7, #83]	; 0x53
#if LV_USE_ANIMATION
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023dfa:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023dfc:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023e00:	f003 0301 	and.w	r3, r3, #1
 8023e04:	b2db      	uxtb	r3, r3
 8023e06:	2b00      	cmp	r3, #0
 8023e08:	d029      	beq.n	8023e5e <lv_page_scrollable_signal+0x39a>
 8023e0a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023e0c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023e10:	f003 0310 	and.w	r3, r3, #16
 8023e14:	b2db      	uxtb	r3, r3
 8023e16:	2b00      	cmp	r3, #0
 8023e18:	d121      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023e1a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023e1c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023e20:	f003 0308 	and.w	r3, r3, #8
 8023e24:	b2db      	uxtb	r3, r3
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023e26:	2b00      	cmp	r3, #0
 8023e28:	d119      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023e2a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023e2c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023e30:	f003 0302 	and.w	r3, r3, #2
 8023e34:	b2db      	uxtb	r3, r3
 8023e36:	2b00      	cmp	r3, #0
 8023e38:	d111      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                   page_ext->edge_flash.bottom_ip == 0) {
 8023e3a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023e3c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023e40:	f003 0304 	and.w	r3, r3, #4
 8023e44:	b2db      	uxtb	r3, r3
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023e46:	2b00      	cmp	r3, #0
 8023e48:	d109      	bne.n	8023e5e <lv_page_scrollable_signal+0x39a>
                    lv_page_start_edge_flash(page);
 8023e4a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023e4c:	f7ff f930 	bl	80230b0 <lv_page_start_edge_flash>
                    page_ext->edge_flash.left_ip = 1;
 8023e50:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8023e52:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8023e56:	f043 0310 	orr.w	r3, r3, #16
 8023e5a:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
#endif
            }
        }

        /*scrollable height smaller then page height? -> align to top*/
        if(lv_area_get_height(&scrl_coords) + vpad <= lv_area_get_height(&page_coords)) {
 8023e5e:	f107 031c 	add.w	r3, r7, #28
 8023e62:	4618      	mov	r0, r3
 8023e64:	f7fe fdc9 	bl	80229fa <lv_area_get_height>
 8023e68:	4603      	mov	r3, r0
 8023e6a:	461a      	mov	r2, r3
 8023e6c:	f9b7 3034 	ldrsh.w	r3, [r7, #52]	; 0x34
 8023e70:	18d4      	adds	r4, r2, r3
 8023e72:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8023e76:	4618      	mov	r0, r3
 8023e78:	f7fe fdbf 	bl	80229fa <lv_area_get_height>
 8023e7c:	4603      	mov	r3, r0
 8023e7e:	429c      	cmp	r4, r3
 8023e80:	dc14      	bgt.n	8023eac <lv_page_scrollable_signal+0x3e8>
            if(scrl_coords.y1 != page_coords.y1 + page_style->body.padding.top) {
 8023e82:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8023e86:	461a      	mov	r2, r3
 8023e88:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8023e8c:	4619      	mov	r1, r3
 8023e8e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023e90:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023e94:	440b      	add	r3, r1
 8023e96:	429a      	cmp	r2, r3
 8023e98:	f000 80c5 	beq.w	8024026 <lv_page_scrollable_signal+0x562>
                new_y  = page_style->body.padding.top;
 8023e9c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023e9e:	8adb      	ldrh	r3, [r3, #22]
 8023ea0:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                refr_y = true;
 8023ea4:	2301      	movs	r3, #1
 8023ea6:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
 8023eaa:	e0bc      	b.n	8024026 <lv_page_scrollable_signal+0x562>
            }
        } else {
            /*If the scroll propagation is in progress revert the original coordinates (don't let
             * the page scroll)*/
            if(page_ext->scroll_prop_ip) {
 8023eac:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023eae:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 8023eb2:	f003 0302 	and.w	r3, r3, #2
 8023eb6:	b2db      	uxtb	r3, r3
 8023eb8:	2b00      	cmp	r3, #0
 8023eba:	d015      	beq.n	8023ee8 <lv_page_scrollable_signal+0x424>
                if(drag_vect.y == diff_y) { /*`scrl` is bouncing: drag pos. it somewhere and here it
 8023ebc:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8023ec0:	f9b7 2038 	ldrsh.w	r2, [r7, #56]	; 0x38
 8023ec4:	429a      	cmp	r2, r3
 8023ec6:	f040 80ae 	bne.w	8024026 <lv_page_scrollable_signal+0x562>
                                               is reverted. Handle only the pos. because of drag*/
                    new_y  = ori_coords->y1 - page_coords.y1;
 8023eca:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8023ecc:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8023ed0:	b29a      	uxth	r2, r3
 8023ed2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8023ed6:	b29b      	uxth	r3, r3
 8023ed8:	1ad3      	subs	r3, r2, r3
 8023eda:	b29b      	uxth	r3, r3
 8023edc:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                    refr_y = true;
 8023ee0:	2301      	movs	r3, #1
 8023ee2:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
 8023ee6:	e09e      	b.n	8024026 <lv_page_scrollable_signal+0x562>
                }
            }
            /*The edges of the scrollable can not be in the page (minus vpad) */
            else if(scrl_coords.y2 < page_coords.y2 - page_style->body.padding.bottom) {
 8023ee8:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8023eec:	461a      	mov	r2, r3
 8023eee:	f9b7 302a 	ldrsh.w	r3, [r7, #42]	; 0x2a
 8023ef2:	4619      	mov	r1, r3
 8023ef4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023ef6:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8023efa:	1acb      	subs	r3, r1, r3
 8023efc:	429a      	cmp	r2, r3
 8023efe:	da4d      	bge.n	8023f9c <lv_page_scrollable_signal+0x4d8>
                new_y = lv_area_get_height(&page_coords) - lv_area_get_height(&scrl_coords) -
 8023f00:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8023f04:	4618      	mov	r0, r3
 8023f06:	f7fe fd78 	bl	80229fa <lv_area_get_height>
 8023f0a:	4603      	mov	r3, r0
 8023f0c:	b29c      	uxth	r4, r3
 8023f0e:	f107 031c 	add.w	r3, r7, #28
 8023f12:	4618      	mov	r0, r3
 8023f14:	f7fe fd71 	bl	80229fa <lv_area_get_height>
 8023f18:	4603      	mov	r3, r0
 8023f1a:	b29b      	uxth	r3, r3
 8023f1c:	1ae3      	subs	r3, r4, r3
 8023f1e:	b29a      	uxth	r2, r3
                        page_style->body.padding.bottom; /* Bottom align */
 8023f20:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023f22:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8023f26:	b29b      	uxth	r3, r3
                new_y = lv_area_get_height(&page_coords) - lv_area_get_height(&scrl_coords) -
 8023f28:	1ad3      	subs	r3, r2, r3
 8023f2a:	b29b      	uxth	r3, r3
 8023f2c:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                refr_y = true;
 8023f30:	2301      	movs	r3, #1
 8023f32:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
#if LV_USE_ANIMATION
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023f36:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023f38:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023f3c:	f003 0301 	and.w	r3, r3, #1
 8023f40:	b2db      	uxtb	r3, r3
 8023f42:	2b00      	cmp	r3, #0
 8023f44:	d06f      	beq.n	8024026 <lv_page_scrollable_signal+0x562>
 8023f46:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023f48:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023f4c:	f003 0310 	and.w	r3, r3, #16
 8023f50:	b2db      	uxtb	r3, r3
 8023f52:	2b00      	cmp	r3, #0
 8023f54:	d167      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023f56:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023f58:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023f5c:	f003 0308 	and.w	r3, r3, #8
 8023f60:	b2db      	uxtb	r3, r3
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023f62:	2b00      	cmp	r3, #0
 8023f64:	d15f      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023f66:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023f68:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023f6c:	f003 0302 	and.w	r3, r3, #2
 8023f70:	b2db      	uxtb	r3, r3
 8023f72:	2b00      	cmp	r3, #0
 8023f74:	d157      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                   page_ext->edge_flash.bottom_ip == 0) {
 8023f76:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023f78:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023f7c:	f003 0304 	and.w	r3, r3, #4
 8023f80:	b2db      	uxtb	r3, r3
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023f82:	2b00      	cmp	r3, #0
 8023f84:	d14f      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                    lv_page_start_edge_flash(page);
 8023f86:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8023f88:	f7ff f892 	bl	80230b0 <lv_page_start_edge_flash>
                    page_ext->edge_flash.bottom_ip = 1;
 8023f8c:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8023f8e:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8023f92:	f043 0304 	orr.w	r3, r3, #4
 8023f96:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
 8023f9a:	e044      	b.n	8024026 <lv_page_scrollable_signal+0x562>
                }
#endif
            } else if(scrl_coords.y1 > page_coords.y1 + page_style->body.padding.top) {
 8023f9c:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 8023fa0:	461a      	mov	r2, r3
 8023fa2:	f9b7 3026 	ldrsh.w	r3, [r7, #38]	; 0x26
 8023fa6:	4619      	mov	r1, r3
 8023fa8:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023faa:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 8023fae:	440b      	add	r3, r1
 8023fb0:	429a      	cmp	r2, r3
 8023fb2:	dd38      	ble.n	8024026 <lv_page_scrollable_signal+0x562>
                new_y  = page_style->body.padding.top; /*Top align*/
 8023fb4:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8023fb6:	8adb      	ldrh	r3, [r3, #22]
 8023fb8:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
                refr_y = true;
 8023fbc:	2301      	movs	r3, #1
 8023fbe:	f887 3052 	strb.w	r3, [r7, #82]	; 0x52
#if LV_USE_ANIMATION
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023fc2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023fc4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023fc8:	f003 0301 	and.w	r3, r3, #1
 8023fcc:	b2db      	uxtb	r3, r3
 8023fce:	2b00      	cmp	r3, #0
 8023fd0:	d029      	beq.n	8024026 <lv_page_scrollable_signal+0x562>
 8023fd2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023fd4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023fd8:	f003 0310 	and.w	r3, r3, #16
 8023fdc:	b2db      	uxtb	r3, r3
 8023fde:	2b00      	cmp	r3, #0
 8023fe0:	d121      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023fe2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023fe4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023fe8:	f003 0308 	and.w	r3, r3, #8
 8023fec:	b2db      	uxtb	r3, r3
                if(page_ext->edge_flash.enabled && page_ext->edge_flash.left_ip == 0 &&
 8023fee:	2b00      	cmp	r3, #0
 8023ff0:	d119      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 8023ff2:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8023ff4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8023ff8:	f003 0302 	and.w	r3, r3, #2
 8023ffc:	b2db      	uxtb	r3, r3
 8023ffe:	2b00      	cmp	r3, #0
 8024000:	d111      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                   page_ext->edge_flash.bottom_ip == 0) {
 8024002:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8024004:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 8024008:	f003 0304 	and.w	r3, r3, #4
 802400c:	b2db      	uxtb	r3, r3
                   page_ext->edge_flash.right_ip == 0 && page_ext->edge_flash.top_ip == 0 &&
 802400e:	2b00      	cmp	r3, #0
 8024010:	d109      	bne.n	8024026 <lv_page_scrollable_signal+0x562>
                    lv_page_start_edge_flash(page);
 8024012:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 8024014:	f7ff f84c 	bl	80230b0 <lv_page_start_edge_flash>
                    page_ext->edge_flash.top_ip = 1;
 8024018:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 802401a:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 802401e:	f043 0302 	orr.w	r3, r3, #2
 8024022:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
                }
#endif
            }
        }

        if(refr_x || refr_y) {
 8024026:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 802402a:	2b00      	cmp	r3, #0
 802402c:	d103      	bne.n	8024036 <lv_page_scrollable_signal+0x572>
 802402e:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 8024032:	2b00      	cmp	r3, #0
 8024034:	d031      	beq.n	802409a <lv_page_scrollable_signal+0x5d6>
            lv_obj_set_pos(scrl, new_x, new_y);
 8024036:	f9b7 2054 	ldrsh.w	r2, [r7, #84]	; 0x54
 802403a:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 802403e:	4619      	mov	r1, r3
 8024040:	68f8      	ldr	r0, [r7, #12]
 8024042:	f7ed f805 	bl	8011050 <lv_obj_set_pos>

            if(page_ext->scroll_prop_ip) {
 8024046:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8024048:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 802404c:	f003 0302 	and.w	r3, r3, #2
 8024050:	b2db      	uxtb	r3, r3
 8024052:	2b00      	cmp	r3, #0
 8024054:	d021      	beq.n	802409a <lv_page_scrollable_signal+0x5d6>
                if(refr_y) lv_obj_set_y(page_parent, lv_obj_get_y(page_parent) + diff_y);
 8024056:	f897 3052 	ldrb.w	r3, [r7, #82]	; 0x52
 802405a:	2b00      	cmp	r3, #0
 802405c:	d00c      	beq.n	8024078 <lv_page_scrollable_signal+0x5b4>
 802405e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8024060:	f7ee f87f 	bl	8012162 <lv_obj_get_y>
 8024064:	4603      	mov	r3, r0
 8024066:	b29a      	uxth	r2, r3
 8024068:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 802406a:	4413      	add	r3, r2
 802406c:	b29b      	uxth	r3, r3
 802406e:	b21b      	sxth	r3, r3
 8024070:	4619      	mov	r1, r3
 8024072:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8024074:	f7ed f88c 	bl	8011190 <lv_obj_set_y>
                if(refr_x) lv_obj_set_x(page_parent, lv_obj_get_x(page_parent) + diff_x);
 8024078:	f897 3053 	ldrb.w	r3, [r7, #83]	; 0x53
 802407c:	2b00      	cmp	r3, #0
 802407e:	d00c      	beq.n	802409a <lv_page_scrollable_signal+0x5d6>
 8024080:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8024082:	f7ee f855 	bl	8012130 <lv_obj_get_x>
 8024086:	4603      	mov	r3, r0
 8024088:	b29a      	uxth	r2, r3
 802408a:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 802408c:	4413      	add	r3, r2
 802408e:	b29b      	uxth	r3, r3
 8024090:	b21b      	sxth	r3, r3
 8024092:	4619      	mov	r1, r3
 8024094:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8024096:	f7ed f866 	bl	8011166 <lv_obj_set_x>
            }
        }

        lv_page_sb_refresh(page);
 802409a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 802409c:	f000 f8da 	bl	8024254 <lv_page_sb_refresh>
 80240a0:	e0a4      	b.n	80241ec <lv_page_scrollable_signal+0x728>
    } else if(sign == LV_SIGNAL_DRAG_END) {
 80240a2:	7afb      	ldrb	r3, [r7, #11]
 80240a4:	2b0e      	cmp	r3, #14
 80240a6:	f040 80a1 	bne.w	80241ec <lv_page_scrollable_signal+0x728>

        /*Scroll propagation is finished on drag end*/
        page_ext->scroll_prop_ip = 0;
 80240aa:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80240ac:	f892 302e 	ldrb.w	r3, [r2, #46]	; 0x2e
 80240b0:	f36f 0341 	bfc	r3, #1, #1
 80240b4:	f882 302e 	strb.w	r3, [r2, #46]	; 0x2e

        /*Hide scrollbars if required*/
        if(page_ext->sb.mode == LV_SB_MODE_DRAG) {
 80240b8:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80240ba:	7f1b      	ldrb	r3, [r3, #28]
 80240bc:	f003 031c 	and.w	r3, r3, #28
 80240c0:	b2db      	uxtb	r3, r3
 80240c2:	2b08      	cmp	r3, #8
 80240c4:	f040 8092 	bne.w	80241ec <lv_page_scrollable_signal+0x728>
            lv_disp_t * disp = lv_obj_get_disp(page);
 80240c8:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 80240ca:	f7ed ffb3 	bl	8012034 <lv_obj_get_disp>
 80240ce:	6438      	str	r0, [r7, #64]	; 0x40
            lv_area_t sb_area_tmp;
            if(page_ext->sb.hor_draw) {
 80240d0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80240d2:	7f1b      	ldrb	r3, [r3, #28]
 80240d4:	f003 0301 	and.w	r3, r3, #1
 80240d8:	b2db      	uxtb	r3, r3
 80240da:	2b00      	cmp	r3, #0
 80240dc:	d03f      	beq.n	802415e <lv_page_scrollable_signal+0x69a>
                lv_area_copy(&sb_area_tmp, &page_ext->sb.hor_area);
 80240de:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 80240e0:	f103 020c 	add.w	r2, r3, #12
 80240e4:	f107 0310 	add.w	r3, r7, #16
 80240e8:	4611      	mov	r1, r2
 80240ea:	4618      	mov	r0, r3
 80240ec:	f7fe fc60 	bl	80229b0 <lv_area_copy>
                sb_area_tmp.x1 += page->coords.x1;
 80240f0:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 80240f4:	b29a      	uxth	r2, r3
 80240f6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80240f8:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80240fc:	b29b      	uxth	r3, r3
 80240fe:	4413      	add	r3, r2
 8024100:	b29b      	uxth	r3, r3
 8024102:	b21b      	sxth	r3, r3
 8024104:	823b      	strh	r3, [r7, #16]
                sb_area_tmp.y1 += page->coords.y1;
 8024106:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 802410a:	b29a      	uxth	r2, r3
 802410c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802410e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8024112:	b29b      	uxth	r3, r3
 8024114:	4413      	add	r3, r2
 8024116:	b29b      	uxth	r3, r3
 8024118:	b21b      	sxth	r3, r3
 802411a:	827b      	strh	r3, [r7, #18]
                sb_area_tmp.x2 += page->coords.x1;
 802411c:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 8024120:	b29a      	uxth	r2, r3
 8024122:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8024124:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8024128:	b29b      	uxth	r3, r3
 802412a:	4413      	add	r3, r2
 802412c:	b29b      	uxth	r3, r3
 802412e:	b21b      	sxth	r3, r3
 8024130:	82bb      	strh	r3, [r7, #20]
                sb_area_tmp.y2 += page->coords.y1;
 8024132:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8024136:	b29a      	uxth	r2, r3
 8024138:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802413a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802413e:	b29b      	uxth	r3, r3
 8024140:	4413      	add	r3, r2
 8024142:	b29b      	uxth	r3, r3
 8024144:	b21b      	sxth	r3, r3
 8024146:	82fb      	strh	r3, [r7, #22]
                lv_inv_area(disp, &sb_area_tmp);
 8024148:	f107 0310 	add.w	r3, r7, #16
 802414c:	4619      	mov	r1, r3
 802414e:	6c38      	ldr	r0, [r7, #64]	; 0x40
 8024150:	f7ee fbf4 	bl	801293c <lv_inv_area>
                page_ext->sb.hor_draw = 0;
 8024154:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 8024156:	7f13      	ldrb	r3, [r2, #28]
 8024158:	f36f 0300 	bfc	r3, #0, #1
 802415c:	7713      	strb	r3, [r2, #28]
            }
            if(page_ext->sb.ver_draw) {
 802415e:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8024160:	7f1b      	ldrb	r3, [r3, #28]
 8024162:	f003 0302 	and.w	r3, r3, #2
 8024166:	b2db      	uxtb	r3, r3
 8024168:	2b00      	cmp	r3, #0
 802416a:	d03f      	beq.n	80241ec <lv_page_scrollable_signal+0x728>
                lv_area_copy(&sb_area_tmp, &page_ext->sb.ver_area);
 802416c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 802416e:	f103 0214 	add.w	r2, r3, #20
 8024172:	f107 0310 	add.w	r3, r7, #16
 8024176:	4611      	mov	r1, r2
 8024178:	4618      	mov	r0, r3
 802417a:	f7fe fc19 	bl	80229b0 <lv_area_copy>
                sb_area_tmp.x1 += page->coords.x1;
 802417e:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8024182:	b29a      	uxth	r2, r3
 8024184:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 8024186:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802418a:	b29b      	uxth	r3, r3
 802418c:	4413      	add	r3, r2
 802418e:	b29b      	uxth	r3, r3
 8024190:	b21b      	sxth	r3, r3
 8024192:	823b      	strh	r3, [r7, #16]
                sb_area_tmp.y1 += page->coords.y1;
 8024194:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8024198:	b29a      	uxth	r2, r3
 802419a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 802419c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80241a0:	b29b      	uxth	r3, r3
 80241a2:	4413      	add	r3, r2
 80241a4:	b29b      	uxth	r3, r3
 80241a6:	b21b      	sxth	r3, r3
 80241a8:	827b      	strh	r3, [r7, #18]
                sb_area_tmp.x2 += page->coords.x1;
 80241aa:	f9b7 3014 	ldrsh.w	r3, [r7, #20]
 80241ae:	b29a      	uxth	r2, r3
 80241b0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80241b2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80241b6:	b29b      	uxth	r3, r3
 80241b8:	4413      	add	r3, r2
 80241ba:	b29b      	uxth	r3, r3
 80241bc:	b21b      	sxth	r3, r3
 80241be:	82bb      	strh	r3, [r7, #20]
                sb_area_tmp.y2 += page->coords.y1;
 80241c0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80241c4:	b29a      	uxth	r2, r3
 80241c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 80241c8:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80241cc:	b29b      	uxth	r3, r3
 80241ce:	4413      	add	r3, r2
 80241d0:	b29b      	uxth	r3, r3
 80241d2:	b21b      	sxth	r3, r3
 80241d4:	82fb      	strh	r3, [r7, #22]
                lv_inv_area(disp, &sb_area_tmp);
 80241d6:	f107 0310 	add.w	r3, r7, #16
 80241da:	4619      	mov	r1, r3
 80241dc:	6c38      	ldr	r0, [r7, #64]	; 0x40
 80241de:	f7ee fbad 	bl	801293c <lv_inv_area>
                page_ext->sb.ver_draw = 0;
 80241e2:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 80241e4:	7f13      	ldrb	r3, [r2, #28]
 80241e6:	f36f 0341 	bfc	r3, #1, #1
 80241ea:	7713      	strb	r3, [r2, #28]
            }
        }
    }

    return res;
 80241ec:	f897 3051 	ldrb.w	r3, [r7, #81]	; 0x51
}
 80241f0:	4618      	mov	r0, r3
 80241f2:	375c      	adds	r7, #92	; 0x5c
 80241f4:	46bd      	mov	sp, r7
 80241f6:	bd90      	pop	{r4, r7, pc}

080241f8 <scrl_def_event_cb>:
 * @param scrl pointer to the page's scrollable object
 * @param event type of the event
 * @param data data of the event
 */
static void scrl_def_event_cb(lv_obj_t * scrl, lv_event_t event)
{
 80241f8:	b580      	push	{r7, lr}
 80241fa:	b084      	sub	sp, #16
 80241fc:	af00      	add	r7, sp, #0
 80241fe:	6078      	str	r0, [r7, #4]
 8024200:	460b      	mov	r3, r1
 8024202:	70fb      	strb	r3, [r7, #3]
    lv_obj_t * page = lv_obj_get_parent(scrl);
 8024204:	6878      	ldr	r0, [r7, #4]
 8024206:	f7ed ff5b 	bl	80120c0 <lv_obj_get_parent>
 802420a:	60f8      	str	r0, [r7, #12]

    /*clang-format off*/
    if(event == LV_EVENT_PRESSED || event == LV_EVENT_PRESSING || event == LV_EVENT_PRESS_LOST ||
 802420c:	78fb      	ldrb	r3, [r7, #3]
 802420e:	2b00      	cmp	r3, #0
 8024210:	d014      	beq.n	802423c <scrl_def_event_cb+0x44>
 8024212:	78fb      	ldrb	r3, [r7, #3]
 8024214:	2b01      	cmp	r3, #1
 8024216:	d011      	beq.n	802423c <scrl_def_event_cb+0x44>
 8024218:	78fb      	ldrb	r3, [r7, #3]
 802421a:	2b02      	cmp	r3, #2
 802421c:	d00e      	beq.n	802423c <scrl_def_event_cb+0x44>
 802421e:	78fb      	ldrb	r3, [r7, #3]
 8024220:	2b07      	cmp	r3, #7
 8024222:	d00b      	beq.n	802423c <scrl_def_event_cb+0x44>
       event == LV_EVENT_RELEASED || event == LV_EVENT_SHORT_CLICKED || event == LV_EVENT_CLICKED ||
 8024224:	78fb      	ldrb	r3, [r7, #3]
 8024226:	2b03      	cmp	r3, #3
 8024228:	d008      	beq.n	802423c <scrl_def_event_cb+0x44>
 802422a:	78fb      	ldrb	r3, [r7, #3]
 802422c:	2b06      	cmp	r3, #6
 802422e:	d005      	beq.n	802423c <scrl_def_event_cb+0x44>
 8024230:	78fb      	ldrb	r3, [r7, #3]
 8024232:	2b04      	cmp	r3, #4
 8024234:	d002      	beq.n	802423c <scrl_def_event_cb+0x44>
       event == LV_EVENT_LONG_PRESSED || event == LV_EVENT_LONG_PRESSED_REPEAT) {
 8024236:	78fb      	ldrb	r3, [r7, #3]
 8024238:	2b05      	cmp	r3, #5
 802423a:	d107      	bne.n	802424c <scrl_def_event_cb+0x54>
        lv_event_send(page, event, lv_event_get_data());
 802423c:	f7ed fe94 	bl	8011f68 <lv_event_get_data>
 8024240:	4602      	mov	r2, r0
 8024242:	78fb      	ldrb	r3, [r7, #3]
 8024244:	4619      	mov	r1, r3
 8024246:	68f8      	ldr	r0, [r7, #12]
 8024248:	f7ed fe09 	bl	8011e5e <lv_event_send>
    }
    /*clang-format on*/
}
 802424c:	bf00      	nop
 802424e:	3710      	adds	r7, #16
 8024250:	46bd      	mov	sp, r7
 8024252:	bd80      	pop	{r7, pc}

08024254 <lv_page_sb_refresh>:
/**
 * Refresh the position and size of the scroll bars.
 * @param page pointer to a page object
 */
static void lv_page_sb_refresh(lv_obj_t * page)
{
 8024254:	b5f0      	push	{r4, r5, r6, r7, lr}
 8024256:	b08d      	sub	sp, #52	; 0x34
 8024258:	af00      	add	r7, sp, #0
 802425a:	6078      	str	r0, [r7, #4]
    lv_page_ext_t * ext      = lv_obj_get_ext_attr(page);
 802425c:	6878      	ldr	r0, [r7, #4]
 802425e:	f7ee f8e8 	bl	8012432 <lv_obj_get_ext_attr>
 8024262:	62b8      	str	r0, [r7, #40]	; 0x28
    const lv_style_t * style = lv_obj_get_style(page);
 8024264:	6878      	ldr	r0, [r7, #4]
 8024266:	f7ed ffc5 	bl	80121f4 <lv_obj_get_style>
 802426a:	6278      	str	r0, [r7, #36]	; 0x24
    lv_obj_t * scrl          = ext->scrl;
 802426c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802426e:	685b      	ldr	r3, [r3, #4]
 8024270:	623b      	str	r3, [r7, #32]
    lv_coord_t size_tmp;
    lv_coord_t scrl_w = lv_obj_get_width(scrl);
 8024272:	6a38      	ldr	r0, [r7, #32]
 8024274:	f7ed ff8e 	bl	8012194 <lv_obj_get_width>
 8024278:	4603      	mov	r3, r0
 802427a:	83fb      	strh	r3, [r7, #30]
    lv_coord_t scrl_h = lv_obj_get_height(scrl);
 802427c:	6a38      	ldr	r0, [r7, #32]
 802427e:	f7ed ff97 	bl	80121b0 <lv_obj_get_height>
 8024282:	4603      	mov	r3, r0
 8024284:	83bb      	strh	r3, [r7, #28]
    lv_coord_t obj_w  = lv_obj_get_width(page);
 8024286:	6878      	ldr	r0, [r7, #4]
 8024288:	f7ed ff84 	bl	8012194 <lv_obj_get_width>
 802428c:	4603      	mov	r3, r0
 802428e:	837b      	strh	r3, [r7, #26]
    lv_coord_t obj_h  = lv_obj_get_height(page);
 8024290:	6878      	ldr	r0, [r7, #4]
 8024292:	f7ed ff8d 	bl	80121b0 <lv_obj_get_height>
 8024296:	4603      	mov	r3, r0
 8024298:	833b      	strh	r3, [r7, #24]

    /*Always let 'scrollbar width' padding above, under, left and right to the scrollbars
     * else:
     * - horizontal and vertical scrollbars can overlap on the corners
     * - if the page has radius the scrollbar can be out of the radius  */
    lv_coord_t sb_hor_pad = LV_MATH_MAX(ext->sb.style->body.padding.inner, style->body.padding.right);
 802429a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 802429c:	f9b3 201c 	ldrsh.w	r2, [r3, #28]
 80242a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80242a2:	689b      	ldr	r3, [r3, #8]
 80242a4:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 80242a8:	4293      	cmp	r3, r2
 80242aa:	bfb8      	it	lt
 80242ac:	4613      	movlt	r3, r2
 80242ae:	82fb      	strh	r3, [r7, #22]
    lv_coord_t sb_ver_pad = LV_MATH_MAX(ext->sb.style->body.padding.inner, style->body.padding.bottom);
 80242b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80242b2:	f9b3 2018 	ldrsh.w	r2, [r3, #24]
 80242b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80242b8:	689b      	ldr	r3, [r3, #8]
 80242ba:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 80242be:	4293      	cmp	r3, r2
 80242c0:	bfb8      	it	lt
 80242c2:	4613      	movlt	r3, r2
 80242c4:	82bb      	strh	r3, [r7, #20]

    if(ext->sb.mode == LV_SB_MODE_OFF) return;
 80242c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80242c8:	7f1b      	ldrb	r3, [r3, #28]
 80242ca:	f003 031c 	and.w	r3, r3, #28
 80242ce:	b2db      	uxtb	r3, r3
 80242d0:	2b00      	cmp	r3, #0
 80242d2:	f000 82ba 	beq.w	802484a <lv_page_sb_refresh+0x5f6>

    if(ext->sb.mode == LV_SB_MODE_ON) {
 80242d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80242d8:	7f1b      	ldrb	r3, [r3, #28]
 80242da:	f003 031c 	and.w	r3, r3, #28
 80242de:	b2db      	uxtb	r3, r3
 80242e0:	2b04      	cmp	r3, #4
 80242e2:	d109      	bne.n	80242f8 <lv_page_sb_refresh+0xa4>
        ext->sb.hor_draw = 1;
 80242e4:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80242e6:	7f13      	ldrb	r3, [r2, #28]
 80242e8:	f043 0301 	orr.w	r3, r3, #1
 80242ec:	7713      	strb	r3, [r2, #28]
        ext->sb.ver_draw = 1;
 80242ee:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80242f0:	7f13      	ldrb	r3, [r2, #28]
 80242f2:	f043 0302 	orr.w	r3, r3, #2
 80242f6:	7713      	strb	r3, [r2, #28]
    }

    /*Invalidate the current (old) scrollbar areas*/
    lv_disp_t * disp = lv_obj_get_disp(page);
 80242f8:	6878      	ldr	r0, [r7, #4]
 80242fa:	f7ed fe9b 	bl	8012034 <lv_obj_get_disp>
 80242fe:	6138      	str	r0, [r7, #16]
    lv_area_t sb_area_tmp;
    if(ext->sb.hor_draw != 0) {
 8024300:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024302:	7f1b      	ldrb	r3, [r3, #28]
 8024304:	f003 0301 	and.w	r3, r3, #1
 8024308:	b2db      	uxtb	r3, r3
 802430a:	2b00      	cmp	r3, #0
 802430c:	d03a      	beq.n	8024384 <lv_page_sb_refresh+0x130>
        lv_area_copy(&sb_area_tmp, &ext->sb.hor_area);
 802430e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024310:	f103 020c 	add.w	r2, r3, #12
 8024314:	f107 0308 	add.w	r3, r7, #8
 8024318:	4611      	mov	r1, r2
 802431a:	4618      	mov	r0, r3
 802431c:	f7fe fb48 	bl	80229b0 <lv_area_copy>
        sb_area_tmp.x1 += page->coords.x1;
 8024320:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8024324:	b29a      	uxth	r2, r3
 8024326:	687b      	ldr	r3, [r7, #4]
 8024328:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802432c:	b29b      	uxth	r3, r3
 802432e:	4413      	add	r3, r2
 8024330:	b29b      	uxth	r3, r3
 8024332:	b21b      	sxth	r3, r3
 8024334:	813b      	strh	r3, [r7, #8]
        sb_area_tmp.y1 += page->coords.y1;
 8024336:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802433a:	b29a      	uxth	r2, r3
 802433c:	687b      	ldr	r3, [r7, #4]
 802433e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8024342:	b29b      	uxth	r3, r3
 8024344:	4413      	add	r3, r2
 8024346:	b29b      	uxth	r3, r3
 8024348:	b21b      	sxth	r3, r3
 802434a:	817b      	strh	r3, [r7, #10]
        sb_area_tmp.x2 += page->coords.x1;
 802434c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8024350:	b29a      	uxth	r2, r3
 8024352:	687b      	ldr	r3, [r7, #4]
 8024354:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8024358:	b29b      	uxth	r3, r3
 802435a:	4413      	add	r3, r2
 802435c:	b29b      	uxth	r3, r3
 802435e:	b21b      	sxth	r3, r3
 8024360:	81bb      	strh	r3, [r7, #12]
        sb_area_tmp.y2 += page->coords.y1;
 8024362:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 8024366:	b29a      	uxth	r2, r3
 8024368:	687b      	ldr	r3, [r7, #4]
 802436a:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 802436e:	b29b      	uxth	r3, r3
 8024370:	4413      	add	r3, r2
 8024372:	b29b      	uxth	r3, r3
 8024374:	b21b      	sxth	r3, r3
 8024376:	81fb      	strh	r3, [r7, #14]
        lv_inv_area(disp, &sb_area_tmp);
 8024378:	f107 0308 	add.w	r3, r7, #8
 802437c:	4619      	mov	r1, r3
 802437e:	6938      	ldr	r0, [r7, #16]
 8024380:	f7ee fadc 	bl	801293c <lv_inv_area>
    }
    if(ext->sb.ver_draw != 0) {
 8024384:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024386:	7f1b      	ldrb	r3, [r3, #28]
 8024388:	f003 0302 	and.w	r3, r3, #2
 802438c:	b2db      	uxtb	r3, r3
 802438e:	2b00      	cmp	r3, #0
 8024390:	d03a      	beq.n	8024408 <lv_page_sb_refresh+0x1b4>
        lv_area_copy(&sb_area_tmp, &ext->sb.ver_area);
 8024392:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024394:	f103 0214 	add.w	r2, r3, #20
 8024398:	f107 0308 	add.w	r3, r7, #8
 802439c:	4611      	mov	r1, r2
 802439e:	4618      	mov	r0, r3
 80243a0:	f7fe fb06 	bl	80229b0 <lv_area_copy>
        sb_area_tmp.x1 += page->coords.x1;
 80243a4:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80243a8:	b29a      	uxth	r2, r3
 80243aa:	687b      	ldr	r3, [r7, #4]
 80243ac:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80243b0:	b29b      	uxth	r3, r3
 80243b2:	4413      	add	r3, r2
 80243b4:	b29b      	uxth	r3, r3
 80243b6:	b21b      	sxth	r3, r3
 80243b8:	813b      	strh	r3, [r7, #8]
        sb_area_tmp.y1 += page->coords.y1;
 80243ba:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80243be:	b29a      	uxth	r2, r3
 80243c0:	687b      	ldr	r3, [r7, #4]
 80243c2:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80243c6:	b29b      	uxth	r3, r3
 80243c8:	4413      	add	r3, r2
 80243ca:	b29b      	uxth	r3, r3
 80243cc:	b21b      	sxth	r3, r3
 80243ce:	817b      	strh	r3, [r7, #10]
        sb_area_tmp.x2 += page->coords.x1;
 80243d0:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 80243d4:	b29a      	uxth	r2, r3
 80243d6:	687b      	ldr	r3, [r7, #4]
 80243d8:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80243dc:	b29b      	uxth	r3, r3
 80243de:	4413      	add	r3, r2
 80243e0:	b29b      	uxth	r3, r3
 80243e2:	b21b      	sxth	r3, r3
 80243e4:	81bb      	strh	r3, [r7, #12]
        sb_area_tmp.y2 += page->coords.y1;
 80243e6:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80243ea:	b29a      	uxth	r2, r3
 80243ec:	687b      	ldr	r3, [r7, #4]
 80243ee:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80243f2:	b29b      	uxth	r3, r3
 80243f4:	4413      	add	r3, r2
 80243f6:	b29b      	uxth	r3, r3
 80243f8:	b21b      	sxth	r3, r3
 80243fa:	81fb      	strh	r3, [r7, #14]
        lv_inv_area(disp, &sb_area_tmp);
 80243fc:	f107 0308 	add.w	r3, r7, #8
 8024400:	4619      	mov	r1, r3
 8024402:	6938      	ldr	r0, [r7, #16]
 8024404:	f7ee fa9a 	bl	801293c <lv_inv_area>
    }

    if(ext->sb.mode == LV_SB_MODE_DRAG && lv_indev_is_dragging(lv_indev_get_act()) == false) {
 8024408:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802440a:	7f1b      	ldrb	r3, [r3, #28]
 802440c:	f003 031c 	and.w	r3, r3, #28
 8024410:	b2db      	uxtb	r3, r3
 8024412:	2b08      	cmp	r3, #8
 8024414:	d116      	bne.n	8024444 <lv_page_sb_refresh+0x1f0>
 8024416:	f7ea fb9f 	bl	800eb58 <lv_indev_get_act>
 802441a:	4603      	mov	r3, r0
 802441c:	4618      	mov	r0, r3
 802441e:	f7ea fc04 	bl	800ec2a <lv_indev_is_dragging>
 8024422:	4603      	mov	r3, r0
 8024424:	f083 0301 	eor.w	r3, r3, #1
 8024428:	b2db      	uxtb	r3, r3
 802442a:	2b00      	cmp	r3, #0
 802442c:	d00a      	beq.n	8024444 <lv_page_sb_refresh+0x1f0>
        ext->sb.hor_draw = 0;
 802442e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8024430:	7f13      	ldrb	r3, [r2, #28]
 8024432:	f36f 0300 	bfc	r3, #0, #1
 8024436:	7713      	strb	r3, [r2, #28]
        ext->sb.ver_draw = 0;
 8024438:	6aba      	ldr	r2, [r7, #40]	; 0x28
 802443a:	7f13      	ldrb	r3, [r2, #28]
 802443c:	f36f 0341 	bfc	r3, #1, #1
 8024440:	7713      	strb	r3, [r2, #28]
        return;
 8024442:	e203      	b.n	802484c <lv_page_sb_refresh+0x5f8>
    }

    /*Full sized horizontal scrollbar*/
    if(scrl_w <= obj_w - style->body.padding.left - style->body.padding.right) {
 8024444:	f9b7 201e 	ldrsh.w	r2, [r7, #30]
 8024448:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 802444c:	6a79      	ldr	r1, [r7, #36]	; 0x24
 802444e:	f9b1 101a 	ldrsh.w	r1, [r1, #26]
 8024452:	1a5b      	subs	r3, r3, r1
 8024454:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8024456:	f9b1 101c 	ldrsh.w	r1, [r1, #28]
 802445a:	1a5b      	subs	r3, r3, r1
 802445c:	429a      	cmp	r2, r3
 802445e:	dc38      	bgt.n	80244d2 <lv_page_sb_refresh+0x27e>
        lv_area_set_width(&ext->sb.hor_area, obj_w - 2 * sb_hor_pad);
 8024460:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024462:	f103 000c 	add.w	r0, r3, #12
 8024466:	8b7a      	ldrh	r2, [r7, #26]
 8024468:	8afb      	ldrh	r3, [r7, #22]
 802446a:	005b      	lsls	r3, r3, #1
 802446c:	b29b      	uxth	r3, r3
 802446e:	1ad3      	subs	r3, r2, r3
 8024470:	b29b      	uxth	r3, r3
 8024472:	b21b      	sxth	r3, r3
 8024474:	4619      	mov	r1, r3
 8024476:	f7f7 fab6 	bl	801b9e6 <lv_area_set_width>
        lv_area_set_pos(&ext->sb.hor_area, sb_hor_pad,
 802447a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802447c:	f103 000c 	add.w	r0, r3, #12
                        obj_h - ext->sb.style->body.padding.inner - ext->sb.style->body.padding.bottom);
 8024480:	8b3a      	ldrh	r2, [r7, #24]
 8024482:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024484:	689b      	ldr	r3, [r3, #8]
 8024486:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 802448a:	b29b      	uxth	r3, r3
 802448c:	1ad3      	subs	r3, r2, r3
 802448e:	b29a      	uxth	r2, r3
 8024490:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024492:	689b      	ldr	r3, [r3, #8]
 8024494:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8024498:	b29b      	uxth	r3, r3
 802449a:	1ad3      	subs	r3, r2, r3
 802449c:	b29b      	uxth	r3, r3
        lv_area_set_pos(&ext->sb.hor_area, sb_hor_pad,
 802449e:	b21a      	sxth	r2, r3
 80244a0:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 80244a4:	4619      	mov	r1, r3
 80244a6:	f7f7 face 	bl	801ba46 <lv_area_set_pos>
        if(ext->sb.mode == LV_SB_MODE_AUTO || ext->sb.mode == LV_SB_MODE_DRAG) ext->sb.hor_draw = 0;
 80244aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80244ac:	7f1b      	ldrb	r3, [r3, #28]
 80244ae:	f003 031c 	and.w	r3, r3, #28
 80244b2:	b2db      	uxtb	r3, r3
 80244b4:	2b0c      	cmp	r3, #12
 80244b6:	d006      	beq.n	80244c6 <lv_page_sb_refresh+0x272>
 80244b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80244ba:	7f1b      	ldrb	r3, [r3, #28]
 80244bc:	f003 031c 	and.w	r3, r3, #28
 80244c0:	b2db      	uxtb	r3, r3
 80244c2:	2b08      	cmp	r3, #8
 80244c4:	d17c      	bne.n	80245c0 <lv_page_sb_refresh+0x36c>
 80244c6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80244c8:	7f13      	ldrb	r3, [r2, #28]
 80244ca:	f36f 0300 	bfc	r3, #0, #1
 80244ce:	7713      	strb	r3, [r2, #28]
 80244d0:	e076      	b.n	80245c0 <lv_page_sb_refresh+0x36c>
    }
    /*Smaller horizontal scrollbar*/
    else {
        size_tmp =
            (obj_w * (obj_w - (2 * sb_hor_pad))) / (scrl_w + style->body.padding.left + style->body.padding.right);
 80244d2:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 80244d6:	f9b7 101a 	ldrsh.w	r1, [r7, #26]
 80244da:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 80244de:	0052      	lsls	r2, r2, #1
 80244e0:	1a8a      	subs	r2, r1, r2
 80244e2:	fb02 f203 	mul.w	r2, r2, r3
 80244e6:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 80244ea:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80244ec:	f9b1 101a 	ldrsh.w	r1, [r1, #26]
 80244f0:	440b      	add	r3, r1
 80244f2:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80244f4:	f9b1 101c 	ldrsh.w	r1, [r1, #28]
 80244f8:	440b      	add	r3, r1
 80244fa:	fb92 f3f3 	sdiv	r3, r2, r3
        size_tmp =
 80244fe:	85fb      	strh	r3, [r7, #46]	; 0x2e
        if(size_tmp < LV_PAGE_SB_MIN_SIZE) size_tmp = LV_PAGE_SB_MIN_SIZE;
 8024500:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8024504:	2b0b      	cmp	r3, #11
 8024506:	dc01      	bgt.n	802450c <lv_page_sb_refresh+0x2b8>
 8024508:	230c      	movs	r3, #12
 802450a:	85fb      	strh	r3, [r7, #46]	; 0x2e
        lv_area_set_width(&ext->sb.hor_area, size_tmp);
 802450c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802450e:	330c      	adds	r3, #12
 8024510:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 8024514:	4611      	mov	r1, r2
 8024516:	4618      	mov	r0, r3
 8024518:	f7f7 fa65 	bl	801b9e6 <lv_area_set_width>

        lv_area_set_pos(&ext->sb.hor_area,
 802451c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802451e:	f103 040c 	add.w	r4, r3, #12
                        sb_hor_pad +
                            (-(lv_obj_get_x(scrl) - style->body.padding.left) * (obj_w - size_tmp - 2 * sb_hor_pad)) /
 8024522:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8024524:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 8024528:	461d      	mov	r5, r3
 802452a:	6a38      	ldr	r0, [r7, #32]
 802452c:	f7ed fe00 	bl	8012130 <lv_obj_get_x>
 8024530:	4603      	mov	r3, r0
 8024532:	1aeb      	subs	r3, r5, r3
 8024534:	f9b7 101a 	ldrsh.w	r1, [r7, #26]
 8024538:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 802453c:	1a89      	subs	r1, r1, r2
 802453e:	f9b7 2016 	ldrsh.w	r2, [r7, #22]
 8024542:	0052      	lsls	r2, r2, #1
 8024544:	1a8a      	subs	r2, r1, r2
 8024546:	fb02 f203 	mul.w	r2, r2, r3
                                (scrl_w + style->body.padding.left + style->body.padding.right - obj_w),
 802454a:	f9b7 301e 	ldrsh.w	r3, [r7, #30]
 802454e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8024550:	f9b1 101a 	ldrsh.w	r1, [r1, #26]
 8024554:	440b      	add	r3, r1
 8024556:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8024558:	f9b1 101c 	ldrsh.w	r1, [r1, #28]
 802455c:	4419      	add	r1, r3
 802455e:	f9b7 301a 	ldrsh.w	r3, [r7, #26]
 8024562:	1acb      	subs	r3, r1, r3
                            (-(lv_obj_get_x(scrl) - style->body.padding.left) * (obj_w - size_tmp - 2 * sb_hor_pad)) /
 8024564:	fb92 f3f3 	sdiv	r3, r2, r3
                        sb_hor_pad +
 8024568:	b29a      	uxth	r2, r3
 802456a:	8afb      	ldrh	r3, [r7, #22]
 802456c:	4413      	add	r3, r2
 802456e:	b29b      	uxth	r3, r3
        lv_area_set_pos(&ext->sb.hor_area,
 8024570:	b219      	sxth	r1, r3
                        obj_h - ext->sb.style->body.padding.inner - ext->sb.style->body.padding.bottom);
 8024572:	8b3a      	ldrh	r2, [r7, #24]
 8024574:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024576:	689b      	ldr	r3, [r3, #8]
 8024578:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 802457c:	b29b      	uxth	r3, r3
 802457e:	1ad3      	subs	r3, r2, r3
 8024580:	b29a      	uxth	r2, r3
 8024582:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024584:	689b      	ldr	r3, [r3, #8]
 8024586:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802458a:	b29b      	uxth	r3, r3
 802458c:	1ad3      	subs	r3, r2, r3
 802458e:	b29b      	uxth	r3, r3
        lv_area_set_pos(&ext->sb.hor_area,
 8024590:	b21b      	sxth	r3, r3
 8024592:	461a      	mov	r2, r3
 8024594:	4620      	mov	r0, r4
 8024596:	f7f7 fa56 	bl	801ba46 <lv_area_set_pos>

        if(ext->sb.mode == LV_SB_MODE_AUTO || ext->sb.mode == LV_SB_MODE_DRAG) ext->sb.hor_draw = 1;
 802459a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802459c:	7f1b      	ldrb	r3, [r3, #28]
 802459e:	f003 031c 	and.w	r3, r3, #28
 80245a2:	b2db      	uxtb	r3, r3
 80245a4:	2b0c      	cmp	r3, #12
 80245a6:	d006      	beq.n	80245b6 <lv_page_sb_refresh+0x362>
 80245a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80245aa:	7f1b      	ldrb	r3, [r3, #28]
 80245ac:	f003 031c 	and.w	r3, r3, #28
 80245b0:	b2db      	uxtb	r3, r3
 80245b2:	2b08      	cmp	r3, #8
 80245b4:	d104      	bne.n	80245c0 <lv_page_sb_refresh+0x36c>
 80245b6:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80245b8:	7f13      	ldrb	r3, [r2, #28]
 80245ba:	f043 0301 	orr.w	r3, r3, #1
 80245be:	7713      	strb	r3, [r2, #28]
    }

    /*Full sized vertical scroll bar*/
    if(scrl_h <= obj_h - style->body.padding.top - style->body.padding.bottom) {
 80245c0:	f9b7 201c 	ldrsh.w	r2, [r7, #28]
 80245c4:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80245c8:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80245ca:	f9b1 1016 	ldrsh.w	r1, [r1, #22]
 80245ce:	1a5b      	subs	r3, r3, r1
 80245d0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80245d2:	f9b1 1018 	ldrsh.w	r1, [r1, #24]
 80245d6:	1a5b      	subs	r3, r3, r1
 80245d8:	429a      	cmp	r2, r3
 80245da:	dc38      	bgt.n	802464e <lv_page_sb_refresh+0x3fa>
        lv_area_set_height(&ext->sb.ver_area, obj_h - 2 * sb_ver_pad);
 80245dc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80245de:	f103 0014 	add.w	r0, r3, #20
 80245e2:	8b3a      	ldrh	r2, [r7, #24]
 80245e4:	8abb      	ldrh	r3, [r7, #20]
 80245e6:	005b      	lsls	r3, r3, #1
 80245e8:	b29b      	uxth	r3, r3
 80245ea:	1ad3      	subs	r3, r2, r3
 80245ec:	b29b      	uxth	r3, r3
 80245ee:	b21b      	sxth	r3, r3
 80245f0:	4619      	mov	r1, r3
 80245f2:	f7f7 fa10 	bl	801ba16 <lv_area_set_height>
        lv_area_set_pos(&ext->sb.ver_area,
 80245f6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80245f8:	f103 0014 	add.w	r0, r3, #20
                        obj_w - ext->sb.style->body.padding.inner - ext->sb.style->body.padding.right, sb_ver_pad);
 80245fc:	8b7a      	ldrh	r2, [r7, #26]
 80245fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024600:	689b      	ldr	r3, [r3, #8]
 8024602:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 8024606:	b29b      	uxth	r3, r3
 8024608:	1ad3      	subs	r3, r2, r3
 802460a:	b29a      	uxth	r2, r3
 802460c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802460e:	689b      	ldr	r3, [r3, #8]
 8024610:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 8024614:	b29b      	uxth	r3, r3
 8024616:	1ad3      	subs	r3, r2, r3
 8024618:	b29b      	uxth	r3, r3
        lv_area_set_pos(&ext->sb.ver_area,
 802461a:	b21b      	sxth	r3, r3
 802461c:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 8024620:	4619      	mov	r1, r3
 8024622:	f7f7 fa10 	bl	801ba46 <lv_area_set_pos>
        if(ext->sb.mode == LV_SB_MODE_AUTO || ext->sb.mode == LV_SB_MODE_DRAG) ext->sb.ver_draw = 0;
 8024626:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024628:	7f1b      	ldrb	r3, [r3, #28]
 802462a:	f003 031c 	and.w	r3, r3, #28
 802462e:	b2db      	uxtb	r3, r3
 8024630:	2b0c      	cmp	r3, #12
 8024632:	d006      	beq.n	8024642 <lv_page_sb_refresh+0x3ee>
 8024634:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024636:	7f1b      	ldrb	r3, [r3, #28]
 8024638:	f003 031c 	and.w	r3, r3, #28
 802463c:	b2db      	uxtb	r3, r3
 802463e:	2b08      	cmp	r3, #8
 8024640:	d17e      	bne.n	8024740 <lv_page_sb_refresh+0x4ec>
 8024642:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8024644:	7f13      	ldrb	r3, [r2, #28]
 8024646:	f36f 0341 	bfc	r3, #1, #1
 802464a:	7713      	strb	r3, [r2, #28]
 802464c:	e078      	b.n	8024740 <lv_page_sb_refresh+0x4ec>
    }
    /*Smaller vertical scroll bar*/
    else {
        size_tmp =
            (obj_h * (obj_h - (2 * sb_ver_pad))) / (scrl_h + style->body.padding.top + style->body.padding.bottom);
 802464e:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8024652:	f9b7 1018 	ldrsh.w	r1, [r7, #24]
 8024656:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 802465a:	0052      	lsls	r2, r2, #1
 802465c:	1a8a      	subs	r2, r1, r2
 802465e:	fb02 f203 	mul.w	r2, r2, r3
 8024662:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 8024666:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8024668:	f9b1 1016 	ldrsh.w	r1, [r1, #22]
 802466c:	440b      	add	r3, r1
 802466e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 8024670:	f9b1 1018 	ldrsh.w	r1, [r1, #24]
 8024674:	440b      	add	r3, r1
 8024676:	fb92 f3f3 	sdiv	r3, r2, r3
        size_tmp =
 802467a:	85fb      	strh	r3, [r7, #46]	; 0x2e
        if(size_tmp < LV_PAGE_SB_MIN_SIZE) size_tmp = LV_PAGE_SB_MIN_SIZE;
 802467c:	f9b7 302e 	ldrsh.w	r3, [r7, #46]	; 0x2e
 8024680:	2b0b      	cmp	r3, #11
 8024682:	dc01      	bgt.n	8024688 <lv_page_sb_refresh+0x434>
 8024684:	230c      	movs	r3, #12
 8024686:	85fb      	strh	r3, [r7, #46]	; 0x2e
        lv_area_set_height(&ext->sb.ver_area, size_tmp);
 8024688:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802468a:	3314      	adds	r3, #20
 802468c:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 8024690:	4611      	mov	r1, r2
 8024692:	4618      	mov	r0, r3
 8024694:	f7f7 f9bf 	bl	801ba16 <lv_area_set_height>

        lv_area_set_pos(&ext->sb.ver_area,
 8024698:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802469a:	f103 0414 	add.w	r4, r3, #20
                        obj_w - ext->sb.style->body.padding.inner - ext->sb.style->body.padding.right,
 802469e:	8b7a      	ldrh	r2, [r7, #26]
 80246a0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80246a2:	689b      	ldr	r3, [r3, #8]
 80246a4:	f9b3 301e 	ldrsh.w	r3, [r3, #30]
 80246a8:	b29b      	uxth	r3, r3
 80246aa:	1ad3      	subs	r3, r2, r3
 80246ac:	b29a      	uxth	r2, r3
 80246ae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80246b0:	689b      	ldr	r3, [r3, #8]
 80246b2:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 80246b6:	b29b      	uxth	r3, r3
 80246b8:	1ad3      	subs	r3, r2, r3
 80246ba:	b29b      	uxth	r3, r3
        lv_area_set_pos(&ext->sb.ver_area,
 80246bc:	b21d      	sxth	r5, r3
                        sb_ver_pad + (-(lv_obj_get_y(scrl) - ext->sb.style->body.padding.bottom) *
 80246be:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80246c0:	689b      	ldr	r3, [r3, #8]
 80246c2:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 80246c6:	461e      	mov	r6, r3
 80246c8:	6a38      	ldr	r0, [r7, #32]
 80246ca:	f7ed fd4a 	bl	8012162 <lv_obj_get_y>
 80246ce:	4603      	mov	r3, r0
 80246d0:	1af3      	subs	r3, r6, r3
                                      (obj_h - size_tmp - 2 * sb_ver_pad)) /
 80246d2:	f9b7 1018 	ldrsh.w	r1, [r7, #24]
 80246d6:	f9b7 202e 	ldrsh.w	r2, [r7, #46]	; 0x2e
 80246da:	1a89      	subs	r1, r1, r2
 80246dc:	f9b7 2014 	ldrsh.w	r2, [r7, #20]
 80246e0:	0052      	lsls	r2, r2, #1
 80246e2:	1a8a      	subs	r2, r1, r2
                        sb_ver_pad + (-(lv_obj_get_y(scrl) - ext->sb.style->body.padding.bottom) *
 80246e4:	fb02 f203 	mul.w	r2, r2, r3
                                         (scrl_h + style->body.padding.top + style->body.padding.bottom - obj_h));
 80246e8:	f9b7 301c 	ldrsh.w	r3, [r7, #28]
 80246ec:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80246ee:	f9b1 1016 	ldrsh.w	r1, [r1, #22]
 80246f2:	440b      	add	r3, r1
 80246f4:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80246f6:	f9b1 1018 	ldrsh.w	r1, [r1, #24]
 80246fa:	4419      	add	r1, r3
 80246fc:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 8024700:	1acb      	subs	r3, r1, r3
                                      (obj_h - size_tmp - 2 * sb_ver_pad)) /
 8024702:	fb92 f3f3 	sdiv	r3, r2, r3
                        sb_ver_pad + (-(lv_obj_get_y(scrl) - ext->sb.style->body.padding.bottom) *
 8024706:	b29a      	uxth	r2, r3
 8024708:	8abb      	ldrh	r3, [r7, #20]
 802470a:	4413      	add	r3, r2
 802470c:	b29b      	uxth	r3, r3
        lv_area_set_pos(&ext->sb.ver_area,
 802470e:	b21b      	sxth	r3, r3
 8024710:	461a      	mov	r2, r3
 8024712:	4629      	mov	r1, r5
 8024714:	4620      	mov	r0, r4
 8024716:	f7f7 f996 	bl	801ba46 <lv_area_set_pos>

        if(ext->sb.mode == LV_SB_MODE_AUTO || ext->sb.mode == LV_SB_MODE_DRAG) ext->sb.ver_draw = 1;
 802471a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802471c:	7f1b      	ldrb	r3, [r3, #28]
 802471e:	f003 031c 	and.w	r3, r3, #28
 8024722:	b2db      	uxtb	r3, r3
 8024724:	2b0c      	cmp	r3, #12
 8024726:	d006      	beq.n	8024736 <lv_page_sb_refresh+0x4e2>
 8024728:	6abb      	ldr	r3, [r7, #40]	; 0x28
 802472a:	7f1b      	ldrb	r3, [r3, #28]
 802472c:	f003 031c 	and.w	r3, r3, #28
 8024730:	b2db      	uxtb	r3, r3
 8024732:	2b08      	cmp	r3, #8
 8024734:	d104      	bne.n	8024740 <lv_page_sb_refresh+0x4ec>
 8024736:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8024738:	7f13      	ldrb	r3, [r2, #28]
 802473a:	f043 0302 	orr.w	r3, r3, #2
 802473e:	7713      	strb	r3, [r2, #28]
    }

    /*Invalidate the new scrollbar areas*/
    if(ext->sb.hor_draw != 0) {
 8024740:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024742:	7f1b      	ldrb	r3, [r3, #28]
 8024744:	f003 0301 	and.w	r3, r3, #1
 8024748:	b2db      	uxtb	r3, r3
 802474a:	2b00      	cmp	r3, #0
 802474c:	d03a      	beq.n	80247c4 <lv_page_sb_refresh+0x570>
        lv_area_copy(&sb_area_tmp, &ext->sb.hor_area);
 802474e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8024750:	f103 020c 	add.w	r2, r3, #12
 8024754:	f107 0308 	add.w	r3, r7, #8
 8024758:	4611      	mov	r1, r2
 802475a:	4618      	mov	r0, r3
 802475c:	f7fe f928 	bl	80229b0 <lv_area_copy>
        sb_area_tmp.x1 += page->coords.x1;
 8024760:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 8024764:	b29a      	uxth	r2, r3
 8024766:	687b      	ldr	r3, [r7, #4]
 8024768:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802476c:	b29b      	uxth	r3, r3
 802476e:	4413      	add	r3, r2
 8024770:	b29b      	uxth	r3, r3
 8024772:	b21b      	sxth	r3, r3
 8024774:	813b      	strh	r3, [r7, #8]
        sb_area_tmp.y1 += page->coords.y1;
 8024776:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 802477a:	b29a      	uxth	r2, r3
 802477c:	687b      	ldr	r3, [r7, #4]
 802477e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8024782:	b29b      	uxth	r3, r3
 8024784:	4413      	add	r3, r2
 8024786:	b29b      	uxth	r3, r3
 8024788:	b21b      	sxth	r3, r3
 802478a:	817b      	strh	r3, [r7, #10]
        sb_area_tmp.x2 += page->coords.x1;
 802478c:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8024790:	b29a      	uxth	r2, r3
 8024792:	687b      	ldr	r3, [r7, #4]
 8024794:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 8024798:	b29b      	uxth	r3, r3
 802479a:	4413      	add	r3, r2
 802479c:	b29b      	uxth	r3, r3
 802479e:	b21b      	sxth	r3, r3
 80247a0:	81bb      	strh	r3, [r7, #12]
        sb_area_tmp.y2 += page->coords.y1;
 80247a2:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 80247a6:	b29a      	uxth	r2, r3
 80247a8:	687b      	ldr	r3, [r7, #4]
 80247aa:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80247ae:	b29b      	uxth	r3, r3
 80247b0:	4413      	add	r3, r2
 80247b2:	b29b      	uxth	r3, r3
 80247b4:	b21b      	sxth	r3, r3
 80247b6:	81fb      	strh	r3, [r7, #14]
        lv_inv_area(disp, &sb_area_tmp);
 80247b8:	f107 0308 	add.w	r3, r7, #8
 80247bc:	4619      	mov	r1, r3
 80247be:	6938      	ldr	r0, [r7, #16]
 80247c0:	f7ee f8bc 	bl	801293c <lv_inv_area>
    }
    if(ext->sb.ver_draw != 0) {
 80247c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80247c6:	7f1b      	ldrb	r3, [r3, #28]
 80247c8:	f003 0302 	and.w	r3, r3, #2
 80247cc:	b2db      	uxtb	r3, r3
 80247ce:	2b00      	cmp	r3, #0
 80247d0:	d03c      	beq.n	802484c <lv_page_sb_refresh+0x5f8>
        lv_area_copy(&sb_area_tmp, &ext->sb.ver_area);
 80247d2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80247d4:	f103 0214 	add.w	r2, r3, #20
 80247d8:	f107 0308 	add.w	r3, r7, #8
 80247dc:	4611      	mov	r1, r2
 80247de:	4618      	mov	r0, r3
 80247e0:	f7fe f8e6 	bl	80229b0 <lv_area_copy>
        sb_area_tmp.x1 += page->coords.x1;
 80247e4:	f9b7 3008 	ldrsh.w	r3, [r7, #8]
 80247e8:	b29a      	uxth	r2, r3
 80247ea:	687b      	ldr	r3, [r7, #4]
 80247ec:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80247f0:	b29b      	uxth	r3, r3
 80247f2:	4413      	add	r3, r2
 80247f4:	b29b      	uxth	r3, r3
 80247f6:	b21b      	sxth	r3, r3
 80247f8:	813b      	strh	r3, [r7, #8]
        sb_area_tmp.y1 += page->coords.y1;
 80247fa:	f9b7 300a 	ldrsh.w	r3, [r7, #10]
 80247fe:	b29a      	uxth	r2, r3
 8024800:	687b      	ldr	r3, [r7, #4]
 8024802:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8024806:	b29b      	uxth	r3, r3
 8024808:	4413      	add	r3, r2
 802480a:	b29b      	uxth	r3, r3
 802480c:	b21b      	sxth	r3, r3
 802480e:	817b      	strh	r3, [r7, #10]
        sb_area_tmp.x2 += page->coords.x1;
 8024810:	f9b7 300c 	ldrsh.w	r3, [r7, #12]
 8024814:	b29a      	uxth	r2, r3
 8024816:	687b      	ldr	r3, [r7, #4]
 8024818:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802481c:	b29b      	uxth	r3, r3
 802481e:	4413      	add	r3, r2
 8024820:	b29b      	uxth	r3, r3
 8024822:	b21b      	sxth	r3, r3
 8024824:	81bb      	strh	r3, [r7, #12]
        sb_area_tmp.y2 += page->coords.y1;
 8024826:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 802482a:	b29a      	uxth	r2, r3
 802482c:	687b      	ldr	r3, [r7, #4]
 802482e:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8024832:	b29b      	uxth	r3, r3
 8024834:	4413      	add	r3, r2
 8024836:	b29b      	uxth	r3, r3
 8024838:	b21b      	sxth	r3, r3
 802483a:	81fb      	strh	r3, [r7, #14]
        lv_inv_area(disp, &sb_area_tmp);
 802483c:	f107 0308 	add.w	r3, r7, #8
 8024840:	4619      	mov	r1, r3
 8024842:	6938      	ldr	r0, [r7, #16]
 8024844:	f7ee f87a 	bl	801293c <lv_inv_area>
 8024848:	e000      	b.n	802484c <lv_page_sb_refresh+0x5f8>
    if(ext->sb.mode == LV_SB_MODE_OFF) return;
 802484a:	bf00      	nop
    }
}
 802484c:	3734      	adds	r7, #52	; 0x34
 802484e:	46bd      	mov	sp, r7
 8024850:	bdf0      	pop	{r4, r5, r6, r7, pc}

08024852 <edge_flash_anim>:

#if LV_USE_ANIMATION
static void edge_flash_anim(void * page, lv_anim_value_t v)
{
 8024852:	b580      	push	{r7, lr}
 8024854:	b084      	sub	sp, #16
 8024856:	af00      	add	r7, sp, #0
 8024858:	6078      	str	r0, [r7, #4]
 802485a:	460b      	mov	r3, r1
 802485c:	807b      	strh	r3, [r7, #2]
    lv_page_ext_t * ext   = lv_obj_get_ext_attr(page);
 802485e:	6878      	ldr	r0, [r7, #4]
 8024860:	f7ed fde7 	bl	8012432 <lv_obj_get_ext_attr>
 8024864:	60f8      	str	r0, [r7, #12]
    ext->edge_flash.state = v;
 8024866:	68fb      	ldr	r3, [r7, #12]
 8024868:	887a      	ldrh	r2, [r7, #2]
 802486a:	841a      	strh	r2, [r3, #32]
    lv_obj_invalidate(page);
 802486c:	6878      	ldr	r0, [r7, #4]
 802486e:	f7ec fade 	bl	8010e2e <lv_obj_invalidate>
}
 8024872:	bf00      	nop
 8024874:	3710      	adds	r7, #16
 8024876:	46bd      	mov	sp, r7
 8024878:	bd80      	pop	{r7, pc}

0802487a <edge_flash_anim_end>:

static void edge_flash_anim_end(lv_anim_t * a)
{
 802487a:	b580      	push	{r7, lr}
 802487c:	b084      	sub	sp, #16
 802487e:	af00      	add	r7, sp, #0
 8024880:	6078      	str	r0, [r7, #4]
    lv_page_ext_t * ext       = lv_obj_get_ext_attr(a->var);
 8024882:	687b      	ldr	r3, [r7, #4]
 8024884:	681b      	ldr	r3, [r3, #0]
 8024886:	4618      	mov	r0, r3
 8024888:	f7ed fdd3 	bl	8012432 <lv_obj_get_ext_attr>
 802488c:	60f8      	str	r0, [r7, #12]
    ext->edge_flash.top_ip    = 0;
 802488e:	68fa      	ldr	r2, [r7, #12]
 8024890:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 8024894:	f36f 0341 	bfc	r3, #1, #1
 8024898:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.bottom_ip = 0;
 802489c:	68fa      	ldr	r2, [r7, #12]
 802489e:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80248a2:	f36f 0382 	bfc	r3, #2, #1
 80248a6:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.left_ip   = 0;
 80248aa:	68fa      	ldr	r2, [r7, #12]
 80248ac:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80248b0:	f36f 1304 	bfc	r3, #4, #1
 80248b4:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    ext->edge_flash.right_ip  = 0;
 80248b8:	68fa      	ldr	r2, [r7, #12]
 80248ba:	f892 3028 	ldrb.w	r3, [r2, #40]	; 0x28
 80248be:	f36f 03c3 	bfc	r3, #3, #1
 80248c2:	f882 3028 	strb.w	r3, [r2, #40]	; 0x28
    lv_obj_invalidate(a->var);
 80248c6:	687b      	ldr	r3, [r7, #4]
 80248c8:	681b      	ldr	r3, [r3, #0]
 80248ca:	4618      	mov	r0, r3
 80248cc:	f7ec faaf 	bl	8010e2e <lv_obj_invalidate>
}
 80248d0:	bf00      	nop
 80248d2:	3710      	adds	r7, #16
 80248d4:	46bd      	mov	sp, r7
 80248d6:	bd80      	pop	{r7, pc}

080248d8 <lv_area_copy>:
{
 80248d8:	b580      	push	{r7, lr}
 80248da:	b082      	sub	sp, #8
 80248dc:	af00      	add	r7, sp, #0
 80248de:	6078      	str	r0, [r7, #4]
 80248e0:	6039      	str	r1, [r7, #0]
    memcpy(dest, src, sizeof(lv_area_t));
 80248e2:	2208      	movs	r2, #8
 80248e4:	6839      	ldr	r1, [r7, #0]
 80248e6:	6878      	ldr	r0, [r7, #4]
 80248e8:	f002 fc68 	bl	80271bc <memcpy>
}
 80248ec:	bf00      	nop
 80248ee:	3708      	adds	r7, #8
 80248f0:	46bd      	mov	sp, r7
 80248f2:	bd80      	pop	{r7, pc}

080248f4 <lv_area_get_width>:
{
 80248f4:	b480      	push	{r7}
 80248f6:	b083      	sub	sp, #12
 80248f8:	af00      	add	r7, sp, #0
 80248fa:	6078      	str	r0, [r7, #4]
    return area_p->x2 - area_p->x1 + 1;
 80248fc:	687b      	ldr	r3, [r7, #4]
 80248fe:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8024902:	b29a      	uxth	r2, r3
 8024904:	687b      	ldr	r3, [r7, #4]
 8024906:	f9b3 3000 	ldrsh.w	r3, [r3]
 802490a:	b29b      	uxth	r3, r3
 802490c:	1ad3      	subs	r3, r2, r3
 802490e:	b29b      	uxth	r3, r3
 8024910:	3301      	adds	r3, #1
 8024912:	b29b      	uxth	r3, r3
 8024914:	b21b      	sxth	r3, r3
}
 8024916:	4618      	mov	r0, r3
 8024918:	370c      	adds	r7, #12
 802491a:	46bd      	mov	sp, r7
 802491c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8024920:	4770      	bx	lr

08024922 <lv_area_get_height>:
{
 8024922:	b480      	push	{r7}
 8024924:	b083      	sub	sp, #12
 8024926:	af00      	add	r7, sp, #0
 8024928:	6078      	str	r0, [r7, #4]
    return area_p->y2 - area_p->y1 + 1;
 802492a:	687b      	ldr	r3, [r7, #4]
 802492c:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8024930:	b29a      	uxth	r2, r3
 8024932:	687b      	ldr	r3, [r7, #4]
 8024934:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8024938:	b29b      	uxth	r3, r3
 802493a:	1ad3      	subs	r3, r2, r3
 802493c:	b29b      	uxth	r3, r3
 802493e:	3301      	adds	r3, #1
 8024940:	b29b      	uxth	r3, r3
 8024942:	b21b      	sxth	r3, r3
}
 8024944:	4618      	mov	r0, r3
 8024946:	370c      	adds	r7, #12
 8024948:	46bd      	mov	sp, r7
 802494a:	f85d 7b04 	ldr.w	r7, [sp], #4
 802494e:	4770      	bx	lr

08024950 <lv_slider_set_value>:
 * @param slider pointer to a slider object
 * @param value new value
 * @param anim LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately
 */
static inline void lv_slider_set_value(lv_obj_t * slider, int16_t value, lv_anim_enable_t anim)
{
 8024950:	b580      	push	{r7, lr}
 8024952:	b082      	sub	sp, #8
 8024954:	af00      	add	r7, sp, #0
 8024956:	6078      	str	r0, [r7, #4]
 8024958:	460b      	mov	r3, r1
 802495a:	807b      	strh	r3, [r7, #2]
 802495c:	4613      	mov	r3, r2
 802495e:	707b      	strb	r3, [r7, #1]
    lv_bar_set_value(slider, value, anim);
 8024960:	787a      	ldrb	r2, [r7, #1]
 8024962:	f9b7 3002 	ldrsh.w	r3, [r7, #2]
 8024966:	4619      	mov	r1, r3
 8024968:	6878      	ldr	r0, [r7, #4]
 802496a:	f7f9 f951 	bl	801dc10 <lv_bar_set_value>
}
 802496e:	bf00      	nop
 8024970:	3708      	adds	r7, #8
 8024972:	46bd      	mov	sp, r7
 8024974:	bd80      	pop	{r7, pc}

08024976 <lv_slider_get_min_value>:
 * Get the minimum value of a slider
 * @param slider pointer to a slider object
 * @return the minimum value of the slider
 */
static inline int16_t lv_slider_get_min_value(const lv_obj_t * slider)
{
 8024976:	b580      	push	{r7, lr}
 8024978:	b082      	sub	sp, #8
 802497a:	af00      	add	r7, sp, #0
 802497c:	6078      	str	r0, [r7, #4]
    return lv_bar_get_min_value(slider);
 802497e:	6878      	ldr	r0, [r7, #4]
 8024980:	f7f9 fa50 	bl	801de24 <lv_bar_get_min_value>
 8024984:	4603      	mov	r3, r0
}
 8024986:	4618      	mov	r0, r3
 8024988:	3708      	adds	r7, #8
 802498a:	46bd      	mov	sp, r7
 802498c:	bd80      	pop	{r7, pc}

0802498e <lv_slider_get_max_value>:
 * Get the maximum value of a slider
 * @param slider pointer to a slider object
 * @return the maximum value of the slider
 */
static inline int16_t lv_slider_get_max_value(const lv_obj_t * slider)
{
 802498e:	b580      	push	{r7, lr}
 8024990:	b082      	sub	sp, #8
 8024992:	af00      	add	r7, sp, #0
 8024994:	6078      	str	r0, [r7, #4]
    return lv_bar_get_max_value(slider);
 8024996:	6878      	ldr	r0, [r7, #4]
 8024998:	f7f9 fa53 	bl	801de42 <lv_bar_get_max_value>
 802499c:	4603      	mov	r3, r0
}
 802499e:	4618      	mov	r0, r3
 80249a0:	3708      	adds	r7, #8
 80249a2:	46bd      	mov	sp, r7
 80249a4:	bd80      	pop	{r7, pc}
	...

080249a8 <lv_slider_create>:
 * @param par pointer to an object, it will be the parent of the new slider
 * @param copy pointer to a slider object, if not NULL then the new object will be copied from it
 * @return pointer to the created slider
 */
lv_obj_t * lv_slider_create(lv_obj_t * par, const lv_obj_t * copy)
{
 80249a8:	b580      	push	{r7, lr}
 80249aa:	b086      	sub	sp, #24
 80249ac:	af00      	add	r7, sp, #0
 80249ae:	6078      	str	r0, [r7, #4]
 80249b0:	6039      	str	r1, [r7, #0]
    LV_LOG_TRACE("slider create started");

    /*Create the ancestor slider*/
    lv_obj_t * new_slider = lv_bar_create(par, copy);
 80249b2:	6839      	ldr	r1, [r7, #0]
 80249b4:	6878      	ldr	r0, [r7, #4]
 80249b6:	f7f9 f855 	bl	801da64 <lv_bar_create>
 80249ba:	6178      	str	r0, [r7, #20]
    lv_mem_assert(new_slider);
 80249bc:	697b      	ldr	r3, [r7, #20]
 80249be:	2b00      	cmp	r3, #0
 80249c0:	d106      	bne.n	80249d0 <lv_slider_create+0x28>
 80249c2:	4b48      	ldr	r3, [pc, #288]	; (8024ae4 <lv_slider_create+0x13c>)
 80249c4:	223c      	movs	r2, #60	; 0x3c
 80249c6:	4948      	ldr	r1, [pc, #288]	; (8024ae8 <lv_slider_create+0x140>)
 80249c8:	2003      	movs	r0, #3
 80249ca:	f7f7 ff1f 	bl	801c80c <lv_log_add>
 80249ce:	e7fe      	b.n	80249ce <lv_slider_create+0x26>
    if(new_slider == NULL) return NULL;
 80249d0:	697b      	ldr	r3, [r7, #20]
 80249d2:	2b00      	cmp	r3, #0
 80249d4:	d101      	bne.n	80249da <lv_slider_create+0x32>
 80249d6:	2300      	movs	r3, #0
 80249d8:	e080      	b.n	8024adc <lv_slider_create+0x134>

    if(ancestor_design_f == NULL) ancestor_design_f = lv_obj_get_design_cb(new_slider);
 80249da:	4b44      	ldr	r3, [pc, #272]	; (8024aec <lv_slider_create+0x144>)
 80249dc:	681b      	ldr	r3, [r3, #0]
 80249de:	2b00      	cmp	r3, #0
 80249e0:	d105      	bne.n	80249ee <lv_slider_create+0x46>
 80249e2:	6978      	ldr	r0, [r7, #20]
 80249e4:	f7ed fd19 	bl	801241a <lv_obj_get_design_cb>
 80249e8:	4602      	mov	r2, r0
 80249ea:	4b40      	ldr	r3, [pc, #256]	; (8024aec <lv_slider_create+0x144>)
 80249ec:	601a      	str	r2, [r3, #0]
    if(ancestor_signal == NULL) ancestor_signal = lv_obj_get_signal_cb(new_slider);
 80249ee:	4b40      	ldr	r3, [pc, #256]	; (8024af0 <lv_slider_create+0x148>)
 80249f0:	681b      	ldr	r3, [r3, #0]
 80249f2:	2b00      	cmp	r3, #0
 80249f4:	d105      	bne.n	8024a02 <lv_slider_create+0x5a>
 80249f6:	6978      	ldr	r0, [r7, #20]
 80249f8:	f7ed fd03 	bl	8012402 <lv_obj_get_signal_cb>
 80249fc:	4602      	mov	r2, r0
 80249fe:	4b3c      	ldr	r3, [pc, #240]	; (8024af0 <lv_slider_create+0x148>)
 8024a00:	601a      	str	r2, [r3, #0]

    /*Allocate the slider type specific extended data*/
    lv_slider_ext_t * ext = lv_obj_allocate_ext_attr(new_slider, sizeof(lv_slider_ext_t));
 8024a02:	211c      	movs	r1, #28
 8024a04:	6978      	ldr	r0, [r7, #20]
 8024a06:	f7ed fad7 	bl	8011fb8 <lv_obj_allocate_ext_attr>
 8024a0a:	6138      	str	r0, [r7, #16]
    lv_mem_assert(ext);
 8024a0c:	693b      	ldr	r3, [r7, #16]
 8024a0e:	2b00      	cmp	r3, #0
 8024a10:	d106      	bne.n	8024a20 <lv_slider_create+0x78>
 8024a12:	4b34      	ldr	r3, [pc, #208]	; (8024ae4 <lv_slider_create+0x13c>)
 8024a14:	2244      	movs	r2, #68	; 0x44
 8024a16:	4934      	ldr	r1, [pc, #208]	; (8024ae8 <lv_slider_create+0x140>)
 8024a18:	2003      	movs	r0, #3
 8024a1a:	f7f7 fef7 	bl	801c80c <lv_log_add>
 8024a1e:	e7fe      	b.n	8024a1e <lv_slider_create+0x76>
    if(ext == NULL) return NULL;
 8024a20:	693b      	ldr	r3, [r7, #16]
 8024a22:	2b00      	cmp	r3, #0
 8024a24:	d101      	bne.n	8024a2a <lv_slider_create+0x82>
 8024a26:	2300      	movs	r3, #0
 8024a28:	e058      	b.n	8024adc <lv_slider_create+0x134>

    /*Initialize the allocated 'ext' */
    ext->drag_value = LV_SLIDER_NOT_PRESSED;
 8024a2a:	693b      	ldr	r3, [r7, #16]
 8024a2c:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8024a30:	831a      	strh	r2, [r3, #24]
    ext->style_knob = &lv_style_pretty;
 8024a32:	693b      	ldr	r3, [r7, #16]
 8024a34:	4a2f      	ldr	r2, [pc, #188]	; (8024af4 <lv_slider_create+0x14c>)
 8024a36:	615a      	str	r2, [r3, #20]
    ext->knob_in    = 0;
 8024a38:	693a      	ldr	r2, [r7, #16]
 8024a3a:	7e93      	ldrb	r3, [r2, #26]
 8024a3c:	f36f 0300 	bfc	r3, #0, #1
 8024a40:	7693      	strb	r3, [r2, #26]

    /*The signal and design functions are not copied so set them here*/
    lv_obj_set_signal_cb(new_slider, lv_slider_signal);
 8024a42:	492d      	ldr	r1, [pc, #180]	; (8024af8 <lv_slider_create+0x150>)
 8024a44:	6978      	ldr	r0, [r7, #20]
 8024a46:	f7ed fa9b 	bl	8011f80 <lv_obj_set_signal_cb>
    lv_obj_set_design_cb(new_slider, lv_slider_design);
 8024a4a:	492c      	ldr	r1, [pc, #176]	; (8024afc <lv_slider_create+0x154>)
 8024a4c:	6978      	ldr	r0, [r7, #20]
 8024a4e:	f7ed faa5 	bl	8011f9c <lv_obj_set_design_cb>

    /*Init the new slider slider*/
    if(copy == NULL) {
 8024a52:	683b      	ldr	r3, [r7, #0]
 8024a54:	2b00      	cmp	r3, #0
 8024a56:	d12b      	bne.n	8024ab0 <lv_slider_create+0x108>
        lv_obj_set_click(new_slider, true);
 8024a58:	2101      	movs	r1, #1
 8024a5a:	6978      	ldr	r0, [r7, #20]
 8024a5c:	f7ed f983 	bl	8011d66 <lv_obj_set_click>
        lv_obj_set_protect(new_slider, LV_PROTECT_PRESS_LOST);
 8024a60:	2110      	movs	r1, #16
 8024a62:	6978      	ldr	r0, [r7, #20]
 8024a64:	f7ed f9c0 	bl	8011de8 <lv_obj_set_protect>

        /*Set the default styles*/
        lv_theme_t * th = lv_theme_get_current();
 8024a68:	f000 ff92 	bl	8025990 <lv_theme_get_current>
 8024a6c:	60b8      	str	r0, [r7, #8]
        if(th) {
 8024a6e:	68bb      	ldr	r3, [r7, #8]
 8024a70:	2b00      	cmp	r3, #0
 8024a72:	d015      	beq.n	8024aa0 <lv_slider_create+0xf8>
            lv_slider_set_style(new_slider, LV_SLIDER_STYLE_BG, th->style.slider.bg);
 8024a74:	68bb      	ldr	r3, [r7, #8]
 8024a76:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8024a78:	461a      	mov	r2, r3
 8024a7a:	2100      	movs	r1, #0
 8024a7c:	6978      	ldr	r0, [r7, #20]
 8024a7e:	f000 f83f 	bl	8024b00 <lv_slider_set_style>
            lv_slider_set_style(new_slider, LV_SLIDER_STYLE_INDIC, th->style.slider.indic);
 8024a82:	68bb      	ldr	r3, [r7, #8]
 8024a84:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8024a86:	461a      	mov	r2, r3
 8024a88:	2101      	movs	r1, #1
 8024a8a:	6978      	ldr	r0, [r7, #20]
 8024a8c:	f000 f838 	bl	8024b00 <lv_slider_set_style>
            lv_slider_set_style(new_slider, LV_SLIDER_STYLE_KNOB, th->style.slider.knob);
 8024a90:	68bb      	ldr	r3, [r7, #8]
 8024a92:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8024a94:	461a      	mov	r2, r3
 8024a96:	2102      	movs	r1, #2
 8024a98:	6978      	ldr	r0, [r7, #20]
 8024a9a:	f000 f831 	bl	8024b00 <lv_slider_set_style>
 8024a9e:	e01c      	b.n	8024ada <lv_slider_create+0x132>
        } else {
            lv_slider_set_style(new_slider, LV_SLIDER_STYLE_KNOB, ext->style_knob);
 8024aa0:	693b      	ldr	r3, [r7, #16]
 8024aa2:	695b      	ldr	r3, [r3, #20]
 8024aa4:	461a      	mov	r2, r3
 8024aa6:	2102      	movs	r1, #2
 8024aa8:	6978      	ldr	r0, [r7, #20]
 8024aaa:	f000 f829 	bl	8024b00 <lv_slider_set_style>
 8024aae:	e014      	b.n	8024ada <lv_slider_create+0x132>
        }
    }
    /*Copy an existing slider*/
    else {
        lv_slider_ext_t * copy_ext = lv_obj_get_ext_attr(copy);
 8024ab0:	6838      	ldr	r0, [r7, #0]
 8024ab2:	f7ed fcbe 	bl	8012432 <lv_obj_get_ext_attr>
 8024ab6:	60f8      	str	r0, [r7, #12]
        ext->style_knob            = copy_ext->style_knob;
 8024ab8:	68fb      	ldr	r3, [r7, #12]
 8024aba:	695a      	ldr	r2, [r3, #20]
 8024abc:	693b      	ldr	r3, [r7, #16]
 8024abe:	615a      	str	r2, [r3, #20]
        ext->knob_in               = copy_ext->knob_in;
 8024ac0:	68fb      	ldr	r3, [r7, #12]
 8024ac2:	7e9b      	ldrb	r3, [r3, #26]
 8024ac4:	f3c3 0300 	ubfx	r3, r3, #0, #1
 8024ac8:	b2d9      	uxtb	r1, r3
 8024aca:	693a      	ldr	r2, [r7, #16]
 8024acc:	7e93      	ldrb	r3, [r2, #26]
 8024ace:	f361 0300 	bfi	r3, r1, #0, #1
 8024ad2:	7693      	strb	r3, [r2, #26]
        /*Refresh the style with new signal function*/
        lv_obj_refresh_style(new_slider);
 8024ad4:	6978      	ldr	r0, [r7, #20]
 8024ad6:	f7ed f8fe 	bl	8011cd6 <lv_obj_refresh_style>
    }

    LV_LOG_INFO("slider created");

    return new_slider;
 8024ada:	697b      	ldr	r3, [r7, #20]
}
 8024adc:	4618      	mov	r0, r3
 8024ade:	3718      	adds	r7, #24
 8024ae0:	46bd      	mov	sp, r7
 8024ae2:	bd80      	pop	{r7, pc}
 8024ae4:	080290fc 	.word	0x080290fc
 8024ae8:	0802910c 	.word	0x0802910c
 8024aec:	2000c3e8 	.word	0x2000c3e8
 8024af0:	2000c3ec 	.word	0x2000c3ec
 8024af4:	2000dd28 	.word	0x2000dd28
 8024af8:	080254a9 	.word	0x080254a9
 8024afc:	08024bdf 	.word	0x08024bdf

08024b00 <lv_slider_set_style>:
 * @param slider pointer to a slider object
 * @param type which style should be set
 * @param style pointer to a style
 */
void lv_slider_set_style(lv_obj_t * slider, lv_slider_style_t type, const lv_style_t * style)
{
 8024b00:	b580      	push	{r7, lr}
 8024b02:	b086      	sub	sp, #24
 8024b04:	af00      	add	r7, sp, #0
 8024b06:	60f8      	str	r0, [r7, #12]
 8024b08:	460b      	mov	r3, r1
 8024b0a:	607a      	str	r2, [r7, #4]
 8024b0c:	72fb      	strb	r3, [r7, #11]
    lv_slider_ext_t * ext = lv_obj_get_ext_attr(slider);
 8024b0e:	68f8      	ldr	r0, [r7, #12]
 8024b10:	f7ed fc8f 	bl	8012432 <lv_obj_get_ext_attr>
 8024b14:	6178      	str	r0, [r7, #20]

    switch(type) {
 8024b16:	7afb      	ldrb	r3, [r7, #11]
 8024b18:	2b01      	cmp	r3, #1
 8024b1a:	d00a      	beq.n	8024b32 <lv_slider_set_style+0x32>
 8024b1c:	2b02      	cmp	r3, #2
 8024b1e:	d00e      	beq.n	8024b3e <lv_slider_set_style+0x3e>
 8024b20:	2b00      	cmp	r3, #0
 8024b22:	d000      	beq.n	8024b26 <lv_slider_set_style+0x26>
        case LV_SLIDER_STYLE_KNOB:
            ext->style_knob = style;
            lv_obj_refresh_ext_draw_pad(slider);
            break;
    }
}
 8024b24:	e012      	b.n	8024b4c <lv_slider_set_style+0x4c>
        case LV_SLIDER_STYLE_BG: lv_bar_set_style(slider, LV_BAR_STYLE_BG, style); break;
 8024b26:	687a      	ldr	r2, [r7, #4]
 8024b28:	2100      	movs	r1, #0
 8024b2a:	68f8      	ldr	r0, [r7, #12]
 8024b2c:	f7f9 f940 	bl	801ddb0 <lv_bar_set_style>
 8024b30:	e00c      	b.n	8024b4c <lv_slider_set_style+0x4c>
        case LV_SLIDER_STYLE_INDIC: lv_bar_set_style(slider, LV_BAR_STYLE_INDIC, style); break;
 8024b32:	687a      	ldr	r2, [r7, #4]
 8024b34:	2101      	movs	r1, #1
 8024b36:	68f8      	ldr	r0, [r7, #12]
 8024b38:	f7f9 f93a 	bl	801ddb0 <lv_bar_set_style>
 8024b3c:	e006      	b.n	8024b4c <lv_slider_set_style+0x4c>
            ext->style_knob = style;
 8024b3e:	697b      	ldr	r3, [r7, #20]
 8024b40:	687a      	ldr	r2, [r7, #4]
 8024b42:	615a      	str	r2, [r3, #20]
            lv_obj_refresh_ext_draw_pad(slider);
 8024b44:	68f8      	ldr	r0, [r7, #12]
 8024b46:	f7ed fa4d 	bl	8011fe4 <lv_obj_refresh_ext_draw_pad>
            break;
 8024b4a:	bf00      	nop
}
 8024b4c:	bf00      	nop
 8024b4e:	3718      	adds	r7, #24
 8024b50:	46bd      	mov	sp, r7
 8024b52:	bd80      	pop	{r7, pc}

08024b54 <lv_slider_get_value>:
 * Get the value of a slider
 * @param slider pointer to a slider object
 * @return the value of the slider
 */
int16_t lv_slider_get_value(const lv_obj_t * slider)
{
 8024b54:	b580      	push	{r7, lr}
 8024b56:	b084      	sub	sp, #16
 8024b58:	af00      	add	r7, sp, #0
 8024b5a:	6078      	str	r0, [r7, #4]
    lv_slider_ext_t * ext = lv_obj_get_ext_attr(slider);
 8024b5c:	6878      	ldr	r0, [r7, #4]
 8024b5e:	f7ed fc68 	bl	8012432 <lv_obj_get_ext_attr>
 8024b62:	60f8      	str	r0, [r7, #12]

    if(ext->drag_value != LV_SLIDER_NOT_PRESSED)
 8024b64:	68fb      	ldr	r3, [r7, #12]
 8024b66:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8024b6a:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8024b6e:	d003      	beq.n	8024b78 <lv_slider_get_value+0x24>
        return ext->drag_value;
 8024b70:	68fb      	ldr	r3, [r7, #12]
 8024b72:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8024b76:	e003      	b.n	8024b80 <lv_slider_get_value+0x2c>
    else
        return lv_bar_get_value(slider);
 8024b78:	6878      	ldr	r0, [r7, #4]
 8024b7a:	f7f9 f93a 	bl	801ddf2 <lv_bar_get_value>
 8024b7e:	4603      	mov	r3, r0
}
 8024b80:	4618      	mov	r0, r3
 8024b82:	3710      	adds	r7, #16
 8024b84:	46bd      	mov	sp, r7
 8024b86:	bd80      	pop	{r7, pc}

08024b88 <lv_slider_get_style>:
 * @param slider pointer to a slider object
 * @param type which style should be get
 * @return style pointer to a style
 */
const lv_style_t * lv_slider_get_style(const lv_obj_t * slider, lv_slider_style_t type)
{
 8024b88:	b580      	push	{r7, lr}
 8024b8a:	b084      	sub	sp, #16
 8024b8c:	af00      	add	r7, sp, #0
 8024b8e:	6078      	str	r0, [r7, #4]
 8024b90:	460b      	mov	r3, r1
 8024b92:	70fb      	strb	r3, [r7, #3]
    const lv_style_t * style = NULL;
 8024b94:	2300      	movs	r3, #0
 8024b96:	60fb      	str	r3, [r7, #12]
    lv_slider_ext_t * ext    = lv_obj_get_ext_attr(slider);
 8024b98:	6878      	ldr	r0, [r7, #4]
 8024b9a:	f7ed fc4a 	bl	8012432 <lv_obj_get_ext_attr>
 8024b9e:	60b8      	str	r0, [r7, #8]

    switch(type) {
 8024ba0:	78fb      	ldrb	r3, [r7, #3]
 8024ba2:	2b01      	cmp	r3, #1
 8024ba4:	d009      	beq.n	8024bba <lv_slider_get_style+0x32>
 8024ba6:	2b02      	cmp	r3, #2
 8024ba8:	d00d      	beq.n	8024bc6 <lv_slider_get_style+0x3e>
 8024baa:	2b00      	cmp	r3, #0
 8024bac:	d10f      	bne.n	8024bce <lv_slider_get_style+0x46>
        case LV_SLIDER_STYLE_BG: style = lv_bar_get_style(slider, LV_BAR_STYLE_BG); break;
 8024bae:	2100      	movs	r1, #0
 8024bb0:	6878      	ldr	r0, [r7, #4]
 8024bb2:	f7f9 f955 	bl	801de60 <lv_bar_get_style>
 8024bb6:	60f8      	str	r0, [r7, #12]
 8024bb8:	e00c      	b.n	8024bd4 <lv_slider_get_style+0x4c>
        case LV_SLIDER_STYLE_INDIC: style = lv_bar_get_style(slider, LV_BAR_STYLE_INDIC); break;
 8024bba:	2101      	movs	r1, #1
 8024bbc:	6878      	ldr	r0, [r7, #4]
 8024bbe:	f7f9 f94f 	bl	801de60 <lv_bar_get_style>
 8024bc2:	60f8      	str	r0, [r7, #12]
 8024bc4:	e006      	b.n	8024bd4 <lv_slider_get_style+0x4c>
        case LV_SLIDER_STYLE_KNOB: style = ext->style_knob; break;
 8024bc6:	68bb      	ldr	r3, [r7, #8]
 8024bc8:	695b      	ldr	r3, [r3, #20]
 8024bca:	60fb      	str	r3, [r7, #12]
 8024bcc:	e002      	b.n	8024bd4 <lv_slider_get_style+0x4c>
        default: style = NULL; break;
 8024bce:	2300      	movs	r3, #0
 8024bd0:	60fb      	str	r3, [r7, #12]
 8024bd2:	bf00      	nop
    }

    return style;
 8024bd4:	68fb      	ldr	r3, [r7, #12]
}
 8024bd6:	4618      	mov	r0, r3
 8024bd8:	3710      	adds	r7, #16
 8024bda:	46bd      	mov	sp, r7
 8024bdc:	bd80      	pop	{r7, pc}

08024bde <lv_slider_design>:
 *             LV_DESIGN_DRAW: draw the object (always return 'true')
 *             LV_DESIGN_DRAW_POST: drawing after every children are drawn
 * @param return true/false, depends on 'mode'
 */
static bool lv_slider_design(lv_obj_t * slider, const lv_area_t * mask, lv_design_mode_t mode)
{
 8024bde:	b590      	push	{r4, r7, lr}
 8024be0:	b0ad      	sub	sp, #180	; 0xb4
 8024be2:	af00      	add	r7, sp, #0
 8024be4:	60f8      	str	r0, [r7, #12]
 8024be6:	60b9      	str	r1, [r7, #8]
 8024be8:	4613      	mov	r3, r2
 8024bea:	71fb      	strb	r3, [r7, #7]
    /*Return false if the object is not covers the mask_p area*/
    if(mode == LV_DESIGN_COVER_CHK) {
 8024bec:	79fb      	ldrb	r3, [r7, #7]
 8024bee:	2b02      	cmp	r3, #2
 8024bf0:	d102      	bne.n	8024bf8 <lv_slider_design+0x1a>
        return false;
 8024bf2:	2300      	movs	r3, #0
 8024bf4:	f000 bc54 	b.w	80254a0 <lv_slider_design+0x8c2>
    }
    /*Draw the object*/
    else if(mode == LV_DESIGN_DRAW_MAIN) {
 8024bf8:	79fb      	ldrb	r3, [r7, #7]
 8024bfa:	2b00      	cmp	r3, #0
 8024bfc:	f040 844f 	bne.w	802549e <lv_slider_design+0x8c0>
        lv_slider_ext_t * ext = lv_obj_get_ext_attr(slider);
 8024c00:	68f8      	ldr	r0, [r7, #12]
 8024c02:	f7ed fc16 	bl	8012432 <lv_obj_get_ext_attr>
 8024c06:	f8c7 0098 	str.w	r0, [r7, #152]	; 0x98

        const lv_style_t * style_bg    = lv_slider_get_style(slider, LV_SLIDER_STYLE_BG);
 8024c0a:	2100      	movs	r1, #0
 8024c0c:	68f8      	ldr	r0, [r7, #12]
 8024c0e:	f7ff ffbb 	bl	8024b88 <lv_slider_get_style>
 8024c12:	f8c7 0094 	str.w	r0, [r7, #148]	; 0x94
        const lv_style_t * style_knob  = lv_slider_get_style(slider, LV_SLIDER_STYLE_KNOB);
 8024c16:	2102      	movs	r1, #2
 8024c18:	68f8      	ldr	r0, [r7, #12]
 8024c1a:	f7ff ffb5 	bl	8024b88 <lv_slider_get_style>
 8024c1e:	f8c7 0090 	str.w	r0, [r7, #144]	; 0x90
        const lv_style_t * style_indic = lv_slider_get_style(slider, LV_SLIDER_STYLE_INDIC);
 8024c22:	2101      	movs	r1, #1
 8024c24:	68f8      	ldr	r0, [r7, #12]
 8024c26:	f7ff ffaf 	bl	8024b88 <lv_slider_get_style>
 8024c2a:	f8c7 008c 	str.w	r0, [r7, #140]	; 0x8c

        lv_opa_t opa_scale = lv_obj_get_opa_scale(slider);
 8024c2e:	68f8      	ldr	r0, [r7, #12]
 8024c30:	f7ed fbb1 	bl	8012396 <lv_obj_get_opa_scale>
 8024c34:	4603      	mov	r3, r0
 8024c36:	f887 308b 	strb.w	r3, [r7, #139]	; 0x8b

        lv_coord_t slider_w = lv_area_get_width(&slider->coords);
 8024c3a:	68fb      	ldr	r3, [r7, #12]
 8024c3c:	3310      	adds	r3, #16
 8024c3e:	4618      	mov	r0, r3
 8024c40:	f7ff fe58 	bl	80248f4 <lv_area_get_width>
 8024c44:	4603      	mov	r3, r0
 8024c46:	f8a7 3088 	strh.w	r3, [r7, #136]	; 0x88
        lv_coord_t slider_h = lv_area_get_height(&slider->coords);
 8024c4a:	68fb      	ldr	r3, [r7, #12]
 8024c4c:	3310      	adds	r3, #16
 8024c4e:	4618      	mov	r0, r3
 8024c50:	f7ff fe67 	bl	8024922 <lv_area_get_height>
 8024c54:	4603      	mov	r3, r0
 8024c56:	f8a7 3086 	strh.w	r3, [r7, #134]	; 0x86

        /*Draw the bar*/
        lv_area_t area_bg;
        lv_area_copy(&area_bg, &slider->coords);
 8024c5a:	68fb      	ldr	r3, [r7, #12]
 8024c5c:	f103 0210 	add.w	r2, r3, #16
 8024c60:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024c64:	4611      	mov	r1, r2
 8024c66:	4618      	mov	r0, r3
 8024c68:	f7ff fe36 	bl	80248d8 <lv_area_copy>

        /*Be sure at least LV_SLIDER_SIZE_MIN  size will remain*/
        lv_coord_t pad_top_bg    = style_bg->body.padding.top;
 8024c6c:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8024c70:	8adb      	ldrh	r3, [r3, #22]
 8024c72:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
        lv_coord_t pad_bottom_bg = style_bg->body.padding.bottom;
 8024c76:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8024c7a:	8b1b      	ldrh	r3, [r3, #24]
 8024c7c:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
        lv_coord_t pad_left_bg   = style_bg->body.padding.left;
 8024c80:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8024c84:	8b5b      	ldrh	r3, [r3, #26]
 8024c86:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
        lv_coord_t pad_right_bg  = style_bg->body.padding.right;
 8024c8a:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8024c8e:	8b9b      	ldrh	r3, [r3, #28]
 8024c90:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
        if(pad_top_bg + pad_bottom_bg + LV_SLIDER_SIZE_MIN > lv_area_get_height(&area_bg)) {
 8024c94:	f9b7 20ae 	ldrsh.w	r2, [r7, #174]	; 0xae
 8024c98:	f9b7 30ac 	ldrsh.w	r3, [r7, #172]	; 0xac
 8024c9c:	4413      	add	r3, r2
 8024c9e:	1d1c      	adds	r4, r3, #4
 8024ca0:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024ca4:	4618      	mov	r0, r3
 8024ca6:	f7ff fe3c 	bl	8024922 <lv_area_get_height>
 8024caa:	4603      	mov	r3, r0
 8024cac:	429c      	cmp	r4, r3
 8024cae:	dd0d      	ble.n	8024ccc <lv_slider_design+0xee>
            pad_top_bg    = (lv_area_get_height(&area_bg) - LV_SLIDER_SIZE_MIN) >> 1;
 8024cb0:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024cb4:	4618      	mov	r0, r3
 8024cb6:	f7ff fe34 	bl	8024922 <lv_area_get_height>
 8024cba:	4603      	mov	r3, r0
 8024cbc:	3b04      	subs	r3, #4
 8024cbe:	105b      	asrs	r3, r3, #1
 8024cc0:	f8a7 30ae 	strh.w	r3, [r7, #174]	; 0xae
            pad_bottom_bg = pad_top_bg;
 8024cc4:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	; 0xae
 8024cc8:	f8a7 30ac 	strh.w	r3, [r7, #172]	; 0xac
        }
        if(pad_left_bg + pad_right_bg + LV_SLIDER_SIZE_MIN > lv_area_get_width(&area_bg)) {
 8024ccc:	f9b7 20aa 	ldrsh.w	r2, [r7, #170]	; 0xaa
 8024cd0:	f9b7 30a8 	ldrsh.w	r3, [r7, #168]	; 0xa8
 8024cd4:	4413      	add	r3, r2
 8024cd6:	1d1c      	adds	r4, r3, #4
 8024cd8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024cdc:	4618      	mov	r0, r3
 8024cde:	f7ff fe09 	bl	80248f4 <lv_area_get_width>
 8024ce2:	4603      	mov	r3, r0
 8024ce4:	429c      	cmp	r4, r3
 8024ce6:	dd13      	ble.n	8024d10 <lv_slider_design+0x132>
            pad_left_bg  = (lv_area_get_width(&area_bg) - LV_SLIDER_SIZE_MIN) >> 1;
 8024ce8:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024cec:	4618      	mov	r0, r3
 8024cee:	f7ff fe01 	bl	80248f4 <lv_area_get_width>
 8024cf2:	4603      	mov	r3, r0
 8024cf4:	3b04      	subs	r3, #4
 8024cf6:	105b      	asrs	r3, r3, #1
 8024cf8:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
            pad_right_bg = (lv_area_get_width(&area_bg) - LV_SLIDER_SIZE_MIN) >> 1;
 8024cfc:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024d00:	4618      	mov	r0, r3
 8024d02:	f7ff fdf7 	bl	80248f4 <lv_area_get_width>
 8024d06:	4603      	mov	r3, r0
 8024d08:	3b04      	subs	r3, #4
 8024d0a:	105b      	asrs	r3, r3, #1
 8024d0c:	f8a7 30a8 	strh.w	r3, [r7, #168]	; 0xa8
        }

        if(ext->knob_in) { /*Enable extra size if the knob is inside */
 8024d10:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8024d14:	7e9b      	ldrb	r3, [r3, #26]
 8024d16:	f003 0301 	and.w	r3, r3, #1
 8024d1a:	b2db      	uxtb	r3, r3
 8024d1c:	2b00      	cmp	r3, #0
 8024d1e:	d028      	beq.n	8024d72 <lv_slider_design+0x194>
            area_bg.x1 += pad_left_bg;
 8024d20:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8024d24:	b29a      	uxth	r2, r3
 8024d26:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 8024d2a:	4413      	add	r3, r2
 8024d2c:	b29b      	uxth	r3, r3
 8024d2e:	b21b      	sxth	r3, r3
 8024d30:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
            area_bg.x2 -= pad_right_bg;
 8024d34:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8024d38:	b29a      	uxth	r2, r3
 8024d3a:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 8024d3e:	1ad3      	subs	r3, r2, r3
 8024d40:	b29b      	uxth	r3, r3
 8024d42:	b21b      	sxth	r3, r3
 8024d44:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
            area_bg.y1 += pad_top_bg;
 8024d48:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8024d4c:	b29a      	uxth	r2, r3
 8024d4e:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	; 0xae
 8024d52:	4413      	add	r3, r2
 8024d54:	b29b      	uxth	r3, r3
 8024d56:	b21b      	sxth	r3, r3
 8024d58:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
            area_bg.y2 -= pad_bottom_bg;
 8024d5c:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8024d60:	b29a      	uxth	r2, r3
 8024d62:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 8024d66:	1ad3      	subs	r3, r2, r3
 8024d68:	b29b      	uxth	r3, r3
 8024d6a:	b21b      	sxth	r3, r3
 8024d6c:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
 8024d70:	e047      	b.n	8024e02 <lv_slider_design+0x224>
        } else {                                                   /*Let space only in the perpendicular directions*/
            area_bg.x1 += slider_w < slider_h ? pad_left_bg : 0;   /*Pad only for vertical slider*/
 8024d72:	f9b7 3060 	ldrsh.w	r3, [r7, #96]	; 0x60
 8024d76:	b29a      	uxth	r2, r3
 8024d78:	f9b7 1088 	ldrsh.w	r1, [r7, #136]	; 0x88
 8024d7c:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8024d80:	4299      	cmp	r1, r3
 8024d82:	da02      	bge.n	8024d8a <lv_slider_design+0x1ac>
 8024d84:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 8024d88:	e000      	b.n	8024d8c <lv_slider_design+0x1ae>
 8024d8a:	2300      	movs	r3, #0
 8024d8c:	4413      	add	r3, r2
 8024d8e:	b29b      	uxth	r3, r3
 8024d90:	b21b      	sxth	r3, r3
 8024d92:	f8a7 3060 	strh.w	r3, [r7, #96]	; 0x60
            area_bg.x2 -= slider_w < slider_h ? pad_right_bg : 0;  /*Pad only for vertical slider*/
 8024d96:	f9b7 3064 	ldrsh.w	r3, [r7, #100]	; 0x64
 8024d9a:	b29a      	uxth	r2, r3
 8024d9c:	f9b7 1088 	ldrsh.w	r1, [r7, #136]	; 0x88
 8024da0:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8024da4:	4299      	cmp	r1, r3
 8024da6:	da02      	bge.n	8024dae <lv_slider_design+0x1d0>
 8024da8:	f8b7 30a8 	ldrh.w	r3, [r7, #168]	; 0xa8
 8024dac:	e000      	b.n	8024db0 <lv_slider_design+0x1d2>
 8024dae:	2300      	movs	r3, #0
 8024db0:	1ad3      	subs	r3, r2, r3
 8024db2:	b29b      	uxth	r3, r3
 8024db4:	b21b      	sxth	r3, r3
 8024db6:	f8a7 3064 	strh.w	r3, [r7, #100]	; 0x64
            area_bg.y1 += slider_w > slider_h ? pad_top_bg : 0;    /*Pad only for horizontal slider*/
 8024dba:	f9b7 3062 	ldrsh.w	r3, [r7, #98]	; 0x62
 8024dbe:	b29a      	uxth	r2, r3
 8024dc0:	f9b7 1088 	ldrsh.w	r1, [r7, #136]	; 0x88
 8024dc4:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8024dc8:	4299      	cmp	r1, r3
 8024dca:	dd02      	ble.n	8024dd2 <lv_slider_design+0x1f4>
 8024dcc:	f8b7 30ae 	ldrh.w	r3, [r7, #174]	; 0xae
 8024dd0:	e000      	b.n	8024dd4 <lv_slider_design+0x1f6>
 8024dd2:	2300      	movs	r3, #0
 8024dd4:	4413      	add	r3, r2
 8024dd6:	b29b      	uxth	r3, r3
 8024dd8:	b21b      	sxth	r3, r3
 8024dda:	f8a7 3062 	strh.w	r3, [r7, #98]	; 0x62
            area_bg.y2 -= slider_w > slider_h ? pad_bottom_bg : 0; /*Pad only for horizontal slider*/
 8024dde:	f9b7 3066 	ldrsh.w	r3, [r7, #102]	; 0x66
 8024de2:	b29a      	uxth	r2, r3
 8024de4:	f9b7 1088 	ldrsh.w	r1, [r7, #136]	; 0x88
 8024de8:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8024dec:	4299      	cmp	r1, r3
 8024dee:	dd02      	ble.n	8024df6 <lv_slider_design+0x218>
 8024df0:	f8b7 30ac 	ldrh.w	r3, [r7, #172]	; 0xac
 8024df4:	e000      	b.n	8024df8 <lv_slider_design+0x21a>
 8024df6:	2300      	movs	r3, #0
 8024df8:	1ad3      	subs	r3, r2, r3
 8024dfa:	b29b      	uxth	r3, r3
 8024dfc:	b21b      	sxth	r3, r3
 8024dfe:	f8a7 3066 	strh.w	r3, [r7, #102]	; 0x66
        lv_draw_rect(&area_bg, mask, style_bg, lv_obj_get_opa_scale(slider));
#else
        /* Draw the borders later if the slider is focused.
         * At value = 100% the indicator can cover to whole background and the focused style won't
         * be visible*/
        if(lv_obj_is_focused(slider)) {
 8024e02:	68f8      	ldr	r0, [r7, #12]
 8024e04:	f7ed fb2d 	bl	8012462 <lv_obj_is_focused>
 8024e08:	4603      	mov	r3, r0
 8024e0a:	2b00      	cmp	r3, #0
 8024e0c:	d012      	beq.n	8024e34 <lv_slider_design+0x256>
            lv_style_t style_tmp;
            lv_style_copy(&style_tmp, style_bg);
 8024e0e:	f107 0314 	add.w	r3, r7, #20
 8024e12:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8024e16:	4618      	mov	r0, r3
 8024e18:	f7ee fe24 	bl	8013a64 <lv_style_copy>
            style_tmp.body.border.width = 0;
 8024e1c:	2300      	movs	r3, #0
 8024e1e:	843b      	strh	r3, [r7, #32]
            lv_draw_rect(&area_bg, mask, &style_tmp, opa_scale);
 8024e20:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8024e24:	f107 0214 	add.w	r2, r7, #20
 8024e28:	f107 0060 	add.w	r0, r7, #96	; 0x60
 8024e2c:	68b9      	ldr	r1, [r7, #8]
 8024e2e:	f7f0 fd68 	bl	8015902 <lv_draw_rect>
 8024e32:	e008      	b.n	8024e46 <lv_slider_design+0x268>
        } else {
            lv_draw_rect(&area_bg, mask, style_bg, opa_scale);
 8024e34:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8024e38:	f107 0060 	add.w	r0, r7, #96	; 0x60
 8024e3c:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 8024e40:	68b9      	ldr	r1, [r7, #8]
 8024e42:	f7f0 fd5e 	bl	8015902 <lv_draw_rect>
        }
#endif

        /*Draw the indicator*/
        lv_area_t area_indic;
        lv_area_copy(&area_indic, &area_bg);
 8024e46:	f107 0260 	add.w	r2, r7, #96	; 0x60
 8024e4a:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8024e4e:	4611      	mov	r1, r2
 8024e50:	4618      	mov	r0, r3
 8024e52:	f7ff fd41 	bl	80248d8 <lv_area_copy>

        /*Be sure at least ver pad/hor pad width indicator will remain*/
        lv_coord_t pad_top_indic    = style_indic->body.padding.top;
 8024e56:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024e5a:	8adb      	ldrh	r3, [r3, #22]
 8024e5c:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
        lv_coord_t pad_bottom_indic = style_indic->body.padding.bottom;
 8024e60:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024e64:	8b1b      	ldrh	r3, [r3, #24]
 8024e66:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
        lv_coord_t pad_left_indic   = style_indic->body.padding.left;
 8024e6a:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024e6e:	8b5b      	ldrh	r3, [r3, #26]
 8024e70:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2
        lv_coord_t pad_right_indic  = style_indic->body.padding.right;
 8024e74:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8024e78:	8b9b      	ldrh	r3, [r3, #28]
 8024e7a:	f8a7 30a0 	strh.w	r3, [r7, #160]	; 0xa0
        if(pad_top_indic + pad_bottom_indic + LV_SLIDER_SIZE_MIN > lv_area_get_height(&area_bg)) {
 8024e7e:	f9b7 20a6 	ldrsh.w	r2, [r7, #166]	; 0xa6
 8024e82:	f9b7 30a4 	ldrsh.w	r3, [r7, #164]	; 0xa4
 8024e86:	4413      	add	r3, r2
 8024e88:	1d1c      	adds	r4, r3, #4
 8024e8a:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024e8e:	4618      	mov	r0, r3
 8024e90:	f7ff fd47 	bl	8024922 <lv_area_get_height>
 8024e94:	4603      	mov	r3, r0
 8024e96:	429c      	cmp	r4, r3
 8024e98:	dd0d      	ble.n	8024eb6 <lv_slider_design+0x2d8>
            pad_top_indic    = (lv_area_get_height(&area_bg) - LV_SLIDER_SIZE_MIN) >> 1;
 8024e9a:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024e9e:	4618      	mov	r0, r3
 8024ea0:	f7ff fd3f 	bl	8024922 <lv_area_get_height>
 8024ea4:	4603      	mov	r3, r0
 8024ea6:	3b04      	subs	r3, #4
 8024ea8:	105b      	asrs	r3, r3, #1
 8024eaa:	f8a7 30a6 	strh.w	r3, [r7, #166]	; 0xa6
            pad_bottom_indic = pad_top_indic;
 8024eae:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
 8024eb2:	f8a7 30a4 	strh.w	r3, [r7, #164]	; 0xa4
        }
        if(pad_left_indic + pad_right_indic + LV_SLIDER_SIZE_MIN > lv_area_get_width(&area_bg)) {
 8024eb6:	f9b7 20a2 	ldrsh.w	r2, [r7, #162]	; 0xa2
 8024eba:	f9b7 30a0 	ldrsh.w	r3, [r7, #160]	; 0xa0
 8024ebe:	4413      	add	r3, r2
 8024ec0:	1d1c      	adds	r4, r3, #4
 8024ec2:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024ec6:	4618      	mov	r0, r3
 8024ec8:	f7ff fd14 	bl	80248f4 <lv_area_get_width>
 8024ecc:	4603      	mov	r3, r0
 8024ece:	429c      	cmp	r4, r3
 8024ed0:	dd0d      	ble.n	8024eee <lv_slider_design+0x310>
            pad_left_indic  = (lv_area_get_width(&area_bg) - LV_SLIDER_SIZE_MIN) >> 1;
 8024ed2:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8024ed6:	4618      	mov	r0, r3
 8024ed8:	f7ff fd0c 	bl	80248f4 <lv_area_get_width>
 8024edc:	4603      	mov	r3, r0
 8024ede:	3b04      	subs	r3, #4
 8024ee0:	105b      	asrs	r3, r3, #1
 8024ee2:	f8a7 30a2 	strh.w	r3, [r7, #162]	; 0xa2
            pad_right_indic = pad_left_indic;
 8024ee6:	f8b7 30a2 	ldrh.w	r3, [r7, #162]	; 0xa2
 8024eea:	f8a7 30a0 	strh.w	r3, [r7, #160]	; 0xa0
        }

        area_indic.x1 += pad_left_indic;
 8024eee:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 8024ef2:	b29a      	uxth	r2, r3
 8024ef4:	f8b7 30a2 	ldrh.w	r3, [r7, #162]	; 0xa2
 8024ef8:	4413      	add	r3, r2
 8024efa:	b29b      	uxth	r3, r3
 8024efc:	b21b      	sxth	r3, r3
 8024efe:	f8a7 3058 	strh.w	r3, [r7, #88]	; 0x58
        area_indic.x2 -= pad_right_indic;
 8024f02:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8024f06:	b29a      	uxth	r2, r3
 8024f08:	f8b7 30a0 	ldrh.w	r3, [r7, #160]	; 0xa0
 8024f0c:	1ad3      	subs	r3, r2, r3
 8024f0e:	b29b      	uxth	r3, r3
 8024f10:	b21b      	sxth	r3, r3
 8024f12:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
        area_indic.y1 += pad_top_indic;
 8024f16:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8024f1a:	b29a      	uxth	r2, r3
 8024f1c:	f8b7 30a6 	ldrh.w	r3, [r7, #166]	; 0xa6
 8024f20:	4413      	add	r3, r2
 8024f22:	b29b      	uxth	r3, r3
 8024f24:	b21b      	sxth	r3, r3
 8024f26:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
        area_indic.y2 -= pad_bottom_indic;
 8024f2a:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 8024f2e:	b29a      	uxth	r2, r3
 8024f30:	f8b7 30a4 	ldrh.w	r3, [r7, #164]	; 0xa4
 8024f34:	1ad3      	subs	r3, r2, r3
 8024f36:	b29b      	uxth	r3, r3
 8024f38:	b21b      	sxth	r3, r3
 8024f3a:	f8a7 305e 	strh.w	r3, [r7, #94]	; 0x5e

        lv_coord_t cur_value = lv_slider_get_value(slider);
 8024f3e:	68f8      	ldr	r0, [r7, #12]
 8024f40:	f7ff fe08 	bl	8024b54 <lv_slider_get_value>
 8024f44:	4603      	mov	r3, r0
 8024f46:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e
        lv_coord_t min_value = lv_slider_get_min_value(slider);
 8024f4a:	68f8      	ldr	r0, [r7, #12]
 8024f4c:	f7ff fd13 	bl	8024976 <lv_slider_get_min_value>
 8024f50:	4603      	mov	r3, r0
 8024f52:	f8a7 3084 	strh.w	r3, [r7, #132]	; 0x84
        lv_coord_t max_value = lv_slider_get_max_value(slider);
 8024f56:	68f8      	ldr	r0, [r7, #12]
 8024f58:	f7ff fd19 	bl	802498e <lv_slider_get_max_value>
 8024f5c:	4603      	mov	r3, r0
 8024f5e:	f8a7 3082 	strh.w	r3, [r7, #130]	; 0x82

        /*If dragged draw to the drag position*/
        if(ext->drag_value != LV_SLIDER_NOT_PRESSED) cur_value = ext->drag_value;
 8024f62:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8024f66:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8024f6a:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8024f6e:	d004      	beq.n	8024f7a <lv_slider_design+0x39c>
 8024f70:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8024f74:	8b1b      	ldrh	r3, [r3, #24]
 8024f76:	f8a7 309e 	strh.w	r3, [r7, #158]	; 0x9e

        if(slider_w >= slider_h) {
 8024f7a:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
 8024f7e:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 8024f82:	429a      	cmp	r2, r3
 8024f84:	db7e      	blt.n	8025084 <lv_slider_design+0x4a6>
            lv_coord_t indic_w = lv_area_get_width(&area_indic);
 8024f86:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8024f8a:	4618      	mov	r0, r3
 8024f8c:	f7ff fcb2 	bl	80248f4 <lv_area_get_width>
 8024f90:	4603      	mov	r3, r0
 8024f92:	f8a7 307a 	strh.w	r3, [r7, #122]	; 0x7a
#if LV_USE_ANIMATION
            if(ext->bar.anim_state != LV_BAR_ANIM_STATE_INV) {
 8024f96:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8024f9a:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8024f9e:	f1b3 3fff 	cmp.w	r3, #4294967295
 8024fa2:	d03e      	beq.n	8025022 <lv_slider_design+0x444>
                /*Calculate the coordinates of anim. start and end*/
                lv_coord_t anim_start_x =
                    (int32_t)((int32_t)indic_w * (ext->bar.anim_start - min_value)) / (max_value - min_value);
 8024fa4:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8024fa8:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8024fac:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 8024fb0:	4611      	mov	r1, r2
 8024fb2:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8024fb6:	1a8a      	subs	r2, r1, r2
 8024fb8:	fb02 f203 	mul.w	r2, r2, r3
 8024fbc:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8024fc0:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8024fc4:	1acb      	subs	r3, r1, r3
 8024fc6:	fb92 f3f3 	sdiv	r3, r2, r3
                lv_coord_t anim_start_x =
 8024fca:	f8a7 3078 	strh.w	r3, [r7, #120]	; 0x78
                lv_coord_t anim_end_x =
                    (int32_t)((int32_t)indic_w * (ext->bar.anim_end - min_value)) / (max_value - min_value);
 8024fce:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8024fd2:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8024fd6:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 8024fda:	4611      	mov	r1, r2
 8024fdc:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8024fe0:	1a8a      	subs	r2, r1, r2
 8024fe2:	fb02 f203 	mul.w	r2, r2, r3
 8024fe6:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8024fea:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8024fee:	1acb      	subs	r3, r1, r3
 8024ff0:	fb92 f3f3 	sdiv	r3, r2, r3
                lv_coord_t anim_end_x =
 8024ff4:	f8a7 3076 	strh.w	r3, [r7, #118]	; 0x76

                /*Calculate the real position based on `anim_state` (between `anim_start` and
                 * `anim_end`)*/
                area_indic.x2 = anim_start_x + (((anim_end_x - anim_start_x) * ext->bar.anim_state) >> 8);
 8024ff8:	f9b7 2076 	ldrsh.w	r2, [r7, #118]	; 0x76
 8024ffc:	f9b7 3078 	ldrsh.w	r3, [r7, #120]	; 0x78
 8025000:	1ad3      	subs	r3, r2, r3
 8025002:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8025006:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 802500a:	fb02 f303 	mul.w	r3, r2, r3
 802500e:	121b      	asrs	r3, r3, #8
 8025010:	b29a      	uxth	r2, r3
 8025012:	f8b7 3078 	ldrh.w	r3, [r7, #120]	; 0x78
 8025016:	4413      	add	r3, r2
 8025018:	b29b      	uxth	r3, r3
 802501a:	b21b      	sxth	r3, r3
 802501c:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
 8025020:	e012      	b.n	8025048 <lv_slider_design+0x46a>
            } else
#endif
            {
                area_indic.x2 = (int32_t)((int32_t)indic_w * (cur_value - min_value)) / (max_value - min_value);
 8025022:	f9b7 307a 	ldrsh.w	r3, [r7, #122]	; 0x7a
 8025026:	f9b7 109e 	ldrsh.w	r1, [r7, #158]	; 0x9e
 802502a:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 802502e:	1a8a      	subs	r2, r1, r2
 8025030:	fb02 f203 	mul.w	r2, r2, r3
 8025034:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8025038:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 802503c:	1acb      	subs	r3, r1, r3
 802503e:	fb92 f3f3 	sdiv	r3, r2, r3
 8025042:	b21b      	sxth	r3, r3
 8025044:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c
            }
            area_indic.x2 = area_indic.x1 + area_indic.x2 - 1;
 8025048:	f9b7 3058 	ldrsh.w	r3, [r7, #88]	; 0x58
 802504c:	b29a      	uxth	r2, r3
 802504e:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8025052:	b29b      	uxth	r3, r3
 8025054:	4413      	add	r3, r2
 8025056:	b29b      	uxth	r3, r3
 8025058:	3b01      	subs	r3, #1
 802505a:	b29b      	uxth	r3, r3
 802505c:	b21b      	sxth	r3, r3
 802505e:	f8a7 305c 	strh.w	r3, [r7, #92]	; 0x5c

            /*Draw the indicator but don't draw an ugly 1px wide rectangle on the left on min.
             * value*/
            if(area_indic.x1 != area_indic.x2) lv_draw_rect(&area_indic, mask, style_indic, opa_scale);
 8025062:	f9b7 2058 	ldrsh.w	r2, [r7, #88]	; 0x58
 8025066:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 802506a:	429a      	cmp	r2, r3
 802506c:	f000 8087 	beq.w	802517e <lv_slider_design+0x5a0>
 8025070:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8025074:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8025078:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 802507c:	68b9      	ldr	r1, [r7, #8]
 802507e:	f7f0 fc40 	bl	8015902 <lv_draw_rect>
 8025082:	e07c      	b.n	802517e <lv_slider_design+0x5a0>

        } else {
            lv_coord_t indic_h = lv_area_get_height(&area_indic);
 8025084:	f107 0358 	add.w	r3, r7, #88	; 0x58
 8025088:	4618      	mov	r0, r3
 802508a:	f7ff fc4a 	bl	8024922 <lv_area_get_height>
 802508e:	4603      	mov	r3, r0
 8025090:	f8a7 3080 	strh.w	r3, [r7, #128]	; 0x80
#if LV_USE_ANIMATION
            if(ext->bar.anim_state != LV_BAR_ANIM_STATE_INV) {
 8025094:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8025098:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 802509c:	f1b3 3fff 	cmp.w	r3, #4294967295
 80250a0:	d03e      	beq.n	8025120 <lv_slider_design+0x542>
                /*Calculate the coordinates of anim. start and end*/
                lv_coord_t anim_start_y =
                    (int32_t)((int32_t)indic_h * (ext->bar.anim_start - min_value)) / (max_value - min_value);
 80250a2:	f9b7 3080 	ldrsh.w	r3, [r7, #128]	; 0x80
 80250a6:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80250aa:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 80250ae:	4611      	mov	r1, r2
 80250b0:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 80250b4:	1a8a      	subs	r2, r1, r2
 80250b6:	fb02 f203 	mul.w	r2, r2, r3
 80250ba:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80250be:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80250c2:	1acb      	subs	r3, r1, r3
 80250c4:	fb92 f3f3 	sdiv	r3, r2, r3
                lv_coord_t anim_start_y =
 80250c8:	f8a7 307e 	strh.w	r3, [r7, #126]	; 0x7e
                lv_coord_t anim_end_y =
                    (int32_t)((int32_t)indic_h * (ext->bar.anim_end - min_value)) / (max_value - min_value);
 80250cc:	f9b7 3080 	ldrsh.w	r3, [r7, #128]	; 0x80
 80250d0:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80250d4:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 80250d8:	4611      	mov	r1, r2
 80250da:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 80250de:	1a8a      	subs	r2, r1, r2
 80250e0:	fb02 f203 	mul.w	r2, r2, r3
 80250e4:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80250e8:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80250ec:	1acb      	subs	r3, r1, r3
 80250ee:	fb92 f3f3 	sdiv	r3, r2, r3
                lv_coord_t anim_end_y =
 80250f2:	f8a7 307c 	strh.w	r3, [r7, #124]	; 0x7c

                /*Calculate the real position based on `anim_state` (between `anim_start` and
                 * `anim_end`)*/
                area_indic.y1 = anim_start_y + (((anim_end_y - anim_start_y) * ext->bar.anim_state) >> 8);
 80250f6:	f9b7 207c 	ldrsh.w	r2, [r7, #124]	; 0x7c
 80250fa:	f9b7 307e 	ldrsh.w	r3, [r7, #126]	; 0x7e
 80250fe:	1ad3      	subs	r3, r2, r3
 8025100:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8025104:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 8025108:	fb02 f303 	mul.w	r3, r2, r3
 802510c:	121b      	asrs	r3, r3, #8
 802510e:	b29a      	uxth	r2, r3
 8025110:	f8b7 307e 	ldrh.w	r3, [r7, #126]	; 0x7e
 8025114:	4413      	add	r3, r2
 8025116:	b29b      	uxth	r3, r3
 8025118:	b21b      	sxth	r3, r3
 802511a:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
 802511e:	e012      	b.n	8025146 <lv_slider_design+0x568>
            } else
#endif
            {
                area_indic.y1 = (int32_t)((int32_t)indic_h * (cur_value - min_value)) / (max_value - min_value);
 8025120:	f9b7 3080 	ldrsh.w	r3, [r7, #128]	; 0x80
 8025124:	f9b7 109e 	ldrsh.w	r1, [r7, #158]	; 0x9e
 8025128:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 802512c:	1a8a      	subs	r2, r1, r2
 802512e:	fb02 f203 	mul.w	r2, r2, r3
 8025132:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8025136:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 802513a:	1acb      	subs	r3, r1, r3
 802513c:	fb92 f3f3 	sdiv	r3, r2, r3
 8025140:	b21b      	sxth	r3, r3
 8025142:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a
            }
            area_indic.y1 = area_indic.y2 - area_indic.y1 + 1;
 8025146:	f9b7 305e 	ldrsh.w	r3, [r7, #94]	; 0x5e
 802514a:	b29a      	uxth	r2, r3
 802514c:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8025150:	b29b      	uxth	r3, r3
 8025152:	1ad3      	subs	r3, r2, r3
 8025154:	b29b      	uxth	r3, r3
 8025156:	3301      	adds	r3, #1
 8025158:	b29b      	uxth	r3, r3
 802515a:	b21b      	sxth	r3, r3
 802515c:	f8a7 305a 	strh.w	r3, [r7, #90]	; 0x5a

            /*Draw the indicator but don't draw an ugly 1px height rectangle on the bottom on min.
             * value*/
            if(area_indic.x1 != area_indic.x2) lv_draw_rect(&area_indic, mask, style_indic, opa_scale);
 8025160:	f9b7 2058 	ldrsh.w	r2, [r7, #88]	; 0x58
 8025164:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 8025168:	429a      	cmp	r2, r3
 802516a:	d008      	beq.n	802517e <lv_slider_design+0x5a0>
 802516c:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8025170:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8025174:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
 8025178:	68b9      	ldr	r1, [r7, #8]
 802517a:	f7f0 fbc2 	bl	8015902 <lv_draw_rect>
        /*Before the knob add the border if required*/
#if LV_USE_GROUP
        /* Draw the borders later if the bar is focused.
         * At value = 100% the indicator can cover to whole background and the focused style won't
         * be visible*/
        if(lv_obj_is_focused(slider)) {
 802517e:	68f8      	ldr	r0, [r7, #12]
 8025180:	f7ed f96f 	bl	8012462 <lv_obj_is_focused>
 8025184:	4603      	mov	r3, r0
 8025186:	2b00      	cmp	r3, #0
 8025188:	d013      	beq.n	80251b2 <lv_slider_design+0x5d4>
            lv_style_t style_tmp;
            lv_style_copy(&style_tmp, style_bg);
 802518a:	f107 0314 	add.w	r3, r7, #20
 802518e:	f8d7 1094 	ldr.w	r1, [r7, #148]	; 0x94
 8025192:	4618      	mov	r0, r3
 8025194:	f7ee fc66 	bl	8013a64 <lv_style_copy>
            style_tmp.body.opa          = LV_OPA_TRANSP;
 8025198:	2300      	movs	r3, #0
 802519a:	773b      	strb	r3, [r7, #28]
            style_tmp.body.shadow.width = 0;
 802519c:	2300      	movs	r3, #0
 802519e:	84fb      	strh	r3, [r7, #38]	; 0x26
            lv_draw_rect(&area_bg, mask, &style_tmp, opa_scale);
 80251a0:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 80251a4:	f107 0214 	add.w	r2, r7, #20
 80251a8:	f107 0060 	add.w	r0, r7, #96	; 0x60
 80251ac:	68b9      	ldr	r1, [r7, #8]
 80251ae:	f7f0 fba8 	bl	8015902 <lv_draw_rect>
        }
#endif

        /*Draw the knob*/
        lv_area_t knob_area;
        lv_area_copy(&knob_area, &slider->coords);
 80251b2:	68fb      	ldr	r3, [r7, #12]
 80251b4:	f103 0210 	add.w	r2, r3, #16
 80251b8:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80251bc:	4611      	mov	r1, r2
 80251be:	4618      	mov	r0, r3
 80251c0:	f7ff fb8a 	bl	80248d8 <lv_area_copy>

        if(slider_w >= slider_h) {
 80251c4:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
 80251c8:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 80251cc:	429a      	cmp	r2, r3
 80251ce:	f2c0 80af 	blt.w	8025330 <lv_slider_design+0x752>
            if(ext->knob_in == 0) {
 80251d2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 80251d6:	7e9b      	ldrb	r3, [r3, #26]
 80251d8:	f003 0301 	and.w	r3, r3, #1
 80251dc:	b2db      	uxtb	r3, r3
 80251de:	2b00      	cmp	r3, #0
 80251e0:	d11c      	bne.n	802521c <lv_slider_design+0x63e>
                knob_area.x1 = area_indic.x2 - slider_h / 2;
 80251e2:	f9b7 305c 	ldrsh.w	r3, [r7, #92]	; 0x5c
 80251e6:	b29a      	uxth	r2, r3
 80251e8:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 80251ec:	2b00      	cmp	r3, #0
 80251ee:	da00      	bge.n	80251f2 <lv_slider_design+0x614>
 80251f0:	3301      	adds	r3, #1
 80251f2:	105b      	asrs	r3, r3, #1
 80251f4:	b21b      	sxth	r3, r3
 80251f6:	b29b      	uxth	r3, r3
 80251f8:	1ad3      	subs	r3, r2, r3
 80251fa:	b29b      	uxth	r3, r3
 80251fc:	b21b      	sxth	r3, r3
 80251fe:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                knob_area.x2 = knob_area.x1 + slider_h - 1;
 8025202:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8025206:	b29a      	uxth	r2, r3
 8025208:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 802520c:	4413      	add	r3, r2
 802520e:	b29b      	uxth	r3, r3
 8025210:	3b01      	subs	r3, #1
 8025212:	b29b      	uxth	r3, r3
 8025214:	b21b      	sxth	r3, r3
 8025216:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
 802521a:	e07e      	b.n	802531a <lv_slider_design+0x73c>
            } else {
#if LV_USE_ANIMATION
                if(ext->bar.anim_state != LV_BAR_ANIM_STATE_INV) {
 802521c:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8025220:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8025224:	f1b3 3fff 	cmp.w	r3, #4294967295
 8025228:	d048      	beq.n	80252bc <lv_slider_design+0x6de>
                    lv_coord_t w = slider_w - slider_h - 1;
 802522a:	f8b7 2088 	ldrh.w	r2, [r7, #136]	; 0x88
 802522e:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 8025232:	1ad3      	subs	r3, r2, r3
 8025234:	b29b      	uxth	r3, r3
 8025236:	3b01      	subs	r3, #1
 8025238:	b29b      	uxth	r3, r3
 802523a:	f8a7 306e 	strh.w	r3, [r7, #110]	; 0x6e
                    lv_coord_t anim_start_x =
                        (int32_t)((int32_t)w * (ext->bar.anim_start - min_value)) / (max_value - min_value);
 802523e:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 8025242:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8025246:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 802524a:	4611      	mov	r1, r2
 802524c:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 8025250:	1a8a      	subs	r2, r1, r2
 8025252:	fb02 f203 	mul.w	r2, r2, r3
 8025256:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 802525a:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 802525e:	1acb      	subs	r3, r1, r3
 8025260:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_start_x =
 8025264:	f8a7 306c 	strh.w	r3, [r7, #108]	; 0x6c
                    lv_coord_t anim_end_x =
                        (int32_t)((int32_t)w * (ext->bar.anim_end - min_value)) / (max_value - min_value);
 8025268:	f9b7 306e 	ldrsh.w	r3, [r7, #110]	; 0x6e
 802526c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 8025270:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 8025274:	4611      	mov	r1, r2
 8025276:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 802527a:	1a8a      	subs	r2, r1, r2
 802527c:	fb02 f203 	mul.w	r2, r2, r3
 8025280:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8025284:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 8025288:	1acb      	subs	r3, r1, r3
 802528a:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_end_x =
 802528e:	f8a7 306a 	strh.w	r3, [r7, #106]	; 0x6a

                    /*Calculate the real position based on `anim_state` (between `anim_start` and
                     * `anim_end`)*/
                    knob_area.x1 = anim_start_x + (((anim_end_x - anim_start_x) * ext->bar.anim_state) >> 8);
 8025292:	f9b7 206a 	ldrsh.w	r2, [r7, #106]	; 0x6a
 8025296:	f9b7 306c 	ldrsh.w	r3, [r7, #108]	; 0x6c
 802529a:	1ad3      	subs	r3, r2, r3
 802529c:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80252a0:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 80252a4:	fb02 f303 	mul.w	r3, r2, r3
 80252a8:	121b      	asrs	r3, r3, #8
 80252aa:	b29a      	uxth	r2, r3
 80252ac:	f8b7 306c 	ldrh.w	r3, [r7, #108]	; 0x6c
 80252b0:	4413      	add	r3, r2
 80252b2:	b29b      	uxth	r3, r3
 80252b4:	b21b      	sxth	r3, r3
 80252b6:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
 80252ba:	e016      	b.n	80252ea <lv_slider_design+0x70c>
                } else
#endif
                {
                    knob_area.x1 = (int32_t)((int32_t)(slider_w - slider_h - 1) * (cur_value - min_value)) /
 80252bc:	f9b7 2088 	ldrsh.w	r2, [r7, #136]	; 0x88
 80252c0:	f9b7 3086 	ldrsh.w	r3, [r7, #134]	; 0x86
 80252c4:	1ad3      	subs	r3, r2, r3
 80252c6:	3b01      	subs	r3, #1
 80252c8:	f9b7 109e 	ldrsh.w	r1, [r7, #158]	; 0x9e
 80252cc:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 80252d0:	1a8a      	subs	r2, r1, r2
 80252d2:	fb02 f203 	mul.w	r2, r2, r3
                                   (max_value - min_value);
 80252d6:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80252da:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80252de:	1acb      	subs	r3, r1, r3
                    knob_area.x1 = (int32_t)((int32_t)(slider_w - slider_h - 1) * (cur_value - min_value)) /
 80252e0:	fb92 f3f3 	sdiv	r3, r2, r3
 80252e4:	b21b      	sxth	r3, r3
 80252e6:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                }

                knob_area.x1 += slider->coords.x1;
 80252ea:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 80252ee:	b29a      	uxth	r2, r3
 80252f0:	68fb      	ldr	r3, [r7, #12]
 80252f2:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 80252f6:	b29b      	uxth	r3, r3
 80252f8:	4413      	add	r3, r2
 80252fa:	b29b      	uxth	r3, r3
 80252fc:	b21b      	sxth	r3, r3
 80252fe:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
                knob_area.x2 = knob_area.x1 + slider_h - 1;
 8025302:	f9b7 3050 	ldrsh.w	r3, [r7, #80]	; 0x50
 8025306:	b29a      	uxth	r2, r3
 8025308:	f8b7 3086 	ldrh.w	r3, [r7, #134]	; 0x86
 802530c:	4413      	add	r3, r2
 802530e:	b29b      	uxth	r3, r3
 8025310:	3b01      	subs	r3, #1
 8025312:	b29b      	uxth	r3, r3
 8025314:	b21b      	sxth	r3, r3
 8025316:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
            }

            knob_area.y1 = slider->coords.y1;
 802531a:	68fb      	ldr	r3, [r7, #12]
 802531c:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 8025320:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            knob_area.y2 = slider->coords.y2;
 8025324:	68fb      	ldr	r3, [r7, #12]
 8025326:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 802532a:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 802532e:	e0ad      	b.n	802548c <lv_slider_design+0x8ae>
        } else {
            if(ext->knob_in == 0) {
 8025330:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8025334:	7e9b      	ldrb	r3, [r3, #26]
 8025336:	f003 0301 	and.w	r3, r3, #1
 802533a:	b2db      	uxtb	r3, r3
 802533c:	2b00      	cmp	r3, #0
 802533e:	d11c      	bne.n	802537a <lv_slider_design+0x79c>
                knob_area.y1 = area_indic.y1 - slider_w / 2;
 8025340:	f9b7 305a 	ldrsh.w	r3, [r7, #90]	; 0x5a
 8025344:	b29a      	uxth	r2, r3
 8025346:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 802534a:	2b00      	cmp	r3, #0
 802534c:	da00      	bge.n	8025350 <lv_slider_design+0x772>
 802534e:	3301      	adds	r3, #1
 8025350:	105b      	asrs	r3, r3, #1
 8025352:	b21b      	sxth	r3, r3
 8025354:	b29b      	uxth	r3, r3
 8025356:	1ad3      	subs	r3, r2, r3
 8025358:	b29b      	uxth	r3, r3
 802535a:	b21b      	sxth	r3, r3
 802535c:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
                knob_area.y2 = knob_area.y1 + slider_w - 1;
 8025360:	f9b7 3052 	ldrsh.w	r3, [r7, #82]	; 0x52
 8025364:	b29a      	uxth	r2, r3
 8025366:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
 802536a:	4413      	add	r3, r2
 802536c:	b29b      	uxth	r3, r3
 802536e:	3b01      	subs	r3, #1
 8025370:	b29b      	uxth	r3, r3
 8025372:	b21b      	sxth	r3, r3
 8025374:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 8025378:	e07e      	b.n	8025478 <lv_slider_design+0x89a>
            } else {
#if LV_USE_ANIMATION
                if(ext->bar.anim_state != LV_BAR_ANIM_STATE_INV) {
 802537a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 802537e:	f9b3 300a 	ldrsh.w	r3, [r3, #10]
 8025382:	f1b3 3fff 	cmp.w	r3, #4294967295
 8025386:	d048      	beq.n	802541a <lv_slider_design+0x83c>
                    lv_coord_t h = slider_h - slider_w - 1;
 8025388:	f8b7 2086 	ldrh.w	r2, [r7, #134]	; 0x86
 802538c:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
 8025390:	1ad3      	subs	r3, r2, r3
 8025392:	b29b      	uxth	r3, r3
 8025394:	3b01      	subs	r3, #1
 8025396:	b29b      	uxth	r3, r3
 8025398:	f8a7 3074 	strh.w	r3, [r7, #116]	; 0x74
                    lv_coord_t anim_start_x =
                        (int32_t)((int32_t)h * (ext->bar.anim_start - min_value)) / (max_value - min_value);
 802539c:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80253a0:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80253a4:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 80253a8:	4611      	mov	r1, r2
 80253aa:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 80253ae:	1a8a      	subs	r2, r1, r2
 80253b0:	fb02 f203 	mul.w	r2, r2, r3
 80253b4:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80253b8:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80253bc:	1acb      	subs	r3, r1, r3
 80253be:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_start_x =
 80253c2:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72
                    lv_coord_t anim_end_x =
                        (int32_t)((int32_t)h * (ext->bar.anim_end - min_value)) / (max_value - min_value);
 80253c6:	f9b7 3074 	ldrsh.w	r3, [r7, #116]	; 0x74
 80253ca:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80253ce:	f9b2 2008 	ldrsh.w	r2, [r2, #8]
 80253d2:	4611      	mov	r1, r2
 80253d4:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 80253d8:	1a8a      	subs	r2, r1, r2
 80253da:	fb02 f203 	mul.w	r2, r2, r3
 80253de:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 80253e2:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 80253e6:	1acb      	subs	r3, r1, r3
 80253e8:	fb92 f3f3 	sdiv	r3, r2, r3
                    lv_coord_t anim_end_x =
 80253ec:	f8a7 3070 	strh.w	r3, [r7, #112]	; 0x70

                    /*Calculate the real position based on `anim_state` (between `anim_start` and
                     * `anim_end`)*/
                    knob_area.y2 = anim_start_x + (((anim_end_x - anim_start_x) * ext->bar.anim_state) >> 8);
 80253f0:	f9b7 2070 	ldrsh.w	r2, [r7, #112]	; 0x70
 80253f4:	f9b7 3072 	ldrsh.w	r3, [r7, #114]	; 0x72
 80253f8:	1ad3      	subs	r3, r2, r3
 80253fa:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80253fe:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 8025402:	fb02 f303 	mul.w	r3, r2, r3
 8025406:	121b      	asrs	r3, r3, #8
 8025408:	b29a      	uxth	r2, r3
 802540a:	f8b7 3072 	ldrh.w	r3, [r7, #114]	; 0x72
 802540e:	4413      	add	r3, r2
 8025410:	b29b      	uxth	r3, r3
 8025412:	b21b      	sxth	r3, r3
 8025414:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
 8025418:	e016      	b.n	8025448 <lv_slider_design+0x86a>
                } else
#endif
                {
                    knob_area.y2 = (int32_t)((int32_t)(slider_h - slider_w - 1) * (cur_value - min_value)) /
 802541a:	f9b7 2086 	ldrsh.w	r2, [r7, #134]	; 0x86
 802541e:	f9b7 3088 	ldrsh.w	r3, [r7, #136]	; 0x88
 8025422:	1ad3      	subs	r3, r2, r3
 8025424:	3b01      	subs	r3, #1
 8025426:	f9b7 109e 	ldrsh.w	r1, [r7, #158]	; 0x9e
 802542a:	f9b7 2084 	ldrsh.w	r2, [r7, #132]	; 0x84
 802542e:	1a8a      	subs	r2, r1, r2
 8025430:	fb02 f203 	mul.w	r2, r2, r3
                                   (max_value - min_value);
 8025434:	f9b7 1082 	ldrsh.w	r1, [r7, #130]	; 0x82
 8025438:	f9b7 3084 	ldrsh.w	r3, [r7, #132]	; 0x84
 802543c:	1acb      	subs	r3, r1, r3
                    knob_area.y2 = (int32_t)((int32_t)(slider_h - slider_w - 1) * (cur_value - min_value)) /
 802543e:	fb92 f3f3 	sdiv	r3, r2, r3
 8025442:	b21b      	sxth	r3, r3
 8025444:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                }

                knob_area.y2 = slider->coords.y2 - knob_area.y2;
 8025448:	68fb      	ldr	r3, [r7, #12]
 802544a:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 802544e:	b29a      	uxth	r2, r3
 8025450:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8025454:	b29b      	uxth	r3, r3
 8025456:	1ad3      	subs	r3, r2, r3
 8025458:	b29b      	uxth	r3, r3
 802545a:	b21b      	sxth	r3, r3
 802545c:	f8a7 3056 	strh.w	r3, [r7, #86]	; 0x56
                knob_area.y1 = knob_area.y2 - slider_w - 1;
 8025460:	f9b7 3056 	ldrsh.w	r3, [r7, #86]	; 0x56
 8025464:	b29a      	uxth	r2, r3
 8025466:	f8b7 3088 	ldrh.w	r3, [r7, #136]	; 0x88
 802546a:	1ad3      	subs	r3, r2, r3
 802546c:	b29b      	uxth	r3, r3
 802546e:	3b01      	subs	r3, #1
 8025470:	b29b      	uxth	r3, r3
 8025472:	b21b      	sxth	r3, r3
 8025474:	f8a7 3052 	strh.w	r3, [r7, #82]	; 0x52
            }
            knob_area.x1 = slider->coords.x1;
 8025478:	68fb      	ldr	r3, [r7, #12]
 802547a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802547e:	f8a7 3050 	strh.w	r3, [r7, #80]	; 0x50
            knob_area.x2 = slider->coords.x2;
 8025482:	68fb      	ldr	r3, [r7, #12]
 8025484:	f9b3 3014 	ldrsh.w	r3, [r3, #20]
 8025488:	f8a7 3054 	strh.w	r3, [r7, #84]	; 0x54
        }
        lv_draw_rect(&knob_area, mask, style_knob, opa_scale);
 802548c:	f897 308b 	ldrb.w	r3, [r7, #139]	; 0x8b
 8025490:	f107 0050 	add.w	r0, r7, #80	; 0x50
 8025494:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8025498:	68b9      	ldr	r1, [r7, #8]
 802549a:	f7f0 fa32 	bl	8015902 <lv_draw_rect>
    }
    /*Post draw when the children are drawn*/
    else if(mode == LV_DESIGN_DRAW_POST) {
    }

    return true;
 802549e:	2301      	movs	r3, #1
}
 80254a0:	4618      	mov	r0, r3
 80254a2:	37b4      	adds	r7, #180	; 0xb4
 80254a4:	46bd      	mov	sp, r7
 80254a6:	bd90      	pop	{r4, r7, pc}

080254a8 <lv_slider_signal>:
 * @param sign a signal type from lv_signal_t enum
 * @param param pointer to a signal specific variable
 * @return LV_RES_OK: the object is not deleted in the function; LV_RES_INV: the object is deleted
 */
static lv_res_t lv_slider_signal(lv_obj_t * slider, lv_signal_t sign, void * param)
{
 80254a8:	b590      	push	{r4, r7, lr}
 80254aa:	b093      	sub	sp, #76	; 0x4c
 80254ac:	af00      	add	r7, sp, #0
 80254ae:	60f8      	str	r0, [r7, #12]
 80254b0:	460b      	mov	r3, r1
 80254b2:	607a      	str	r2, [r7, #4]
 80254b4:	72fb      	strb	r3, [r7, #11]
    lv_res_t res;

    /* Include the ancient signal function */
    res = ancestor_signal(slider, sign, param);
 80254b6:	4bbc      	ldr	r3, [pc, #752]	; (80257a8 <lv_slider_signal+0x300>)
 80254b8:	681b      	ldr	r3, [r3, #0]
 80254ba:	7af9      	ldrb	r1, [r7, #11]
 80254bc:	687a      	ldr	r2, [r7, #4]
 80254be:	68f8      	ldr	r0, [r7, #12]
 80254c0:	4798      	blx	r3
 80254c2:	4603      	mov	r3, r0
 80254c4:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
    if(res != LV_RES_OK) return res;
 80254c8:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80254cc:	2b01      	cmp	r3, #1
 80254ce:	d002      	beq.n	80254d6 <lv_slider_signal+0x2e>
 80254d0:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80254d4:	e237      	b.n	8025946 <lv_slider_signal+0x49e>

    lv_slider_ext_t * ext = lv_obj_get_ext_attr(slider);
 80254d6:	68f8      	ldr	r0, [r7, #12]
 80254d8:	f7ec ffab 	bl	8012432 <lv_obj_get_ext_attr>
 80254dc:	63f8      	str	r0, [r7, #60]	; 0x3c
    lv_point_t p;
    lv_coord_t w = lv_obj_get_width(slider);
 80254de:	68f8      	ldr	r0, [r7, #12]
 80254e0:	f7ec fe58 	bl	8012194 <lv_obj_get_width>
 80254e4:	4603      	mov	r3, r0
 80254e6:	877b      	strh	r3, [r7, #58]	; 0x3a
    lv_coord_t h = lv_obj_get_height(slider);
 80254e8:	68f8      	ldr	r0, [r7, #12]
 80254ea:	f7ec fe61 	bl	80121b0 <lv_obj_get_height>
 80254ee:	4603      	mov	r3, r0
 80254f0:	873b      	strh	r3, [r7, #56]	; 0x38

    if(sign == LV_SIGNAL_PRESSED) {
 80254f2:	7afb      	ldrb	r3, [r7, #11]
 80254f4:	2b07      	cmp	r3, #7
 80254f6:	d107      	bne.n	8025508 <lv_slider_signal+0x60>
        ext->drag_value = lv_slider_get_value(slider);
 80254f8:	68f8      	ldr	r0, [r7, #12]
 80254fa:	f7ff fb2b 	bl	8024b54 <lv_slider_get_value>
 80254fe:	4603      	mov	r3, r0
 8025500:	461a      	mov	r2, r3
 8025502:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025504:	831a      	strh	r2, [r3, #24]
 8025506:	e21c      	b.n	8025942 <lv_slider_signal+0x49a>
    } else if(sign == LV_SIGNAL_PRESSING) {
 8025508:	7afb      	ldrb	r3, [r7, #11]
 802550a:	2b08      	cmp	r3, #8
 802550c:	f040 80b6 	bne.w	802567c <lv_slider_signal+0x1d4>
        lv_indev_get_point(param, &p);
 8025510:	f107 0310 	add.w	r3, r7, #16
 8025514:	4619      	mov	r1, r3
 8025516:	6878      	ldr	r0, [r7, #4]
 8025518:	f7e9 fb61 	bl	800ebde <lv_indev_get_point>
        int16_t tmp = 0;
 802551c:	2300      	movs	r3, #0
 802551e:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        if(w > h) {
 8025522:	f9b7 203a 	ldrsh.w	r2, [r7, #58]	; 0x3a
 8025526:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 802552a:	429a      	cmp	r2, r3
 802552c:	dd38      	ble.n	80255a0 <lv_slider_signal+0xf8>
            lv_coord_t knob_w = h;
 802552e:	8f3b      	ldrh	r3, [r7, #56]	; 0x38
 8025530:	82fb      	strh	r3, [r7, #22]
            p.x -=
 8025532:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8025536:	b29a      	uxth	r2, r3
                slider->coords.x1 + h / 2; /*Modify the point to shift with half knob (important on the start and end)*/
 8025538:	68fb      	ldr	r3, [r7, #12]
 802553a:	f9b3 3010 	ldrsh.w	r3, [r3, #16]
 802553e:	b299      	uxth	r1, r3
 8025540:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 8025544:	2b00      	cmp	r3, #0
 8025546:	da00      	bge.n	802554a <lv_slider_signal+0xa2>
 8025548:	3301      	adds	r3, #1
 802554a:	105b      	asrs	r3, r3, #1
 802554c:	b21b      	sxth	r3, r3
 802554e:	b29b      	uxth	r3, r3
 8025550:	440b      	add	r3, r1
 8025552:	b29b      	uxth	r3, r3
            p.x -=
 8025554:	1ad3      	subs	r3, r2, r3
 8025556:	b29b      	uxth	r3, r3
 8025558:	b21b      	sxth	r3, r3
 802555a:	823b      	strh	r3, [r7, #16]
            tmp = (int32_t)((int32_t)p.x * (ext->bar.max_value - ext->bar.min_value + 1)) / (w - knob_w);
 802555c:	f9b7 3010 	ldrsh.w	r3, [r7, #16]
 8025560:	461a      	mov	r2, r3
 8025562:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025564:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8025568:	4619      	mov	r1, r3
 802556a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802556c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8025570:	1acb      	subs	r3, r1, r3
 8025572:	3301      	adds	r3, #1
 8025574:	fb03 f202 	mul.w	r2, r3, r2
 8025578:	f9b7 103a 	ldrsh.w	r1, [r7, #58]	; 0x3a
 802557c:	f9b7 3016 	ldrsh.w	r3, [r7, #22]
 8025580:	1acb      	subs	r3, r1, r3
 8025582:	fb92 f3f3 	sdiv	r3, r2, r3
 8025586:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
            tmp += ext->bar.min_value;
 802558a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802558c:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8025590:	b29a      	uxth	r2, r3
 8025592:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8025596:	4413      	add	r3, r2
 8025598:	b29b      	uxth	r3, r3
 802559a:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 802559e:	e037      	b.n	8025610 <lv_slider_signal+0x168>
        } else {
            lv_coord_t knob_h = w;
 80255a0:	8f7b      	ldrh	r3, [r7, #58]	; 0x3a
 80255a2:	833b      	strh	r3, [r7, #24]
            p.y -=
 80255a4:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80255a8:	b29a      	uxth	r2, r3
                slider->coords.y1 + w / 2; /*Modify the point to shift with half knob (important on the start and end)*/
 80255aa:	68fb      	ldr	r3, [r7, #12]
 80255ac:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 80255b0:	b299      	uxth	r1, r3
 80255b2:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 80255b6:	2b00      	cmp	r3, #0
 80255b8:	da00      	bge.n	80255bc <lv_slider_signal+0x114>
 80255ba:	3301      	adds	r3, #1
 80255bc:	105b      	asrs	r3, r3, #1
 80255be:	b21b      	sxth	r3, r3
 80255c0:	b29b      	uxth	r3, r3
 80255c2:	440b      	add	r3, r1
 80255c4:	b29b      	uxth	r3, r3
            p.y -=
 80255c6:	1ad3      	subs	r3, r2, r3
 80255c8:	b29b      	uxth	r3, r3
 80255ca:	b21b      	sxth	r3, r3
 80255cc:	827b      	strh	r3, [r7, #18]
            tmp = (int32_t)((int32_t)p.y * (ext->bar.max_value - ext->bar.min_value + 1)) / (h - knob_h);
 80255ce:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 80255d2:	461a      	mov	r2, r3
 80255d4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80255d6:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 80255da:	4619      	mov	r1, r3
 80255dc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80255de:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 80255e2:	1acb      	subs	r3, r1, r3
 80255e4:	3301      	adds	r3, #1
 80255e6:	fb03 f202 	mul.w	r2, r3, r2
 80255ea:	f9b7 1038 	ldrsh.w	r1, [r7, #56]	; 0x38
 80255ee:	f9b7 3018 	ldrsh.w	r3, [r7, #24]
 80255f2:	1acb      	subs	r3, r1, r3
 80255f4:	fb92 f3f3 	sdiv	r3, r2, r3
 80255f8:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
            tmp = ext->bar.max_value - tmp; /*Invert the value: smaller value means higher y*/
 80255fc:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80255fe:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 8025602:	b29a      	uxth	r2, r3
 8025604:	f8b7 3044 	ldrh.w	r3, [r7, #68]	; 0x44
 8025608:	1ad3      	subs	r3, r2, r3
 802560a:	b29b      	uxth	r3, r3
 802560c:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
        }

        if(tmp < ext->bar.min_value)
 8025610:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025612:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 8025616:	f9b7 2044 	ldrsh.w	r2, [r7, #68]	; 0x44
 802561a:	429a      	cmp	r2, r3
 802561c:	da04      	bge.n	8025628 <lv_slider_signal+0x180>
            tmp = ext->bar.min_value;
 802561e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025620:	885b      	ldrh	r3, [r3, #2]
 8025622:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44
 8025626:	e00a      	b.n	802563e <lv_slider_signal+0x196>
        else if(tmp > ext->bar.max_value)
 8025628:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802562a:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 802562e:	f9b7 2044 	ldrsh.w	r2, [r7, #68]	; 0x44
 8025632:	429a      	cmp	r2, r3
 8025634:	dd03      	ble.n	802563e <lv_slider_signal+0x196>
            tmp = ext->bar.max_value;
 8025636:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025638:	889b      	ldrh	r3, [r3, #4]
 802563a:	f8a7 3044 	strh.w	r3, [r7, #68]	; 0x44

        if(tmp != ext->drag_value) {
 802563e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025640:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 8025644:	f9b7 2044 	ldrsh.w	r2, [r7, #68]	; 0x44
 8025648:	429a      	cmp	r2, r3
 802564a:	f000 817a 	beq.w	8025942 <lv_slider_signal+0x49a>
            ext->drag_value = tmp;
 802564e:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025650:	f8b7 2044 	ldrh.w	r2, [r7, #68]	; 0x44
 8025654:	831a      	strh	r2, [r3, #24]
            lv_obj_invalidate(slider);
 8025656:	68f8      	ldr	r0, [r7, #12]
 8025658:	f7eb fbe9 	bl	8010e2e <lv_obj_invalidate>
            res = lv_event_send(slider, LV_EVENT_VALUE_CHANGED, NULL);
 802565c:	2200      	movs	r2, #0
 802565e:	210e      	movs	r1, #14
 8025660:	68f8      	ldr	r0, [r7, #12]
 8025662:	f7ec fbfc 	bl	8011e5e <lv_event_send>
 8025666:	4603      	mov	r3, r0
 8025668:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            if(res != LV_RES_OK) return res;
 802566c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8025670:	2b01      	cmp	r3, #1
 8025672:	f000 8166 	beq.w	8025942 <lv_slider_signal+0x49a>
 8025676:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 802567a:	e164      	b.n	8025946 <lv_slider_signal+0x49e>
        }
    } else if(sign == LV_SIGNAL_RELEASED || sign == LV_SIGNAL_PRESS_LOST) {
 802567c:	7afb      	ldrb	r3, [r7, #11]
 802567e:	2b0a      	cmp	r3, #10
 8025680:	d002      	beq.n	8025688 <lv_slider_signal+0x1e0>
 8025682:	7afb      	ldrb	r3, [r7, #11]
 8025684:	2b09      	cmp	r3, #9
 8025686:	d12f      	bne.n	80256e8 <lv_slider_signal+0x240>
        if(ext->drag_value != LV_SLIDER_NOT_PRESSED) lv_slider_set_value(slider, ext->drag_value, false);
 8025688:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802568a:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802568e:	f513 4f00 	cmn.w	r3, #32768	; 0x8000
 8025692:	d007      	beq.n	80256a4 <lv_slider_signal+0x1fc>
 8025694:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025696:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 802569a:	2200      	movs	r2, #0
 802569c:	4619      	mov	r1, r3
 802569e:	68f8      	ldr	r0, [r7, #12]
 80256a0:	f7ff f956 	bl	8024950 <lv_slider_set_value>
        ext->drag_value = LV_SLIDER_NOT_PRESSED;
 80256a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80256a6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80256aa:	831a      	strh	r2, [r3, #24]

#if LV_USE_GROUP
        /*Leave edit mode if released. (No need to wait for LONG_PRESS) */
        lv_group_t * g             = lv_obj_get_group(slider);
 80256ac:	68f8      	ldr	r0, [r7, #12]
 80256ae:	f7ec fecc 	bl	801244a <lv_obj_get_group>
 80256b2:	61f8      	str	r0, [r7, #28]
        bool editing               = lv_group_get_editing(g);
 80256b4:	69f8      	ldr	r0, [r7, #28]
 80256b6:	f7e8 fee9 	bl	800e48c <lv_group_get_editing>
 80256ba:	4603      	mov	r3, r0
 80256bc:	76fb      	strb	r3, [r7, #27]
        lv_indev_type_t indev_type = lv_indev_get_type(lv_indev_get_act());
 80256be:	f7e9 fa4b 	bl	800eb58 <lv_indev_get_act>
 80256c2:	4603      	mov	r3, r0
 80256c4:	4618      	mov	r0, r3
 80256c6:	f7e9 fa53 	bl	800eb70 <lv_indev_get_type>
 80256ca:	4603      	mov	r3, r0
 80256cc:	76bb      	strb	r3, [r7, #26]
        if(indev_type == LV_INDEV_TYPE_ENCODER) {
 80256ce:	7ebb      	ldrb	r3, [r7, #26]
 80256d0:	2b04      	cmp	r3, #4
 80256d2:	f040 8135 	bne.w	8025940 <lv_slider_signal+0x498>
            if(editing) lv_group_set_editing(g, false);
 80256d6:	7efb      	ldrb	r3, [r7, #27]
 80256d8:	2b00      	cmp	r3, #0
 80256da:	f000 8131 	beq.w	8025940 <lv_slider_signal+0x498>
 80256de:	2100      	movs	r1, #0
 80256e0:	69f8      	ldr	r0, [r7, #28]
 80256e2:	f7e8 fe4a 	bl	800e37a <lv_group_set_editing>
    } else if(sign == LV_SIGNAL_RELEASED || sign == LV_SIGNAL_PRESS_LOST) {
 80256e6:	e12b      	b.n	8025940 <lv_slider_signal+0x498>
        }
#endif

    } else if(sign == LV_SIGNAL_CORD_CHG) {
 80256e8:	7afb      	ldrb	r3, [r7, #11]
 80256ea:	2b02      	cmp	r3, #2
 80256ec:	d11d      	bne.n	802572a <lv_slider_signal+0x282>
        /* The knob size depends on slider size.
         * During the drawing method the ext. size is used by the knob so refresh the ext. size.*/
        if(lv_obj_get_width(slider) != lv_area_get_width(param) ||
 80256ee:	68f8      	ldr	r0, [r7, #12]
 80256f0:	f7ec fd50 	bl	8012194 <lv_obj_get_width>
 80256f4:	4603      	mov	r3, r0
 80256f6:	461c      	mov	r4, r3
 80256f8:	6878      	ldr	r0, [r7, #4]
 80256fa:	f7ff f8fb 	bl	80248f4 <lv_area_get_width>
 80256fe:	4603      	mov	r3, r0
 8025700:	429c      	cmp	r4, r3
 8025702:	d10b      	bne.n	802571c <lv_slider_signal+0x274>
           lv_obj_get_height(slider) != lv_area_get_height(param)) {
 8025704:	68f8      	ldr	r0, [r7, #12]
 8025706:	f7ec fd53 	bl	80121b0 <lv_obj_get_height>
 802570a:	4603      	mov	r3, r0
 802570c:	461c      	mov	r4, r3
 802570e:	6878      	ldr	r0, [r7, #4]
 8025710:	f7ff f907 	bl	8024922 <lv_area_get_height>
 8025714:	4603      	mov	r3, r0
        if(lv_obj_get_width(slider) != lv_area_get_width(param) ||
 8025716:	429c      	cmp	r4, r3
 8025718:	f000 8113 	beq.w	8025942 <lv_slider_signal+0x49a>
            slider->signal_cb(slider, LV_SIGNAL_REFR_EXT_DRAW_PAD, NULL);
 802571c:	68fb      	ldr	r3, [r7, #12]
 802571e:	69db      	ldr	r3, [r3, #28]
 8025720:	2200      	movs	r2, #0
 8025722:	2105      	movs	r1, #5
 8025724:	68f8      	ldr	r0, [r7, #12]
 8025726:	4798      	blx	r3
 8025728:	e10b      	b.n	8025942 <lv_slider_signal+0x49a>
        }
    } else if(sign == LV_SIGNAL_REFR_EXT_DRAW_PAD) {
 802572a:	7afb      	ldrb	r3, [r7, #11]
 802572c:	2b05      	cmp	r3, #5
 802572e:	f040 8089 	bne.w	8025844 <lv_slider_signal+0x39c>
        const lv_style_t * style      = lv_slider_get_style(slider, LV_SLIDER_STYLE_BG);
 8025732:	2100      	movs	r1, #0
 8025734:	68f8      	ldr	r0, [r7, #12]
 8025736:	f7ff fa27 	bl	8024b88 <lv_slider_get_style>
 802573a:	62b8      	str	r0, [r7, #40]	; 0x28
        const lv_style_t * knob_style = lv_slider_get_style(slider, LV_SLIDER_STYLE_KNOB);
 802573c:	2102      	movs	r1, #2
 802573e:	68f8      	ldr	r0, [r7, #12]
 8025740:	f7ff fa22 	bl	8024b88 <lv_slider_get_style>
 8025744:	6278      	str	r0, [r7, #36]	; 0x24

        lv_coord_t shadow_w = knob_style->body.shadow.width;
 8025746:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8025748:	8a5b      	ldrh	r3, [r3, #18]
 802574a:	847b      	strh	r3, [r7, #34]	; 0x22
        if(ext->knob_in == 0) {
 802574c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 802574e:	7e9b      	ldrb	r3, [r3, #26]
 8025750:	f003 0301 	and.w	r3, r3, #1
 8025754:	b2db      	uxtb	r3, r3
 8025756:	2b00      	cmp	r3, #0
 8025758:	d128      	bne.n	80257ac <lv_slider_signal+0x304>
            /* The smaller size is the knob diameter*/
            lv_coord_t x = LV_MATH_MIN(w / 2 + 1 + shadow_w, h / 2 + 1 + shadow_w);
 802575a:	f9b7 3038 	ldrsh.w	r3, [r7, #56]	; 0x38
 802575e:	2b00      	cmp	r3, #0
 8025760:	da00      	bge.n	8025764 <lv_slider_signal+0x2bc>
 8025762:	3301      	adds	r3, #1
 8025764:	105b      	asrs	r3, r3, #1
 8025766:	b21b      	sxth	r3, r3
 8025768:	1c5a      	adds	r2, r3, #1
 802576a:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 802576e:	441a      	add	r2, r3
 8025770:	f9b7 303a 	ldrsh.w	r3, [r7, #58]	; 0x3a
 8025774:	2b00      	cmp	r3, #0
 8025776:	da00      	bge.n	802577a <lv_slider_signal+0x2d2>
 8025778:	3301      	adds	r3, #1
 802577a:	105b      	asrs	r3, r3, #1
 802577c:	b21b      	sxth	r3, r3
 802577e:	1c59      	adds	r1, r3, #1
 8025780:	f9b7 3022 	ldrsh.w	r3, [r7, #34]	; 0x22
 8025784:	440b      	add	r3, r1
 8025786:	4293      	cmp	r3, r2
 8025788:	bfa8      	it	ge
 802578a:	4613      	movge	r3, r2
 802578c:	843b      	strh	r3, [r7, #32]
            if(slider->ext_draw_pad < x) slider->ext_draw_pad = x;
 802578e:	68fb      	ldr	r3, [r7, #12]
 8025790:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8025794:	f9b7 2020 	ldrsh.w	r2, [r7, #32]
 8025798:	429a      	cmp	r2, r3
 802579a:	f340 80d2 	ble.w	8025942 <lv_slider_signal+0x49a>
 802579e:	68fb      	ldr	r3, [r7, #12]
 80257a0:	8c3a      	ldrh	r2, [r7, #32]
 80257a2:	869a      	strh	r2, [r3, #52]	; 0x34
 80257a4:	e0cd      	b.n	8025942 <lv_slider_signal+0x49a>
 80257a6:	bf00      	nop
 80257a8:	2000c3ec 	.word	0x2000c3ec
        } else {
            lv_coord_t pad = 0;
 80257ac:	2300      	movs	r3, #0
 80257ae:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            pad            = LV_MATH_MIN(pad, style->body.padding.top);
 80257b2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80257b4:	f9b3 3016 	ldrsh.w	r3, [r3, #22]
 80257b8:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 80257bc:	4293      	cmp	r3, r2
 80257be:	bfa8      	it	ge
 80257c0:	4613      	movge	r3, r2
 80257c2:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            pad            = LV_MATH_MIN(pad, style->body.padding.bottom);
 80257c6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80257c8:	f9b3 3018 	ldrsh.w	r3, [r3, #24]
 80257cc:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 80257d0:	4293      	cmp	r3, r2
 80257d2:	bfa8      	it	ge
 80257d4:	4613      	movge	r3, r2
 80257d6:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            pad            = LV_MATH_MIN(pad, style->body.padding.left);
 80257da:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80257dc:	f9b3 301a 	ldrsh.w	r3, [r3, #26]
 80257e0:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 80257e4:	4293      	cmp	r3, r2
 80257e6:	bfa8      	it	ge
 80257e8:	4613      	movge	r3, r2
 80257ea:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            pad            = LV_MATH_MIN(pad, style->body.padding.right);
 80257ee:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80257f0:	f9b3 301c 	ldrsh.w	r3, [r3, #28]
 80257f4:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 80257f8:	4293      	cmp	r3, r2
 80257fa:	bfa8      	it	ge
 80257fc:	4613      	movge	r3, r2
 80257fe:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            if(pad < 0) pad = -pad;
 8025802:	f9b7 3042 	ldrsh.w	r3, [r7, #66]	; 0x42
 8025806:	2b00      	cmp	r3, #0
 8025808:	da05      	bge.n	8025816 <lv_slider_signal+0x36e>
 802580a:	f8b7 3042 	ldrh.w	r3, [r7, #66]	; 0x42
 802580e:	425b      	negs	r3, r3
 8025810:	b29b      	uxth	r3, r3
 8025812:	f8a7 3042 	strh.w	r3, [r7, #66]	; 0x42
            if(slider->ext_draw_pad < pad) slider->ext_draw_pad = pad;
 8025816:	68fb      	ldr	r3, [r7, #12]
 8025818:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 802581c:	f9b7 2042 	ldrsh.w	r2, [r7, #66]	; 0x42
 8025820:	429a      	cmp	r2, r3
 8025822:	dd03      	ble.n	802582c <lv_slider_signal+0x384>
 8025824:	68fb      	ldr	r3, [r7, #12]
 8025826:	f8b7 2042 	ldrh.w	r2, [r7, #66]	; 0x42
 802582a:	869a      	strh	r2, [r3, #52]	; 0x34

            if(slider->ext_draw_pad < shadow_w) slider->ext_draw_pad = shadow_w;
 802582c:	68fb      	ldr	r3, [r7, #12]
 802582e:	f9b3 3034 	ldrsh.w	r3, [r3, #52]	; 0x34
 8025832:	f9b7 2022 	ldrsh.w	r2, [r7, #34]	; 0x22
 8025836:	429a      	cmp	r2, r3
 8025838:	f340 8083 	ble.w	8025942 <lv_slider_signal+0x49a>
 802583c:	68fb      	ldr	r3, [r7, #12]
 802583e:	8c7a      	ldrh	r2, [r7, #34]	; 0x22
 8025840:	869a      	strh	r2, [r3, #52]	; 0x34
 8025842:	e07e      	b.n	8025942 <lv_slider_signal+0x49a>
        }
    } else if(sign == LV_SIGNAL_CONTROL) {
 8025844:	7afb      	ldrb	r3, [r7, #11]
 8025846:	2b11      	cmp	r3, #17
 8025848:	d14f      	bne.n	80258ea <lv_slider_signal+0x442>
        char c = *((char *)param);
 802584a:	687b      	ldr	r3, [r7, #4]
 802584c:	781b      	ldrb	r3, [r3, #0]
 802584e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

        ext->drag_value = LV_SLIDER_NOT_PRESSED;
 8025852:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8025854:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8025858:	831a      	strh	r2, [r3, #24]

        if(c == LV_KEY_RIGHT || c == LV_KEY_UP) {
 802585a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 802585e:	2b13      	cmp	r3, #19
 8025860:	d003      	beq.n	802586a <lv_slider_signal+0x3c2>
 8025862:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8025866:	2b11      	cmp	r3, #17
 8025868:	d11b      	bne.n	80258a2 <lv_slider_signal+0x3fa>
            lv_slider_set_value(slider, lv_slider_get_value(slider) + 1, true);
 802586a:	68f8      	ldr	r0, [r7, #12]
 802586c:	f7ff f972 	bl	8024b54 <lv_slider_get_value>
 8025870:	4603      	mov	r3, r0
 8025872:	b29b      	uxth	r3, r3
 8025874:	3301      	adds	r3, #1
 8025876:	b29b      	uxth	r3, r3
 8025878:	b21b      	sxth	r3, r3
 802587a:	2201      	movs	r2, #1
 802587c:	4619      	mov	r1, r3
 802587e:	68f8      	ldr	r0, [r7, #12]
 8025880:	f7ff f866 	bl	8024950 <lv_slider_set_value>
            res = lv_event_send(slider, LV_EVENT_VALUE_CHANGED, NULL);
 8025884:	2200      	movs	r2, #0
 8025886:	210e      	movs	r1, #14
 8025888:	68f8      	ldr	r0, [r7, #12]
 802588a:	f7ec fae8 	bl	8011e5e <lv_event_send>
 802588e:	4603      	mov	r3, r0
 8025890:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            if(res != LV_RES_OK) return res;
 8025894:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 8025898:	2b01      	cmp	r3, #1
 802589a:	d052      	beq.n	8025942 <lv_slider_signal+0x49a>
 802589c:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80258a0:	e051      	b.n	8025946 <lv_slider_signal+0x49e>
        } else if(c == LV_KEY_LEFT || c == LV_KEY_DOWN) {
 80258a2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80258a6:	2b14      	cmp	r3, #20
 80258a8:	d003      	beq.n	80258b2 <lv_slider_signal+0x40a>
 80258aa:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 80258ae:	2b12      	cmp	r3, #18
 80258b0:	d147      	bne.n	8025942 <lv_slider_signal+0x49a>
            lv_slider_set_value(slider, lv_slider_get_value(slider) - 1, true);
 80258b2:	68f8      	ldr	r0, [r7, #12]
 80258b4:	f7ff f94e 	bl	8024b54 <lv_slider_get_value>
 80258b8:	4603      	mov	r3, r0
 80258ba:	b29b      	uxth	r3, r3
 80258bc:	3b01      	subs	r3, #1
 80258be:	b29b      	uxth	r3, r3
 80258c0:	b21b      	sxth	r3, r3
 80258c2:	2201      	movs	r2, #1
 80258c4:	4619      	mov	r1, r3
 80258c6:	68f8      	ldr	r0, [r7, #12]
 80258c8:	f7ff f842 	bl	8024950 <lv_slider_set_value>
            res = lv_event_send(slider, LV_EVENT_VALUE_CHANGED, NULL);
 80258cc:	2200      	movs	r2, #0
 80258ce:	210e      	movs	r1, #14
 80258d0:	68f8      	ldr	r0, [r7, #12]
 80258d2:	f7ec fac4 	bl	8011e5e <lv_event_send>
 80258d6:	4603      	mov	r3, r0
 80258d8:	f887 3047 	strb.w	r3, [r7, #71]	; 0x47
            if(res != LV_RES_OK) return res;
 80258dc:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80258e0:	2b01      	cmp	r3, #1
 80258e2:	d02e      	beq.n	8025942 <lv_slider_signal+0x49a>
 80258e4:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
 80258e8:	e02d      	b.n	8025946 <lv_slider_signal+0x49e>
        }
    } else if(sign == LV_SIGNAL_GET_EDITABLE) {
 80258ea:	7afb      	ldrb	r3, [r7, #11]
 80258ec:	2b12      	cmp	r3, #18
 80258ee:	d105      	bne.n	80258fc <lv_slider_signal+0x454>
        bool * editable = (bool *)param;
 80258f0:	687b      	ldr	r3, [r7, #4]
 80258f2:	633b      	str	r3, [r7, #48]	; 0x30
        *editable       = true;
 80258f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80258f6:	2201      	movs	r2, #1
 80258f8:	701a      	strb	r2, [r3, #0]
 80258fa:	e022      	b.n	8025942 <lv_slider_signal+0x49a>
    } else if(sign == LV_SIGNAL_GET_TYPE) {
 80258fc:	7afb      	ldrb	r3, [r7, #11]
 80258fe:	2b06      	cmp	r3, #6
 8025900:	d11f      	bne.n	8025942 <lv_slider_signal+0x49a>
        lv_obj_type_t * buf = param;
 8025902:	687b      	ldr	r3, [r7, #4]
 8025904:	637b      	str	r3, [r7, #52]	; 0x34
        uint8_t i;
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 8025906:	2300      	movs	r3, #0
 8025908:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
 802590c:	e00b      	b.n	8025926 <lv_slider_signal+0x47e>
            if(buf->type[i] == NULL) break;
 802590e:	f897 2041 	ldrb.w	r2, [r7, #65]	; 0x41
 8025912:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025914:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8025918:	2b00      	cmp	r3, #0
 802591a:	d009      	beq.n	8025930 <lv_slider_signal+0x488>
        for(i = 0; i < LV_MAX_ANCESTOR_NUM - 1; i++) { /*Find the last set data*/
 802591c:	f897 3041 	ldrb.w	r3, [r7, #65]	; 0x41
 8025920:	3301      	adds	r3, #1
 8025922:	f887 3041 	strb.w	r3, [r7, #65]	; 0x41
 8025926:	f897 3041 	ldrb.w	r3, [r7, #65]	; 0x41
 802592a:	2b06      	cmp	r3, #6
 802592c:	d9ef      	bls.n	802590e <lv_slider_signal+0x466>
 802592e:	e000      	b.n	8025932 <lv_slider_signal+0x48a>
            if(buf->type[i] == NULL) break;
 8025930:	bf00      	nop
        }
        buf->type[i] = "lv_slider";
 8025932:	f897 2041 	ldrb.w	r2, [r7, #65]	; 0x41
 8025936:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8025938:	4905      	ldr	r1, [pc, #20]	; (8025950 <lv_slider_signal+0x4a8>)
 802593a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 802593e:	e000      	b.n	8025942 <lv_slider_signal+0x49a>
    } else if(sign == LV_SIGNAL_RELEASED || sign == LV_SIGNAL_PRESS_LOST) {
 8025940:	bf00      	nop
    }

    return res;
 8025942:	f897 3047 	ldrb.w	r3, [r7, #71]	; 0x47
}
 8025946:	4618      	mov	r0, r3
 8025948:	374c      	adds	r7, #76	; 0x4c
 802594a:	46bd      	mov	sp, r7
 802594c:	bd90      	pop	{r4, r7, pc}
 802594e:	bf00      	nop
 8025950:	0802912c 	.word	0x0802912c

08025954 <lv_theme_set_current>:
 * Set a theme for the system.
 * From now, all the created objects will use styles from this theme by default
 * @param th pointer to theme (return value of: 'lv_theme_init_xxx()')
 */
void lv_theme_set_current(lv_theme_t * th)
{
 8025954:	b580      	push	{r7, lr}
 8025956:	b082      	sub	sp, #8
 8025958:	af00      	add	r7, sp, #0
 802595a:	6078      	str	r0, [r7, #4]
#if LV_THEME_LIVE_UPDATE == 0
    current_theme = th;
 802595c:	4a0b      	ldr	r2, [pc, #44]	; (802598c <lv_theme_set_current+0x38>)
 802595e:	687b      	ldr	r3, [r7, #4]
 8025960:	6013      	str	r3, [r2, #0]

#if LV_USE_GROUP
    /*Copy group style modification callback functions*/
    memcpy(&current_theme->group, &th->group, sizeof(th->group));
 8025962:	4b0a      	ldr	r3, [pc, #40]	; (802598c <lv_theme_set_current+0x38>)
 8025964:	681b      	ldr	r3, [r3, #0]
 8025966:	f503 70d6 	add.w	r0, r3, #428	; 0x1ac
 802596a:	687b      	ldr	r3, [r7, #4]
 802596c:	f503 73d6 	add.w	r3, r3, #428	; 0x1ac
 8025970:	2208      	movs	r2, #8
 8025972:	4619      	mov	r1, r3
 8025974:	f001 fc22 	bl	80271bc <memcpy>
#endif

    /*Let the object know their style might change*/
    lv_obj_report_style_mod(NULL);
 8025978:	2000      	movs	r0, #0
 802597a:	f7ec f9c0 	bl	8011cfe <lv_obj_report_style_mod>
    lv_obj_report_style_mod(NULL);

#endif

#if LV_USE_GROUP
    lv_group_report_style_mod(NULL);
 802597e:	2000      	movs	r0, #0
 8025980:	f7e8 fdba 	bl	800e4f8 <lv_group_report_style_mod>
#endif
}
 8025984:	bf00      	nop
 8025986:	3708      	adds	r7, #8
 8025988:	46bd      	mov	sp, r7
 802598a:	bd80      	pop	{r7, pc}
 802598c:	2000c3f0 	.word	0x2000c3f0

08025990 <lv_theme_get_current>:
/**
 * Get the current system theme.
 * @return pointer to the current system theme. NULL if not set.
 */
lv_theme_t * lv_theme_get_current(void)
{
 8025990:	b480      	push	{r7}
 8025992:	af00      	add	r7, sp, #0
#if LV_THEME_LIVE_UPDATE == 0
    return current_theme;
 8025994:	4b03      	ldr	r3, [pc, #12]	; (80259a4 <lv_theme_get_current+0x14>)
 8025996:	681b      	ldr	r3, [r3, #0]
    if(!inited)
        return NULL;
    else
        return &current_theme;
#endif
}
 8025998:	4618      	mov	r0, r3
 802599a:	46bd      	mov	sp, r7
 802599c:	f85d 7b04 	ldr.w	r7, [sp], #4
 80259a0:	4770      	bx	lr
 80259a2:	bf00      	nop
 80259a4:	2000c3f0 	.word	0x2000c3f0

080259a8 <lv_color_mix>:
    return color.full;
#endif
}

static inline lv_color_t lv_color_mix(lv_color_t c1, lv_color_t c2, uint8_t mix)
{
 80259a8:	b480      	push	{r7}
 80259aa:	b085      	sub	sp, #20
 80259ac:	af00      	add	r7, sp, #0
 80259ae:	80b8      	strh	r0, [r7, #4]
 80259b0:	8039      	strh	r1, [r7, #0]
 80259b2:	4613      	mov	r3, r2
 80259b4:	70fb      	strb	r3, [r7, #3]
    lv_color_t ret;
#if LV_COLOR_DEPTH != 1
    /*LV_COLOR_DEPTH == 8, 16 or 32*/
    ret.ch.red = (uint16_t)((uint16_t)c1.ch.red * mix + (c2.ch.red * (255 - mix))) >> 8;
 80259b6:	797b      	ldrb	r3, [r7, #5]
 80259b8:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80259bc:	b2db      	uxtb	r3, r3
 80259be:	b29a      	uxth	r2, r3
 80259c0:	78fb      	ldrb	r3, [r7, #3]
 80259c2:	b29b      	uxth	r3, r3
 80259c4:	fb12 f303 	smulbb	r3, r2, r3
 80259c8:	b29a      	uxth	r2, r3
 80259ca:	787b      	ldrb	r3, [r7, #1]
 80259cc:	f3c3 03c4 	ubfx	r3, r3, #3, #5
 80259d0:	b2db      	uxtb	r3, r3
 80259d2:	b299      	uxth	r1, r3
 80259d4:	78fb      	ldrb	r3, [r7, #3]
 80259d6:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 80259da:	b29b      	uxth	r3, r3
 80259dc:	fb11 f303 	smulbb	r3, r1, r3
 80259e0:	b29b      	uxth	r3, r3
 80259e2:	4413      	add	r3, r2
 80259e4:	b29b      	uxth	r3, r3
 80259e6:	0a1b      	lsrs	r3, r3, #8
 80259e8:	b29b      	uxth	r3, r3
 80259ea:	f003 031f 	and.w	r3, r3, #31
 80259ee:	b2da      	uxtb	r2, r3
 80259f0:	7b7b      	ldrb	r3, [r7, #13]
 80259f2:	f362 03c7 	bfi	r3, r2, #3, #5
 80259f6:	737b      	strb	r3, [r7, #13]
    uint16_t g_2   = (c2.ch.green_h << 3) + c2.ch.green_l;
    uint16_t g_out = (uint16_t)((uint16_t)g_1 * mix + (g_2 * (255 - mix))) >> 8;
    ret.ch.green_h = g_out >> 3;
    ret.ch.green_l = g_out & 0x7;
#else
    ret.ch.green = (uint16_t)((uint16_t)c1.ch.green * mix + (c2.ch.green * (255 - mix))) >> 8;
 80259f8:	88bb      	ldrh	r3, [r7, #4]
 80259fa:	f3c3 1345 	ubfx	r3, r3, #5, #6
 80259fe:	b2db      	uxtb	r3, r3
 8025a00:	b29a      	uxth	r2, r3
 8025a02:	78fb      	ldrb	r3, [r7, #3]
 8025a04:	b29b      	uxth	r3, r3
 8025a06:	fb12 f303 	smulbb	r3, r2, r3
 8025a0a:	b29a      	uxth	r2, r3
 8025a0c:	883b      	ldrh	r3, [r7, #0]
 8025a0e:	f3c3 1345 	ubfx	r3, r3, #5, #6
 8025a12:	b2db      	uxtb	r3, r3
 8025a14:	b299      	uxth	r1, r3
 8025a16:	78fb      	ldrb	r3, [r7, #3]
 8025a18:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8025a1c:	b29b      	uxth	r3, r3
 8025a1e:	fb11 f303 	smulbb	r3, r1, r3
 8025a22:	b29b      	uxth	r3, r3
 8025a24:	4413      	add	r3, r2
 8025a26:	b29b      	uxth	r3, r3
 8025a28:	0a1b      	lsrs	r3, r3, #8
 8025a2a:	b29b      	uxth	r3, r3
 8025a2c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8025a30:	b2da      	uxtb	r2, r3
 8025a32:	89bb      	ldrh	r3, [r7, #12]
 8025a34:	f362 134a 	bfi	r3, r2, #5, #6
 8025a38:	81bb      	strh	r3, [r7, #12]
#endif
    ret.ch.blue = (uint16_t)((uint16_t)c1.ch.blue * mix + (c2.ch.blue * (255 - mix))) >> 8;
 8025a3a:	793b      	ldrb	r3, [r7, #4]
 8025a3c:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8025a40:	b2db      	uxtb	r3, r3
 8025a42:	b29a      	uxth	r2, r3
 8025a44:	78fb      	ldrb	r3, [r7, #3]
 8025a46:	b29b      	uxth	r3, r3
 8025a48:	fb12 f303 	smulbb	r3, r2, r3
 8025a4c:	b29a      	uxth	r2, r3
 8025a4e:	783b      	ldrb	r3, [r7, #0]
 8025a50:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8025a54:	b2db      	uxtb	r3, r3
 8025a56:	b299      	uxth	r1, r3
 8025a58:	78fb      	ldrb	r3, [r7, #3]
 8025a5a:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 8025a5e:	b29b      	uxth	r3, r3
 8025a60:	fb11 f303 	smulbb	r3, r1, r3
 8025a64:	b29b      	uxth	r3, r3
 8025a66:	4413      	add	r3, r2
 8025a68:	b29b      	uxth	r3, r3
 8025a6a:	0a1b      	lsrs	r3, r3, #8
 8025a6c:	b29b      	uxth	r3, r3
 8025a6e:	f003 031f 	and.w	r3, r3, #31
 8025a72:	b2da      	uxtb	r2, r3
 8025a74:	7b3b      	ldrb	r3, [r7, #12]
 8025a76:	f362 0304 	bfi	r3, r2, #0, #5
 8025a7a:	733b      	strb	r3, [r7, #12]
#else
    /*LV_COLOR_DEPTH == 1*/
    ret.full = mix > LV_OPA_50 ? c1.full : c2.full;
#endif

    return ret;
 8025a7c:	89bb      	ldrh	r3, [r7, #12]
}
 8025a7e:	4618      	mov	r0, r3
 8025a80:	3714      	adds	r7, #20
 8025a82:	46bd      	mov	sp, r7
 8025a84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025a88:	4770      	bx	lr

08025a8a <lv_color_make>:
}
#elif LV_COLOR_DEPTH == 16
#if LV_COLOR_16_SWAP == 0
#define LV_COLOR_MAKE(r8, g8, b8) ((lv_color_t){{b8 >> 3, g8 >> 2, r8 >> 3}})
static inline lv_color_t lv_color_make(uint8_t r8, uint8_t g8, uint8_t b8)
{
 8025a8a:	b480      	push	{r7}
 8025a8c:	b085      	sub	sp, #20
 8025a8e:	af00      	add	r7, sp, #0
 8025a90:	4603      	mov	r3, r0
 8025a92:	71fb      	strb	r3, [r7, #7]
 8025a94:	460b      	mov	r3, r1
 8025a96:	71bb      	strb	r3, [r7, #6]
 8025a98:	4613      	mov	r3, r2
 8025a9a:	717b      	strb	r3, [r7, #5]
    lv_color_t color;
    color.ch.blue  = (uint16_t)(b8 >> 3);
 8025a9c:	797b      	ldrb	r3, [r7, #5]
 8025a9e:	08db      	lsrs	r3, r3, #3
 8025aa0:	b2db      	uxtb	r3, r3
 8025aa2:	f003 031f 	and.w	r3, r3, #31
 8025aa6:	b2da      	uxtb	r2, r3
 8025aa8:	7b3b      	ldrb	r3, [r7, #12]
 8025aaa:	f362 0304 	bfi	r3, r2, #0, #5
 8025aae:	733b      	strb	r3, [r7, #12]
    color.ch.green = (uint16_t)(g8 >> 2);
 8025ab0:	79bb      	ldrb	r3, [r7, #6]
 8025ab2:	089b      	lsrs	r3, r3, #2
 8025ab4:	b2db      	uxtb	r3, r3
 8025ab6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8025aba:	b2da      	uxtb	r2, r3
 8025abc:	89bb      	ldrh	r3, [r7, #12]
 8025abe:	f362 134a 	bfi	r3, r2, #5, #6
 8025ac2:	81bb      	strh	r3, [r7, #12]
    color.ch.red   = (uint16_t)(r8 >> 3);
 8025ac4:	79fb      	ldrb	r3, [r7, #7]
 8025ac6:	08db      	lsrs	r3, r3, #3
 8025ac8:	b2db      	uxtb	r3, r3
 8025aca:	f003 031f 	and.w	r3, r3, #31
 8025ace:	b2da      	uxtb	r2, r3
 8025ad0:	7b7b      	ldrb	r3, [r7, #13]
 8025ad2:	f362 03c7 	bfi	r3, r2, #3, #5
 8025ad6:	737b      	strb	r3, [r7, #13]
    return color;
 8025ad8:	89bb      	ldrh	r3, [r7, #12]
}
 8025ada:	4618      	mov	r0, r3
 8025adc:	3714      	adds	r7, #20
 8025ade:	46bd      	mov	sp, r7
 8025ae0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8025ae4:	4770      	bx	lr

08025ae6 <lv_color_hex3>:
{
    return lv_color_make((uint8_t)((c >> 16) & 0xFF), (uint8_t)((c >> 8) & 0xFF), (uint8_t)(c & 0xFF));
}

static inline lv_color_t lv_color_hex3(uint32_t c)
{
 8025ae6:	b580      	push	{r7, lr}
 8025ae8:	b082      	sub	sp, #8
 8025aea:	af00      	add	r7, sp, #0
 8025aec:	6078      	str	r0, [r7, #4]
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 8025aee:	687b      	ldr	r3, [r7, #4]
 8025af0:	091b      	lsrs	r3, r3, #4
 8025af2:	b2db      	uxtb	r3, r3
 8025af4:	f023 030f 	bic.w	r3, r3, #15
 8025af8:	b2da      	uxtb	r2, r3
 8025afa:	687b      	ldr	r3, [r7, #4]
 8025afc:	0a1b      	lsrs	r3, r3, #8
 8025afe:	b2db      	uxtb	r3, r3
 8025b00:	f003 030f 	and.w	r3, r3, #15
 8025b04:	b2db      	uxtb	r3, r3
 8025b06:	4313      	orrs	r3, r2
 8025b08:	b2d8      	uxtb	r0, r3
 8025b0a:	687b      	ldr	r3, [r7, #4]
 8025b0c:	b2db      	uxtb	r3, r3
 8025b0e:	f023 030f 	bic.w	r3, r3, #15
 8025b12:	b2da      	uxtb	r2, r3
 8025b14:	687b      	ldr	r3, [r7, #4]
 8025b16:	091b      	lsrs	r3, r3, #4
 8025b18:	b2db      	uxtb	r3, r3
 8025b1a:	f003 030f 	and.w	r3, r3, #15
 8025b1e:	b2db      	uxtb	r3, r3
 8025b20:	4313      	orrs	r3, r2
 8025b22:	b2d9      	uxtb	r1, r3
                         (uint8_t)((c & 0xF) | ((c & 0xF) << 4)));
 8025b24:	687b      	ldr	r3, [r7, #4]
 8025b26:	b2db      	uxtb	r3, r3
 8025b28:	f003 030f 	and.w	r3, r3, #15
 8025b2c:	b2da      	uxtb	r2, r3
 8025b2e:	687b      	ldr	r3, [r7, #4]
 8025b30:	b2db      	uxtb	r3, r3
 8025b32:	011b      	lsls	r3, r3, #4
 8025b34:	b2db      	uxtb	r3, r3
    return lv_color_make((uint8_t)(((c >> 4) & 0xF0) | ((c >> 8) & 0xF)), (uint8_t)((c & 0xF0) | ((c & 0xF0) >> 4)),
 8025b36:	4313      	orrs	r3, r2
 8025b38:	b2db      	uxtb	r3, r3
 8025b3a:	461a      	mov	r2, r3
 8025b3c:	f7ff ffa5 	bl	8025a8a <lv_color_make>
 8025b40:	4603      	mov	r3, r0
}
 8025b42:	4618      	mov	r0, r3
 8025b44:	3708      	adds	r7, #8
 8025b46:	46bd      	mov	sp, r7
 8025b48:	bd80      	pop	{r7, pc}
	...

08025b4c <basic_init>:
/**********************
 *   STATIC FUNCTIONS
 **********************/

static void basic_init(void)
{
 8025b4c:	b598      	push	{r3, r4, r7, lr}
 8025b4e:	af00      	add	r7, sp, #0
    /*Default*/
    lv_style_copy(&def, &lv_style_plain);
 8025b50:	497b      	ldr	r1, [pc, #492]	; (8025d40 <basic_init+0x1f4>)
 8025b52:	487c      	ldr	r0, [pc, #496]	; (8025d44 <basic_init+0x1f8>)
 8025b54:	f7ed ff86 	bl	8013a64 <lv_style_copy>
    def.body.opa = LV_OPA_COVER;
 8025b58:	4b7a      	ldr	r3, [pc, #488]	; (8025d44 <basic_init+0x1f8>)
 8025b5a:	22ff      	movs	r2, #255	; 0xff
 8025b5c:	721a      	strb	r2, [r3, #8]
    def.glass    = 0;
 8025b5e:	4a79      	ldr	r2, [pc, #484]	; (8025d44 <basic_init+0x1f8>)
 8025b60:	7813      	ldrb	r3, [r2, #0]
 8025b62:	f36f 0300 	bfc	r3, #0, #1
 8025b66:	7013      	strb	r3, [r2, #0]

    def.body.main_color     = lv_color_hex3(0x222);
 8025b68:	4c76      	ldr	r4, [pc, #472]	; (8025d44 <basic_init+0x1f8>)
 8025b6a:	f240 2022 	movw	r0, #546	; 0x222
 8025b6e:	f7ff ffba 	bl	8025ae6 <lv_color_hex3>
 8025b72:	8060      	strh	r0, [r4, #2]

    def.body.radius         = 0;
 8025b74:	4b73      	ldr	r3, [pc, #460]	; (8025d44 <basic_init+0x1f8>)
 8025b76:	2200      	movs	r2, #0
 8025b78:	80da      	strh	r2, [r3, #6]
    def.body.padding.left   = LV_DPI / 8;
 8025b7a:	4b72      	ldr	r3, [pc, #456]	; (8025d44 <basic_init+0x1f8>)
 8025b7c:	220c      	movs	r2, #12
 8025b7e:	835a      	strh	r2, [r3, #26]
    def.body.padding.right  = LV_DPI / 8;
 8025b80:	4b70      	ldr	r3, [pc, #448]	; (8025d44 <basic_init+0x1f8>)
 8025b82:	220c      	movs	r2, #12
 8025b84:	839a      	strh	r2, [r3, #28]
    def.body.padding.top    = LV_DPI / 8;
 8025b86:	4b6f      	ldr	r3, [pc, #444]	; (8025d44 <basic_init+0x1f8>)
 8025b88:	220c      	movs	r2, #12
 8025b8a:	82da      	strh	r2, [r3, #22]
    def.body.padding.bottom = LV_DPI / 8;
 8025b8c:	4b6d      	ldr	r3, [pc, #436]	; (8025d44 <basic_init+0x1f8>)
 8025b8e:	220c      	movs	r2, #12
 8025b90:	831a      	strh	r2, [r3, #24]
    def.body.padding.inner  = LV_DPI / 8;
 8025b92:	4b6c      	ldr	r3, [pc, #432]	; (8025d44 <basic_init+0x1f8>)
 8025b94:	220c      	movs	r2, #12
 8025b96:	83da      	strh	r2, [r3, #30]
    def.body.border.color   = LV_COLOR_SILVER;
 8025b98:	4a6a      	ldr	r2, [pc, #424]	; (8025d44 <basic_init+0x1f8>)
 8025b9a:	4b6b      	ldr	r3, [pc, #428]	; (8025d48 <basic_init+0x1fc>)
 8025b9c:	881b      	ldrh	r3, [r3, #0]
 8025b9e:	8153      	strh	r3, [r2, #10]
    def.body.border.width   = 1;
 8025ba0:	4b68      	ldr	r3, [pc, #416]	; (8025d44 <basic_init+0x1f8>)
 8025ba2:	2201      	movs	r2, #1
 8025ba4:	819a      	strh	r2, [r3, #12]
    def.body.border.opa     = LV_OPA_COVER;
 8025ba6:	4b67      	ldr	r3, [pc, #412]	; (8025d44 <basic_init+0x1f8>)
 8025ba8:	22ff      	movs	r2, #255	; 0xff
 8025baa:	73da      	strb	r2, [r3, #15]
    def.body.shadow.color   = LV_COLOR_SILVER;
 8025bac:	4a65      	ldr	r2, [pc, #404]	; (8025d44 <basic_init+0x1f8>)
 8025bae:	4b66      	ldr	r3, [pc, #408]	; (8025d48 <basic_init+0x1fc>)
 8025bb0:	881b      	ldrh	r3, [r3, #0]
 8025bb2:	8213      	strh	r3, [r2, #16]
    def.body.shadow.width   = 0;
 8025bb4:	4b63      	ldr	r3, [pc, #396]	; (8025d44 <basic_init+0x1f8>)
 8025bb6:	2200      	movs	r2, #0
 8025bb8:	825a      	strh	r2, [r3, #18]
    def.body.shadow.type    = LV_SHADOW_FULL;
 8025bba:	4b62      	ldr	r3, [pc, #392]	; (8025d44 <basic_init+0x1f8>)
 8025bbc:	2201      	movs	r2, #1
 8025bbe:	751a      	strb	r2, [r3, #20]

    def.text.color        = lv_color_hex3(0xDDD);
 8025bc0:	4c60      	ldr	r4, [pc, #384]	; (8025d44 <basic_init+0x1f8>)
 8025bc2:	f640 50dd 	movw	r0, #3549	; 0xddd
 8025bc6:	f7ff ff8e 	bl	8025ae6 <lv_color_hex3>
 8025bca:	8420      	strh	r0, [r4, #32]
    def.text.font         = _font;
 8025bcc:	4b5f      	ldr	r3, [pc, #380]	; (8025d4c <basic_init+0x200>)
 8025bce:	681b      	ldr	r3, [r3, #0]
 8025bd0:	4a5c      	ldr	r2, [pc, #368]	; (8025d44 <basic_init+0x1f8>)
 8025bd2:	6253      	str	r3, [r2, #36]	; 0x24
    def.text.letter_space = 1;
 8025bd4:	4b5b      	ldr	r3, [pc, #364]	; (8025d44 <basic_init+0x1f8>)
 8025bd6:	2201      	movs	r2, #1
 8025bd8:	851a      	strh	r2, [r3, #40]	; 0x28
    def.text.line_space   = 2;
 8025bda:	4b5a      	ldr	r3, [pc, #360]	; (8025d44 <basic_init+0x1f8>)
 8025bdc:	2202      	movs	r2, #2
 8025bde:	855a      	strh	r2, [r3, #42]	; 0x2a

    def.image.color   = lv_color_hex3(0xDDD);
 8025be0:	4c58      	ldr	r4, [pc, #352]	; (8025d44 <basic_init+0x1f8>)
 8025be2:	f640 50dd 	movw	r0, #3549	; 0xddd
 8025be6:	f7ff ff7e 	bl	8025ae6 <lv_color_hex3>
 8025bea:	8620      	strh	r0, [r4, #48]	; 0x30
    def.image.intense = LV_OPA_TRANSP;
 8025bec:	4b55      	ldr	r3, [pc, #340]	; (8025d44 <basic_init+0x1f8>)
 8025bee:	2200      	movs	r2, #0
 8025bf0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

    def.line.color = lv_color_hex3(0xDDD);
 8025bf4:	4c53      	ldr	r4, [pc, #332]	; (8025d44 <basic_init+0x1f8>)
 8025bf6:	f640 50dd 	movw	r0, #3549	; 0xddd
 8025bfa:	f7ff ff74 	bl	8025ae6 <lv_color_hex3>
 8025bfe:	86a0      	strh	r0, [r4, #52]	; 0x34
    def.line.width = 1;
 8025c00:	4b50      	ldr	r3, [pc, #320]	; (8025d44 <basic_init+0x1f8>)
 8025c02:	2201      	movs	r2, #1
 8025c04:	86da      	strh	r2, [r3, #54]	; 0x36

    /*Background*/
    lv_style_copy(&bg, &def);
 8025c06:	494f      	ldr	r1, [pc, #316]	; (8025d44 <basic_init+0x1f8>)
 8025c08:	4851      	ldr	r0, [pc, #324]	; (8025d50 <basic_init+0x204>)
 8025c0a:	f7ed ff2b 	bl	8013a64 <lv_style_copy>
    bg.body.main_color   = lv_color_hex3(0x000);
 8025c0e:	4c50      	ldr	r4, [pc, #320]	; (8025d50 <basic_init+0x204>)
 8025c10:	2000      	movs	r0, #0
 8025c12:	f7ff ff68 	bl	8025ae6 <lv_color_hex3>
 8025c16:	8060      	strh	r0, [r4, #2]
    bg.body.grad_color   = lv_color_hex3(0x000);
 8025c18:	4c4d      	ldr	r4, [pc, #308]	; (8025d50 <basic_init+0x204>)
 8025c1a:	2000      	movs	r0, #0
 8025c1c:	f7ff ff63 	bl	8025ae6 <lv_color_hex3>
 8025c20:	80a0      	strh	r0, [r4, #4]
    bg.body.border.width = 2;
 8025c22:	4b4b      	ldr	r3, [pc, #300]	; (8025d50 <basic_init+0x204>)
 8025c24:	2202      	movs	r2, #2
 8025c26:	819a      	strh	r2, [r3, #12]
    bg.body.border.color = lv_color_hex3(0x666);
 8025c28:	4c49      	ldr	r4, [pc, #292]	; (8025d50 <basic_init+0x204>)
 8025c2a:	f240 6066 	movw	r0, #1638	; 0x666
 8025c2e:	f7ff ff5a 	bl	8025ae6 <lv_color_hex3>
 8025c32:	8160      	strh	r0, [r4, #10]
    bg.body.shadow.color = LV_COLOR_SILVER;
 8025c34:	4a46      	ldr	r2, [pc, #280]	; (8025d50 <basic_init+0x204>)
 8025c36:	4b44      	ldr	r3, [pc, #272]	; (8025d48 <basic_init+0x1fc>)
 8025c38:	881b      	ldrh	r3, [r3, #0]
 8025c3a:	8213      	strh	r3, [r2, #16]

    lv_style_copy(&scr, &bg);
 8025c3c:	4944      	ldr	r1, [pc, #272]	; (8025d50 <basic_init+0x204>)
 8025c3e:	4845      	ldr	r0, [pc, #276]	; (8025d54 <basic_init+0x208>)
 8025c40:	f7ed ff10 	bl	8013a64 <lv_style_copy>
    scr.body.padding.bottom = 0;
 8025c44:	4b43      	ldr	r3, [pc, #268]	; (8025d54 <basic_init+0x208>)
 8025c46:	2200      	movs	r2, #0
 8025c48:	831a      	strh	r2, [r3, #24]
    scr.body.padding.top    = 0;
 8025c4a:	4b42      	ldr	r3, [pc, #264]	; (8025d54 <basic_init+0x208>)
 8025c4c:	2200      	movs	r2, #0
 8025c4e:	82da      	strh	r2, [r3, #22]
    scr.body.padding.left   = 0;
 8025c50:	4b40      	ldr	r3, [pc, #256]	; (8025d54 <basic_init+0x208>)
 8025c52:	2200      	movs	r2, #0
 8025c54:	835a      	strh	r2, [r3, #26]
    scr.body.padding.right  = 0;
 8025c56:	4b3f      	ldr	r3, [pc, #252]	; (8025d54 <basic_init+0x208>)
 8025c58:	2200      	movs	r2, #0
 8025c5a:	839a      	strh	r2, [r3, #28]

    /*Panel*/
    lv_style_copy(&panel, &def);
 8025c5c:	4939      	ldr	r1, [pc, #228]	; (8025d44 <basic_init+0x1f8>)
 8025c5e:	483e      	ldr	r0, [pc, #248]	; (8025d58 <basic_init+0x20c>)
 8025c60:	f7ed ff00 	bl	8013a64 <lv_style_copy>
    panel.body.radius       = LV_DPI / 10;
 8025c64:	4b3c      	ldr	r3, [pc, #240]	; (8025d58 <basic_init+0x20c>)
 8025c66:	220a      	movs	r2, #10
 8025c68:	80da      	strh	r2, [r3, #6]
    panel.body.main_color   = lv_color_hex3(0x500);
 8025c6a:	4c3b      	ldr	r4, [pc, #236]	; (8025d58 <basic_init+0x20c>)
 8025c6c:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 8025c70:	f7ff ff39 	bl	8025ae6 <lv_color_hex3>
 8025c74:	8060      	strh	r0, [r4, #2]
    panel.body.grad_color   = lv_color_hex3(0x505);
 8025c76:	4c38      	ldr	r4, [pc, #224]	; (8025d58 <basic_init+0x20c>)
 8025c78:	f240 5005 	movw	r0, #1285	; 0x505
 8025c7c:	f7ff ff33 	bl	8025ae6 <lv_color_hex3>
 8025c80:	80a0      	strh	r0, [r4, #4]
    panel.body.border.color = lv_color_hex3(0xccc);
 8025c82:	4c35      	ldr	r4, [pc, #212]	; (8025d58 <basic_init+0x20c>)
 8025c84:	f640 40cc 	movw	r0, #3276	; 0xccc
 8025c88:	f7ff ff2d 	bl	8025ae6 <lv_color_hex3>
 8025c8c:	8160      	strh	r0, [r4, #10]
    panel.body.border.width = 2;
 8025c8e:	4b32      	ldr	r3, [pc, #200]	; (8025d58 <basic_init+0x20c>)
 8025c90:	2202      	movs	r2, #2
 8025c92:	819a      	strh	r2, [r3, #12]
    panel.body.border.opa   = LV_OPA_60;
 8025c94:	4b30      	ldr	r3, [pc, #192]	; (8025d58 <basic_init+0x20c>)
 8025c96:	2299      	movs	r2, #153	; 0x99
 8025c98:	73da      	strb	r2, [r3, #15]
    panel.text.color        = lv_color_hsv_to_rgb(_hue, 8, 96);
 8025c9a:	4b30      	ldr	r3, [pc, #192]	; (8025d5c <basic_init+0x210>)
 8025c9c:	881b      	ldrh	r3, [r3, #0]
 8025c9e:	4c2e      	ldr	r4, [pc, #184]	; (8025d58 <basic_init+0x20c>)
 8025ca0:	2260      	movs	r2, #96	; 0x60
 8025ca2:	2108      	movs	r1, #8
 8025ca4:	4618      	mov	r0, r3
 8025ca6:	f7f6 f8d9 	bl	801be5c <lv_color_hsv_to_rgb>
 8025caa:	8420      	strh	r0, [r4, #32]
    panel.line.color        = lv_color_hsv_to_rgb(_hue, 20, 70);
 8025cac:	4b2b      	ldr	r3, [pc, #172]	; (8025d5c <basic_init+0x210>)
 8025cae:	881b      	ldrh	r3, [r3, #0]
 8025cb0:	4c29      	ldr	r4, [pc, #164]	; (8025d58 <basic_init+0x20c>)
 8025cb2:	2246      	movs	r2, #70	; 0x46
 8025cb4:	2114      	movs	r1, #20
 8025cb6:	4618      	mov	r0, r3
 8025cb8:	f7f6 f8d0 	bl	801be5c <lv_color_hsv_to_rgb>
 8025cbc:	86a0      	strh	r0, [r4, #52]	; 0x34

    /*Scrollbar*/
    lv_style_copy(&sb, &def);
 8025cbe:	4921      	ldr	r1, [pc, #132]	; (8025d44 <basic_init+0x1f8>)
 8025cc0:	4827      	ldr	r0, [pc, #156]	; (8025d60 <basic_init+0x214>)
 8025cc2:	f7ed fecf 	bl	8013a64 <lv_style_copy>
    sb.body.opa            = LV_OPA_50;
 8025cc6:	4b26      	ldr	r3, [pc, #152]	; (8025d60 <basic_init+0x214>)
 8025cc8:	227f      	movs	r2, #127	; 0x7f
 8025cca:	721a      	strb	r2, [r3, #8]
    sb.body.radius         = LV_RADIUS_CIRCLE;
 8025ccc:	4b24      	ldr	r3, [pc, #144]	; (8025d60 <basic_init+0x214>)
 8025cce:	f647 4218 	movw	r2, #31768	; 0x7c18
 8025cd2:	80da      	strh	r2, [r3, #6]
    sb.body.border.color   = LV_COLOR_SILVER;
 8025cd4:	4a22      	ldr	r2, [pc, #136]	; (8025d60 <basic_init+0x214>)
 8025cd6:	4b1c      	ldr	r3, [pc, #112]	; (8025d48 <basic_init+0x1fc>)
 8025cd8:	881b      	ldrh	r3, [r3, #0]
 8025cda:	8153      	strh	r3, [r2, #10]
    sb.body.border.opa     = LV_OPA_40;
 8025cdc:	4b20      	ldr	r3, [pc, #128]	; (8025d60 <basic_init+0x214>)
 8025cde:	2266      	movs	r2, #102	; 0x66
 8025ce0:	73da      	strb	r2, [r3, #15]
    sb.body.border.width   = 1;
 8025ce2:	4b1f      	ldr	r3, [pc, #124]	; (8025d60 <basic_init+0x214>)
 8025ce4:	2201      	movs	r2, #1
 8025ce6:	819a      	strh	r2, [r3, #12]
    sb.body.main_color     = lv_color_hsv_to_rgb(_hue, 33, 92);
 8025ce8:	4b1c      	ldr	r3, [pc, #112]	; (8025d5c <basic_init+0x210>)
 8025cea:	881b      	ldrh	r3, [r3, #0]
 8025cec:	4c1c      	ldr	r4, [pc, #112]	; (8025d60 <basic_init+0x214>)
 8025cee:	225c      	movs	r2, #92	; 0x5c
 8025cf0:	2121      	movs	r1, #33	; 0x21
 8025cf2:	4618      	mov	r0, r3
 8025cf4:	f7f6 f8b2 	bl	801be5c <lv_color_hsv_to_rgb>
 8025cf8:	8060      	strh	r0, [r4, #2]
    sb.body.grad_color     = lv_color_hsv_to_rgb(_hue, 33, 92);
 8025cfa:	4b18      	ldr	r3, [pc, #96]	; (8025d5c <basic_init+0x210>)
 8025cfc:	881b      	ldrh	r3, [r3, #0]
 8025cfe:	4c18      	ldr	r4, [pc, #96]	; (8025d60 <basic_init+0x214>)
 8025d00:	225c      	movs	r2, #92	; 0x5c
 8025d02:	2121      	movs	r1, #33	; 0x21
 8025d04:	4618      	mov	r0, r3
 8025d06:	f7f6 f8a9 	bl	801be5c <lv_color_hsv_to_rgb>
 8025d0a:	80a0      	strh	r0, [r4, #4]
    sb.body.padding.left   = 1;
 8025d0c:	4b14      	ldr	r3, [pc, #80]	; (8025d60 <basic_init+0x214>)
 8025d0e:	2201      	movs	r2, #1
 8025d10:	835a      	strh	r2, [r3, #26]
    sb.body.padding.right  = 1;
 8025d12:	4b13      	ldr	r3, [pc, #76]	; (8025d60 <basic_init+0x214>)
 8025d14:	2201      	movs	r2, #1
 8025d16:	839a      	strh	r2, [r3, #28]
    sb.body.padding.top    = 1;
 8025d18:	4b11      	ldr	r3, [pc, #68]	; (8025d60 <basic_init+0x214>)
 8025d1a:	2201      	movs	r2, #1
 8025d1c:	82da      	strh	r2, [r3, #22]
    sb.body.padding.bottom = 1;
 8025d1e:	4b10      	ldr	r3, [pc, #64]	; (8025d60 <basic_init+0x214>)
 8025d20:	2201      	movs	r2, #1
 8025d22:	831a      	strh	r2, [r3, #24]
    sb.body.padding.inner  = LV_DPI / 15; /*Scrollbar width*/
 8025d24:	4b0e      	ldr	r3, [pc, #56]	; (8025d60 <basic_init+0x214>)
 8025d26:	2206      	movs	r2, #6
 8025d28:	83da      	strh	r2, [r3, #30]

    theme.style.bg    = &bg;
 8025d2a:	4b0e      	ldr	r3, [pc, #56]	; (8025d64 <basic_init+0x218>)
 8025d2c:	4a08      	ldr	r2, [pc, #32]	; (8025d50 <basic_init+0x204>)
 8025d2e:	605a      	str	r2, [r3, #4]
    theme.style.scr   = &scr;
 8025d30:	4b0c      	ldr	r3, [pc, #48]	; (8025d64 <basic_init+0x218>)
 8025d32:	4a08      	ldr	r2, [pc, #32]	; (8025d54 <basic_init+0x208>)
 8025d34:	601a      	str	r2, [r3, #0]
    theme.style.panel = &panel;
 8025d36:	4b0b      	ldr	r3, [pc, #44]	; (8025d64 <basic_init+0x218>)
 8025d38:	4a07      	ldr	r2, [pc, #28]	; (8025d58 <basic_init+0x20c>)
 8025d3a:	609a      	str	r2, [r3, #8]
}
 8025d3c:	bf00      	nop
 8025d3e:	bd98      	pop	{r3, r4, r7, pc}
 8025d40:	2000de18 	.word	0x2000de18
 8025d44:	2000c5b0 	.word	0x2000c5b0
 8025d48:	08029138 	.word	0x08029138
 8025d4c:	2000c3f8 	.word	0x2000c3f8
 8025d50:	2000c5ec 	.word	0x2000c5ec
 8025d54:	2000c628 	.word	0x2000c628
 8025d58:	2000c664 	.word	0x2000c664
 8025d5c:	2000c3f4 	.word	0x2000c3f4
 8025d60:	2000c6a0 	.word	0x2000c6a0
 8025d64:	2000c3fc 	.word	0x2000c3fc

08025d68 <btn_init>:

static void btn_init(void)
{
 8025d68:	b598      	push	{r3, r4, r7, lr}
 8025d6a:	af00      	add	r7, sp, #0
#if LV_USE_BTN != 0
    lv_style_copy(&btn_rel, &def);
 8025d6c:	497a      	ldr	r1, [pc, #488]	; (8025f58 <btn_init+0x1f0>)
 8025d6e:	487b      	ldr	r0, [pc, #492]	; (8025f5c <btn_init+0x1f4>)
 8025d70:	f7ed fe78 	bl	8013a64 <lv_style_copy>
    btn_rel.glass               = 0;
 8025d74:	4a79      	ldr	r2, [pc, #484]	; (8025f5c <btn_init+0x1f4>)
 8025d76:	7813      	ldrb	r3, [r2, #0]
 8025d78:	f36f 0300 	bfc	r3, #0, #1
 8025d7c:	7013      	strb	r3, [r2, #0]
    btn_rel.body.opa            = LV_OPA_TRANSP;
 8025d7e:	4b77      	ldr	r3, [pc, #476]	; (8025f5c <btn_init+0x1f4>)
 8025d80:	2200      	movs	r2, #0
 8025d82:	721a      	strb	r2, [r3, #8]
    btn_rel.body.radius         = LV_RADIUS_CIRCLE;
 8025d84:	4b75      	ldr	r3, [pc, #468]	; (8025f5c <btn_init+0x1f4>)
 8025d86:	f647 4218 	movw	r2, #31768	; 0x7c18
 8025d8a:	80da      	strh	r2, [r3, #6]
    btn_rel.body.border.width   = 2;
 8025d8c:	4b73      	ldr	r3, [pc, #460]	; (8025f5c <btn_init+0x1f4>)
 8025d8e:	2202      	movs	r2, #2
 8025d90:	819a      	strh	r2, [r3, #12]
    btn_rel.body.border.color   = lv_color_hsv_to_rgb(_hue, 70, 90);
 8025d92:	4b73      	ldr	r3, [pc, #460]	; (8025f60 <btn_init+0x1f8>)
 8025d94:	881b      	ldrh	r3, [r3, #0]
 8025d96:	4c71      	ldr	r4, [pc, #452]	; (8025f5c <btn_init+0x1f4>)
 8025d98:	225a      	movs	r2, #90	; 0x5a
 8025d9a:	2146      	movs	r1, #70	; 0x46
 8025d9c:	4618      	mov	r0, r3
 8025d9e:	f7f6 f85d 	bl	801be5c <lv_color_hsv_to_rgb>
 8025da2:	8160      	strh	r0, [r4, #10]
    btn_rel.body.border.opa     = LV_OPA_80;
 8025da4:	4b6d      	ldr	r3, [pc, #436]	; (8025f5c <btn_init+0x1f4>)
 8025da6:	22cc      	movs	r2, #204	; 0xcc
 8025da8:	73da      	strb	r2, [r3, #15]
    btn_rel.body.padding.left   = LV_DPI / 4;
 8025daa:	4b6c      	ldr	r3, [pc, #432]	; (8025f5c <btn_init+0x1f4>)
 8025dac:	2219      	movs	r2, #25
 8025dae:	835a      	strh	r2, [r3, #26]
    btn_rel.body.padding.right  = LV_DPI / 4;
 8025db0:	4b6a      	ldr	r3, [pc, #424]	; (8025f5c <btn_init+0x1f4>)
 8025db2:	2219      	movs	r2, #25
 8025db4:	839a      	strh	r2, [r3, #28]
    btn_rel.body.padding.top    = LV_DPI / 6;
 8025db6:	4b69      	ldr	r3, [pc, #420]	; (8025f5c <btn_init+0x1f4>)
 8025db8:	2210      	movs	r2, #16
 8025dba:	82da      	strh	r2, [r3, #22]
    btn_rel.body.padding.bottom = LV_DPI / 6;
 8025dbc:	4b67      	ldr	r3, [pc, #412]	; (8025f5c <btn_init+0x1f4>)
 8025dbe:	2210      	movs	r2, #16
 8025dc0:	831a      	strh	r2, [r3, #24]
    btn_rel.body.padding.inner  = LV_DPI / 10;
 8025dc2:	4b66      	ldr	r3, [pc, #408]	; (8025f5c <btn_init+0x1f4>)
 8025dc4:	220a      	movs	r2, #10
 8025dc6:	83da      	strh	r2, [r3, #30]
    btn_rel.text.color          = lv_color_hsv_to_rgb(_hue, 8, 96);
 8025dc8:	4b65      	ldr	r3, [pc, #404]	; (8025f60 <btn_init+0x1f8>)
 8025dca:	881b      	ldrh	r3, [r3, #0]
 8025dcc:	4c63      	ldr	r4, [pc, #396]	; (8025f5c <btn_init+0x1f4>)
 8025dce:	2260      	movs	r2, #96	; 0x60
 8025dd0:	2108      	movs	r1, #8
 8025dd2:	4618      	mov	r0, r3
 8025dd4:	f7f6 f842 	bl	801be5c <lv_color_hsv_to_rgb>
 8025dd8:	8420      	strh	r0, [r4, #32]
    btn_rel.text.font           = _font;
 8025dda:	4b62      	ldr	r3, [pc, #392]	; (8025f64 <btn_init+0x1fc>)
 8025ddc:	681b      	ldr	r3, [r3, #0]
 8025dde:	4a5f      	ldr	r2, [pc, #380]	; (8025f5c <btn_init+0x1f4>)
 8025de0:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&btn_pr, &btn_rel);
 8025de2:	495e      	ldr	r1, [pc, #376]	; (8025f5c <btn_init+0x1f4>)
 8025de4:	4860      	ldr	r0, [pc, #384]	; (8025f68 <btn_init+0x200>)
 8025de6:	f7ed fe3d 	bl	8013a64 <lv_style_copy>
    btn_pr.body.opa        = LV_OPA_COVER;
 8025dea:	4b5f      	ldr	r3, [pc, #380]	; (8025f68 <btn_init+0x200>)
 8025dec:	22ff      	movs	r2, #255	; 0xff
 8025dee:	721a      	strb	r2, [r3, #8]
    btn_pr.body.main_color = lv_color_hsv_to_rgb(_hue, 50, 50);
 8025df0:	4b5b      	ldr	r3, [pc, #364]	; (8025f60 <btn_init+0x1f8>)
 8025df2:	881b      	ldrh	r3, [r3, #0]
 8025df4:	4c5c      	ldr	r4, [pc, #368]	; (8025f68 <btn_init+0x200>)
 8025df6:	2232      	movs	r2, #50	; 0x32
 8025df8:	2132      	movs	r1, #50	; 0x32
 8025dfa:	4618      	mov	r0, r3
 8025dfc:	f7f6 f82e 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e00:	8060      	strh	r0, [r4, #2]
    btn_pr.body.grad_color = lv_color_hsv_to_rgb(_hue, 50, 50);
 8025e02:	4b57      	ldr	r3, [pc, #348]	; (8025f60 <btn_init+0x1f8>)
 8025e04:	881b      	ldrh	r3, [r3, #0]
 8025e06:	4c58      	ldr	r4, [pc, #352]	; (8025f68 <btn_init+0x200>)
 8025e08:	2232      	movs	r2, #50	; 0x32
 8025e0a:	2132      	movs	r1, #50	; 0x32
 8025e0c:	4618      	mov	r0, r3
 8025e0e:	f7f6 f825 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e12:	80a0      	strh	r0, [r4, #4]
    btn_pr.body.border.opa = LV_OPA_60;
 8025e14:	4b54      	ldr	r3, [pc, #336]	; (8025f68 <btn_init+0x200>)
 8025e16:	2299      	movs	r2, #153	; 0x99
 8025e18:	73da      	strb	r2, [r3, #15]
    btn_pr.text.font       = _font;
 8025e1a:	4b52      	ldr	r3, [pc, #328]	; (8025f64 <btn_init+0x1fc>)
 8025e1c:	681b      	ldr	r3, [r3, #0]
 8025e1e:	4a52      	ldr	r2, [pc, #328]	; (8025f68 <btn_init+0x200>)
 8025e20:	6253      	str	r3, [r2, #36]	; 0x24
    btn_pr.text.color      = lv_color_hsv_to_rgb(_hue, 10, 100);
 8025e22:	4b4f      	ldr	r3, [pc, #316]	; (8025f60 <btn_init+0x1f8>)
 8025e24:	881b      	ldrh	r3, [r3, #0]
 8025e26:	4c50      	ldr	r4, [pc, #320]	; (8025f68 <btn_init+0x200>)
 8025e28:	2264      	movs	r2, #100	; 0x64
 8025e2a:	210a      	movs	r1, #10
 8025e2c:	4618      	mov	r0, r3
 8025e2e:	f7f6 f815 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e32:	8420      	strh	r0, [r4, #32]

    lv_style_copy(&btn_trel, &btn_pr);
 8025e34:	494c      	ldr	r1, [pc, #304]	; (8025f68 <btn_init+0x200>)
 8025e36:	484d      	ldr	r0, [pc, #308]	; (8025f6c <btn_init+0x204>)
 8025e38:	f7ed fe14 	bl	8013a64 <lv_style_copy>
    btn_trel.body.opa          = LV_OPA_COVER;
 8025e3c:	4b4b      	ldr	r3, [pc, #300]	; (8025f6c <btn_init+0x204>)
 8025e3e:	22ff      	movs	r2, #255	; 0xff
 8025e40:	721a      	strb	r2, [r3, #8]
    btn_trel.body.main_color   = lv_color_hsv_to_rgb(_hue, 50, 60);
 8025e42:	4b47      	ldr	r3, [pc, #284]	; (8025f60 <btn_init+0x1f8>)
 8025e44:	881b      	ldrh	r3, [r3, #0]
 8025e46:	4c49      	ldr	r4, [pc, #292]	; (8025f6c <btn_init+0x204>)
 8025e48:	223c      	movs	r2, #60	; 0x3c
 8025e4a:	2132      	movs	r1, #50	; 0x32
 8025e4c:	4618      	mov	r0, r3
 8025e4e:	f7f6 f805 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e52:	8060      	strh	r0, [r4, #2]
    btn_trel.body.grad_color   = lv_color_hsv_to_rgb(_hue, 50, 60);
 8025e54:	4b42      	ldr	r3, [pc, #264]	; (8025f60 <btn_init+0x1f8>)
 8025e56:	881b      	ldrh	r3, [r3, #0]
 8025e58:	4c44      	ldr	r4, [pc, #272]	; (8025f6c <btn_init+0x204>)
 8025e5a:	223c      	movs	r2, #60	; 0x3c
 8025e5c:	2132      	movs	r1, #50	; 0x32
 8025e5e:	4618      	mov	r0, r3
 8025e60:	f7f5 fffc 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e64:	80a0      	strh	r0, [r4, #4]
    btn_trel.body.border.opa   = LV_OPA_60;
 8025e66:	4b41      	ldr	r3, [pc, #260]	; (8025f6c <btn_init+0x204>)
 8025e68:	2299      	movs	r2, #153	; 0x99
 8025e6a:	73da      	strb	r2, [r3, #15]
    btn_trel.body.border.color = lv_color_hsv_to_rgb(_hue, 80, 90);
 8025e6c:	4b3c      	ldr	r3, [pc, #240]	; (8025f60 <btn_init+0x1f8>)
 8025e6e:	881b      	ldrh	r3, [r3, #0]
 8025e70:	4c3e      	ldr	r4, [pc, #248]	; (8025f6c <btn_init+0x204>)
 8025e72:	225a      	movs	r2, #90	; 0x5a
 8025e74:	2150      	movs	r1, #80	; 0x50
 8025e76:	4618      	mov	r0, r3
 8025e78:	f7f5 fff0 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e7c:	8160      	strh	r0, [r4, #10]
    btn_trel.text.font         = _font;
 8025e7e:	4b39      	ldr	r3, [pc, #228]	; (8025f64 <btn_init+0x1fc>)
 8025e80:	681b      	ldr	r3, [r3, #0]
 8025e82:	4a3a      	ldr	r2, [pc, #232]	; (8025f6c <btn_init+0x204>)
 8025e84:	6253      	str	r3, [r2, #36]	; 0x24
    btn_trel.text.color        = lv_color_hsv_to_rgb(_hue, 0, 100);
 8025e86:	4b36      	ldr	r3, [pc, #216]	; (8025f60 <btn_init+0x1f8>)
 8025e88:	881b      	ldrh	r3, [r3, #0]
 8025e8a:	4c38      	ldr	r4, [pc, #224]	; (8025f6c <btn_init+0x204>)
 8025e8c:	2264      	movs	r2, #100	; 0x64
 8025e8e:	2100      	movs	r1, #0
 8025e90:	4618      	mov	r0, r3
 8025e92:	f7f5 ffe3 	bl	801be5c <lv_color_hsv_to_rgb>
 8025e96:	8420      	strh	r0, [r4, #32]

    lv_style_copy(&btn_tpr, &btn_trel);
 8025e98:	4934      	ldr	r1, [pc, #208]	; (8025f6c <btn_init+0x204>)
 8025e9a:	4835      	ldr	r0, [pc, #212]	; (8025f70 <btn_init+0x208>)
 8025e9c:	f7ed fde2 	bl	8013a64 <lv_style_copy>
    btn_tpr.body.opa          = LV_OPA_COVER;
 8025ea0:	4b33      	ldr	r3, [pc, #204]	; (8025f70 <btn_init+0x208>)
 8025ea2:	22ff      	movs	r2, #255	; 0xff
 8025ea4:	721a      	strb	r2, [r3, #8]
    btn_tpr.body.main_color   = lv_color_hsv_to_rgb(_hue, 50, 50);
 8025ea6:	4b2e      	ldr	r3, [pc, #184]	; (8025f60 <btn_init+0x1f8>)
 8025ea8:	881b      	ldrh	r3, [r3, #0]
 8025eaa:	4c31      	ldr	r4, [pc, #196]	; (8025f70 <btn_init+0x208>)
 8025eac:	2232      	movs	r2, #50	; 0x32
 8025eae:	2132      	movs	r1, #50	; 0x32
 8025eb0:	4618      	mov	r0, r3
 8025eb2:	f7f5 ffd3 	bl	801be5c <lv_color_hsv_to_rgb>
 8025eb6:	8060      	strh	r0, [r4, #2]
    btn_tpr.body.grad_color   = lv_color_hsv_to_rgb(_hue, 50, 50);
 8025eb8:	4b29      	ldr	r3, [pc, #164]	; (8025f60 <btn_init+0x1f8>)
 8025eba:	881b      	ldrh	r3, [r3, #0]
 8025ebc:	4c2c      	ldr	r4, [pc, #176]	; (8025f70 <btn_init+0x208>)
 8025ebe:	2232      	movs	r2, #50	; 0x32
 8025ec0:	2132      	movs	r1, #50	; 0x32
 8025ec2:	4618      	mov	r0, r3
 8025ec4:	f7f5 ffca 	bl	801be5c <lv_color_hsv_to_rgb>
 8025ec8:	80a0      	strh	r0, [r4, #4]
    btn_tpr.body.border.opa   = LV_OPA_60;
 8025eca:	4b29      	ldr	r3, [pc, #164]	; (8025f70 <btn_init+0x208>)
 8025ecc:	2299      	movs	r2, #153	; 0x99
 8025ece:	73da      	strb	r2, [r3, #15]
    btn_tpr.body.border.color = lv_color_hsv_to_rgb(_hue, 80, 70);
 8025ed0:	4b23      	ldr	r3, [pc, #140]	; (8025f60 <btn_init+0x1f8>)
 8025ed2:	881b      	ldrh	r3, [r3, #0]
 8025ed4:	4c26      	ldr	r4, [pc, #152]	; (8025f70 <btn_init+0x208>)
 8025ed6:	2246      	movs	r2, #70	; 0x46
 8025ed8:	2150      	movs	r1, #80	; 0x50
 8025eda:	4618      	mov	r0, r3
 8025edc:	f7f5 ffbe 	bl	801be5c <lv_color_hsv_to_rgb>
 8025ee0:	8160      	strh	r0, [r4, #10]
    btn_tpr.text.font         = _font;
 8025ee2:	4b20      	ldr	r3, [pc, #128]	; (8025f64 <btn_init+0x1fc>)
 8025ee4:	681b      	ldr	r3, [r3, #0]
 8025ee6:	4a22      	ldr	r2, [pc, #136]	; (8025f70 <btn_init+0x208>)
 8025ee8:	6253      	str	r3, [r2, #36]	; 0x24
    btn_tpr.text.color        = lv_color_hsv_to_rgb(_hue, 10, 90);
 8025eea:	4b1d      	ldr	r3, [pc, #116]	; (8025f60 <btn_init+0x1f8>)
 8025eec:	881b      	ldrh	r3, [r3, #0]
 8025eee:	4c20      	ldr	r4, [pc, #128]	; (8025f70 <btn_init+0x208>)
 8025ef0:	225a      	movs	r2, #90	; 0x5a
 8025ef2:	210a      	movs	r1, #10
 8025ef4:	4618      	mov	r0, r3
 8025ef6:	f7f5 ffb1 	bl	801be5c <lv_color_hsv_to_rgb>
 8025efa:	8420      	strh	r0, [r4, #32]

    lv_style_copy(&btn_ina, &btn_rel);
 8025efc:	4917      	ldr	r1, [pc, #92]	; (8025f5c <btn_init+0x1f4>)
 8025efe:	481d      	ldr	r0, [pc, #116]	; (8025f74 <btn_init+0x20c>)
 8025f00:	f7ed fdb0 	bl	8013a64 <lv_style_copy>
    btn_ina.body.border.opa   = LV_OPA_60;
 8025f04:	4b1b      	ldr	r3, [pc, #108]	; (8025f74 <btn_init+0x20c>)
 8025f06:	2299      	movs	r2, #153	; 0x99
 8025f08:	73da      	strb	r2, [r3, #15]
    btn_ina.body.border.color = lv_color_hsv_to_rgb(_hue, 10, 50);
 8025f0a:	4b15      	ldr	r3, [pc, #84]	; (8025f60 <btn_init+0x1f8>)
 8025f0c:	881b      	ldrh	r3, [r3, #0]
 8025f0e:	4c19      	ldr	r4, [pc, #100]	; (8025f74 <btn_init+0x20c>)
 8025f10:	2232      	movs	r2, #50	; 0x32
 8025f12:	210a      	movs	r1, #10
 8025f14:	4618      	mov	r0, r3
 8025f16:	f7f5 ffa1 	bl	801be5c <lv_color_hsv_to_rgb>
 8025f1a:	8160      	strh	r0, [r4, #10]
    btn_ina.text.font         = _font;
 8025f1c:	4b11      	ldr	r3, [pc, #68]	; (8025f64 <btn_init+0x1fc>)
 8025f1e:	681b      	ldr	r3, [r3, #0]
 8025f20:	4a14      	ldr	r2, [pc, #80]	; (8025f74 <btn_init+0x20c>)
 8025f22:	6253      	str	r3, [r2, #36]	; 0x24
    btn_ina.text.color        = lv_color_hsv_to_rgb(_hue, 10, 90);
 8025f24:	4b0e      	ldr	r3, [pc, #56]	; (8025f60 <btn_init+0x1f8>)
 8025f26:	881b      	ldrh	r3, [r3, #0]
 8025f28:	4c12      	ldr	r4, [pc, #72]	; (8025f74 <btn_init+0x20c>)
 8025f2a:	225a      	movs	r2, #90	; 0x5a
 8025f2c:	210a      	movs	r1, #10
 8025f2e:	4618      	mov	r0, r3
 8025f30:	f7f5 ff94 	bl	801be5c <lv_color_hsv_to_rgb>
 8025f34:	8420      	strh	r0, [r4, #32]

    theme.style.btn.rel     = &btn_rel;
 8025f36:	4b10      	ldr	r3, [pc, #64]	; (8025f78 <btn_init+0x210>)
 8025f38:	4a08      	ldr	r2, [pc, #32]	; (8025f5c <btn_init+0x1f4>)
 8025f3a:	611a      	str	r2, [r3, #16]
    theme.style.btn.pr      = &btn_pr;
 8025f3c:	4b0e      	ldr	r3, [pc, #56]	; (8025f78 <btn_init+0x210>)
 8025f3e:	4a0a      	ldr	r2, [pc, #40]	; (8025f68 <btn_init+0x200>)
 8025f40:	615a      	str	r2, [r3, #20]
    theme.style.btn.tgl_rel = &btn_trel;
 8025f42:	4b0d      	ldr	r3, [pc, #52]	; (8025f78 <btn_init+0x210>)
 8025f44:	4a09      	ldr	r2, [pc, #36]	; (8025f6c <btn_init+0x204>)
 8025f46:	619a      	str	r2, [r3, #24]
    theme.style.btn.tgl_pr  = &btn_tpr;
 8025f48:	4b0b      	ldr	r3, [pc, #44]	; (8025f78 <btn_init+0x210>)
 8025f4a:	4a09      	ldr	r2, [pc, #36]	; (8025f70 <btn_init+0x208>)
 8025f4c:	61da      	str	r2, [r3, #28]
    theme.style.btn.ina     = &btn_ina;
 8025f4e:	4b0a      	ldr	r3, [pc, #40]	; (8025f78 <btn_init+0x210>)
 8025f50:	4a08      	ldr	r2, [pc, #32]	; (8025f74 <btn_init+0x20c>)
 8025f52:	621a      	str	r2, [r3, #32]
#endif
}
 8025f54:	bf00      	nop
 8025f56:	bd98      	pop	{r3, r4, r7, pc}
 8025f58:	2000c5b0 	.word	0x2000c5b0
 8025f5c:	2000c6dc 	.word	0x2000c6dc
 8025f60:	2000c3f4 	.word	0x2000c3f4
 8025f64:	2000c3f8 	.word	0x2000c3f8
 8025f68:	2000c718 	.word	0x2000c718
 8025f6c:	2000c754 	.word	0x2000c754
 8025f70:	2000c790 	.word	0x2000c790
 8025f74:	2000c7cc 	.word	0x2000c7cc
 8025f78:	2000c3fc 	.word	0x2000c3fc

08025f7c <label_init>:

static void label_init(void)
{
 8025f7c:	b598      	push	{r3, r4, r7, lr}
 8025f7e:	af00      	add	r7, sp, #0
#if LV_USE_LABEL != 0
    static lv_style_t label_prim, label_sec, label_hint;

    lv_style_copy(&label_prim, &def);
 8025f80:	491a      	ldr	r1, [pc, #104]	; (8025fec <label_init+0x70>)
 8025f82:	481b      	ldr	r0, [pc, #108]	; (8025ff0 <label_init+0x74>)
 8025f84:	f7ed fd6e 	bl	8013a64 <lv_style_copy>
    label_prim.text.font  = _font;
 8025f88:	4b1a      	ldr	r3, [pc, #104]	; (8025ff4 <label_init+0x78>)
 8025f8a:	681b      	ldr	r3, [r3, #0]
 8025f8c:	4a18      	ldr	r2, [pc, #96]	; (8025ff0 <label_init+0x74>)
 8025f8e:	6253      	str	r3, [r2, #36]	; 0x24
    label_prim.text.color = lv_color_hsv_to_rgb(_hue, 5, 96);
 8025f90:	4b19      	ldr	r3, [pc, #100]	; (8025ff8 <label_init+0x7c>)
 8025f92:	881b      	ldrh	r3, [r3, #0]
 8025f94:	4c16      	ldr	r4, [pc, #88]	; (8025ff0 <label_init+0x74>)
 8025f96:	2260      	movs	r2, #96	; 0x60
 8025f98:	2105      	movs	r1, #5
 8025f9a:	4618      	mov	r0, r3
 8025f9c:	f7f5 ff5e 	bl	801be5c <lv_color_hsv_to_rgb>
 8025fa0:	8420      	strh	r0, [r4, #32]

    lv_style_copy(&label_sec, &label_prim);
 8025fa2:	4913      	ldr	r1, [pc, #76]	; (8025ff0 <label_init+0x74>)
 8025fa4:	4815      	ldr	r0, [pc, #84]	; (8025ffc <label_init+0x80>)
 8025fa6:	f7ed fd5d 	bl	8013a64 <lv_style_copy>
    label_sec.text.color = lv_color_hsv_to_rgb(_hue, 40, 85);
 8025faa:	4b13      	ldr	r3, [pc, #76]	; (8025ff8 <label_init+0x7c>)
 8025fac:	881b      	ldrh	r3, [r3, #0]
 8025fae:	4c13      	ldr	r4, [pc, #76]	; (8025ffc <label_init+0x80>)
 8025fb0:	2255      	movs	r2, #85	; 0x55
 8025fb2:	2128      	movs	r1, #40	; 0x28
 8025fb4:	4618      	mov	r0, r3
 8025fb6:	f7f5 ff51 	bl	801be5c <lv_color_hsv_to_rgb>
 8025fba:	8420      	strh	r0, [r4, #32]

    lv_style_copy(&label_hint, &label_prim);
 8025fbc:	490c      	ldr	r1, [pc, #48]	; (8025ff0 <label_init+0x74>)
 8025fbe:	4810      	ldr	r0, [pc, #64]	; (8026000 <label_init+0x84>)
 8025fc0:	f7ed fd50 	bl	8013a64 <lv_style_copy>
    label_hint.text.color = lv_color_hsv_to_rgb(_hue, 20, 70);
 8025fc4:	4b0c      	ldr	r3, [pc, #48]	; (8025ff8 <label_init+0x7c>)
 8025fc6:	881b      	ldrh	r3, [r3, #0]
 8025fc8:	4c0d      	ldr	r4, [pc, #52]	; (8026000 <label_init+0x84>)
 8025fca:	2246      	movs	r2, #70	; 0x46
 8025fcc:	2114      	movs	r1, #20
 8025fce:	4618      	mov	r0, r3
 8025fd0:	f7f5 ff44 	bl	801be5c <lv_color_hsv_to_rgb>
 8025fd4:	8420      	strh	r0, [r4, #32]

    theme.style.label.prim = &label_prim;
 8025fd6:	4b0b      	ldr	r3, [pc, #44]	; (8026004 <label_init+0x88>)
 8025fd8:	4a05      	ldr	r2, [pc, #20]	; (8025ff0 <label_init+0x74>)
 8025fda:	639a      	str	r2, [r3, #56]	; 0x38
    theme.style.label.sec  = &label_sec;
 8025fdc:	4b09      	ldr	r3, [pc, #36]	; (8026004 <label_init+0x88>)
 8025fde:	4a07      	ldr	r2, [pc, #28]	; (8025ffc <label_init+0x80>)
 8025fe0:	63da      	str	r2, [r3, #60]	; 0x3c
    theme.style.label.hint = &label_hint;
 8025fe2:	4b08      	ldr	r3, [pc, #32]	; (8026004 <label_init+0x88>)
 8025fe4:	4a06      	ldr	r2, [pc, #24]	; (8026000 <label_init+0x84>)
 8025fe6:	641a      	str	r2, [r3, #64]	; 0x40
#endif
}
 8025fe8:	bf00      	nop
 8025fea:	bd98      	pop	{r3, r4, r7, pc}
 8025fec:	2000c5b0 	.word	0x2000c5b0
 8025ff0:	2000ca9c 	.word	0x2000ca9c
 8025ff4:	2000c3f8 	.word	0x2000c3f8
 8025ff8:	2000c3f4 	.word	0x2000c3f4
 8025ffc:	2000cad8 	.word	0x2000cad8
 8026000:	2000cb14 	.word	0x2000cb14
 8026004:	2000c3fc 	.word	0x2000c3fc

08026008 <bar_init>:

static void bar_init(void)
{
 8026008:	b598      	push	{r3, r4, r7, lr}
 802600a:	af00      	add	r7, sp, #0
#if LV_USE_BAR
    lv_style_copy(&bar_bg, &def);
 802600c:	4937      	ldr	r1, [pc, #220]	; (80260ec <bar_init+0xe4>)
 802600e:	4838      	ldr	r0, [pc, #224]	; (80260f0 <bar_init+0xe8>)
 8026010:	f7ed fd28 	bl	8013a64 <lv_style_copy>
    bar_bg.body.opa            = LV_OPA_30;
 8026014:	4b36      	ldr	r3, [pc, #216]	; (80260f0 <bar_init+0xe8>)
 8026016:	224c      	movs	r2, #76	; 0x4c
 8026018:	721a      	strb	r2, [r3, #8]
    bar_bg.body.radius         = LV_RADIUS_CIRCLE;
 802601a:	4b35      	ldr	r3, [pc, #212]	; (80260f0 <bar_init+0xe8>)
 802601c:	f647 4218 	movw	r2, #31768	; 0x7c18
 8026020:	80da      	strh	r2, [r3, #6]
    bar_bg.body.main_color     = LV_COLOR_WHITE;
 8026022:	4a33      	ldr	r2, [pc, #204]	; (80260f0 <bar_init+0xe8>)
 8026024:	4b33      	ldr	r3, [pc, #204]	; (80260f4 <bar_init+0xec>)
 8026026:	881b      	ldrh	r3, [r3, #0]
 8026028:	8053      	strh	r3, [r2, #2]
    bar_bg.body.grad_color     = LV_COLOR_SILVER;
 802602a:	4a31      	ldr	r2, [pc, #196]	; (80260f0 <bar_init+0xe8>)
 802602c:	4b32      	ldr	r3, [pc, #200]	; (80260f8 <bar_init+0xf0>)
 802602e:	881b      	ldrh	r3, [r3, #0]
 8026030:	8093      	strh	r3, [r2, #4]
    bar_bg.body.border.width   = 2;
 8026032:	4b2f      	ldr	r3, [pc, #188]	; (80260f0 <bar_init+0xe8>)
 8026034:	2202      	movs	r2, #2
 8026036:	819a      	strh	r2, [r3, #12]
    bar_bg.body.border.color   = LV_COLOR_SILVER;
 8026038:	4a2d      	ldr	r2, [pc, #180]	; (80260f0 <bar_init+0xe8>)
 802603a:	4b2f      	ldr	r3, [pc, #188]	; (80260f8 <bar_init+0xf0>)
 802603c:	881b      	ldrh	r3, [r3, #0]
 802603e:	8153      	strh	r3, [r2, #10]
    bar_bg.body.border.opa     = LV_OPA_20;
 8026040:	4b2b      	ldr	r3, [pc, #172]	; (80260f0 <bar_init+0xe8>)
 8026042:	2233      	movs	r2, #51	; 0x33
 8026044:	73da      	strb	r2, [r3, #15]
    bar_bg.body.padding.left   = 0;
 8026046:	4b2a      	ldr	r3, [pc, #168]	; (80260f0 <bar_init+0xe8>)
 8026048:	2200      	movs	r2, #0
 802604a:	835a      	strh	r2, [r3, #26]
    bar_bg.body.padding.right  = 0;
 802604c:	4b28      	ldr	r3, [pc, #160]	; (80260f0 <bar_init+0xe8>)
 802604e:	2200      	movs	r2, #0
 8026050:	839a      	strh	r2, [r3, #28]
    bar_bg.body.padding.top    = LV_DPI / 10;
 8026052:	4b27      	ldr	r3, [pc, #156]	; (80260f0 <bar_init+0xe8>)
 8026054:	220a      	movs	r2, #10
 8026056:	82da      	strh	r2, [r3, #22]
    bar_bg.body.padding.bottom = LV_DPI / 10;
 8026058:	4b25      	ldr	r3, [pc, #148]	; (80260f0 <bar_init+0xe8>)
 802605a:	220a      	movs	r2, #10
 802605c:	831a      	strh	r2, [r3, #24]
    bar_bg.body.padding.inner  = 0;
 802605e:	4b24      	ldr	r3, [pc, #144]	; (80260f0 <bar_init+0xe8>)
 8026060:	2200      	movs	r2, #0
 8026062:	83da      	strh	r2, [r3, #30]

    lv_style_copy(&bar_indic, &def);
 8026064:	4921      	ldr	r1, [pc, #132]	; (80260ec <bar_init+0xe4>)
 8026066:	4825      	ldr	r0, [pc, #148]	; (80260fc <bar_init+0xf4>)
 8026068:	f7ed fcfc 	bl	8013a64 <lv_style_copy>
    bar_indic.body.radius         = LV_RADIUS_CIRCLE;
 802606c:	4b23      	ldr	r3, [pc, #140]	; (80260fc <bar_init+0xf4>)
 802606e:	f647 4218 	movw	r2, #31768	; 0x7c18
 8026072:	80da      	strh	r2, [r3, #6]
    bar_indic.body.border.width   = 2;
 8026074:	4b21      	ldr	r3, [pc, #132]	; (80260fc <bar_init+0xf4>)
 8026076:	2202      	movs	r2, #2
 8026078:	819a      	strh	r2, [r3, #12]
    bar_indic.body.border.color   = LV_COLOR_SILVER;
 802607a:	4a20      	ldr	r2, [pc, #128]	; (80260fc <bar_init+0xf4>)
 802607c:	4b1e      	ldr	r3, [pc, #120]	; (80260f8 <bar_init+0xf0>)
 802607e:	881b      	ldrh	r3, [r3, #0]
 8026080:	8153      	strh	r3, [r2, #10]
    bar_indic.body.border.opa     = LV_OPA_70;
 8026082:	4b1e      	ldr	r3, [pc, #120]	; (80260fc <bar_init+0xf4>)
 8026084:	22b2      	movs	r2, #178	; 0xb2
 8026086:	73da      	strb	r2, [r3, #15]
    bar_indic.body.padding.left   = 0;
 8026088:	4b1c      	ldr	r3, [pc, #112]	; (80260fc <bar_init+0xf4>)
 802608a:	2200      	movs	r2, #0
 802608c:	835a      	strh	r2, [r3, #26]
    bar_indic.body.padding.right  = 0;
 802608e:	4b1b      	ldr	r3, [pc, #108]	; (80260fc <bar_init+0xf4>)
 8026090:	2200      	movs	r2, #0
 8026092:	839a      	strh	r2, [r3, #28]
    bar_indic.body.padding.top    = 0;
 8026094:	4b19      	ldr	r3, [pc, #100]	; (80260fc <bar_init+0xf4>)
 8026096:	2200      	movs	r2, #0
 8026098:	82da      	strh	r2, [r3, #22]
    bar_indic.body.padding.bottom = 0;
 802609a:	4b18      	ldr	r3, [pc, #96]	; (80260fc <bar_init+0xf4>)
 802609c:	2200      	movs	r2, #0
 802609e:	831a      	strh	r2, [r3, #24]
    bar_indic.body.shadow.width   = LV_DPI / 20;
 80260a0:	4b16      	ldr	r3, [pc, #88]	; (80260fc <bar_init+0xf4>)
 80260a2:	2205      	movs	r2, #5
 80260a4:	825a      	strh	r2, [r3, #18]
    bar_indic.body.shadow.color   = lv_color_hsv_to_rgb(_hue, 20, 90);
 80260a6:	4b16      	ldr	r3, [pc, #88]	; (8026100 <bar_init+0xf8>)
 80260a8:	881b      	ldrh	r3, [r3, #0]
 80260aa:	4c14      	ldr	r4, [pc, #80]	; (80260fc <bar_init+0xf4>)
 80260ac:	225a      	movs	r2, #90	; 0x5a
 80260ae:	2114      	movs	r1, #20
 80260b0:	4618      	mov	r0, r3
 80260b2:	f7f5 fed3 	bl	801be5c <lv_color_hsv_to_rgb>
 80260b6:	8220      	strh	r0, [r4, #16]
    bar_indic.body.main_color     = lv_color_hsv_to_rgb(_hue, 40, 80);
 80260b8:	4b11      	ldr	r3, [pc, #68]	; (8026100 <bar_init+0xf8>)
 80260ba:	881b      	ldrh	r3, [r3, #0]
 80260bc:	4c0f      	ldr	r4, [pc, #60]	; (80260fc <bar_init+0xf4>)
 80260be:	2250      	movs	r2, #80	; 0x50
 80260c0:	2128      	movs	r1, #40	; 0x28
 80260c2:	4618      	mov	r0, r3
 80260c4:	f7f5 feca 	bl	801be5c <lv_color_hsv_to_rgb>
 80260c8:	8060      	strh	r0, [r4, #2]
    bar_indic.body.grad_color     = lv_color_hsv_to_rgb(_hue, 40, 80);
 80260ca:	4b0d      	ldr	r3, [pc, #52]	; (8026100 <bar_init+0xf8>)
 80260cc:	881b      	ldrh	r3, [r3, #0]
 80260ce:	4c0b      	ldr	r4, [pc, #44]	; (80260fc <bar_init+0xf4>)
 80260d0:	2250      	movs	r2, #80	; 0x50
 80260d2:	2128      	movs	r1, #40	; 0x28
 80260d4:	4618      	mov	r0, r3
 80260d6:	f7f5 fec1 	bl	801be5c <lv_color_hsv_to_rgb>
 80260da:	80a0      	strh	r0, [r4, #4]

    theme.style.bar.bg    = &bar_bg;
 80260dc:	4b09      	ldr	r3, [pc, #36]	; (8026104 <bar_init+0xfc>)
 80260de:	4a04      	ldr	r2, [pc, #16]	; (80260f0 <bar_init+0xe8>)
 80260e0:	655a      	str	r2, [r3, #84]	; 0x54
    theme.style.bar.indic = &bar_indic;
 80260e2:	4b08      	ldr	r3, [pc, #32]	; (8026104 <bar_init+0xfc>)
 80260e4:	4a05      	ldr	r2, [pc, #20]	; (80260fc <bar_init+0xf4>)
 80260e6:	659a      	str	r2, [r3, #88]	; 0x58
#endif
}
 80260e8:	bf00      	nop
 80260ea:	bd98      	pop	{r3, r4, r7, pc}
 80260ec:	2000c5b0 	.word	0x2000c5b0
 80260f0:	2000c808 	.word	0x2000c808
 80260f4:	0802913c 	.word	0x0802913c
 80260f8:	08029138 	.word	0x08029138
 80260fc:	2000c844 	.word	0x2000c844
 8026100:	2000c3f4 	.word	0x2000c3f4
 8026104:	2000c3fc 	.word	0x2000c3fc

08026108 <img_init>:

static void img_init(void)
{
 8026108:	b598      	push	{r3, r4, r7, lr}
 802610a:	af00      	add	r7, sp, #0
#if LV_USE_IMG != 0
    static lv_style_t img_light, img_dark;
    lv_style_copy(&img_light, &def);
 802610c:	4914      	ldr	r1, [pc, #80]	; (8026160 <img_init+0x58>)
 802610e:	4815      	ldr	r0, [pc, #84]	; (8026164 <img_init+0x5c>)
 8026110:	f7ed fca8 	bl	8013a64 <lv_style_copy>
    img_light.image.color   = lv_color_hsv_to_rgb(_hue, 15, 85);
 8026114:	4b14      	ldr	r3, [pc, #80]	; (8026168 <img_init+0x60>)
 8026116:	881b      	ldrh	r3, [r3, #0]
 8026118:	4c12      	ldr	r4, [pc, #72]	; (8026164 <img_init+0x5c>)
 802611a:	2255      	movs	r2, #85	; 0x55
 802611c:	210f      	movs	r1, #15
 802611e:	4618      	mov	r0, r3
 8026120:	f7f5 fe9c 	bl	801be5c <lv_color_hsv_to_rgb>
 8026124:	8620      	strh	r0, [r4, #48]	; 0x30
    img_light.image.intense = LV_OPA_80;
 8026126:	4b0f      	ldr	r3, [pc, #60]	; (8026164 <img_init+0x5c>)
 8026128:	22cc      	movs	r2, #204	; 0xcc
 802612a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

    lv_style_copy(&img_dark, &def);
 802612e:	490c      	ldr	r1, [pc, #48]	; (8026160 <img_init+0x58>)
 8026130:	480e      	ldr	r0, [pc, #56]	; (802616c <img_init+0x64>)
 8026132:	f7ed fc97 	bl	8013a64 <lv_style_copy>
    img_light.image.color   = lv_color_hsv_to_rgb(_hue, 85, 65);
 8026136:	4b0c      	ldr	r3, [pc, #48]	; (8026168 <img_init+0x60>)
 8026138:	881b      	ldrh	r3, [r3, #0]
 802613a:	4c0a      	ldr	r4, [pc, #40]	; (8026164 <img_init+0x5c>)
 802613c:	2241      	movs	r2, #65	; 0x41
 802613e:	2155      	movs	r1, #85	; 0x55
 8026140:	4618      	mov	r0, r3
 8026142:	f7f5 fe8b 	bl	801be5c <lv_color_hsv_to_rgb>
 8026146:	8620      	strh	r0, [r4, #48]	; 0x30
    img_light.image.intense = LV_OPA_80;
 8026148:	4b06      	ldr	r3, [pc, #24]	; (8026164 <img_init+0x5c>)
 802614a:	22cc      	movs	r2, #204	; 0xcc
 802614c:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32

    theme.style.img.light = &img_light;
 8026150:	4b07      	ldr	r3, [pc, #28]	; (8026170 <img_init+0x68>)
 8026152:	4a04      	ldr	r2, [pc, #16]	; (8026164 <img_init+0x5c>)
 8026154:	645a      	str	r2, [r3, #68]	; 0x44
    theme.style.img.dark  = &img_dark;
 8026156:	4b06      	ldr	r3, [pc, #24]	; (8026170 <img_init+0x68>)
 8026158:	4a04      	ldr	r2, [pc, #16]	; (802616c <img_init+0x64>)
 802615a:	649a      	str	r2, [r3, #72]	; 0x48
#endif
}
 802615c:	bf00      	nop
 802615e:	bd98      	pop	{r3, r4, r7, pc}
 8026160:	2000c5b0 	.word	0x2000c5b0
 8026164:	2000cb50 	.word	0x2000cb50
 8026168:	2000c3f4 	.word	0x2000c3f4
 802616c:	2000cb8c 	.word	0x2000cb8c
 8026170:	2000c3fc 	.word	0x2000c3fc

08026174 <line_init>:

static void line_init(void)
{
 8026174:	b598      	push	{r3, r4, r7, lr}
 8026176:	af00      	add	r7, sp, #0
#if LV_USE_LINE != 0
    static lv_style_t line_decor;
    lv_style_copy(&line_decor, &def);
 8026178:	490a      	ldr	r1, [pc, #40]	; (80261a4 <line_init+0x30>)
 802617a:	480b      	ldr	r0, [pc, #44]	; (80261a8 <line_init+0x34>)
 802617c:	f7ed fc72 	bl	8013a64 <lv_style_copy>
    line_decor.line.color = lv_color_hsv_to_rgb(_hue, 50, 50);
 8026180:	4b0a      	ldr	r3, [pc, #40]	; (80261ac <line_init+0x38>)
 8026182:	881b      	ldrh	r3, [r3, #0]
 8026184:	4c08      	ldr	r4, [pc, #32]	; (80261a8 <line_init+0x34>)
 8026186:	2232      	movs	r2, #50	; 0x32
 8026188:	2132      	movs	r1, #50	; 0x32
 802618a:	4618      	mov	r0, r3
 802618c:	f7f5 fe66 	bl	801be5c <lv_color_hsv_to_rgb>
 8026190:	86a0      	strh	r0, [r4, #52]	; 0x34
    line_decor.line.width = 1;
 8026192:	4b05      	ldr	r3, [pc, #20]	; (80261a8 <line_init+0x34>)
 8026194:	2201      	movs	r2, #1
 8026196:	86da      	strh	r2, [r3, #54]	; 0x36

    theme.style.line.decor = &line_decor;
 8026198:	4b05      	ldr	r3, [pc, #20]	; (80261b0 <line_init+0x3c>)
 802619a:	4a03      	ldr	r2, [pc, #12]	; (80261a8 <line_init+0x34>)
 802619c:	64da      	str	r2, [r3, #76]	; 0x4c
#endif
}
 802619e:	bf00      	nop
 80261a0:	bd98      	pop	{r3, r4, r7, pc}
 80261a2:	bf00      	nop
 80261a4:	2000c5b0 	.word	0x2000c5b0
 80261a8:	2000cbc8 	.word	0x2000cbc8
 80261ac:	2000c3f4 	.word	0x2000c3f4
 80261b0:	2000c3fc 	.word	0x2000c3fc

080261b4 <led_init>:

static void led_init(void)
{
 80261b4:	b598      	push	{r3, r4, r7, lr}
 80261b6:	af00      	add	r7, sp, #0
#if LV_USE_LED != 0
    static lv_style_t led;
    lv_style_copy(&led, &lv_style_pretty_color);
 80261b8:	491c      	ldr	r1, [pc, #112]	; (802622c <led_init+0x78>)
 80261ba:	481d      	ldr	r0, [pc, #116]	; (8026230 <led_init+0x7c>)
 80261bc:	f7ed fc52 	bl	8013a64 <lv_style_copy>
    led.body.shadow.width = LV_DPI / 10;
 80261c0:	4b1b      	ldr	r3, [pc, #108]	; (8026230 <led_init+0x7c>)
 80261c2:	220a      	movs	r2, #10
 80261c4:	825a      	strh	r2, [r3, #18]
    led.body.radius       = LV_RADIUS_CIRCLE;
 80261c6:	4b1a      	ldr	r3, [pc, #104]	; (8026230 <led_init+0x7c>)
 80261c8:	f647 4218 	movw	r2, #31768	; 0x7c18
 80261cc:	80da      	strh	r2, [r3, #6]
    led.body.border.width = LV_DPI / 30;
 80261ce:	4b18      	ldr	r3, [pc, #96]	; (8026230 <led_init+0x7c>)
 80261d0:	2203      	movs	r2, #3
 80261d2:	819a      	strh	r2, [r3, #12]
    led.body.border.opa   = LV_OPA_30;
 80261d4:	4b16      	ldr	r3, [pc, #88]	; (8026230 <led_init+0x7c>)
 80261d6:	224c      	movs	r2, #76	; 0x4c
 80261d8:	73da      	strb	r2, [r3, #15]
    led.body.main_color   = lv_color_hsv_to_rgb(_hue, 100, 100);
 80261da:	4b16      	ldr	r3, [pc, #88]	; (8026234 <led_init+0x80>)
 80261dc:	881b      	ldrh	r3, [r3, #0]
 80261de:	4c14      	ldr	r4, [pc, #80]	; (8026230 <led_init+0x7c>)
 80261e0:	2264      	movs	r2, #100	; 0x64
 80261e2:	2164      	movs	r1, #100	; 0x64
 80261e4:	4618      	mov	r0, r3
 80261e6:	f7f5 fe39 	bl	801be5c <lv_color_hsv_to_rgb>
 80261ea:	8060      	strh	r0, [r4, #2]
    led.body.grad_color   = lv_color_hsv_to_rgb(_hue, 100, 40);
 80261ec:	4b11      	ldr	r3, [pc, #68]	; (8026234 <led_init+0x80>)
 80261ee:	881b      	ldrh	r3, [r3, #0]
 80261f0:	4c0f      	ldr	r4, [pc, #60]	; (8026230 <led_init+0x7c>)
 80261f2:	2228      	movs	r2, #40	; 0x28
 80261f4:	2164      	movs	r1, #100	; 0x64
 80261f6:	4618      	mov	r0, r3
 80261f8:	f7f5 fe30 	bl	801be5c <lv_color_hsv_to_rgb>
 80261fc:	80a0      	strh	r0, [r4, #4]
    led.body.border.color = lv_color_hsv_to_rgb(_hue, 60, 60);
 80261fe:	4b0d      	ldr	r3, [pc, #52]	; (8026234 <led_init+0x80>)
 8026200:	881b      	ldrh	r3, [r3, #0]
 8026202:	4c0b      	ldr	r4, [pc, #44]	; (8026230 <led_init+0x7c>)
 8026204:	223c      	movs	r2, #60	; 0x3c
 8026206:	213c      	movs	r1, #60	; 0x3c
 8026208:	4618      	mov	r0, r3
 802620a:	f7f5 fe27 	bl	801be5c <lv_color_hsv_to_rgb>
 802620e:	8160      	strh	r0, [r4, #10]
    led.body.shadow.color = lv_color_hsv_to_rgb(_hue, 100, 100);
 8026210:	4b08      	ldr	r3, [pc, #32]	; (8026234 <led_init+0x80>)
 8026212:	881b      	ldrh	r3, [r3, #0]
 8026214:	4c06      	ldr	r4, [pc, #24]	; (8026230 <led_init+0x7c>)
 8026216:	2264      	movs	r2, #100	; 0x64
 8026218:	2164      	movs	r1, #100	; 0x64
 802621a:	4618      	mov	r0, r3
 802621c:	f7f5 fe1e 	bl	801be5c <lv_color_hsv_to_rgb>
 8026220:	8220      	strh	r0, [r4, #16]

    theme.style.led = &led;
 8026222:	4b05      	ldr	r3, [pc, #20]	; (8026238 <led_init+0x84>)
 8026224:	4a02      	ldr	r2, [pc, #8]	; (8026230 <led_init+0x7c>)
 8026226:	651a      	str	r2, [r3, #80]	; 0x50
#endif
}
 8026228:	bf00      	nop
 802622a:	bd98      	pop	{r3, r4, r7, pc}
 802622c:	2000dc38 	.word	0x2000dc38
 8026230:	2000cc04 	.word	0x2000cc04
 8026234:	2000c3f4 	.word	0x2000c3f4
 8026238:	2000c3fc 	.word	0x2000c3fc

0802623c <slider_init>:

static void slider_init(void)
{
 802623c:	b580      	push	{r7, lr}
 802623e:	af00      	add	r7, sp, #0
#if LV_USE_SLIDER != 0
    lv_style_copy(&slider_knob, &def);
 8026240:	4920      	ldr	r1, [pc, #128]	; (80262c4 <slider_init+0x88>)
 8026242:	4821      	ldr	r0, [pc, #132]	; (80262c8 <slider_init+0x8c>)
 8026244:	f7ed fc0e 	bl	8013a64 <lv_style_copy>
    slider_knob.body.opa          = LV_OPA_60;
 8026248:	4b1f      	ldr	r3, [pc, #124]	; (80262c8 <slider_init+0x8c>)
 802624a:	2299      	movs	r2, #153	; 0x99
 802624c:	721a      	strb	r2, [r3, #8]
    slider_knob.body.radius       = LV_RADIUS_CIRCLE;
 802624e:	4b1e      	ldr	r3, [pc, #120]	; (80262c8 <slider_init+0x8c>)
 8026250:	f647 4218 	movw	r2, #31768	; 0x7c18
 8026254:	80da      	strh	r2, [r3, #6]
    slider_knob.body.main_color   = LV_COLOR_PURPLE;
 8026256:	4a1c      	ldr	r2, [pc, #112]	; (80262c8 <slider_init+0x8c>)
 8026258:	7893      	ldrb	r3, [r2, #2]
 802625a:	2110      	movs	r1, #16
 802625c:	f361 0304 	bfi	r3, r1, #0, #5
 8026260:	7093      	strb	r3, [r2, #2]
 8026262:	4a19      	ldr	r2, [pc, #100]	; (80262c8 <slider_init+0x8c>)
 8026264:	8853      	ldrh	r3, [r2, #2]
 8026266:	f36f 134a 	bfc	r3, #5, #6
 802626a:	8053      	strh	r3, [r2, #2]
 802626c:	4a16      	ldr	r2, [pc, #88]	; (80262c8 <slider_init+0x8c>)
 802626e:	78d3      	ldrb	r3, [r2, #3]
 8026270:	2110      	movs	r1, #16
 8026272:	f361 03c7 	bfi	r3, r1, #3, #5
 8026276:	70d3      	strb	r3, [r2, #3]
    slider_knob.body.grad_color   = LV_COLOR_SILVER;
 8026278:	4a13      	ldr	r2, [pc, #76]	; (80262c8 <slider_init+0x8c>)
 802627a:	4b14      	ldr	r3, [pc, #80]	; (80262cc <slider_init+0x90>)
 802627c:	881b      	ldrh	r3, [r3, #0]
 802627e:	8093      	strh	r3, [r2, #4]
    slider_knob.body.border.width = 2;
 8026280:	4b11      	ldr	r3, [pc, #68]	; (80262c8 <slider_init+0x8c>)
 8026282:	2202      	movs	r2, #2
 8026284:	819a      	strh	r2, [r3, #12]
    slider_knob.body.border.color = LV_COLOR_ORANGE;
 8026286:	4a10      	ldr	r2, [pc, #64]	; (80262c8 <slider_init+0x8c>)
 8026288:	7a93      	ldrb	r3, [r2, #10]
 802628a:	f36f 0304 	bfc	r3, #0, #5
 802628e:	7293      	strb	r3, [r2, #10]
 8026290:	4a0d      	ldr	r2, [pc, #52]	; (80262c8 <slider_init+0x8c>)
 8026292:	8953      	ldrh	r3, [r2, #10]
 8026294:	2129      	movs	r1, #41	; 0x29
 8026296:	f361 134a 	bfi	r3, r1, #5, #6
 802629a:	8153      	strh	r3, [r2, #10]
 802629c:	4a0a      	ldr	r2, [pc, #40]	; (80262c8 <slider_init+0x8c>)
 802629e:	7ad3      	ldrb	r3, [r2, #11]
 80262a0:	f043 03f8 	orr.w	r3, r3, #248	; 0xf8
 80262a4:	72d3      	strb	r3, [r2, #11]
    slider_knob.body.border.opa   = LV_OPA_50;
 80262a6:	4b08      	ldr	r3, [pc, #32]	; (80262c8 <slider_init+0x8c>)
 80262a8:	227f      	movs	r2, #127	; 0x7f
 80262aa:	73da      	strb	r2, [r3, #15]

    theme.style.slider.bg    = &bar_bg;
 80262ac:	4b08      	ldr	r3, [pc, #32]	; (80262d0 <slider_init+0x94>)
 80262ae:	4a09      	ldr	r2, [pc, #36]	; (80262d4 <slider_init+0x98>)
 80262b0:	65da      	str	r2, [r3, #92]	; 0x5c
    theme.style.slider.indic = &bar_indic;
 80262b2:	4b07      	ldr	r3, [pc, #28]	; (80262d0 <slider_init+0x94>)
 80262b4:	4a08      	ldr	r2, [pc, #32]	; (80262d8 <slider_init+0x9c>)
 80262b6:	661a      	str	r2, [r3, #96]	; 0x60
    theme.style.slider.knob  = &slider_knob;
 80262b8:	4b05      	ldr	r3, [pc, #20]	; (80262d0 <slider_init+0x94>)
 80262ba:	4a03      	ldr	r2, [pc, #12]	; (80262c8 <slider_init+0x8c>)
 80262bc:	665a      	str	r2, [r3, #100]	; 0x64
#endif
}
 80262be:	bf00      	nop
 80262c0:	bd80      	pop	{r7, pc}
 80262c2:	bf00      	nop
 80262c4:	2000c5b0 	.word	0x2000c5b0
 80262c8:	2000c880 	.word	0x2000c880
 80262cc:	08029138 	.word	0x08029138
 80262d0:	2000c3fc 	.word	0x2000c3fc
 80262d4:	2000c808 	.word	0x2000c808
 80262d8:	2000c844 	.word	0x2000c844

080262dc <sw_init>:

static void sw_init(void)
{
 80262dc:	b598      	push	{r3, r4, r7, lr}
 80262de:	af00      	add	r7, sp, #0
#if LV_USE_SW != 0
    static lv_style_t sw_bg, sw_indic, sw_knob;
    lv_style_copy(&sw_bg, &bar_bg);
 80262e0:	4926      	ldr	r1, [pc, #152]	; (802637c <sw_init+0xa0>)
 80262e2:	4827      	ldr	r0, [pc, #156]	; (8026380 <sw_init+0xa4>)
 80262e4:	f7ed fbbe 	bl	8013a64 <lv_style_copy>
    sw_bg.body.opa            = LV_OPA_COVER;
 80262e8:	4b25      	ldr	r3, [pc, #148]	; (8026380 <sw_init+0xa4>)
 80262ea:	22ff      	movs	r2, #255	; 0xff
 80262ec:	721a      	strb	r2, [r3, #8]
    sw_bg.body.padding.left   = -2;
 80262ee:	4b24      	ldr	r3, [pc, #144]	; (8026380 <sw_init+0xa4>)
 80262f0:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 80262f4:	835a      	strh	r2, [r3, #26]
    sw_bg.body.padding.right  = -2;
 80262f6:	4b22      	ldr	r3, [pc, #136]	; (8026380 <sw_init+0xa4>)
 80262f8:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 80262fc:	839a      	strh	r2, [r3, #28]
    sw_bg.body.padding.top    = -2;
 80262fe:	4b20      	ldr	r3, [pc, #128]	; (8026380 <sw_init+0xa4>)
 8026300:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8026304:	82da      	strh	r2, [r3, #22]
    sw_bg.body.padding.bottom = -2;
 8026306:	4b1e      	ldr	r3, [pc, #120]	; (8026380 <sw_init+0xa4>)
 8026308:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 802630c:	831a      	strh	r2, [r3, #24]
    sw_bg.body.main_color     = lv_color_hex3(0x000);
 802630e:	4c1c      	ldr	r4, [pc, #112]	; (8026380 <sw_init+0xa4>)
 8026310:	2000      	movs	r0, #0
 8026312:	f7ff fbe8 	bl	8025ae6 <lv_color_hex3>
 8026316:	8060      	strh	r0, [r4, #2]
    sw_bg.body.border.width   = 2;
 8026318:	4b19      	ldr	r3, [pc, #100]	; (8026380 <sw_init+0xa4>)
 802631a:	2202      	movs	r2, #2
 802631c:	819a      	strh	r2, [r3, #12]
    sw_bg.body.border.opa     = LV_OPA_50;
 802631e:	4b18      	ldr	r3, [pc, #96]	; (8026380 <sw_init+0xa4>)
 8026320:	227f      	movs	r2, #127	; 0x7f
 8026322:	73da      	strb	r2, [r3, #15]

    lv_style_copy(&sw_indic, &bar_indic);
 8026324:	4917      	ldr	r1, [pc, #92]	; (8026384 <sw_init+0xa8>)
 8026326:	4818      	ldr	r0, [pc, #96]	; (8026388 <sw_init+0xac>)
 8026328:	f7ed fb9c 	bl	8013a64 <lv_style_copy>
    sw_indic.body.shadow.width   = LV_DPI / 20;
 802632c:	4b16      	ldr	r3, [pc, #88]	; (8026388 <sw_init+0xac>)
 802632e:	2205      	movs	r2, #5
 8026330:	825a      	strh	r2, [r3, #18]
    sw_indic.body.padding.left   = 0;
 8026332:	4b15      	ldr	r3, [pc, #84]	; (8026388 <sw_init+0xac>)
 8026334:	2200      	movs	r2, #0
 8026336:	835a      	strh	r2, [r3, #26]
    sw_indic.body.padding.right  = 0;
 8026338:	4b13      	ldr	r3, [pc, #76]	; (8026388 <sw_init+0xac>)
 802633a:	2200      	movs	r2, #0
 802633c:	839a      	strh	r2, [r3, #28]
    sw_indic.body.padding.top    = 0;
 802633e:	4b12      	ldr	r3, [pc, #72]	; (8026388 <sw_init+0xac>)
 8026340:	2200      	movs	r2, #0
 8026342:	82da      	strh	r2, [r3, #22]
    sw_indic.body.padding.bottom = 0;
 8026344:	4b10      	ldr	r3, [pc, #64]	; (8026388 <sw_init+0xac>)
 8026346:	2200      	movs	r2, #0
 8026348:	831a      	strh	r2, [r3, #24]

    lv_style_copy(&sw_knob, &slider_knob);
 802634a:	4910      	ldr	r1, [pc, #64]	; (802638c <sw_init+0xb0>)
 802634c:	4810      	ldr	r0, [pc, #64]	; (8026390 <sw_init+0xb4>)
 802634e:	f7ed fb89 	bl	8013a64 <lv_style_copy>
    sw_knob.body.opa = LV_OPA_80;
 8026352:	4b0f      	ldr	r3, [pc, #60]	; (8026390 <sw_init+0xb4>)
 8026354:	22cc      	movs	r2, #204	; 0xcc
 8026356:	721a      	strb	r2, [r3, #8]

    theme.style.sw.bg       = &sw_bg;
 8026358:	4b0e      	ldr	r3, [pc, #56]	; (8026394 <sw_init+0xb8>)
 802635a:	4a09      	ldr	r2, [pc, #36]	; (8026380 <sw_init+0xa4>)
 802635c:	67da      	str	r2, [r3, #124]	; 0x7c
    theme.style.sw.indic    = &sw_indic;
 802635e:	4b0d      	ldr	r3, [pc, #52]	; (8026394 <sw_init+0xb8>)
 8026360:	4a09      	ldr	r2, [pc, #36]	; (8026388 <sw_init+0xac>)
 8026362:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    theme.style.sw.knob_off = &sw_knob;
 8026366:	4b0b      	ldr	r3, [pc, #44]	; (8026394 <sw_init+0xb8>)
 8026368:	4a09      	ldr	r2, [pc, #36]	; (8026390 <sw_init+0xb4>)
 802636a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    theme.style.sw.knob_on  = &sw_knob;
 802636e:	4b09      	ldr	r3, [pc, #36]	; (8026394 <sw_init+0xb8>)
 8026370:	4a07      	ldr	r2, [pc, #28]	; (8026390 <sw_init+0xb4>)
 8026372:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
#endif
}
 8026376:	bf00      	nop
 8026378:	bd98      	pop	{r3, r4, r7, pc}
 802637a:	bf00      	nop
 802637c:	2000c808 	.word	0x2000c808
 8026380:	2000cc40 	.word	0x2000cc40
 8026384:	2000c844 	.word	0x2000c844
 8026388:	2000cc7c 	.word	0x2000cc7c
 802638c:	2000c880 	.word	0x2000c880
 8026390:	2000ccb8 	.word	0x2000ccb8
 8026394:	2000c3fc 	.word	0x2000c3fc

08026398 <lmeter_init>:

static void lmeter_init(void)
{
 8026398:	b598      	push	{r3, r4, r7, lr}
 802639a:	af00      	add	r7, sp, #0
#if LV_USE_LMETER != 0
    lv_style_copy(&lmeter_bg, &def);
 802639c:	490e      	ldr	r1, [pc, #56]	; (80263d8 <lmeter_init+0x40>)
 802639e:	480f      	ldr	r0, [pc, #60]	; (80263dc <lmeter_init+0x44>)
 80263a0:	f7ed fb60 	bl	8013a64 <lv_style_copy>
    lmeter_bg.body.main_color   = lv_color_hsv_to_rgb(_hue, 10, 70);
 80263a4:	4b0e      	ldr	r3, [pc, #56]	; (80263e0 <lmeter_init+0x48>)
 80263a6:	881b      	ldrh	r3, [r3, #0]
 80263a8:	4c0c      	ldr	r4, [pc, #48]	; (80263dc <lmeter_init+0x44>)
 80263aa:	2246      	movs	r2, #70	; 0x46
 80263ac:	210a      	movs	r1, #10
 80263ae:	4618      	mov	r0, r3
 80263b0:	f7f5 fd54 	bl	801be5c <lv_color_hsv_to_rgb>
 80263b4:	8060      	strh	r0, [r4, #2]
    lmeter_bg.body.padding.left = LV_DPI / 8; /*Scale line length*/
 80263b6:	4b09      	ldr	r3, [pc, #36]	; (80263dc <lmeter_init+0x44>)
 80263b8:	220c      	movs	r2, #12
 80263ba:	835a      	strh	r2, [r3, #26]
    lmeter_bg.line.color        = lv_color_hex3(0x500);
 80263bc:	4c07      	ldr	r4, [pc, #28]	; (80263dc <lmeter_init+0x44>)
 80263be:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 80263c2:	f7ff fb90 	bl	8025ae6 <lv_color_hex3>
 80263c6:	86a0      	strh	r0, [r4, #52]	; 0x34
    lmeter_bg.line.width        = 2;
 80263c8:	4b04      	ldr	r3, [pc, #16]	; (80263dc <lmeter_init+0x44>)
 80263ca:	2202      	movs	r2, #2
 80263cc:	86da      	strh	r2, [r3, #54]	; 0x36

    theme.style.lmeter = &lmeter_bg;
 80263ce:	4b05      	ldr	r3, [pc, #20]	; (80263e4 <lmeter_init+0x4c>)
 80263d0:	4a02      	ldr	r2, [pc, #8]	; (80263dc <lmeter_init+0x44>)
 80263d2:	669a      	str	r2, [r3, #104]	; 0x68

#endif
}
 80263d4:	bf00      	nop
 80263d6:	bd98      	pop	{r3, r4, r7, pc}
 80263d8:	2000c5b0 	.word	0x2000c5b0
 80263dc:	2000c8bc 	.word	0x2000c8bc
 80263e0:	2000c3f4 	.word	0x2000c3f4
 80263e4:	2000c3fc 	.word	0x2000c3fc

080263e8 <gauge_init>:

static void gauge_init(void)
{
 80263e8:	b598      	push	{r3, r4, r7, lr}
 80263ea:	af00      	add	r7, sp, #0
#if LV_USE_GAUGE != 0
    static lv_style_t gauge_bg;
    lv_style_copy(&gauge_bg, &def);
 80263ec:	491f      	ldr	r1, [pc, #124]	; (802646c <gauge_init+0x84>)
 80263ee:	4820      	ldr	r0, [pc, #128]	; (8026470 <gauge_init+0x88>)
 80263f0:	f7ed fb38 	bl	8013a64 <lv_style_copy>
    gauge_bg.body.main_color     = lv_color_hsv_to_rgb(_hue, 20, 100);
 80263f4:	4b1f      	ldr	r3, [pc, #124]	; (8026474 <gauge_init+0x8c>)
 80263f6:	881b      	ldrh	r3, [r3, #0]
 80263f8:	4c1d      	ldr	r4, [pc, #116]	; (8026470 <gauge_init+0x88>)
 80263fa:	2264      	movs	r2, #100	; 0x64
 80263fc:	2114      	movs	r1, #20
 80263fe:	4618      	mov	r0, r3
 8026400:	f7f5 fd2c 	bl	801be5c <lv_color_hsv_to_rgb>
 8026404:	8060      	strh	r0, [r4, #2]
    gauge_bg.body.padding.left   = LV_DPI / 16; /*Scale line length*/
 8026406:	4b1a      	ldr	r3, [pc, #104]	; (8026470 <gauge_init+0x88>)
 8026408:	2206      	movs	r2, #6
 802640a:	835a      	strh	r2, [r3, #26]
    gauge_bg.body.padding.right  = LV_DPI / 16; /*Scale line length*/
 802640c:	4b18      	ldr	r3, [pc, #96]	; (8026470 <gauge_init+0x88>)
 802640e:	2206      	movs	r2, #6
 8026410:	839a      	strh	r2, [r3, #28]
    gauge_bg.body.padding.top    = LV_DPI / 20; /*Needle center size*/
 8026412:	4b17      	ldr	r3, [pc, #92]	; (8026470 <gauge_init+0x88>)
 8026414:	2205      	movs	r2, #5
 8026416:	82da      	strh	r2, [r3, #22]
    gauge_bg.body.padding.bottom = LV_DPI / 20; /*Needle center size*/
 8026418:	4b15      	ldr	r3, [pc, #84]	; (8026470 <gauge_init+0x88>)
 802641a:	2205      	movs	r2, #5
 802641c:	831a      	strh	r2, [r3, #24]
    gauge_bg.body.padding.inner  = LV_DPI / 12; /*Label - scale distance*/
 802641e:	4b14      	ldr	r3, [pc, #80]	; (8026470 <gauge_init+0x88>)
 8026420:	2208      	movs	r2, #8
 8026422:	83da      	strh	r2, [r3, #30]
    gauge_bg.body.border.color   = lv_color_hex3(0x500);
 8026424:	4c12      	ldr	r4, [pc, #72]	; (8026470 <gauge_init+0x88>)
 8026426:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 802642a:	f7ff fb5c 	bl	8025ae6 <lv_color_hex3>
 802642e:	8160      	strh	r0, [r4, #10]
    gauge_bg.line.color          = lv_color_hsv_to_rgb(_hue, 80, 75);
 8026430:	4b10      	ldr	r3, [pc, #64]	; (8026474 <gauge_init+0x8c>)
 8026432:	881b      	ldrh	r3, [r3, #0]
 8026434:	4c0e      	ldr	r4, [pc, #56]	; (8026470 <gauge_init+0x88>)
 8026436:	224b      	movs	r2, #75	; 0x4b
 8026438:	2150      	movs	r1, #80	; 0x50
 802643a:	4618      	mov	r0, r3
 802643c:	f7f5 fd0e 	bl	801be5c <lv_color_hsv_to_rgb>
 8026440:	86a0      	strh	r0, [r4, #52]	; 0x34
    gauge_bg.line.width          = 2;
 8026442:	4b0b      	ldr	r3, [pc, #44]	; (8026470 <gauge_init+0x88>)
 8026444:	2202      	movs	r2, #2
 8026446:	86da      	strh	r2, [r3, #54]	; 0x36
    gauge_bg.text.color          = lv_color_hsv_to_rgb(_hue, 10, 90);
 8026448:	4b0a      	ldr	r3, [pc, #40]	; (8026474 <gauge_init+0x8c>)
 802644a:	881b      	ldrh	r3, [r3, #0]
 802644c:	4c08      	ldr	r4, [pc, #32]	; (8026470 <gauge_init+0x88>)
 802644e:	225a      	movs	r2, #90	; 0x5a
 8026450:	210a      	movs	r1, #10
 8026452:	4618      	mov	r0, r3
 8026454:	f7f5 fd02 	bl	801be5c <lv_color_hsv_to_rgb>
 8026458:	8420      	strh	r0, [r4, #32]
    gauge_bg.text.font           = _font;
 802645a:	4b07      	ldr	r3, [pc, #28]	; (8026478 <gauge_init+0x90>)
 802645c:	681b      	ldr	r3, [r3, #0]
 802645e:	4a04      	ldr	r2, [pc, #16]	; (8026470 <gauge_init+0x88>)
 8026460:	6253      	str	r3, [r2, #36]	; 0x24

    theme.style.gauge = &gauge_bg;
 8026462:	4b06      	ldr	r3, [pc, #24]	; (802647c <gauge_init+0x94>)
 8026464:	4a02      	ldr	r2, [pc, #8]	; (8026470 <gauge_init+0x88>)
 8026466:	671a      	str	r2, [r3, #112]	; 0x70
#endif
}
 8026468:	bf00      	nop
 802646a:	bd98      	pop	{r3, r4, r7, pc}
 802646c:	2000c5b0 	.word	0x2000c5b0
 8026470:	2000ccf4 	.word	0x2000ccf4
 8026474:	2000c3f4 	.word	0x2000c3f4
 8026478:	2000c3f8 	.word	0x2000c3f8
 802647c:	2000c3fc 	.word	0x2000c3fc

08026480 <arc_init>:

static void arc_init(void)
{
 8026480:	b598      	push	{r3, r4, r7, lr}
 8026482:	af00      	add	r7, sp, #0
#if LV_USE_ARC != 0

    static lv_style_t arc;
    lv_style_copy(&arc, &def);
 8026484:	490f      	ldr	r1, [pc, #60]	; (80264c4 <arc_init+0x44>)
 8026486:	4810      	ldr	r0, [pc, #64]	; (80264c8 <arc_init+0x48>)
 8026488:	f7ed faec 	bl	8013a64 <lv_style_copy>
    arc.line.width   = 10;
 802648c:	4b0e      	ldr	r3, [pc, #56]	; (80264c8 <arc_init+0x48>)
 802648e:	220a      	movs	r2, #10
 8026490:	86da      	strh	r2, [r3, #54]	; 0x36
    arc.line.color   = lv_color_hsv_to_rgb(_hue, 70, 90);
 8026492:	4b0e      	ldr	r3, [pc, #56]	; (80264cc <arc_init+0x4c>)
 8026494:	881b      	ldrh	r3, [r3, #0]
 8026496:	4c0c      	ldr	r4, [pc, #48]	; (80264c8 <arc_init+0x48>)
 8026498:	225a      	movs	r2, #90	; 0x5a
 802649a:	2146      	movs	r1, #70	; 0x46
 802649c:	4618      	mov	r0, r3
 802649e:	f7f5 fcdd 	bl	801be5c <lv_color_hsv_to_rgb>
 80264a2:	86a0      	strh	r0, [r4, #52]	; 0x34
    arc.line.rounded = 1;
 80264a4:	4a08      	ldr	r2, [pc, #32]	; (80264c8 <arc_init+0x48>)
 80264a6:	f892 3039 	ldrb.w	r3, [r2, #57]	; 0x39
 80264aa:	f043 0301 	orr.w	r3, r3, #1
 80264ae:	f882 3039 	strb.w	r3, [r2, #57]	; 0x39

    /*For preloader*/
    arc.body.border.width = 0;
 80264b2:	4b05      	ldr	r3, [pc, #20]	; (80264c8 <arc_init+0x48>)
 80264b4:	2200      	movs	r2, #0
 80264b6:	819a      	strh	r2, [r3, #12]

    theme.style.arc = &arc;
 80264b8:	4b05      	ldr	r3, [pc, #20]	; (80264d0 <arc_init+0x50>)
 80264ba:	4a03      	ldr	r2, [pc, #12]	; (80264c8 <arc_init+0x48>)
 80264bc:	675a      	str	r2, [r3, #116]	; 0x74
#endif
}
 80264be:	bf00      	nop
 80264c0:	bd98      	pop	{r3, r4, r7, pc}
 80264c2:	bf00      	nop
 80264c4:	2000c5b0 	.word	0x2000c5b0
 80264c8:	2000cd30 	.word	0x2000cd30
 80264cc:	2000c3f4 	.word	0x2000c3f4
 80264d0:	2000c3fc 	.word	0x2000c3fc

080264d4 <preload_init>:

static void preload_init(void)
{
 80264d4:	b480      	push	{r7}
 80264d6:	af00      	add	r7, sp, #0
#if LV_USE_PRELOAD != 0

    theme.style.preload = theme.style.arc;
 80264d8:	4b04      	ldr	r3, [pc, #16]	; (80264ec <preload_init+0x18>)
 80264da:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80264dc:	4a03      	ldr	r2, [pc, #12]	; (80264ec <preload_init+0x18>)
 80264de:	6793      	str	r3, [r2, #120]	; 0x78
#endif
}
 80264e0:	bf00      	nop
 80264e2:	46bd      	mov	sp, r7
 80264e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80264e8:	4770      	bx	lr
 80264ea:	bf00      	nop
 80264ec:	2000c3fc 	.word	0x2000c3fc

080264f0 <chart_init>:

static void chart_init(void)
{
 80264f0:	b480      	push	{r7}
 80264f2:	af00      	add	r7, sp, #0
#if LV_USE_CHART
    theme.style.chart = &panel;
 80264f4:	4b04      	ldr	r3, [pc, #16]	; (8026508 <chart_init+0x18>)
 80264f6:	4a05      	ldr	r2, [pc, #20]	; (802650c <chart_init+0x1c>)
 80264f8:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
#endif
}
 80264fc:	bf00      	nop
 80264fe:	46bd      	mov	sp, r7
 8026500:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026504:	4770      	bx	lr
 8026506:	bf00      	nop
 8026508:	2000c3fc 	.word	0x2000c3fc
 802650c:	2000c664 	.word	0x2000c664

08026510 <calendar_init>:

static void calendar_init(void)
{
 8026510:	b598      	push	{r3, r4, r7, lr}
 8026512:	af00      	add	r7, sp, #0
#if LV_USE_CALENDAR != 0
    static lv_style_t ina_days;
    lv_style_copy(&ina_days, &def);
 8026514:	492f      	ldr	r1, [pc, #188]	; (80265d4 <calendar_init+0xc4>)
 8026516:	4830      	ldr	r0, [pc, #192]	; (80265d8 <calendar_init+0xc8>)
 8026518:	f7ed faa4 	bl	8013a64 <lv_style_copy>
    ina_days.text.color = lv_color_hsv_to_rgb(_hue, 0, 50);
 802651c:	4b2f      	ldr	r3, [pc, #188]	; (80265dc <calendar_init+0xcc>)
 802651e:	881b      	ldrh	r3, [r3, #0]
 8026520:	4c2d      	ldr	r4, [pc, #180]	; (80265d8 <calendar_init+0xc8>)
 8026522:	2232      	movs	r2, #50	; 0x32
 8026524:	2100      	movs	r1, #0
 8026526:	4618      	mov	r0, r3
 8026528:	f7f5 fc98 	bl	801be5c <lv_color_hsv_to_rgb>
 802652c:	8420      	strh	r0, [r4, #32]

    static lv_style_t high_days;
    lv_style_copy(&high_days, &def);
 802652e:	4929      	ldr	r1, [pc, #164]	; (80265d4 <calendar_init+0xc4>)
 8026530:	482b      	ldr	r0, [pc, #172]	; (80265e0 <calendar_init+0xd0>)
 8026532:	f7ed fa97 	bl	8013a64 <lv_style_copy>
    high_days.text.color = lv_color_hsv_to_rgb(_hue, 50, 90);
 8026536:	4b29      	ldr	r3, [pc, #164]	; (80265dc <calendar_init+0xcc>)
 8026538:	881b      	ldrh	r3, [r3, #0]
 802653a:	4c29      	ldr	r4, [pc, #164]	; (80265e0 <calendar_init+0xd0>)
 802653c:	225a      	movs	r2, #90	; 0x5a
 802653e:	2132      	movs	r1, #50	; 0x32
 8026540:	4618      	mov	r0, r3
 8026542:	f7f5 fc8b 	bl	801be5c <lv_color_hsv_to_rgb>
 8026546:	8420      	strh	r0, [r4, #32]

    static lv_style_t week_box;
    lv_style_copy(&week_box, &def);
 8026548:	4922      	ldr	r1, [pc, #136]	; (80265d4 <calendar_init+0xc4>)
 802654a:	4826      	ldr	r0, [pc, #152]	; (80265e4 <calendar_init+0xd4>)
 802654c:	f7ed fa8a 	bl	8013a64 <lv_style_copy>
    week_box.body.opa            = LV_OPA_TRANSP;
 8026550:	4b24      	ldr	r3, [pc, #144]	; (80265e4 <calendar_init+0xd4>)
 8026552:	2200      	movs	r2, #0
 8026554:	721a      	strb	r2, [r3, #8]
    week_box.body.border.color   = theme.style.panel->body.border.color;
 8026556:	4b24      	ldr	r3, [pc, #144]	; (80265e8 <calendar_init+0xd8>)
 8026558:	689b      	ldr	r3, [r3, #8]
 802655a:	4a22      	ldr	r2, [pc, #136]	; (80265e4 <calendar_init+0xd4>)
 802655c:	895b      	ldrh	r3, [r3, #10]
 802655e:	8153      	strh	r3, [r2, #10]
    week_box.body.padding.top    = LV_DPI / 20;
 8026560:	4b20      	ldr	r3, [pc, #128]	; (80265e4 <calendar_init+0xd4>)
 8026562:	2205      	movs	r2, #5
 8026564:	82da      	strh	r2, [r3, #22]
    week_box.body.padding.bottom = LV_DPI / 20;
 8026566:	4b1f      	ldr	r3, [pc, #124]	; (80265e4 <calendar_init+0xd4>)
 8026568:	2205      	movs	r2, #5
 802656a:	831a      	strh	r2, [r3, #24]

    static lv_style_t today_box;
    lv_style_copy(&today_box, &def);
 802656c:	4919      	ldr	r1, [pc, #100]	; (80265d4 <calendar_init+0xc4>)
 802656e:	481f      	ldr	r0, [pc, #124]	; (80265ec <calendar_init+0xdc>)
 8026570:	f7ed fa78 	bl	8013a64 <lv_style_copy>
    today_box.body.main_color     = LV_COLOR_WHITE;
 8026574:	4a1d      	ldr	r2, [pc, #116]	; (80265ec <calendar_init+0xdc>)
 8026576:	4b1e      	ldr	r3, [pc, #120]	; (80265f0 <calendar_init+0xe0>)
 8026578:	881b      	ldrh	r3, [r3, #0]
 802657a:	8053      	strh	r3, [r2, #2]
    today_box.body.padding.top    = LV_DPI / 20;
 802657c:	4b1b      	ldr	r3, [pc, #108]	; (80265ec <calendar_init+0xdc>)
 802657e:	2205      	movs	r2, #5
 8026580:	82da      	strh	r2, [r3, #22]
    today_box.body.padding.bottom = LV_DPI / 20;
 8026582:	4b1a      	ldr	r3, [pc, #104]	; (80265ec <calendar_init+0xdc>)
 8026584:	2205      	movs	r2, #5
 8026586:	831a      	strh	r2, [r3, #24]
    today_box.body.radius         = 0;
 8026588:	4b18      	ldr	r3, [pc, #96]	; (80265ec <calendar_init+0xdc>)
 802658a:	2200      	movs	r2, #0
 802658c:	80da      	strh	r2, [r3, #6]

    theme.style.calendar.bg               = theme.style.panel;
 802658e:	4b16      	ldr	r3, [pc, #88]	; (80265e8 <calendar_init+0xd8>)
 8026590:	689b      	ldr	r3, [r3, #8]
 8026592:	4a15      	ldr	r2, [pc, #84]	; (80265e8 <calendar_init+0xd8>)
 8026594:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
    theme.style.calendar.header           = theme.style.label.prim;
 8026598:	4b13      	ldr	r3, [pc, #76]	; (80265e8 <calendar_init+0xd8>)
 802659a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 802659c:	4a12      	ldr	r2, [pc, #72]	; (80265e8 <calendar_init+0xd8>)
 802659e:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
    theme.style.calendar.inactive_days    = theme.style.label.hint;
 80265a2:	4b11      	ldr	r3, [pc, #68]	; (80265e8 <calendar_init+0xd8>)
 80265a4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80265a6:	4a10      	ldr	r2, [pc, #64]	; (80265e8 <calendar_init+0xd8>)
 80265a8:	f8c2 30a4 	str.w	r3, [r2, #164]	; 0xa4
    theme.style.calendar.highlighted_days = theme.style.label.sec;
 80265ac:	4b0e      	ldr	r3, [pc, #56]	; (80265e8 <calendar_init+0xd8>)
 80265ae:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80265b0:	4a0d      	ldr	r2, [pc, #52]	; (80265e8 <calendar_init+0xd8>)
 80265b2:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
    theme.style.calendar.week_box         = &week_box;
 80265b6:	4b0c      	ldr	r3, [pc, #48]	; (80265e8 <calendar_init+0xd8>)
 80265b8:	4a0a      	ldr	r2, [pc, #40]	; (80265e4 <calendar_init+0xd4>)
 80265ba:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
    theme.style.calendar.today_box        = &week_box;
 80265be:	4b0a      	ldr	r3, [pc, #40]	; (80265e8 <calendar_init+0xd8>)
 80265c0:	4a08      	ldr	r2, [pc, #32]	; (80265e4 <calendar_init+0xd4>)
 80265c2:	f8c3 20ac 	str.w	r2, [r3, #172]	; 0xac
    theme.style.calendar.header_pr        = theme.style.label.prim;
 80265c6:	4b08      	ldr	r3, [pc, #32]	; (80265e8 <calendar_init+0xd8>)
 80265c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80265ca:	4a07      	ldr	r2, [pc, #28]	; (80265e8 <calendar_init+0xd8>)
 80265cc:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98
#endif
}
 80265d0:	bf00      	nop
 80265d2:	bd98      	pop	{r3, r4, r7, pc}
 80265d4:	2000c5b0 	.word	0x2000c5b0
 80265d8:	2000cd6c 	.word	0x2000cd6c
 80265dc:	2000c3f4 	.word	0x2000c3f4
 80265e0:	2000cda8 	.word	0x2000cda8
 80265e4:	2000cde4 	.word	0x2000cde4
 80265e8:	2000c3fc 	.word	0x2000c3fc
 80265ec:	2000ce20 	.word	0x2000ce20
 80265f0:	0802913c 	.word	0x0802913c

080265f4 <cb_init>:

static void cb_init(void)
{
 80265f4:	b598      	push	{r3, r4, r7, lr}
 80265f6:	af00      	add	r7, sp, #0
#if LV_USE_CB != 0
    static lv_style_t cb_bg, cb_rel, cb_pr, cb_trel, cb_tpr, cb_ina;
    lv_style_copy(&cb_rel, &bg);
 80265f8:	495f      	ldr	r1, [pc, #380]	; (8026778 <cb_init+0x184>)
 80265fa:	4860      	ldr	r0, [pc, #384]	; (802677c <cb_init+0x188>)
 80265fc:	f7ed fa32 	bl	8013a64 <lv_style_copy>
    cb_rel.body.radius       = LV_DPI / 20;
 8026600:	4b5e      	ldr	r3, [pc, #376]	; (802677c <cb_init+0x188>)
 8026602:	2205      	movs	r2, #5
 8026604:	80da      	strh	r2, [r3, #6]
    cb_rel.body.border.width = 1;
 8026606:	4b5d      	ldr	r3, [pc, #372]	; (802677c <cb_init+0x188>)
 8026608:	2201      	movs	r2, #1
 802660a:	819a      	strh	r2, [r3, #12]
    cb_rel.body.border.color = LV_COLOR_ORANGE;
 802660c:	4a5b      	ldr	r2, [pc, #364]	; (802677c <cb_init+0x188>)
 802660e:	7a93      	ldrb	r3, [r2, #10]
 8026610:	f36f 0304 	bfc	r3, #0, #5
 8026614:	7293      	strb	r3, [r2, #10]
 8026616:	4a59      	ldr	r2, [pc, #356]	; (802677c <cb_init+0x188>)
 8026618:	8953      	ldrh	r3, [r2, #10]
 802661a:	2129      	movs	r1, #41	; 0x29
 802661c:	f361 134a 	bfi	r3, r1, #5, #6
 8026620:	8153      	strh	r3, [r2, #10]
 8026622:	4a56      	ldr	r2, [pc, #344]	; (802677c <cb_init+0x188>)
 8026624:	7ad3      	ldrb	r3, [r2, #11]
 8026626:	f043 03f8 	orr.w	r3, r3, #248	; 0xf8
 802662a:	72d3      	strb	r3, [r2, #11]
    cb_rel.body.main_color   = LV_COLOR_PURPLE;
 802662c:	4a53      	ldr	r2, [pc, #332]	; (802677c <cb_init+0x188>)
 802662e:	7893      	ldrb	r3, [r2, #2]
 8026630:	2110      	movs	r1, #16
 8026632:	f361 0304 	bfi	r3, r1, #0, #5
 8026636:	7093      	strb	r3, [r2, #2]
 8026638:	4a50      	ldr	r2, [pc, #320]	; (802677c <cb_init+0x188>)
 802663a:	8853      	ldrh	r3, [r2, #2]
 802663c:	f36f 134a 	bfc	r3, #5, #6
 8026640:	8053      	strh	r3, [r2, #2]
 8026642:	4a4e      	ldr	r2, [pc, #312]	; (802677c <cb_init+0x188>)
 8026644:	78d3      	ldrb	r3, [r2, #3]
 8026646:	2110      	movs	r1, #16
 8026648:	f361 03c7 	bfi	r3, r1, #3, #5
 802664c:	70d3      	strb	r3, [r2, #3]

    lv_style_copy(&cb_bg, &bg);
 802664e:	494a      	ldr	r1, [pc, #296]	; (8026778 <cb_init+0x184>)
 8026650:	484b      	ldr	r0, [pc, #300]	; (8026780 <cb_init+0x18c>)
 8026652:	f7ed fa07 	bl	8013a64 <lv_style_copy>
    cb_bg.body.opa            = LV_OPA_TRANSP;
 8026656:	4b4a      	ldr	r3, [pc, #296]	; (8026780 <cb_init+0x18c>)
 8026658:	2200      	movs	r2, #0
 802665a:	721a      	strb	r2, [r3, #8]
    cb_bg.body.border.width   = 0;
 802665c:	4b48      	ldr	r3, [pc, #288]	; (8026780 <cb_init+0x18c>)
 802665e:	2200      	movs	r2, #0
 8026660:	819a      	strh	r2, [r3, #12]
    cb_bg.body.padding.inner  = LV_DPI / 8;
 8026662:	4b47      	ldr	r3, [pc, #284]	; (8026780 <cb_init+0x18c>)
 8026664:	220c      	movs	r2, #12
 8026666:	83da      	strh	r2, [r3, #30]
    cb_bg.body.padding.left   = 0;
 8026668:	4b45      	ldr	r3, [pc, #276]	; (8026780 <cb_init+0x18c>)
 802666a:	2200      	movs	r2, #0
 802666c:	835a      	strh	r2, [r3, #26]
    cb_bg.body.padding.right  = 0;
 802666e:	4b44      	ldr	r3, [pc, #272]	; (8026780 <cb_init+0x18c>)
 8026670:	2200      	movs	r2, #0
 8026672:	839a      	strh	r2, [r3, #28]
    cb_bg.body.padding.top    = 0;
 8026674:	4b42      	ldr	r3, [pc, #264]	; (8026780 <cb_init+0x18c>)
 8026676:	2200      	movs	r2, #0
 8026678:	82da      	strh	r2, [r3, #22]
    cb_bg.body.padding.bottom = 0;
 802667a:	4b41      	ldr	r3, [pc, #260]	; (8026780 <cb_init+0x18c>)
 802667c:	2200      	movs	r2, #0
 802667e:	831a      	strh	r2, [r3, #24]
    cb_bg.text.font           = _font;
 8026680:	4b40      	ldr	r3, [pc, #256]	; (8026784 <cb_init+0x190>)
 8026682:	681b      	ldr	r3, [r3, #0]
 8026684:	4a3e      	ldr	r2, [pc, #248]	; (8026780 <cb_init+0x18c>)
 8026686:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&cb_pr, &cb_rel);
 8026688:	493c      	ldr	r1, [pc, #240]	; (802677c <cb_init+0x188>)
 802668a:	483f      	ldr	r0, [pc, #252]	; (8026788 <cb_init+0x194>)
 802668c:	f7ed f9ea 	bl	8013a64 <lv_style_copy>
    cb_pr.body.main_color = lv_color_hsv_to_rgb(_hue, 10, 90);
 8026690:	4b3e      	ldr	r3, [pc, #248]	; (802678c <cb_init+0x198>)
 8026692:	881b      	ldrh	r3, [r3, #0]
 8026694:	4c3c      	ldr	r4, [pc, #240]	; (8026788 <cb_init+0x194>)
 8026696:	225a      	movs	r2, #90	; 0x5a
 8026698:	210a      	movs	r1, #10
 802669a:	4618      	mov	r0, r3
 802669c:	f7f5 fbde 	bl	801be5c <lv_color_hsv_to_rgb>
 80266a0:	8060      	strh	r0, [r4, #2]
    cb_pr.body.main_color = lv_color_hsv_to_rgb(_hue, 10, 82);
 80266a2:	4b3a      	ldr	r3, [pc, #232]	; (802678c <cb_init+0x198>)
 80266a4:	881b      	ldrh	r3, [r3, #0]
 80266a6:	4c38      	ldr	r4, [pc, #224]	; (8026788 <cb_init+0x194>)
 80266a8:	2252      	movs	r2, #82	; 0x52
 80266aa:	210a      	movs	r1, #10
 80266ac:	4618      	mov	r0, r3
 80266ae:	f7f5 fbd5 	bl	801be5c <lv_color_hsv_to_rgb>
 80266b2:	8060      	strh	r0, [r4, #2]

    lv_style_copy(&cb_trel, &cb_rel);
 80266b4:	4931      	ldr	r1, [pc, #196]	; (802677c <cb_init+0x188>)
 80266b6:	4836      	ldr	r0, [pc, #216]	; (8026790 <cb_init+0x19c>)
 80266b8:	f7ed f9d4 	bl	8013a64 <lv_style_copy>
    cb_trel.body.border.width = 4;
 80266bc:	4b34      	ldr	r3, [pc, #208]	; (8026790 <cb_init+0x19c>)
 80266be:	2204      	movs	r2, #4
 80266c0:	819a      	strh	r2, [r3, #12]
    cb_trel.body.border.color = LV_COLOR_WHITE;
 80266c2:	4a33      	ldr	r2, [pc, #204]	; (8026790 <cb_init+0x19c>)
 80266c4:	4b33      	ldr	r3, [pc, #204]	; (8026794 <cb_init+0x1a0>)
 80266c6:	881b      	ldrh	r3, [r3, #0]
 80266c8:	8153      	strh	r3, [r2, #10]
    cb_trel.body.border.opa   = LV_OPA_60;
 80266ca:	4b31      	ldr	r3, [pc, #196]	; (8026790 <cb_init+0x19c>)
 80266cc:	2299      	movs	r2, #153	; 0x99
 80266ce:	73da      	strb	r2, [r3, #15]
    cb_trel.body.main_color   = lv_color_hsv_to_rgb(_hue, 50, 82);
 80266d0:	4b2e      	ldr	r3, [pc, #184]	; (802678c <cb_init+0x198>)
 80266d2:	881b      	ldrh	r3, [r3, #0]
 80266d4:	4c2e      	ldr	r4, [pc, #184]	; (8026790 <cb_init+0x19c>)
 80266d6:	2252      	movs	r2, #82	; 0x52
 80266d8:	2132      	movs	r1, #50	; 0x32
 80266da:	4618      	mov	r0, r3
 80266dc:	f7f5 fbbe 	bl	801be5c <lv_color_hsv_to_rgb>
 80266e0:	8060      	strh	r0, [r4, #2]

    lv_style_copy(&cb_tpr, &cb_trel);
 80266e2:	492b      	ldr	r1, [pc, #172]	; (8026790 <cb_init+0x19c>)
 80266e4:	482c      	ldr	r0, [pc, #176]	; (8026798 <cb_init+0x1a4>)
 80266e6:	f7ed f9bd 	bl	8013a64 <lv_style_copy>
    cb_tpr.body.border.color = LV_COLOR_SILVER;
 80266ea:	4a2b      	ldr	r2, [pc, #172]	; (8026798 <cb_init+0x1a4>)
 80266ec:	4b2b      	ldr	r3, [pc, #172]	; (802679c <cb_init+0x1a8>)
 80266ee:	881b      	ldrh	r3, [r3, #0]
 80266f0:	8153      	strh	r3, [r2, #10]
    cb_tpr.body.border.opa   = LV_OPA_70;
 80266f2:	4b29      	ldr	r3, [pc, #164]	; (8026798 <cb_init+0x1a4>)
 80266f4:	22b2      	movs	r2, #178	; 0xb2
 80266f6:	73da      	strb	r2, [r3, #15]
    cb_tpr.body.main_color   = lv_color_hsv_to_rgb(_hue, 50, 72);
 80266f8:	4b24      	ldr	r3, [pc, #144]	; (802678c <cb_init+0x198>)
 80266fa:	881b      	ldrh	r3, [r3, #0]
 80266fc:	4c26      	ldr	r4, [pc, #152]	; (8026798 <cb_init+0x1a4>)
 80266fe:	2248      	movs	r2, #72	; 0x48
 8026700:	2132      	movs	r1, #50	; 0x32
 8026702:	4618      	mov	r0, r3
 8026704:	f7f5 fbaa 	bl	801be5c <lv_color_hsv_to_rgb>
 8026708:	8060      	strh	r0, [r4, #2]

    lv_style_copy(&cb_ina, &cb_trel);
 802670a:	4921      	ldr	r1, [pc, #132]	; (8026790 <cb_init+0x19c>)
 802670c:	4824      	ldr	r0, [pc, #144]	; (80267a0 <cb_init+0x1ac>)
 802670e:	f7ed f9a9 	bl	8013a64 <lv_style_copy>
    cb_ina.body.border.width = 1;
 8026712:	4b23      	ldr	r3, [pc, #140]	; (80267a0 <cb_init+0x1ac>)
 8026714:	2201      	movs	r2, #1
 8026716:	819a      	strh	r2, [r3, #12]
    cb_ina.body.border.color = LV_COLOR_GRAY;
 8026718:	4a21      	ldr	r2, [pc, #132]	; (80267a0 <cb_init+0x1ac>)
 802671a:	4b22      	ldr	r3, [pc, #136]	; (80267a4 <cb_init+0x1b0>)
 802671c:	881b      	ldrh	r3, [r3, #0]
 802671e:	8153      	strh	r3, [r2, #10]
    cb_ina.body.main_color   = LV_COLOR_PURPLE;
 8026720:	4a1f      	ldr	r2, [pc, #124]	; (80267a0 <cb_init+0x1ac>)
 8026722:	7893      	ldrb	r3, [r2, #2]
 8026724:	2110      	movs	r1, #16
 8026726:	f361 0304 	bfi	r3, r1, #0, #5
 802672a:	7093      	strb	r3, [r2, #2]
 802672c:	4a1c      	ldr	r2, [pc, #112]	; (80267a0 <cb_init+0x1ac>)
 802672e:	8853      	ldrh	r3, [r2, #2]
 8026730:	f36f 134a 	bfc	r3, #5, #6
 8026734:	8053      	strh	r3, [r2, #2]
 8026736:	4a1a      	ldr	r2, [pc, #104]	; (80267a0 <cb_init+0x1ac>)
 8026738:	78d3      	ldrb	r3, [r2, #3]
 802673a:	2110      	movs	r1, #16
 802673c:	f361 03c7 	bfi	r3, r1, #3, #5
 8026740:	70d3      	strb	r3, [r2, #3]

    theme.style.cb.bg          = &cb_bg;
 8026742:	4b19      	ldr	r3, [pc, #100]	; (80267a8 <cb_init+0x1b4>)
 8026744:	4a0e      	ldr	r2, [pc, #56]	; (8026780 <cb_init+0x18c>)
 8026746:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
    theme.style.cb.box.rel     = &cb_rel;
 802674a:	4b17      	ldr	r3, [pc, #92]	; (80267a8 <cb_init+0x1b4>)
 802674c:	4a0b      	ldr	r2, [pc, #44]	; (802677c <cb_init+0x188>)
 802674e:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    theme.style.cb.box.pr      = &cb_pr;
 8026752:	4b15      	ldr	r3, [pc, #84]	; (80267a8 <cb_init+0x1b4>)
 8026754:	4a0c      	ldr	r2, [pc, #48]	; (8026788 <cb_init+0x194>)
 8026756:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    theme.style.cb.box.tgl_rel = &cb_trel;
 802675a:	4b13      	ldr	r3, [pc, #76]	; (80267a8 <cb_init+0x1b4>)
 802675c:	4a0c      	ldr	r2, [pc, #48]	; (8026790 <cb_init+0x19c>)
 802675e:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    theme.style.cb.box.tgl_pr  = &cb_tpr;
 8026762:	4b11      	ldr	r3, [pc, #68]	; (80267a8 <cb_init+0x1b4>)
 8026764:	4a0c      	ldr	r2, [pc, #48]	; (8026798 <cb_init+0x1a4>)
 8026766:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    theme.style.cb.box.ina     = &cb_ina;
 802676a:	4b0f      	ldr	r3, [pc, #60]	; (80267a8 <cb_init+0x1b4>)
 802676c:	4a0c      	ldr	r2, [pc, #48]	; (80267a0 <cb_init+0x1ac>)
 802676e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
#endif
}
 8026772:	bf00      	nop
 8026774:	bd98      	pop	{r3, r4, r7, pc}
 8026776:	bf00      	nop
 8026778:	2000c5ec 	.word	0x2000c5ec
 802677c:	2000ce5c 	.word	0x2000ce5c
 8026780:	2000ce98 	.word	0x2000ce98
 8026784:	2000c3f8 	.word	0x2000c3f8
 8026788:	2000ced4 	.word	0x2000ced4
 802678c:	2000c3f4 	.word	0x2000c3f4
 8026790:	2000cf10 	.word	0x2000cf10
 8026794:	0802913c 	.word	0x0802913c
 8026798:	2000cf4c 	.word	0x2000cf4c
 802679c:	08029138 	.word	0x08029138
 80267a0:	2000cf88 	.word	0x2000cf88
 80267a4:	08029140 	.word	0x08029140
 80267a8:	2000c3fc 	.word	0x2000c3fc

080267ac <btnm_init>:

static void btnm_init(void)
{
 80267ac:	b598      	push	{r3, r4, r7, lr}
 80267ae:	af00      	add	r7, sp, #0
#if LV_USE_BTNM
    lv_style_copy(&btnm_bg, &lv_style_transp_tight);
 80267b0:	4940      	ldr	r1, [pc, #256]	; (80268b4 <btnm_init+0x108>)
 80267b2:	4841      	ldr	r0, [pc, #260]	; (80268b8 <btnm_init+0x10c>)
 80267b4:	f7ed f956 	bl	8013a64 <lv_style_copy>
    btnm_bg.body.border.width = 1;
 80267b8:	4b3f      	ldr	r3, [pc, #252]	; (80268b8 <btnm_init+0x10c>)
 80267ba:	2201      	movs	r2, #1
 80267bc:	819a      	strh	r2, [r3, #12]
    btnm_bg.body.border.color = lv_color_hsv_to_rgb(_hue, 60, 80);
 80267be:	4b3f      	ldr	r3, [pc, #252]	; (80268bc <btnm_init+0x110>)
 80267c0:	881b      	ldrh	r3, [r3, #0]
 80267c2:	4c3d      	ldr	r4, [pc, #244]	; (80268b8 <btnm_init+0x10c>)
 80267c4:	2250      	movs	r2, #80	; 0x50
 80267c6:	213c      	movs	r1, #60	; 0x3c
 80267c8:	4618      	mov	r0, r3
 80267ca:	f7f5 fb47 	bl	801be5c <lv_color_hsv_to_rgb>
 80267ce:	8160      	strh	r0, [r4, #10]
    btnm_bg.body.border.opa   = LV_OPA_COVER;
 80267d0:	4b39      	ldr	r3, [pc, #228]	; (80268b8 <btnm_init+0x10c>)
 80267d2:	22ff      	movs	r2, #255	; 0xff
 80267d4:	73da      	strb	r2, [r3, #15]
    btnm_bg.body.radius       = LV_DPI / 8;
 80267d6:	4b38      	ldr	r3, [pc, #224]	; (80268b8 <btnm_init+0x10c>)
 80267d8:	220c      	movs	r2, #12
 80267da:	80da      	strh	r2, [r3, #6]

    lv_style_copy(&btnm_rel, &lv_style_plain);
 80267dc:	4938      	ldr	r1, [pc, #224]	; (80268c0 <btnm_init+0x114>)
 80267de:	4839      	ldr	r0, [pc, #228]	; (80268c4 <btnm_init+0x118>)
 80267e0:	f7ed f940 	bl	8013a64 <lv_style_copy>
    btnm_rel.body.opa    = LV_OPA_TRANSP;
 80267e4:	4b37      	ldr	r3, [pc, #220]	; (80268c4 <btnm_init+0x118>)
 80267e6:	2200      	movs	r2, #0
 80267e8:	721a      	strb	r2, [r3, #8]
    btnm_rel.body.radius = LV_DPI / 8;
 80267ea:	4b36      	ldr	r3, [pc, #216]	; (80268c4 <btnm_init+0x118>)
 80267ec:	220c      	movs	r2, #12
 80267ee:	80da      	strh	r2, [r3, #6]
    btnm_rel.text.color  = lv_color_hsv_to_rgb(_hue, 60, 80);
 80267f0:	4b32      	ldr	r3, [pc, #200]	; (80268bc <btnm_init+0x110>)
 80267f2:	881b      	ldrh	r3, [r3, #0]
 80267f4:	4c33      	ldr	r4, [pc, #204]	; (80268c4 <btnm_init+0x118>)
 80267f6:	2250      	movs	r2, #80	; 0x50
 80267f8:	213c      	movs	r1, #60	; 0x3c
 80267fa:	4618      	mov	r0, r3
 80267fc:	f7f5 fb2e 	bl	801be5c <lv_color_hsv_to_rgb>
 8026800:	8420      	strh	r0, [r4, #32]
    btnm_rel.text.font   = _font;
 8026802:	4b31      	ldr	r3, [pc, #196]	; (80268c8 <btnm_init+0x11c>)
 8026804:	681b      	ldr	r3, [r3, #0]
 8026806:	4a2f      	ldr	r2, [pc, #188]	; (80268c4 <btnm_init+0x118>)
 8026808:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&btnm_pr, &lv_style_plain);
 802680a:	492d      	ldr	r1, [pc, #180]	; (80268c0 <btnm_init+0x114>)
 802680c:	482f      	ldr	r0, [pc, #188]	; (80268cc <btnm_init+0x120>)
 802680e:	f7ed f929 	bl	8013a64 <lv_style_copy>
    btnm_pr.body.main_color = lv_color_hsv_to_rgb(_hue, 40, 70);
 8026812:	4b2a      	ldr	r3, [pc, #168]	; (80268bc <btnm_init+0x110>)
 8026814:	881b      	ldrh	r3, [r3, #0]
 8026816:	4c2d      	ldr	r4, [pc, #180]	; (80268cc <btnm_init+0x120>)
 8026818:	2246      	movs	r2, #70	; 0x46
 802681a:	2128      	movs	r1, #40	; 0x28
 802681c:	4618      	mov	r0, r3
 802681e:	f7f5 fb1d 	bl	801be5c <lv_color_hsv_to_rgb>
 8026822:	8060      	strh	r0, [r4, #2]
    btnm_pr.body.radius     = LV_DPI / 8;
 8026824:	4b29      	ldr	r3, [pc, #164]	; (80268cc <btnm_init+0x120>)
 8026826:	220c      	movs	r2, #12
 8026828:	80da      	strh	r2, [r3, #6]
    btnm_pr.text.color      = lv_color_hsv_to_rgb(_hue, 40, 40);
 802682a:	4b24      	ldr	r3, [pc, #144]	; (80268bc <btnm_init+0x110>)
 802682c:	881b      	ldrh	r3, [r3, #0]
 802682e:	4c27      	ldr	r4, [pc, #156]	; (80268cc <btnm_init+0x120>)
 8026830:	2228      	movs	r2, #40	; 0x28
 8026832:	2128      	movs	r1, #40	; 0x28
 8026834:	4618      	mov	r0, r3
 8026836:	f7f5 fb11 	bl	801be5c <lv_color_hsv_to_rgb>
 802683a:	8420      	strh	r0, [r4, #32]
    btnm_pr.text.font       = _font;
 802683c:	4b22      	ldr	r3, [pc, #136]	; (80268c8 <btnm_init+0x11c>)
 802683e:	681b      	ldr	r3, [r3, #0]
 8026840:	4a22      	ldr	r2, [pc, #136]	; (80268cc <btnm_init+0x120>)
 8026842:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&btnm_trel, &btnm_rel);
 8026844:	491f      	ldr	r1, [pc, #124]	; (80268c4 <btnm_init+0x118>)
 8026846:	4822      	ldr	r0, [pc, #136]	; (80268d0 <btnm_init+0x124>)
 8026848:	f7ed f90c 	bl	8013a64 <lv_style_copy>
    btnm_trel.body.border.color = lv_color_hsv_to_rgb(_hue, 80, 80);
 802684c:	4b1b      	ldr	r3, [pc, #108]	; (80268bc <btnm_init+0x110>)
 802684e:	881b      	ldrh	r3, [r3, #0]
 8026850:	4c1f      	ldr	r4, [pc, #124]	; (80268d0 <btnm_init+0x124>)
 8026852:	2250      	movs	r2, #80	; 0x50
 8026854:	2150      	movs	r1, #80	; 0x50
 8026856:	4618      	mov	r0, r3
 8026858:	f7f5 fb00 	bl	801be5c <lv_color_hsv_to_rgb>
 802685c:	8160      	strh	r0, [r4, #10]
    btnm_trel.body.border.width = 3;
 802685e:	4b1c      	ldr	r3, [pc, #112]	; (80268d0 <btnm_init+0x124>)
 8026860:	2203      	movs	r2, #3
 8026862:	819a      	strh	r2, [r3, #12]

    lv_style_copy(&btnm_ina, &btnm_rel);
 8026864:	4917      	ldr	r1, [pc, #92]	; (80268c4 <btnm_init+0x118>)
 8026866:	481b      	ldr	r0, [pc, #108]	; (80268d4 <btnm_init+0x128>)
 8026868:	f7ed f8fc 	bl	8013a64 <lv_style_copy>
    btnm_ina.text.color = lv_color_hsv_to_rgb(_hue, 10, 60);
 802686c:	4b13      	ldr	r3, [pc, #76]	; (80268bc <btnm_init+0x110>)
 802686e:	881b      	ldrh	r3, [r3, #0]
 8026870:	4c18      	ldr	r4, [pc, #96]	; (80268d4 <btnm_init+0x128>)
 8026872:	223c      	movs	r2, #60	; 0x3c
 8026874:	210a      	movs	r1, #10
 8026876:	4618      	mov	r0, r3
 8026878:	f7f5 faf0 	bl	801be5c <lv_color_hsv_to_rgb>
 802687c:	8420      	strh	r0, [r4, #32]

    theme.style.btnm.bg          = &btnm_bg;
 802687e:	4b16      	ldr	r3, [pc, #88]	; (80268d8 <btnm_init+0x12c>)
 8026880:	4a0d      	ldr	r2, [pc, #52]	; (80268b8 <btnm_init+0x10c>)
 8026882:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    theme.style.btnm.btn.rel     = &btnm_rel;
 8026886:	4b14      	ldr	r3, [pc, #80]	; (80268d8 <btnm_init+0x12c>)
 8026888:	4a0e      	ldr	r2, [pc, #56]	; (80268c4 <btnm_init+0x118>)
 802688a:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
    theme.style.btnm.btn.pr      = &btnm_pr;
 802688e:	4b12      	ldr	r3, [pc, #72]	; (80268d8 <btnm_init+0x12c>)
 8026890:	4a0e      	ldr	r2, [pc, #56]	; (80268cc <btnm_init+0x120>)
 8026892:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
    theme.style.btnm.btn.tgl_rel = &btnm_trel;
 8026896:	4b10      	ldr	r3, [pc, #64]	; (80268d8 <btnm_init+0x12c>)
 8026898:	4a0d      	ldr	r2, [pc, #52]	; (80268d0 <btnm_init+0x124>)
 802689a:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
    theme.style.btnm.btn.tgl_pr  = &btnm_pr;
 802689e:	4b0e      	ldr	r3, [pc, #56]	; (80268d8 <btnm_init+0x12c>)
 80268a0:	4a0a      	ldr	r2, [pc, #40]	; (80268cc <btnm_init+0x120>)
 80268a2:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    theme.style.btnm.btn.ina     = &btnm_ina;
 80268a6:	4b0c      	ldr	r3, [pc, #48]	; (80268d8 <btnm_init+0x12c>)
 80268a8:	4a0a      	ldr	r2, [pc, #40]	; (80268d4 <btnm_init+0x128>)
 80268aa:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
#endif
}
 80268ae:	bf00      	nop
 80268b0:	bd98      	pop	{r3, r4, r7, pc}
 80268b2:	bf00      	nop
 80268b4:	2000dd64 	.word	0x2000dd64
 80268b8:	2000c970 	.word	0x2000c970
 80268bc:	2000c3f4 	.word	0x2000c3f4
 80268c0:	2000de18 	.word	0x2000de18
 80268c4:	2000c9ac 	.word	0x2000c9ac
 80268c8:	2000c3f8 	.word	0x2000c3f8
 80268cc:	2000c9e8 	.word	0x2000c9e8
 80268d0:	2000ca24 	.word	0x2000ca24
 80268d4:	2000ca60 	.word	0x2000ca60
 80268d8:	2000c3fc 	.word	0x2000c3fc

080268dc <kb_init>:

static void kb_init(void)
{
 80268dc:	b480      	push	{r7}
 80268de:	af00      	add	r7, sp, #0
#if LV_USE_KB
    theme.style.kb.bg          = &btnm_bg;
 80268e0:	4b0e      	ldr	r3, [pc, #56]	; (802691c <kb_init+0x40>)
 80268e2:	4a0f      	ldr	r2, [pc, #60]	; (8026920 <kb_init+0x44>)
 80268e4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
    theme.style.kb.btn.rel     = &btnm_rel;
 80268e8:	4b0c      	ldr	r3, [pc, #48]	; (802691c <kb_init+0x40>)
 80268ea:	4a0e      	ldr	r2, [pc, #56]	; (8026924 <kb_init+0x48>)
 80268ec:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
    theme.style.kb.btn.pr      = &btnm_pr;
 80268f0:	4b0a      	ldr	r3, [pc, #40]	; (802691c <kb_init+0x40>)
 80268f2:	4a0d      	ldr	r2, [pc, #52]	; (8026928 <kb_init+0x4c>)
 80268f4:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    theme.style.kb.btn.tgl_rel = &btnm_trel;
 80268f8:	4b08      	ldr	r3, [pc, #32]	; (802691c <kb_init+0x40>)
 80268fa:	4a0c      	ldr	r2, [pc, #48]	; (802692c <kb_init+0x50>)
 80268fc:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
    theme.style.kb.btn.tgl_pr  = &btnm_pr;
 8026900:	4b06      	ldr	r3, [pc, #24]	; (802691c <kb_init+0x40>)
 8026902:	4a09      	ldr	r2, [pc, #36]	; (8026928 <kb_init+0x4c>)
 8026904:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
    theme.style.kb.btn.ina     = &btnm_ina;
 8026908:	4b04      	ldr	r3, [pc, #16]	; (802691c <kb_init+0x40>)
 802690a:	4a09      	ldr	r2, [pc, #36]	; (8026930 <kb_init+0x54>)
 802690c:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
#endif
}
 8026910:	bf00      	nop
 8026912:	46bd      	mov	sp, r7
 8026914:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026918:	4770      	bx	lr
 802691a:	bf00      	nop
 802691c:	2000c3fc 	.word	0x2000c3fc
 8026920:	2000c970 	.word	0x2000c970
 8026924:	2000c9ac 	.word	0x2000c9ac
 8026928:	2000c9e8 	.word	0x2000c9e8
 802692c:	2000ca24 	.word	0x2000ca24
 8026930:	2000ca60 	.word	0x2000ca60

08026934 <mbox_init>:

static void mbox_init(void)
{
 8026934:	b580      	push	{r7, lr}
 8026936:	af00      	add	r7, sp, #0
#if LV_USE_MBOX
    static lv_style_t mbox_bg;
    lv_style_copy(&mbox_bg, &panel);
 8026938:	490c      	ldr	r1, [pc, #48]	; (802696c <mbox_init+0x38>)
 802693a:	480d      	ldr	r0, [pc, #52]	; (8026970 <mbox_init+0x3c>)
 802693c:	f7ed f892 	bl	8013a64 <lv_style_copy>
    mbox_bg.body.shadow.width = LV_DPI / 12;
 8026940:	4b0b      	ldr	r3, [pc, #44]	; (8026970 <mbox_init+0x3c>)
 8026942:	2208      	movs	r2, #8
 8026944:	825a      	strh	r2, [r3, #18]

    theme.style.mbox.bg      = &mbox_bg;
 8026946:	4b0b      	ldr	r3, [pc, #44]	; (8026974 <mbox_init+0x40>)
 8026948:	4a09      	ldr	r2, [pc, #36]	; (8026970 <mbox_init+0x3c>)
 802694a:	f8c3 20f8 	str.w	r2, [r3, #248]	; 0xf8
    theme.style.mbox.btn.bg  = &lv_style_transp;
 802694e:	4b09      	ldr	r3, [pc, #36]	; (8026974 <mbox_init+0x40>)
 8026950:	4a09      	ldr	r2, [pc, #36]	; (8026978 <mbox_init+0x44>)
 8026952:	f8c3 20fc 	str.w	r2, [r3, #252]	; 0xfc
    theme.style.mbox.btn.rel = &btn_trel;
 8026956:	4b07      	ldr	r3, [pc, #28]	; (8026974 <mbox_init+0x40>)
 8026958:	4a08      	ldr	r2, [pc, #32]	; (802697c <mbox_init+0x48>)
 802695a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    theme.style.mbox.btn.pr  = &btn_tpr;
 802695e:	4b05      	ldr	r3, [pc, #20]	; (8026974 <mbox_init+0x40>)
 8026960:	4a07      	ldr	r2, [pc, #28]	; (8026980 <mbox_init+0x4c>)
 8026962:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
#endif
}
 8026966:	bf00      	nop
 8026968:	bd80      	pop	{r7, pc}
 802696a:	bf00      	nop
 802696c:	2000c664 	.word	0x2000c664
 8026970:	2000cfc4 	.word	0x2000cfc4
 8026974:	2000c3fc 	.word	0x2000c3fc
 8026978:	2000dc74 	.word	0x2000dc74
 802697c:	2000c754 	.word	0x2000c754
 8026980:	2000c790 	.word	0x2000c790

08026984 <page_init>:

static void page_init(void)
{
 8026984:	b480      	push	{r7}
 8026986:	af00      	add	r7, sp, #0
#if LV_USE_PAGE
    theme.style.page.bg   = &panel;
 8026988:	4b08      	ldr	r3, [pc, #32]	; (80269ac <page_init+0x28>)
 802698a:	4a09      	ldr	r2, [pc, #36]	; (80269b0 <page_init+0x2c>)
 802698c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
    theme.style.page.scrl = &lv_style_transp_fit;
 8026990:	4b06      	ldr	r3, [pc, #24]	; (80269ac <page_init+0x28>)
 8026992:	4a08      	ldr	r2, [pc, #32]	; (80269b4 <page_init+0x30>)
 8026994:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    theme.style.page.sb   = &sb;
 8026998:	4b04      	ldr	r3, [pc, #16]	; (80269ac <page_init+0x28>)
 802699a:	4a07      	ldr	r2, [pc, #28]	; (80269b8 <page_init+0x34>)
 802699c:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
#endif
}
 80269a0:	bf00      	nop
 80269a2:	46bd      	mov	sp, r7
 80269a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80269a8:	4770      	bx	lr
 80269aa:	bf00      	nop
 80269ac:	2000c3fc 	.word	0x2000c3fc
 80269b0:	2000c664 	.word	0x2000c664
 80269b4:	2000dddc 	.word	0x2000dddc
 80269b8:	2000c6a0 	.word	0x2000c6a0

080269bc <ta_init>:

static void ta_init(void)
{
 80269bc:	b480      	push	{r7}
 80269be:	af00      	add	r7, sp, #0
#if LV_USE_TA
    theme.style.ta.area    = &panel;
 80269c0:	4b0a      	ldr	r3, [pc, #40]	; (80269ec <ta_init+0x30>)
 80269c2:	4a0b      	ldr	r2, [pc, #44]	; (80269f0 <ta_init+0x34>)
 80269c4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
    theme.style.ta.oneline = &panel;
 80269c8:	4b08      	ldr	r3, [pc, #32]	; (80269ec <ta_init+0x30>)
 80269ca:	4a09      	ldr	r2, [pc, #36]	; (80269f0 <ta_init+0x34>)
 80269cc:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
    theme.style.ta.cursor  = NULL;
 80269d0:	4b06      	ldr	r3, [pc, #24]	; (80269ec <ta_init+0x30>)
 80269d2:	2200      	movs	r2, #0
 80269d4:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
    theme.style.ta.sb      = &sb;
 80269d8:	4b04      	ldr	r3, [pc, #16]	; (80269ec <ta_init+0x30>)
 80269da:	4a06      	ldr	r2, [pc, #24]	; (80269f4 <ta_init+0x38>)
 80269dc:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
#endif
}
 80269e0:	bf00      	nop
 80269e2:	46bd      	mov	sp, r7
 80269e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80269e8:	4770      	bx	lr
 80269ea:	bf00      	nop
 80269ec:	2000c3fc 	.word	0x2000c3fc
 80269f0:	2000c664 	.word	0x2000c664
 80269f4:	2000c6a0 	.word	0x2000c6a0

080269f8 <spinbox_init>:

static void spinbox_init(void)
{
 80269f8:	b480      	push	{r7}
 80269fa:	af00      	add	r7, sp, #0
#if LV_USE_SPINBOX
    theme.style.spinbox.bg     = &panel;
 80269fc:	4b0a      	ldr	r3, [pc, #40]	; (8026a28 <spinbox_init+0x30>)
 80269fe:	4a0b      	ldr	r2, [pc, #44]	; (8026a2c <spinbox_init+0x34>)
 8026a00:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124
    theme.style.spinbox.cursor = theme.style.ta.cursor;
 8026a04:	4b08      	ldr	r3, [pc, #32]	; (8026a28 <spinbox_init+0x30>)
 8026a06:	f8d3 311c 	ldr.w	r3, [r3, #284]	; 0x11c
 8026a0a:	4a07      	ldr	r2, [pc, #28]	; (8026a28 <spinbox_init+0x30>)
 8026a0c:	f8c2 3128 	str.w	r3, [r2, #296]	; 0x128
    theme.style.spinbox.sb     = theme.style.ta.sb;
 8026a10:	4b05      	ldr	r3, [pc, #20]	; (8026a28 <spinbox_init+0x30>)
 8026a12:	f8d3 3120 	ldr.w	r3, [r3, #288]	; 0x120
 8026a16:	4a04      	ldr	r2, [pc, #16]	; (8026a28 <spinbox_init+0x30>)
 8026a18:	f8c2 312c 	str.w	r3, [r2, #300]	; 0x12c
#endif
}
 8026a1c:	bf00      	nop
 8026a1e:	46bd      	mov	sp, r7
 8026a20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026a24:	4770      	bx	lr
 8026a26:	bf00      	nop
 8026a28:	2000c3fc 	.word	0x2000c3fc
 8026a2c:	2000c664 	.word	0x2000c664

08026a30 <list_init>:

static void list_init(void)
{
 8026a30:	b598      	push	{r3, r4, r7, lr}
 8026a32:	af00      	add	r7, sp, #0
#if LV_USE_LIST != 0
    static lv_style_t list_bg, list_rel, list_pr, list_trel, list_tpr, list_ina;
    lv_style_copy(&list_rel, &def);
 8026a34:	493c      	ldr	r1, [pc, #240]	; (8026b28 <list_init+0xf8>)
 8026a36:	483d      	ldr	r0, [pc, #244]	; (8026b2c <list_init+0xfc>)
 8026a38:	f7ed f814 	bl	8013a64 <lv_style_copy>
    list_rel.body.opa          = LV_OPA_TRANSP;
 8026a3c:	4b3b      	ldr	r3, [pc, #236]	; (8026b2c <list_init+0xfc>)
 8026a3e:	2200      	movs	r2, #0
 8026a40:	721a      	strb	r2, [r3, #8]
    list_rel.body.border.width = 1;
 8026a42:	4b3a      	ldr	r3, [pc, #232]	; (8026b2c <list_init+0xfc>)
 8026a44:	2201      	movs	r2, #1
 8026a46:	819a      	strh	r2, [r3, #12]
    list_rel.body.border.color = lv_color_hsv_to_rgb(_hue, 50, 85);
 8026a48:	4b39      	ldr	r3, [pc, #228]	; (8026b30 <list_init+0x100>)
 8026a4a:	881b      	ldrh	r3, [r3, #0]
 8026a4c:	4c37      	ldr	r4, [pc, #220]	; (8026b2c <list_init+0xfc>)
 8026a4e:	2255      	movs	r2, #85	; 0x55
 8026a50:	2132      	movs	r1, #50	; 0x32
 8026a52:	4618      	mov	r0, r3
 8026a54:	f7f5 fa02 	bl	801be5c <lv_color_hsv_to_rgb>
 8026a58:	8160      	strh	r0, [r4, #10]
    list_rel.body.border.opa   = LV_OPA_COVER;
 8026a5a:	4b34      	ldr	r3, [pc, #208]	; (8026b2c <list_init+0xfc>)
 8026a5c:	22ff      	movs	r2, #255	; 0xff
 8026a5e:	73da      	strb	r2, [r3, #15]
    list_rel.text.color        = lv_color_hsv_to_rgb(_hue, 10, 94);
 8026a60:	4b33      	ldr	r3, [pc, #204]	; (8026b30 <list_init+0x100>)
 8026a62:	881b      	ldrh	r3, [r3, #0]
 8026a64:	4c31      	ldr	r4, [pc, #196]	; (8026b2c <list_init+0xfc>)
 8026a66:	225e      	movs	r2, #94	; 0x5e
 8026a68:	210a      	movs	r1, #10
 8026a6a:	4618      	mov	r0, r3
 8026a6c:	f7f5 f9f6 	bl	801be5c <lv_color_hsv_to_rgb>
 8026a70:	8420      	strh	r0, [r4, #32]
    list_rel.text.font         = _font;
 8026a72:	4b30      	ldr	r3, [pc, #192]	; (8026b34 <list_init+0x104>)
 8026a74:	681b      	ldr	r3, [r3, #0]
 8026a76:	4a2d      	ldr	r2, [pc, #180]	; (8026b2c <list_init+0xfc>)
 8026a78:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&list_pr, &list_rel);
 8026a7a:	492c      	ldr	r1, [pc, #176]	; (8026b2c <list_init+0xfc>)
 8026a7c:	482e      	ldr	r0, [pc, #184]	; (8026b38 <list_init+0x108>)
 8026a7e:	f7ec fff1 	bl	8013a64 <lv_style_copy>
    list_pr.body.opa        = LV_OPA_COVER;
 8026a82:	4b2d      	ldr	r3, [pc, #180]	; (8026b38 <list_init+0x108>)
 8026a84:	22ff      	movs	r2, #255	; 0xff
 8026a86:	721a      	strb	r2, [r3, #8]
    list_pr.body.main_color = lv_color_hsv_to_rgb(_hue, 34, 41);
 8026a88:	4b29      	ldr	r3, [pc, #164]	; (8026b30 <list_init+0x100>)
 8026a8a:	881b      	ldrh	r3, [r3, #0]
 8026a8c:	4c2a      	ldr	r4, [pc, #168]	; (8026b38 <list_init+0x108>)
 8026a8e:	2229      	movs	r2, #41	; 0x29
 8026a90:	2122      	movs	r1, #34	; 0x22
 8026a92:	4618      	mov	r0, r3
 8026a94:	f7f5 f9e2 	bl	801be5c <lv_color_hsv_to_rgb>
 8026a98:	8060      	strh	r0, [r4, #2]
    list_pr.text.color      = lv_color_hsv_to_rgb(_hue, 7, 96);
 8026a9a:	4b25      	ldr	r3, [pc, #148]	; (8026b30 <list_init+0x100>)
 8026a9c:	881b      	ldrh	r3, [r3, #0]
 8026a9e:	4c26      	ldr	r4, [pc, #152]	; (8026b38 <list_init+0x108>)
 8026aa0:	2260      	movs	r2, #96	; 0x60
 8026aa2:	2107      	movs	r1, #7
 8026aa4:	4618      	mov	r0, r3
 8026aa6:	f7f5 f9d9 	bl	801be5c <lv_color_hsv_to_rgb>
 8026aaa:	8420      	strh	r0, [r4, #32]

    lv_style_copy(&list_trel, &list_rel);
 8026aac:	491f      	ldr	r1, [pc, #124]	; (8026b2c <list_init+0xfc>)
 8026aae:	4823      	ldr	r0, [pc, #140]	; (8026b3c <list_init+0x10c>)
 8026ab0:	f7ec ffd8 	bl	8013a64 <lv_style_copy>
    lv_style_copy(&list_tpr, &list_pr);
 8026ab4:	4920      	ldr	r1, [pc, #128]	; (8026b38 <list_init+0x108>)
 8026ab6:	4822      	ldr	r0, [pc, #136]	; (8026b40 <list_init+0x110>)
 8026ab8:	f7ec ffd4 	bl	8013a64 <lv_style_copy>
    lv_style_copy(&list_ina, &def);
 8026abc:	491a      	ldr	r1, [pc, #104]	; (8026b28 <list_init+0xf8>)
 8026abe:	4821      	ldr	r0, [pc, #132]	; (8026b44 <list_init+0x114>)
 8026ac0:	f7ec ffd0 	bl	8013a64 <lv_style_copy>

    lv_style_copy(&list_bg, &list_rel);
 8026ac4:	4919      	ldr	r1, [pc, #100]	; (8026b2c <list_init+0xfc>)
 8026ac6:	4820      	ldr	r0, [pc, #128]	; (8026b48 <list_init+0x118>)
 8026ac8:	f7ec ffcc 	bl	8013a64 <lv_style_copy>
    list_bg.body.padding.left   = 0;
 8026acc:	4b1e      	ldr	r3, [pc, #120]	; (8026b48 <list_init+0x118>)
 8026ace:	2200      	movs	r2, #0
 8026ad0:	835a      	strh	r2, [r3, #26]
    list_bg.body.padding.right  = 0;
 8026ad2:	4b1d      	ldr	r3, [pc, #116]	; (8026b48 <list_init+0x118>)
 8026ad4:	2200      	movs	r2, #0
 8026ad6:	839a      	strh	r2, [r3, #28]
    list_bg.body.padding.top    = 0;
 8026ad8:	4b1b      	ldr	r3, [pc, #108]	; (8026b48 <list_init+0x118>)
 8026ada:	2200      	movs	r2, #0
 8026adc:	82da      	strh	r2, [r3, #22]
    list_bg.body.padding.bottom = 0;
 8026ade:	4b1a      	ldr	r3, [pc, #104]	; (8026b48 <list_init+0x118>)
 8026ae0:	2200      	movs	r2, #0
 8026ae2:	831a      	strh	r2, [r3, #24]

    theme.style.list.sb          = &sb;
 8026ae4:	4b19      	ldr	r3, [pc, #100]	; (8026b4c <list_init+0x11c>)
 8026ae6:	4a1a      	ldr	r2, [pc, #104]	; (8026b50 <list_init+0x120>)
 8026ae8:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138
    theme.style.list.bg          = &list_bg;
 8026aec:	4b17      	ldr	r3, [pc, #92]	; (8026b4c <list_init+0x11c>)
 8026aee:	4a16      	ldr	r2, [pc, #88]	; (8026b48 <list_init+0x118>)
 8026af0:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
    theme.style.list.scrl        = &lv_style_transp_tight;
 8026af4:	4b15      	ldr	r3, [pc, #84]	; (8026b4c <list_init+0x11c>)
 8026af6:	4a17      	ldr	r2, [pc, #92]	; (8026b54 <list_init+0x124>)
 8026af8:	f8c3 2134 	str.w	r2, [r3, #308]	; 0x134
    theme.style.list.btn.rel     = &list_rel;
 8026afc:	4b13      	ldr	r3, [pc, #76]	; (8026b4c <list_init+0x11c>)
 8026afe:	4a0b      	ldr	r2, [pc, #44]	; (8026b2c <list_init+0xfc>)
 8026b00:	f8c3 213c 	str.w	r2, [r3, #316]	; 0x13c
    theme.style.list.btn.pr      = &list_pr;
 8026b04:	4b11      	ldr	r3, [pc, #68]	; (8026b4c <list_init+0x11c>)
 8026b06:	4a0c      	ldr	r2, [pc, #48]	; (8026b38 <list_init+0x108>)
 8026b08:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
    theme.style.list.btn.tgl_rel = &list_trel;
 8026b0c:	4b0f      	ldr	r3, [pc, #60]	; (8026b4c <list_init+0x11c>)
 8026b0e:	4a0b      	ldr	r2, [pc, #44]	; (8026b3c <list_init+0x10c>)
 8026b10:	f8c3 2144 	str.w	r2, [r3, #324]	; 0x144
    theme.style.list.btn.tgl_pr  = &list_tpr;
 8026b14:	4b0d      	ldr	r3, [pc, #52]	; (8026b4c <list_init+0x11c>)
 8026b16:	4a0a      	ldr	r2, [pc, #40]	; (8026b40 <list_init+0x110>)
 8026b18:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    theme.style.list.btn.ina     = &list_ina;
 8026b1c:	4b0b      	ldr	r3, [pc, #44]	; (8026b4c <list_init+0x11c>)
 8026b1e:	4a09      	ldr	r2, [pc, #36]	; (8026b44 <list_init+0x114>)
 8026b20:	f8c3 214c 	str.w	r2, [r3, #332]	; 0x14c
#endif
}
 8026b24:	bf00      	nop
 8026b26:	bd98      	pop	{r3, r4, r7, pc}
 8026b28:	2000c5b0 	.word	0x2000c5b0
 8026b2c:	2000d000 	.word	0x2000d000
 8026b30:	2000c3f4 	.word	0x2000c3f4
 8026b34:	2000c3f8 	.word	0x2000c3f8
 8026b38:	2000d03c 	.word	0x2000d03c
 8026b3c:	2000d078 	.word	0x2000d078
 8026b40:	2000d0b4 	.word	0x2000d0b4
 8026b44:	2000d0f0 	.word	0x2000d0f0
 8026b48:	2000d12c 	.word	0x2000d12c
 8026b4c:	2000c3fc 	.word	0x2000c3fc
 8026b50:	2000c6a0 	.word	0x2000c6a0
 8026b54:	2000dd64 	.word	0x2000dd64

08026b58 <ddlist_init>:

static void ddlist_init(void)
{
 8026b58:	b598      	push	{r3, r4, r7, lr}
 8026b5a:	af00      	add	r7, sp, #0
#if LV_USE_DDLIST != 0
    lv_style_copy(&ddlist_bg, &panel);
 8026b5c:	4919      	ldr	r1, [pc, #100]	; (8026bc4 <ddlist_init+0x6c>)
 8026b5e:	481a      	ldr	r0, [pc, #104]	; (8026bc8 <ddlist_init+0x70>)
 8026b60:	f7ec ff80 	bl	8013a64 <lv_style_copy>
    ddlist_bg.text.line_space     = LV_DPI / 8;
 8026b64:	4b18      	ldr	r3, [pc, #96]	; (8026bc8 <ddlist_init+0x70>)
 8026b66:	220c      	movs	r2, #12
 8026b68:	855a      	strh	r2, [r3, #42]	; 0x2a
    ddlist_bg.body.padding.left   = LV_DPI / 6;
 8026b6a:	4b17      	ldr	r3, [pc, #92]	; (8026bc8 <ddlist_init+0x70>)
 8026b6c:	2210      	movs	r2, #16
 8026b6e:	835a      	strh	r2, [r3, #26]
    ddlist_bg.body.padding.right  = LV_DPI / 6;
 8026b70:	4b15      	ldr	r3, [pc, #84]	; (8026bc8 <ddlist_init+0x70>)
 8026b72:	2210      	movs	r2, #16
 8026b74:	839a      	strh	r2, [r3, #28]
    ddlist_bg.body.padding.top    = LV_DPI / 6;
 8026b76:	4b14      	ldr	r3, [pc, #80]	; (8026bc8 <ddlist_init+0x70>)
 8026b78:	2210      	movs	r2, #16
 8026b7a:	82da      	strh	r2, [r3, #22]
    ddlist_bg.body.padding.bottom = LV_DPI / 6;
 8026b7c:	4b12      	ldr	r3, [pc, #72]	; (8026bc8 <ddlist_init+0x70>)
 8026b7e:	2210      	movs	r2, #16
 8026b80:	831a      	strh	r2, [r3, #24]

    lv_style_copy(&ddlist_sel, &panel);
 8026b82:	4910      	ldr	r1, [pc, #64]	; (8026bc4 <ddlist_init+0x6c>)
 8026b84:	4811      	ldr	r0, [pc, #68]	; (8026bcc <ddlist_init+0x74>)
 8026b86:	f7ec ff6d 	bl	8013a64 <lv_style_copy>
    ddlist_sel.body.main_color = lv_color_hsv_to_rgb(_hue, 45, 70);
 8026b8a:	4b11      	ldr	r3, [pc, #68]	; (8026bd0 <ddlist_init+0x78>)
 8026b8c:	881b      	ldrh	r3, [r3, #0]
 8026b8e:	4c0f      	ldr	r4, [pc, #60]	; (8026bcc <ddlist_init+0x74>)
 8026b90:	2246      	movs	r2, #70	; 0x46
 8026b92:	212d      	movs	r1, #45	; 0x2d
 8026b94:	4618      	mov	r0, r3
 8026b96:	f7f5 f961 	bl	801be5c <lv_color_hsv_to_rgb>
 8026b9a:	8060      	strh	r0, [r4, #2]
    ddlist_sel.body.opa        = LV_OPA_COVER;
 8026b9c:	4b0b      	ldr	r3, [pc, #44]	; (8026bcc <ddlist_init+0x74>)
 8026b9e:	22ff      	movs	r2, #255	; 0xff
 8026ba0:	721a      	strb	r2, [r3, #8]
    ddlist_sel.body.radius     = 0;
 8026ba2:	4b0a      	ldr	r3, [pc, #40]	; (8026bcc <ddlist_init+0x74>)
 8026ba4:	2200      	movs	r2, #0
 8026ba6:	80da      	strh	r2, [r3, #6]

    theme.style.ddlist.bg  = &ddlist_bg;
 8026ba8:	4b0a      	ldr	r3, [pc, #40]	; (8026bd4 <ddlist_init+0x7c>)
 8026baa:	4a07      	ldr	r2, [pc, #28]	; (8026bc8 <ddlist_init+0x70>)
 8026bac:	f8c3 2150 	str.w	r2, [r3, #336]	; 0x150
    theme.style.ddlist.sel = &ddlist_sel;
 8026bb0:	4b08      	ldr	r3, [pc, #32]	; (8026bd4 <ddlist_init+0x7c>)
 8026bb2:	4a06      	ldr	r2, [pc, #24]	; (8026bcc <ddlist_init+0x74>)
 8026bb4:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
    theme.style.ddlist.sb  = &sb;
 8026bb8:	4b06      	ldr	r3, [pc, #24]	; (8026bd4 <ddlist_init+0x7c>)
 8026bba:	4a07      	ldr	r2, [pc, #28]	; (8026bd8 <ddlist_init+0x80>)
 8026bbc:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
#endif
}
 8026bc0:	bf00      	nop
 8026bc2:	bd98      	pop	{r3, r4, r7, pc}
 8026bc4:	2000c664 	.word	0x2000c664
 8026bc8:	2000c8f8 	.word	0x2000c8f8
 8026bcc:	2000c934 	.word	0x2000c934
 8026bd0:	2000c3f4 	.word	0x2000c3f4
 8026bd4:	2000c3fc 	.word	0x2000c3fc
 8026bd8:	2000c6a0 	.word	0x2000c6a0

08026bdc <roller_init>:

static void roller_init(void)
{
 8026bdc:	b598      	push	{r3, r4, r7, lr}
 8026bde:	af00      	add	r7, sp, #0
#if LV_USE_ROLLER != 0
    static lv_style_t roller_bg, roller_sel;
    lv_style_copy(&roller_bg, &ddlist_bg);
 8026be0:	4921      	ldr	r1, [pc, #132]	; (8026c68 <roller_init+0x8c>)
 8026be2:	4822      	ldr	r0, [pc, #136]	; (8026c6c <roller_init+0x90>)
 8026be4:	f7ec ff3e 	bl	8013a64 <lv_style_copy>
    roller_bg.text.line_space   = LV_DPI / 6;
 8026be8:	4b20      	ldr	r3, [pc, #128]	; (8026c6c <roller_init+0x90>)
 8026bea:	2210      	movs	r2, #16
 8026bec:	855a      	strh	r2, [r3, #42]	; 0x2a
    roller_bg.body.radius       = LV_DPI / 20;
 8026bee:	4b1f      	ldr	r3, [pc, #124]	; (8026c6c <roller_init+0x90>)
 8026bf0:	2205      	movs	r2, #5
 8026bf2:	80da      	strh	r2, [r3, #6]
    roller_bg.body.main_color   = lv_color_hex3(0x500);
 8026bf4:	4c1d      	ldr	r4, [pc, #116]	; (8026c6c <roller_init+0x90>)
 8026bf6:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 8026bfa:	f7fe ff74 	bl	8025ae6 <lv_color_hex3>
 8026bfe:	8060      	strh	r0, [r4, #2]
    roller_bg.body.border.opa   = LV_OPA_30;
 8026c00:	4b1a      	ldr	r3, [pc, #104]	; (8026c6c <roller_init+0x90>)
 8026c02:	224c      	movs	r2, #76	; 0x4c
 8026c04:	73da      	strb	r2, [r3, #15]
    roller_bg.text.opa          = LV_OPA_70;
 8026c06:	4b19      	ldr	r3, [pc, #100]	; (8026c6c <roller_init+0x90>)
 8026c08:	22b2      	movs	r2, #178	; 0xb2
 8026c0a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    roller_bg.text.color        = lv_color_hsv_to_rgb(_hue, 20, 70);
 8026c0e:	4b18      	ldr	r3, [pc, #96]	; (8026c70 <roller_init+0x94>)
 8026c10:	881b      	ldrh	r3, [r3, #0]
 8026c12:	4c16      	ldr	r4, [pc, #88]	; (8026c6c <roller_init+0x90>)
 8026c14:	2246      	movs	r2, #70	; 0x46
 8026c16:	2114      	movs	r1, #20
 8026c18:	4618      	mov	r0, r3
 8026c1a:	f7f5 f91f 	bl	801be5c <lv_color_hsv_to_rgb>
 8026c1e:	8420      	strh	r0, [r4, #32]
    roller_bg.body.shadow.width = 0;
 8026c20:	4b12      	ldr	r3, [pc, #72]	; (8026c6c <roller_init+0x90>)
 8026c22:	2200      	movs	r2, #0
 8026c24:	825a      	strh	r2, [r3, #18]

    lv_style_copy(&roller_sel, &panel);
 8026c26:	4913      	ldr	r1, [pc, #76]	; (8026c74 <roller_init+0x98>)
 8026c28:	4813      	ldr	r0, [pc, #76]	; (8026c78 <roller_init+0x9c>)
 8026c2a:	f7ec ff1b 	bl	8013a64 <lv_style_copy>
    roller_sel.body.opa    = LV_OPA_TRANSP;
 8026c2e:	4b12      	ldr	r3, [pc, #72]	; (8026c78 <roller_init+0x9c>)
 8026c30:	2200      	movs	r2, #0
 8026c32:	721a      	strb	r2, [r3, #8]
    roller_sel.body.radius = 0;
 8026c34:	4b10      	ldr	r3, [pc, #64]	; (8026c78 <roller_init+0x9c>)
 8026c36:	2200      	movs	r2, #0
 8026c38:	80da      	strh	r2, [r3, #6]
    roller_sel.text.opa    = LV_OPA_COVER;
 8026c3a:	4b0f      	ldr	r3, [pc, #60]	; (8026c78 <roller_init+0x9c>)
 8026c3c:	22ff      	movs	r2, #255	; 0xff
 8026c3e:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
    roller_sel.text.color  = lv_color_hsv_to_rgb(_hue, 70, 95);
 8026c42:	4b0b      	ldr	r3, [pc, #44]	; (8026c70 <roller_init+0x94>)
 8026c44:	881b      	ldrh	r3, [r3, #0]
 8026c46:	4c0c      	ldr	r4, [pc, #48]	; (8026c78 <roller_init+0x9c>)
 8026c48:	225f      	movs	r2, #95	; 0x5f
 8026c4a:	2146      	movs	r1, #70	; 0x46
 8026c4c:	4618      	mov	r0, r3
 8026c4e:	f7f5 f905 	bl	801be5c <lv_color_hsv_to_rgb>
 8026c52:	8420      	strh	r0, [r4, #32]

    theme.style.roller.bg  = &roller_bg;
 8026c54:	4b09      	ldr	r3, [pc, #36]	; (8026c7c <roller_init+0xa0>)
 8026c56:	4a05      	ldr	r2, [pc, #20]	; (8026c6c <roller_init+0x90>)
 8026c58:	f8c3 215c 	str.w	r2, [r3, #348]	; 0x15c
    theme.style.roller.sel = &roller_sel;
 8026c5c:	4b07      	ldr	r3, [pc, #28]	; (8026c7c <roller_init+0xa0>)
 8026c5e:	4a06      	ldr	r2, [pc, #24]	; (8026c78 <roller_init+0x9c>)
 8026c60:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
#endif
}
 8026c64:	bf00      	nop
 8026c66:	bd98      	pop	{r3, r4, r7, pc}
 8026c68:	2000c8f8 	.word	0x2000c8f8
 8026c6c:	2000d168 	.word	0x2000d168
 8026c70:	2000c3f4 	.word	0x2000c3f4
 8026c74:	2000c664 	.word	0x2000c664
 8026c78:	2000d1a4 	.word	0x2000d1a4
 8026c7c:	2000c3fc 	.word	0x2000c3fc

08026c80 <tabview_init>:

static void tabview_init(void)
{
 8026c80:	b598      	push	{r3, r4, r7, lr}
 8026c82:	af00      	add	r7, sp, #0
#if LV_USE_TABVIEW != 0
    static lv_style_t tab_rel, tab_pr, tab_trel, tab_tpr, tab_indic;
    lv_style_copy(&tab_rel, &def);
 8026c84:	4960      	ldr	r1, [pc, #384]	; (8026e08 <tabview_init+0x188>)
 8026c86:	4861      	ldr	r0, [pc, #388]	; (8026e0c <tabview_init+0x18c>)
 8026c88:	f7ec feec 	bl	8013a64 <lv_style_copy>
    tab_rel.body.main_color     = lv_color_hex3(0x500);
 8026c8c:	4c5f      	ldr	r4, [pc, #380]	; (8026e0c <tabview_init+0x18c>)
 8026c8e:	f44f 60a0 	mov.w	r0, #1280	; 0x500
 8026c92:	f7fe ff28 	bl	8025ae6 <lv_color_hex3>
 8026c96:	8060      	strh	r0, [r4, #2]
    tab_rel.body.padding.left   = 0;
 8026c98:	4b5c      	ldr	r3, [pc, #368]	; (8026e0c <tabview_init+0x18c>)
 8026c9a:	2200      	movs	r2, #0
 8026c9c:	835a      	strh	r2, [r3, #26]
    tab_rel.body.padding.right  = 0;
 8026c9e:	4b5b      	ldr	r3, [pc, #364]	; (8026e0c <tabview_init+0x18c>)
 8026ca0:	2200      	movs	r2, #0
 8026ca2:	839a      	strh	r2, [r3, #28]
    tab_rel.body.padding.top    = LV_DPI / 6;
 8026ca4:	4b59      	ldr	r3, [pc, #356]	; (8026e0c <tabview_init+0x18c>)
 8026ca6:	2210      	movs	r2, #16
 8026ca8:	82da      	strh	r2, [r3, #22]
    tab_rel.body.padding.bottom = LV_DPI / 6;
 8026caa:	4b58      	ldr	r3, [pc, #352]	; (8026e0c <tabview_init+0x18c>)
 8026cac:	2210      	movs	r2, #16
 8026cae:	831a      	strh	r2, [r3, #24]
    tab_rel.body.padding.inner  = 0;
 8026cb0:	4b56      	ldr	r3, [pc, #344]	; (8026e0c <tabview_init+0x18c>)
 8026cb2:	2200      	movs	r2, #0
 8026cb4:	83da      	strh	r2, [r3, #30]
    tab_rel.body.border.width   = 1;
 8026cb6:	4b55      	ldr	r3, [pc, #340]	; (8026e0c <tabview_init+0x18c>)
 8026cb8:	2201      	movs	r2, #1
 8026cba:	819a      	strh	r2, [r3, #12]
    tab_rel.body.border.color   = LV_COLOR_SILVER;
 8026cbc:	4a53      	ldr	r2, [pc, #332]	; (8026e0c <tabview_init+0x18c>)
 8026cbe:	4b54      	ldr	r3, [pc, #336]	; (8026e10 <tabview_init+0x190>)
 8026cc0:	881b      	ldrh	r3, [r3, #0]
 8026cc2:	8153      	strh	r3, [r2, #10]
    tab_rel.body.border.opa     = LV_OPA_40;
 8026cc4:	4b51      	ldr	r3, [pc, #324]	; (8026e0c <tabview_init+0x18c>)
 8026cc6:	2266      	movs	r2, #102	; 0x66
 8026cc8:	73da      	strb	r2, [r3, #15]
    tab_rel.text.color          = lv_color_hex3(0xDDD);
 8026cca:	4c50      	ldr	r4, [pc, #320]	; (8026e0c <tabview_init+0x18c>)
 8026ccc:	f640 50dd 	movw	r0, #3549	; 0xddd
 8026cd0:	f7fe ff09 	bl	8025ae6 <lv_color_hex3>
 8026cd4:	8420      	strh	r0, [r4, #32]
    tab_rel.text.font           = _font;
 8026cd6:	4b4f      	ldr	r3, [pc, #316]	; (8026e14 <tabview_init+0x194>)
 8026cd8:	681b      	ldr	r3, [r3, #0]
 8026cda:	4a4c      	ldr	r2, [pc, #304]	; (8026e0c <tabview_init+0x18c>)
 8026cdc:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&tab_pr, &tab_rel);
 8026cde:	494b      	ldr	r1, [pc, #300]	; (8026e0c <tabview_init+0x18c>)
 8026ce0:	484d      	ldr	r0, [pc, #308]	; (8026e18 <tabview_init+0x198>)
 8026ce2:	f7ec febf 	bl	8013a64 <lv_style_copy>
    tab_pr.body.main_color = lv_color_hex3(0x005);
 8026ce6:	4c4c      	ldr	r4, [pc, #304]	; (8026e18 <tabview_init+0x198>)
 8026ce8:	2005      	movs	r0, #5
 8026cea:	f7fe fefc 	bl	8025ae6 <lv_color_hex3>
 8026cee:	8060      	strh	r0, [r4, #2]

    lv_style_copy(&tab_trel, &def);
 8026cf0:	4945      	ldr	r1, [pc, #276]	; (8026e08 <tabview_init+0x188>)
 8026cf2:	484a      	ldr	r0, [pc, #296]	; (8026e1c <tabview_init+0x19c>)
 8026cf4:	f7ec feb6 	bl	8013a64 <lv_style_copy>
    tab_trel.body.opa            = LV_OPA_TRANSP;
 8026cf8:	4b48      	ldr	r3, [pc, #288]	; (8026e1c <tabview_init+0x19c>)
 8026cfa:	2200      	movs	r2, #0
 8026cfc:	721a      	strb	r2, [r3, #8]
    tab_trel.body.padding.left   = 0;
 8026cfe:	4b47      	ldr	r3, [pc, #284]	; (8026e1c <tabview_init+0x19c>)
 8026d00:	2200      	movs	r2, #0
 8026d02:	835a      	strh	r2, [r3, #26]
    tab_trel.body.padding.right  = 0;
 8026d04:	4b45      	ldr	r3, [pc, #276]	; (8026e1c <tabview_init+0x19c>)
 8026d06:	2200      	movs	r2, #0
 8026d08:	839a      	strh	r2, [r3, #28]
    tab_trel.body.padding.top    = LV_DPI / 6;
 8026d0a:	4b44      	ldr	r3, [pc, #272]	; (8026e1c <tabview_init+0x19c>)
 8026d0c:	2210      	movs	r2, #16
 8026d0e:	82da      	strh	r2, [r3, #22]
    tab_trel.body.padding.bottom = LV_DPI / 6;
 8026d10:	4b42      	ldr	r3, [pc, #264]	; (8026e1c <tabview_init+0x19c>)
 8026d12:	2210      	movs	r2, #16
 8026d14:	831a      	strh	r2, [r3, #24]
    tab_trel.body.padding.inner  = 0;
 8026d16:	4b41      	ldr	r3, [pc, #260]	; (8026e1c <tabview_init+0x19c>)
 8026d18:	2200      	movs	r2, #0
 8026d1a:	83da      	strh	r2, [r3, #30]
    tab_trel.body.border.width   = 1;
 8026d1c:	4b3f      	ldr	r3, [pc, #252]	; (8026e1c <tabview_init+0x19c>)
 8026d1e:	2201      	movs	r2, #1
 8026d20:	819a      	strh	r2, [r3, #12]
    tab_trel.body.border.color   = LV_COLOR_SILVER;
 8026d22:	4a3e      	ldr	r2, [pc, #248]	; (8026e1c <tabview_init+0x19c>)
 8026d24:	4b3a      	ldr	r3, [pc, #232]	; (8026e10 <tabview_init+0x190>)
 8026d26:	881b      	ldrh	r3, [r3, #0]
 8026d28:	8153      	strh	r3, [r2, #10]
    tab_trel.body.border.opa     = LV_OPA_40;
 8026d2a:	4b3c      	ldr	r3, [pc, #240]	; (8026e1c <tabview_init+0x19c>)
 8026d2c:	2266      	movs	r2, #102	; 0x66
 8026d2e:	73da      	strb	r2, [r3, #15]
    tab_trel.text.color          = lv_color_hsv_to_rgb(_hue, 10, 94);
 8026d30:	4b3b      	ldr	r3, [pc, #236]	; (8026e20 <tabview_init+0x1a0>)
 8026d32:	881b      	ldrh	r3, [r3, #0]
 8026d34:	4c39      	ldr	r4, [pc, #228]	; (8026e1c <tabview_init+0x19c>)
 8026d36:	225e      	movs	r2, #94	; 0x5e
 8026d38:	210a      	movs	r1, #10
 8026d3a:	4618      	mov	r0, r3
 8026d3c:	f7f5 f88e 	bl	801be5c <lv_color_hsv_to_rgb>
 8026d40:	8420      	strh	r0, [r4, #32]
    tab_trel.text.font           = _font;
 8026d42:	4b34      	ldr	r3, [pc, #208]	; (8026e14 <tabview_init+0x194>)
 8026d44:	681b      	ldr	r3, [r3, #0]
 8026d46:	4a35      	ldr	r2, [pc, #212]	; (8026e1c <tabview_init+0x19c>)
 8026d48:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&tab_tpr, &def);
 8026d4a:	492f      	ldr	r1, [pc, #188]	; (8026e08 <tabview_init+0x188>)
 8026d4c:	4835      	ldr	r0, [pc, #212]	; (8026e24 <tabview_init+0x1a4>)
 8026d4e:	f7ec fe89 	bl	8013a64 <lv_style_copy>
    tab_tpr.body.main_color     = LV_COLOR_GRAY;
 8026d52:	4a34      	ldr	r2, [pc, #208]	; (8026e24 <tabview_init+0x1a4>)
 8026d54:	4b34      	ldr	r3, [pc, #208]	; (8026e28 <tabview_init+0x1a8>)
 8026d56:	881b      	ldrh	r3, [r3, #0]
 8026d58:	8053      	strh	r3, [r2, #2]
    tab_tpr.body.padding.left   = 0;
 8026d5a:	4b32      	ldr	r3, [pc, #200]	; (8026e24 <tabview_init+0x1a4>)
 8026d5c:	2200      	movs	r2, #0
 8026d5e:	835a      	strh	r2, [r3, #26]
    tab_tpr.body.padding.right  = 0;
 8026d60:	4b30      	ldr	r3, [pc, #192]	; (8026e24 <tabview_init+0x1a4>)
 8026d62:	2200      	movs	r2, #0
 8026d64:	839a      	strh	r2, [r3, #28]
    tab_tpr.body.padding.top    = LV_DPI / 6;
 8026d66:	4b2f      	ldr	r3, [pc, #188]	; (8026e24 <tabview_init+0x1a4>)
 8026d68:	2210      	movs	r2, #16
 8026d6a:	82da      	strh	r2, [r3, #22]
    tab_tpr.body.padding.bottom = LV_DPI / 6;
 8026d6c:	4b2d      	ldr	r3, [pc, #180]	; (8026e24 <tabview_init+0x1a4>)
 8026d6e:	2210      	movs	r2, #16
 8026d70:	831a      	strh	r2, [r3, #24]
    tab_tpr.body.padding.inner  = 0;
 8026d72:	4b2c      	ldr	r3, [pc, #176]	; (8026e24 <tabview_init+0x1a4>)
 8026d74:	2200      	movs	r2, #0
 8026d76:	83da      	strh	r2, [r3, #30]
    tab_tpr.body.border.width   = 1;
 8026d78:	4b2a      	ldr	r3, [pc, #168]	; (8026e24 <tabview_init+0x1a4>)
 8026d7a:	2201      	movs	r2, #1
 8026d7c:	819a      	strh	r2, [r3, #12]
    tab_tpr.body.border.color   = LV_COLOR_SILVER;
 8026d7e:	4a29      	ldr	r2, [pc, #164]	; (8026e24 <tabview_init+0x1a4>)
 8026d80:	4b23      	ldr	r3, [pc, #140]	; (8026e10 <tabview_init+0x190>)
 8026d82:	881b      	ldrh	r3, [r3, #0]
 8026d84:	8153      	strh	r3, [r2, #10]
    tab_tpr.body.border.opa     = LV_OPA_40;
 8026d86:	4b27      	ldr	r3, [pc, #156]	; (8026e24 <tabview_init+0x1a4>)
 8026d88:	2266      	movs	r2, #102	; 0x66
 8026d8a:	73da      	strb	r2, [r3, #15]
    tab_tpr.text.color          = lv_color_hsv_to_rgb(_hue, 10, 94);
 8026d8c:	4b24      	ldr	r3, [pc, #144]	; (8026e20 <tabview_init+0x1a0>)
 8026d8e:	881b      	ldrh	r3, [r3, #0]
 8026d90:	4c24      	ldr	r4, [pc, #144]	; (8026e24 <tabview_init+0x1a4>)
 8026d92:	225e      	movs	r2, #94	; 0x5e
 8026d94:	210a      	movs	r1, #10
 8026d96:	4618      	mov	r0, r3
 8026d98:	f7f5 f860 	bl	801be5c <lv_color_hsv_to_rgb>
 8026d9c:	8420      	strh	r0, [r4, #32]
    tab_tpr.text.font           = _font;
 8026d9e:	4b1d      	ldr	r3, [pc, #116]	; (8026e14 <tabview_init+0x194>)
 8026da0:	681b      	ldr	r3, [r3, #0]
 8026da2:	4a20      	ldr	r2, [pc, #128]	; (8026e24 <tabview_init+0x1a4>)
 8026da4:	6253      	str	r3, [r2, #36]	; 0x24

    lv_style_copy(&tab_indic, &def);
 8026da6:	4918      	ldr	r1, [pc, #96]	; (8026e08 <tabview_init+0x188>)
 8026da8:	4820      	ldr	r0, [pc, #128]	; (8026e2c <tabview_init+0x1ac>)
 8026daa:	f7ec fe5b 	bl	8013a64 <lv_style_copy>
    tab_indic.body.border.width  = 0;
 8026dae:	4b1f      	ldr	r3, [pc, #124]	; (8026e2c <tabview_init+0x1ac>)
 8026db0:	2200      	movs	r2, #0
 8026db2:	819a      	strh	r2, [r3, #12]
    tab_indic.body.main_color    = lv_color_hsv_to_rgb(_hue, 80, 87);
 8026db4:	4b1a      	ldr	r3, [pc, #104]	; (8026e20 <tabview_init+0x1a0>)
 8026db6:	881b      	ldrh	r3, [r3, #0]
 8026db8:	4c1c      	ldr	r4, [pc, #112]	; (8026e2c <tabview_init+0x1ac>)
 8026dba:	2257      	movs	r2, #87	; 0x57
 8026dbc:	2150      	movs	r1, #80	; 0x50
 8026dbe:	4618      	mov	r0, r3
 8026dc0:	f7f5 f84c 	bl	801be5c <lv_color_hsv_to_rgb>
 8026dc4:	8060      	strh	r0, [r4, #2]
    tab_indic.body.padding.inner = LV_DPI / 10; /*Indicator height*/
 8026dc6:	4b19      	ldr	r3, [pc, #100]	; (8026e2c <tabview_init+0x1ac>)
 8026dc8:	220a      	movs	r2, #10
 8026dca:	83da      	strh	r2, [r3, #30]

    theme.style.tabview.bg          = &bg;
 8026dcc:	4b18      	ldr	r3, [pc, #96]	; (8026e30 <tabview_init+0x1b0>)
 8026dce:	4a19      	ldr	r2, [pc, #100]	; (8026e34 <tabview_init+0x1b4>)
 8026dd0:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
    theme.style.tabview.indic       = &tab_indic;
 8026dd4:	4b16      	ldr	r3, [pc, #88]	; (8026e30 <tabview_init+0x1b0>)
 8026dd6:	4a15      	ldr	r2, [pc, #84]	; (8026e2c <tabview_init+0x1ac>)
 8026dd8:	f8c3 2168 	str.w	r2, [r3, #360]	; 0x168
    theme.style.tabview.btn.bg      = &lv_style_transp_tight;
 8026ddc:	4b14      	ldr	r3, [pc, #80]	; (8026e30 <tabview_init+0x1b0>)
 8026dde:	4a16      	ldr	r2, [pc, #88]	; (8026e38 <tabview_init+0x1b8>)
 8026de0:	f8c3 216c 	str.w	r2, [r3, #364]	; 0x16c
    theme.style.tabview.btn.rel     = &tab_rel;
 8026de4:	4b12      	ldr	r3, [pc, #72]	; (8026e30 <tabview_init+0x1b0>)
 8026de6:	4a09      	ldr	r2, [pc, #36]	; (8026e0c <tabview_init+0x18c>)
 8026de8:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
    theme.style.tabview.btn.pr      = &tab_pr;
 8026dec:	4b10      	ldr	r3, [pc, #64]	; (8026e30 <tabview_init+0x1b0>)
 8026dee:	4a0a      	ldr	r2, [pc, #40]	; (8026e18 <tabview_init+0x198>)
 8026df0:	f8c3 2174 	str.w	r2, [r3, #372]	; 0x174
    theme.style.tabview.btn.tgl_rel = &tab_trel;
 8026df4:	4b0e      	ldr	r3, [pc, #56]	; (8026e30 <tabview_init+0x1b0>)
 8026df6:	4a09      	ldr	r2, [pc, #36]	; (8026e1c <tabview_init+0x19c>)
 8026df8:	f8c3 2178 	str.w	r2, [r3, #376]	; 0x178
    theme.style.tabview.btn.tgl_pr  = &tab_tpr;
 8026dfc:	4b0c      	ldr	r3, [pc, #48]	; (8026e30 <tabview_init+0x1b0>)
 8026dfe:	4a09      	ldr	r2, [pc, #36]	; (8026e24 <tabview_init+0x1a4>)
 8026e00:	f8c3 217c 	str.w	r2, [r3, #380]	; 0x17c
#endif
}
 8026e04:	bf00      	nop
 8026e06:	bd98      	pop	{r3, r4, r7, pc}
 8026e08:	2000c5b0 	.word	0x2000c5b0
 8026e0c:	2000d1e0 	.word	0x2000d1e0
 8026e10:	08029138 	.word	0x08029138
 8026e14:	2000c3f8 	.word	0x2000c3f8
 8026e18:	2000d21c 	.word	0x2000d21c
 8026e1c:	2000d258 	.word	0x2000d258
 8026e20:	2000c3f4 	.word	0x2000c3f4
 8026e24:	2000d294 	.word	0x2000d294
 8026e28:	08029140 	.word	0x08029140
 8026e2c:	2000d2d0 	.word	0x2000d2d0
 8026e30:	2000c3fc 	.word	0x2000c3fc
 8026e34:	2000c5ec 	.word	0x2000c5ec
 8026e38:	2000dd64 	.word	0x2000dd64

08026e3c <tileview_init>:

static void tileview_init(void)
{
 8026e3c:	b480      	push	{r7}
 8026e3e:	af00      	add	r7, sp, #0
#if LV_USE_TILEVIEW != 0
    theme.style.tileview.bg   = &lv_style_transp_tight;
 8026e40:	4b09      	ldr	r3, [pc, #36]	; (8026e68 <tileview_init+0x2c>)
 8026e42:	4a0a      	ldr	r2, [pc, #40]	; (8026e6c <tileview_init+0x30>)
 8026e44:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    theme.style.tileview.scrl = &lv_style_transp_tight;
 8026e48:	4b07      	ldr	r3, [pc, #28]	; (8026e68 <tileview_init+0x2c>)
 8026e4a:	4a08      	ldr	r2, [pc, #32]	; (8026e6c <tileview_init+0x30>)
 8026e4c:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    theme.style.tileview.sb   = theme.style.page.sb;
 8026e50:	4b05      	ldr	r3, [pc, #20]	; (8026e68 <tileview_init+0x2c>)
 8026e52:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
 8026e56:	4a04      	ldr	r2, [pc, #16]	; (8026e68 <tileview_init+0x2c>)
 8026e58:	f8c2 3188 	str.w	r3, [r2, #392]	; 0x188
#endif
}
 8026e5c:	bf00      	nop
 8026e5e:	46bd      	mov	sp, r7
 8026e60:	f85d 7b04 	ldr.w	r7, [sp], #4
 8026e64:	4770      	bx	lr
 8026e66:	bf00      	nop
 8026e68:	2000c3fc 	.word	0x2000c3fc
 8026e6c:	2000dd64 	.word	0x2000dd64

08026e70 <table_init>:

static void table_init(void)
{
 8026e70:	b580      	push	{r7, lr}
 8026e72:	af00      	add	r7, sp, #0
#if LV_USE_TABLE != 0
    static lv_style_t cell;
    lv_style_copy(&cell, &panel);
 8026e74:	4909      	ldr	r1, [pc, #36]	; (8026e9c <table_init+0x2c>)
 8026e76:	480a      	ldr	r0, [pc, #40]	; (8026ea0 <table_init+0x30>)
 8026e78:	f7ec fdf4 	bl	8013a64 <lv_style_copy>
    cell.body.radius       = 0;
 8026e7c:	4b08      	ldr	r3, [pc, #32]	; (8026ea0 <table_init+0x30>)
 8026e7e:	2200      	movs	r2, #0
 8026e80:	80da      	strh	r2, [r3, #6]
    cell.body.border.width = 1;
 8026e82:	4b07      	ldr	r3, [pc, #28]	; (8026ea0 <table_init+0x30>)
 8026e84:	2201      	movs	r2, #1
 8026e86:	819a      	strh	r2, [r3, #12]

    theme.style.table.bg   = &lv_style_transp_tight;
 8026e88:	4b06      	ldr	r3, [pc, #24]	; (8026ea4 <table_init+0x34>)
 8026e8a:	4a07      	ldr	r2, [pc, #28]	; (8026ea8 <table_init+0x38>)
 8026e8c:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
    theme.style.table.cell = &cell;
 8026e90:	4b04      	ldr	r3, [pc, #16]	; (8026ea4 <table_init+0x34>)
 8026e92:	4a03      	ldr	r2, [pc, #12]	; (8026ea0 <table_init+0x30>)
 8026e94:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
#endif
}
 8026e98:	bf00      	nop
 8026e9a:	bd80      	pop	{r7, pc}
 8026e9c:	2000c664 	.word	0x2000c664
 8026ea0:	2000d30c 	.word	0x2000d30c
 8026ea4:	2000c3fc 	.word	0x2000c3fc
 8026ea8:	2000dd64 	.word	0x2000dd64

08026eac <win_init>:

static void win_init(void)
{
 8026eac:	b598      	push	{r3, r4, r7, lr}
 8026eae:	af00      	add	r7, sp, #0
#if LV_USE_WIN != 0
    static lv_style_t win_header;

    lv_style_copy(&win_header, &panel);
 8026eb0:	4923      	ldr	r1, [pc, #140]	; (8026f40 <win_init+0x94>)
 8026eb2:	4824      	ldr	r0, [pc, #144]	; (8026f44 <win_init+0x98>)
 8026eb4:	f7ec fdd6 	bl	8013a64 <lv_style_copy>
    win_header.body.radius         = 0;
 8026eb8:	4b22      	ldr	r3, [pc, #136]	; (8026f44 <win_init+0x98>)
 8026eba:	2200      	movs	r2, #0
 8026ebc:	80da      	strh	r2, [r3, #6]
    win_header.body.padding.left   = LV_DPI / 12;
 8026ebe:	4b21      	ldr	r3, [pc, #132]	; (8026f44 <win_init+0x98>)
 8026ec0:	2208      	movs	r2, #8
 8026ec2:	835a      	strh	r2, [r3, #26]
    win_header.body.padding.right  = LV_DPI / 12;
 8026ec4:	4b1f      	ldr	r3, [pc, #124]	; (8026f44 <win_init+0x98>)
 8026ec6:	2208      	movs	r2, #8
 8026ec8:	839a      	strh	r2, [r3, #28]
    win_header.body.padding.top    = LV_DPI / 20;
 8026eca:	4b1e      	ldr	r3, [pc, #120]	; (8026f44 <win_init+0x98>)
 8026ecc:	2205      	movs	r2, #5
 8026ece:	82da      	strh	r2, [r3, #22]
    win_header.body.padding.bottom = LV_DPI / 20;
 8026ed0:	4b1c      	ldr	r3, [pc, #112]	; (8026f44 <win_init+0x98>)
 8026ed2:	2205      	movs	r2, #5
 8026ed4:	831a      	strh	r2, [r3, #24]
    win_header.body.border.opa     = panel.body.border.opa;
 8026ed6:	4b1a      	ldr	r3, [pc, #104]	; (8026f40 <win_init+0x94>)
 8026ed8:	7bda      	ldrb	r2, [r3, #15]
 8026eda:	4b1a      	ldr	r3, [pc, #104]	; (8026f44 <win_init+0x98>)
 8026edc:	73da      	strb	r2, [r3, #15]
    win_header.body.border.width   = panel.body.border.width;
 8026ede:	4b18      	ldr	r3, [pc, #96]	; (8026f40 <win_init+0x94>)
 8026ee0:	f9b3 200c 	ldrsh.w	r2, [r3, #12]
 8026ee4:	4b17      	ldr	r3, [pc, #92]	; (8026f44 <win_init+0x98>)
 8026ee6:	819a      	strh	r2, [r3, #12]
    win_header.body.border.color   = lv_color_hsv_to_rgb(_hue, 20, 80);
 8026ee8:	4b17      	ldr	r3, [pc, #92]	; (8026f48 <win_init+0x9c>)
 8026eea:	881b      	ldrh	r3, [r3, #0]
 8026eec:	4c15      	ldr	r4, [pc, #84]	; (8026f44 <win_init+0x98>)
 8026eee:	2250      	movs	r2, #80	; 0x50
 8026ef0:	2114      	movs	r1, #20
 8026ef2:	4618      	mov	r0, r3
 8026ef4:	f7f4 ffb2 	bl	801be5c <lv_color_hsv_to_rgb>
 8026ef8:	8160      	strh	r0, [r4, #10]
    win_header.text.color          = lv_color_hsv_to_rgb(_hue, 5, 100);
 8026efa:	4b13      	ldr	r3, [pc, #76]	; (8026f48 <win_init+0x9c>)
 8026efc:	881b      	ldrh	r3, [r3, #0]
 8026efe:	4c11      	ldr	r4, [pc, #68]	; (8026f44 <win_init+0x98>)
 8026f00:	2264      	movs	r2, #100	; 0x64
 8026f02:	2105      	movs	r1, #5
 8026f04:	4618      	mov	r0, r3
 8026f06:	f7f4 ffa9 	bl	801be5c <lv_color_hsv_to_rgb>
 8026f0a:	8420      	strh	r0, [r4, #32]

    theme.style.win.bg      = &bg;
 8026f0c:	4b0f      	ldr	r3, [pc, #60]	; (8026f4c <win_init+0xa0>)
 8026f0e:	4a10      	ldr	r2, [pc, #64]	; (8026f50 <win_init+0xa4>)
 8026f10:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    theme.style.win.sb      = &sb;
 8026f14:	4b0d      	ldr	r3, [pc, #52]	; (8026f4c <win_init+0xa0>)
 8026f16:	4a0f      	ldr	r2, [pc, #60]	; (8026f54 <win_init+0xa8>)
 8026f18:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    theme.style.win.header  = &win_header;
 8026f1c:	4b0b      	ldr	r3, [pc, #44]	; (8026f4c <win_init+0xa0>)
 8026f1e:	4a09      	ldr	r2, [pc, #36]	; (8026f44 <win_init+0x98>)
 8026f20:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
    theme.style.win.content = &lv_style_transp;
 8026f24:	4b09      	ldr	r3, [pc, #36]	; (8026f4c <win_init+0xa0>)
 8026f26:	4a0c      	ldr	r2, [pc, #48]	; (8026f58 <win_init+0xac>)
 8026f28:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
    theme.style.win.btn.rel = &btn_rel;
 8026f2c:	4b07      	ldr	r3, [pc, #28]	; (8026f4c <win_init+0xa0>)
 8026f2e:	4a0b      	ldr	r2, [pc, #44]	; (8026f5c <win_init+0xb0>)
 8026f30:	f8c3 21a4 	str.w	r2, [r3, #420]	; 0x1a4
    theme.style.win.btn.pr  = &btn_pr;
 8026f34:	4b05      	ldr	r3, [pc, #20]	; (8026f4c <win_init+0xa0>)
 8026f36:	4a0a      	ldr	r2, [pc, #40]	; (8026f60 <win_init+0xb4>)
 8026f38:	f8c3 21a8 	str.w	r2, [r3, #424]	; 0x1a8
#endif
}
 8026f3c:	bf00      	nop
 8026f3e:	bd98      	pop	{r3, r4, r7, pc}
 8026f40:	2000c664 	.word	0x2000c664
 8026f44:	2000d348 	.word	0x2000d348
 8026f48:	2000c3f4 	.word	0x2000c3f4
 8026f4c:	2000c3fc 	.word	0x2000c3fc
 8026f50:	2000c5ec 	.word	0x2000c5ec
 8026f54:	2000c6a0 	.word	0x2000c6a0
 8026f58:	2000dc74 	.word	0x2000dc74
 8026f5c:	2000c6dc 	.word	0x2000c6dc
 8026f60:	2000c718 	.word	0x2000c718

08026f64 <style_mod>:

#if LV_USE_GROUP

static void style_mod(lv_group_t * group, lv_style_t * style)
{
 8026f64:	b590      	push	{r4, r7, lr}
 8026f66:	b083      	sub	sp, #12
 8026f68:	af00      	add	r7, sp, #0
 8026f6a:	6078      	str	r0, [r7, #4]
 8026f6c:	6039      	str	r1, [r7, #0]
    (void)group; /*Unused*/
#if LV_COLOR_DEPTH != 1
    style->body.border.width = 2;
 8026f6e:	683b      	ldr	r3, [r7, #0]
 8026f70:	2202      	movs	r2, #2
 8026f72:	819a      	strh	r2, [r3, #12]
    style->body.border.color = LV_COLOR_SILVER;
 8026f74:	683b      	ldr	r3, [r7, #0]
 8026f76:	4a0f      	ldr	r2, [pc, #60]	; (8026fb4 <style_mod+0x50>)
 8026f78:	8812      	ldrh	r2, [r2, #0]
 8026f7a:	815a      	strh	r2, [r3, #10]
    style->body.border.opa   = LV_OPA_70;
 8026f7c:	683b      	ldr	r3, [r7, #0]
 8026f7e:	22b2      	movs	r2, #178	; 0xb2
 8026f80:	73da      	strb	r2, [r3, #15]
    style->body.shadow.width = LV_DPI / 20;
 8026f82:	683b      	ldr	r3, [r7, #0]
 8026f84:	2205      	movs	r2, #5
 8026f86:	825a      	strh	r2, [r3, #18]
    style->body.shadow.color = lv_color_hsv_to_rgb(_hue, 20, 90);
 8026f88:	4b0b      	ldr	r3, [pc, #44]	; (8026fb8 <style_mod+0x54>)
 8026f8a:	881b      	ldrh	r3, [r3, #0]
 8026f8c:	683c      	ldr	r4, [r7, #0]
 8026f8e:	225a      	movs	r2, #90	; 0x5a
 8026f90:	2114      	movs	r1, #20
 8026f92:	4618      	mov	r0, r3
 8026f94:	f7f4 ff62 	bl	801be5c <lv_color_hsv_to_rgb>
 8026f98:	8220      	strh	r0, [r4, #16]
    style->body.main_color   = lv_color_hsv_to_rgb(_hue, 40, 80);
 8026f9a:	4b07      	ldr	r3, [pc, #28]	; (8026fb8 <style_mod+0x54>)
 8026f9c:	881b      	ldrh	r3, [r3, #0]
 8026f9e:	683c      	ldr	r4, [r7, #0]
 8026fa0:	2250      	movs	r2, #80	; 0x50
 8026fa2:	2128      	movs	r1, #40	; 0x28
 8026fa4:	4618      	mov	r0, r3
 8026fa6:	f7f4 ff59 	bl	801be5c <lv_color_hsv_to_rgb>
 8026faa:	8060      	strh	r0, [r4, #2]
#else
    style->body.border.opa   = LV_OPA_COVER;
    style->body.border.color = LV_COLOR_BLACK;
    style->body.border.width = 2;
#endif
}
 8026fac:	bf00      	nop
 8026fae:	370c      	adds	r7, #12
 8026fb0:	46bd      	mov	sp, r7
 8026fb2:	bd90      	pop	{r4, r7, pc}
 8026fb4:	08029138 	.word	0x08029138
 8026fb8:	2000c3f4 	.word	0x2000c3f4

08026fbc <style_mod_edit>:

static void style_mod_edit(lv_group_t * group, lv_style_t * style)
{
 8026fbc:	b5b0      	push	{r4, r5, r7, lr}
 8026fbe:	b082      	sub	sp, #8
 8026fc0:	af00      	add	r7, sp, #0
 8026fc2:	6078      	str	r0, [r7, #4]
 8026fc4:	6039      	str	r1, [r7, #0]
    (void)group; /*Unused*/
#if LV_COLOR_DEPTH != 1
    /*Make the style to be a little bit orange*/
    style->body.border.opa   = LV_OPA_COVER;
 8026fc6:	683a      	ldr	r2, [r7, #0]
 8026fc8:	21ff      	movs	r1, #255	; 0xff
 8026fca:	73d1      	strb	r1, [r2, #15]
    style->body.border.color = LV_COLOR_GREEN;
 8026fcc:	6839      	ldr	r1, [r7, #0]
 8026fce:	7a8a      	ldrb	r2, [r1, #10]
 8026fd0:	f36f 0204 	bfc	r2, #0, #5
 8026fd4:	728a      	strb	r2, [r1, #10]
 8026fd6:	6839      	ldr	r1, [r7, #0]
 8026fd8:	894a      	ldrh	r2, [r1, #10]
 8026fda:	2020      	movs	r0, #32
 8026fdc:	f360 124a 	bfi	r2, r0, #5, #6
 8026fe0:	814a      	strh	r2, [r1, #10]
 8026fe2:	6839      	ldr	r1, [r7, #0]
 8026fe4:	7aca      	ldrb	r2, [r1, #11]
 8026fe6:	f36f 02c7 	bfc	r2, #3, #5
 8026fea:	72ca      	strb	r2, [r1, #11]

    /*If not empty or has border then emphasis the border*/
    if(style->body.opa != LV_OPA_TRANSP || style->body.border.width != 0) style->body.border.width = LV_DPI / 20;
 8026fec:	683a      	ldr	r2, [r7, #0]
 8026fee:	7a12      	ldrb	r2, [r2, #8]
 8026ff0:	2a00      	cmp	r2, #0
 8026ff2:	d104      	bne.n	8026ffe <style_mod_edit+0x42>
 8026ff4:	683a      	ldr	r2, [r7, #0]
 8026ff6:	f9b2 200c 	ldrsh.w	r2, [r2, #12]
 8026ffa:	2a00      	cmp	r2, #0
 8026ffc:	d002      	beq.n	8027004 <style_mod_edit+0x48>
 8026ffe:	683a      	ldr	r2, [r7, #0]
 8027000:	2105      	movs	r1, #5
 8027002:	8191      	strh	r1, [r2, #12]

    style->body.main_color   = LV_COLOR_BLACK;
 8027004:	6839      	ldr	r1, [r7, #0]
 8027006:	788a      	ldrb	r2, [r1, #2]
 8027008:	f36f 0204 	bfc	r2, #0, #5
 802700c:	708a      	strb	r2, [r1, #2]
 802700e:	6839      	ldr	r1, [r7, #0]
 8027010:	884a      	ldrh	r2, [r1, #2]
 8027012:	f36f 124a 	bfc	r2, #5, #6
 8027016:	804a      	strh	r2, [r1, #2]
 8027018:	6839      	ldr	r1, [r7, #0]
 802701a:	78ca      	ldrb	r2, [r1, #3]
 802701c:	f36f 02c7 	bfc	r2, #3, #5
 8027020:	70ca      	strb	r2, [r1, #3]
    style->body.shadow.color = lv_color_mix(style->body.shadow.color, LV_COLOR_GREEN, LV_OPA_60);
 8027022:	f36f 0304 	bfc	r3, #0, #5
 8027026:	2220      	movs	r2, #32
 8027028:	f362 134a 	bfi	r3, r2, #5, #6
 802702c:	f36f 23cf 	bfc	r3, #11, #5
 8027030:	683d      	ldr	r5, [r7, #0]
 8027032:	6838      	ldr	r0, [r7, #0]
 8027034:	2299      	movs	r2, #153	; 0x99
 8027036:	4619      	mov	r1, r3
 8027038:	8a00      	ldrh	r0, [r0, #16]
 802703a:	f7fe fcb5 	bl	80259a8 <lv_color_mix>
 802703e:	8228      	strh	r0, [r5, #16]

    style->text.color = lv_color_mix(style->text.color, LV_COLOR_GREEN, LV_OPA_70);
 8027040:	f36f 0404 	bfc	r4, #0, #5
 8027044:	2320      	movs	r3, #32
 8027046:	f363 144a 	bfi	r4, r3, #5, #6
 802704a:	f36f 24cf 	bfc	r4, #11, #5
 802704e:	683d      	ldr	r5, [r7, #0]
 8027050:	683b      	ldr	r3, [r7, #0]
 8027052:	22b2      	movs	r2, #178	; 0xb2
 8027054:	4621      	mov	r1, r4
 8027056:	8c18      	ldrh	r0, [r3, #32]
 8027058:	f7fe fca6 	bl	80259a8 <lv_color_mix>
 802705c:	8428      	strh	r0, [r5, #32]
#else
    style->body.border.opa   = LV_OPA_COVER;
    style->body.border.color = LV_COLOR_BLACK;
    style->body.border.width = 3;
#endif
}
 802705e:	bf00      	nop
 8027060:	3708      	adds	r7, #8
 8027062:	46bd      	mov	sp, r7
 8027064:	bdb0      	pop	{r4, r5, r7, pc}
	...

08027068 <lv_theme_mono_init>:
 * @param hue [0..360] hue value from HSV color space to define the theme's base color
 * @param font pointer to a font (NULL to use the default)
 * @return pointer to the initialized theme
 */
lv_theme_t * lv_theme_mono_init(uint16_t hue, lv_font_t * font)
{
 8027068:	b580      	push	{r7, lr}
 802706a:	b084      	sub	sp, #16
 802706c:	af00      	add	r7, sp, #0
 802706e:	4603      	mov	r3, r0
 8027070:	6039      	str	r1, [r7, #0]
 8027072:	80fb      	strh	r3, [r7, #6]
    if(font == NULL) font = LV_FONT_DEFAULT;
 8027074:	683b      	ldr	r3, [r7, #0]
 8027076:	2b00      	cmp	r3, #0
 8027078:	d101      	bne.n	802707e <lv_theme_mono_init+0x16>
 802707a:	4b30      	ldr	r3, [pc, #192]	; (802713c <lv_theme_mono_init+0xd4>)
 802707c:	603b      	str	r3, [r7, #0]

    _hue  = hue;
 802707e:	4a30      	ldr	r2, [pc, #192]	; (8027140 <lv_theme_mono_init+0xd8>)
 8027080:	88fb      	ldrh	r3, [r7, #6]
 8027082:	8013      	strh	r3, [r2, #0]
    _font = font;
 8027084:	4a2f      	ldr	r2, [pc, #188]	; (8027144 <lv_theme_mono_init+0xdc>)
 8027086:	683b      	ldr	r3, [r7, #0]
 8027088:	6013      	str	r3, [r2, #0]

    /*For backward compatibility initialize all theme elements with a default style */
    uint16_t i;
    lv_style_t ** style_p = (lv_style_t **)&theme.style;
 802708a:	4b2f      	ldr	r3, [pc, #188]	; (8027148 <lv_theme_mono_init+0xe0>)
 802708c:	60bb      	str	r3, [r7, #8]
    for(i = 0; i < LV_THEME_STYLE_COUNT; i++) {
 802708e:	2300      	movs	r3, #0
 8027090:	81fb      	strh	r3, [r7, #14]
 8027092:	e008      	b.n	80270a6 <lv_theme_mono_init+0x3e>
        *style_p = &def;
 8027094:	68bb      	ldr	r3, [r7, #8]
 8027096:	4a2d      	ldr	r2, [pc, #180]	; (802714c <lv_theme_mono_init+0xe4>)
 8027098:	601a      	str	r2, [r3, #0]
        style_p++;
 802709a:	68bb      	ldr	r3, [r7, #8]
 802709c:	3304      	adds	r3, #4
 802709e:	60bb      	str	r3, [r7, #8]
    for(i = 0; i < LV_THEME_STYLE_COUNT; i++) {
 80270a0:	89fb      	ldrh	r3, [r7, #14]
 80270a2:	3301      	adds	r3, #1
 80270a4:	81fb      	strh	r3, [r7, #14]
 80270a6:	89fb      	ldrh	r3, [r7, #14]
 80270a8:	2b6a      	cmp	r3, #106	; 0x6a
 80270aa:	d9f3      	bls.n	8027094 <lv_theme_mono_init+0x2c>
    }

    basic_init();
 80270ac:	f7fe fd4e 	bl	8025b4c <basic_init>
    btn_init();
 80270b0:	f7fe fe5a 	bl	8025d68 <btn_init>
    label_init();
 80270b4:	f7fe ff62 	bl	8025f7c <label_init>
    bar_init();
 80270b8:	f7fe ffa6 	bl	8026008 <bar_init>
    img_init();
 80270bc:	f7ff f824 	bl	8026108 <img_init>
    line_init();
 80270c0:	f7ff f858 	bl	8026174 <line_init>
    led_init();
 80270c4:	f7ff f876 	bl	80261b4 <led_init>
    slider_init();
 80270c8:	f7ff f8b8 	bl	802623c <slider_init>
    sw_init();
 80270cc:	f7ff f906 	bl	80262dc <sw_init>
    lmeter_init();
 80270d0:	f7ff f962 	bl	8026398 <lmeter_init>
    gauge_init();
 80270d4:	f7ff f988 	bl	80263e8 <gauge_init>
    arc_init();
 80270d8:	f7ff f9d2 	bl	8026480 <arc_init>
    preload_init();
 80270dc:	f7ff f9fa 	bl	80264d4 <preload_init>
    chart_init();
 80270e0:	f7ff fa06 	bl	80264f0 <chart_init>
    calendar_init();
 80270e4:	f7ff fa14 	bl	8026510 <calendar_init>
    cb_init();
 80270e8:	f7ff fa84 	bl	80265f4 <cb_init>
    btnm_init();
 80270ec:	f7ff fb5e 	bl	80267ac <btnm_init>
    kb_init();
 80270f0:	f7ff fbf4 	bl	80268dc <kb_init>
    mbox_init();
 80270f4:	f7ff fc1e 	bl	8026934 <mbox_init>
    page_init();
 80270f8:	f7ff fc44 	bl	8026984 <page_init>
    ta_init();
 80270fc:	f7ff fc5e 	bl	80269bc <ta_init>
    spinbox_init();
 8027100:	f7ff fc7a 	bl	80269f8 <spinbox_init>
    list_init();
 8027104:	f7ff fc94 	bl	8026a30 <list_init>
    ddlist_init();
 8027108:	f7ff fd26 	bl	8026b58 <ddlist_init>
    roller_init();
 802710c:	f7ff fd66 	bl	8026bdc <roller_init>
    tabview_init();
 8027110:	f7ff fdb6 	bl	8026c80 <tabview_init>
    tileview_init();
 8027114:	f7ff fe92 	bl	8026e3c <tileview_init>
    table_init();
 8027118:	f7ff feaa 	bl	8026e70 <table_init>
    win_init();
 802711c:	f7ff fec6 	bl	8026eac <win_init>

#if LV_USE_GROUP
    theme.group.style_mod_xcb      = style_mod;
 8027120:	4b09      	ldr	r3, [pc, #36]	; (8027148 <lv_theme_mono_init+0xe0>)
 8027122:	4a0b      	ldr	r2, [pc, #44]	; (8027150 <lv_theme_mono_init+0xe8>)
 8027124:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
    theme.group.style_mod_edit_xcb = style_mod_edit;
 8027128:	4b07      	ldr	r3, [pc, #28]	; (8027148 <lv_theme_mono_init+0xe0>)
 802712a:	4a0a      	ldr	r2, [pc, #40]	; (8027154 <lv_theme_mono_init+0xec>)
 802712c:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
#endif

    return &theme;
 8027130:	4b05      	ldr	r3, [pc, #20]	; (8027148 <lv_theme_mono_init+0xe0>)
}
 8027132:	4618      	mov	r0, r3
 8027134:	3710      	adds	r7, #16
 8027136:	46bd      	mov	sp, r7
 8027138:	bd80      	pop	{r7, pc}
 802713a:	bf00      	nop
 802713c:	20000c1c 	.word	0x20000c1c
 8027140:	2000c3f4 	.word	0x2000c3f4
 8027144:	2000c3f8 	.word	0x2000c3f8
 8027148:	2000c3fc 	.word	0x2000c3fc
 802714c:	2000c5b0 	.word	0x2000c5b0
 8027150:	08026f65 	.word	0x08026f65
 8027154:	08026fbd 	.word	0x08026fbd

08027158 <abort>:
 8027158:	b508      	push	{r3, lr}
 802715a:	2006      	movs	r0, #6
 802715c:	f000 f882 	bl	8027264 <raise>
 8027160:	2001      	movs	r0, #1
 8027162:	f7e3 f93f 	bl	800a3e4 <_exit>
	...

08027168 <__errno>:
 8027168:	4b01      	ldr	r3, [pc, #4]	; (8027170 <__errno+0x8>)
 802716a:	6818      	ldr	r0, [r3, #0]
 802716c:	4770      	bx	lr
 802716e:	bf00      	nop
 8027170:	20000c48 	.word	0x20000c48

08027174 <__libc_init_array>:
 8027174:	b570      	push	{r4, r5, r6, lr}
 8027176:	4e0d      	ldr	r6, [pc, #52]	; (80271ac <__libc_init_array+0x38>)
 8027178:	4c0d      	ldr	r4, [pc, #52]	; (80271b0 <__libc_init_array+0x3c>)
 802717a:	1ba4      	subs	r4, r4, r6
 802717c:	10a4      	asrs	r4, r4, #2
 802717e:	2500      	movs	r5, #0
 8027180:	42a5      	cmp	r5, r4
 8027182:	d109      	bne.n	8027198 <__libc_init_array+0x24>
 8027184:	4e0b      	ldr	r6, [pc, #44]	; (80271b4 <__libc_init_array+0x40>)
 8027186:	4c0c      	ldr	r4, [pc, #48]	; (80271b8 <__libc_init_array+0x44>)
 8027188:	f001 f92a 	bl	80283e0 <_init>
 802718c:	1ba4      	subs	r4, r4, r6
 802718e:	10a4      	asrs	r4, r4, #2
 8027190:	2500      	movs	r5, #0
 8027192:	42a5      	cmp	r5, r4
 8027194:	d105      	bne.n	80271a2 <__libc_init_array+0x2e>
 8027196:	bd70      	pop	{r4, r5, r6, pc}
 8027198:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802719c:	4798      	blx	r3
 802719e:	3501      	adds	r5, #1
 80271a0:	e7ee      	b.n	8027180 <__libc_init_array+0xc>
 80271a2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80271a6:	4798      	blx	r3
 80271a8:	3501      	adds	r5, #1
 80271aa:	e7f2      	b.n	8027192 <__libc_init_array+0x1e>
 80271ac:	0802b604 	.word	0x0802b604
 80271b0:	0802b604 	.word	0x0802b604
 80271b4:	0802b604 	.word	0x0802b604
 80271b8:	0802b608 	.word	0x0802b608

080271bc <memcpy>:
 80271bc:	b510      	push	{r4, lr}
 80271be:	1e43      	subs	r3, r0, #1
 80271c0:	440a      	add	r2, r1
 80271c2:	4291      	cmp	r1, r2
 80271c4:	d100      	bne.n	80271c8 <memcpy+0xc>
 80271c6:	bd10      	pop	{r4, pc}
 80271c8:	f811 4b01 	ldrb.w	r4, [r1], #1
 80271cc:	f803 4f01 	strb.w	r4, [r3, #1]!
 80271d0:	e7f7      	b.n	80271c2 <memcpy+0x6>

080271d2 <memset>:
 80271d2:	4402      	add	r2, r0
 80271d4:	4603      	mov	r3, r0
 80271d6:	4293      	cmp	r3, r2
 80271d8:	d100      	bne.n	80271dc <memset+0xa>
 80271da:	4770      	bx	lr
 80271dc:	f803 1b01 	strb.w	r1, [r3], #1
 80271e0:	e7f9      	b.n	80271d6 <memset+0x4>
	...

080271e4 <iprintf>:
 80271e4:	b40f      	push	{r0, r1, r2, r3}
 80271e6:	4b0a      	ldr	r3, [pc, #40]	; (8027210 <iprintf+0x2c>)
 80271e8:	b513      	push	{r0, r1, r4, lr}
 80271ea:	681c      	ldr	r4, [r3, #0]
 80271ec:	b124      	cbz	r4, 80271f8 <iprintf+0x14>
 80271ee:	69a3      	ldr	r3, [r4, #24]
 80271f0:	b913      	cbnz	r3, 80271f8 <iprintf+0x14>
 80271f2:	4620      	mov	r0, r4
 80271f4:	f000 f8ce 	bl	8027394 <__sinit>
 80271f8:	ab05      	add	r3, sp, #20
 80271fa:	9a04      	ldr	r2, [sp, #16]
 80271fc:	68a1      	ldr	r1, [r4, #8]
 80271fe:	9301      	str	r3, [sp, #4]
 8027200:	4620      	mov	r0, r4
 8027202:	f000 fb27 	bl	8027854 <_vfiprintf_r>
 8027206:	b002      	add	sp, #8
 8027208:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 802720c:	b004      	add	sp, #16
 802720e:	4770      	bx	lr
 8027210:	20000c48 	.word	0x20000c48

08027214 <_raise_r>:
 8027214:	291f      	cmp	r1, #31
 8027216:	b538      	push	{r3, r4, r5, lr}
 8027218:	4604      	mov	r4, r0
 802721a:	460d      	mov	r5, r1
 802721c:	d904      	bls.n	8027228 <_raise_r+0x14>
 802721e:	2316      	movs	r3, #22
 8027220:	6003      	str	r3, [r0, #0]
 8027222:	f04f 30ff 	mov.w	r0, #4294967295
 8027226:	bd38      	pop	{r3, r4, r5, pc}
 8027228:	6c42      	ldr	r2, [r0, #68]	; 0x44
 802722a:	b112      	cbz	r2, 8027232 <_raise_r+0x1e>
 802722c:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8027230:	b94b      	cbnz	r3, 8027246 <_raise_r+0x32>
 8027232:	4620      	mov	r0, r4
 8027234:	f000 f830 	bl	8027298 <_getpid_r>
 8027238:	462a      	mov	r2, r5
 802723a:	4601      	mov	r1, r0
 802723c:	4620      	mov	r0, r4
 802723e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8027242:	f000 b817 	b.w	8027274 <_kill_r>
 8027246:	2b01      	cmp	r3, #1
 8027248:	d00a      	beq.n	8027260 <_raise_r+0x4c>
 802724a:	1c59      	adds	r1, r3, #1
 802724c:	d103      	bne.n	8027256 <_raise_r+0x42>
 802724e:	2316      	movs	r3, #22
 8027250:	6003      	str	r3, [r0, #0]
 8027252:	2001      	movs	r0, #1
 8027254:	e7e7      	b.n	8027226 <_raise_r+0x12>
 8027256:	2400      	movs	r4, #0
 8027258:	f842 4025 	str.w	r4, [r2, r5, lsl #2]
 802725c:	4628      	mov	r0, r5
 802725e:	4798      	blx	r3
 8027260:	2000      	movs	r0, #0
 8027262:	e7e0      	b.n	8027226 <_raise_r+0x12>

08027264 <raise>:
 8027264:	4b02      	ldr	r3, [pc, #8]	; (8027270 <raise+0xc>)
 8027266:	4601      	mov	r1, r0
 8027268:	6818      	ldr	r0, [r3, #0]
 802726a:	f7ff bfd3 	b.w	8027214 <_raise_r>
 802726e:	bf00      	nop
 8027270:	20000c48 	.word	0x20000c48

08027274 <_kill_r>:
 8027274:	b538      	push	{r3, r4, r5, lr}
 8027276:	4c07      	ldr	r4, [pc, #28]	; (8027294 <_kill_r+0x20>)
 8027278:	2300      	movs	r3, #0
 802727a:	4605      	mov	r5, r0
 802727c:	4608      	mov	r0, r1
 802727e:	4611      	mov	r1, r2
 8027280:	6023      	str	r3, [r4, #0]
 8027282:	f7e3 f89f 	bl	800a3c4 <_kill>
 8027286:	1c43      	adds	r3, r0, #1
 8027288:	d102      	bne.n	8027290 <_kill_r+0x1c>
 802728a:	6823      	ldr	r3, [r4, #0]
 802728c:	b103      	cbz	r3, 8027290 <_kill_r+0x1c>
 802728e:	602b      	str	r3, [r5, #0]
 8027290:	bd38      	pop	{r3, r4, r5, pc}
 8027292:	bf00      	nop
 8027294:	2000dfb0 	.word	0x2000dfb0

08027298 <_getpid_r>:
 8027298:	f7e3 b88c 	b.w	800a3b4 <_getpid>

0802729c <sniprintf>:
 802729c:	b40c      	push	{r2, r3}
 802729e:	b530      	push	{r4, r5, lr}
 80272a0:	4b17      	ldr	r3, [pc, #92]	; (8027300 <sniprintf+0x64>)
 80272a2:	1e0c      	subs	r4, r1, #0
 80272a4:	b09d      	sub	sp, #116	; 0x74
 80272a6:	681d      	ldr	r5, [r3, #0]
 80272a8:	da08      	bge.n	80272bc <sniprintf+0x20>
 80272aa:	238b      	movs	r3, #139	; 0x8b
 80272ac:	602b      	str	r3, [r5, #0]
 80272ae:	f04f 30ff 	mov.w	r0, #4294967295
 80272b2:	b01d      	add	sp, #116	; 0x74
 80272b4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 80272b8:	b002      	add	sp, #8
 80272ba:	4770      	bx	lr
 80272bc:	f44f 7302 	mov.w	r3, #520	; 0x208
 80272c0:	f8ad 3014 	strh.w	r3, [sp, #20]
 80272c4:	bf14      	ite	ne
 80272c6:	f104 33ff 	addne.w	r3, r4, #4294967295
 80272ca:	4623      	moveq	r3, r4
 80272cc:	9304      	str	r3, [sp, #16]
 80272ce:	9307      	str	r3, [sp, #28]
 80272d0:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80272d4:	9002      	str	r0, [sp, #8]
 80272d6:	9006      	str	r0, [sp, #24]
 80272d8:	f8ad 3016 	strh.w	r3, [sp, #22]
 80272dc:	9a20      	ldr	r2, [sp, #128]	; 0x80
 80272de:	ab21      	add	r3, sp, #132	; 0x84
 80272e0:	a902      	add	r1, sp, #8
 80272e2:	4628      	mov	r0, r5
 80272e4:	9301      	str	r3, [sp, #4]
 80272e6:	f000 f993 	bl	8027610 <_svfiprintf_r>
 80272ea:	1c43      	adds	r3, r0, #1
 80272ec:	bfbc      	itt	lt
 80272ee:	238b      	movlt	r3, #139	; 0x8b
 80272f0:	602b      	strlt	r3, [r5, #0]
 80272f2:	2c00      	cmp	r4, #0
 80272f4:	d0dd      	beq.n	80272b2 <sniprintf+0x16>
 80272f6:	9b02      	ldr	r3, [sp, #8]
 80272f8:	2200      	movs	r2, #0
 80272fa:	701a      	strb	r2, [r3, #0]
 80272fc:	e7d9      	b.n	80272b2 <sniprintf+0x16>
 80272fe:	bf00      	nop
 8027300:	20000c48 	.word	0x20000c48

08027304 <strcpy>:
 8027304:	4603      	mov	r3, r0
 8027306:	f811 2b01 	ldrb.w	r2, [r1], #1
 802730a:	f803 2b01 	strb.w	r2, [r3], #1
 802730e:	2a00      	cmp	r2, #0
 8027310:	d1f9      	bne.n	8027306 <strcpy+0x2>
 8027312:	4770      	bx	lr

08027314 <std>:
 8027314:	2300      	movs	r3, #0
 8027316:	b510      	push	{r4, lr}
 8027318:	4604      	mov	r4, r0
 802731a:	e9c0 3300 	strd	r3, r3, [r0]
 802731e:	6083      	str	r3, [r0, #8]
 8027320:	8181      	strh	r1, [r0, #12]
 8027322:	6643      	str	r3, [r0, #100]	; 0x64
 8027324:	81c2      	strh	r2, [r0, #14]
 8027326:	e9c0 3304 	strd	r3, r3, [r0, #16]
 802732a:	6183      	str	r3, [r0, #24]
 802732c:	4619      	mov	r1, r3
 802732e:	2208      	movs	r2, #8
 8027330:	305c      	adds	r0, #92	; 0x5c
 8027332:	f7ff ff4e 	bl	80271d2 <memset>
 8027336:	4b05      	ldr	r3, [pc, #20]	; (802734c <std+0x38>)
 8027338:	6263      	str	r3, [r4, #36]	; 0x24
 802733a:	4b05      	ldr	r3, [pc, #20]	; (8027350 <std+0x3c>)
 802733c:	62a3      	str	r3, [r4, #40]	; 0x28
 802733e:	4b05      	ldr	r3, [pc, #20]	; (8027354 <std+0x40>)
 8027340:	62e3      	str	r3, [r4, #44]	; 0x2c
 8027342:	4b05      	ldr	r3, [pc, #20]	; (8027358 <std+0x44>)
 8027344:	6224      	str	r4, [r4, #32]
 8027346:	6323      	str	r3, [r4, #48]	; 0x30
 8027348:	bd10      	pop	{r4, pc}
 802734a:	bf00      	nop
 802734c:	08027db1 	.word	0x08027db1
 8027350:	08027dd3 	.word	0x08027dd3
 8027354:	08027e0b 	.word	0x08027e0b
 8027358:	08027e2f 	.word	0x08027e2f

0802735c <_cleanup_r>:
 802735c:	4901      	ldr	r1, [pc, #4]	; (8027364 <_cleanup_r+0x8>)
 802735e:	f000 b885 	b.w	802746c <_fwalk_reent>
 8027362:	bf00      	nop
 8027364:	08028109 	.word	0x08028109

08027368 <__sfmoreglue>:
 8027368:	b570      	push	{r4, r5, r6, lr}
 802736a:	1e4a      	subs	r2, r1, #1
 802736c:	2568      	movs	r5, #104	; 0x68
 802736e:	4355      	muls	r5, r2
 8027370:	460e      	mov	r6, r1
 8027372:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8027376:	f000 f897 	bl	80274a8 <_malloc_r>
 802737a:	4604      	mov	r4, r0
 802737c:	b140      	cbz	r0, 8027390 <__sfmoreglue+0x28>
 802737e:	2100      	movs	r1, #0
 8027380:	e9c0 1600 	strd	r1, r6, [r0]
 8027384:	300c      	adds	r0, #12
 8027386:	60a0      	str	r0, [r4, #8]
 8027388:	f105 0268 	add.w	r2, r5, #104	; 0x68
 802738c:	f7ff ff21 	bl	80271d2 <memset>
 8027390:	4620      	mov	r0, r4
 8027392:	bd70      	pop	{r4, r5, r6, pc}

08027394 <__sinit>:
 8027394:	6983      	ldr	r3, [r0, #24]
 8027396:	b510      	push	{r4, lr}
 8027398:	4604      	mov	r4, r0
 802739a:	bb33      	cbnz	r3, 80273ea <__sinit+0x56>
 802739c:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 80273a0:	6503      	str	r3, [r0, #80]	; 0x50
 80273a2:	4b12      	ldr	r3, [pc, #72]	; (80273ec <__sinit+0x58>)
 80273a4:	4a12      	ldr	r2, [pc, #72]	; (80273f0 <__sinit+0x5c>)
 80273a6:	681b      	ldr	r3, [r3, #0]
 80273a8:	6282      	str	r2, [r0, #40]	; 0x28
 80273aa:	4298      	cmp	r0, r3
 80273ac:	bf04      	itt	eq
 80273ae:	2301      	moveq	r3, #1
 80273b0:	6183      	streq	r3, [r0, #24]
 80273b2:	f000 f81f 	bl	80273f4 <__sfp>
 80273b6:	6060      	str	r0, [r4, #4]
 80273b8:	4620      	mov	r0, r4
 80273ba:	f000 f81b 	bl	80273f4 <__sfp>
 80273be:	60a0      	str	r0, [r4, #8]
 80273c0:	4620      	mov	r0, r4
 80273c2:	f000 f817 	bl	80273f4 <__sfp>
 80273c6:	2200      	movs	r2, #0
 80273c8:	60e0      	str	r0, [r4, #12]
 80273ca:	2104      	movs	r1, #4
 80273cc:	6860      	ldr	r0, [r4, #4]
 80273ce:	f7ff ffa1 	bl	8027314 <std>
 80273d2:	2201      	movs	r2, #1
 80273d4:	2109      	movs	r1, #9
 80273d6:	68a0      	ldr	r0, [r4, #8]
 80273d8:	f7ff ff9c 	bl	8027314 <std>
 80273dc:	2202      	movs	r2, #2
 80273de:	2112      	movs	r1, #18
 80273e0:	68e0      	ldr	r0, [r4, #12]
 80273e2:	f7ff ff97 	bl	8027314 <std>
 80273e6:	2301      	movs	r3, #1
 80273e8:	61a3      	str	r3, [r4, #24]
 80273ea:	bd10      	pop	{r4, pc}
 80273ec:	0802b564 	.word	0x0802b564
 80273f0:	0802735d 	.word	0x0802735d

080273f4 <__sfp>:
 80273f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80273f6:	4b1b      	ldr	r3, [pc, #108]	; (8027464 <__sfp+0x70>)
 80273f8:	681e      	ldr	r6, [r3, #0]
 80273fa:	69b3      	ldr	r3, [r6, #24]
 80273fc:	4607      	mov	r7, r0
 80273fe:	b913      	cbnz	r3, 8027406 <__sfp+0x12>
 8027400:	4630      	mov	r0, r6
 8027402:	f7ff ffc7 	bl	8027394 <__sinit>
 8027406:	3648      	adds	r6, #72	; 0x48
 8027408:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 802740c:	3b01      	subs	r3, #1
 802740e:	d503      	bpl.n	8027418 <__sfp+0x24>
 8027410:	6833      	ldr	r3, [r6, #0]
 8027412:	b133      	cbz	r3, 8027422 <__sfp+0x2e>
 8027414:	6836      	ldr	r6, [r6, #0]
 8027416:	e7f7      	b.n	8027408 <__sfp+0x14>
 8027418:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 802741c:	b16d      	cbz	r5, 802743a <__sfp+0x46>
 802741e:	3468      	adds	r4, #104	; 0x68
 8027420:	e7f4      	b.n	802740c <__sfp+0x18>
 8027422:	2104      	movs	r1, #4
 8027424:	4638      	mov	r0, r7
 8027426:	f7ff ff9f 	bl	8027368 <__sfmoreglue>
 802742a:	6030      	str	r0, [r6, #0]
 802742c:	2800      	cmp	r0, #0
 802742e:	d1f1      	bne.n	8027414 <__sfp+0x20>
 8027430:	230c      	movs	r3, #12
 8027432:	603b      	str	r3, [r7, #0]
 8027434:	4604      	mov	r4, r0
 8027436:	4620      	mov	r0, r4
 8027438:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802743a:	4b0b      	ldr	r3, [pc, #44]	; (8027468 <__sfp+0x74>)
 802743c:	6665      	str	r5, [r4, #100]	; 0x64
 802743e:	e9c4 5500 	strd	r5, r5, [r4]
 8027442:	60a5      	str	r5, [r4, #8]
 8027444:	e9c4 3503 	strd	r3, r5, [r4, #12]
 8027448:	e9c4 5505 	strd	r5, r5, [r4, #20]
 802744c:	2208      	movs	r2, #8
 802744e:	4629      	mov	r1, r5
 8027450:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8027454:	f7ff febd 	bl	80271d2 <memset>
 8027458:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 802745c:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8027460:	e7e9      	b.n	8027436 <__sfp+0x42>
 8027462:	bf00      	nop
 8027464:	0802b564 	.word	0x0802b564
 8027468:	ffff0001 	.word	0xffff0001

0802746c <_fwalk_reent>:
 802746c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8027470:	4680      	mov	r8, r0
 8027472:	4689      	mov	r9, r1
 8027474:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8027478:	2600      	movs	r6, #0
 802747a:	b914      	cbnz	r4, 8027482 <_fwalk_reent+0x16>
 802747c:	4630      	mov	r0, r6
 802747e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8027482:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 8027486:	3f01      	subs	r7, #1
 8027488:	d501      	bpl.n	802748e <_fwalk_reent+0x22>
 802748a:	6824      	ldr	r4, [r4, #0]
 802748c:	e7f5      	b.n	802747a <_fwalk_reent+0xe>
 802748e:	89ab      	ldrh	r3, [r5, #12]
 8027490:	2b01      	cmp	r3, #1
 8027492:	d907      	bls.n	80274a4 <_fwalk_reent+0x38>
 8027494:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8027498:	3301      	adds	r3, #1
 802749a:	d003      	beq.n	80274a4 <_fwalk_reent+0x38>
 802749c:	4629      	mov	r1, r5
 802749e:	4640      	mov	r0, r8
 80274a0:	47c8      	blx	r9
 80274a2:	4306      	orrs	r6, r0
 80274a4:	3568      	adds	r5, #104	; 0x68
 80274a6:	e7ee      	b.n	8027486 <_fwalk_reent+0x1a>

080274a8 <_malloc_r>:
 80274a8:	b570      	push	{r4, r5, r6, lr}
 80274aa:	1ccd      	adds	r5, r1, #3
 80274ac:	f025 0503 	bic.w	r5, r5, #3
 80274b0:	3508      	adds	r5, #8
 80274b2:	2d0c      	cmp	r5, #12
 80274b4:	bf38      	it	cc
 80274b6:	250c      	movcc	r5, #12
 80274b8:	2d00      	cmp	r5, #0
 80274ba:	4606      	mov	r6, r0
 80274bc:	db01      	blt.n	80274c2 <_malloc_r+0x1a>
 80274be:	42a9      	cmp	r1, r5
 80274c0:	d903      	bls.n	80274ca <_malloc_r+0x22>
 80274c2:	230c      	movs	r3, #12
 80274c4:	6033      	str	r3, [r6, #0]
 80274c6:	2000      	movs	r0, #0
 80274c8:	bd70      	pop	{r4, r5, r6, pc}
 80274ca:	f000 fed6 	bl	802827a <__malloc_lock>
 80274ce:	4a21      	ldr	r2, [pc, #132]	; (8027554 <_malloc_r+0xac>)
 80274d0:	6814      	ldr	r4, [r2, #0]
 80274d2:	4621      	mov	r1, r4
 80274d4:	b991      	cbnz	r1, 80274fc <_malloc_r+0x54>
 80274d6:	4c20      	ldr	r4, [pc, #128]	; (8027558 <_malloc_r+0xb0>)
 80274d8:	6823      	ldr	r3, [r4, #0]
 80274da:	b91b      	cbnz	r3, 80274e4 <_malloc_r+0x3c>
 80274dc:	4630      	mov	r0, r6
 80274de:	f000 fc57 	bl	8027d90 <_sbrk_r>
 80274e2:	6020      	str	r0, [r4, #0]
 80274e4:	4629      	mov	r1, r5
 80274e6:	4630      	mov	r0, r6
 80274e8:	f000 fc52 	bl	8027d90 <_sbrk_r>
 80274ec:	1c43      	adds	r3, r0, #1
 80274ee:	d124      	bne.n	802753a <_malloc_r+0x92>
 80274f0:	230c      	movs	r3, #12
 80274f2:	6033      	str	r3, [r6, #0]
 80274f4:	4630      	mov	r0, r6
 80274f6:	f000 fec1 	bl	802827c <__malloc_unlock>
 80274fa:	e7e4      	b.n	80274c6 <_malloc_r+0x1e>
 80274fc:	680b      	ldr	r3, [r1, #0]
 80274fe:	1b5b      	subs	r3, r3, r5
 8027500:	d418      	bmi.n	8027534 <_malloc_r+0x8c>
 8027502:	2b0b      	cmp	r3, #11
 8027504:	d90f      	bls.n	8027526 <_malloc_r+0x7e>
 8027506:	600b      	str	r3, [r1, #0]
 8027508:	50cd      	str	r5, [r1, r3]
 802750a:	18cc      	adds	r4, r1, r3
 802750c:	4630      	mov	r0, r6
 802750e:	f000 feb5 	bl	802827c <__malloc_unlock>
 8027512:	f104 000b 	add.w	r0, r4, #11
 8027516:	1d23      	adds	r3, r4, #4
 8027518:	f020 0007 	bic.w	r0, r0, #7
 802751c:	1ac3      	subs	r3, r0, r3
 802751e:	d0d3      	beq.n	80274c8 <_malloc_r+0x20>
 8027520:	425a      	negs	r2, r3
 8027522:	50e2      	str	r2, [r4, r3]
 8027524:	e7d0      	b.n	80274c8 <_malloc_r+0x20>
 8027526:	428c      	cmp	r4, r1
 8027528:	684b      	ldr	r3, [r1, #4]
 802752a:	bf16      	itet	ne
 802752c:	6063      	strne	r3, [r4, #4]
 802752e:	6013      	streq	r3, [r2, #0]
 8027530:	460c      	movne	r4, r1
 8027532:	e7eb      	b.n	802750c <_malloc_r+0x64>
 8027534:	460c      	mov	r4, r1
 8027536:	6849      	ldr	r1, [r1, #4]
 8027538:	e7cc      	b.n	80274d4 <_malloc_r+0x2c>
 802753a:	1cc4      	adds	r4, r0, #3
 802753c:	f024 0403 	bic.w	r4, r4, #3
 8027540:	42a0      	cmp	r0, r4
 8027542:	d005      	beq.n	8027550 <_malloc_r+0xa8>
 8027544:	1a21      	subs	r1, r4, r0
 8027546:	4630      	mov	r0, r6
 8027548:	f000 fc22 	bl	8027d90 <_sbrk_r>
 802754c:	3001      	adds	r0, #1
 802754e:	d0cf      	beq.n	80274f0 <_malloc_r+0x48>
 8027550:	6025      	str	r5, [r4, #0]
 8027552:	e7db      	b.n	802750c <_malloc_r+0x64>
 8027554:	2000d384 	.word	0x2000d384
 8027558:	2000d388 	.word	0x2000d388

0802755c <__ssputs_r>:
 802755c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8027560:	688e      	ldr	r6, [r1, #8]
 8027562:	429e      	cmp	r6, r3
 8027564:	4682      	mov	sl, r0
 8027566:	460c      	mov	r4, r1
 8027568:	4690      	mov	r8, r2
 802756a:	4699      	mov	r9, r3
 802756c:	d837      	bhi.n	80275de <__ssputs_r+0x82>
 802756e:	898a      	ldrh	r2, [r1, #12]
 8027570:	f412 6f90 	tst.w	r2, #1152	; 0x480
 8027574:	d031      	beq.n	80275da <__ssputs_r+0x7e>
 8027576:	6825      	ldr	r5, [r4, #0]
 8027578:	6909      	ldr	r1, [r1, #16]
 802757a:	1a6f      	subs	r7, r5, r1
 802757c:	6965      	ldr	r5, [r4, #20]
 802757e:	2302      	movs	r3, #2
 8027580:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8027584:	fb95 f5f3 	sdiv	r5, r5, r3
 8027588:	f109 0301 	add.w	r3, r9, #1
 802758c:	443b      	add	r3, r7
 802758e:	429d      	cmp	r5, r3
 8027590:	bf38      	it	cc
 8027592:	461d      	movcc	r5, r3
 8027594:	0553      	lsls	r3, r2, #21
 8027596:	d530      	bpl.n	80275fa <__ssputs_r+0x9e>
 8027598:	4629      	mov	r1, r5
 802759a:	f7ff ff85 	bl	80274a8 <_malloc_r>
 802759e:	4606      	mov	r6, r0
 80275a0:	b950      	cbnz	r0, 80275b8 <__ssputs_r+0x5c>
 80275a2:	230c      	movs	r3, #12
 80275a4:	f8ca 3000 	str.w	r3, [sl]
 80275a8:	89a3      	ldrh	r3, [r4, #12]
 80275aa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80275ae:	81a3      	strh	r3, [r4, #12]
 80275b0:	f04f 30ff 	mov.w	r0, #4294967295
 80275b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80275b8:	463a      	mov	r2, r7
 80275ba:	6921      	ldr	r1, [r4, #16]
 80275bc:	f7ff fdfe 	bl	80271bc <memcpy>
 80275c0:	89a3      	ldrh	r3, [r4, #12]
 80275c2:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 80275c6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80275ca:	81a3      	strh	r3, [r4, #12]
 80275cc:	6126      	str	r6, [r4, #16]
 80275ce:	6165      	str	r5, [r4, #20]
 80275d0:	443e      	add	r6, r7
 80275d2:	1bed      	subs	r5, r5, r7
 80275d4:	6026      	str	r6, [r4, #0]
 80275d6:	60a5      	str	r5, [r4, #8]
 80275d8:	464e      	mov	r6, r9
 80275da:	454e      	cmp	r6, r9
 80275dc:	d900      	bls.n	80275e0 <__ssputs_r+0x84>
 80275de:	464e      	mov	r6, r9
 80275e0:	4632      	mov	r2, r6
 80275e2:	4641      	mov	r1, r8
 80275e4:	6820      	ldr	r0, [r4, #0]
 80275e6:	f000 fe2f 	bl	8028248 <memmove>
 80275ea:	68a3      	ldr	r3, [r4, #8]
 80275ec:	1b9b      	subs	r3, r3, r6
 80275ee:	60a3      	str	r3, [r4, #8]
 80275f0:	6823      	ldr	r3, [r4, #0]
 80275f2:	441e      	add	r6, r3
 80275f4:	6026      	str	r6, [r4, #0]
 80275f6:	2000      	movs	r0, #0
 80275f8:	e7dc      	b.n	80275b4 <__ssputs_r+0x58>
 80275fa:	462a      	mov	r2, r5
 80275fc:	f000 fe8e 	bl	802831c <_realloc_r>
 8027600:	4606      	mov	r6, r0
 8027602:	2800      	cmp	r0, #0
 8027604:	d1e2      	bne.n	80275cc <__ssputs_r+0x70>
 8027606:	6921      	ldr	r1, [r4, #16]
 8027608:	4650      	mov	r0, sl
 802760a:	f000 fe39 	bl	8028280 <_free_r>
 802760e:	e7c8      	b.n	80275a2 <__ssputs_r+0x46>

08027610 <_svfiprintf_r>:
 8027610:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027614:	461d      	mov	r5, r3
 8027616:	898b      	ldrh	r3, [r1, #12]
 8027618:	061f      	lsls	r7, r3, #24
 802761a:	b09d      	sub	sp, #116	; 0x74
 802761c:	4680      	mov	r8, r0
 802761e:	460c      	mov	r4, r1
 8027620:	4616      	mov	r6, r2
 8027622:	d50f      	bpl.n	8027644 <_svfiprintf_r+0x34>
 8027624:	690b      	ldr	r3, [r1, #16]
 8027626:	b96b      	cbnz	r3, 8027644 <_svfiprintf_r+0x34>
 8027628:	2140      	movs	r1, #64	; 0x40
 802762a:	f7ff ff3d 	bl	80274a8 <_malloc_r>
 802762e:	6020      	str	r0, [r4, #0]
 8027630:	6120      	str	r0, [r4, #16]
 8027632:	b928      	cbnz	r0, 8027640 <_svfiprintf_r+0x30>
 8027634:	230c      	movs	r3, #12
 8027636:	f8c8 3000 	str.w	r3, [r8]
 802763a:	f04f 30ff 	mov.w	r0, #4294967295
 802763e:	e0c8      	b.n	80277d2 <_svfiprintf_r+0x1c2>
 8027640:	2340      	movs	r3, #64	; 0x40
 8027642:	6163      	str	r3, [r4, #20]
 8027644:	2300      	movs	r3, #0
 8027646:	9309      	str	r3, [sp, #36]	; 0x24
 8027648:	2320      	movs	r3, #32
 802764a:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802764e:	2330      	movs	r3, #48	; 0x30
 8027650:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8027654:	9503      	str	r5, [sp, #12]
 8027656:	f04f 0b01 	mov.w	fp, #1
 802765a:	4637      	mov	r7, r6
 802765c:	463d      	mov	r5, r7
 802765e:	f815 3b01 	ldrb.w	r3, [r5], #1
 8027662:	b10b      	cbz	r3, 8027668 <_svfiprintf_r+0x58>
 8027664:	2b25      	cmp	r3, #37	; 0x25
 8027666:	d13e      	bne.n	80276e6 <_svfiprintf_r+0xd6>
 8027668:	ebb7 0a06 	subs.w	sl, r7, r6
 802766c:	d00b      	beq.n	8027686 <_svfiprintf_r+0x76>
 802766e:	4653      	mov	r3, sl
 8027670:	4632      	mov	r2, r6
 8027672:	4621      	mov	r1, r4
 8027674:	4640      	mov	r0, r8
 8027676:	f7ff ff71 	bl	802755c <__ssputs_r>
 802767a:	3001      	adds	r0, #1
 802767c:	f000 80a4 	beq.w	80277c8 <_svfiprintf_r+0x1b8>
 8027680:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027682:	4453      	add	r3, sl
 8027684:	9309      	str	r3, [sp, #36]	; 0x24
 8027686:	783b      	ldrb	r3, [r7, #0]
 8027688:	2b00      	cmp	r3, #0
 802768a:	f000 809d 	beq.w	80277c8 <_svfiprintf_r+0x1b8>
 802768e:	2300      	movs	r3, #0
 8027690:	f04f 32ff 	mov.w	r2, #4294967295
 8027694:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8027698:	9304      	str	r3, [sp, #16]
 802769a:	9307      	str	r3, [sp, #28]
 802769c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80276a0:	931a      	str	r3, [sp, #104]	; 0x68
 80276a2:	462f      	mov	r7, r5
 80276a4:	2205      	movs	r2, #5
 80276a6:	f817 1b01 	ldrb.w	r1, [r7], #1
 80276aa:	4850      	ldr	r0, [pc, #320]	; (80277ec <_svfiprintf_r+0x1dc>)
 80276ac:	f7d8 fdc8 	bl	8000240 <memchr>
 80276b0:	9b04      	ldr	r3, [sp, #16]
 80276b2:	b9d0      	cbnz	r0, 80276ea <_svfiprintf_r+0xda>
 80276b4:	06d9      	lsls	r1, r3, #27
 80276b6:	bf44      	itt	mi
 80276b8:	2220      	movmi	r2, #32
 80276ba:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80276be:	071a      	lsls	r2, r3, #28
 80276c0:	bf44      	itt	mi
 80276c2:	222b      	movmi	r2, #43	; 0x2b
 80276c4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80276c8:	782a      	ldrb	r2, [r5, #0]
 80276ca:	2a2a      	cmp	r2, #42	; 0x2a
 80276cc:	d015      	beq.n	80276fa <_svfiprintf_r+0xea>
 80276ce:	9a07      	ldr	r2, [sp, #28]
 80276d0:	462f      	mov	r7, r5
 80276d2:	2000      	movs	r0, #0
 80276d4:	250a      	movs	r5, #10
 80276d6:	4639      	mov	r1, r7
 80276d8:	f811 3b01 	ldrb.w	r3, [r1], #1
 80276dc:	3b30      	subs	r3, #48	; 0x30
 80276de:	2b09      	cmp	r3, #9
 80276e0:	d94d      	bls.n	802777e <_svfiprintf_r+0x16e>
 80276e2:	b1b8      	cbz	r0, 8027714 <_svfiprintf_r+0x104>
 80276e4:	e00f      	b.n	8027706 <_svfiprintf_r+0xf6>
 80276e6:	462f      	mov	r7, r5
 80276e8:	e7b8      	b.n	802765c <_svfiprintf_r+0x4c>
 80276ea:	4a40      	ldr	r2, [pc, #256]	; (80277ec <_svfiprintf_r+0x1dc>)
 80276ec:	1a80      	subs	r0, r0, r2
 80276ee:	fa0b f000 	lsl.w	r0, fp, r0
 80276f2:	4318      	orrs	r0, r3
 80276f4:	9004      	str	r0, [sp, #16]
 80276f6:	463d      	mov	r5, r7
 80276f8:	e7d3      	b.n	80276a2 <_svfiprintf_r+0x92>
 80276fa:	9a03      	ldr	r2, [sp, #12]
 80276fc:	1d11      	adds	r1, r2, #4
 80276fe:	6812      	ldr	r2, [r2, #0]
 8027700:	9103      	str	r1, [sp, #12]
 8027702:	2a00      	cmp	r2, #0
 8027704:	db01      	blt.n	802770a <_svfiprintf_r+0xfa>
 8027706:	9207      	str	r2, [sp, #28]
 8027708:	e004      	b.n	8027714 <_svfiprintf_r+0x104>
 802770a:	4252      	negs	r2, r2
 802770c:	f043 0302 	orr.w	r3, r3, #2
 8027710:	9207      	str	r2, [sp, #28]
 8027712:	9304      	str	r3, [sp, #16]
 8027714:	783b      	ldrb	r3, [r7, #0]
 8027716:	2b2e      	cmp	r3, #46	; 0x2e
 8027718:	d10c      	bne.n	8027734 <_svfiprintf_r+0x124>
 802771a:	787b      	ldrb	r3, [r7, #1]
 802771c:	2b2a      	cmp	r3, #42	; 0x2a
 802771e:	d133      	bne.n	8027788 <_svfiprintf_r+0x178>
 8027720:	9b03      	ldr	r3, [sp, #12]
 8027722:	1d1a      	adds	r2, r3, #4
 8027724:	681b      	ldr	r3, [r3, #0]
 8027726:	9203      	str	r2, [sp, #12]
 8027728:	2b00      	cmp	r3, #0
 802772a:	bfb8      	it	lt
 802772c:	f04f 33ff 	movlt.w	r3, #4294967295
 8027730:	3702      	adds	r7, #2
 8027732:	9305      	str	r3, [sp, #20]
 8027734:	4d2e      	ldr	r5, [pc, #184]	; (80277f0 <_svfiprintf_r+0x1e0>)
 8027736:	7839      	ldrb	r1, [r7, #0]
 8027738:	2203      	movs	r2, #3
 802773a:	4628      	mov	r0, r5
 802773c:	f7d8 fd80 	bl	8000240 <memchr>
 8027740:	b138      	cbz	r0, 8027752 <_svfiprintf_r+0x142>
 8027742:	2340      	movs	r3, #64	; 0x40
 8027744:	1b40      	subs	r0, r0, r5
 8027746:	fa03 f000 	lsl.w	r0, r3, r0
 802774a:	9b04      	ldr	r3, [sp, #16]
 802774c:	4303      	orrs	r3, r0
 802774e:	3701      	adds	r7, #1
 8027750:	9304      	str	r3, [sp, #16]
 8027752:	7839      	ldrb	r1, [r7, #0]
 8027754:	4827      	ldr	r0, [pc, #156]	; (80277f4 <_svfiprintf_r+0x1e4>)
 8027756:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 802775a:	2206      	movs	r2, #6
 802775c:	1c7e      	adds	r6, r7, #1
 802775e:	f7d8 fd6f 	bl	8000240 <memchr>
 8027762:	2800      	cmp	r0, #0
 8027764:	d038      	beq.n	80277d8 <_svfiprintf_r+0x1c8>
 8027766:	4b24      	ldr	r3, [pc, #144]	; (80277f8 <_svfiprintf_r+0x1e8>)
 8027768:	bb13      	cbnz	r3, 80277b0 <_svfiprintf_r+0x1a0>
 802776a:	9b03      	ldr	r3, [sp, #12]
 802776c:	3307      	adds	r3, #7
 802776e:	f023 0307 	bic.w	r3, r3, #7
 8027772:	3308      	adds	r3, #8
 8027774:	9303      	str	r3, [sp, #12]
 8027776:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8027778:	444b      	add	r3, r9
 802777a:	9309      	str	r3, [sp, #36]	; 0x24
 802777c:	e76d      	b.n	802765a <_svfiprintf_r+0x4a>
 802777e:	fb05 3202 	mla	r2, r5, r2, r3
 8027782:	2001      	movs	r0, #1
 8027784:	460f      	mov	r7, r1
 8027786:	e7a6      	b.n	80276d6 <_svfiprintf_r+0xc6>
 8027788:	2300      	movs	r3, #0
 802778a:	3701      	adds	r7, #1
 802778c:	9305      	str	r3, [sp, #20]
 802778e:	4619      	mov	r1, r3
 8027790:	250a      	movs	r5, #10
 8027792:	4638      	mov	r0, r7
 8027794:	f810 2b01 	ldrb.w	r2, [r0], #1
 8027798:	3a30      	subs	r2, #48	; 0x30
 802779a:	2a09      	cmp	r2, #9
 802779c:	d903      	bls.n	80277a6 <_svfiprintf_r+0x196>
 802779e:	2b00      	cmp	r3, #0
 80277a0:	d0c8      	beq.n	8027734 <_svfiprintf_r+0x124>
 80277a2:	9105      	str	r1, [sp, #20]
 80277a4:	e7c6      	b.n	8027734 <_svfiprintf_r+0x124>
 80277a6:	fb05 2101 	mla	r1, r5, r1, r2
 80277aa:	2301      	movs	r3, #1
 80277ac:	4607      	mov	r7, r0
 80277ae:	e7f0      	b.n	8027792 <_svfiprintf_r+0x182>
 80277b0:	ab03      	add	r3, sp, #12
 80277b2:	9300      	str	r3, [sp, #0]
 80277b4:	4622      	mov	r2, r4
 80277b6:	4b11      	ldr	r3, [pc, #68]	; (80277fc <_svfiprintf_r+0x1ec>)
 80277b8:	a904      	add	r1, sp, #16
 80277ba:	4640      	mov	r0, r8
 80277bc:	f3af 8000 	nop.w
 80277c0:	f1b0 3fff 	cmp.w	r0, #4294967295
 80277c4:	4681      	mov	r9, r0
 80277c6:	d1d6      	bne.n	8027776 <_svfiprintf_r+0x166>
 80277c8:	89a3      	ldrh	r3, [r4, #12]
 80277ca:	065b      	lsls	r3, r3, #25
 80277cc:	f53f af35 	bmi.w	802763a <_svfiprintf_r+0x2a>
 80277d0:	9809      	ldr	r0, [sp, #36]	; 0x24
 80277d2:	b01d      	add	sp, #116	; 0x74
 80277d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80277d8:	ab03      	add	r3, sp, #12
 80277da:	9300      	str	r3, [sp, #0]
 80277dc:	4622      	mov	r2, r4
 80277de:	4b07      	ldr	r3, [pc, #28]	; (80277fc <_svfiprintf_r+0x1ec>)
 80277e0:	a904      	add	r1, sp, #16
 80277e2:	4640      	mov	r0, r8
 80277e4:	f000 f9c2 	bl	8027b6c <_printf_i>
 80277e8:	e7ea      	b.n	80277c0 <_svfiprintf_r+0x1b0>
 80277ea:	bf00      	nop
 80277ec:	0802b5c8 	.word	0x0802b5c8
 80277f0:	0802b5ce 	.word	0x0802b5ce
 80277f4:	0802b5d2 	.word	0x0802b5d2
 80277f8:	00000000 	.word	0x00000000
 80277fc:	0802755d 	.word	0x0802755d

08027800 <__sfputc_r>:
 8027800:	6893      	ldr	r3, [r2, #8]
 8027802:	3b01      	subs	r3, #1
 8027804:	2b00      	cmp	r3, #0
 8027806:	b410      	push	{r4}
 8027808:	6093      	str	r3, [r2, #8]
 802780a:	da08      	bge.n	802781e <__sfputc_r+0x1e>
 802780c:	6994      	ldr	r4, [r2, #24]
 802780e:	42a3      	cmp	r3, r4
 8027810:	db01      	blt.n	8027816 <__sfputc_r+0x16>
 8027812:	290a      	cmp	r1, #10
 8027814:	d103      	bne.n	802781e <__sfputc_r+0x1e>
 8027816:	f85d 4b04 	ldr.w	r4, [sp], #4
 802781a:	f000 bb0d 	b.w	8027e38 <__swbuf_r>
 802781e:	6813      	ldr	r3, [r2, #0]
 8027820:	1c58      	adds	r0, r3, #1
 8027822:	6010      	str	r0, [r2, #0]
 8027824:	7019      	strb	r1, [r3, #0]
 8027826:	4608      	mov	r0, r1
 8027828:	f85d 4b04 	ldr.w	r4, [sp], #4
 802782c:	4770      	bx	lr

0802782e <__sfputs_r>:
 802782e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8027830:	4606      	mov	r6, r0
 8027832:	460f      	mov	r7, r1
 8027834:	4614      	mov	r4, r2
 8027836:	18d5      	adds	r5, r2, r3
 8027838:	42ac      	cmp	r4, r5
 802783a:	d101      	bne.n	8027840 <__sfputs_r+0x12>
 802783c:	2000      	movs	r0, #0
 802783e:	e007      	b.n	8027850 <__sfputs_r+0x22>
 8027840:	463a      	mov	r2, r7
 8027842:	f814 1b01 	ldrb.w	r1, [r4], #1
 8027846:	4630      	mov	r0, r6
 8027848:	f7ff ffda 	bl	8027800 <__sfputc_r>
 802784c:	1c43      	adds	r3, r0, #1
 802784e:	d1f3      	bne.n	8027838 <__sfputs_r+0xa>
 8027850:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08027854 <_vfiprintf_r>:
 8027854:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8027858:	460c      	mov	r4, r1
 802785a:	b09d      	sub	sp, #116	; 0x74
 802785c:	4617      	mov	r7, r2
 802785e:	461d      	mov	r5, r3
 8027860:	4606      	mov	r6, r0
 8027862:	b118      	cbz	r0, 802786c <_vfiprintf_r+0x18>
 8027864:	6983      	ldr	r3, [r0, #24]
 8027866:	b90b      	cbnz	r3, 802786c <_vfiprintf_r+0x18>
 8027868:	f7ff fd94 	bl	8027394 <__sinit>
 802786c:	4b7c      	ldr	r3, [pc, #496]	; (8027a60 <_vfiprintf_r+0x20c>)
 802786e:	429c      	cmp	r4, r3
 8027870:	d158      	bne.n	8027924 <_vfiprintf_r+0xd0>
 8027872:	6874      	ldr	r4, [r6, #4]
 8027874:	89a3      	ldrh	r3, [r4, #12]
 8027876:	0718      	lsls	r0, r3, #28
 8027878:	d55e      	bpl.n	8027938 <_vfiprintf_r+0xe4>
 802787a:	6923      	ldr	r3, [r4, #16]
 802787c:	2b00      	cmp	r3, #0
 802787e:	d05b      	beq.n	8027938 <_vfiprintf_r+0xe4>
 8027880:	2300      	movs	r3, #0
 8027882:	9309      	str	r3, [sp, #36]	; 0x24
 8027884:	2320      	movs	r3, #32
 8027886:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 802788a:	2330      	movs	r3, #48	; 0x30
 802788c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8027890:	9503      	str	r5, [sp, #12]
 8027892:	f04f 0b01 	mov.w	fp, #1
 8027896:	46b8      	mov	r8, r7
 8027898:	4645      	mov	r5, r8
 802789a:	f815 3b01 	ldrb.w	r3, [r5], #1
 802789e:	b10b      	cbz	r3, 80278a4 <_vfiprintf_r+0x50>
 80278a0:	2b25      	cmp	r3, #37	; 0x25
 80278a2:	d154      	bne.n	802794e <_vfiprintf_r+0xfa>
 80278a4:	ebb8 0a07 	subs.w	sl, r8, r7
 80278a8:	d00b      	beq.n	80278c2 <_vfiprintf_r+0x6e>
 80278aa:	4653      	mov	r3, sl
 80278ac:	463a      	mov	r2, r7
 80278ae:	4621      	mov	r1, r4
 80278b0:	4630      	mov	r0, r6
 80278b2:	f7ff ffbc 	bl	802782e <__sfputs_r>
 80278b6:	3001      	adds	r0, #1
 80278b8:	f000 80c2 	beq.w	8027a40 <_vfiprintf_r+0x1ec>
 80278bc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80278be:	4453      	add	r3, sl
 80278c0:	9309      	str	r3, [sp, #36]	; 0x24
 80278c2:	f898 3000 	ldrb.w	r3, [r8]
 80278c6:	2b00      	cmp	r3, #0
 80278c8:	f000 80ba 	beq.w	8027a40 <_vfiprintf_r+0x1ec>
 80278cc:	2300      	movs	r3, #0
 80278ce:	f04f 32ff 	mov.w	r2, #4294967295
 80278d2:	e9cd 2305 	strd	r2, r3, [sp, #20]
 80278d6:	9304      	str	r3, [sp, #16]
 80278d8:	9307      	str	r3, [sp, #28]
 80278da:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 80278de:	931a      	str	r3, [sp, #104]	; 0x68
 80278e0:	46a8      	mov	r8, r5
 80278e2:	2205      	movs	r2, #5
 80278e4:	f818 1b01 	ldrb.w	r1, [r8], #1
 80278e8:	485e      	ldr	r0, [pc, #376]	; (8027a64 <_vfiprintf_r+0x210>)
 80278ea:	f7d8 fca9 	bl	8000240 <memchr>
 80278ee:	9b04      	ldr	r3, [sp, #16]
 80278f0:	bb78      	cbnz	r0, 8027952 <_vfiprintf_r+0xfe>
 80278f2:	06d9      	lsls	r1, r3, #27
 80278f4:	bf44      	itt	mi
 80278f6:	2220      	movmi	r2, #32
 80278f8:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 80278fc:	071a      	lsls	r2, r3, #28
 80278fe:	bf44      	itt	mi
 8027900:	222b      	movmi	r2, #43	; 0x2b
 8027902:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8027906:	782a      	ldrb	r2, [r5, #0]
 8027908:	2a2a      	cmp	r2, #42	; 0x2a
 802790a:	d02a      	beq.n	8027962 <_vfiprintf_r+0x10e>
 802790c:	9a07      	ldr	r2, [sp, #28]
 802790e:	46a8      	mov	r8, r5
 8027910:	2000      	movs	r0, #0
 8027912:	250a      	movs	r5, #10
 8027914:	4641      	mov	r1, r8
 8027916:	f811 3b01 	ldrb.w	r3, [r1], #1
 802791a:	3b30      	subs	r3, #48	; 0x30
 802791c:	2b09      	cmp	r3, #9
 802791e:	d969      	bls.n	80279f4 <_vfiprintf_r+0x1a0>
 8027920:	b360      	cbz	r0, 802797c <_vfiprintf_r+0x128>
 8027922:	e024      	b.n	802796e <_vfiprintf_r+0x11a>
 8027924:	4b50      	ldr	r3, [pc, #320]	; (8027a68 <_vfiprintf_r+0x214>)
 8027926:	429c      	cmp	r4, r3
 8027928:	d101      	bne.n	802792e <_vfiprintf_r+0xda>
 802792a:	68b4      	ldr	r4, [r6, #8]
 802792c:	e7a2      	b.n	8027874 <_vfiprintf_r+0x20>
 802792e:	4b4f      	ldr	r3, [pc, #316]	; (8027a6c <_vfiprintf_r+0x218>)
 8027930:	429c      	cmp	r4, r3
 8027932:	bf08      	it	eq
 8027934:	68f4      	ldreq	r4, [r6, #12]
 8027936:	e79d      	b.n	8027874 <_vfiprintf_r+0x20>
 8027938:	4621      	mov	r1, r4
 802793a:	4630      	mov	r0, r6
 802793c:	f000 fae0 	bl	8027f00 <__swsetup_r>
 8027940:	2800      	cmp	r0, #0
 8027942:	d09d      	beq.n	8027880 <_vfiprintf_r+0x2c>
 8027944:	f04f 30ff 	mov.w	r0, #4294967295
 8027948:	b01d      	add	sp, #116	; 0x74
 802794a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802794e:	46a8      	mov	r8, r5
 8027950:	e7a2      	b.n	8027898 <_vfiprintf_r+0x44>
 8027952:	4a44      	ldr	r2, [pc, #272]	; (8027a64 <_vfiprintf_r+0x210>)
 8027954:	1a80      	subs	r0, r0, r2
 8027956:	fa0b f000 	lsl.w	r0, fp, r0
 802795a:	4318      	orrs	r0, r3
 802795c:	9004      	str	r0, [sp, #16]
 802795e:	4645      	mov	r5, r8
 8027960:	e7be      	b.n	80278e0 <_vfiprintf_r+0x8c>
 8027962:	9a03      	ldr	r2, [sp, #12]
 8027964:	1d11      	adds	r1, r2, #4
 8027966:	6812      	ldr	r2, [r2, #0]
 8027968:	9103      	str	r1, [sp, #12]
 802796a:	2a00      	cmp	r2, #0
 802796c:	db01      	blt.n	8027972 <_vfiprintf_r+0x11e>
 802796e:	9207      	str	r2, [sp, #28]
 8027970:	e004      	b.n	802797c <_vfiprintf_r+0x128>
 8027972:	4252      	negs	r2, r2
 8027974:	f043 0302 	orr.w	r3, r3, #2
 8027978:	9207      	str	r2, [sp, #28]
 802797a:	9304      	str	r3, [sp, #16]
 802797c:	f898 3000 	ldrb.w	r3, [r8]
 8027980:	2b2e      	cmp	r3, #46	; 0x2e
 8027982:	d10e      	bne.n	80279a2 <_vfiprintf_r+0x14e>
 8027984:	f898 3001 	ldrb.w	r3, [r8, #1]
 8027988:	2b2a      	cmp	r3, #42	; 0x2a
 802798a:	d138      	bne.n	80279fe <_vfiprintf_r+0x1aa>
 802798c:	9b03      	ldr	r3, [sp, #12]
 802798e:	1d1a      	adds	r2, r3, #4
 8027990:	681b      	ldr	r3, [r3, #0]
 8027992:	9203      	str	r2, [sp, #12]
 8027994:	2b00      	cmp	r3, #0
 8027996:	bfb8      	it	lt
 8027998:	f04f 33ff 	movlt.w	r3, #4294967295
 802799c:	f108 0802 	add.w	r8, r8, #2
 80279a0:	9305      	str	r3, [sp, #20]
 80279a2:	4d33      	ldr	r5, [pc, #204]	; (8027a70 <_vfiprintf_r+0x21c>)
 80279a4:	f898 1000 	ldrb.w	r1, [r8]
 80279a8:	2203      	movs	r2, #3
 80279aa:	4628      	mov	r0, r5
 80279ac:	f7d8 fc48 	bl	8000240 <memchr>
 80279b0:	b140      	cbz	r0, 80279c4 <_vfiprintf_r+0x170>
 80279b2:	2340      	movs	r3, #64	; 0x40
 80279b4:	1b40      	subs	r0, r0, r5
 80279b6:	fa03 f000 	lsl.w	r0, r3, r0
 80279ba:	9b04      	ldr	r3, [sp, #16]
 80279bc:	4303      	orrs	r3, r0
 80279be:	f108 0801 	add.w	r8, r8, #1
 80279c2:	9304      	str	r3, [sp, #16]
 80279c4:	f898 1000 	ldrb.w	r1, [r8]
 80279c8:	482a      	ldr	r0, [pc, #168]	; (8027a74 <_vfiprintf_r+0x220>)
 80279ca:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 80279ce:	2206      	movs	r2, #6
 80279d0:	f108 0701 	add.w	r7, r8, #1
 80279d4:	f7d8 fc34 	bl	8000240 <memchr>
 80279d8:	2800      	cmp	r0, #0
 80279da:	d037      	beq.n	8027a4c <_vfiprintf_r+0x1f8>
 80279dc:	4b26      	ldr	r3, [pc, #152]	; (8027a78 <_vfiprintf_r+0x224>)
 80279de:	bb1b      	cbnz	r3, 8027a28 <_vfiprintf_r+0x1d4>
 80279e0:	9b03      	ldr	r3, [sp, #12]
 80279e2:	3307      	adds	r3, #7
 80279e4:	f023 0307 	bic.w	r3, r3, #7
 80279e8:	3308      	adds	r3, #8
 80279ea:	9303      	str	r3, [sp, #12]
 80279ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80279ee:	444b      	add	r3, r9
 80279f0:	9309      	str	r3, [sp, #36]	; 0x24
 80279f2:	e750      	b.n	8027896 <_vfiprintf_r+0x42>
 80279f4:	fb05 3202 	mla	r2, r5, r2, r3
 80279f8:	2001      	movs	r0, #1
 80279fa:	4688      	mov	r8, r1
 80279fc:	e78a      	b.n	8027914 <_vfiprintf_r+0xc0>
 80279fe:	2300      	movs	r3, #0
 8027a00:	f108 0801 	add.w	r8, r8, #1
 8027a04:	9305      	str	r3, [sp, #20]
 8027a06:	4619      	mov	r1, r3
 8027a08:	250a      	movs	r5, #10
 8027a0a:	4640      	mov	r0, r8
 8027a0c:	f810 2b01 	ldrb.w	r2, [r0], #1
 8027a10:	3a30      	subs	r2, #48	; 0x30
 8027a12:	2a09      	cmp	r2, #9
 8027a14:	d903      	bls.n	8027a1e <_vfiprintf_r+0x1ca>
 8027a16:	2b00      	cmp	r3, #0
 8027a18:	d0c3      	beq.n	80279a2 <_vfiprintf_r+0x14e>
 8027a1a:	9105      	str	r1, [sp, #20]
 8027a1c:	e7c1      	b.n	80279a2 <_vfiprintf_r+0x14e>
 8027a1e:	fb05 2101 	mla	r1, r5, r1, r2
 8027a22:	2301      	movs	r3, #1
 8027a24:	4680      	mov	r8, r0
 8027a26:	e7f0      	b.n	8027a0a <_vfiprintf_r+0x1b6>
 8027a28:	ab03      	add	r3, sp, #12
 8027a2a:	9300      	str	r3, [sp, #0]
 8027a2c:	4622      	mov	r2, r4
 8027a2e:	4b13      	ldr	r3, [pc, #76]	; (8027a7c <_vfiprintf_r+0x228>)
 8027a30:	a904      	add	r1, sp, #16
 8027a32:	4630      	mov	r0, r6
 8027a34:	f3af 8000 	nop.w
 8027a38:	f1b0 3fff 	cmp.w	r0, #4294967295
 8027a3c:	4681      	mov	r9, r0
 8027a3e:	d1d5      	bne.n	80279ec <_vfiprintf_r+0x198>
 8027a40:	89a3      	ldrh	r3, [r4, #12]
 8027a42:	065b      	lsls	r3, r3, #25
 8027a44:	f53f af7e 	bmi.w	8027944 <_vfiprintf_r+0xf0>
 8027a48:	9809      	ldr	r0, [sp, #36]	; 0x24
 8027a4a:	e77d      	b.n	8027948 <_vfiprintf_r+0xf4>
 8027a4c:	ab03      	add	r3, sp, #12
 8027a4e:	9300      	str	r3, [sp, #0]
 8027a50:	4622      	mov	r2, r4
 8027a52:	4b0a      	ldr	r3, [pc, #40]	; (8027a7c <_vfiprintf_r+0x228>)
 8027a54:	a904      	add	r1, sp, #16
 8027a56:	4630      	mov	r0, r6
 8027a58:	f000 f888 	bl	8027b6c <_printf_i>
 8027a5c:	e7ec      	b.n	8027a38 <_vfiprintf_r+0x1e4>
 8027a5e:	bf00      	nop
 8027a60:	0802b588 	.word	0x0802b588
 8027a64:	0802b5c8 	.word	0x0802b5c8
 8027a68:	0802b5a8 	.word	0x0802b5a8
 8027a6c:	0802b568 	.word	0x0802b568
 8027a70:	0802b5ce 	.word	0x0802b5ce
 8027a74:	0802b5d2 	.word	0x0802b5d2
 8027a78:	00000000 	.word	0x00000000
 8027a7c:	0802782f 	.word	0x0802782f

08027a80 <_printf_common>:
 8027a80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8027a84:	4691      	mov	r9, r2
 8027a86:	461f      	mov	r7, r3
 8027a88:	688a      	ldr	r2, [r1, #8]
 8027a8a:	690b      	ldr	r3, [r1, #16]
 8027a8c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8027a90:	4293      	cmp	r3, r2
 8027a92:	bfb8      	it	lt
 8027a94:	4613      	movlt	r3, r2
 8027a96:	f8c9 3000 	str.w	r3, [r9]
 8027a9a:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 8027a9e:	4606      	mov	r6, r0
 8027aa0:	460c      	mov	r4, r1
 8027aa2:	b112      	cbz	r2, 8027aaa <_printf_common+0x2a>
 8027aa4:	3301      	adds	r3, #1
 8027aa6:	f8c9 3000 	str.w	r3, [r9]
 8027aaa:	6823      	ldr	r3, [r4, #0]
 8027aac:	0699      	lsls	r1, r3, #26
 8027aae:	bf42      	ittt	mi
 8027ab0:	f8d9 3000 	ldrmi.w	r3, [r9]
 8027ab4:	3302      	addmi	r3, #2
 8027ab6:	f8c9 3000 	strmi.w	r3, [r9]
 8027aba:	6825      	ldr	r5, [r4, #0]
 8027abc:	f015 0506 	ands.w	r5, r5, #6
 8027ac0:	d107      	bne.n	8027ad2 <_printf_common+0x52>
 8027ac2:	f104 0a19 	add.w	sl, r4, #25
 8027ac6:	68e3      	ldr	r3, [r4, #12]
 8027ac8:	f8d9 2000 	ldr.w	r2, [r9]
 8027acc:	1a9b      	subs	r3, r3, r2
 8027ace:	42ab      	cmp	r3, r5
 8027ad0:	dc28      	bgt.n	8027b24 <_printf_common+0xa4>
 8027ad2:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 8027ad6:	6822      	ldr	r2, [r4, #0]
 8027ad8:	3300      	adds	r3, #0
 8027ada:	bf18      	it	ne
 8027adc:	2301      	movne	r3, #1
 8027ade:	0692      	lsls	r2, r2, #26
 8027ae0:	d42d      	bmi.n	8027b3e <_printf_common+0xbe>
 8027ae2:	f104 0243 	add.w	r2, r4, #67	; 0x43
 8027ae6:	4639      	mov	r1, r7
 8027ae8:	4630      	mov	r0, r6
 8027aea:	47c0      	blx	r8
 8027aec:	3001      	adds	r0, #1
 8027aee:	d020      	beq.n	8027b32 <_printf_common+0xb2>
 8027af0:	6823      	ldr	r3, [r4, #0]
 8027af2:	68e5      	ldr	r5, [r4, #12]
 8027af4:	f8d9 2000 	ldr.w	r2, [r9]
 8027af8:	f003 0306 	and.w	r3, r3, #6
 8027afc:	2b04      	cmp	r3, #4
 8027afe:	bf08      	it	eq
 8027b00:	1aad      	subeq	r5, r5, r2
 8027b02:	68a3      	ldr	r3, [r4, #8]
 8027b04:	6922      	ldr	r2, [r4, #16]
 8027b06:	bf0c      	ite	eq
 8027b08:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 8027b0c:	2500      	movne	r5, #0
 8027b0e:	4293      	cmp	r3, r2
 8027b10:	bfc4      	itt	gt
 8027b12:	1a9b      	subgt	r3, r3, r2
 8027b14:	18ed      	addgt	r5, r5, r3
 8027b16:	f04f 0900 	mov.w	r9, #0
 8027b1a:	341a      	adds	r4, #26
 8027b1c:	454d      	cmp	r5, r9
 8027b1e:	d11a      	bne.n	8027b56 <_printf_common+0xd6>
 8027b20:	2000      	movs	r0, #0
 8027b22:	e008      	b.n	8027b36 <_printf_common+0xb6>
 8027b24:	2301      	movs	r3, #1
 8027b26:	4652      	mov	r2, sl
 8027b28:	4639      	mov	r1, r7
 8027b2a:	4630      	mov	r0, r6
 8027b2c:	47c0      	blx	r8
 8027b2e:	3001      	adds	r0, #1
 8027b30:	d103      	bne.n	8027b3a <_printf_common+0xba>
 8027b32:	f04f 30ff 	mov.w	r0, #4294967295
 8027b36:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8027b3a:	3501      	adds	r5, #1
 8027b3c:	e7c3      	b.n	8027ac6 <_printf_common+0x46>
 8027b3e:	18e1      	adds	r1, r4, r3
 8027b40:	1c5a      	adds	r2, r3, #1
 8027b42:	2030      	movs	r0, #48	; 0x30
 8027b44:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8027b48:	4422      	add	r2, r4
 8027b4a:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 8027b4e:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 8027b52:	3302      	adds	r3, #2
 8027b54:	e7c5      	b.n	8027ae2 <_printf_common+0x62>
 8027b56:	2301      	movs	r3, #1
 8027b58:	4622      	mov	r2, r4
 8027b5a:	4639      	mov	r1, r7
 8027b5c:	4630      	mov	r0, r6
 8027b5e:	47c0      	blx	r8
 8027b60:	3001      	adds	r0, #1
 8027b62:	d0e6      	beq.n	8027b32 <_printf_common+0xb2>
 8027b64:	f109 0901 	add.w	r9, r9, #1
 8027b68:	e7d8      	b.n	8027b1c <_printf_common+0x9c>
	...

08027b6c <_printf_i>:
 8027b6c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8027b70:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 8027b74:	460c      	mov	r4, r1
 8027b76:	7e09      	ldrb	r1, [r1, #24]
 8027b78:	b085      	sub	sp, #20
 8027b7a:	296e      	cmp	r1, #110	; 0x6e
 8027b7c:	4617      	mov	r7, r2
 8027b7e:	4606      	mov	r6, r0
 8027b80:	4698      	mov	r8, r3
 8027b82:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8027b84:	f000 80b3 	beq.w	8027cee <_printf_i+0x182>
 8027b88:	d822      	bhi.n	8027bd0 <_printf_i+0x64>
 8027b8a:	2963      	cmp	r1, #99	; 0x63
 8027b8c:	d036      	beq.n	8027bfc <_printf_i+0x90>
 8027b8e:	d80a      	bhi.n	8027ba6 <_printf_i+0x3a>
 8027b90:	2900      	cmp	r1, #0
 8027b92:	f000 80b9 	beq.w	8027d08 <_printf_i+0x19c>
 8027b96:	2958      	cmp	r1, #88	; 0x58
 8027b98:	f000 8083 	beq.w	8027ca2 <_printf_i+0x136>
 8027b9c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8027ba0:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8027ba4:	e032      	b.n	8027c0c <_printf_i+0xa0>
 8027ba6:	2964      	cmp	r1, #100	; 0x64
 8027ba8:	d001      	beq.n	8027bae <_printf_i+0x42>
 8027baa:	2969      	cmp	r1, #105	; 0x69
 8027bac:	d1f6      	bne.n	8027b9c <_printf_i+0x30>
 8027bae:	6820      	ldr	r0, [r4, #0]
 8027bb0:	6813      	ldr	r3, [r2, #0]
 8027bb2:	0605      	lsls	r5, r0, #24
 8027bb4:	f103 0104 	add.w	r1, r3, #4
 8027bb8:	d52a      	bpl.n	8027c10 <_printf_i+0xa4>
 8027bba:	681b      	ldr	r3, [r3, #0]
 8027bbc:	6011      	str	r1, [r2, #0]
 8027bbe:	2b00      	cmp	r3, #0
 8027bc0:	da03      	bge.n	8027bca <_printf_i+0x5e>
 8027bc2:	222d      	movs	r2, #45	; 0x2d
 8027bc4:	425b      	negs	r3, r3
 8027bc6:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 8027bca:	486f      	ldr	r0, [pc, #444]	; (8027d88 <_printf_i+0x21c>)
 8027bcc:	220a      	movs	r2, #10
 8027bce:	e039      	b.n	8027c44 <_printf_i+0xd8>
 8027bd0:	2973      	cmp	r1, #115	; 0x73
 8027bd2:	f000 809d 	beq.w	8027d10 <_printf_i+0x1a4>
 8027bd6:	d808      	bhi.n	8027bea <_printf_i+0x7e>
 8027bd8:	296f      	cmp	r1, #111	; 0x6f
 8027bda:	d020      	beq.n	8027c1e <_printf_i+0xb2>
 8027bdc:	2970      	cmp	r1, #112	; 0x70
 8027bde:	d1dd      	bne.n	8027b9c <_printf_i+0x30>
 8027be0:	6823      	ldr	r3, [r4, #0]
 8027be2:	f043 0320 	orr.w	r3, r3, #32
 8027be6:	6023      	str	r3, [r4, #0]
 8027be8:	e003      	b.n	8027bf2 <_printf_i+0x86>
 8027bea:	2975      	cmp	r1, #117	; 0x75
 8027bec:	d017      	beq.n	8027c1e <_printf_i+0xb2>
 8027bee:	2978      	cmp	r1, #120	; 0x78
 8027bf0:	d1d4      	bne.n	8027b9c <_printf_i+0x30>
 8027bf2:	2378      	movs	r3, #120	; 0x78
 8027bf4:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 8027bf8:	4864      	ldr	r0, [pc, #400]	; (8027d8c <_printf_i+0x220>)
 8027bfa:	e055      	b.n	8027ca8 <_printf_i+0x13c>
 8027bfc:	6813      	ldr	r3, [r2, #0]
 8027bfe:	1d19      	adds	r1, r3, #4
 8027c00:	681b      	ldr	r3, [r3, #0]
 8027c02:	6011      	str	r1, [r2, #0]
 8027c04:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8027c08:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8027c0c:	2301      	movs	r3, #1
 8027c0e:	e08c      	b.n	8027d2a <_printf_i+0x1be>
 8027c10:	681b      	ldr	r3, [r3, #0]
 8027c12:	6011      	str	r1, [r2, #0]
 8027c14:	f010 0f40 	tst.w	r0, #64	; 0x40
 8027c18:	bf18      	it	ne
 8027c1a:	b21b      	sxthne	r3, r3
 8027c1c:	e7cf      	b.n	8027bbe <_printf_i+0x52>
 8027c1e:	6813      	ldr	r3, [r2, #0]
 8027c20:	6825      	ldr	r5, [r4, #0]
 8027c22:	1d18      	adds	r0, r3, #4
 8027c24:	6010      	str	r0, [r2, #0]
 8027c26:	0628      	lsls	r0, r5, #24
 8027c28:	d501      	bpl.n	8027c2e <_printf_i+0xc2>
 8027c2a:	681b      	ldr	r3, [r3, #0]
 8027c2c:	e002      	b.n	8027c34 <_printf_i+0xc8>
 8027c2e:	0668      	lsls	r0, r5, #25
 8027c30:	d5fb      	bpl.n	8027c2a <_printf_i+0xbe>
 8027c32:	881b      	ldrh	r3, [r3, #0]
 8027c34:	4854      	ldr	r0, [pc, #336]	; (8027d88 <_printf_i+0x21c>)
 8027c36:	296f      	cmp	r1, #111	; 0x6f
 8027c38:	bf14      	ite	ne
 8027c3a:	220a      	movne	r2, #10
 8027c3c:	2208      	moveq	r2, #8
 8027c3e:	2100      	movs	r1, #0
 8027c40:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8027c44:	6865      	ldr	r5, [r4, #4]
 8027c46:	60a5      	str	r5, [r4, #8]
 8027c48:	2d00      	cmp	r5, #0
 8027c4a:	f2c0 8095 	blt.w	8027d78 <_printf_i+0x20c>
 8027c4e:	6821      	ldr	r1, [r4, #0]
 8027c50:	f021 0104 	bic.w	r1, r1, #4
 8027c54:	6021      	str	r1, [r4, #0]
 8027c56:	2b00      	cmp	r3, #0
 8027c58:	d13d      	bne.n	8027cd6 <_printf_i+0x16a>
 8027c5a:	2d00      	cmp	r5, #0
 8027c5c:	f040 808e 	bne.w	8027d7c <_printf_i+0x210>
 8027c60:	4665      	mov	r5, ip
 8027c62:	2a08      	cmp	r2, #8
 8027c64:	d10b      	bne.n	8027c7e <_printf_i+0x112>
 8027c66:	6823      	ldr	r3, [r4, #0]
 8027c68:	07db      	lsls	r3, r3, #31
 8027c6a:	d508      	bpl.n	8027c7e <_printf_i+0x112>
 8027c6c:	6923      	ldr	r3, [r4, #16]
 8027c6e:	6862      	ldr	r2, [r4, #4]
 8027c70:	429a      	cmp	r2, r3
 8027c72:	bfde      	ittt	le
 8027c74:	2330      	movle	r3, #48	; 0x30
 8027c76:	f805 3c01 	strble.w	r3, [r5, #-1]
 8027c7a:	f105 35ff 	addle.w	r5, r5, #4294967295
 8027c7e:	ebac 0305 	sub.w	r3, ip, r5
 8027c82:	6123      	str	r3, [r4, #16]
 8027c84:	f8cd 8000 	str.w	r8, [sp]
 8027c88:	463b      	mov	r3, r7
 8027c8a:	aa03      	add	r2, sp, #12
 8027c8c:	4621      	mov	r1, r4
 8027c8e:	4630      	mov	r0, r6
 8027c90:	f7ff fef6 	bl	8027a80 <_printf_common>
 8027c94:	3001      	adds	r0, #1
 8027c96:	d14d      	bne.n	8027d34 <_printf_i+0x1c8>
 8027c98:	f04f 30ff 	mov.w	r0, #4294967295
 8027c9c:	b005      	add	sp, #20
 8027c9e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8027ca2:	4839      	ldr	r0, [pc, #228]	; (8027d88 <_printf_i+0x21c>)
 8027ca4:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 8027ca8:	6813      	ldr	r3, [r2, #0]
 8027caa:	6821      	ldr	r1, [r4, #0]
 8027cac:	1d1d      	adds	r5, r3, #4
 8027cae:	681b      	ldr	r3, [r3, #0]
 8027cb0:	6015      	str	r5, [r2, #0]
 8027cb2:	060a      	lsls	r2, r1, #24
 8027cb4:	d50b      	bpl.n	8027cce <_printf_i+0x162>
 8027cb6:	07ca      	lsls	r2, r1, #31
 8027cb8:	bf44      	itt	mi
 8027cba:	f041 0120 	orrmi.w	r1, r1, #32
 8027cbe:	6021      	strmi	r1, [r4, #0]
 8027cc0:	b91b      	cbnz	r3, 8027cca <_printf_i+0x15e>
 8027cc2:	6822      	ldr	r2, [r4, #0]
 8027cc4:	f022 0220 	bic.w	r2, r2, #32
 8027cc8:	6022      	str	r2, [r4, #0]
 8027cca:	2210      	movs	r2, #16
 8027ccc:	e7b7      	b.n	8027c3e <_printf_i+0xd2>
 8027cce:	064d      	lsls	r5, r1, #25
 8027cd0:	bf48      	it	mi
 8027cd2:	b29b      	uxthmi	r3, r3
 8027cd4:	e7ef      	b.n	8027cb6 <_printf_i+0x14a>
 8027cd6:	4665      	mov	r5, ip
 8027cd8:	fbb3 f1f2 	udiv	r1, r3, r2
 8027cdc:	fb02 3311 	mls	r3, r2, r1, r3
 8027ce0:	5cc3      	ldrb	r3, [r0, r3]
 8027ce2:	f805 3d01 	strb.w	r3, [r5, #-1]!
 8027ce6:	460b      	mov	r3, r1
 8027ce8:	2900      	cmp	r1, #0
 8027cea:	d1f5      	bne.n	8027cd8 <_printf_i+0x16c>
 8027cec:	e7b9      	b.n	8027c62 <_printf_i+0xf6>
 8027cee:	6813      	ldr	r3, [r2, #0]
 8027cf0:	6825      	ldr	r5, [r4, #0]
 8027cf2:	6961      	ldr	r1, [r4, #20]
 8027cf4:	1d18      	adds	r0, r3, #4
 8027cf6:	6010      	str	r0, [r2, #0]
 8027cf8:	0628      	lsls	r0, r5, #24
 8027cfa:	681b      	ldr	r3, [r3, #0]
 8027cfc:	d501      	bpl.n	8027d02 <_printf_i+0x196>
 8027cfe:	6019      	str	r1, [r3, #0]
 8027d00:	e002      	b.n	8027d08 <_printf_i+0x19c>
 8027d02:	066a      	lsls	r2, r5, #25
 8027d04:	d5fb      	bpl.n	8027cfe <_printf_i+0x192>
 8027d06:	8019      	strh	r1, [r3, #0]
 8027d08:	2300      	movs	r3, #0
 8027d0a:	6123      	str	r3, [r4, #16]
 8027d0c:	4665      	mov	r5, ip
 8027d0e:	e7b9      	b.n	8027c84 <_printf_i+0x118>
 8027d10:	6813      	ldr	r3, [r2, #0]
 8027d12:	1d19      	adds	r1, r3, #4
 8027d14:	6011      	str	r1, [r2, #0]
 8027d16:	681d      	ldr	r5, [r3, #0]
 8027d18:	6862      	ldr	r2, [r4, #4]
 8027d1a:	2100      	movs	r1, #0
 8027d1c:	4628      	mov	r0, r5
 8027d1e:	f7d8 fa8f 	bl	8000240 <memchr>
 8027d22:	b108      	cbz	r0, 8027d28 <_printf_i+0x1bc>
 8027d24:	1b40      	subs	r0, r0, r5
 8027d26:	6060      	str	r0, [r4, #4]
 8027d28:	6863      	ldr	r3, [r4, #4]
 8027d2a:	6123      	str	r3, [r4, #16]
 8027d2c:	2300      	movs	r3, #0
 8027d2e:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 8027d32:	e7a7      	b.n	8027c84 <_printf_i+0x118>
 8027d34:	6923      	ldr	r3, [r4, #16]
 8027d36:	462a      	mov	r2, r5
 8027d38:	4639      	mov	r1, r7
 8027d3a:	4630      	mov	r0, r6
 8027d3c:	47c0      	blx	r8
 8027d3e:	3001      	adds	r0, #1
 8027d40:	d0aa      	beq.n	8027c98 <_printf_i+0x12c>
 8027d42:	6823      	ldr	r3, [r4, #0]
 8027d44:	079b      	lsls	r3, r3, #30
 8027d46:	d413      	bmi.n	8027d70 <_printf_i+0x204>
 8027d48:	68e0      	ldr	r0, [r4, #12]
 8027d4a:	9b03      	ldr	r3, [sp, #12]
 8027d4c:	4298      	cmp	r0, r3
 8027d4e:	bfb8      	it	lt
 8027d50:	4618      	movlt	r0, r3
 8027d52:	e7a3      	b.n	8027c9c <_printf_i+0x130>
 8027d54:	2301      	movs	r3, #1
 8027d56:	464a      	mov	r2, r9
 8027d58:	4639      	mov	r1, r7
 8027d5a:	4630      	mov	r0, r6
 8027d5c:	47c0      	blx	r8
 8027d5e:	3001      	adds	r0, #1
 8027d60:	d09a      	beq.n	8027c98 <_printf_i+0x12c>
 8027d62:	3501      	adds	r5, #1
 8027d64:	68e3      	ldr	r3, [r4, #12]
 8027d66:	9a03      	ldr	r2, [sp, #12]
 8027d68:	1a9b      	subs	r3, r3, r2
 8027d6a:	42ab      	cmp	r3, r5
 8027d6c:	dcf2      	bgt.n	8027d54 <_printf_i+0x1e8>
 8027d6e:	e7eb      	b.n	8027d48 <_printf_i+0x1dc>
 8027d70:	2500      	movs	r5, #0
 8027d72:	f104 0919 	add.w	r9, r4, #25
 8027d76:	e7f5      	b.n	8027d64 <_printf_i+0x1f8>
 8027d78:	2b00      	cmp	r3, #0
 8027d7a:	d1ac      	bne.n	8027cd6 <_printf_i+0x16a>
 8027d7c:	7803      	ldrb	r3, [r0, #0]
 8027d7e:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 8027d82:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8027d86:	e76c      	b.n	8027c62 <_printf_i+0xf6>
 8027d88:	0802b5d9 	.word	0x0802b5d9
 8027d8c:	0802b5ea 	.word	0x0802b5ea

08027d90 <_sbrk_r>:
 8027d90:	b538      	push	{r3, r4, r5, lr}
 8027d92:	4c06      	ldr	r4, [pc, #24]	; (8027dac <_sbrk_r+0x1c>)
 8027d94:	2300      	movs	r3, #0
 8027d96:	4605      	mov	r5, r0
 8027d98:	4608      	mov	r0, r1
 8027d9a:	6023      	str	r3, [r4, #0]
 8027d9c:	f7e2 fb9a 	bl	800a4d4 <_sbrk>
 8027da0:	1c43      	adds	r3, r0, #1
 8027da2:	d102      	bne.n	8027daa <_sbrk_r+0x1a>
 8027da4:	6823      	ldr	r3, [r4, #0]
 8027da6:	b103      	cbz	r3, 8027daa <_sbrk_r+0x1a>
 8027da8:	602b      	str	r3, [r5, #0]
 8027daa:	bd38      	pop	{r3, r4, r5, pc}
 8027dac:	2000dfb0 	.word	0x2000dfb0

08027db0 <__sread>:
 8027db0:	b510      	push	{r4, lr}
 8027db2:	460c      	mov	r4, r1
 8027db4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027db8:	f000 fad6 	bl	8028368 <_read_r>
 8027dbc:	2800      	cmp	r0, #0
 8027dbe:	bfab      	itete	ge
 8027dc0:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 8027dc2:	89a3      	ldrhlt	r3, [r4, #12]
 8027dc4:	181b      	addge	r3, r3, r0
 8027dc6:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8027dca:	bfac      	ite	ge
 8027dcc:	6563      	strge	r3, [r4, #84]	; 0x54
 8027dce:	81a3      	strhlt	r3, [r4, #12]
 8027dd0:	bd10      	pop	{r4, pc}

08027dd2 <__swrite>:
 8027dd2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027dd6:	461f      	mov	r7, r3
 8027dd8:	898b      	ldrh	r3, [r1, #12]
 8027dda:	05db      	lsls	r3, r3, #23
 8027ddc:	4605      	mov	r5, r0
 8027dde:	460c      	mov	r4, r1
 8027de0:	4616      	mov	r6, r2
 8027de2:	d505      	bpl.n	8027df0 <__swrite+0x1e>
 8027de4:	2302      	movs	r3, #2
 8027de6:	2200      	movs	r2, #0
 8027de8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027dec:	f000 f9b6 	bl	802815c <_lseek_r>
 8027df0:	89a3      	ldrh	r3, [r4, #12]
 8027df2:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8027df6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8027dfa:	81a3      	strh	r3, [r4, #12]
 8027dfc:	4632      	mov	r2, r6
 8027dfe:	463b      	mov	r3, r7
 8027e00:	4628      	mov	r0, r5
 8027e02:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8027e06:	f000 b869 	b.w	8027edc <_write_r>

08027e0a <__sseek>:
 8027e0a:	b510      	push	{r4, lr}
 8027e0c:	460c      	mov	r4, r1
 8027e0e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027e12:	f000 f9a3 	bl	802815c <_lseek_r>
 8027e16:	1c43      	adds	r3, r0, #1
 8027e18:	89a3      	ldrh	r3, [r4, #12]
 8027e1a:	bf15      	itete	ne
 8027e1c:	6560      	strne	r0, [r4, #84]	; 0x54
 8027e1e:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 8027e22:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 8027e26:	81a3      	strheq	r3, [r4, #12]
 8027e28:	bf18      	it	ne
 8027e2a:	81a3      	strhne	r3, [r4, #12]
 8027e2c:	bd10      	pop	{r4, pc}

08027e2e <__sclose>:
 8027e2e:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8027e32:	f000 b8d3 	b.w	8027fdc <_close_r>
	...

08027e38 <__swbuf_r>:
 8027e38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8027e3a:	460e      	mov	r6, r1
 8027e3c:	4614      	mov	r4, r2
 8027e3e:	4605      	mov	r5, r0
 8027e40:	b118      	cbz	r0, 8027e4a <__swbuf_r+0x12>
 8027e42:	6983      	ldr	r3, [r0, #24]
 8027e44:	b90b      	cbnz	r3, 8027e4a <__swbuf_r+0x12>
 8027e46:	f7ff faa5 	bl	8027394 <__sinit>
 8027e4a:	4b21      	ldr	r3, [pc, #132]	; (8027ed0 <__swbuf_r+0x98>)
 8027e4c:	429c      	cmp	r4, r3
 8027e4e:	d12a      	bne.n	8027ea6 <__swbuf_r+0x6e>
 8027e50:	686c      	ldr	r4, [r5, #4]
 8027e52:	69a3      	ldr	r3, [r4, #24]
 8027e54:	60a3      	str	r3, [r4, #8]
 8027e56:	89a3      	ldrh	r3, [r4, #12]
 8027e58:	071a      	lsls	r2, r3, #28
 8027e5a:	d52e      	bpl.n	8027eba <__swbuf_r+0x82>
 8027e5c:	6923      	ldr	r3, [r4, #16]
 8027e5e:	b363      	cbz	r3, 8027eba <__swbuf_r+0x82>
 8027e60:	6923      	ldr	r3, [r4, #16]
 8027e62:	6820      	ldr	r0, [r4, #0]
 8027e64:	1ac0      	subs	r0, r0, r3
 8027e66:	6963      	ldr	r3, [r4, #20]
 8027e68:	b2f6      	uxtb	r6, r6
 8027e6a:	4283      	cmp	r3, r0
 8027e6c:	4637      	mov	r7, r6
 8027e6e:	dc04      	bgt.n	8027e7a <__swbuf_r+0x42>
 8027e70:	4621      	mov	r1, r4
 8027e72:	4628      	mov	r0, r5
 8027e74:	f000 f948 	bl	8028108 <_fflush_r>
 8027e78:	bb28      	cbnz	r0, 8027ec6 <__swbuf_r+0x8e>
 8027e7a:	68a3      	ldr	r3, [r4, #8]
 8027e7c:	3b01      	subs	r3, #1
 8027e7e:	60a3      	str	r3, [r4, #8]
 8027e80:	6823      	ldr	r3, [r4, #0]
 8027e82:	1c5a      	adds	r2, r3, #1
 8027e84:	6022      	str	r2, [r4, #0]
 8027e86:	701e      	strb	r6, [r3, #0]
 8027e88:	6963      	ldr	r3, [r4, #20]
 8027e8a:	3001      	adds	r0, #1
 8027e8c:	4283      	cmp	r3, r0
 8027e8e:	d004      	beq.n	8027e9a <__swbuf_r+0x62>
 8027e90:	89a3      	ldrh	r3, [r4, #12]
 8027e92:	07db      	lsls	r3, r3, #31
 8027e94:	d519      	bpl.n	8027eca <__swbuf_r+0x92>
 8027e96:	2e0a      	cmp	r6, #10
 8027e98:	d117      	bne.n	8027eca <__swbuf_r+0x92>
 8027e9a:	4621      	mov	r1, r4
 8027e9c:	4628      	mov	r0, r5
 8027e9e:	f000 f933 	bl	8028108 <_fflush_r>
 8027ea2:	b190      	cbz	r0, 8027eca <__swbuf_r+0x92>
 8027ea4:	e00f      	b.n	8027ec6 <__swbuf_r+0x8e>
 8027ea6:	4b0b      	ldr	r3, [pc, #44]	; (8027ed4 <__swbuf_r+0x9c>)
 8027ea8:	429c      	cmp	r4, r3
 8027eaa:	d101      	bne.n	8027eb0 <__swbuf_r+0x78>
 8027eac:	68ac      	ldr	r4, [r5, #8]
 8027eae:	e7d0      	b.n	8027e52 <__swbuf_r+0x1a>
 8027eb0:	4b09      	ldr	r3, [pc, #36]	; (8027ed8 <__swbuf_r+0xa0>)
 8027eb2:	429c      	cmp	r4, r3
 8027eb4:	bf08      	it	eq
 8027eb6:	68ec      	ldreq	r4, [r5, #12]
 8027eb8:	e7cb      	b.n	8027e52 <__swbuf_r+0x1a>
 8027eba:	4621      	mov	r1, r4
 8027ebc:	4628      	mov	r0, r5
 8027ebe:	f000 f81f 	bl	8027f00 <__swsetup_r>
 8027ec2:	2800      	cmp	r0, #0
 8027ec4:	d0cc      	beq.n	8027e60 <__swbuf_r+0x28>
 8027ec6:	f04f 37ff 	mov.w	r7, #4294967295
 8027eca:	4638      	mov	r0, r7
 8027ecc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027ece:	bf00      	nop
 8027ed0:	0802b588 	.word	0x0802b588
 8027ed4:	0802b5a8 	.word	0x0802b5a8
 8027ed8:	0802b568 	.word	0x0802b568

08027edc <_write_r>:
 8027edc:	b538      	push	{r3, r4, r5, lr}
 8027ede:	4c07      	ldr	r4, [pc, #28]	; (8027efc <_write_r+0x20>)
 8027ee0:	4605      	mov	r5, r0
 8027ee2:	4608      	mov	r0, r1
 8027ee4:	4611      	mov	r1, r2
 8027ee6:	2200      	movs	r2, #0
 8027ee8:	6022      	str	r2, [r4, #0]
 8027eea:	461a      	mov	r2, r3
 8027eec:	f7e2 faa1 	bl	800a432 <_write>
 8027ef0:	1c43      	adds	r3, r0, #1
 8027ef2:	d102      	bne.n	8027efa <_write_r+0x1e>
 8027ef4:	6823      	ldr	r3, [r4, #0]
 8027ef6:	b103      	cbz	r3, 8027efa <_write_r+0x1e>
 8027ef8:	602b      	str	r3, [r5, #0]
 8027efa:	bd38      	pop	{r3, r4, r5, pc}
 8027efc:	2000dfb0 	.word	0x2000dfb0

08027f00 <__swsetup_r>:
 8027f00:	4b32      	ldr	r3, [pc, #200]	; (8027fcc <__swsetup_r+0xcc>)
 8027f02:	b570      	push	{r4, r5, r6, lr}
 8027f04:	681d      	ldr	r5, [r3, #0]
 8027f06:	4606      	mov	r6, r0
 8027f08:	460c      	mov	r4, r1
 8027f0a:	b125      	cbz	r5, 8027f16 <__swsetup_r+0x16>
 8027f0c:	69ab      	ldr	r3, [r5, #24]
 8027f0e:	b913      	cbnz	r3, 8027f16 <__swsetup_r+0x16>
 8027f10:	4628      	mov	r0, r5
 8027f12:	f7ff fa3f 	bl	8027394 <__sinit>
 8027f16:	4b2e      	ldr	r3, [pc, #184]	; (8027fd0 <__swsetup_r+0xd0>)
 8027f18:	429c      	cmp	r4, r3
 8027f1a:	d10f      	bne.n	8027f3c <__swsetup_r+0x3c>
 8027f1c:	686c      	ldr	r4, [r5, #4]
 8027f1e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027f22:	b29a      	uxth	r2, r3
 8027f24:	0715      	lsls	r5, r2, #28
 8027f26:	d42c      	bmi.n	8027f82 <__swsetup_r+0x82>
 8027f28:	06d0      	lsls	r0, r2, #27
 8027f2a:	d411      	bmi.n	8027f50 <__swsetup_r+0x50>
 8027f2c:	2209      	movs	r2, #9
 8027f2e:	6032      	str	r2, [r6, #0]
 8027f30:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8027f34:	81a3      	strh	r3, [r4, #12]
 8027f36:	f04f 30ff 	mov.w	r0, #4294967295
 8027f3a:	e03e      	b.n	8027fba <__swsetup_r+0xba>
 8027f3c:	4b25      	ldr	r3, [pc, #148]	; (8027fd4 <__swsetup_r+0xd4>)
 8027f3e:	429c      	cmp	r4, r3
 8027f40:	d101      	bne.n	8027f46 <__swsetup_r+0x46>
 8027f42:	68ac      	ldr	r4, [r5, #8]
 8027f44:	e7eb      	b.n	8027f1e <__swsetup_r+0x1e>
 8027f46:	4b24      	ldr	r3, [pc, #144]	; (8027fd8 <__swsetup_r+0xd8>)
 8027f48:	429c      	cmp	r4, r3
 8027f4a:	bf08      	it	eq
 8027f4c:	68ec      	ldreq	r4, [r5, #12]
 8027f4e:	e7e6      	b.n	8027f1e <__swsetup_r+0x1e>
 8027f50:	0751      	lsls	r1, r2, #29
 8027f52:	d512      	bpl.n	8027f7a <__swsetup_r+0x7a>
 8027f54:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8027f56:	b141      	cbz	r1, 8027f6a <__swsetup_r+0x6a>
 8027f58:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8027f5c:	4299      	cmp	r1, r3
 8027f5e:	d002      	beq.n	8027f66 <__swsetup_r+0x66>
 8027f60:	4630      	mov	r0, r6
 8027f62:	f000 f98d 	bl	8028280 <_free_r>
 8027f66:	2300      	movs	r3, #0
 8027f68:	6363      	str	r3, [r4, #52]	; 0x34
 8027f6a:	89a3      	ldrh	r3, [r4, #12]
 8027f6c:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 8027f70:	81a3      	strh	r3, [r4, #12]
 8027f72:	2300      	movs	r3, #0
 8027f74:	6063      	str	r3, [r4, #4]
 8027f76:	6923      	ldr	r3, [r4, #16]
 8027f78:	6023      	str	r3, [r4, #0]
 8027f7a:	89a3      	ldrh	r3, [r4, #12]
 8027f7c:	f043 0308 	orr.w	r3, r3, #8
 8027f80:	81a3      	strh	r3, [r4, #12]
 8027f82:	6923      	ldr	r3, [r4, #16]
 8027f84:	b94b      	cbnz	r3, 8027f9a <__swsetup_r+0x9a>
 8027f86:	89a3      	ldrh	r3, [r4, #12]
 8027f88:	f403 7320 	and.w	r3, r3, #640	; 0x280
 8027f8c:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8027f90:	d003      	beq.n	8027f9a <__swsetup_r+0x9a>
 8027f92:	4621      	mov	r1, r4
 8027f94:	4630      	mov	r0, r6
 8027f96:	f000 f917 	bl	80281c8 <__smakebuf_r>
 8027f9a:	89a2      	ldrh	r2, [r4, #12]
 8027f9c:	f012 0301 	ands.w	r3, r2, #1
 8027fa0:	d00c      	beq.n	8027fbc <__swsetup_r+0xbc>
 8027fa2:	2300      	movs	r3, #0
 8027fa4:	60a3      	str	r3, [r4, #8]
 8027fa6:	6963      	ldr	r3, [r4, #20]
 8027fa8:	425b      	negs	r3, r3
 8027faa:	61a3      	str	r3, [r4, #24]
 8027fac:	6923      	ldr	r3, [r4, #16]
 8027fae:	b953      	cbnz	r3, 8027fc6 <__swsetup_r+0xc6>
 8027fb0:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8027fb4:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8027fb8:	d1ba      	bne.n	8027f30 <__swsetup_r+0x30>
 8027fba:	bd70      	pop	{r4, r5, r6, pc}
 8027fbc:	0792      	lsls	r2, r2, #30
 8027fbe:	bf58      	it	pl
 8027fc0:	6963      	ldrpl	r3, [r4, #20]
 8027fc2:	60a3      	str	r3, [r4, #8]
 8027fc4:	e7f2      	b.n	8027fac <__swsetup_r+0xac>
 8027fc6:	2000      	movs	r0, #0
 8027fc8:	e7f7      	b.n	8027fba <__swsetup_r+0xba>
 8027fca:	bf00      	nop
 8027fcc:	20000c48 	.word	0x20000c48
 8027fd0:	0802b588 	.word	0x0802b588
 8027fd4:	0802b5a8 	.word	0x0802b5a8
 8027fd8:	0802b568 	.word	0x0802b568

08027fdc <_close_r>:
 8027fdc:	b538      	push	{r3, r4, r5, lr}
 8027fde:	4c06      	ldr	r4, [pc, #24]	; (8027ff8 <_close_r+0x1c>)
 8027fe0:	2300      	movs	r3, #0
 8027fe2:	4605      	mov	r5, r0
 8027fe4:	4608      	mov	r0, r1
 8027fe6:	6023      	str	r3, [r4, #0]
 8027fe8:	f7e2 fa3f 	bl	800a46a <_close>
 8027fec:	1c43      	adds	r3, r0, #1
 8027fee:	d102      	bne.n	8027ff6 <_close_r+0x1a>
 8027ff0:	6823      	ldr	r3, [r4, #0]
 8027ff2:	b103      	cbz	r3, 8027ff6 <_close_r+0x1a>
 8027ff4:	602b      	str	r3, [r5, #0]
 8027ff6:	bd38      	pop	{r3, r4, r5, pc}
 8027ff8:	2000dfb0 	.word	0x2000dfb0

08027ffc <__sflush_r>:
 8027ffc:	898a      	ldrh	r2, [r1, #12]
 8027ffe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8028002:	4605      	mov	r5, r0
 8028004:	0710      	lsls	r0, r2, #28
 8028006:	460c      	mov	r4, r1
 8028008:	d458      	bmi.n	80280bc <__sflush_r+0xc0>
 802800a:	684b      	ldr	r3, [r1, #4]
 802800c:	2b00      	cmp	r3, #0
 802800e:	dc05      	bgt.n	802801c <__sflush_r+0x20>
 8028010:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8028012:	2b00      	cmp	r3, #0
 8028014:	dc02      	bgt.n	802801c <__sflush_r+0x20>
 8028016:	2000      	movs	r0, #0
 8028018:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 802801c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802801e:	2e00      	cmp	r6, #0
 8028020:	d0f9      	beq.n	8028016 <__sflush_r+0x1a>
 8028022:	2300      	movs	r3, #0
 8028024:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8028028:	682f      	ldr	r7, [r5, #0]
 802802a:	6a21      	ldr	r1, [r4, #32]
 802802c:	602b      	str	r3, [r5, #0]
 802802e:	d032      	beq.n	8028096 <__sflush_r+0x9a>
 8028030:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8028032:	89a3      	ldrh	r3, [r4, #12]
 8028034:	075a      	lsls	r2, r3, #29
 8028036:	d505      	bpl.n	8028044 <__sflush_r+0x48>
 8028038:	6863      	ldr	r3, [r4, #4]
 802803a:	1ac0      	subs	r0, r0, r3
 802803c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 802803e:	b10b      	cbz	r3, 8028044 <__sflush_r+0x48>
 8028040:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8028042:	1ac0      	subs	r0, r0, r3
 8028044:	2300      	movs	r3, #0
 8028046:	4602      	mov	r2, r0
 8028048:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802804a:	6a21      	ldr	r1, [r4, #32]
 802804c:	4628      	mov	r0, r5
 802804e:	47b0      	blx	r6
 8028050:	1c43      	adds	r3, r0, #1
 8028052:	89a3      	ldrh	r3, [r4, #12]
 8028054:	d106      	bne.n	8028064 <__sflush_r+0x68>
 8028056:	6829      	ldr	r1, [r5, #0]
 8028058:	291d      	cmp	r1, #29
 802805a:	d848      	bhi.n	80280ee <__sflush_r+0xf2>
 802805c:	4a29      	ldr	r2, [pc, #164]	; (8028104 <__sflush_r+0x108>)
 802805e:	40ca      	lsrs	r2, r1
 8028060:	07d6      	lsls	r6, r2, #31
 8028062:	d544      	bpl.n	80280ee <__sflush_r+0xf2>
 8028064:	2200      	movs	r2, #0
 8028066:	6062      	str	r2, [r4, #4]
 8028068:	04d9      	lsls	r1, r3, #19
 802806a:	6922      	ldr	r2, [r4, #16]
 802806c:	6022      	str	r2, [r4, #0]
 802806e:	d504      	bpl.n	802807a <__sflush_r+0x7e>
 8028070:	1c42      	adds	r2, r0, #1
 8028072:	d101      	bne.n	8028078 <__sflush_r+0x7c>
 8028074:	682b      	ldr	r3, [r5, #0]
 8028076:	b903      	cbnz	r3, 802807a <__sflush_r+0x7e>
 8028078:	6560      	str	r0, [r4, #84]	; 0x54
 802807a:	6b61      	ldr	r1, [r4, #52]	; 0x34
 802807c:	602f      	str	r7, [r5, #0]
 802807e:	2900      	cmp	r1, #0
 8028080:	d0c9      	beq.n	8028016 <__sflush_r+0x1a>
 8028082:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8028086:	4299      	cmp	r1, r3
 8028088:	d002      	beq.n	8028090 <__sflush_r+0x94>
 802808a:	4628      	mov	r0, r5
 802808c:	f000 f8f8 	bl	8028280 <_free_r>
 8028090:	2000      	movs	r0, #0
 8028092:	6360      	str	r0, [r4, #52]	; 0x34
 8028094:	e7c0      	b.n	8028018 <__sflush_r+0x1c>
 8028096:	2301      	movs	r3, #1
 8028098:	4628      	mov	r0, r5
 802809a:	47b0      	blx	r6
 802809c:	1c41      	adds	r1, r0, #1
 802809e:	d1c8      	bne.n	8028032 <__sflush_r+0x36>
 80280a0:	682b      	ldr	r3, [r5, #0]
 80280a2:	2b00      	cmp	r3, #0
 80280a4:	d0c5      	beq.n	8028032 <__sflush_r+0x36>
 80280a6:	2b1d      	cmp	r3, #29
 80280a8:	d001      	beq.n	80280ae <__sflush_r+0xb2>
 80280aa:	2b16      	cmp	r3, #22
 80280ac:	d101      	bne.n	80280b2 <__sflush_r+0xb6>
 80280ae:	602f      	str	r7, [r5, #0]
 80280b0:	e7b1      	b.n	8028016 <__sflush_r+0x1a>
 80280b2:	89a3      	ldrh	r3, [r4, #12]
 80280b4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80280b8:	81a3      	strh	r3, [r4, #12]
 80280ba:	e7ad      	b.n	8028018 <__sflush_r+0x1c>
 80280bc:	690f      	ldr	r7, [r1, #16]
 80280be:	2f00      	cmp	r7, #0
 80280c0:	d0a9      	beq.n	8028016 <__sflush_r+0x1a>
 80280c2:	0793      	lsls	r3, r2, #30
 80280c4:	680e      	ldr	r6, [r1, #0]
 80280c6:	bf08      	it	eq
 80280c8:	694b      	ldreq	r3, [r1, #20]
 80280ca:	600f      	str	r7, [r1, #0]
 80280cc:	bf18      	it	ne
 80280ce:	2300      	movne	r3, #0
 80280d0:	eba6 0807 	sub.w	r8, r6, r7
 80280d4:	608b      	str	r3, [r1, #8]
 80280d6:	f1b8 0f00 	cmp.w	r8, #0
 80280da:	dd9c      	ble.n	8028016 <__sflush_r+0x1a>
 80280dc:	4643      	mov	r3, r8
 80280de:	463a      	mov	r2, r7
 80280e0:	6a21      	ldr	r1, [r4, #32]
 80280e2:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 80280e4:	4628      	mov	r0, r5
 80280e6:	47b0      	blx	r6
 80280e8:	2800      	cmp	r0, #0
 80280ea:	dc06      	bgt.n	80280fa <__sflush_r+0xfe>
 80280ec:	89a3      	ldrh	r3, [r4, #12]
 80280ee:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80280f2:	81a3      	strh	r3, [r4, #12]
 80280f4:	f04f 30ff 	mov.w	r0, #4294967295
 80280f8:	e78e      	b.n	8028018 <__sflush_r+0x1c>
 80280fa:	4407      	add	r7, r0
 80280fc:	eba8 0800 	sub.w	r8, r8, r0
 8028100:	e7e9      	b.n	80280d6 <__sflush_r+0xda>
 8028102:	bf00      	nop
 8028104:	20400001 	.word	0x20400001

08028108 <_fflush_r>:
 8028108:	b538      	push	{r3, r4, r5, lr}
 802810a:	690b      	ldr	r3, [r1, #16]
 802810c:	4605      	mov	r5, r0
 802810e:	460c      	mov	r4, r1
 8028110:	b1db      	cbz	r3, 802814a <_fflush_r+0x42>
 8028112:	b118      	cbz	r0, 802811c <_fflush_r+0x14>
 8028114:	6983      	ldr	r3, [r0, #24]
 8028116:	b90b      	cbnz	r3, 802811c <_fflush_r+0x14>
 8028118:	f7ff f93c 	bl	8027394 <__sinit>
 802811c:	4b0c      	ldr	r3, [pc, #48]	; (8028150 <_fflush_r+0x48>)
 802811e:	429c      	cmp	r4, r3
 8028120:	d109      	bne.n	8028136 <_fflush_r+0x2e>
 8028122:	686c      	ldr	r4, [r5, #4]
 8028124:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8028128:	b17b      	cbz	r3, 802814a <_fflush_r+0x42>
 802812a:	4621      	mov	r1, r4
 802812c:	4628      	mov	r0, r5
 802812e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8028132:	f7ff bf63 	b.w	8027ffc <__sflush_r>
 8028136:	4b07      	ldr	r3, [pc, #28]	; (8028154 <_fflush_r+0x4c>)
 8028138:	429c      	cmp	r4, r3
 802813a:	d101      	bne.n	8028140 <_fflush_r+0x38>
 802813c:	68ac      	ldr	r4, [r5, #8]
 802813e:	e7f1      	b.n	8028124 <_fflush_r+0x1c>
 8028140:	4b05      	ldr	r3, [pc, #20]	; (8028158 <_fflush_r+0x50>)
 8028142:	429c      	cmp	r4, r3
 8028144:	bf08      	it	eq
 8028146:	68ec      	ldreq	r4, [r5, #12]
 8028148:	e7ec      	b.n	8028124 <_fflush_r+0x1c>
 802814a:	2000      	movs	r0, #0
 802814c:	bd38      	pop	{r3, r4, r5, pc}
 802814e:	bf00      	nop
 8028150:	0802b588 	.word	0x0802b588
 8028154:	0802b5a8 	.word	0x0802b5a8
 8028158:	0802b568 	.word	0x0802b568

0802815c <_lseek_r>:
 802815c:	b538      	push	{r3, r4, r5, lr}
 802815e:	4c07      	ldr	r4, [pc, #28]	; (802817c <_lseek_r+0x20>)
 8028160:	4605      	mov	r5, r0
 8028162:	4608      	mov	r0, r1
 8028164:	4611      	mov	r1, r2
 8028166:	2200      	movs	r2, #0
 8028168:	6022      	str	r2, [r4, #0]
 802816a:	461a      	mov	r2, r3
 802816c:	f7e2 f9a4 	bl	800a4b8 <_lseek>
 8028170:	1c43      	adds	r3, r0, #1
 8028172:	d102      	bne.n	802817a <_lseek_r+0x1e>
 8028174:	6823      	ldr	r3, [r4, #0]
 8028176:	b103      	cbz	r3, 802817a <_lseek_r+0x1e>
 8028178:	602b      	str	r3, [r5, #0]
 802817a:	bd38      	pop	{r3, r4, r5, pc}
 802817c:	2000dfb0 	.word	0x2000dfb0

08028180 <__swhatbuf_r>:
 8028180:	b570      	push	{r4, r5, r6, lr}
 8028182:	460e      	mov	r6, r1
 8028184:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8028188:	2900      	cmp	r1, #0
 802818a:	b096      	sub	sp, #88	; 0x58
 802818c:	4614      	mov	r4, r2
 802818e:	461d      	mov	r5, r3
 8028190:	da07      	bge.n	80281a2 <__swhatbuf_r+0x22>
 8028192:	2300      	movs	r3, #0
 8028194:	602b      	str	r3, [r5, #0]
 8028196:	89b3      	ldrh	r3, [r6, #12]
 8028198:	061a      	lsls	r2, r3, #24
 802819a:	d410      	bmi.n	80281be <__swhatbuf_r+0x3e>
 802819c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80281a0:	e00e      	b.n	80281c0 <__swhatbuf_r+0x40>
 80281a2:	466a      	mov	r2, sp
 80281a4:	f000 f8f2 	bl	802838c <_fstat_r>
 80281a8:	2800      	cmp	r0, #0
 80281aa:	dbf2      	blt.n	8028192 <__swhatbuf_r+0x12>
 80281ac:	9a01      	ldr	r2, [sp, #4]
 80281ae:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 80281b2:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 80281b6:	425a      	negs	r2, r3
 80281b8:	415a      	adcs	r2, r3
 80281ba:	602a      	str	r2, [r5, #0]
 80281bc:	e7ee      	b.n	802819c <__swhatbuf_r+0x1c>
 80281be:	2340      	movs	r3, #64	; 0x40
 80281c0:	2000      	movs	r0, #0
 80281c2:	6023      	str	r3, [r4, #0]
 80281c4:	b016      	add	sp, #88	; 0x58
 80281c6:	bd70      	pop	{r4, r5, r6, pc}

080281c8 <__smakebuf_r>:
 80281c8:	898b      	ldrh	r3, [r1, #12]
 80281ca:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80281cc:	079d      	lsls	r5, r3, #30
 80281ce:	4606      	mov	r6, r0
 80281d0:	460c      	mov	r4, r1
 80281d2:	d507      	bpl.n	80281e4 <__smakebuf_r+0x1c>
 80281d4:	f104 0347 	add.w	r3, r4, #71	; 0x47
 80281d8:	6023      	str	r3, [r4, #0]
 80281da:	6123      	str	r3, [r4, #16]
 80281dc:	2301      	movs	r3, #1
 80281de:	6163      	str	r3, [r4, #20]
 80281e0:	b002      	add	sp, #8
 80281e2:	bd70      	pop	{r4, r5, r6, pc}
 80281e4:	ab01      	add	r3, sp, #4
 80281e6:	466a      	mov	r2, sp
 80281e8:	f7ff ffca 	bl	8028180 <__swhatbuf_r>
 80281ec:	9900      	ldr	r1, [sp, #0]
 80281ee:	4605      	mov	r5, r0
 80281f0:	4630      	mov	r0, r6
 80281f2:	f7ff f959 	bl	80274a8 <_malloc_r>
 80281f6:	b948      	cbnz	r0, 802820c <__smakebuf_r+0x44>
 80281f8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 80281fc:	059a      	lsls	r2, r3, #22
 80281fe:	d4ef      	bmi.n	80281e0 <__smakebuf_r+0x18>
 8028200:	f023 0303 	bic.w	r3, r3, #3
 8028204:	f043 0302 	orr.w	r3, r3, #2
 8028208:	81a3      	strh	r3, [r4, #12]
 802820a:	e7e3      	b.n	80281d4 <__smakebuf_r+0xc>
 802820c:	4b0d      	ldr	r3, [pc, #52]	; (8028244 <__smakebuf_r+0x7c>)
 802820e:	62b3      	str	r3, [r6, #40]	; 0x28
 8028210:	89a3      	ldrh	r3, [r4, #12]
 8028212:	6020      	str	r0, [r4, #0]
 8028214:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8028218:	81a3      	strh	r3, [r4, #12]
 802821a:	9b00      	ldr	r3, [sp, #0]
 802821c:	6163      	str	r3, [r4, #20]
 802821e:	9b01      	ldr	r3, [sp, #4]
 8028220:	6120      	str	r0, [r4, #16]
 8028222:	b15b      	cbz	r3, 802823c <__smakebuf_r+0x74>
 8028224:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8028228:	4630      	mov	r0, r6
 802822a:	f000 f8c1 	bl	80283b0 <_isatty_r>
 802822e:	b128      	cbz	r0, 802823c <__smakebuf_r+0x74>
 8028230:	89a3      	ldrh	r3, [r4, #12]
 8028232:	f023 0303 	bic.w	r3, r3, #3
 8028236:	f043 0301 	orr.w	r3, r3, #1
 802823a:	81a3      	strh	r3, [r4, #12]
 802823c:	89a3      	ldrh	r3, [r4, #12]
 802823e:	431d      	orrs	r5, r3
 8028240:	81a5      	strh	r5, [r4, #12]
 8028242:	e7cd      	b.n	80281e0 <__smakebuf_r+0x18>
 8028244:	0802735d 	.word	0x0802735d

08028248 <memmove>:
 8028248:	4288      	cmp	r0, r1
 802824a:	b510      	push	{r4, lr}
 802824c:	eb01 0302 	add.w	r3, r1, r2
 8028250:	d807      	bhi.n	8028262 <memmove+0x1a>
 8028252:	1e42      	subs	r2, r0, #1
 8028254:	4299      	cmp	r1, r3
 8028256:	d00a      	beq.n	802826e <memmove+0x26>
 8028258:	f811 4b01 	ldrb.w	r4, [r1], #1
 802825c:	f802 4f01 	strb.w	r4, [r2, #1]!
 8028260:	e7f8      	b.n	8028254 <memmove+0xc>
 8028262:	4283      	cmp	r3, r0
 8028264:	d9f5      	bls.n	8028252 <memmove+0xa>
 8028266:	1881      	adds	r1, r0, r2
 8028268:	1ad2      	subs	r2, r2, r3
 802826a:	42d3      	cmn	r3, r2
 802826c:	d100      	bne.n	8028270 <memmove+0x28>
 802826e:	bd10      	pop	{r4, pc}
 8028270:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8028274:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8028278:	e7f7      	b.n	802826a <memmove+0x22>

0802827a <__malloc_lock>:
 802827a:	4770      	bx	lr

0802827c <__malloc_unlock>:
 802827c:	4770      	bx	lr
	...

08028280 <_free_r>:
 8028280:	b538      	push	{r3, r4, r5, lr}
 8028282:	4605      	mov	r5, r0
 8028284:	2900      	cmp	r1, #0
 8028286:	d045      	beq.n	8028314 <_free_r+0x94>
 8028288:	f851 3c04 	ldr.w	r3, [r1, #-4]
 802828c:	1f0c      	subs	r4, r1, #4
 802828e:	2b00      	cmp	r3, #0
 8028290:	bfb8      	it	lt
 8028292:	18e4      	addlt	r4, r4, r3
 8028294:	f7ff fff1 	bl	802827a <__malloc_lock>
 8028298:	4a1f      	ldr	r2, [pc, #124]	; (8028318 <_free_r+0x98>)
 802829a:	6813      	ldr	r3, [r2, #0]
 802829c:	4610      	mov	r0, r2
 802829e:	b933      	cbnz	r3, 80282ae <_free_r+0x2e>
 80282a0:	6063      	str	r3, [r4, #4]
 80282a2:	6014      	str	r4, [r2, #0]
 80282a4:	4628      	mov	r0, r5
 80282a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80282aa:	f7ff bfe7 	b.w	802827c <__malloc_unlock>
 80282ae:	42a3      	cmp	r3, r4
 80282b0:	d90c      	bls.n	80282cc <_free_r+0x4c>
 80282b2:	6821      	ldr	r1, [r4, #0]
 80282b4:	1862      	adds	r2, r4, r1
 80282b6:	4293      	cmp	r3, r2
 80282b8:	bf04      	itt	eq
 80282ba:	681a      	ldreq	r2, [r3, #0]
 80282bc:	685b      	ldreq	r3, [r3, #4]
 80282be:	6063      	str	r3, [r4, #4]
 80282c0:	bf04      	itt	eq
 80282c2:	1852      	addeq	r2, r2, r1
 80282c4:	6022      	streq	r2, [r4, #0]
 80282c6:	6004      	str	r4, [r0, #0]
 80282c8:	e7ec      	b.n	80282a4 <_free_r+0x24>
 80282ca:	4613      	mov	r3, r2
 80282cc:	685a      	ldr	r2, [r3, #4]
 80282ce:	b10a      	cbz	r2, 80282d4 <_free_r+0x54>
 80282d0:	42a2      	cmp	r2, r4
 80282d2:	d9fa      	bls.n	80282ca <_free_r+0x4a>
 80282d4:	6819      	ldr	r1, [r3, #0]
 80282d6:	1858      	adds	r0, r3, r1
 80282d8:	42a0      	cmp	r0, r4
 80282da:	d10b      	bne.n	80282f4 <_free_r+0x74>
 80282dc:	6820      	ldr	r0, [r4, #0]
 80282de:	4401      	add	r1, r0
 80282e0:	1858      	adds	r0, r3, r1
 80282e2:	4282      	cmp	r2, r0
 80282e4:	6019      	str	r1, [r3, #0]
 80282e6:	d1dd      	bne.n	80282a4 <_free_r+0x24>
 80282e8:	6810      	ldr	r0, [r2, #0]
 80282ea:	6852      	ldr	r2, [r2, #4]
 80282ec:	605a      	str	r2, [r3, #4]
 80282ee:	4401      	add	r1, r0
 80282f0:	6019      	str	r1, [r3, #0]
 80282f2:	e7d7      	b.n	80282a4 <_free_r+0x24>
 80282f4:	d902      	bls.n	80282fc <_free_r+0x7c>
 80282f6:	230c      	movs	r3, #12
 80282f8:	602b      	str	r3, [r5, #0]
 80282fa:	e7d3      	b.n	80282a4 <_free_r+0x24>
 80282fc:	6820      	ldr	r0, [r4, #0]
 80282fe:	1821      	adds	r1, r4, r0
 8028300:	428a      	cmp	r2, r1
 8028302:	bf04      	itt	eq
 8028304:	6811      	ldreq	r1, [r2, #0]
 8028306:	6852      	ldreq	r2, [r2, #4]
 8028308:	6062      	str	r2, [r4, #4]
 802830a:	bf04      	itt	eq
 802830c:	1809      	addeq	r1, r1, r0
 802830e:	6021      	streq	r1, [r4, #0]
 8028310:	605c      	str	r4, [r3, #4]
 8028312:	e7c7      	b.n	80282a4 <_free_r+0x24>
 8028314:	bd38      	pop	{r3, r4, r5, pc}
 8028316:	bf00      	nop
 8028318:	2000d384 	.word	0x2000d384

0802831c <_realloc_r>:
 802831c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802831e:	4607      	mov	r7, r0
 8028320:	4614      	mov	r4, r2
 8028322:	460e      	mov	r6, r1
 8028324:	b921      	cbnz	r1, 8028330 <_realloc_r+0x14>
 8028326:	4611      	mov	r1, r2
 8028328:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 802832c:	f7ff b8bc 	b.w	80274a8 <_malloc_r>
 8028330:	b922      	cbnz	r2, 802833c <_realloc_r+0x20>
 8028332:	f7ff ffa5 	bl	8028280 <_free_r>
 8028336:	4625      	mov	r5, r4
 8028338:	4628      	mov	r0, r5
 802833a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802833c:	f000 f848 	bl	80283d0 <_malloc_usable_size_r>
 8028340:	42a0      	cmp	r0, r4
 8028342:	d20f      	bcs.n	8028364 <_realloc_r+0x48>
 8028344:	4621      	mov	r1, r4
 8028346:	4638      	mov	r0, r7
 8028348:	f7ff f8ae 	bl	80274a8 <_malloc_r>
 802834c:	4605      	mov	r5, r0
 802834e:	2800      	cmp	r0, #0
 8028350:	d0f2      	beq.n	8028338 <_realloc_r+0x1c>
 8028352:	4631      	mov	r1, r6
 8028354:	4622      	mov	r2, r4
 8028356:	f7fe ff31 	bl	80271bc <memcpy>
 802835a:	4631      	mov	r1, r6
 802835c:	4638      	mov	r0, r7
 802835e:	f7ff ff8f 	bl	8028280 <_free_r>
 8028362:	e7e9      	b.n	8028338 <_realloc_r+0x1c>
 8028364:	4635      	mov	r5, r6
 8028366:	e7e7      	b.n	8028338 <_realloc_r+0x1c>

08028368 <_read_r>:
 8028368:	b538      	push	{r3, r4, r5, lr}
 802836a:	4c07      	ldr	r4, [pc, #28]	; (8028388 <_read_r+0x20>)
 802836c:	4605      	mov	r5, r0
 802836e:	4608      	mov	r0, r1
 8028370:	4611      	mov	r1, r2
 8028372:	2200      	movs	r2, #0
 8028374:	6022      	str	r2, [r4, #0]
 8028376:	461a      	mov	r2, r3
 8028378:	f7e2 f83e 	bl	800a3f8 <_read>
 802837c:	1c43      	adds	r3, r0, #1
 802837e:	d102      	bne.n	8028386 <_read_r+0x1e>
 8028380:	6823      	ldr	r3, [r4, #0]
 8028382:	b103      	cbz	r3, 8028386 <_read_r+0x1e>
 8028384:	602b      	str	r3, [r5, #0]
 8028386:	bd38      	pop	{r3, r4, r5, pc}
 8028388:	2000dfb0 	.word	0x2000dfb0

0802838c <_fstat_r>:
 802838c:	b538      	push	{r3, r4, r5, lr}
 802838e:	4c07      	ldr	r4, [pc, #28]	; (80283ac <_fstat_r+0x20>)
 8028390:	2300      	movs	r3, #0
 8028392:	4605      	mov	r5, r0
 8028394:	4608      	mov	r0, r1
 8028396:	4611      	mov	r1, r2
 8028398:	6023      	str	r3, [r4, #0]
 802839a:	f7e2 f872 	bl	800a482 <_fstat>
 802839e:	1c43      	adds	r3, r0, #1
 80283a0:	d102      	bne.n	80283a8 <_fstat_r+0x1c>
 80283a2:	6823      	ldr	r3, [r4, #0]
 80283a4:	b103      	cbz	r3, 80283a8 <_fstat_r+0x1c>
 80283a6:	602b      	str	r3, [r5, #0]
 80283a8:	bd38      	pop	{r3, r4, r5, pc}
 80283aa:	bf00      	nop
 80283ac:	2000dfb0 	.word	0x2000dfb0

080283b0 <_isatty_r>:
 80283b0:	b538      	push	{r3, r4, r5, lr}
 80283b2:	4c06      	ldr	r4, [pc, #24]	; (80283cc <_isatty_r+0x1c>)
 80283b4:	2300      	movs	r3, #0
 80283b6:	4605      	mov	r5, r0
 80283b8:	4608      	mov	r0, r1
 80283ba:	6023      	str	r3, [r4, #0]
 80283bc:	f7e2 f871 	bl	800a4a2 <_isatty>
 80283c0:	1c43      	adds	r3, r0, #1
 80283c2:	d102      	bne.n	80283ca <_isatty_r+0x1a>
 80283c4:	6823      	ldr	r3, [r4, #0]
 80283c6:	b103      	cbz	r3, 80283ca <_isatty_r+0x1a>
 80283c8:	602b      	str	r3, [r5, #0]
 80283ca:	bd38      	pop	{r3, r4, r5, pc}
 80283cc:	2000dfb0 	.word	0x2000dfb0

080283d0 <_malloc_usable_size_r>:
 80283d0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 80283d4:	1f18      	subs	r0, r3, #4
 80283d6:	2b00      	cmp	r3, #0
 80283d8:	bfbc      	itt	lt
 80283da:	580b      	ldrlt	r3, [r1, r0]
 80283dc:	18c0      	addlt	r0, r0, r3
 80283de:	4770      	bx	lr

080283e0 <_init>:
 80283e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80283e2:	bf00      	nop
 80283e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80283e6:	bc08      	pop	{r3}
 80283e8:	469e      	mov	lr, r3
 80283ea:	4770      	bx	lr

080283ec <_fini>:
 80283ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80283ee:	bf00      	nop
 80283f0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80283f2:	bc08      	pop	{r3}
 80283f4:	469e      	mov	lr, r3
 80283f6:	4770      	bx	lr
